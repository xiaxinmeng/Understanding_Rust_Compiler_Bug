{"sha": "dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZTM1ZTc1YTMwMTI5ZmRjNjFiYjE3OTAyM2E5ZjBkYmRjN2E3OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-07T22:40:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-07T22:40:47Z"}, "message": "Auto merge of #32800 - Manishearth:rollup, r=Manishearth\n\nRollup of 7 pull requests\n\n- Successful merges: #32687, #32729, #32731, #32732, #32734, #32737, #32741\n- Failed merges:", "tree": {"sha": "fb2b3936d3a0aa04dde650139e46f46133e99cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb2b3936d3a0aa04dde650139e46f46133e99cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "html_url": "https://github.com/rust-lang/rust/commit/dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "url": "https://api.github.com/repos/rust-lang/rust/commits/7979dd6089ee5cba39cfbe6e880a3edeb7fff788", "html_url": "https://github.com/rust-lang/rust/commit/7979dd6089ee5cba39cfbe6e880a3edeb7fff788"}, {"sha": "1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d59b91ed4ba0e832846c9cbe1188e374e1056f3", "html_url": "https://github.com/rust-lang/rust/commit/1d59b91ed4ba0e832846c9cbe1188e374e1056f3"}], "stats": {"total": 358, "additions": 222, "deletions": 136}, "files": [{"sha": "fdef550a6451aa520079776b0e26d3a58be8314e", "filename": "configure", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/configure", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -717,18 +717,6 @@ if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; f\n \n if [ -n \"$CFG_ENABLE_ORBIT\" ]; then putvar CFG_ENABLE_ORBIT; fi\n \n-# A magic value that allows the compiler to use unstable features\n-# during the bootstrap even when doing so would normally be an error\n-# because of feature staging or because the build turns on\n-# warnings-as-errors and unstable features default to warnings.  The\n-# build has to match this key in an env var. Meant to be a mild\n-# deterrent from users just turning on unstable features on the stable\n-# channel.\n-# Basing CFG_BOOTSTRAP_KEY on CFG_BOOTSTRAP_KEY lets it get picked up\n-# during a Makefile reconfig.\n-CFG_BOOTSTRAP_KEY=\"${CFG_BOOTSTRAP_KEY-`date +%H:%M:%S`}\"\n-putvar CFG_BOOTSTRAP_KEY\n-\n step_msg \"looking for build programs\"\n \n probe_need CFG_CURLORWGET  curl wget"}, {"sha": "9b8080f96610f3d763acab25fe67fdf8ea82dc9c", "filename": "mk/main.mk", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -24,6 +24,17 @@ CFG_PRERELEASE_VERSION=.1\n # versions in the same place\n CFG_FILENAME_EXTRA=$(shell printf '%s' $(CFG_RELEASE)$(CFG_EXTRA_FILENAME) | $(CFG_HASH_COMMAND))\n \n+# A magic value that allows the compiler to use unstable features during the\n+# bootstrap even when doing so would normally be an error because of feature\n+# staging or because the build turns on warnings-as-errors and unstable features\n+# default to warnings. The build has to match this key in an env var.\n+#\n+# This value is keyed off the release to ensure that all compilers for one\n+# particular release have the same bootstrap key. Note that this is\n+# intentionally not \"secure\" by any definition, this is largely just a deterrent\n+# from users enabling unstable features on the stable compiler.\n+CFG_BOOTSTRAP_KEY=$(CFG_FILENAME_EXTRA)\n+\n ifeq ($(CFG_RELEASE_CHANNEL),stable)\n # This is the normal semver version string, e.g. \"0.12.0\", \"0.12.0-nightly\"\n CFG_RELEASE=$(CFG_RELEASE_NUM)"}, {"sha": "8e1da69cf02e752e2a4c5622549092408b37bd70", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -43,10 +43,16 @@ pub fn cc2ar(cc: &Path, target: &str) -> PathBuf {\n     if target.contains(\"musl\") || target.contains(\"msvc\") {\n         PathBuf::from(\"ar\")\n     } else {\n+        let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n-        cc.parent().unwrap().join(file.replace(\"gcc\", \"ar\")\n-                                      .replace(\"cc\", \"ar\")\n-                                      .replace(\"clang\", \"ar\"))\n+        for suffix in &[\"gcc\", \"cc\", \"clang\"] {\n+            if let Some(idx) = file.rfind(suffix) {\n+                let mut file = file[..idx].to_owned();\n+                file.push_str(\"ar\");\n+                return parent.join(&file);\n+            }\n+        }\n+        parent.join(file)\n     }\n }\n "}, {"sha": "4aba567fa1c202215b361bba0db7ea1b6f913124", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -124,9 +124,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: Shared<ArcInner<T>>,\n+    ptr: Shared<ArcInner<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,9 +142,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n #[unsafe_no_drop_flag]\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: Shared<ArcInner<T>>,\n+    ptr: Shared<ArcInner<T>>,\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n@@ -198,7 +194,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data: data,\n         };\n-        Arc { _ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n+        Arc { ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n     }\n \n     /// Unwraps the contained value if the `Arc<T>` has exactly one strong reference.\n@@ -230,11 +226,11 @@ impl<T> Arc<T> {\n         atomic::fence(Acquire);\n \n         unsafe {\n-            let ptr = *this._ptr;\n+            let ptr = *this.ptr;\n             let elem = ptr::read(&(*ptr).data);\n \n             // Make a weak pointer to clean up the implicit strong-weak reference\n-            let _weak = Weak { _ptr: this._ptr };\n+            let _weak = Weak { ptr: this.ptr };\n             mem::forget(this);\n \n             Ok(elem)\n@@ -275,7 +271,7 @@ impl<T: ?Sized> Arc<T> {\n             // synchronize with the write coming from `is_unique`, so that the\n             // events prior to that write happen before this read.\n             match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n-                Ok(_) => return Weak { _ptr: this._ptr },\n+                Ok(_) => return Weak { ptr: this.ptr },\n                 Err(old) => cur = old,\n             }\n         }\n@@ -304,13 +300,13 @@ impl<T: ?Sized> Arc<T> {\n         // `ArcInner` structure itself is `Sync` because the inner data is\n         // `Sync` as well, so we're ok loaning out an immutable pointer to these\n         // contents.\n-        unsafe { &**self._ptr }\n+        unsafe { &**self.ptr }\n     }\n \n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = *self._ptr;\n+        let ptr = *self.ptr;\n \n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n@@ -368,7 +364,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n             }\n         }\n \n-        Arc { _ptr: self._ptr }\n+        Arc { ptr: self.ptr }\n     }\n }\n \n@@ -436,15 +432,15 @@ impl<T: Clone> Arc<T> {\n \n             // Materialize our own implicit weak pointer, so that it can clean\n             // up the ArcInner as needed.\n-            let weak = Weak { _ptr: this._ptr };\n+            let weak = Weak { ptr: this.ptr };\n \n             // mark the data itself as already deallocated\n             unsafe {\n                 // there is no data race in the implicit write caused by `read`\n                 // here (due to zeroing) because data is no longer accessed by\n                 // other threads (due to there being no more strong refs at this\n                 // point).\n-                let mut swap = Arc::new(ptr::read(&(**weak._ptr).data));\n+                let mut swap = Arc::new(ptr::read(&(**weak.ptr).data));\n                 mem::swap(this, &mut swap);\n                 mem::forget(swap);\n             }\n@@ -457,7 +453,7 @@ impl<T: Clone> Arc<T> {\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n         unsafe {\n-            let inner = &mut **this._ptr;\n+            let inner = &mut **this.ptr;\n             &mut inner.data\n         }\n     }\n@@ -489,7 +485,7 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                let inner = &mut **this._ptr;\n+                let inner = &mut **this.ptr;\n                 Some(&mut inner.data)\n             }\n         } else {\n@@ -558,7 +554,7 @@ impl<T: ?Sized> Drop for Arc<T> {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run\n         // more than once (but it is guaranteed to be zeroed after the first if\n         // it's run more than once)\n-        let thin = *self._ptr as *const ();\n+        let thin = *self.ptr as *const ();\n \n         if thin as usize == mem::POST_DROP_USIZE {\n             return;\n@@ -639,7 +635,7 @@ impl<T: ?Sized> Weak<T> {\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n             match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n-                Ok(_) => return Some(Arc { _ptr: self._ptr }),\n+                Ok(_) => return Some(Arc { ptr: self.ptr }),\n                 Err(old) => n = old,\n             }\n         }\n@@ -648,7 +644,7 @@ impl<T: ?Sized> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &**self._ptr }\n+        unsafe { &**self.ptr }\n     }\n }\n \n@@ -682,7 +678,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n             }\n         }\n \n-        return Weak { _ptr: self._ptr };\n+        return Weak { ptr: self.ptr };\n     }\n }\n \n@@ -714,7 +710,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// } // implicit drop\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = *self._ptr;\n+        let ptr = *self.ptr;\n         let thin = ptr as *const ();\n \n         // see comments above for why this check is here\n@@ -886,7 +882,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self._ptr, f)\n+        fmt::Pointer::fmt(&*self.ptr, f)\n     }\n }\n \n@@ -931,7 +927,7 @@ impl<T> Weak<T> {\n                issue = \"30425\")]\n     pub fn new() -> Weak<T> {\n         unsafe {\n-            Weak { _ptr: Shared::new(Box::into_raw(box ArcInner {\n+            Weak { ptr: Shared::new(Box::into_raw(box ArcInner {\n                 strong: atomic::AtomicUsize::new(0),\n                 weak: atomic::AtomicUsize::new(1),\n                 data: uninitialized(),"}, {"sha": "c2f0a96132733221514a09f067ad59e8b4aca1a8", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -184,9 +184,7 @@ struct RcBox<T: ?Sized> {\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n-    // FIXME #12808: strange names to try to avoid interfering with field\n-    // accesses of the contained type via Deref\n-    _ptr: Shared<RcBox<T>>,\n+    ptr: Shared<RcBox<T>>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -215,7 +213,7 @@ impl<T> Rc<T> {\n                 // pointers, which ensures that the weak destructor never frees\n                 // the allocation while the strong destructor is running, even\n                 // if the weak pointer is stored inside the strong one.\n-                _ptr: Shared::new(Box::into_raw(box RcBox {\n+                ptr: Shared::new(Box::into_raw(box RcBox {\n                     strong: Cell::new(1),\n                     weak: Cell::new(1),\n                     value: value,\n@@ -254,7 +252,7 @@ impl<T> Rc<T> {\n                 // pointer while also handling drop logic by just crafting a\n                 // fake Weak.\n                 this.dec_strong();\n-                let _weak = Weak { _ptr: this._ptr };\n+                let _weak = Weak { ptr: this.ptr };\n                 forget(this);\n                 Ok(val)\n             }\n@@ -287,7 +285,7 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn downgrade(this: &Self) -> Weak<T> {\n         this.inc_weak();\n-        Weak { _ptr: this._ptr }\n+        Weak { ptr: this.ptr }\n     }\n \n     /// Get the number of weak references to this value.\n@@ -348,7 +346,7 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n-            let inner = unsafe { &mut **this._ptr };\n+            let inner = unsafe { &mut **this.ptr };\n             Some(&mut inner.value)\n         } else {\n             None\n@@ -390,7 +388,7 @@ impl<T: Clone> Rc<T> {\n         } else if Rc::weak_count(this) != 0 {\n             // Can just steal the data, all that's left is Weaks\n             unsafe {\n-                let mut swap = Rc::new(ptr::read(&(**this._ptr).value));\n+                let mut swap = Rc::new(ptr::read(&(**this.ptr).value));\n                 mem::swap(this, &mut swap);\n                 swap.dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n@@ -404,7 +402,7 @@ impl<T: Clone> Rc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut **this._ptr };\n+        let inner = unsafe { &mut **this.ptr };\n         &mut inner.value\n     }\n }\n@@ -449,7 +447,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self._ptr;\n+            let ptr = *self.ptr;\n             let thin = ptr as *const ();\n \n             if thin as usize != mem::POST_DROP_USIZE {\n@@ -490,7 +488,7 @@ impl<T: ?Sized> Clone for Rc<T> {\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n-        Rc { _ptr: self._ptr }\n+        Rc { ptr: self.ptr }\n     }\n }\n \n@@ -691,7 +689,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self._ptr, f)\n+        fmt::Pointer::fmt(&*self.ptr, f)\n     }\n }\n \n@@ -711,9 +709,7 @@ impl<T> From<T> for Rc<T> {\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: Shared<RcBox<T>>,\n+    ptr: Shared<RcBox<T>>,\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -749,7 +745,7 @@ impl<T: ?Sized> Weak<T> {\n             None\n         } else {\n             self.inc_strong();\n-            Some(Rc { _ptr: self._ptr })\n+            Some(Rc { ptr: self.ptr })\n         }\n     }\n }\n@@ -783,7 +779,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self._ptr;\n+            let ptr = *self.ptr;\n             let thin = ptr as *const ();\n \n             if thin as usize != mem::POST_DROP_USIZE {\n@@ -816,7 +812,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();\n-        Weak { _ptr: self._ptr }\n+        Weak { ptr: self.ptr }\n     }\n }\n \n@@ -848,7 +844,7 @@ impl<T> Weak<T> {\n     pub fn new() -> Weak<T> {\n         unsafe {\n             Weak {\n-                _ptr: Shared::new(Box::into_raw(box RcBox {\n+                ptr: Shared::new(Box::into_raw(box RcBox {\n                     strong: Cell::new(0),\n                     weak: Cell::new(1),\n                     value: uninitialized(),\n@@ -910,8 +906,8 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n+            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n+            &(**self.ptr)\n         }\n     }\n }\n@@ -924,8 +920,8 @@ impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n             // the contract anyway.\n             // This allows the null check to be elided in the destructor if we\n             // manipulated the reference count in the same function.\n-            assume(!(*(&self._ptr as *const _ as *const *const ())).is_null());\n-            &(**self._ptr)\n+            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n+            &(**self.ptr)\n         }\n     }\n }"}, {"sha": "a1c7a293af0b3d759a8b828c1a74b0e0a3ee81c7", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -390,8 +390,8 @@ impl<T: ?Sized> RefCell<T> {\n     pub fn borrow(&self) -> Ref<T> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Ref {\n-                _value: unsafe { &*self.value.get() },\n-                _borrow: b,\n+                value: unsafe { &*self.value.get() },\n+                borrow: b,\n             },\n             None => panic!(\"RefCell<T> already mutably borrowed\"),\n         }\n@@ -438,8 +438,8 @@ impl<T: ?Sized> RefCell<T> {\n     pub fn borrow_mut(&self) -> RefMut<T> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => RefMut {\n-                _value: unsafe { &mut *self.value.get() },\n-                _borrow: b,\n+                value: unsafe { &mut *self.value.get() },\n+                borrow: b,\n             },\n             None => panic!(\"RefCell<T> already borrowed\"),\n         }\n@@ -491,7 +491,7 @@ impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n impl<T: ?Sized + Eq> Eq for RefCell<T> {}\n \n struct BorrowRef<'b> {\n-    _borrow: &'b Cell<BorrowFlag>,\n+    borrow: &'b Cell<BorrowFlag>,\n }\n \n impl<'b> BorrowRef<'b> {\n@@ -501,7 +501,7 @@ impl<'b> BorrowRef<'b> {\n             WRITING => None,\n             b => {\n                 borrow.set(b + 1);\n-                Some(BorrowRef { _borrow: borrow })\n+                Some(BorrowRef { borrow: borrow })\n             },\n         }\n     }\n@@ -510,9 +510,9 @@ impl<'b> BorrowRef<'b> {\n impl<'b> Drop for BorrowRef<'b> {\n     #[inline]\n     fn drop(&mut self) {\n-        let borrow = self._borrow.get();\n+        let borrow = self.borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n-        self._borrow.set(borrow - 1);\n+        self.borrow.set(borrow - 1);\n     }\n }\n \n@@ -521,10 +521,10 @@ impl<'b> Clone for BorrowRef<'b> {\n     fn clone(&self) -> BorrowRef<'b> {\n         // Since this Ref exists, we know the borrow flag\n         // is not set to WRITING.\n-        let borrow = self._borrow.get();\n+        let borrow = self.borrow.get();\n         debug_assert!(borrow != WRITING && borrow != UNUSED);\n-        self._borrow.set(borrow + 1);\n-        BorrowRef { _borrow: self._borrow }\n+        self.borrow.set(borrow + 1);\n+        BorrowRef { borrow: self.borrow }\n     }\n }\n \n@@ -534,10 +534,8 @@ impl<'b> Clone for BorrowRef<'b> {\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T: ?Sized + 'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _value: &'b T,\n-    _borrow: BorrowRef<'b>,\n+    value: &'b T,\n+    borrow: BorrowRef<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -546,7 +544,7 @@ impl<'b, T: ?Sized> Deref for Ref<'b, T> {\n \n     #[inline]\n     fn deref(&self) -> &T {\n-        self._value\n+        self.value\n     }\n }\n \n@@ -565,8 +563,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     #[inline]\n     pub fn clone(orig: &Ref<'b, T>) -> Ref<'b, T> {\n         Ref {\n-            _value: orig._value,\n-            _borrow: orig._borrow.clone(),\n+            value: orig.value,\n+            borrow: orig.borrow.clone(),\n         }\n     }\n \n@@ -594,8 +592,8 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         where F: FnOnce(&T) -> &U\n     {\n         Ref {\n-            _value: f(orig._value),\n-            _borrow: orig._borrow,\n+            value: f(orig.value),\n+            borrow: orig.borrow,\n         }\n     }\n \n@@ -627,9 +625,9 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     pub fn filter_map<U: ?Sized, F>(orig: Ref<'b, T>, f: F) -> Option<Ref<'b, U>>\n         where F: FnOnce(&T) -> Option<&U>\n     {\n-        f(orig._value).map(move |new| Ref {\n-            _value: new,\n-            _borrow: orig._borrow,\n+        f(orig.value).map(move |new| Ref {\n+            value: new,\n+            borrow: orig.borrow,\n         })\n     }\n }\n@@ -667,8 +665,8 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         where F: FnOnce(&mut T) -> &mut U\n     {\n         RefMut {\n-            _value: f(orig._value),\n-            _borrow: orig._borrow,\n+            value: f(orig.value),\n+            borrow: orig.borrow,\n         }\n     }\n \n@@ -706,24 +704,24 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     pub fn filter_map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> Option<RefMut<'b, U>>\n         where F: FnOnce(&mut T) -> Option<&mut U>\n     {\n-        let RefMut { _value, _borrow } = orig;\n-        f(_value).map(move |new| RefMut {\n-            _value: new,\n-            _borrow: _borrow,\n+        let RefMut { value, borrow } = orig;\n+        f(value).map(move |new| RefMut {\n+            value: new,\n+            borrow: borrow,\n         })\n     }\n }\n \n struct BorrowRefMut<'b> {\n-    _borrow: &'b Cell<BorrowFlag>,\n+    borrow: &'b Cell<BorrowFlag>,\n }\n \n impl<'b> Drop for BorrowRefMut<'b> {\n     #[inline]\n     fn drop(&mut self) {\n-        let borrow = self._borrow.get();\n+        let borrow = self.borrow.get();\n         debug_assert!(borrow == WRITING);\n-        self._borrow.set(UNUSED);\n+        self.borrow.set(UNUSED);\n     }\n }\n \n@@ -733,7 +731,7 @@ impl<'b> BorrowRefMut<'b> {\n         match borrow.get() {\n             UNUSED => {\n                 borrow.set(WRITING);\n-                Some(BorrowRefMut { _borrow: borrow })\n+                Some(BorrowRefMut { borrow: borrow })\n             },\n             _ => None,\n         }\n@@ -745,10 +743,8 @@ impl<'b> BorrowRefMut<'b> {\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T: ?Sized + 'b> {\n-    // FIXME #12808: strange name to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _value: &'b mut T,\n-    _borrow: BorrowRefMut<'b>,\n+    value: &'b mut T,\n+    borrow: BorrowRefMut<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -757,15 +753,15 @@ impl<'b, T: ?Sized> Deref for RefMut<'b, T> {\n \n     #[inline]\n     fn deref(&self) -> &T {\n-        self._value\n+        self.value\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut(&mut self) -> &mut T {\n-        self._value\n+        self.value\n     }\n }\n "}, {"sha": "cb29f27b83fd7a15ac173be75be667ff9c3a4e96", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -80,6 +80,8 @@ pub struct ArgType {\n     /// Only later will `original_ty` aka `%Foo` be used in the LLVM function\n     /// pointer type, without ever having introspected it.\n     pub ty: Type,\n+    /// Signedness for integer types, None for other types\n+    pub signedness: Option<bool>,\n     /// Coerced LLVM Type\n     pub cast: Option<Type>,\n     /// Dummy argument, which is emitted before the real argument\n@@ -94,6 +96,7 @@ impl ArgType {\n             kind: ArgKind::Direct,\n             original_ty: original_ty,\n             ty: ty,\n+            signedness: None,\n             cast: None,\n             pad: None,\n             attrs: llvm::Attributes::default()\n@@ -123,6 +126,19 @@ impl ArgType {\n         self.kind = ArgKind::Ignore;\n     }\n \n+    pub fn extend_integer_width_to(&mut self, bits: u64) {\n+        // Only integers have signedness\n+        if let Some(signed) = self.signedness {\n+            if self.ty.int_width() < bits {\n+                self.attrs.set(if signed {\n+                    llvm::Attribute::SExt\n+                } else {\n+                    llvm::Attribute::ZExt\n+                });\n+            }\n+        }\n+    }\n+\n     pub fn is_indirect(&self) -> bool {\n         self.kind == ArgKind::Indirect\n     }\n@@ -268,6 +284,9 @@ impl FnType {\n             } else {\n                 let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n                                            type_of::sizing_type_of(ccx, ty));\n+                if ty.is_integral() {\n+                    arg.signedness = Some(ty.is_signed());\n+                }\n                 if llsize_of_real(ccx, arg.ty) == 0 {\n                     // For some forsaken reason, x86_64-pc-windows-gnu\n                     // doesn't ignore zero-sized struct arguments."}, {"sha": "fc11e3888d3c2e6cfcf72d42e3384ff25d11c39e", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -163,6 +163,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n     if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n         return;\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n@@ -190,6 +191,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if is_reg_ty(arg.ty) {\n+        arg.extend_integer_width_to(32);\n         return;\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {"}, {"sha": "68a2e8aa8ce95d8c38bfd91ad30db2cc08927a39", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -131,6 +131,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n     if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n         return;\n     }\n     let size = ty_size(ret.ty, align_fn);\n@@ -150,6 +151,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, align_fn: TyAlignFn) {\n     if is_reg_ty(arg.ty) {\n+        arg.extend_integer_width_to(32);\n         return;\n     }\n     let align = align_fn(arg.ty);"}, {"sha": "680310e195a41536d18554af0a994b095f79951d", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -86,6 +86,14 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n+    } else {\n+        ret.make_indirect(ccx);\n+    }\n+}\n+\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n     let size = ty_size(arg.ty) * 8;\n@@ -98,6 +106,8 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     if !is_reg_ty(arg.ty) {\n         arg.cast = Some(struct_ty(ccx, arg.ty));\n         arg.pad = padding_ty(ccx, align, orig_offset);\n+    } else {\n+        arg.extend_integer_width_to(32);\n     }\n }\n \n@@ -146,8 +156,8 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n-        fty.ret.make_indirect(ccx);\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };"}, {"sha": "efbdce67a8b2ad911cd837b3d016a20be58cce46", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -82,6 +82,14 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(32);\n+    } else {\n+        ret.make_indirect(ccx);\n+    }\n+}\n+\n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     let orig_offset = *offset;\n     let size = ty_size(arg.ty) * 8;\n@@ -94,6 +102,8 @@ fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n     if !is_reg_ty(arg.ty) {\n         arg.cast = Some(struct_ty(ccx, arg.ty));\n         arg.pad = padding_ty(ccx, align, orig_offset);\n+    } else {\n+        arg.extend_integer_width_to(32);\n     }\n }\n \n@@ -141,8 +151,8 @@ fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n }\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if !fty.ret.is_ignore() && !is_reg_ty(fty.ret.ty) {\n-        fty.ret.make_indirect(ccx);\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     let mut offset = if fty.ret.is_indirect() { 4 } else { 0 };"}, {"sha": "ba54e369fd8382779b9ee6bfd567ccc82b4d2834", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -153,6 +153,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n     if is_reg_ty(ret.ty) {\n+        ret.extend_integer_width_to(64);\n         return;\n     }\n \n@@ -187,6 +188,7 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n     if is_reg_ty(arg.ty) {\n+        arg.extend_integer_width_to(64);\n         return;\n     }\n "}, {"sha": "b52231fa6b432f8aaca36d346d29368f2ea024c4", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -15,25 +15,29 @@ use super::common::*;\n use super::machine::*;\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    if !fty.ret.is_ignore() && fty.ret.ty.kind() == Struct {\n-        // Returning a structure. Most often, this will use\n-        // a hidden first argument. On some platforms, though,\n-        // small structs are returned as integers.\n-        //\n-        // Some links:\n-        // http://www.angelcode.com/dev/callconv/callconv.html\n-        // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n-        let t = &ccx.sess().target.target;\n-        if t.options.is_like_osx || t.options.is_like_windows {\n-            match llsize_of_alloc(ccx, fty.ret.ty) {\n-                1 => fty.ret.cast = Some(Type::i8(ccx)),\n-                2 => fty.ret.cast = Some(Type::i16(ccx)),\n-                4 => fty.ret.cast = Some(Type::i32(ccx)),\n-                8 => fty.ret.cast = Some(Type::i64(ccx)),\n-                _ => fty.ret.make_indirect(ccx)\n+    if !fty.ret.is_ignore() {\n+        if fty.ret.ty.kind() == Struct {\n+            // Returning a structure. Most often, this will use\n+            // a hidden first argument. On some platforms, though,\n+            // small structs are returned as integers.\n+            //\n+            // Some links:\n+            // http://www.angelcode.com/dev/callconv/callconv.html\n+            // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n+            let t = &ccx.sess().target.target;\n+            if t.options.is_like_osx || t.options.is_like_windows {\n+                match llsize_of_alloc(ccx, fty.ret.ty) {\n+                    1 => fty.ret.cast = Some(Type::i8(ccx)),\n+                    2 => fty.ret.cast = Some(Type::i16(ccx)),\n+                    4 => fty.ret.cast = Some(Type::i32(ccx)),\n+                    8 => fty.ret.cast = Some(Type::i64(ccx)),\n+                    _ => fty.ret.make_indirect(ccx)\n+                }\n+            } else {\n+                fty.ret.make_indirect(ccx);\n             }\n         } else {\n-            fty.ret.make_indirect(ccx);\n+            fty.ret.extend_integer_width_to(32);\n         }\n     }\n \n@@ -42,6 +46,8 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n         if arg.ty.kind() == Struct {\n             arg.make_indirect(ccx);\n             arg.attrs.set(Attribute::ByVal);\n+        } else {\n+            arg.extend_integer_width_to(32);\n         }\n     }\n }"}, {"sha": "805c7d345a0e72d2de3a47209f325937e74d7c83", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -400,6 +400,8 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n             } else {\n                 arg.cast = Some(llreg_ty(ccx, &cls));\n             }\n+        } else {\n+            arg.extend_integer_width_to(32);\n         }\n     }\n "}, {"sha": "71ecb6e9ca104593024e0b10a04be9874f9c6b73", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -26,6 +26,8 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n                 8 => a.cast = Some(Type::i64(ccx)),\n                 _ => a.make_indirect(ccx)\n             }\n+        } else {\n+            a.extend_integer_width_to(32);\n         }\n     };\n "}, {"sha": "5014186d13b9ce8352bf6859fc4e90e6c57379cb", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -50,7 +50,9 @@ use syntax::{ast, codemap};\n use syntax::parse::token;\n \n \n-const DW_LANG_RUST: c_uint = 0x9000;\n+// From DWARF 5.\n+// See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n+const DW_LANG_RUST: c_uint = 0x1c;\n #[allow(non_upper_case_globals)]\n const DW_ATE_boolean: c_uint = 0x02;\n #[allow(non_upper_case_globals)]"}, {"sha": "db672e5643531181fb59b0759274cc81d74c7e50", "filename": "src/libstd/os/dragonfly/fs.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fos%2Fdragonfly%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fos%2Fdragonfly%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Ffs.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -63,10 +63,6 @@ pub trait MetadataExt {\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime_nsec(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_birthtime(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n-    fn st_birthtime_nsec(&self) -> i64;\n-    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blksize(&self) -> u64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blocks(&self) -> u64;\n@@ -129,12 +125,6 @@ impl MetadataExt for Metadata {\n     fn st_ctime_nsec(&self) -> i64 {\n         self.as_inner().as_inner().st_ctime_nsec as i64\n     }\n-    fn st_birthtime(&self) -> i64 {\n-        self.as_inner().as_inner().st_birthtime as i64\n-    }\n-    fn st_birthtime_nsec(&self) -> i64 {\n-        self.as_inner().as_inner().st_birthtime_nsec as i64\n-    }\n     fn st_blksize(&self) -> u64 {\n         self.as_inner().as_inner().st_blksize as u64\n     }"}, {"sha": "da7a340af351525ac6a766722b9d921b7295d66d", "filename": "src/libstd/sys/common/unwind/gcc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -224,8 +224,13 @@ pub mod eabi {\n         context: *mut uw::_Unwind_Context\n     ) -> uw::_Unwind_Reason_Code\n     {\n+        // Backtraces on ARM will call the personality routine with\n+        // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n+        // we want to continue unwinding the stack, otherwise all our backtraces\n+        // would end at __rust_try.\n         if (state as c_int & uw::_US_ACTION_MASK as c_int)\n-                           == uw::_US_VIRTUAL_UNWIND_FRAME as c_int { // search phase\n+                           == uw::_US_VIRTUAL_UNWIND_FRAME as c_int\n+               && (state as c_int & uw::_US_FORCE_UNWIND as c_int) == 0 { // search phase\n             uw::_URC_HANDLER_FOUND // catch!\n         }\n         else { // cleanup phase"}, {"sha": "94ebbd70ae83deb5c6194460c96aa613ee6997a2", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -36,6 +36,7 @@ const TMPBUF_SZ: usize = 128;\n static ENV_LOCK: StaticMutex = StaticMutex::new();\n \n /// Returns the platform-specific value of errno\n+#[cfg(not(target_os = \"dragonfly\"))]\n pub fn errno() -> i32 {\n     extern {\n         #[cfg_attr(any(target_os = \"linux\", target_os = \"emscripten\"),\n@@ -47,7 +48,6 @@ pub fn errno() -> i32 {\n                        target_env = \"newlib\"),\n                    link_name = \"__errno\")]\n         #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n-        #[cfg_attr(target_os = \"dragonfly\", link_name = \"__dfly_error\")]\n         #[cfg_attr(any(target_os = \"macos\",\n                        target_os = \"ios\",\n                        target_os = \"freebsd\"),\n@@ -60,6 +60,16 @@ pub fn errno() -> i32 {\n     }\n }\n \n+#[cfg(target_os = \"dragonfly\")]\n+pub fn errno() -> i32 {\n+    extern {\n+        #[thread_local]\n+        static errno: c_int;\n+    }\n+\n+    errno as i32\n+}\n+\n /// Gets a detailed string description for the given error number.\n pub fn error_string(errno: i32) -> String {\n     extern {"}, {"sha": "cc7abe25e35e5a1edc902e6608996a8da7344172", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -303,8 +303,13 @@ mod inner {\n         }\n     }\n \n+    #[cfg(not(target_os = \"dragonfly\"))]\n+    pub type clock_t = libc::c_int;\n+    #[cfg(target_os = \"dragonfly\")]\n+    pub type clock_t = libc::c_ulong;\n+\n     impl Timespec {\n-        pub fn now(clock: libc::c_int) -> Timespec {\n+        pub fn now(clock: clock_t) -> Timespec {\n             let mut t = Timespec {\n                 t: libc::timespec {\n                     tv_sec: 0,"}, {"sha": "d2ebdcca80cf0cb6b44a037b1b3c08fa7e1921b7", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -243,3 +243,7 @@ double rust_interesting_average(uint64_t n, ...) {\n     va_end(pairs);\n     return sum / n;\n }\n+\n+int32_t rust_int8_to_int32(int8_t x) {\n+    return (int32_t)x;\n+}"}, {"sha": "c7a227593333524eea1d04c83de7bd97fa3fded3", "filename": "src/test/run-pass/cabi-int-widening.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dde35e75a30129fdc61bb179023a9f0dbdc7a79a/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcabi-int-widening.rs?ref=dde35e75a30129fdc61bb179023a9f0dbdc7a79a", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[link(name = \"rust_test_helpers\")]\n+extern {\n+    fn rust_int8_to_int32(_: i8) -> i32;\n+}\n+\n+fn main() {\n+    let x = unsafe {\n+        rust_int8_to_int32(-1)\n+    };\n+\n+    assert!(x == -1);\n+}"}]}