{"sha": "f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MmI2NTU2MjFkYzBlM2JhOGQyYjM3ZGU5YTY4Zjk2YTY1YWI2NjA=", "commit": {"author": {"name": "Masood Malekghassemi", "email": "atash@google.com", "date": "2016-05-12T00:22:13Z"}, "committer": {"name": "Masood Malekghassemi", "email": "atash@google.com", "date": "2016-05-12T00:29:23Z"}, "message": "Plumb inference obligations through selection", "tree": {"sha": "c6c2cf6d4d51db694aa5a13a01ecd381852c0dab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6c2cf6d4d51db694aa5a13a01ecd381852c0dab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "html_url": "https://github.com/rust-lang/rust/commit/f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f52b655621dc0e3ba8d2b37de9a68f96a65ab660/comments", "author": {"login": "soltanmm-google", "id": 21180148, "node_id": "MDQ6VXNlcjIxMTgwMTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/21180148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soltanmm-google", "html_url": "https://github.com/soltanmm-google", "followers_url": "https://api.github.com/users/soltanmm-google/followers", "following_url": "https://api.github.com/users/soltanmm-google/following{/other_user}", "gists_url": "https://api.github.com/users/soltanmm-google/gists{/gist_id}", "starred_url": "https://api.github.com/users/soltanmm-google/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soltanmm-google/subscriptions", "organizations_url": "https://api.github.com/users/soltanmm-google/orgs", "repos_url": "https://api.github.com/users/soltanmm-google/repos", "events_url": "https://api.github.com/users/soltanmm-google/events{/privacy}", "received_events_url": "https://api.github.com/users/soltanmm-google/received_events", "type": "User", "site_admin": false}, "committer": {"login": "soltanmm-google", "id": 21180148, "node_id": "MDQ6VXNlcjIxMTgwMTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/21180148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soltanmm-google", "html_url": "https://github.com/soltanmm-google", "followers_url": "https://api.github.com/users/soltanmm-google/followers", "following_url": "https://api.github.com/users/soltanmm-google/following{/other_user}", "gists_url": "https://api.github.com/users/soltanmm-google/gists{/gist_id}", "starred_url": "https://api.github.com/users/soltanmm-google/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soltanmm-google/subscriptions", "organizations_url": "https://api.github.com/users/soltanmm-google/orgs", "repos_url": "https://api.github.com/users/soltanmm-google/repos", "events_url": "https://api.github.com/users/soltanmm-google/events{/privacy}", "received_events_url": "https://api.github.com/users/soltanmm-google/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec7c483d679b70d50690cf477ef00106a5b97fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7c483d679b70d50690cf477ef00106a5b97fc2", "html_url": "https://github.com/rust-lang/rust/commit/ec7c483d679b70d50690cf477ef00106a5b97fc2"}], "stats": {"total": 192, "additions": 126, "deletions": 66}, "files": [{"sha": "65df056fd424b2ae71d1b213230758ca0068eb1f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f52b655621dc0e3ba8d2b37de9a68f96a65ab660/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b655621dc0e3ba8d2b37de9a68f96a65ab660/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "patch": "@@ -582,6 +582,18 @@ impl<'tcx, N> Vtable<'tcx, N> {\n         }\n     }\n \n+    fn nested_obligations_mut(&mut self) -> &mut Vec<N> {\n+        match self {\n+            &mut VtableImpl(ref mut i) => &mut i.nested,\n+            &mut VtableParam(ref mut n) => n,\n+            &mut VtableBuiltin(ref mut i) => &mut i.nested,\n+            &mut VtableDefaultImpl(ref mut d) => &mut d.nested,\n+            &mut VtableClosure(ref mut c) => &mut c.nested,\n+            &mut VtableObject(ref mut d) => &mut d.nested,\n+            &mut VtableFnPointer(ref mut d) => &mut d.nested,\n+        }\n+    }\n+\n     pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M> where F: FnMut(N) -> M {\n         match self {\n             VtableImpl(i) => VtableImpl(VtableImplData {"}, {"sha": "5307749b87b6adf3515bbc2a7f360f46809f49a0", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 106, "deletions": 66, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f52b655621dc0e3ba8d2b37de9a68f96a65ab660/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b655621dc0e3ba8d2b37de9a68f96a65ab660/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "patch": "@@ -346,6 +346,46 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx.projection_mode()\n     }\n \n+    /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n+    /// context's self.\n+    fn in_snapshot<R, F>(&mut self, f: F) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+    {\n+        // The irrefutable nature of the operation means we don't need to snapshot the\n+        // inferred_obligations vector.\n+        self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n+    }\n+\n+    /// Wraps a probe s.t. obligations collected during it are ignored and old obligations are\n+    /// retained.\n+    fn probe<R, F>(&mut self, f: F) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+    {\n+        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n+        let result = self.infcx.probe(|snapshot| f(self, snapshot));\n+        self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n+        result\n+    }\n+\n+    /// Wraps a commit_if_ok s.t. obligations collected during it are not returned in selection if\n+    /// the transaction fails and s.t. old obligations are retained.\n+    fn commit_if_ok<T, E, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> Result<T, E>\n+    {\n+        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n+        match self.infcx.commit_if_ok(|snapshot| f(self, snapshot)) {\n+            Ok(ok) => {\n+                self.inferred_obligations.commit(inferred_obligations_snapshot);\n+                Ok(ok)\n+            },\n+            Err(err) => {\n+                self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n+                Err(err)\n+            }\n+        }\n+    }\n+\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -374,7 +414,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         match self.candidate_from_obligation(&stack)? {\n             None => Ok(None),\n-            Some(candidate) => Ok(Some(self.confirm_candidate(obligation, candidate)?)),\n+            Some(candidate) => {\n+                let mut candidate = self.confirm_candidate(obligation, candidate)?;\n+                // FIXME(#32730) remove this assertion once inferred obligations are propagated\n+                // from inference\n+                assert!(self.inferred_obligations.len() == 0);\n+                let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n+                candidate.nested_obligations_mut().extend(inferred_obligations);\n+                Ok(Some(candidate))\n+            },\n         }\n     }\n \n@@ -396,8 +444,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation({:?})\",\n                obligation);\n \n-        self.infcx.probe(|_| {\n-            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+        self.probe(|this, _| {\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n                 .may_apply()\n         })\n     }\n@@ -412,8 +460,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation_conservatively({:?})\",\n                obligation);\n \n-        self.infcx.probe(|_| {\n-            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+        self.probe(|this, _| {\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n                 == EvaluatedToOk\n         })\n     }\n@@ -475,8 +523,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.equality_predicate(obligation.cause.span, p) {\n                     Ok(InferOk { obligations, .. }) => {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n+                        self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n                     },\n                     Err(_) => EvaluatedToErr\n@@ -658,11 +705,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n                stack.obligation.recursion_depth, candidate);\n-        let result = self.infcx.probe(|_| {\n+        let result = self.probe(|this, _| {\n             let candidate = (*candidate).clone();\n-            match self.confirm_candidate(stack.obligation, candidate) {\n+            match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => {\n-                    self.evaluate_predicates_recursively(\n+                    this.evaluate_predicates_recursively(\n                         stack.list(),\n                         selection.nested_obligations().iter())\n                 }\n@@ -1122,8 +1169,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"assemble_candidates_for_projected_tys: trait_def_id={:?}\",\n                trait_def_id);\n \n-        let result = self.infcx.probe(|snapshot| {\n-            self.match_projection_obligation_against_bounds_from_trait(obligation,\n+        let result = self.probe(|this, snapshot| {\n+            this.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                        snapshot)\n         });\n \n@@ -1171,12 +1218,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n             .filter_to_traits()\n             .find(\n-                |bound| self.infcx.probe(\n-                    |_| self.match_projection(obligation,\n-                                              bound.clone(),\n-                                              skol_trait_predicate.trait_ref.clone(),\n-                                              &skol_map,\n-                                              snapshot)));\n+                |bound| self.probe(\n+                    |this, _| this.match_projection(obligation,\n+                                                    bound.clone(),\n+                                                    skol_trait_predicate.trait_ref.clone(),\n+                                                    &skol_map,\n+                                                    snapshot)));\n \n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 matching_bound={:?}\",\n@@ -1211,8 +1258,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n             Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n             }\n             Err(_) => { return false; }\n         }\n@@ -1254,10 +1300,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                  -> EvaluationResult\n     {\n-        self.infcx().probe(move |_| {\n-            match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n+        self.probe(move |this, _| {\n+            match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n+                    this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => EvaluatedToErr\n             }\n@@ -1376,8 +1422,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.tcx(),\n             obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.infcx.probe(|snapshot| {\n-                    if let Ok(_) = self.match_impl(impl_def_id, obligation, snapshot) {\n+                self.probe(|this, snapshot| {\n+                    if let Ok(_) = this.match_impl(impl_def_id, obligation, snapshot) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n                 });\n@@ -1463,12 +1509,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.probe(|snapshot| {\n+        self.probe(|this, snapshot| {\n             let (self_ty, _) =\n-                self.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n+                this.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n-                    match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n+                    match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n                         Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n                             if data.bounds.builtin_bounds.contains(&bound) {\n                                 debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n@@ -1480,7 +1526,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         _ => {}\n                     }\n \n-                    data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                    data.principal_trait_ref_with_self_ty(this.tcx(), self_ty)\n                 }\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -1501,11 +1547,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo : Bar<u32>`.\n             let upcast_trait_refs =\n-                util::supertraits(self.tcx(), poly_trait_ref)\n+                util::supertraits(this.tcx(), poly_trait_ref)\n                 .filter(|upcast_trait_ref| {\n-                    self.infcx.probe(|_| {\n+                    this.probe(|this, _| {\n                         let upcast_trait_ref = upcast_trait_ref.clone();\n-                        self.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n+                        this.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n                     })\n                 })\n                 .count();\n@@ -1909,23 +1955,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         types.skip_binder().into_iter().flat_map(|ty| { // binder moved -\\\n             let ty: ty::Binder<Ty<'tcx>> = ty::Binder(ty); // <----------/\n \n-            self.infcx.in_snapshot(|snapshot| {\n+            self.in_snapshot(|this, snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty, snapshot);\n+                    this.infcx().skolemize_late_bound_regions(&ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n-                    project::normalize_with_depth(self,\n+                    project::normalize_with_depth(this,\n                                                   cause.clone(),\n                                                   recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    self.tcx().predicate_for_trait_def(\n+                    this.tcx().predicate_for_trait_def(\n                                                   cause.clone(),\n                                                   trait_def_id,\n                                                   recursion_depth,\n                                                   normalized_ty,\n                                                   vec![]);\n                 obligations.push(skol_obligation);\n-                self.infcx().plug_leaks(skol_map, snapshot, &obligations)\n+                this.infcx().plug_leaks(skol_map, snapshot, &obligations)\n             })\n         }).collect()\n     }\n@@ -2012,9 +2058,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn confirm_projection_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n     {\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.in_snapshot(|this, snapshot| {\n             let result =\n-                self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                this.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                            snapshot);\n             assert!(result);\n         })\n@@ -2155,12 +2201,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             trait_def_id,\n             nested);\n \n-        let trait_obligations = self.infcx.in_snapshot(|snapshot| {\n+        let trait_obligations = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n-            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n-            self.impl_or_trait_obligations(cause,\n+                this.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n                                            trait_def_id,\n                                            &trait_ref.substs,\n@@ -2189,13 +2235,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.in_snapshot(|this, snapshot| {\n             let (substs, skol_map) =\n-                self.rematch_impl(impl_def_id, obligation,\n+                this.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n-            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n-            self.vtable_impl(impl_def_id, substs, cause,\n+            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            this.vtable_impl(impl_def_id, substs, cause,\n                              obligation.recursion_depth + 1,\n                              skol_map, snapshot)\n         })\n@@ -2266,18 +2312,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let vtable_base;\n \n         {\n+            let tcx = self.tcx();\n+\n             // We want to find the first supertrait in the list of\n             // supertraits that we can unify with, and do that\n             // unification. We know that there is exactly one in the list\n             // where we can unify because otherwise select would have\n             // reported an ambiguity. (When we do find a match, also\n             // record it for later.)\n             let nonmatching =\n-                util::supertraits(self.tcx(), poly_trait_ref)\n+                util::supertraits(tcx, poly_trait_ref)\n                 .take_while(|&t| {\n                     match\n-                        self.infcx.commit_if_ok(\n-                            |_| self.match_poly_trait_ref(obligation, t))\n+                        self.commit_if_ok(\n+                            |this, _| this.match_poly_trait_ref(obligation, t))\n                     {\n                         Ok(_) => { upcast_trait_ref = Some(t); false }\n                         Err(_) => { true }\n@@ -2289,12 +2337,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // entries, so that we can compute the offset for the selected\n             // trait.\n             vtable_base =\n-                nonmatching.map(|t| self.tcx().count_own_vtable_entries(t))\n+                nonmatching.map(|t| tcx.count_own_vtable_entries(t))\n                            .sum();\n \n         }\n \n-        // FIXME(#32730) propagate obligations\n         VtableObjectData {\n             upcast_trait_ref: upcast_trait_ref.unwrap(),\n             vtable_base: vtable_base,\n@@ -2321,7 +2368,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n-        // FIXME(#32730) propagate obligations\n         Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n     }\n \n@@ -2401,8 +2447,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                        origin,\n                                        expected_trait_ref.clone(),\n                                        obligation_trait_ref.clone())\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n@@ -2437,8 +2482,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2511,8 +2555,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, a, b)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -2571,8 +2614,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -2666,8 +2708,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n                 ()\n             })?;\n-        // FIXME(#32730) propagate obligations\n-        assert!(obligations.is_empty());\n+        self.inferred_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false, &skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n@@ -2720,7 +2761,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n-    fn match_poly_trait_ref(&self,\n+    fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n@@ -2734,8 +2775,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                        origin,\n                                        poly_trait_ref,\n                                        obligation.predicate.to_poly_trait_ref())\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|_| ())\n     }\n "}, {"sha": "dac074ab91e1bfe11c67876f0d3dce2bc7bfc492", "filename": "src/librustc_data_structures/snapshot_vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f52b655621dc0e3ba8d2b37de9a68f96a65ab660/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f52b655621dc0e3ba8d2b37de9a68f96a65ab660/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs?ref=f52b655621dc0e3ba8d2b37de9a68f96a65ab660", "patch": "@@ -213,3 +213,11 @@ impl<D: SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n         self.get_mut(index)\n     }\n }\n+\n+impl<D: SnapshotVecDelegate> Extend<D::Value> for SnapshotVec<D> {\n+    fn extend<T>(&mut self, iterable: T) where T: IntoIterator<Item=D::Value> {\n+        for item in iterable {\n+            self.push(item);\n+        }\n+    }\n+}"}]}