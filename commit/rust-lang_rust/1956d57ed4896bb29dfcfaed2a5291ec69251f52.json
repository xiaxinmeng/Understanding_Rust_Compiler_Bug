{"sha": "1956d57ed4896bb29dfcfaed2a5291ec69251f52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NTZkNTdlZDQ4OTZiYjI5ZGZjZmFlZDJhNTI5MWVjNjkyNTFmNTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-24T12:50:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-24T12:50:45Z"}, "message": "Slightly reduce code duplication", "tree": {"sha": "c74e88db824e751818e7f1c4f80a9251732cf3a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c74e88db824e751818e7f1c4f80a9251732cf3a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1956d57ed4896bb29dfcfaed2a5291ec69251f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1956d57ed4896bb29dfcfaed2a5291ec69251f52", "html_url": "https://github.com/rust-lang/rust/commit/1956d57ed4896bb29dfcfaed2a5291ec69251f52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1956d57ed4896bb29dfcfaed2a5291ec69251f52/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e36cb586038e2c12e6eceae57f7a95684fc6c6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e36cb586038e2c12e6eceae57f7a95684fc6c6d", "html_url": "https://github.com/rust-lang/rust/commit/8e36cb586038e2c12e6eceae57f7a95684fc6c6d"}], "stats": {"total": 63, "additions": 30, "deletions": 33}, "files": [{"sha": "5c1b151f7d1614c2605c45ae42bbc714b64f1909", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1956d57ed4896bb29dfcfaed2a5291ec69251f52/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1956d57ed4896bb29dfcfaed2a5291ec69251f52/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=1956d57ed4896bb29dfcfaed2a5291ec69251f52", "patch": "@@ -2,7 +2,7 @@\n \n use std::{ops, sync::Arc};\n \n-use hir_expand::{either::Either, hygiene::Hygiene, AstId};\n+use hir_expand::{either::Either, hygiene::Hygiene, AstId, Source};\n use mbe::ast_to_token_tree;\n use ra_cfg::CfgOptions;\n use ra_syntax::{\n@@ -40,23 +40,19 @@ impl Attrs {\n                     Some(it) => it,\n                     None => return Attrs::default(),\n                 };\n-                let hygiene = Hygiene::new(db, src.file_id);\n-                Attr::from_attrs_owner(&src.value, &hygiene)\n+                Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n             }\n             AttrDefId::StructFieldId(it) => {\n                 let src = it.parent.child_source(db);\n                 match &src.value[it.local_id] {\n                     Either::A(_tuple) => Attrs::default(),\n-                    Either::B(record) => {\n-                        let hygiene = Hygiene::new(db, src.file_id);\n-                        Attr::from_attrs_owner(record, &hygiene)\n-                    }\n+                    Either::B(record) => Attrs::from_attrs_owner(db, src.with_value(record)),\n                 }\n             }\n-            AttrDefId::EnumVariantId(it) => {\n-                let src = it.parent.child_source(db);\n-                let hygiene = Hygiene::new(db, src.file_id);\n-                Attr::from_attrs_owner(&src.value[it.local_id], &hygiene)\n+            AttrDefId::EnumVariantId(var_id) => {\n+                let src = var_id.parent.child_source(db);\n+                let src = src.as_ref().map(|it| &it[var_id.local_id]);\n+                Attrs::from_attrs_owner(db, src.map(|it| it as &dyn AttrsOwner))\n             }\n             AttrDefId::AdtId(it) => match it {\n                 AdtId::StructId(it) => attrs_from_ast(it.0.lookup_intern(db).ast_id, db),\n@@ -73,6 +69,22 @@ impl Attrs {\n         }\n     }\n \n+    fn from_attrs_owner(db: &impl DefDatabase, owner: Source<&dyn AttrsOwner>) -> Attrs {\n+        let hygiene = Hygiene::new(db, owner.file_id);\n+        Attrs::new(owner.value, &hygiene)\n+    }\n+\n+    pub(crate) fn new(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n+        let mut attrs = owner.attrs().peekable();\n+        let entries = if attrs.peek().is_none() {\n+            // Avoid heap allocation\n+            None\n+        } else {\n+            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n+        };\n+        Attrs { entries }\n+    }\n+\n     pub fn has_atom(&self, atom: &str) -> bool {\n         self.iter().any(|it| it.is_simple_atom(atom))\n     }\n@@ -100,7 +112,7 @@ pub enum AttrInput {\n }\n \n impl Attr {\n-    pub(crate) fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n+    fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n         let path = Path::from_src(ast.path()?, hygiene)?;\n         let input = match ast.input() {\n             None => None,\n@@ -117,17 +129,6 @@ impl Attr {\n         Some(Attr { path, input })\n     }\n \n-    pub fn from_attrs_owner(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Attrs {\n-        let mut attrs = owner.attrs().peekable();\n-        let entries = if attrs.peek().is_none() {\n-            // Avoid heap allocation\n-            None\n-        } else {\n-            Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n-        };\n-        Attrs { entries }\n-    }\n-\n     pub fn is_simple_atom(&self, name: &str) -> bool {\n         // FIXME: Avoid cloning\n         self.path.as_ident().map_or(false, |s| s.to_string() == name)\n@@ -154,8 +155,8 @@ where\n     N: ast::AttrsOwner,\n     D: DefDatabase,\n {\n-    let hygiene = Hygiene::new(db, src.file_id());\n-    Attr::from_attrs_owner(&src.to_node(db), &hygiene)\n+    let src = Source::new(src.file_id(), src.to_node(db));\n+    Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n }\n \n fn attrs_from_loc<T, D>(node: T, db: &D) -> Attrs\n@@ -165,6 +166,5 @@ where\n     D: DefDatabase,\n {\n     let src = node.source(db);\n-    let hygiene = Hygiene::new(db, src.file_id);\n-    Attr::from_attrs_owner(&src.value, &hygiene)\n+    Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n }"}, {"sha": "69d7bf21a35ab67cd9995d324cda4a28c79c38b6", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1956d57ed4896bb29dfcfaed2a5291ec69251f52/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1956d57ed4896bb29dfcfaed2a5291ec69251f52/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=1956d57ed4896bb29dfcfaed2a5291ec69251f52", "patch": "@@ -114,7 +114,7 @@ impl LangItems {\n     {\n         let attrs = db.attrs(item.into());\n         if let Some(lang_item_name) = attrs.find_string_value(\"lang\") {\n-            self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n+            self.items.entry(lang_item_name.clone()).or_insert_with(|| constructor(item));\n         }\n     }\n }"}, {"sha": "19857875381d99091d92913759023719e517dd59", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1956d57ed4896bb29dfcfaed2a5291ec69251f52/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1956d57ed4896bb29dfcfaed2a5291ec69251f52/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=1956d57ed4896bb29dfcfaed2a5291ec69251f52", "patch": "@@ -17,10 +17,7 @@ use ra_syntax::{\n use test_utils::tested_by;\n \n use crate::{\n-    attr::{Attr, Attrs},\n-    db::DefDatabase,\n-    path::Path,\n-    FileAstId, HirFileId, LocalImportId, Source,\n+    attr::Attrs, db::DefDatabase, path::Path, FileAstId, HirFileId, LocalImportId, Source,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -407,6 +404,6 @@ impl RawItemsCollector {\n     }\n \n     fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n-        Attr::from_attrs_owner(item, &self.hygiene)\n+        Attrs::new(item, &self.hygiene)\n     }\n }"}]}