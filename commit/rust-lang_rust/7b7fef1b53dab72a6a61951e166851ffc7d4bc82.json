{"sha": "7b7fef1b53dab72a6a61951e166851ffc7d4bc82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiN2ZlZjFiNTNkYWI3MmE2YTYxOTUxZTE2Njg1MWZmYzdkNGJjODI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-17T06:42:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-17T14:02:57Z"}, "message": "let the permission of a new pointer depend on the type only", "tree": {"sha": "79c4c8f8c979151531cc8a8051b9906288158d16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79c4c8f8c979151531cc8a8051b9906288158d16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b7fef1b53dab72a6a61951e166851ffc7d4bc82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7fef1b53dab72a6a61951e166851ffc7d4bc82", "html_url": "https://github.com/rust-lang/rust/commit/7b7fef1b53dab72a6a61951e166851ffc7d4bc82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b7fef1b53dab72a6a61951e166851ffc7d4bc82/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a503259d8b6437550fd1563368cfae618f8ab426", "url": "https://api.github.com/repos/rust-lang/rust/commits/a503259d8b6437550fd1563368cfae618f8ab426", "html_url": "https://github.com/rust-lang/rust/commit/a503259d8b6437550fd1563368cfae618f8ab426"}], "stats": {"total": 264, "additions": 125, "deletions": 139}, "files": [{"sha": "ca257aaf1feb17374fb67e9ce982a9d2581db2b6", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 125, "deletions": 139, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/7b7fef1b53dab72a6a61951e166851ffc7d4bc82/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7fef1b53dab72a6a61951e166851ffc7d4bc82/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=7b7fef1b53dab72a6a61951e166851ffc7d4bc82", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use std::num::NonZeroU64;\n \n use rustc::ty::{self, layout::Size};\n-use rustc::hir::{Mutability, MutMutable, MutImmutable};\n+use rustc::hir::{MutMutable, MutImmutable};\n use rustc::mir::RetagKind;\n \n use crate::{\n@@ -96,50 +96,38 @@ pub type MemoryState = Rc<RefCell<GlobalState>>;\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum AccessKind {\n     Read,\n-    Write { dealloc: bool },\n-}\n-\n-// \"Fake\" constructors\n-impl AccessKind {\n-    fn write() -> AccessKind {\n-        AccessKind::Write { dealloc: false }\n-    }\n-\n-    fn dealloc() -> AccessKind {\n-        AccessKind::Write { dealloc: true }\n-    }\n+    Write,\n }\n \n impl fmt::Display for AccessKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n             AccessKind::Read => write!(f, \"read\"),\n-            AccessKind::Write { dealloc: false } => write!(f, \"write\"),\n-            AccessKind::Write { dealloc: true } => write!(f, \"deallocation\"),\n+            AccessKind::Write => write!(f, \"write\"),\n         }\n     }\n }\n \n /// Indicates which kind of reference is being created.\n-/// Used by `reborrow` to compute which permissions to grant to the\n+/// Used by high-level `reborrow` to compute which permissions to grant to the\n /// new pointer.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum RefKind {\n-    /// `&mut`.\n-    Mutable,\n+    /// `&mut` and `Box`.\n+    Unique,\n     /// `&` with or without interior mutability.\n-    Shared { frozen: bool },\n-    /// `*` (raw pointer).\n-    Raw,\n+    Shared,\n+    /// `*mut`/`*const` (raw pointers).\n+    Raw { mutable: bool },\n }\n \n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            RefKind::Mutable => write!(f, \"mutable\"),\n-            RefKind::Shared { frozen: true } => write!(f, \"shared (frozen)\"),\n-            RefKind::Shared { frozen: false } => write!(f, \"shared (mutable)\"),\n-            RefKind::Raw => write!(f, \"raw\"),\n+            RefKind::Unique => write!(f, \"unique\"),\n+            RefKind::Shared => write!(f, \"shared\"),\n+            RefKind::Raw { mutable: true } => write!(f, \"raw (mutable)\"),\n+            RefKind::Raw { mutable: false } => write!(f, \"raw (constant)\"),\n         }\n     }\n }\n@@ -216,7 +204,7 @@ impl Permission {\n             // SharedReadOnly only permits read access.\n             (Permission::SharedReadOnly, AccessKind::Read) =>\n                 true,\n-            (Permission::SharedReadOnly, AccessKind::Write { .. }) =>\n+            (Permission::SharedReadOnly, AccessKind::Write) =>\n                 false,\n         }\n     }\n@@ -235,7 +223,7 @@ impl Permission {\n             // When `other` is `SharedReadOnly`, that is NEVER compatible with\n             // write accesses.\n             // This makes sure read-only pointers become invalid on write accesses (ensures F2a).\n-            (_, AccessKind::Write { .. }, SharedReadOnly) =>\n+            (_, AccessKind::Write, SharedReadOnly) =>\n                 false,\n             // When `other` is `Unique`, that is compatible with nothing.\n             // This makes sure unique pointers become invalid on incompatible accesses (ensures U2).\n@@ -246,7 +234,7 @@ impl Permission {\n             // (This is particularily important such that when a new mutable ref gets created, it gets\n             // pushed into the right item -- this behaves like a write and we assert uniqueness of the\n             // pointer from which this comes, *if* it was a unique pointer.)\n-            (Unique, AccessKind::Write { .. }, _) =>\n+            (Unique, AccessKind::Write, _) =>\n                 false,\n             // `SharedReadWrite` items can tolerate any other akin items for any kind of access.\n             (SharedReadWrite, _, SharedReadWrite) =>\n@@ -262,42 +250,7 @@ impl Permission {\n     }\n }\n \n-impl<'tcx> RefKind {\n-    /// Defines which kind of access the \"parent\" must grant to create this reference.\n-    fn access(self) -> AccessKind {\n-        match self {\n-            RefKind::Mutable | RefKind::Shared { frozen: false } => AccessKind::write(),\n-            RefKind::Raw | RefKind::Shared { frozen: true } => AccessKind::Read,\n-            // FIXME: Just requiring read-only access for raw means that a raw ptr might not be writeable\n-            // even when we think it should be!  Think about this some more.\n-        }\n-    }\n-\n-    /// This defines the new permission used when a pointer gets created: For raw pointers, whether these are read-only\n-    /// or read-write depends on the permission from which they derive.\n-    fn new_perm(self, derived_from: Permission) -> EvalResult<'tcx, Permission> {\n-        Ok(match (self, derived_from) {\n-            // Do not derive writable safe pointer from read-only pointer!\n-            (RefKind::Mutable, Permission::SharedReadOnly) =>\n-                return err!(MachineError(format!(\n-                    \"deriving mutable reference from read-only pointer\"\n-                ))),\n-            (RefKind::Shared { frozen: false }, Permission::SharedReadOnly) =>\n-                return err!(MachineError(format!(\n-                    \"deriving shared reference with interior mutability from read-only pointer\"\n-                ))),\n-            // Safe pointer cases.\n-            (RefKind::Mutable, _) => Permission::Unique,\n-            (RefKind::Shared { frozen: true }, _) => Permission::SharedReadOnly,\n-            (RefKind::Shared { frozen: false }, _) => Permission::SharedReadWrite,\n-            // Raw pointer cases.\n-            (RefKind::Raw, Permission::SharedReadOnly) => Permission::SharedReadOnly,\n-            (RefKind::Raw, _) => Permission::SharedReadWrite,\n-        })\n-    }\n-}\n-\n-/// Core per-location operations: access, create.\n+/// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and where that item is in the stack.\n     fn find_granting(&self, access: AccessKind, tag: Tag) -> Option<(usize, Permission)> {\n@@ -326,7 +279,6 @@ impl<'tcx> Stack {\n         // The second step is where barriers get implemented: they \"protect\" the items\n         // below them, meaning that if we remove an item and then further up encounter a barrier,\n         // we raise an error.\n-        // Afterwards we just do some post-processing for deallocation accesses.\n \n         // Step 1: Find granting item.\n         let (granting_idx, granting_perm) = self.find_granting(access, tag)\n@@ -356,7 +308,7 @@ impl<'tcx> Stack {\n                         } else {\n                             // Aha! This is a bad one, remove it.\n                             let item = self.borrows.remove(cur);\n-                            trace!(\"access: popping item {}\", item);\n+                            trace!(\"access: removing item {}\", item);\n                             removed_item = Some(item);\n                         }\n                     }\n@@ -380,25 +332,38 @@ impl<'tcx> Stack {\n             }\n         }\n \n-        // Post-processing.\n-        // If we got here, we found a matching item. Congratulations!\n-        // However, we are not done yet: If this access is deallocating, we must make sure\n-        // there are no active barriers remaining on the stack.\n-        if access == AccessKind::dealloc() {\n-            for &itm in self.borrows.iter().rev() {\n-                match itm {\n-                    Item::FnBarrier(call) if global.is_active(call) => {\n-                        return err!(MachineError(format!(\n-                            \"deallocating with active barrier ({})\", call\n-                        )))\n-                    }\n-                    _ => {},\n+        // Done.\n+        return Ok(granting_idx);\n+    }\n+\n+    /// Deallocate a location: Like a write access, but also there must be no\n+    /// barriers at all.\n+    fn dealloc(\n+        &mut self,\n+        tag: Tag,\n+        global: &GlobalState,\n+    ) -> EvalResult<'tcx> {\n+        // Step 1: Find granting item.\n+        self.find_granting(AccessKind::Write, tag)\n+            .ok_or_else(|| InterpError::MachineError(format!(\n+                    \"no item granting write access for deallocation to tag {} found in borrow stack\",\n+                    tag,\n+            )))?;\n+\n+        // We must make sure there are no active barriers remaining on the stack.\n+        // Also clear the stack, no more accesses are possible.\n+        while let Some(itm) = self.borrows.pop() {\n+            match itm {\n+                Item::FnBarrier(call) if global.is_active(call) => {\n+                    return err!(MachineError(format!(\n+                        \"deallocating with active barrier ({})\", call\n+                    )))\n                 }\n+                _ => {},\n             }\n         }\n \n-        // Done.\n-        return Ok(granting_idx);\n+        Ok(())\n     }\n \n     /// `reborrow` helper function.\n@@ -412,7 +377,7 @@ impl<'tcx> Stack {\n             trace!(\"reborrow: avoiding redundant item {}\", item);\n             return;\n         }\n-        trace!(\"reborrow: pushing item {}\", item);\n+        trace!(\"reborrow: adding item {}\", item);\n         self.borrows.insert(position, item);\n     }\n \n@@ -427,7 +392,7 @@ impl<'tcx> Stack {\n             // that overlap.\n             trace!(\"reborrow: avoiding redundant extra barrier\");\n         } else {\n-            trace!(\"reborrow: pushing barrier for call {}\", call);\n+            trace!(\"reborrow: adding barrier for call {}\", call);\n             self.borrows.push(itm);\n         }\n     }\n@@ -453,27 +418,22 @@ impl<'tcx> Stack {\n         &mut self,\n         derived_from: Tag,\n         barrier: Option<CallId>,\n-        new_kind: RefKind,\n+        new_perm: Permission,\n         new_tag: Tag,\n         global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n-        // Find the permission \"from which we derive\".  To this end we first have to decide\n-        // if we derive from a permission that grants writes or just reads.\n-        let access = new_kind.access();\n-        // Now we figure out which item grants our parent (`derived_from`) permission.\n-        // We use that to determine (a) where to put the new item, and for raw pointers\n-        // (b) whether to given read-only or read-write access.\n-        // FIXME: This handling of raw pointers is fragile, very fragile.  What if we do\n-        // not get \"the right one\", like when there are multiple items granting `derived_from`\n-        // and we accidentally create a read-only pointer?  This can happen for two-phase borrows\n-        // (then there's a `Unique` and a `SharedReadOnly` for the same tag), and for raw pointers\n-        // (which currently all are `Untagged`).\n-        let (derived_from_idx, derived_from_perm) = self.find_granting(access, derived_from)\n+        // Figure out which access `perm` corresponds to.\n+        let access = if new_perm.grants(AccessKind::Write) {\n+                AccessKind::Write\n+            } else {\n+                AccessKind::Read\n+            };\n+        // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n+        // We use that to determine where to put the new item.\n+        let (derived_from_idx, _) = self.find_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                    \"no item to reborrow as {} from tag {} found in borrow stack\", new_kind, derived_from,\n+                    \"no item to reborrow for {:?} from tag {} found in borrow stack\", new_perm, derived_from,\n             )))?;\n-        // With this we can compute the permission for the new pointer.\n-        let new_perm = new_kind.new_perm(derived_from_perm).expect(\"this should never fail\");\n \n         // We behave very differently for the \"unsafe\" case of a shared-read-write pointer\n         // (\"unsafe\" because this also applies to shared references with interior mutability).\n@@ -530,8 +490,9 @@ impl<'tcx> Stack {\n         Ok(())\n     }\n }\n+// # Stacked Borrows Core End\n \n-/// Higher-level per-location operations: deref, access, reborrow.\n+/// Higher-level per-location operations: deref, access, dealloc, reborrow.\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n     pub(crate) fn new(\n@@ -554,16 +515,34 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        kind: AccessKind,\n+        access: AccessKind,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"{} access of tag {}: {:?}, size {}\", access, ptr.tag, ptr, size.bytes());\n+        // Even reads can have a side-effect, by invalidating other references.\n+        // This is fundamentally necessary since `&mut` asserts that there\n+        // are no accesses through other references, not even reads.\n+        let global = self.global.borrow();\n+        let mut stacks = self.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            stack.access(access, ptr.tag, &*global)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// `ptr` is used to deallocate.\n+    fn dealloc(\n+        &self,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"{} access of tag {}: {:?}, size {}\", kind, ptr.tag, ptr, size.bytes());\n+        trace!(\"deallocation with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n         // Even reads can have a side-effect, by invalidating other references.\n         // This is fundamentally necessary since `&mut` asserts that there\n         // are no accesses through other references, not even reads.\n         let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.access(kind, ptr.tag, &*global)?;\n+            stack.dealloc(ptr.tag, &*global)?;\n         }\n         Ok(())\n     }\n@@ -575,26 +554,23 @@ impl<'tcx> Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n         barrier: Option<CallId>,\n-        new_kind: RefKind,\n+        new_perm: Permission,\n         new_tag: Tag,\n     ) -> EvalResult<'tcx> {\n         trace!(\n-            \"{} reborrow for tag {} to {}: {:?}, size {}\",\n-            new_kind, ptr.tag, new_tag, ptr, size.bytes(),\n+            \"reborrow tag {} as {:?} {}: {:?}, size {}\",\n+            ptr.tag, new_perm, new_tag, ptr, size.bytes(),\n         );\n         let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.reborrow(ptr.tag, barrier, new_kind, new_tag, &*global)?;\n+            stack.reborrow(ptr.tag, barrier, new_perm, new_tag, &*global)?;\n         }\n         Ok(())\n     }\n }\n \n-// # Stacked Borrows Core End\n-\n-// Glue code to connect with Miri Machine Hooks\n-\n+/// Glue code to connect with Miri Machine Hooks\n impl Stacks {\n     pub fn new_allocation(\n         size: Size,\n@@ -638,7 +614,7 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, AccessKind::write())\n+        alloc.extra.access(ptr, size, AccessKind::Write)\n     }\n \n     #[inline(always)]\n@@ -647,50 +623,56 @@ impl AllocationExtra<Tag> for Stacks {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, AccessKind::dealloc())\n+        alloc.extra.dealloc(ptr, size)\n     }\n }\n \n impl<'a, 'mir, 'tcx> EvalContextPrivExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n+    /// High-level `reborrow` operation.  This decides which reference gets which kind\n+    /// of permission!\n     fn reborrow(\n         &mut self,\n         place: MPlaceTy<'tcx, Tag>,\n         size: Size,\n-        mutbl: Option<Mutability>,\n+        kind: RefKind,\n         new_tag: Tag,\n         fn_barrier: bool,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n         let barrier = if fn_barrier { Some(this.frame().extra) } else { None };\n         let ptr = place.ptr.to_ptr()?;\n-        trace!(\"reborrow: creating new reference for {:?} (pointee {}): {:?}\",\n-            ptr, place.layout.ty, new_tag);\n+        trace!(\"reborrow: creating new reference for {:?} (pointee {}): {}, {:?}\",\n+            ptr, place.layout.ty, kind, new_tag);\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // Update the stacks.\n-        if mutbl == Some(MutImmutable) {\n-            // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n-            this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n-                let new_kind = RefKind::Shared { frozen };\n-                alloc.extra.reborrow(cur_ptr, size, barrier, new_kind, new_tag)\n-            })?;\n-        } else {\n-            // Just treat this as one big chunk.\n-            let new_kind = if mutbl == Some(MutMutable) { RefKind::Mutable } else { RefKind::Raw };\n-            alloc.extra.reborrow(ptr, size, barrier, new_kind, new_tag)?;\n-        }\n-        Ok(())\n+        let perm = match kind {\n+            RefKind::Unique => Permission::Unique,\n+            RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n+            RefKind::Shared | RefKind::Raw { mutable: false } => {\n+                // Shared references and *const are a whole different kind of game, the\n+                // permission is not uniform across the entire range!\n+                // We need a frozen-sensitive reborrow.\n+                return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                    // We are only ever `SharedReadOnly` inside the frozen bits.\n+                    let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n+                    alloc.extra.reborrow(cur_ptr, size, barrier, perm, new_tag)\n+                });\n+            }\n+        };\n+        debug_assert_ne!(perm, Permission::SharedReadOnly, \"SharedReadOnly must be used frozen-sensitive\");\n+        return alloc.extra.reborrow(ptr, size, barrier, perm, new_tag);\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n     /// `mutbl` can be `None` to make this a raw pointer.\n     fn retag_reference(\n         &mut self,\n         val: ImmTy<'tcx, Tag>,\n-        mutbl: Option<Mutability>,\n+        kind: RefKind,\n         fn_barrier: bool,\n         two_phase: bool,\n     ) -> EvalResult<'tcx, Immediate<Tag>> {\n@@ -706,24 +688,24 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         }\n \n         // Compute new borrow.\n-        let new_tag = match mutbl {\n-            Some(_) => Tag::Tagged(this.memory().extra.borrow_mut().new_ptr()),\n-            None => Tag::Untagged,\n+        let new_tag = match kind {\n+            RefKind::Raw { .. } => Tag::Untagged,\n+            _ => Tag::Tagged(this.memory().extra.borrow_mut().new_ptr()),\n         };\n \n         // Reborrow.\n-        this.reborrow(place, size, mutbl, new_tag, fn_barrier)?;\n+        this.reborrow(place, size, kind, new_tag, fn_barrier)?;\n         let new_place = place.replace_tag(new_tag);\n         // Handle two-phase borrows.\n         if two_phase {\n-            assert!(mutbl == Some(MutMutable), \"two-phase shared borrows make no sense\");\n+            assert!(kind == RefKind::Unique, \"two-phase shared borrows make no sense\");\n             // Grant read access *to the parent pointer* with the old tag.  This means the same pointer\n             // has multiple items in the stack now!\n             // FIXME: Think about this some more, in particular about the interaction with cast-to-raw.\n             // Maybe find a better way to express 2-phase, now that we have a \"more expressive language\"\n             // in the stack.\n             let old_tag = place.ptr.to_ptr().unwrap().tag;\n-            this.reborrow(new_place, size, Some(MutImmutable), old_tag, /* fn_barrier: */ false)?;\n+            this.reborrow(new_place, size, RefKind::Shared, old_tag, /* fn_barrier: */ false)?;\n         }\n \n         // Return new pointer.\n@@ -742,15 +724,19 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         // Determine mutability and whether to add a barrier.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n         // making it useless.\n-        fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(Option<Mutability>, bool)> {\n+        fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(RefKind, bool)> {\n             match ty.sty {\n                 // References are simple.\n-                ty::Ref(_, _, mutbl) => Some((Some(mutbl), kind == RetagKind::FnEntry)),\n+                ty::Ref(_, _, MutMutable) =>\n+                    Some((RefKind::Unique, kind == RetagKind::FnEntry)),\n+                ty::Ref(_, _, MutImmutable) =>\n+                    Some((RefKind::Shared, kind == RetagKind::FnEntry)),\n                 // Raw pointers need to be enabled.\n-                ty::RawPtr(..) if kind == RetagKind::Raw => Some((None, false)),\n+                ty::RawPtr(tym) if kind == RetagKind::Raw =>\n+                    Some((RefKind::Raw { mutable: tym.mutbl == MutMutable }, false)),\n                 // Boxes do not get a barrier: barriers reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n-                ty::Adt(..) if ty.is_box() => Some((Some(MutMutable), false)),\n+                ty::Adt(..) if ty.is_box() => Some((RefKind::Unique, false)),\n                 _ => None,\n             }\n         }"}]}