{"sha": "42e38e89498ec4690479b268066ad1ca58917aec", "node_id": "C_kwDOAAsO6NoAKDQyZTM4ZTg5NDk4ZWM0NjkwNDc5YjI2ODA2NmFkMWNhNTg5MTdhZWM", "commit": {"author": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2023-04-05T08:27:11Z"}, "committer": {"name": "Thom Chiovoloni", "email": "thom@shift.click", "date": "2023-04-05T08:27:11Z"}, "message": "Use the `junction` crate in bootstrap instead of manually creating the junction", "tree": {"sha": "13a5ffddcaebde3cb09aac6d5da4ba3071329455", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13a5ffddcaebde3cb09aac6d5da4ba3071329455"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42e38e89498ec4690479b268066ad1ca58917aec", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgMrDyZKNSLq6TEmWvPtNWv4vJNv\nay7sfrM7c6iOWHdh8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQGMcfWY4e4H2b3dLtzS2Pj1cnWUcKZb+FOi1IO7LwztEd0GYOpR1aOmgzvA1feKqYJ\nQHPa61WT8L+Uu2fWp7Ew4=\n-----END SSH SIGNATURE-----", "payload": "tree 13a5ffddcaebde3cb09aac6d5da4ba3071329455\nparent 12dff54a6acf271e367a8fb0c3d149d6554d9d90\nauthor Thom Chiovoloni <thom@shift.click> 1680683231 -0700\ncommitter Thom Chiovoloni <thom@shift.click> 1680683231 -0700\n\nUse the `junction` crate in bootstrap instead of manually creating the junction\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42e38e89498ec4690479b268066ad1ca58917aec", "html_url": "https://github.com/rust-lang/rust/commit/42e38e89498ec4690479b268066ad1ca58917aec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42e38e89498ec4690479b268066ad1ca58917aec/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12dff54a6acf271e367a8fb0c3d149d6554d9d90", "url": "https://api.github.com/repos/rust-lang/rust/commits/12dff54a6acf271e367a8fb0c3d149d6554d9d90", "html_url": "https://github.com/rust-lang/rust/commit/12dff54a6acf271e367a8fb0c3d149d6554d9d90"}], "stats": {"total": 130, "additions": 15, "deletions": 115}, "files": [{"sha": "a158d1f718e2caa494ae889bdf4e0cb9d14d34d3", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42e38e89498ec4690479b268066ad1ca58917aec/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/42e38e89498ec4690479b268066ad1ca58917aec/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=42e38e89498ec4690479b268066ad1ca58917aec", "patch": "@@ -45,6 +45,7 @@ dependencies = [\n  \"hex\",\n  \"ignore\",\n  \"is-terminal\",\n+ \"junction\",\n  \"libc\",\n  \"object\",\n  \"once_cell\",\n@@ -349,6 +350,16 @@ version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n \n+[[package]]\n+name = \"junction\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca39ef0d69b18e6a2fd14c2f0a1d593200f4a4ed949b240b5917ab51fac754cb\"\n+dependencies = [\n+ \"scopeguard\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\""}, {"sha": "eeda6d7c121f7c97c358bb5fa17a6c9871fd4372", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42e38e89498ec4690479b268066ad1ca58917aec/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/42e38e89498ec4690479b268066ad1ca58917aec/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=42e38e89498ec4690479b268066ad1ca58917aec", "patch": "@@ -61,6 +61,9 @@ sysinfo = { version = \"0.26.0\", optional = true }\n [target.'cfg(not(target_os = \"solaris\"))'.dependencies]\n fd-lock = \"3.0.8\"\n \n+[target.'cfg(windows)'.dependencies.junction]\n+version = \"1.0.0\"\n+\n [target.'cfg(windows)'.dependencies.windows]\n version = \"0.46.0\"\n features = ["}, {"sha": "2e1adbf63bb102bcf85dd103101a046e758ba074", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 115, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/42e38e89498ec4690479b268066ad1ca58917aec/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42e38e89498ec4690479b268066ad1ca58917aec/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=42e38e89498ec4690479b268066ad1ca58917aec", "patch": "@@ -146,123 +146,9 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n         fs::symlink(src, dest)\n     }\n \n-    // Creating a directory junction on windows involves dealing with reparse\n-    // points and the DeviceIoControl function, and this code is a skeleton of\n-    // what can be found here:\n-    //\n-    // http://www.flexhex.com/docs/articles/hard-links.phtml\n     #[cfg(windows)]\n     fn symlink_dir_inner(target: &Path, junction: &Path) -> io::Result<()> {\n-        use std::ffi::OsStr;\n-        use std::os::windows::ffi::OsStrExt;\n-\n-        use windows::{\n-            core::PCWSTR,\n-            Win32::Foundation::{CloseHandle, HANDLE},\n-            Win32::Storage::FileSystem::{\n-                CreateFileW, FILE_ACCESS_FLAGS, FILE_FLAG_BACKUP_SEMANTICS,\n-                FILE_FLAG_OPEN_REPARSE_POINT, FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE,\n-                MAXIMUM_REPARSE_DATA_BUFFER_SIZE, OPEN_EXISTING,\n-            },\n-            Win32::System::Ioctl::FSCTL_SET_REPARSE_POINT,\n-            Win32::System::SystemServices::{GENERIC_WRITE, IO_REPARSE_TAG_MOUNT_POINT},\n-            Win32::System::IO::DeviceIoControl,\n-        };\n-\n-        #[allow(non_snake_case)]\n-        #[repr(C)]\n-        struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n-            ReparseTag: u32,\n-            ReparseDataLength: u32,\n-            Reserved: u16,\n-            ReparseTargetLength: u16,\n-            ReparseTargetMaximumLength: u16,\n-            Reserved1: u16,\n-            ReparseTarget: u16,\n-        }\n-\n-        fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n-            Ok(s.as_ref().encode_wide().chain(Some(0)).collect())\n-        }\n-\n-        // We're using low-level APIs to create the junction, and these are more\n-        // picky about paths. For example, forward slashes cannot be used as a\n-        // path separator, so we should try to canonicalize the path first.\n-        let target = fs::canonicalize(target)?;\n-\n-        fs::create_dir(junction)?;\n-\n-        let path = to_u16s(junction)?;\n-\n-        let h = unsafe {\n-            CreateFileW(\n-                PCWSTR(path.as_ptr()),\n-                FILE_ACCESS_FLAGS(GENERIC_WRITE),\n-                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                None,\n-                OPEN_EXISTING,\n-                FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n-                HANDLE::default(),\n-            )\n-        }\n-        .map_err(|_| io::Error::last_os_error())?;\n-\n-        unsafe {\n-            #[repr(C, align(8))]\n-            struct Align8<T>(T);\n-            let mut data = Align8([0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize]);\n-            let db = data.0.as_mut_ptr() as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n-            let end = db.cast::<u8>().add(MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize);\n-            let reparse_target_slice = {\n-                let buf_start = core::ptr::addr_of_mut!((*db).ReparseTarget).cast::<u16>();\n-                // Compute offset in bytes and then divide so that we round down\n-                // rather than hit any UB (admittedly this arithmetic should work\n-                // out so that this isn't necessary)\n-                let buf_len_bytes =\n-                    usize::try_from(end.offset_from(buf_start.cast::<u8>())).unwrap();\n-                let buf_len_wchars = buf_len_bytes / core::mem::size_of::<u16>();\n-                core::slice::from_raw_parts_mut(buf_start, buf_len_wchars)\n-            };\n-\n-            // FIXME: this conversion is very hacky\n-            let iter = br\"\\??\\\"\n-                .iter()\n-                .map(|x| *x as u16)\n-                .chain(path.iter().copied())\n-                .chain(core::iter::once(0));\n-            let mut i = 0;\n-            for c in iter {\n-                if i >= reparse_target_slice.len() {\n-                    return Err(io::Error::new(\n-                        io::ErrorKind::Other,\n-                        format!(\"path too long for reparse target: {target:?}\"),\n-                    ));\n-                }\n-                reparse_target_slice[i] = c;\n-                i += 1;\n-            }\n-            (*db).ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n-            (*db).ReparseTargetMaximumLength = (i * 2) as u16;\n-            (*db).ReparseTargetLength = ((i - 1) * 2) as u16;\n-            (*db).ReparseDataLength = ((*db).ReparseTargetLength + 12) as u32;\n-\n-            let mut ret = 0u32;\n-            DeviceIoControl(\n-                h,\n-                FSCTL_SET_REPARSE_POINT,\n-                Some(db.cast()),\n-                (*db).ReparseDataLength + 8,\n-                None,\n-                0,\n-                Some(&mut ret),\n-                None,\n-            )\n-            .ok()\n-            .map_err(|_| io::Error::last_os_error())?;\n-        }\n-\n-        unsafe { CloseHandle(h) };\n-        Ok(())\n+        junction::create(&target, &junction)\n     }\n }\n "}]}