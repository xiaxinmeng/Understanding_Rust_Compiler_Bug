{"sha": "f8f204c0bf03ccb0a87940803fddb8f631a92afd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZjIwNGMwYmYwM2NjYjBhODc5NDA4MDNmZGRiOGY2MzFhOTJhZmQ=", "commit": {"author": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-05-04T18:07:35Z"}, "committer": {"name": "gnzlbg", "email": "gonzalobg88@gmail.com", "date": "2018-05-24T14:04:39Z"}, "message": "add simd float intrinsics and gather/scatter", "tree": {"sha": "6bc2d90a8bbb9e9ac5cf70bfc82a59795e099947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bc2d90a8bbb9e9ac5cf70bfc82a59795e099947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8f204c0bf03ccb0a87940803fddb8f631a92afd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f204c0bf03ccb0a87940803fddb8f631a92afd", "html_url": "https://github.com/rust-lang/rust/commit/f8f204c0bf03ccb0a87940803fddb8f631a92afd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8f204c0bf03ccb0a87940803fddb8f631a92afd/comments", "author": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gnzlbg", "id": 904614, "node_id": "MDQ6VXNlcjkwNDYxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/904614?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnzlbg", "html_url": "https://github.com/gnzlbg", "followers_url": "https://api.github.com/users/gnzlbg/followers", "following_url": "https://api.github.com/users/gnzlbg/following{/other_user}", "gists_url": "https://api.github.com/users/gnzlbg/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnzlbg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnzlbg/subscriptions", "organizations_url": "https://api.github.com/users/gnzlbg/orgs", "repos_url": "https://api.github.com/users/gnzlbg/repos", "events_url": "https://api.github.com/users/gnzlbg/events{/privacy}", "received_events_url": "https://api.github.com/users/gnzlbg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "729c22e7979ca2f1f82caedf5a7b245d59ea6dbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/729c22e7979ca2f1f82caedf5a7b245d59ea6dbc", "html_url": "https://github.com/rust-lang/rust/commit/729c22e7979ca2f1f82caedf5a7b245d59ea6dbc"}], "stats": {"total": 1951, "additions": 1950, "deletions": 1}, "files": [{"sha": "b774d7c5def217a9a17f5bc501bc8ef60cdb7d07", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -522,6 +522,15 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     let t_f32 = Type::f32(cx);\n     let t_f64 = Type::f64(cx);\n \n+    let t_v2f32 = Type::vector(&t_f32, 2);\n+    let t_v4f32 = Type::vector(&t_f32, 4);\n+    let t_v8f32 = Type::vector(&t_f32, 8);\n+    let t_v16f32 = Type::vector(&t_f32, 16);\n+\n+    let t_v2f64 = Type::vector(&t_f64, 2);\n+    let t_v4f64 = Type::vector(&t_f64, 4);\n+    let t_v8f64 = Type::vector(&t_f64, 8);\n+\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i16\", fn(i8p, i8p, t_i16, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n     ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n@@ -537,37 +546,145 @@ fn declare_intrinsic(cx: &CodegenCx, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n \n     ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n+    ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);\n+    ifn!(\"llvm.powi.v4f32\", fn(t_v4f32, t_i32) -> t_v4f32);\n+    ifn!(\"llvm.powi.v8f32\", fn(t_v8f32, t_i32) -> t_v8f32);\n+    ifn!(\"llvm.powi.v16f32\", fn(t_v16f32, t_i32) -> t_v16f32);\n     ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n+    ifn!(\"llvm.powi.v2f64\", fn(t_v2f64, t_i32) -> t_v2f64);\n+    ifn!(\"llvm.powi.v4f64\", fn(t_v4f64, t_i32) -> t_v4f64);\n+    ifn!(\"llvm.powi.v8f64\", fn(t_v8f64, t_i32) -> t_v8f64);\n+\n     ifn!(\"llvm.pow.f32\", fn(t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.pow.v2f32\", fn(t_v2f32, t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.pow.v4f32\", fn(t_v4f32, t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.pow.v8f32\", fn(t_v8f32, t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.pow.v16f32\", fn(t_v16f32, t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.pow.f64\", fn(t_f64, t_f64) -> t_f64);\n+    ifn!(\"llvm.pow.v2f64\", fn(t_v2f64, t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.pow.v4f64\", fn(t_v4f64, t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.pow.v8f64\", fn(t_v8f64, t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.sqrt.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sqrt.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.sqrt.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.sqrt.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.sqrt.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.sqrt.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sqrt.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.sqrt.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.sqrt.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.sin.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sin.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.sin.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.sin.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.sin.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.sin.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sin.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.sin.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.sin.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.cos.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.cos.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.cos.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.cos.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.cos.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.cos.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.cos.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.cos.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.cos.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.exp.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.exp.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.exp.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.exp.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.exp.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.exp.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.exp.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.exp2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp2.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.exp2.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.exp2.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.exp2.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.exp2.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp2.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.exp2.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.exp2.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.log.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.log.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.log.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.log.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.log.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.log.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.log.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.log10.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log10.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.log10.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.log10.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.log10.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.log10.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log10.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.log10.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.log10.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.log2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log2.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.log2.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.log2.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.log2.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.log2.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log2.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.log2.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.log2.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.fma.f32\", fn(t_f32, t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.fma.v2f32\", fn(t_v2f32, t_v2f32, t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.fma.v4f32\", fn(t_v4f32, t_v4f32, t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.fma.v8f32\", fn(t_v8f32, t_v8f32, t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.fma.v16f32\", fn(t_v16f32, t_v16f32, t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.fma.f64\", fn(t_f64, t_f64, t_f64) -> t_f64);\n+    ifn!(\"llvm.fma.v2f64\", fn(t_v2f64, t_v2f64, t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.fma.v4f64\", fn(t_v4f64, t_v4f64, t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.fma.v8f64\", fn(t_v8f64, t_v8f64, t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.fabs.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.fabs.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.fabs.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.fabs.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.fabs.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.fabs.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.fabs.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.fabs.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.fabs.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n     ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.floor.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.floor.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.floor.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.floor.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.floor.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.floor.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.floor.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.floor.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.ceil.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.ceil.v2f32\", fn(t_v2f32) -> t_v2f32);\n+    ifn!(\"llvm.ceil.v4f32\", fn(t_v4f32) -> t_v4f32);\n+    ifn!(\"llvm.ceil.v8f32\", fn(t_v8f32) -> t_v8f32);\n+    ifn!(\"llvm.ceil.v16f32\", fn(t_v16f32) -> t_v16f32);\n     ifn!(\"llvm.ceil.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.ceil.v2f64\", fn(t_v2f64) -> t_v2f64);\n+    ifn!(\"llvm.ceil.v4f64\", fn(t_v4f64) -> t_v4f64);\n+    ifn!(\"llvm.ceil.v8f64\", fn(t_v8f64) -> t_v8f64);\n+\n     ifn!(\"llvm.trunc.f32\", fn(t_f32) -> t_f32);\n     ifn!(\"llvm.trunc.f64\", fn(t_f64) -> t_f64);\n "}, {"sha": "71641a7f248a093270b53c0c2cc310a194067de7", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -1140,6 +1140,377 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n \n+    fn simd_simple_float_intrinsic<'a, 'tcx>(name: &str, in_elem: &::rustc::ty::TyS, in_ty: &::rustc::ty::TyS,\n+                                             in_len: usize, bx: &Builder<'a, 'tcx>, span: Span,\n+                                             args: &[OperandRef<'tcx>])\n+                                             -> Result<ValueRef, ()> {\n+        macro_rules! emit_error {\n+            ($msg: tt) => {\n+                emit_error!($msg, )\n+            };\n+            ($msg: tt, $($fmt: tt)*) => {\n+                span_invalid_monomorphization_error(\n+                    bx.sess(), span,\n+                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n+                                     $msg),\n+                             name, $($fmt)*));\n+            }\n+        }\n+        macro_rules! return_error {\n+            ($($fmt: tt)*) => {\n+                {\n+                    emit_error!($($fmt)*);\n+                    return Err(());\n+                }\n+            }\n+        }\n+        let ety = match in_elem.sty {\n+            ty::TyFloat(f) if f.bit_width() == 32 => {\n+                if in_len < 2 || in_len > 16 {\n+                    return_error!(\"unsupported floating-point vector `{}` with length `{}` out-of-range [2, 16]\",\n+                                  in_ty, in_len);\n+                }\n+                \"f32\"\n+            },\n+            ty::TyFloat(f) if f.bit_width() == 64 => {\n+                if in_len < 2 || in_len > 8 {\n+                    return_error!(\"unsupported floating-point vector `{}` with length `{}` out-of-range [2, 8]\",\n+                                  in_ty, in_len);\n+                }\n+                \"f64\"\n+            },\n+            ty::TyFloat(f) => {\n+                return_error!(\"unsupported element type `{}` of floating-point vector `{}`\",\n+                              f, in_ty);\n+            },\n+            _ => {\n+                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+            }\n+        };\n+\n+        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", name, in_len, ety);\n+        let intrinsic = bx.cx.get_intrinsic(&llvm_name);\n+        return Ok(bx.call(intrinsic,\n+                          &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+                          None));\n+    }\n+\n+    if name == \"simd_fsqrt\" {\n+        return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fsin\" {\n+        return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fcos\" {\n+        return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fabs\" {\n+        return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_floor\" {\n+        return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_ceil\" {\n+        return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fexp\" {\n+        return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fexp2\" {\n+        return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_flog10\" {\n+        return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_flog2\" {\n+        return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_flog\" {\n+        return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fpowi\" {\n+        return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fpow\"  {\n+        return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_fma\" {\n+        return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n+    }\n+\n+    if name == \"simd_gather\"  {\n+        // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n+        //             mask: <N x i{M}>) -> <N x T>\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(ret_ty, \"return\");\n+\n+        // Of the same length:\n+        require!(in_len == arg_tys[1].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"second\", in_len, in_ty, arg_tys[1],\n+                 arg_tys[1].simd_size(tcx));\n+        require!(in_len == arg_tys[2].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"third\", in_len, in_ty, arg_tys[2],\n+                 arg_tys[2].simd_size(tcx));\n+\n+        // The return type must match the first argument type\n+        require!(ret_ty == in_ty,\n+                 \"expected return type `{}`, found `{}`\",\n+                 in_ty, ret_ty);\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: ty::Ty) -> usize {\n+            match t.sty {\n+                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: ty::Ty) -> ty::Ty {\n+            match t.sty {\n+                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n+            ty::TyRawPtr(p) if p.ty == in_elem => (ptr_count(arg_tys[1].simd_type(tcx)),\n+                                                   non_ptr(arg_tys[1].simd_type(tcx))),\n+            _ => {\n+                require!(false, \"expected element type `{}` of second argument `{}` \\\n+                                 to be a pointer to the element type `{}` of the first \\\n+                                 argument `{}`, found `{}` != `*_ {}`\",\n+                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match arg_tys[2].simd_type(tcx).sty {\n+            ty::TyInt(_) => (),\n+            _ => {\n+                require!(false, \"expected element type `{}` of third argument `{}` \\\n+                                 to be a signed integer type\",\n+                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+            }\n+        }\n+\n+        // Alignment of T, must be a constant integer value:\n+        let alignment_ty = Type::i32(bx.cx);\n+        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+\n+        // Truncate the mask vector to a vector of i1s:\n+        let (mask, mask_ty) = {\n+            let i1 = Type::i1(bx.cx);\n+            let i1xn = Type::vector(&i1, in_len as u64);\n+            (bx.trunc(args[2].immediate(), i1xn), i1xn)\n+        };\n+\n+        // FIXME: use:\n+        //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Function.h#L182\n+        //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Intrinsics.h#L81\n+        fn llvm_vector_str(elem_ty: ty::Ty, vec_len: usize, no_pointers: usize) -> String {\n+            let p0s: String = \"p0\".repeat(no_pointers);\n+            match elem_ty.sty {\n+                ty::TyInt(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+                ty::TyUint(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+                ty::TyFloat(v) => format!(\"v{}{}f{}\", vec_len, p0s, v.bit_width()),\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        fn llvm_vector_ty(cx: &CodegenCx, elem_ty: ty::Ty, vec_len: usize,\n+                          mut no_pointers: usize) -> Type {\n+            // FIXME: use cx.layout_of(ty).llvm_type() ?\n+            let mut elem_ty = match elem_ty.sty {\n+                ty::TyInt(v) => Type::int_from_ty(cx, v),\n+                ty::TyUint(v) => Type::uint_from_ty(cx, v),\n+                ty::TyFloat(v) => Type::float_from_ty(cx, v),\n+                _ => unreachable!(),\n+            };\n+            while no_pointers > 0 {\n+                elem_ty = elem_ty.ptr_to();\n+                no_pointers -= 1;\n+            }\n+            Type::vector(&elem_ty, vec_len as u64)\n+        }\n+\n+\n+        // Type of the vector of pointers:\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n+\n+        // Type of the vector of elements:\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n+\n+        let llvm_intrinsic = format!(\"llvm.masked.gather.{}.{}\",\n+                                     llvm_elem_vec_str, llvm_pointer_vec_str);\n+        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n+                                     Type::func(&[llvm_pointer_vec_ty, alignment_ty, mask_ty,\n+                                                  llvm_elem_vec_ty], &llvm_elem_vec_ty));\n+        llvm::SetUnnamedAddr(f, false);\n+        let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()],\n+                        None);\n+        return Ok(v);\n+    }\n+\n+    if name == \"simd_scatter\"  {\n+        // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n+        //             mask: <N x i{M}>) -> ()\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+\n+        // Of the same length:\n+        require!(in_len == arg_tys[1].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"second\", in_len, in_ty, arg_tys[1],\n+                 arg_tys[1].simd_size(tcx));\n+        require!(in_len == arg_tys[2].simd_size(tcx),\n+                 \"expected {} argument with length {} (same as input type `{}`), \\\n+                  found `{}` with length {}\", \"third\", in_len, in_ty, arg_tys[2],\n+                 arg_tys[2].simd_size(tcx));\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: ty::Ty) -> usize {\n+            match t.sty {\n+                ty::TyRawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: ty::Ty) -> ty::Ty {\n+            match t.sty {\n+                ty::TyRawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).sty {\n+            ty::TyRawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n+                => (ptr_count(arg_tys[1].simd_type(tcx)),\n+                    non_ptr(arg_tys[1].simd_type(tcx))),\n+            _ => {\n+                require!(false, \"expected element type `{}` of second argument `{}` \\\n+                                 to be a pointer to the element type `{}` of the first \\\n+                                 argument `{}`, found `{}` != `*mut {}`\",\n+                         arg_tys[1].simd_type(tcx).sty, arg_tys[1], in_elem, in_ty,\n+                         arg_tys[1].simd_type(tcx).sty, in_elem);\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match arg_tys[2].simd_type(tcx).sty {\n+            ty::TyInt(_) => (),\n+            _ => {\n+                require!(false, \"expected element type `{}` of third argument `{}` \\\n+                                 to be a signed integer type\",\n+                         arg_tys[2].simd_type(tcx).sty, arg_tys[2]);\n+            }\n+        }\n+\n+        // Alignment of T, must be a constant integer value:\n+        let alignment_ty = Type::i32(bx.cx);\n+        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+\n+        // Truncate the mask vector to a vector of i1s:\n+        let (mask, mask_ty) = {\n+            let i1 = Type::i1(bx.cx);\n+            let i1xn = Type::vector(&i1, in_len as u64);\n+            (bx.trunc(args[2].immediate(), i1xn), i1xn)\n+        };\n+\n+        let ret_t = Type::void(bx.cx);\n+\n+        // FIXME: use:\n+        //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Function.h#L182\n+        //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Intrinsics.h#L81\n+        fn llvm_vector_str(elem_ty: ty::Ty, vec_len: usize, no_pointers: usize) -> String {\n+            let p0s: String = \"p0\".repeat(no_pointers);\n+            match elem_ty.sty {\n+                ty::TyInt(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+                ty::TyUint(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n+                ty::TyFloat(v) => format!(\"v{}{}f{}\", vec_len, p0s, v.bit_width()),\n+                _ => unreachable!(),\n+            }\n+        }\n+\n+        fn llvm_vector_ty(cx: &CodegenCx, elem_ty: ty::Ty, vec_len: usize,\n+                          mut no_pointers: usize) -> Type {\n+            // FIXME: use cx.layout_of(ty).llvm_type() ?\n+            let mut elem_ty = match elem_ty.sty {\n+                ty::TyInt(v) => Type::int_from_ty(cx, v),\n+                ty::TyUint(v) => Type::uint_from_ty(cx, v),\n+                ty::TyFloat(v) => Type::float_from_ty(cx, v),\n+                _ => unreachable!(),\n+            };\n+            while no_pointers > 0 {\n+                elem_ty = elem_ty.ptr_to();\n+                no_pointers -= 1;\n+            }\n+            Type::vector(&elem_ty, vec_len as u64)\n+        }\n+\n+\n+        // Type of the vector of pointers:\n+        let llvm_pointer_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count);\n+        let llvm_pointer_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count);\n+\n+        // Type of the vector of elements:\n+        let llvm_elem_vec_ty = llvm_vector_ty(bx.cx, underlying_ty, in_len, pointer_count - 1);\n+        let llvm_elem_vec_str = llvm_vector_str(underlying_ty, in_len, pointer_count - 1);\n+\n+        let llvm_intrinsic = format!(\"llvm.masked.scatter.{}.{}\",\n+                                     llvm_elem_vec_str, llvm_pointer_vec_str);\n+        let f = declare::declare_cfn(bx.cx, &llvm_intrinsic,\n+                                     Type::func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], &ret_t));\n+        llvm::SetUnnamedAddr(f, false);\n+        let v = bx.call(f, &[args[0].immediate(), args[1].immediate(), alignment, mask],\n+                        None);\n+        return Ok(v);\n+    }\n+\n     macro_rules! arith_red {\n         ($name:tt : $integer_reduce:ident, $float_reduce:ident, $ordered:expr) => {\n             if name == $name {"}, {"sha": "5546aa58d4cfa41dbe14906590e34c3350baeb0a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -351,9 +351,26 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"simd_add\" | \"simd_sub\" | \"simd_mul\" | \"simd_rem\" |\n         \"simd_div\" | \"simd_shl\" | \"simd_shr\" |\n         \"simd_and\" | \"simd_or\" | \"simd_xor\" |\n-        \"simd_fmin\" | \"simd_fmax\" => {\n+        \"simd_fmin\" | \"simd_fmax\" | \"simd_fpow\" => {\n             (1, vec![param(0), param(0)], param(0))\n         }\n+        \"simd_fsqrt\" | \"simd_fsin\" | \"simd_fcos\" | \"simd_fexp\" | \"simd_fexp2\" |\n+        \"simd_flog2\" | \"simd_flog10\" | \"simd_flog\" |\n+        \"simd_fabs\" | \"simd_floor\" | \"simd_ceil\" => {\n+            (1, vec![param(0)], param(0))\n+        }\n+        \"simd_fpowi\" => {\n+            (1, vec![param(0), tcx.types.i32], param(0))\n+        }\n+        \"simd_fma\" => {\n+            (1, vec![param(0), param(0), param(0)], param(0))\n+        }\n+        \"simd_gather\" => {\n+            (3, vec![param(0), param(1), param(2)], param(0))\n+        }\n+        \"simd_scatter\" => {\n+            (3, vec![param(0), param(1), param(2)], tcx.mk_nil())\n+        }\n         \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n         \"simd_cast\" => (2, vec![param(0)], param(1)),"}, {"sha": "8fc6b7a4826f20d97b9f051bf2faaa45cac5bdc3", "filename": "src/test/codegen/simd-intrinsic-float-abs.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-abs.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fabs<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fabs_32x2\n+#[no_mangle]\n+pub unsafe fn fabs_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.fabs.v2f32\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_32x4\n+#[no_mangle]\n+pub unsafe fn fabs_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.fabs.v4f32\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_32x8\n+#[no_mangle]\n+pub unsafe fn fabs_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.fabs.v8f32\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_32x16\n+#[no_mangle]\n+pub unsafe fn fabs_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.fabs.v16f32\n+    simd_fabs(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fabs_64x4\n+#[no_mangle]\n+pub unsafe fn fabs_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.fabs.v4f64\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_64x2\n+#[no_mangle]\n+pub unsafe fn fabs_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.fabs.v2f64\n+    simd_fabs(a)\n+}\n+\n+// CHECK-LABEL: @fabs_64x8\n+#[no_mangle]\n+pub unsafe fn fabs_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.fabs.v8f64\n+    simd_fabs(a)\n+}"}, {"sha": "aca591b97abae059b561be7b180ef49aa7c9daa0", "filename": "src/test/codegen/simd-intrinsic-float-ceil.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-ceil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-ceil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-ceil.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_ceil<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @ceil_32x2\n+#[no_mangle]\n+pub unsafe fn ceil_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.ceil.v2f32\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_32x4\n+#[no_mangle]\n+pub unsafe fn ceil_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.ceil.v4f32\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_32x8\n+#[no_mangle]\n+pub unsafe fn ceil_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.ceil.v8f32\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_32x16\n+#[no_mangle]\n+pub unsafe fn ceil_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.ceil.v16f32\n+    simd_ceil(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @ceil_64x4\n+#[no_mangle]\n+pub unsafe fn ceil_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.ceil.v4f64\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_64x2\n+#[no_mangle]\n+pub unsafe fn ceil_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.ceil.v2f64\n+    simd_ceil(a)\n+}\n+\n+// CHECK-LABEL: @ceil_64x8\n+#[no_mangle]\n+pub unsafe fn ceil_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.ceil.v8f64\n+    simd_ceil(a)\n+}"}, {"sha": "77715f23d63313acecdeaa49097a9d8af60b0114", "filename": "src/test/codegen/simd-intrinsic-float-cos.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-cos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-cos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-cos.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fcos<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fcos_32x2\n+#[no_mangle]\n+pub unsafe fn fcos_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.cos.v2f32\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_32x4\n+#[no_mangle]\n+pub unsafe fn fcos_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.cos.v4f32\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_32x8\n+#[no_mangle]\n+pub unsafe fn fcos_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.cos.v8f32\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_32x16\n+#[no_mangle]\n+pub unsafe fn fcos_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.cos.v16f32\n+    simd_fcos(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fcos_64x4\n+#[no_mangle]\n+pub unsafe fn fcos_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.cos.v4f64\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_64x2\n+#[no_mangle]\n+pub unsafe fn fcos_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.cos.v2f64\n+    simd_fcos(a)\n+}\n+\n+// CHECK-LABEL: @fcos_64x8\n+#[no_mangle]\n+pub unsafe fn fcos_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.cos.v8f64\n+    simd_fcos(a)\n+}"}, {"sha": "0046ce668602641baf1479f56990f0336686c5ec", "filename": "src/test/codegen/simd-intrinsic-float-exp.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fexp<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @exp_32x2\n+#[no_mangle]\n+pub unsafe fn exp_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.exp.v2f32\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_32x4\n+#[no_mangle]\n+pub unsafe fn exp_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.exp.v4f32\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_32x8\n+#[no_mangle]\n+pub unsafe fn exp_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.exp.v8f32\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_32x16\n+#[no_mangle]\n+pub unsafe fn exp_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.exp.v16f32\n+    simd_fexp(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @exp_64x4\n+#[no_mangle]\n+pub unsafe fn exp_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.exp.v4f64\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_64x2\n+#[no_mangle]\n+pub unsafe fn exp_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.exp.v2f64\n+    simd_fexp(a)\n+}\n+\n+// CHECK-LABEL: @exp_64x8\n+#[no_mangle]\n+pub unsafe fn exp_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.exp.v8f64\n+    simd_fexp(a)\n+}"}, {"sha": "a93fd7ea65a8fd7f3a992d664fd1c831d8381751", "filename": "src/test/codegen/simd-intrinsic-float-exp2.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-exp2.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fexp2<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @exp2_32x2\n+#[no_mangle]\n+pub unsafe fn exp2_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.exp2.v2f32\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_32x4\n+#[no_mangle]\n+pub unsafe fn exp2_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.exp2.v4f32\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_32x8\n+#[no_mangle]\n+pub unsafe fn exp2_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.exp2.v8f32\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_32x16\n+#[no_mangle]\n+pub unsafe fn exp2_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.exp2.v16f32\n+    simd_fexp2(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @exp2_64x4\n+#[no_mangle]\n+pub unsafe fn exp2_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.exp2.v4f64\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_64x2\n+#[no_mangle]\n+pub unsafe fn exp2_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.exp2.v2f64\n+    simd_fexp2(a)\n+}\n+\n+// CHECK-LABEL: @exp2_64x8\n+#[no_mangle]\n+pub unsafe fn exp2_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.exp2.v8f64\n+    simd_fexp2(a)\n+}"}, {"sha": "dfea41869de247990cadfa8473a0300505d9c155", "filename": "src/test/codegen/simd-intrinsic-float-floor.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-floor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-floor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-floor.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_floor<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @floor_32x2\n+#[no_mangle]\n+pub unsafe fn floor_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.floor.v2f32\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_32x4\n+#[no_mangle]\n+pub unsafe fn floor_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.floor.v4f32\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_32x8\n+#[no_mangle]\n+pub unsafe fn floor_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.floor.v8f32\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_32x16\n+#[no_mangle]\n+pub unsafe fn floor_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.floor.v16f32\n+    simd_floor(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @floor_64x4\n+#[no_mangle]\n+pub unsafe fn floor_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.floor.v4f64\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_64x2\n+#[no_mangle]\n+pub unsafe fn floor_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.floor.v2f64\n+    simd_floor(a)\n+}\n+\n+// CHECK-LABEL: @floor_64x8\n+#[no_mangle]\n+pub unsafe fn floor_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.floor.v8f64\n+    simd_floor(a)\n+}"}, {"sha": "02f6d0ff75e88264856a43f65585dea3ec451133", "filename": "src/test/codegen/simd-intrinsic-float-fma.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fma.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fma<T>(x: T, b: T, c: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fma_32x2\n+#[no_mangle]\n+pub unsafe fn fma_32x2(a: f32x2, b: f32x2, c: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.fma.v2f32\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_32x4\n+#[no_mangle]\n+pub unsafe fn fma_32x4(a: f32x4, b: f32x4, c: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.fma.v4f32\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_32x8\n+#[no_mangle]\n+pub unsafe fn fma_32x8(a: f32x8, b: f32x8, c: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.fma.v8f32\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_32x16\n+#[no_mangle]\n+pub unsafe fn fma_32x16(a: f32x16, b: f32x16, c: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.fma.v16f32\n+    simd_fma(a, b, c)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fma_64x4\n+#[no_mangle]\n+pub unsafe fn fma_64x4(a: f64x4, b: f64x4, c: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.fma.v4f64\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_64x2\n+#[no_mangle]\n+pub unsafe fn fma_64x2(a: f64x2, b: f64x2, c: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.fma.v2f64\n+    simd_fma(a, b, c)\n+}\n+\n+// CHECK-LABEL: @fma_64x8\n+#[no_mangle]\n+pub unsafe fn fma_64x8(a: f64x8, b: f64x8, c: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.fma.v8f64\n+    simd_fma(a, b, c)\n+}"}, {"sha": "d8fc3e3675b21b30252c47a11285194bd3a559c5", "filename": "src/test/codegen/simd-intrinsic-float-fsqrt.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fsqrt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fsqrt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-fsqrt.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fsqrt<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x2\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.sqrt.v2f32\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x4\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.sqrt.v4f32\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x8\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.sqrt.v8f32\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_32x16\n+#[no_mangle]\n+pub unsafe fn fsqrt_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.sqrt.v16f32\n+    simd_fsqrt(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fsqrt_64x4\n+#[no_mangle]\n+pub unsafe fn fsqrt_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.sqrt.v4f64\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_64x2\n+#[no_mangle]\n+pub unsafe fn fsqrt_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.sqrt.v2f64\n+    simd_fsqrt(a)\n+}\n+\n+// CHECK-LABEL: @fsqrt_64x8\n+#[no_mangle]\n+pub unsafe fn fsqrt_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.sqrt.v8f64\n+    simd_fsqrt(a)\n+}"}, {"sha": "0e094ac5b6e5e28bd44ff1137993c0941aca5395", "filename": "src/test/codegen/simd-intrinsic-float-log10.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log10.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_flog10<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @log10_32x2\n+#[no_mangle]\n+pub unsafe fn log10_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.log10.v2f32\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_32x4\n+#[no_mangle]\n+pub unsafe fn log10_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.log10.v4f32\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_32x8\n+#[no_mangle]\n+pub unsafe fn log10_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.log10.v8f32\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_32x16\n+#[no_mangle]\n+pub unsafe fn log10_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.log10.v16f32\n+    simd_flog10(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @log10_64x4\n+#[no_mangle]\n+pub unsafe fn log10_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.log10.v4f64\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_64x2\n+#[no_mangle]\n+pub unsafe fn log10_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.log10.v2f64\n+    simd_flog10(a)\n+}\n+\n+// CHECK-LABEL: @log10_64x8\n+#[no_mangle]\n+pub unsafe fn log10_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.log10.v8f64\n+    simd_flog10(a)\n+}"}, {"sha": "da1207fc7eed22fb006c2f89d695505acb746406", "filename": "src/test/codegen/simd-intrinsic-float-log2.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-log2.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_flog2<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @log2_32x2\n+#[no_mangle]\n+pub unsafe fn log2_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.log2.v2f32\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_32x4\n+#[no_mangle]\n+pub unsafe fn log2_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.log2.v4f32\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_32x8\n+#[no_mangle]\n+pub unsafe fn log2_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.log2.v8f32\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_32x16\n+#[no_mangle]\n+pub unsafe fn log2_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.log2.v16f32\n+    simd_flog2(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @log2_64x4\n+#[no_mangle]\n+pub unsafe fn log2_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.log2.v4f64\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_64x2\n+#[no_mangle]\n+pub unsafe fn log2_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.log2.v2f64\n+    simd_flog2(a)\n+}\n+\n+// CHECK-LABEL: @log2_64x8\n+#[no_mangle]\n+pub unsafe fn log2_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.log2.v8f64\n+    simd_flog2(a)\n+}"}, {"sha": "5817dd49f4d6a3c71972b4912e2a19fc7ae84f68", "filename": "src/test/codegen/simd-intrinsic-float-pow.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-pow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-pow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-pow.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fpow<T>(x: T, b: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fpow_32x2\n+#[no_mangle]\n+pub unsafe fn fpow_32x2(a: f32x2, b: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.pow.v2f32\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_32x4\n+#[no_mangle]\n+pub unsafe fn fpow_32x4(a: f32x4, b: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.pow.v4f32\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_32x8\n+#[no_mangle]\n+pub unsafe fn fpow_32x8(a: f32x8, b: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.pow.v8f32\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_32x16\n+#[no_mangle]\n+pub unsafe fn fpow_32x16(a: f32x16, b: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.pow.v16f32\n+    simd_fpow(a, b)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fpow_64x4\n+#[no_mangle]\n+pub unsafe fn fpow_64x4(a: f64x4, b: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.pow.v4f64\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_64x2\n+#[no_mangle]\n+pub unsafe fn fpow_64x2(a: f64x2, b: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.pow.v2f64\n+    simd_fpow(a, b)\n+}\n+\n+// CHECK-LABEL: @fpow_64x8\n+#[no_mangle]\n+pub unsafe fn fpow_64x8(a: f64x8, b: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.pow.v8f64\n+    simd_fpow(a, b)\n+}"}, {"sha": "2db5689f623ba847b28e4e990a0af475072772a8", "filename": "src/test/codegen/simd-intrinsic-float-powi.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-powi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-powi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-powi.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fpowi<T>(x: T, b: i32) -> T;\n+}\n+\n+// CHECK-LABEL: @fpowi_32x2\n+#[no_mangle]\n+pub unsafe fn fpowi_32x2(a: f32x2, b: i32) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.powi.v2f32\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_32x4\n+#[no_mangle]\n+pub unsafe fn fpowi_32x4(a: f32x4, b: i32) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.powi.v4f32\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_32x8\n+#[no_mangle]\n+pub unsafe fn fpowi_32x8(a: f32x8, b: i32) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.powi.v8f32\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_32x16\n+#[no_mangle]\n+pub unsafe fn fpowi_32x16(a: f32x16, b: i32) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.powi.v16f32\n+    simd_fpowi(a, b)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fpowi_64x4\n+#[no_mangle]\n+pub unsafe fn fpowi_64x4(a: f64x4, b: i32) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.powi.v4f64\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_64x2\n+#[no_mangle]\n+pub unsafe fn fpowi_64x2(a: f64x2, b: i32) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.powi.v2f64\n+    simd_fpowi(a, b)\n+}\n+\n+// CHECK-LABEL: @fpowi_64x8\n+#[no_mangle]\n+pub unsafe fn fpowi_64x8(a: f64x8, b: i32) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.powi.v8f64\n+    simd_fpowi(a, b)\n+}"}, {"sha": "15720462db7ff29b7c39579864529f4a43d6a5fa", "filename": "src/test/codegen/simd-intrinsic-float-sin.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-sin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-sin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-float-sin.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x2(pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x8(pub f32, pub f32, pub f32, pub f32,\n+                 pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f32x16(pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32,\n+                  pub f32, pub f32, pub f32, pub f32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_fsin<T>(x: T) -> T;\n+}\n+\n+// CHECK-LABEL: @fsin_32x2\n+#[no_mangle]\n+pub unsafe fn fsin_32x2(a: f32x2) -> f32x2 {\n+    // CHECK: call <2 x float> @llvm.sin.v2f32\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_32x4\n+#[no_mangle]\n+pub unsafe fn fsin_32x4(a: f32x4) -> f32x4 {\n+    // CHECK: call <4 x float> @llvm.sin.v4f32\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_32x8\n+#[no_mangle]\n+pub unsafe fn fsin_32x8(a: f32x8) -> f32x8 {\n+    // CHECK: call <8 x float> @llvm.sin.v8f32\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_32x16\n+#[no_mangle]\n+pub unsafe fn fsin_32x16(a: f32x16) -> f32x16 {\n+    // CHECK: call <16 x float> @llvm.sin.v16f32\n+    simd_fsin(a)\n+}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x2(pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x4(pub f64, pub f64, pub f64, pub f64);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct f64x8(pub f64, pub f64, pub f64, pub f64,\n+                 pub f64, pub f64, pub f64, pub f64);\n+\n+// CHECK-LABEL: @fsin_64x4\n+#[no_mangle]\n+pub unsafe fn fsin_64x4(a: f64x4) -> f64x4 {\n+    // CHECK: call <4 x double> @llvm.sin.v4f64\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_64x2\n+#[no_mangle]\n+pub unsafe fn fsin_64x2(a: f64x2) -> f64x2 {\n+    // CHECK: call <2 x double> @llvm.sin.v2f64\n+    simd_fsin(a)\n+}\n+\n+// CHECK-LABEL: @fsin_64x8\n+#[no_mangle]\n+pub unsafe fn fsin_64x8(a: f64x8) -> f64x8 {\n+    // CHECK: call <8 x double> @llvm.sin.v8f64\n+    simd_fsin(a)\n+}"}, {"sha": "58876d2197852f88e20b2da54bb8ca8500a4cde3", "filename": "src/test/codegen/simd-intrinsic-generic-gather.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-gather.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-gather.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-gather.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec2<T>(pub T, pub T);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec4<T>(pub T, pub T, pub T, pub T);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_gather<T, P, M>(value: T, pointers: P, mask: M) -> T;\n+}\n+\n+// CHECK-LABEL: @gather_f32x2\n+#[no_mangle]\n+pub unsafe fn gather_f32x2(pointers: Vec2<*const f32>, mask: Vec2<i32>,\n+                           values: Vec2<f32>) -> Vec2<f32> {\n+    // CHECK: call <2 x float> @llvm.masked.gather.v2f32.v2p0f32(<2 x float*> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x float> {{.*}})\n+    simd_gather(values, pointers, mask)\n+}\n+\n+// CHECK-LABEL: @gather_pf32x2\n+#[no_mangle]\n+pub unsafe fn gather_pf32x2(pointers: Vec2<*const *const f32>, mask: Vec2<i32>,\n+                           values: Vec2<*const f32>) -> Vec2<*const f32> {\n+    // CHECK: call <2 x float*> @llvm.masked.gather.v2p0f32.v2p0p0f32(<2 x float**> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}}, <2 x float*> {{.*}})\n+    simd_gather(values, pointers, mask)\n+}"}, {"sha": "44bb4b71259506cf0958c456200b974d20a6fa32", "filename": "src/test/codegen/simd-intrinsic-generic-scatter.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-scatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8f204c0bf03ccb0a87940803fddb8f631a92afd/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-scatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic-generic-scatter.rs?ref=f8f204c0bf03ccb0a87940803fddb8f631a92afd", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec2<T>(pub T, pub T);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub struct Vec4<T>(pub T, pub T, pub T, pub T);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_scatter<T, P, M>(value: T, pointers: P, mask: M);\n+}\n+\n+// CHECK-LABEL: @scatter_f32x2\n+#[no_mangle]\n+pub unsafe fn scatter_f32x2(pointers: Vec2<*mut f32>, mask: Vec2<i32>,\n+                            values: Vec2<f32>) {\n+    // CHECK: call void @llvm.masked.scatter.v2f32.v2p0f32(<2 x float> {{.*}}, <2 x float*> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n+    simd_scatter(values, pointers, mask)\n+}\n+\n+// CHECK-LABEL: @scatter_pf32x2\n+#[no_mangle]\n+pub unsafe fn scatter_pf32x2(pointers: Vec2<*mut *const f32>, mask: Vec2<i32>,\n+                             values: Vec2<*const f32>) {\n+    // CHECK: call void @llvm.masked.scatter.v2p0f32.v2p0p0f32(<2 x float*> {{.*}}, <2 x float**> {{.*}}, i32 {{.*}}, <2 x i1> {{.*}})\n+    simd_scatter(values, pointers, mask)\n+}"}]}