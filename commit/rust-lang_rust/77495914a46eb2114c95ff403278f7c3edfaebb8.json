{"sha": "77495914a46eb2114c95ff403278f7c3edfaebb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NDk1OTE0YTQ2ZWIyMTE0Yzk1ZmY0MDMyNzhmN2MzZWRmYWViYjg=", "commit": {"author": {"name": "Alex Aktsipetrov", "email": "alex.akts@gmail.com", "date": "2020-04-25T11:46:37Z"}, "committer": {"name": "Alex Aktsipetrov", "email": "alex.akts@gmail.com", "date": "2020-04-25T11:46:37Z"}, "message": "Replace hash map with IndexVec for liveness data.\nUtilize IndexVec::push to avoid redundant object creation.", "tree": {"sha": "c1b41249da0ef586aaeb4fa3384f76b47c0a5177", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1b41249da0ef586aaeb4fa3384f76b47c0a5177"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77495914a46eb2114c95ff403278f7c3edfaebb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77495914a46eb2114c95ff403278f7c3edfaebb8", "html_url": "https://github.com/rust-lang/rust/commit/77495914a46eb2114c95ff403278f7c3edfaebb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77495914a46eb2114c95ff403278f7c3edfaebb8/comments", "author": {"login": "gizmondo", "id": 3333919, "node_id": "MDQ6VXNlcjMzMzM5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3333919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gizmondo", "html_url": "https://github.com/gizmondo", "followers_url": "https://api.github.com/users/gizmondo/followers", "following_url": "https://api.github.com/users/gizmondo/following{/other_user}", "gists_url": "https://api.github.com/users/gizmondo/gists{/gist_id}", "starred_url": "https://api.github.com/users/gizmondo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gizmondo/subscriptions", "organizations_url": "https://api.github.com/users/gizmondo/orgs", "repos_url": "https://api.github.com/users/gizmondo/repos", "events_url": "https://api.github.com/users/gizmondo/events{/privacy}", "received_events_url": "https://api.github.com/users/gizmondo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gizmondo", "id": 3333919, "node_id": "MDQ6VXNlcjMzMzM5MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3333919?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gizmondo", "html_url": "https://github.com/gizmondo", "followers_url": "https://api.github.com/users/gizmondo/followers", "following_url": "https://api.github.com/users/gizmondo/following{/other_user}", "gists_url": "https://api.github.com/users/gizmondo/gists{/gist_id}", "starred_url": "https://api.github.com/users/gizmondo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gizmondo/subscriptions", "organizations_url": "https://api.github.com/users/gizmondo/orgs", "repos_url": "https://api.github.com/users/gizmondo/repos", "events_url": "https://api.github.com/users/gizmondo/events{/privacy}", "received_events_url": "https://api.github.com/users/gizmondo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a58b1ed44f5e06976de2bdc4d7dc81c36a96934f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f", "html_url": "https://github.com/rust-lang/rust/commit/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f"}], "stats": {"total": 34, "additions": 13, "deletions": 21}, "files": [{"sha": "611d03405e2c84149f90530300e3bfe6cb279334", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/77495914a46eb2114c95ff403278f7c3edfaebb8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77495914a46eb2114c95ff403278f7c3edfaebb8/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=77495914a46eb2114c95ff403278f7c3edfaebb8", "patch": "@@ -210,8 +210,7 @@ struct TransformVisitor<'tcx> {\n     remap: FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n-    // FIXME(eddyb) This should use `IndexVec<BasicBlock, Option<_>>`.\n-    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n \n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint<'tcx>>,\n@@ -338,7 +337,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n                     resume,\n                     resume_arg,\n                     drop,\n-                    storage_liveness: self.storage_liveness.get(&block).unwrap().clone(),\n+                    storage_liveness: self.storage_liveness[block].clone().unwrap(),\n                 });\n \n                 VariantIdx::new(state)\n@@ -404,8 +403,7 @@ fn replace_local<'tcx>(\n         is_block_tail: None,\n         local_info: LocalInfo::Other,\n     };\n-    let new_local = Local::new(body.local_decls.len());\n-    body.local_decls.push(new_decl);\n+    let new_local = body.local_decls.push(new_decl);\n     body.local_decls.swap(local, new_local);\n \n     RenameLocalVisitor { from: local, to: new_local, tcx }.visit_body(body);\n@@ -431,7 +429,7 @@ struct LivenessInfo {\n \n     /// For every suspending block, the locals which are storage-live across\n     /// that suspension point.\n-    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    storage_liveness: IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n }\n \n fn locals_live_across_suspend_points(\n@@ -472,7 +470,7 @@ fn locals_live_across_suspend_points(\n     let mut liveness = liveness::liveness_of_locals(body);\n     liveness::dump_mir(tcx, \"generator_liveness\", source, body_ref, &liveness);\n \n-    let mut storage_liveness_map = FxHashMap::default();\n+    let mut storage_liveness_map = IndexVec::from_elem(None, body.basic_blocks());\n     let mut live_locals_at_suspension_points = Vec::new();\n \n     for (block, data) in body.basic_blocks().iter_enumerated() {\n@@ -502,7 +500,7 @@ fn locals_live_across_suspend_points(\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n-            storage_liveness_map.insert(block, storage_liveness);\n+            storage_liveness_map[block] = Some(storage_liveness);\n \n             requires_storage_cursor.seek_before(loc);\n             let storage_required = requires_storage_cursor.get().clone();\n@@ -690,7 +688,7 @@ fn compute_layout<'tcx>(\n ) -> (\n     FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n     GeneratorLayout<'tcx>,\n-    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+    IndexVec<BasicBlock, Option<liveness::LiveVarSet>>,\n ) {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let LivenessInfo {\n@@ -925,14 +923,12 @@ fn create_generator_drop_shim<'tcx>(\n }\n \n fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-    let term_block = BasicBlock::new(body.basic_blocks().len());\n     let source_info = source_info(body);\n     body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator { source_info, kind }),\n         is_cleanup: false,\n-    });\n-    term_block\n+    })\n }\n \n fn insert_panic_block<'tcx>(\n@@ -1030,9 +1026,8 @@ fn create_generator_resume_function<'tcx>(\n \n     // Poison the generator when it unwinds\n     if can_unwind {\n-        let poison_block = BasicBlock::new(body.basic_blocks().len());\n         let source_info = source_info(body);\n-        body.basic_blocks_mut().push(BasicBlockData {\n+        let poison_block = body.basic_blocks_mut().push(BasicBlockData {\n             statements: vec![transform.set_discr(VariantIdx::new(POISONED), source_info)],\n             terminator: Some(Terminator { source_info, kind: TerminatorKind::Resume }),\n             is_cleanup: true,\n@@ -1105,21 +1100,19 @@ fn source_info(body: &Body<'_>) -> SourceInfo {\n fn insert_clean_drop(body: &mut Body<'_>) -> BasicBlock {\n     let return_block = insert_term_block(body, TerminatorKind::Return);\n \n-    // Create a block to destroy an unresumed generators. This can only destroy upvars.\n-    let drop_clean = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n         location: Place::from(SELF_ARG),\n         target: return_block,\n         unwind: None,\n     };\n     let source_info = source_info(body);\n+\n+    // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator { source_info, kind: term }),\n         is_cleanup: false,\n-    });\n-\n-    drop_clean\n+    })\n }\n \n /// An operation that can be performed on a generator.\n@@ -1151,7 +1144,6 @@ fn create_cases<'tcx>(\n         .filter_map(|point| {\n             // Find the target for this suspension point, if applicable\n             operation.target_block(point).map(|target| {\n-                let block = BasicBlock::new(body.basic_blocks().len());\n                 let mut statements = Vec::new();\n \n                 // Create StorageLive instructions for locals with live storage\n@@ -1186,7 +1178,7 @@ fn create_cases<'tcx>(\n                 }\n \n                 // Then jump to the real target\n-                body.basic_blocks_mut().push(BasicBlockData {\n+                let block = body.basic_blocks_mut().push(BasicBlockData {\n                     statements,\n                     terminator: Some(Terminator {\n                         source_info,"}]}