{"sha": "565c5d694a51882fbbe6f1ebba370682c15bfbe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NWM1ZDY5NGE1MTg4MmZiYmU2ZjFlYmJhMzcwNjgyYzE1YmZiZTg=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-02T01:27:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:16Z"}, "message": "std: impl for high-level tcp client/request workflow", "tree": {"sha": "f08e8cc7d2e739c4a9604eda8ef4e732a6c2edb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f08e8cc7d2e739c4a9604eda8ef4e732a6c2edb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/565c5d694a51882fbbe6f1ebba370682c15bfbe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/565c5d694a51882fbbe6f1ebba370682c15bfbe8", "html_url": "https://github.com/rust-lang/rust/commit/565c5d694a51882fbbe6f1ebba370682c15bfbe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/565c5d694a51882fbbe6f1ebba370682c15bfbe8/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e114b200abccb7dcbc03c47585828716dfc0f4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e114b200abccb7dcbc03c47585828716dfc0f4a", "html_url": "https://github.com/rust-lang/rust/commit/7e114b200abccb7dcbc03c47585828716dfc0f4a"}], "stats": {"total": 175, "additions": 150, "deletions": 25}, "files": [{"sha": "c75afc7e021120b1211b78dbda353aa4cdc462cb", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 150, "deletions": 25, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/565c5d694a51882fbbe6f1ebba370682c15bfbe8/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565c5d694a51882fbbe6f1ebba370682c15bfbe8/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=565c5d694a51882fbbe6f1ebba370682c15bfbe8", "patch": "@@ -4,7 +4,7 @@ High-level interface to libuv's TCP functionality\n \n import ip = net_ip;\n \n-export tcp_connect_result, tcp_write_result;\n+export tcp_connect_result, tcp_write_result, tcp_read_start_result;\n export connect, write;\n \n resource tcp_socket(socket_data: @tcp_socket_data) unsafe {\n@@ -36,6 +36,17 @@ enum tcp_write_result {\n     tcp_write_error(uv::ll::uv_err_data)\n }\n \n+enum tcp_read_start_result {\n+    tcp_read_start_success(comm::port<tcp_read_result>),\n+    tcp_read_start_error(uv::ll::uv_err_data)\n+}\n+\n+enum tcp_read_result {\n+    tcp_read_data([u8]),\n+    tcp_read_done,\n+    tcp_read_err(uv::ll::uv_err_data)\n+}\n+\n #[doc=\"\n Initiate a client connection over TCP/IP\n \n@@ -58,8 +69,10 @@ fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n     let hl_loop = uv::global_loop::get();\n+    let reader_po = comm::port::<tcp_read_result>();\n     let socket_data = @{\n-        reader_port: comm::port::<[u8]>(),\n+        reader_po: reader_po,\n+        reader_ch: comm::chan(reader_po),\n         stream_handle : uv::ll::tcp_t(),\n         connect_req : uv::ll::connect_t(),\n         write_req : uv::ll::write_t(),\n@@ -183,9 +196,99 @@ fn write(sock: tcp_socket, raw_write_data: [[u8]]) -> tcp_write_result\n     comm::recv(result_po)\n }\n \n+#[doc=\"\n+\"]\n+fn read_start(sock: tcp_socket) -> tcp_read_start_result unsafe {\n+    let stream_handle_ptr = ptr::addr_of((**sock).stream_handle);\n+    let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n+    let start_ch = comm::chan(start_po);\n+    uv::hl::interact((**sock).hl_loop) {|loop_ptr|\n+        log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n+        alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n+                               on_alloc_cb,\n+                               on_tcp_read_cb) {\n+          0i32 {\n+            log(debug, \"success doing uv_read_start\");\n+            comm::send(start_ch, none);\n+          }\n+          _ {\n+            log(debug, \"error attempting uv_read_start\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send(start_ch, some(err_data));\n+          }\n+        }\n+    };\n+    alt comm::recv(start_po) {\n+      some(err_data) {\n+        tcp_read_start_error(err_data)\n+      }\n+      none {\n+        tcp_read_start_success((**sock).reader_po)\n+      }\n+    }\n+}\n \n+fn read_stop(sock: tcp_socket) -> option<uv::ll::uv_err_data> unsafe {\n+    let stream_handle_ptr = ptr::addr_of((**sock).stream_handle);\n+    let stop_po = comm::port::<option<uv::ll::uv_err_data>>();\n+    let stop_ch = comm::chan(stop_po);\n+    uv::hl::interact((**sock).hl_loop) {|loop_ptr|\n+        log(debug, \"in interact cb for tcp::read_stop\");\n+        alt uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n+          0i32 {\n+            log(debug, \"successfully called uv_read_stop\");\n+            comm::send(stop_ch, none);\n+          }\n+          _ {\n+            log(debug, \"failure in calling uv_read_stop\");\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send(stop_ch, some(err_data));\n+          }\n+        }\n+    };\n+    comm::recv(stop_po)\n+}\n \n // INTERNAL API\n+crust fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n+                    nread: libc::ssize_t,\n+                    ++buf: uv::ll::uv_buf_t) unsafe {\n+    let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n+    let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n+        as *tcp_socket_data;\n+    let reader_ch = (*socket_data_ptr).reader_ch;\n+    alt nread {\n+      // incoming err.. probably eof\n+      -1 {\n+        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+        comm::send(reader_ch, tcp_read_err(err_data));\n+      }\n+      // do nothing .. unneeded buf\n+      0 {}\n+      // have data\n+      _ {\n+        // we have data\n+        log(debug, #fmt(\"tcp on_read_cb nread: %d\", nread));\n+        let buf_base = uv::ll::get_base_from_buf(buf);\n+        let buf_len = uv::ll::get_len_from_buf(buf);\n+        let new_bytes = vec::unsafe::from_buf(buf_base, buf_len);\n+        comm::send(reader_ch, tcp_read_data(new_bytes));\n+      }\n+    }\n+    uv::ll::free_base_of_buf(buf);\n+}\n+\n+crust fn on_alloc_cb(handle: *libc::c_void,\n+                     ++suggested_size: libc::size_t)\n+    -> uv::ll::uv_buf_t unsafe {\n+    log(debug, \"tcp read on_alloc_cb!\");\n+    let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n+    log(debug, #fmt(\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+                     handle,\n+                     char_ptr as uint,\n+                     suggested_size as uint));\n+    uv::ll::buf_init(char_ptr, suggested_size)\n+}\n \n type tcp_socket_close_data = {\n     closed_ch: comm::chan<()>\n@@ -272,9 +375,9 @@ enum conn_attempt {\n     conn_failure(uv::ll::uv_err_data)\n }\n \n-\n type tcp_socket_data = {\n-    reader_port: comm::port<[u8]>,\n+    reader_po: comm::port<tcp_read_result>,\n+    reader_ch: comm::chan<tcp_read_result>,\n     stream_handle: uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n@@ -310,30 +413,52 @@ mod test {\n             alt write(sock, write_data) {\n               tcp_write_success {\n                 log(debug, \"tcp::write successful\");\n-                /*\n                 let mut total_read_data: [u8] = [];\n-                let reader_po = read_start(sock);\n-                loop {\n-                    alt comm::recv(reader_po) {\n-                      new_read_data(data) {\n-                        total_read_data += data;\n-                        // theoretically, we could keep iterating, here, if\n-                        // we expect the server on the other end to keep\n-                        // streaming/chunking data to us, but..\n-                        read_stop(tcp_stream);\n-                        break;\n-                      }\n-                      done_reading {\n-                        break;\n-                      }\n-                      error {\n-                        fail \"erroring occured during read attempt..\"\n-                            + \"FIXME need info\";\n-                      }\n+                alt read_start(sock) {\n+                  tcp_read_start_success(reader_po) {\n+                    loop {\n+                        alt comm::recv(reader_po) {\n+                          tcp_read_data(new_data) {\n+                            total_read_data += new_data;\n+                            // theoretically, we could keep iterating, if\n+                            // we expect the server on the other end to keep\n+                            // streaming/chunking data to us, but..\n+                            alt read_stop(sock) {\n+                              some(err_data) {\n+                                log(debug, \"error while calling read_stop\");\n+                                log(debug, #fmt(\"read_stop error: %? %?\",\n+                                                err_data.err_name,\n+                                                err_data.err_msg));\n+                                assert false;\n+                              }\n+                              none {\n+                                // exiting the read loop\n+                                break;\n+                              }\n+                            }\n+                          }\n+                          tcp_read_done {\n+                            break;\n+                          }\n+                          tcp_read_err(err_data) {\n+                            log(debug, \"read error data recv'd\");\n+                            log(debug, #fmt(\"read error: %? %?\",\n+                                            err_data.err_name,\n+                                            err_data.err_msg));\n+                            assert false;\n+                          }\n+                        }\n                     }\n+                    comm::send(data_ch, total_read_data);\n+                  }\n+                  tcp_read_start_error(err_data) {\n+                    log(debug, \"tcp_read_start_error received..\");\n+                    log(debug, #fmt(\"tcp read_start error: %? %?\",\n+                                    err_data.err_name,\n+                                   err_data.err_msg));\n+                    assert false;\n+                  }\n                 }\n-                comm::send(data_ch, total_read_data);\n-                */\n               }\n               tcp_write_error(err_data) {\n                 log(debug, \"tcp_write_error received..\");"}]}