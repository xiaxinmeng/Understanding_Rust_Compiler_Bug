{"sha": "0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10", "node_id": "C_kwDOAAsO6NoAKDBmY2I4NmIxMjliOWVjMTE5Y2YxZDgxYWJmYWViOGZmMmQwN2FkMTA", "commit": {"author": {"name": "David Koloski", "email": "dkoloski@google.com", "date": "2022-07-20T19:42:17Z"}, "committer": {"name": "David Koloski", "email": "dkoloski@google.com", "date": "2022-07-28T20:37:35Z"}, "message": "Add Fuchsia platform support documentation", "tree": {"sha": "826bb039271f9c181d04e6c79bff03440194aaff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/826bb039271f9c181d04e6c79bff03440194aaff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10", "html_url": "https://github.com/rust-lang/rust/commit/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10/comments", "author": null, "committer": null, "parents": [{"sha": "14dbfebfa25a0e626ad827526934381b2545cbb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/14dbfebfa25a0e626ad827526934381b2545cbb4", "html_url": "https://github.com/rust-lang/rust/commit/14dbfebfa25a0e626ad827526934381b2545cbb4"}], "stats": {"total": 296, "additions": 296, "deletions": 0}, "files": [{"sha": "0bb230d31977fc0df869a4e5c7fcdae3e653fe3f", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10", "patch": "@@ -21,6 +21,7 @@\n     - [armv6k-nintendo-3ds](platform-support/armv6k-nintendo-3ds.md)\n     - [armv7-unknown-linux-uclibceabi](platform-support/armv7-unknown-linux-uclibceabi.md)\n     - [armv7-unknown-linux-uclibceabihf](platform-support/armv7-unknown-linux-uclibceabihf.md)\n+    - [\\*-fuchsia](platform-support/fuchsia.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n     - [m68k-unknown-linux-gnu](platform-support/m68k-unknown-linux-gnu.md)\n     - [mips64-openwrt-linux-musl](platform-support/mips64-openwrt-linux-musl.md)"}, {"sha": "61bd1b425bc35e420ce3e0506e35795dc77ed80d", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=0fcb86b129b9ec119cf1d81abfaeb8ff2d07ad10", "patch": "@@ -0,0 +1,295 @@\n+# `aarch64-fuchsia` and `x86_64-fuchsia`\n+\n+**Tier: 2**\n+\n+[Fuchsia] is a modern open source operating system that's simple, secure,\n+updatable, and performant.\n+\n+[Fuchsia]: https://fuchsia.dev/\n+\n+## Target maintainers\n+\n+The [Fuchsia team]:\n+\n+[Fuchsia team]: https://team-api.infra.rust-lang.org/v1/teams/fuchsia.json\n+\n+- Tyler Mandry ([@tmandry](https://github.com/tmandry))\n+- Dan Johnson ([@computerdruid](https://github.com/computerdruid))\n+- David Koloski ([@djkoloski](https://github.com/djkoloski))\n+- Andrew Pollack ([@andrewpollack](https://github.com/andrewpollack))\n+- Joseph Ryan ([@P1n3appl3](https://github.com/P1n3appl3))\n+\n+As the team evolves over time, the specific members listed here may differ from\n+the members reported by the API. The API should be considered to be\n+authoritative if this occurs. Instead of pinging individual members, use\n+`@rustbot ping fuchsia` to contact the team on GitHub.\n+\n+## Requirements\n+\n+This target is cross-compiled from a host environment. Development may be done\n+from the [source tree] or using the Fuchsia SDK.\n+\n+[source tree]: https://fuchsia.dev/fuchsia-src/get-started/learn/build\n+\n+Fuchsia targets support std and follow the `sysv64` calling convention on\n+x86_64. Fuchsia binaries use the ELF file format.\n+\n+## Building the target\n+\n+Before building Rust for Fuchsia, you'll need a clang toolchain that supports\n+Fuchsia as well. A recent version (14+) of clang should be sufficient to compile\n+Rust for Fuchsia.\n+\n+You'll also need a recent copy of the [Fuchsia SDK], which provides the tools\n+and binaries required to build and link programs for Fuchsia.\n+\n+[Fuchsia SDK]: https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core\n+\n+x86-64 and AArch64 Fuchsia targets can be enabled using the following\n+configuration.\n+\n+In `config.toml`, add:\n+\n+```toml\n+[build]\n+target = [\"<host_platform>\", \"aarch64-fuchsia\", \"x86_64-fuchsia\"]\n+\n+[target.x86_64-fuchsia]\n+llvm-libunwind = \"in-tree\"\n+\n+[target.aarch64-fuchsia]\n+llvm-libunwind = \"in-tree\"\n+```\n+\n+Additionally, the following environment variables must be configured (for\n+example, using a script like `config-env.sh`):\n+\n+```sh\n+# Configure this environment variable to be the path to the downloaded SDK\n+export SDK_PATH=\"<SDK path goes here>\"\n+\n+export CFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export CXXFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export LDFLAGS_aarch64_fuchsia=\"--target=aarch64-fuchsia --sysroot=${SDK_PATH}/arch/arm64/sysroot -L${SDK_PATH}/arch/arm64/lib\"\n+export CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/arm64/sysroot -Lnative=${SDK_PATH}/arch/arm64/sysroot/lib -Lnative=${SDK_PATH}/arch/arm64/lib\"\n+export CFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export CXXFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -I${SDK_PATH}/pkg/fdio/include\"\n+export LDFLAGS_x86_64_fuchsia=\"--target=x86_64-fuchsia --sysroot=${SDK_PATH}/arch/x64/sysroot -L${SDK_PATH}/arch/x64/lib\"\n+export CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS=\"-C link-arg=--sysroot=${SDK_PATH}/arch/x64/sysroot -Lnative=${SDK_PATH}/arch/x64/sysroot/lib -Lnative=${SDK_PATH}/arch/x64/lib\"\n+```\n+\n+These can be run together in a shell environment by executing\n+`(source config-env.sh && ./x.py install)`.\n+\n+## Building Rust programs\n+\n+After compiling Rust binaries, you'll need to build a component, package it, and\n+serve it to a Fuchsia device or emulator. All of this can be done using the\n+Fuchsia SDK.\n+\n+As an example, we'll compile and run this simple program on a Fuchsia emulator:\n+\n+**`hello_fuchsia.rs`**\n+```rust\n+fn main() {\n+    println!(\"Hello Fuchsia!\");\n+}\n+\n+#[test]\n+fn it_works() {\n+    assert_eq!(2 + 2, 4);\n+}\n+```\n+\n+Create a new file named `hello_fuchsia.rs` and fill out its contents with that\n+code.\n+\n+### Create a package\n+\n+On Fuchsia, a package is the unit of distribution for software. We'll need to\n+create a new package directory where we will place files like our finished\n+binary and any data it may need. The working directory will have this layout:\n+\n+```txt\n+hello_fuchsia.rs\n+hello_fuchsia.cml\n+package\n+\u2523\u2501 bin\n+\u2503  \u2517\u2501 hello_fuchsia\n+\u2523\u2501 meta\n+\u2503  \u2523\u2501 package\n+\u2503  \u2517\u2501 hello_fuchsia.cm\n+\u2517\u2501 hello_fuchsia.manifest\n+```\n+\n+Make the `package`, `package/bin`, and `package/meta` directories and create the\n+following files inside:\n+\n+**`package/meta/package`**\n+```json\n+{\"name\":\"hello_fuchsia\",\"version\":0}\n+```\n+\n+The `package` file describes our package's name and version number. Every\n+package must contain one.\n+\n+**`package/hello_fuchsia.manifest`**\n+```txt\n+bin/hello_fuchsia=package/bin/hello_fuchsia\n+lib/ld.so.1=<SDK_PATH>/arch/x64/sysroot/dist/lib/ld.so.1\n+lib/libfdio.so=<SDK_PATH>/arch/x64/dist/libfdio.so\n+meta/package=package/meta/package\n+meta/hello_fuchsia.cm=package/meta/hello_fuchsia.cm\n+```\n+\n+*Note: Relative manifest paths are resolved starting from the working directory\n+of `pm`. Make sure to fill out `<SDK_PATH>` with the path to the downloaded\n+SDK.*\n+\n+The `.manifest` file will be used to describe the contents of the package by\n+relating their location when installed to their location on the file system. You\n+can use this to make a package pull files from other places, but for this\n+example we'll just be placing everything in the `package` directory.\n+\n+### Compiling a binary\n+\n+Using your freshly compiled `rustc`, you can compile a binary for Fuchsia using\n+the following options:\n+\n+* `--target x86_64-fuchsia`/`--target aarch64-fuchsia`: Targets the Fuchsia\n+  platform of your choice\n+* `-Lnative ${SDK_PATH}/arch/${ARCH}/lib`: Link against Fuchsia libraries from\n+  the SDK\n+* `-Lnative ${SDK_PATH}/arch/${ARCH}/sysroot/lib`: Link against Fuchsia kernel\n+  libraries from the SDK\n+\n+Putting it all together:\n+\n+```sh\n+# Configure these for the Fuchsia target of your choice\n+TARGET_ARCH=\"<x86_64-fuchsia|aarch64-fuchsia>\"\n+ARCH=\"<x64|aarch64>\"\n+\n+rustc --target ${TARGET_ARCH} -Lnative=${SDK_PATH}/arch/${ARCH}/lib -Lnative=${SDK_PATH}/arch/${ARCH}/sysroot/lib -o package/bin/hello_fuchsia hello_fuchsia.rs\n+```\n+\n+### Bulding a component\n+\n+On Fuchsia, components require a component manifest written in Fuchia's markup\n+language called CML. The Fuchsia devsite contains an [overview of CML] and a\n+[reference for the file format]. Here's a basic one that can run our single binary:\n+\n+[overview of CML]: https://fuchsia.dev/fuchsia-src/concepts/components/v2/component_manifests\n+[reference for the file format]: https://fuchsia.dev/reference/cml\n+\n+**`hello_fuchsia.cml`**\n+```txt\n+{\n+    include: [ \"syslog/client.shard.cml\" ],\n+    program: {\n+        runner: \"elf\",\n+        binary: \"bin/hello_fuchsia\",\n+    },\n+}\n+```\n+\n+Now we can compile that CML into a component manifest:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/cmc compile hello_fuchsia.cml --includepath ${SDK_PATH}/pkg -o package/meta/hello_fuchsia.cm\n+```\n+\n+`--includepath` tells the compiler where to look for `include`s from our CML.\n+In our case, we're only using `syslog/client.shard.cml`.\n+\n+### Building and publishing a package\n+\n+Next, we'll build our package as defined by our manifest:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/pm -o hello_fuchsia -m package/hello_fuchsia.manifest build -output-package-manifest hello_fuchsia_manifest\n+```\n+\n+This will produce `hello_fuchsia_manifest` which is a package manifest we can\n+publish directly to a repository. We can set up that repository with:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/pm newrepo -repo repo\n+```\n+\n+And then publish our new package to that repository with:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/pm publish -repo repo -lp -f <(echo \"hello_fuchsia_manifest\")\n+```\n+\n+Then we can add it to `ffx`'s package server as `hello-fuchsia` using:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/ffx repository add-from-pm repo -r hello-fuchsia\n+```\n+\n+### Starting the emulator\n+\n+Start a Fuchsia emulator in a new terminal using:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/ffx product-bundle get workstation_eng.qemu-${ARCH}\n+${SDK_PATH}/tools/${ARCH}/ffx emu start workstation_eng.qemu-${ARCH} --headless\n+```\n+\n+Then, once the emulator has been started:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/ffx target repository register\n+```\n+\n+And watch the logs from the emulator in a separate terminal:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/ffx log --since now\n+```\n+\n+Finally, run the component:\n+\n+```sh\n+${SDK_PATH}/tools/${ARCH}/ffx component run fuchsia-pkg://hello-fuchsia/hello_fuchsia#meta/hello_fuchsia.cm\n+```\n+\n+On reruns of the component, the `--recreate` argument may also need to be\n+passed.\n+\n+## Testing\n+\n+### Running unit tests\n+\n+Tests can be run in the same way as a regular binary, simply by passing `--test`\n+to the `rustc` invocation and then repackaging and rerunning. The test harness\n+will run the applicable unit tests.\n+\n+Often when testing, you may want to pass additional command line arguments to\n+your binary. Additional arguments can be set in the component manifest:\n+\n+**`hello_fuchsia.cml`**\n+```txt\n+{\n+    include: [ \"syslog/client.shard.cml\" ],\n+    program: {\n+        runner: \"elf\",\n+        binary: \"bin/hello_fuchsia\",\n+        args: [\"it_works\"],\n+    },\n+}\n+```\n+\n+This will pass the argument `it_works` to the binary, filtering the tests to\n+only those tests that match the pattern. There are many more configuration\n+options available in CML including environment variables. More documentation is\n+available on the [Fuchsia devsite](https://fuchsia.dev/reference/cml).\n+\n+### Running the compiler test suite\n+\n+Running the Rust test suite on Fuchsia is [not currently supported], but work is\n+underway to enable it.\n+\n+[not currently supported]: https://fxbug.dev/105393"}]}