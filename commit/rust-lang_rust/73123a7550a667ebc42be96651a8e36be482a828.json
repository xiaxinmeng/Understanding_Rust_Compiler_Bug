{"sha": "73123a7550a667ebc42be96651a8e36be482a828", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMTIzYTc1NTBhNjY3ZWJjNDJiZTk2NjUxYThlMzZiZTQ4MmE4Mjg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-14T13:40:11Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-14T13:40:11Z"}, "message": "internal: remove SyntaxRewriter", "tree": {"sha": "e074fabfcdfb806685bc2fe75a976f9ce677d64d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e074fabfcdfb806685bc2fe75a976f9ce677d64d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73123a7550a667ebc42be96651a8e36be482a828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73123a7550a667ebc42be96651a8e36be482a828", "html_url": "https://github.com/rust-lang/rust/commit/73123a7550a667ebc42be96651a8e36be482a828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73123a7550a667ebc42be96651a8e36be482a828/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "873717190d2f324ffaa9222914737606eee7a03d", "url": "https://api.github.com/repos/rust-lang/rust/commits/873717190d2f324ffaa9222914737606eee7a03d", "html_url": "https://github.com/rust-lang/rust/commit/873717190d2f324ffaa9222914737606eee7a03d"}], "stats": {"total": 161, "additions": 7, "deletions": 154}, "files": [{"sha": "8fb40e8371f4fe4c1376c852580188787e0093ac", "filename": "crates/ide_db/src/helpers/merge_imports.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73123a7550a667ebc42be96651a8e36be482a828/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73123a7550a667ebc42be96651a8e36be482a828/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs?ref=73123a7550a667ebc42be96651a8e36be482a828", "patch": "@@ -42,10 +42,12 @@ pub fn try_merge_imports(\n         return None;\n     }\n \n+    let lhs = lhs.clone_subtree().clone_for_update();\n     let lhs_tree = lhs.use_tree()?;\n     let rhs_tree = rhs.use_tree()?;\n     let merged = try_merge_trees(&lhs_tree, &rhs_tree, merge_behavior)?;\n-    Some(lhs.with_use_tree(merged).clone_for_update())\n+    ted::replace(lhs_tree.syntax(), merged.syntax());\n+    Some(lhs)\n }\n \n pub fn try_merge_trees("}, {"sha": "241713c48ee9683bec140829a248db2b16d6fbab", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 1, "deletions": 105, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/73123a7550a667ebc42be96651a8e36be482a828/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73123a7550a667ebc42be96651a8e36be482a828/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=73123a7550a667ebc42be96651a8e36be482a828", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use std::{fmt, hash::BuildHasherDefault, ops::RangeInclusive};\n+use std::{hash::BuildHasherDefault, ops::RangeInclusive};\n \n use indexmap::IndexMap;\n use itertools::Itertools;\n@@ -330,110 +330,6 @@ fn _replace_children(\n     with_children(parent, new_children)\n }\n \n-#[derive(Debug, PartialEq, Eq, Hash)]\n-enum InsertPos {\n-    FirstChildOf(SyntaxNode),\n-    After(SyntaxElement),\n-}\n-\n-#[derive(Default)]\n-pub(crate) struct SyntaxRewriter<'a> {\n-    //FIXME: add debug_assertions that all elements are in fact from the same file.\n-    replacements: FxHashMap<SyntaxElement, Replacement>,\n-    insertions: IndexMap<InsertPos, Vec<SyntaxElement>>,\n-    _pd: std::marker::PhantomData<&'a ()>,\n-}\n-\n-impl fmt::Debug for SyntaxRewriter<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SyntaxRewriter\")\n-            .field(\"replacements\", &self.replacements)\n-            .field(\"insertions\", &self.insertions)\n-            .finish()\n-    }\n-}\n-\n-impl SyntaxRewriter<'_> {\n-    pub(crate) fn replace<T: Clone + Into<SyntaxElement>>(&mut self, what: &T, with: &T) {\n-        let what = what.clone().into();\n-        let replacement = Replacement::Single(with.clone().into());\n-        self.replacements.insert(what, replacement);\n-    }\n-\n-    pub(crate) fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n-        let _p = profile::span(\"rewrite\");\n-\n-        if self.replacements.is_empty() && self.insertions.is_empty() {\n-            return node.clone();\n-        }\n-        let green = self.rewrite_children(node);\n-        with_green(node, green)\n-    }\n-\n-    pub(crate) fn rewrite_ast<N: AstNode>(self, node: &N) -> N {\n-        N::cast(self.rewrite(node.syntax())).unwrap()\n-    }\n-\n-    fn replacement(&self, element: &SyntaxElement) -> Option<Replacement> {\n-        self.replacements.get(element).cloned()\n-    }\n-\n-    fn insertions(&self, pos: &InsertPos) -> Option<impl Iterator<Item = SyntaxElement> + '_> {\n-        self.insertions.get(pos).map(|insertions| insertions.iter().cloned())\n-    }\n-\n-    fn rewrite_children(&self, node: &SyntaxNode) -> rowan::GreenNode {\n-        let _p = profile::span(\"rewrite_children\");\n-\n-        //  FIXME: this could be made much faster.\n-        let mut new_children = Vec::new();\n-        if let Some(elements) = self.insertions(&InsertPos::FirstChildOf(node.clone())) {\n-            new_children.extend(elements.map(element_to_green));\n-        }\n-        for child in node.children_with_tokens() {\n-            self.rewrite_self(&mut new_children, &child);\n-        }\n-\n-        rowan::GreenNode::new(rowan::SyntaxKind(node.kind() as u16), new_children)\n-    }\n-\n-    fn rewrite_self(\n-        &self,\n-        acc: &mut Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,\n-        element: &SyntaxElement,\n-    ) {\n-        let _p = profile::span(\"rewrite_self\");\n-\n-        if let Some(replacement) = self.replacement(&element) {\n-            match replacement {\n-                Replacement::Single(element) => acc.push(element_to_green(element)),\n-            };\n-        } else {\n-            match element {\n-                NodeOrToken::Token(it) => acc.push(NodeOrToken::Token(it.green().to_owned())),\n-                NodeOrToken::Node(it) => {\n-                    acc.push(NodeOrToken::Node(self.rewrite_children(it)));\n-                }\n-            }\n-        }\n-        if let Some(elements) = self.insertions(&InsertPos::After(element.clone())) {\n-            acc.extend(elements.map(element_to_green));\n-        }\n-    }\n-}\n-\n-fn element_to_green(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n-    match element {\n-        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().into_owned()),\n-        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().to_owned()),\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-enum Replacement {\n-    Single(SyntaxElement),\n-}\n-\n fn with_children(\n     parent: &SyntaxNode,\n     new_children: Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,"}, {"sha": "10ec94cd2c36da139724a5bfe6391298d78decd1", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/73123a7550a667ebc42be96651a8e36be482a828/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73123a7550a667ebc42be96651a8e36be482a828/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=73123a7550a667ebc42be96651a8e36be482a828", "patch": "@@ -2,18 +2,18 @@\n //! immutable, all function here return a fresh copy of the tree, instead of\n //! doing an in-place modification.\n use std::{\n-    array, fmt, iter,\n+    fmt, iter,\n     ops::{self, RangeInclusive},\n };\n \n use arrayvec::ArrayVec;\n \n use crate::{\n-    algo::{self, SyntaxRewriter},\n+    algo,\n     ast::{\n         self,\n         make::{self, tokens},\n-        AstNode, GenericParamsOwner, NameOwner, TypeBoundsOwner,\n+        AstNode, TypeBoundsOwner,\n     },\n     ted, AstToken, Direction, InsertPosition, NodeOrToken, SmolStr, SyntaxElement, SyntaxKind,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n@@ -46,18 +46,6 @@ impl ast::Fn {\n         to_insert.push(body.syntax().clone().into());\n         self.replace_children(single_node(old_body_or_semi), to_insert)\n     }\n-\n-    #[must_use]\n-    pub fn with_generic_param_list(&self, generic_args: ast::GenericParamList) -> ast::Fn {\n-        if let Some(old) = self.generic_param_list() {\n-            return self.replace_descendant(old, generic_args);\n-        }\n-\n-        let anchor = self.name().expect(\"The function must have a name\").syntax().clone();\n-\n-        let to_insert = [generic_args.syntax().clone().into()];\n-        self.insert_children(InsertPosition::After(anchor.into()), array::IntoIter::new(to_insert))\n-    }\n }\n \n fn make_multiline<N>(node: N) -> N\n@@ -313,33 +301,7 @@ impl ast::PathSegment {\n     }\n }\n \n-impl ast::Use {\n-    #[must_use]\n-    pub fn with_use_tree(&self, use_tree: ast::UseTree) -> ast::Use {\n-        if let Some(old) = self.use_tree() {\n-            return self.replace_descendant(old, use_tree);\n-        }\n-        self.clone()\n-    }\n-}\n-\n impl ast::UseTree {\n-    #[must_use]\n-    pub fn with_path(&self, path: ast::Path) -> ast::UseTree {\n-        if let Some(old) = self.path() {\n-            return self.replace_descendant(old, path);\n-        }\n-        self.clone()\n-    }\n-\n-    #[must_use]\n-    pub fn with_use_tree_list(&self, use_tree_list: ast::UseTreeList) -> ast::UseTree {\n-        if let Some(old) = self.use_tree_list() {\n-            return self.replace_descendant(old, use_tree_list);\n-        }\n-        self.clone()\n-    }\n-\n     /// Splits off the given prefix, making it the path component of the use tree, appending the rest of the path to all UseTreeList items.\n     #[must_use]\n     pub fn split_prefix(&self, prefix: &ast::Path) -> ast::UseTree {\n@@ -664,13 +626,6 @@ pub trait AstNodeEdit: AstNode + Clone + Sized {\n         let new_syntax = algo::replace_children(self.syntax(), to_replace, to_insert);\n         Self::cast(new_syntax).unwrap()\n     }\n-\n-    #[must_use]\n-    fn replace_descendant<D: AstNode>(&self, old: D, new: D) -> Self {\n-        let mut rewriter = SyntaxRewriter::default();\n-        rewriter.replace(old.syntax(), new.syntax());\n-        rewriter.rewrite_ast(self)\n-    }\n     fn indent_level(&self) -> IndentLevel {\n         IndentLevel::from_node(self.syntax())\n     }"}]}