{"sha": "c1d977a638064e3ad8c1343d4b146e99607525ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZDk3N2E2MzgwNjRlM2FkOGMxMzQzZDRiMTQ2ZTk5NjA3NTI1YmE=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-09-12T19:11:06Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-09-16T11:26:50Z"}, "message": "Update rustdoc_ng to syntax and metadata changes", "tree": {"sha": "67b1ebfdc7fabf9343b37d99b8ed5ec699dbafb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b1ebfdc7fabf9343b37d99b8ed5ec699dbafb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d977a638064e3ad8c1343d4b146e99607525ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d977a638064e3ad8c1343d4b146e99607525ba", "html_url": "https://github.com/rust-lang/rust/commit/c1d977a638064e3ad8c1343d4b146e99607525ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d977a638064e3ad8c1343d4b146e99607525ba/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be2f85e24f50e365de76af2bff8e33e848f8f1d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/be2f85e24f50e365de76af2bff8e33e848f8f1d1", "html_url": "https://github.com/rust-lang/rust/commit/be2f85e24f50e365de76af2bff8e33e848f8f1d1"}], "stats": {"total": 111, "additions": 54, "deletions": 57}, "files": [{"sha": "aae3be7001ac988604f2033ff84aea52d2385013", "filename": "src/rustdoc_ng/clean.rs", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fclean.rs?ref=c1d977a638064e3ad8c1343d4b146e99607525ba", "patch": "@@ -3,7 +3,6 @@\n \n use its = syntax::parse::token::ident_to_str;\n \n-use rustc::metadata::{csearch,decoder,cstore};\n use syntax;\n use syntax::ast;\n \n@@ -500,7 +499,7 @@ impl Clean<Type> for ast::Ty {\n         let t = match self.node {\n             ty_nil => Unit,\n             ty_ptr(ref m) =>  RawPointer(m.mutbl.clean(), ~resolve_type(&m.ty.clean())),\n-            ty_rptr(ref l, ref m) => \n+            ty_rptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n                              type_: ~resolve_type(&m.ty.clean())},\n             ty_box(ref m) => Managed(m.mutbl.clean(), ~resolve_type(&m.ty.clean())),\n@@ -666,17 +665,32 @@ impl Clean<~str> for syntax::codemap::Span {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Path {\n-    name: ~str,\n-    lifetime: Option<Lifetime>,\n-    typarams: ~[Type]\n+    global: bool,\n+    segments: ~[PathSegment],\n }\n \n impl Clean<Path> for ast::Path {\n     fn clean(&self) -> Path {\n         Path {\n-            name: path_to_str(self),\n-            lifetime: self.rp.clean(),\n-            typarams: self.types.clean(),\n+            global: self.global,\n+            segments: self.segments.clean()\n+        }\n+    }\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct PathSegment {\n+    name: ~str,\n+    lifetime: Option<Lifetime>,\n+    types: ~[Type],\n+}\n+\n+impl Clean<PathSegment> for ast::PathSegment {\n+    fn clean(&self) -> PathSegment {\n+        PathSegment {\n+            name: self.identifier.clean(),\n+            lifetime: self.lifetime.clean(),\n+            types: self.types.clean()\n         }\n     }\n }\n@@ -686,7 +700,7 @@ fn path_to_str(p: &ast::Path) -> ~str {\n \n     let mut s = ~\"\";\n     let mut first = true;\n-    for i in p.idents.iter().map(|x| interner_get(x.name)) {\n+    for i in p.segments.iter().map(|x| interner_get(x.identifier.name)) {\n         if !first || p.global {\n             s.push_str(\"::\");\n         } else {\n@@ -899,7 +913,7 @@ impl ToSource for syntax::codemap::Span {\n fn lit_to_str(lit: &ast::lit) -> ~str {\n     match lit.node {\n         ast::lit_str(st) => st.to_owned(),\n-        ast::lit_int(ch, ast::ty_char) => ~\"'\" + ch.to_str() + \"'\",\n+        ast::lit_char(c) => ~\"'\" + std::char::from_u32(c).unwrap().to_str() + \"'\",\n         ast::lit_int(i, _t) => i.to_str(),\n         ast::lit_uint(u, _t) => u.to_str(),\n         ast::lit_int_unsuffixed(i) => i.to_str(),\n@@ -966,7 +980,7 @@ fn resolve_type(t: &Type) -> Type {\n \n     let def_id = match *d {\n         DefFn(i, _) => i,\n-        DefSelf(i, _) | DefSelfTy(i) => return Self(i),\n+        DefSelf(i) | DefSelfTy(i) => return Self(i),\n         DefTy(i) => i,\n         DefTrait(i) => {\n             debug!(\"saw DefTrait in def_to_id\");\n@@ -979,58 +993,41 @@ fn resolve_type(t: &Type) -> Type {\n         },\n         DefTyParam(i, _) => return Generic(i.node),\n         DefStruct(i) => i,\n-        DefTyParamBinder(i) => { \n+        DefTyParamBinder(i) => {\n             debug!(\"found a typaram_binder, what is it? %d\", i);\n             return TyParamBinder(i);\n         },\n         x => fail!(\"resolved type maps to a weird def %?\", x),\n     };\n \n     if def_id.crate != ast::CRATE_NODE_ID {\n+        use rustc::metadata::decoder::*;\n+\n         let sess = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess;\n-        let mut path = ~\"\";\n-        let mut ty = ~\"\";\n-        do csearch::each_path(sess.cstore, def_id.crate) |pathstr, deflike, _vis| {\n-            match deflike {\n-                decoder::DlDef(di) => {\n-                    let d2 = match di {\n-                        DefFn(i, _) | DefTy(i) | DefTrait(i) |\n-                            DefStruct(i) | DefMod(i) => Some(i),\n-                        _ => None,\n-                    };\n-                    if d2.is_some() {\n-                        let d2 = d2.unwrap();\n-                        if def_id.node == d2.node {\n-                            debug!(\"found external def: %?\", di);\n-                            path = pathstr.to_owned();\n-                            ty = match di {\n-                                DefFn(*) => ~\"fn\",\n-                                DefTy(*) => ~\"enum\",\n-                                DefTrait(*) => ~\"trait\",\n-                                DefPrimTy(p) => match p {\n-                                    ty_str => ~\"str\",\n-                                    ty_bool => ~\"bool\",\n-                                    ty_int(t) => match t.to_str() {\n-                                        ~\"\" => ~\"i\",\n-                                        s => s\n-                                    },\n-                                    ty_uint(t) => t.to_str(),\n-                                    ty_float(t) => t.to_str()\n-                                },\n-                                DefTyParam(*) => ~\"generic\",\n-                                DefStruct(*) => ~\"struct\",\n-                                DefTyParamBinder(*) => ~\"typaram_binder\",\n-                                x => fail!(\"resolved external maps to a weird def %?\", x),\n-                            };\n-\n-                        }\n-                    }\n+        let cratedata = ::rustc::metadata::cstore::get_crate_data(sess.cstore, def_id.crate);\n+        let doc = lookup_item(def_id.node, cratedata.data);\n+        let path = syntax::ast_map::path_to_str_with_sep(item_path(doc), \"::\", sess.intr());\n+        let ty = match def_like_to_def(item_to_def_like(doc, def_id, def_id.crate)) {\n+            DefFn(*) => ~\"fn\",\n+            DefTy(*) => ~\"enum\",\n+            DefTrait(*) => ~\"trait\",\n+            DefPrimTy(p) => match p {\n+                ty_str => ~\"str\",\n+                ty_bool => ~\"bool\",\n+                ty_int(t) => match t.to_str() {\n+                    ~\"\" => ~\"i\",\n+                    s => s\n                 },\n-                _ => (),\n-            };\n-            true\n+                ty_uint(t) => t.to_str(),\n+                ty_float(t) => t.to_str(),\n+                ty_char => ~\"char\",\n+            },\n+            DefTyParam(*) => ~\"generic\",\n+            DefStruct(*) => ~\"struct\",\n+            DefTyParamBinder(*) => ~\"typaram_binder\",\n+            x => fail!(\"resolved external maps to a weird def %?\", x),\n         };\n-        let cname = cstore::get_crate_data(sess.cstore, def_id.crate).name.to_owned();\n+        let cname = cratedata.name.to_owned();\n         External(cname + \"::\" + path, ty)\n     } else {\n         ResolvedPath {path: path.clone(), typarams: tpbs.clone(), id: def_id.node}"}, {"sha": "0a948bd73eb08fbc4021d8902fc69c852dd2628e", "filename": "src/rustdoc_ng/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fcore.rs?ref=c1d977a638064e3ad8c1343d4b146e99607525ba", "patch": "@@ -42,7 +42,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: ~[Path]) -> DocContext {\n                                                   syntax::diagnostic::emit,\n                                                   span_diagnostic_handler);\n \n-    let mut cfg = build_configuration(sess, @\"rustdoc_ng\", &input);\n+    let mut cfg = build_configuration(sess);\n     cfg.push(@dummy_spanned(ast::MetaWord(@\"stage2\")));\n \n     let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);"}, {"sha": "e3ce6e80ae4020d66cd3e54a1ee308ac1531dae5", "filename": "src/rustdoc_ng/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Ffold.rs?ref=c1d977a638064e3ad8c1343d4b146e99607525ba", "patch": "@@ -1,6 +1,6 @@\n use std;\n use clean::*;\n-use std::iterator::Extendable;\n+use std::iter::Extendable;\n \n pub trait DocFolder {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {"}, {"sha": "30fa0f56a4313c3ac4104636b7f500ee6545f48c", "filename": "src/rustdoc_ng/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d977a638064e3ad8c1343d4b146e99607525ba/src%2Frustdoc_ng%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc_ng%2Fpasses.rs?ref=c1d977a638064e3ad8c1343d4b146e99607525ba", "patch": "@@ -173,7 +173,7 @@ fn clean_comment_body(s: ~str) -> ~str {\n         1 => return lines[0].slice_from(2).trim().to_owned(),\n         _ => (),\n     }\n-            \n+\n     let mut ol = std::vec::with_capacity(lines.len());\n     for line in lines.clone().move_iter() {\n         // replace meaningless things with a single newline\n@@ -184,7 +184,7 @@ fn clean_comment_body(s: ~str) -> ~str {\n         }\n     }\n     let li = longest_common_prefix(ol.clone());\n-    \n+\n     let x = ol.iter()\n          .filter(|x| { debug!(\"cleaning line: %s\", **x); true })\n          .map(|x| if x.len() == 0 { ~\"\" } else { x.slice_chars(li, x.char_len()).to_owned() })"}]}