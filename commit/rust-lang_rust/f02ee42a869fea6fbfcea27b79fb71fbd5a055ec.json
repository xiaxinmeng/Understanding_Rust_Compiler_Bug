{"sha": "f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMmVlNDJhODY5ZmVhNmZiZmNlYTI3Yjc5ZmI3MWZiZDVhMDU1ZWM=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-03-26T12:04:54Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-03-28T02:04:23Z"}, "message": "derive Eq and Clone impls where applicable", "tree": {"sha": "ed6a17927a2a9bfd7b337338ffb9572d6e188ede", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed6a17927a2a9bfd7b337338ffb9572d6e188ede"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "html_url": "https://github.com/rust-lang/rust/commit/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f6013a625cefcf914ed890c297a87dacf7bb91", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f6013a625cefcf914ed890c297a87dacf7bb91", "html_url": "https://github.com/rust-lang/rust/commit/f7f6013a625cefcf914ed890c297a87dacf7bb91"}], "stats": {"total": 324, "additions": 21, "deletions": 303}, "files": [{"sha": "4d6226a5db6975dde6c0a14aa59880848e7a77ee", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -111,7 +111,6 @@ use middle::typeck;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n-use core::cmp;\n use core::hashmap::linear::LinearMap;\n use core::io::WriterUtil;\n use core::io;\n@@ -137,58 +136,19 @@ use syntax::{visit, ast_util};\n // if it detects an outstanding loan (that is, the addr is taken).\n pub type last_use_map = @mut LinearMap<node_id, @mut ~[node_id]>;\n \n+#[deriving(Eq)]\n struct Variable(uint);\n+#[deriving(Eq)]\n struct LiveNode(uint);\n \n-impl cmp::Eq for Variable {\n-    fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }\n-    fn ne(&self, other: &Variable) -> bool { *(*self) != *(*other) }\n-}\n-\n-impl cmp::Eq for LiveNode {\n-    fn eq(&self, other: &LiveNode) -> bool { *(*self) == *(*other) }\n-    fn ne(&self, other: &LiveNode) -> bool { *(*self) != *(*other) }\n-}\n-\n+#[deriving(Eq)]\n enum LiveNodeKind {\n     FreeVarNode(span),\n     ExprNode(span),\n     VarDefNode(span),\n     ExitNode\n }\n \n-impl cmp::Eq for LiveNodeKind {\n-    fn eq(&self, other: &LiveNodeKind) -> bool {\n-        match (*self) {\n-            FreeVarNode(e0a) => {\n-                match (*other) {\n-                    FreeVarNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExprNode(e0a) => {\n-                match (*other) {\n-                    ExprNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            VarDefNode(e0a) => {\n-                match (*other) {\n-                    VarDefNode(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ExitNode => {\n-                match (*other) {\n-                    ExitNode => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    fn ne(&self, other: &LiveNodeKind) -> bool { !(*self).eq(other) }\n-}\n-\n fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     let cm = cx.sess.codemap;\n     match lnk {"}, {"sha": "e9769f14b72dadc57412e6bc43c0e001cb77b2c5", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -18,13 +18,13 @@ use lib::llvm::struct_tys;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n-use core::cmp;\n use core::libc::c_uint;\n use core::option;\n use core::option::Option;\n use core::uint;\n use core::vec;\n \n+#[deriving(Eq)]\n enum x86_64_reg_class {\n     no_class,\n     integer_class,\n@@ -40,13 +40,6 @@ enum x86_64_reg_class {\n     memory_class\n }\n \n-impl cmp::Eq for x86_64_reg_class {\n-    fn eq(&self, other: &x86_64_reg_class) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    fn ne(&self, other: &x86_64_reg_class) -> bool { !(*self).eq(other) }\n-}\n-\n fn is_sse(++c: x86_64_reg_class) -> bool {\n     return match c {\n         sse_fs_class | sse_fv_class |"}, {"sha": "164f6fe44fc6d8680f5c5a827479936bbb8e1526", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -104,7 +104,6 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n-use core::cmp;\n use core::container::Set; // XXX: this should not be necessary\n use core::to_bytes;\n use core::uint;\n@@ -140,6 +139,7 @@ pub struct DatumBlock {\n     datum: Datum,\n }\n \n+#[deriving(Eq)]\n pub enum DatumMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,\n@@ -158,13 +158,6 @@ pub impl DatumMode {\n     }\n }\n \n-impl cmp::Eq for DatumMode {\n-    fn eq(&self, other: &DatumMode) -> bool {\n-        (*self) as uint == (*other as uint)\n-    }\n-    fn ne(&self, other: &DatumMode) -> bool { !(*self).eq(other) }\n-}\n-\n impl to_bytes::IterBytes for DatumMode {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f)"}, {"sha": "3e1496692ae47692e5f1aee142a9818776e572a3", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -160,6 +160,7 @@ use syntax::codemap;\n // These are passed around by the code generating functions to track the\n // destination of a computation's value.\n \n+#[deriving(Eq)]\n pub enum Dest {\n     SaveIn(ValueRef),\n     Ignore,\n@@ -174,18 +175,6 @@ pub impl Dest {\n     }\n }\n \n-impl cmp::Eq for Dest {\n-    fn eq(&self, other: &Dest) -> bool {\n-        match ((*self), (*other)) {\n-            (SaveIn(e0a), SaveIn(e0b)) => e0a == e0b,\n-            (Ignore, Ignore) => true,\n-            (SaveIn(*), _) => false,\n-            (Ignore, _) => false,\n-        }\n-    }\n-    fn ne(&self, other: &Dest) -> bool { !(*self).eq(other) }\n-}\n-\n fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n     let bcx = dat.drop_val(bcx);\n     dat.cancel_clean(bcx);\n@@ -1682,6 +1671,7 @@ fn float_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n     } else { llsrc };\n }\n \n+#[deriving(Eq)]\n pub enum cast_kind {\n     cast_pointer,\n     cast_integral,\n@@ -1690,24 +1680,6 @@ pub enum cast_kind {\n     cast_other,\n }\n \n-impl cmp::Eq for cast_kind {\n-    fn eq(&self, other: &cast_kind) -> bool {\n-        match ((*self), (*other)) {\n-            (cast_pointer, cast_pointer) => true,\n-            (cast_integral, cast_integral) => true,\n-            (cast_float, cast_float) => true,\n-            (cast_enum, cast_enum) => true,\n-            (cast_other, cast_other) => true,\n-            (cast_pointer, _) => false,\n-            (cast_integral, _) => false,\n-            (cast_float, _) => false,\n-            (cast_enum, _) => false,\n-            (cast_other, _) => false,\n-        }\n-    }\n-    fn ne(&self, other: &cast_kind) -> bool { !(*self).eq(other) }\n-}\n-\n pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_float(*)   => cast_float,"}, {"sha": "088d8183d4818c2c4dee1b07240fe2f5152b4876", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 135, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -76,6 +76,7 @@ pub struct method {\n     def_id: ast::def_id\n }\n \n+#[deriving(Eq)]\n pub struct mt {\n     ty: t,\n     mutbl: ast::mutability,\n@@ -161,22 +162,9 @@ pub type opt_region_variance = Option<region_variance>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving(Eq)]\n pub enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n-impl cmp::Eq for region_variance {\n-    fn eq(&self, other: &region_variance) -> bool {\n-        match ((*self), (*other)) {\n-            (rv_covariant, rv_covariant) => true,\n-            (rv_invariant, rv_invariant) => true,\n-            (rv_contravariant, rv_contravariant) => true,\n-            (rv_covariant, _) => false,\n-            (rv_invariant, _) => false,\n-            (rv_contravariant, _) => false\n-        }\n-    }\n-    fn ne(&self, other: &region_variance) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n pub enum AutoAdjustment {\n@@ -417,6 +405,7 @@ impl to_bytes::IterBytes for param_ty {\n /// Representation of regions:\n #[auto_encode]\n #[auto_decode]\n+#[deriving(Eq)]\n pub enum Region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -446,6 +435,7 @@ pub enum Region {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving(Eq)]\n pub enum bound_region {\n     /// The self region for structs, impls (&T in a type defn or &'self T)\n     br_self,\n@@ -585,6 +575,7 @@ pub enum type_err {\n     terr_float_mismatch(expected_found<ast::float_ty>)\n }\n \n+#[deriving(Eq)]\n pub enum param_bound {\n     bound_copy,\n     bound_durable,\n@@ -4367,127 +4358,6 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n     }\n }\n \n-impl cmp::Eq for mt {\n-    fn eq(&self, other: &mt) -> bool {\n-        (*self).ty == (*other).ty && (*self).mutbl == (*other).mutbl\n-    }\n-    fn ne(&self, other: &mt) -> bool { !(*self).eq(other) }\n-}\n-\n-impl cmp::Eq for Region {\n-    fn eq(&self, other: &Region) -> bool {\n-        match (*self) {\n-            re_bound(e0a) => {\n-                match (*other) {\n-                    re_bound(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_free(e0a, e1a) => {\n-                match (*other) {\n-                    re_free(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            re_scope(e0a) => {\n-                match (*other) {\n-                    re_scope(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            re_static => {\n-                match (*other) {\n-                    re_static => true,\n-                    _ => false\n-                }\n-            }\n-            re_infer(e0a) => {\n-                match (*other) {\n-                    re_infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    fn ne(&self, other: &Region) -> bool { !(*self).eq(other) }\n-}\n-\n-impl cmp::Eq for bound_region {\n-    fn eq(&self, other: &bound_region) -> bool {\n-        match (*self) {\n-            br_self => {\n-                match (*other) {\n-                    br_self => true,\n-                    _ => false\n-                }\n-            }\n-            br_anon(e0a) => {\n-                match (*other) {\n-                    br_anon(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_named(e0a) => {\n-                match (*other) {\n-                    br_named(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            br_cap_avoid(e0a, e1a) => {\n-                match (*other) {\n-                    br_cap_avoid(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            br_fresh(e0a) => {\n-                match (*other) {\n-                    br_fresh(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n-}\n-\n-impl cmp::Eq for param_bound {\n-    fn eq(&self, other: &param_bound) -> bool {\n-        match (*self) {\n-            bound_copy => {\n-                match (*other) {\n-                    bound_copy => true,\n-                    _ => false\n-                }\n-            }\n-            bound_durable => {\n-                match (*other) {\n-                    bound_durable => true,\n-                    _ => false\n-                }\n-            }\n-            bound_owned => {\n-                match (*other) {\n-                    bound_owned => true,\n-                    _ => false\n-                }\n-            }\n-            bound_const => {\n-                match (*other) {\n-                    bound_const => true,\n-                    _ => false\n-                }\n-            }\n-            bound_trait(e0a) => {\n-                match (*other) {\n-                    bound_trait(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    fn ne(&self, other: &param_bound) -> bool { !self.eq(other) }\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "24d763eaee13f3090017f6d480485e1e9f234959", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -548,40 +548,20 @@ use util::common::indenter;\n use util::ppaux::note_and_explain_region;\n \n use core::cell::{Cell, empty_cell};\n-use core::cmp;\n use core::hashmap::linear::{LinearMap, LinearSet};\n use core::result::{Err, Ok, Result};\n use core::to_bytes;\n use core::uint;\n use core::vec;\n use syntax::codemap::span;\n \n+#[deriving(Eq)]\n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),\n     ConstrainVarSubReg(RegionVid, Region)\n }\n \n-impl cmp::Eq for Constraint {\n-    fn eq(&self, other: &Constraint) -> bool {\n-        match ((*self), (*other)) {\n-            (ConstrainVarSubVar(v0a, v1a), ConstrainVarSubVar(v0b, v1b)) => {\n-                v0a == v0b && v1a == v1b\n-            }\n-            (ConstrainRegSubVar(ra, va), ConstrainRegSubVar(rb, vb)) => {\n-                ra == rb && va == vb\n-            }\n-            (ConstrainVarSubReg(va, ra), ConstrainVarSubReg(vb, rb)) => {\n-                va == vb && ra == rb\n-            }\n-            (ConstrainVarSubVar(*), _) => false,\n-            (ConstrainRegSubVar(*), _) => false,\n-            (ConstrainVarSubReg(*), _) => false\n-        }\n-    }\n-    fn ne(&self, other: &Constraint) -> bool { !(*self).eq(other) }\n-}\n-\n impl to_bytes::IterBytes for Constraint {\n    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         match *self {\n@@ -597,18 +577,12 @@ impl to_bytes::IterBytes for Constraint {\n     }\n }\n \n+#[deriving(Eq)]\n struct TwoRegions {\n     a: Region,\n     b: Region,\n }\n \n-impl cmp::Eq for TwoRegions {\n-    fn eq(&self, other: &TwoRegions) -> bool {\n-        (*self).a == (*other).a && (*self).b == (*other).b\n-    }\n-    fn ne(&self, other: &TwoRegions) -> bool { !(*self).eq(other) }\n-}\n-\n impl to_bytes::IterBytes for TwoRegions {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.a, &self.b, lsb0, f)"}, {"sha": "5bf7e18552ff60f5c0df6874e5ec441ad0eb85ad", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -45,18 +45,11 @@ enum Msg {\n     Exit\n }\n \n+#[deriving(Clone)]\n pub struct Srv {\n     ch: SharedChan<Msg>\n }\n \n-impl Clone for Srv {\n-    fn clone(&self) -> Srv {\n-        Srv {\n-            ch: self.ch.clone()\n-        }\n-    }\n-}\n-\n pub fn from_str<T>(source: ~str, owner: SrvOwner<T>) -> T {\n     run(owner, copy source, parse::from_str_sess)\n }"}, {"sha": "2b95d42f40e759d71e1efb60ed2a660f089e6178", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -11,7 +11,6 @@\n use core::prelude::*;\n \n use core::cell::Cell;\n-use core::cmp;\n use core::os;\n use core::result;\n use core::run;\n@@ -21,35 +20,23 @@ use core::result::Result;\n use std::getopts;\n \n /// The type of document to output\n+#[deriving(Eq)]\n pub enum OutputFormat {\n     /// Markdown\n     pub Markdown,\n     /// HTML, via markdown and pandoc\n     pub PandocHtml\n }\n \n-impl cmp::Eq for OutputFormat {\n-    fn eq(&self, other: &OutputFormat) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    fn ne(&self, other: &OutputFormat) -> bool { !(*self).eq(other) }\n-}\n-\n /// How to organize the output\n+#[deriving(Eq)]\n pub enum OutputStyle {\n     /// All in a single document\n     pub DocPerCrate,\n     /// Each module in its own document\n     pub DocPerMod\n }\n \n-impl cmp::Eq for OutputStyle {\n-    fn eq(&self, other: &OutputStyle) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    fn ne(&self, other: &OutputStyle) -> bool { !(*self).eq(other) }\n-}\n-\n /// The configuration for a rustdoc session\n pub struct Config {\n     input_crate: Path,"}, {"sha": "90e8c0aa6168025d1a1bba9c8ab401f9417cd72f", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -19,7 +19,6 @@ use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n-use core::cmp;\n use core::either::Either;\n use core::vec;\n use core::hashmap::linear::LinearSet;\n@@ -325,20 +324,14 @@ pub fn foreign_abi(attrs: &[ast::attribute])\n     };\n }\n \n+#[deriving(Eq)]\n pub enum inline_attr {\n     ia_none,\n     ia_hint,\n     ia_always,\n     ia_never,\n }\n \n-impl cmp::Eq for inline_attr {\n-    fn eq(&self, other: &inline_attr) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    fn ne(&self, other: &inline_attr) -> bool { !(*self).eq(other) }\n-}\n-\n /// True if something like #[inline] is found in the list of attrs.\n pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]"}, {"sha": "b086670956e243bcbbd5c4575252ed570364182e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -35,10 +35,12 @@ pub trait Pos {\n }\n \n /// A byte offset\n+#[deriving(Eq)]\n pub struct BytePos(uint);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n+#[deriving(Eq)]\n pub struct CharPos(uint);\n \n // XXX: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -49,11 +51,6 @@ impl Pos for BytePos {\n     fn to_uint(&self) -> uint { **self }\n }\n \n-impl cmp::Eq for BytePos {\n-    fn eq(&self, other: &BytePos) -> bool { **self == **other }\n-    fn ne(&self, other: &BytePos) -> bool { !(*self).eq(other) }\n-}\n-\n impl cmp::Ord for BytePos {\n     fn lt(&self, other: &BytePos) -> bool { **self < **other }\n     fn le(&self, other: &BytePos) -> bool { **self <= **other }\n@@ -84,11 +81,6 @@ impl Pos for CharPos {\n     fn to_uint(&self) -> uint { **self }\n }\n \n-impl cmp::Eq for CharPos {\n-    fn eq(&self, other: &CharPos) -> bool { **self == **other }\n-    fn ne(&self, other: &CharPos) -> bool { !(*self).eq(other) }\n-}\n-\n impl cmp::Ord for CharPos {\n     fn lt(&self, other: &CharPos) -> bool { **self < **other }\n     fn le(&self, other: &CharPos) -> bool { **self <= **other }"}, {"sha": "e5685cdb4c7d1a50f497d4f1031065e02446a0ee", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f02ee42a869fea6fbfcea27b79fb71fbd5a055ec/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=f02ee42a869fea6fbfcea27b79fb71fbd5a055ec", "patch": "@@ -20,29 +20,20 @@ use parse::lexer;\n use parse::token;\n use parse;\n \n-use core::cmp;\n use core::io::ReaderUtil;\n use core::io;\n use core::str;\n use core::uint;\n use core::vec;\n \n+#[deriving(Eq)]\n pub enum cmnt_style {\n     isolated, // No code on either side of each line of the comment\n     trailing, // Code exists to the left of the comment\n     mixed, // Code before /* foo */ and after the comment\n     blank_line, // Just a manual blank line \"\\n\\n\", for layout\n }\n \n-impl cmp::Eq for cmnt_style {\n-    fn eq(&self, other: &cmnt_style) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    fn ne(&self, other: &cmnt_style) -> bool {\n-        ((*self) as uint) != ((*other) as uint)\n-    }\n-}\n-\n pub struct cmnt {\n     style: cmnt_style,\n     lines: ~[~str],"}]}