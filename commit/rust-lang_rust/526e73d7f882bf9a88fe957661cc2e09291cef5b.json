{"sha": "526e73d7f882bf9a88fe957661cc2e09291cef5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNmU3M2Q3Zjg4MmJmOWE4OGZlOTU3NjYxY2MyZTA5MjkxY2VmNWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-08T17:14:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-02-08T17:14:59Z"}, "message": "make shape code use the tydesc found in the box, not the shape str", "tree": {"sha": "78c551a1d0c7d0bbd5d337eb606cc1f570ecc6d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78c551a1d0c7d0bbd5d337eb606cc1f570ecc6d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/526e73d7f882bf9a88fe957661cc2e09291cef5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/526e73d7f882bf9a88fe957661cc2e09291cef5b", "html_url": "https://github.com/rust-lang/rust/commit/526e73d7f882bf9a88fe957661cc2e09291cef5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/526e73d7f882bf9a88fe957661cc2e09291cef5b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a1e33e134cf3adc8a1844b59f57828478b36aff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1e33e134cf3adc8a1844b59f57828478b36aff", "html_url": "https://github.com/rust-lang/rust/commit/3a1e33e134cf3adc8a1844b59f57828478b36aff"}], "stats": {"total": 134, "additions": 88, "deletions": 46}, "files": [{"sha": "ec54b1ef181133c676a9c3d230e8b5845766a152", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/526e73d7f882bf9a88fe957661cc2e09291cef5b/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/526e73d7f882bf9a88fe957661cc2e09291cef5b/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=526e73d7f882bf9a88fe957661cc2e09291cef5b", "patch": "@@ -93,7 +93,11 @@ class irc : public shape::data<irc,shape::ptr> {\n     }\n \n     void walk_box2() {\n-        shape::data<irc,shape::ptr>::walk_box_contents1();\n+        // the box ptr can be NULL for env ptrs in closures and data\n+        // not fully initialized\n+        rust_opaque_box *box = *(rust_opaque_box**)dp;\n+        if (box)\n+            shape::data<irc,shape::ptr>::walk_box_contents1();\n     }\n \n     void walk_uniq2() {\n@@ -103,8 +107,6 @@ class irc : public shape::data<irc,shape::ptr> {\n     void walk_fn2(char code) {\n         switch (code) {\n           case shape::SHAPE_BOX_FN: {\n-              // Record an irc for the environment box, but don't descend\n-              // into it since it will be walked via the box's allocation\n               shape::bump_dp<void*>(dp); // skip over the code ptr\n               walk_box2();               // walk over the environment ptr\n               break;\n@@ -137,19 +139,19 @@ class irc : public shape::data<irc,shape::ptr> {\n \n     void walk_uniq_contents2(irc &sub) { sub.walk(); }\n \n-    void walk_box_contents2(irc &sub, shape::ptr &box_dp) {\n-        maybe_record_irc(box_dp);\n+    void walk_box_contents2(irc &sub) {\n+        maybe_record_irc();\n \n         // Do not traverse the contents of this box; it's in the allocation\n         // somewhere, so we're guaranteed to come back to it (if we haven't\n         // traversed it already).\n     }\n \n-    void maybe_record_irc(shape::ptr &box_dp) {\n-        if (!box_dp)\n-            return;\n+    void maybe_record_irc() {\n+        rust_opaque_box *box_ptr = *(rust_opaque_box **) dp;\n \n-        rust_opaque_box *box_ptr = (rust_opaque_box *) box_dp;\n+        if (!box_ptr)\n+            return;\n \n         // Bump the internal reference count of the box.\n         if (ircs.find(box_ptr) == ircs.end()) {\n@@ -326,7 +328,11 @@ class mark : public shape::data<mark,shape::ptr> {\n     }\n \n     void walk_box2() {\n-        shape::data<mark,shape::ptr>::walk_box_contents1();\n+        // the box ptr can be NULL for env ptrs in closures and data\n+        // not fully initialized\n+        rust_opaque_box *box = *(rust_opaque_box**)dp;\n+        if (box)\n+            shape::data<mark,shape::ptr>::walk_box_contents1();\n     }\n \n     void walk_uniq2() {\n@@ -336,8 +342,6 @@ class mark : public shape::data<mark,shape::ptr> {\n     void walk_fn2(char code) {\n         switch (code) {\n           case shape::SHAPE_BOX_FN: {\n-              // Record an irc for the environment box, but don't descend\n-              // into it since it will be walked via the box's allocation\n               shape::data<mark,shape::ptr>::walk_fn_contents1();\n               break;\n           }\n@@ -369,11 +373,11 @@ class mark : public shape::data<mark,shape::ptr> {\n \n     void walk_uniq_contents2(mark &sub) { sub.walk(); }\n \n-    void walk_box_contents2(mark &sub, shape::ptr &box_dp) {\n-        if (!box_dp)\n-            return;\n+    void walk_box_contents2(mark &sub) {\n+        rust_opaque_box *box_ptr = *(rust_opaque_box **) dp;\n \n-        rust_opaque_box *box_ptr = (rust_opaque_box *) box_dp;\n+        if (!box_ptr)\n+            return;\n \n         if (marked.find(box_ptr) != marked.end())\n             return; // Skip to avoid chasing cycles.\n@@ -516,22 +520,26 @@ class sweep : public shape::data<sweep,shape::ptr> {\n     }\n \n     void walk_box2() {\n-        shape::data<sweep,shape::ptr>::walk_box_contents1();\n+        // In sweep phase, do not walk the box contents.  There is an\n+        // outer loop walking all remaining boxes, and this box may well\n+        // have been freed already!\n     }\n \n     void walk_fn2(char code) {\n         switch (code) {\n           case shape::SHAPE_UNIQ_FN: {\n               fn_env_pair pair = *(fn_env_pair*)dp;\n \n-              // free closed over data:\n-              shape::data<sweep,shape::ptr>::walk_fn_contents1();\n-\n-              // now free the embedded type descr:\n-              upcall_s_free_shared_type_desc((type_desc*)pair.env->td);\n-\n-              // now free the ptr:\n-              task->kernel->free(pair.env);\n+              if (pair.env) {\n+                  // free closed over data:\n+                  shape::data<sweep,shape::ptr>::walk_fn_contents1();\n+                  \n+                  // now free the embedded type descr:\n+                  upcall_s_free_shared_type_desc((type_desc*)pair.env->td);\n+                  \n+                  // now free the ptr:\n+                  task->kernel->free(pair.env);\n+              }\n               break;\n           }\n           case shape::SHAPE_BOX_FN: {\n@@ -579,10 +587,6 @@ class sweep : public shape::data<sweep,shape::ptr> {\n \n     void walk_uniq_contents2(sweep &sub) { sub.walk(); }\n \n-    void walk_box_contents2(sweep &sub, shape::ptr &box_dp) {\n-        return;\n-    }\n-\n     void walk_struct2(const uint8_t *end_sp) {\n         while (this->sp != end_sp) {\n             this->walk();"}, {"sha": "866bc4ac17a72b986927de0bcafe0b389226b224", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/526e73d7f882bf9a88fe957661cc2e09291cef5b/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/526e73d7f882bf9a88fe957661cc2e09291cef5b/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=526e73d7f882bf9a88fe957661cc2e09291cef5b", "patch": "@@ -264,7 +264,7 @@ class cmp : public data<cmp,ptr_pair> {\n         result = sub.result;\n     }\n \n-    inline void walk_box_contents2(cmp &sub, ptr_pair &box_dp) {\n+    inline void walk_box_contents2(cmp &sub) {\n         sub.align = true;\n         sub.walk();\n         result = sub.result;\n@@ -309,6 +309,15 @@ class cmp : public data<cmp,ptr_pair> {\n                          ptr_pair::make(in_data_0, in_data_1)),\n       result(0) {}\n \n+    cmp(const cmp &other,\n+        const uint8_t *in_sp,\n+        const type_param *in_params,\n+        const rust_shape_tables *in_tables,\n+        ptr_pair &in_dp)\n+    : data<cmp,ptr_pair>(other.task, other.align, in_sp, in_params, in_tables,\n+                         in_dp),\n+      result(0) {}\n+\n     cmp(const cmp &other,\n         const uint8_t *in_sp = NULL,\n         const type_param *in_params = NULL,"}, {"sha": "675d67f12d4154a625bc09dc07718bf603274680", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 45, "deletions": 16, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/526e73d7f882bf9a88fe957661cc2e09291cef5b/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/526e73d7f882bf9a88fe957661cc2e09291cef5b/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=526e73d7f882bf9a88fe957661cc2e09291cef5b", "patch": "@@ -712,6 +712,17 @@ class ptr {\n     inline operator bool() const { return p != NULL; }\n     inline operator uintptr_t() const { return (uintptr_t)p; }\n \n+    inline const type_desc *box_body_td() const {\n+        rust_opaque_box *box = *reinterpret_cast<rust_opaque_box**>(p);\n+        assert(box->ref_count >= 1);\n+        return box->td;\n+    }\n+\n+    inline ptr box_body() const {\n+        rust_opaque_box *box = *reinterpret_cast<rust_opaque_box**>(p);\n+        return make((uint8_t*)::box_body(box));\n+    }\n+\n     static inline ptr make(uint8_t *in_p) {\n         ptr self(in_p);\n         return self;\n@@ -746,7 +757,7 @@ class data_pair {\n     inline void operator=(const T rhs) { fst = snd = rhs; }\n \n     static data_pair<T> make(T &fst, T &snd) {\n-        data_pair<T> data(fst, snd);\n+          data_pair<T> data(fst, snd);\n         return data;\n     }\n };\n@@ -792,6 +803,25 @@ class ptr_pair {\n         ptr_pair self(pair.fst, pair.snd);\n         return self;\n     }\n+\n+    inline const type_desc *box_body_td() const {\n+        // Here we assume that the two ptrs are both boxes with\n+        // equivalent type descriptors.  This is safe because we only\n+        // use ptr_pair in the cmp glue, and we only use the cmp glue\n+        // when rust guarantees us that the boxes are of the same\n+        // type.  As box types are not opaque to Rust, it is in a\n+        // position to make this determination.\n+        rust_opaque_box *box_fst = *reinterpret_cast<rust_opaque_box**>(fst);\n+        assert(box_fst->ref_count >= 1);\n+        return box_fst->td;\n+    }\n+\n+    inline ptr_pair box_body() const {\n+        rust_opaque_box *box_fst = *reinterpret_cast<rust_opaque_box**>(fst);\n+        rust_opaque_box *box_snd = *reinterpret_cast<rust_opaque_box**>(snd);\n+        return make((uint8_t*)::box_body(box_fst),\n+                    (uint8_t*)::box_body(box_snd));\n+    }\n };\n \n // NB: This function does not align.\n@@ -933,18 +963,16 @@ class data : public ctxt< data<T,U> > {\n template<typename T,typename U>\n void\n data<T,U>::walk_box_contents1() {\n-    typename U::template data<uint8_t *>::t box_ptr = bump_dp<uint8_t *>(dp);\n-    U box_dp(box_ptr);\n-\n-    // No need to worry about alignment so long as the box header is\n-    // a multiple of 16 bytes.  We can just find the body by adding\n-    // the size of header to box_dp.\n-    assert ((sizeof(rust_opaque_box) % 16) == 0 ||\n-            !\"Must align to find the box body\");\n-\n-    U body_dp = box_dp + sizeof(rust_opaque_box);\n-    T sub(*static_cast<T *>(this), body_dp);\n-    static_cast<T *>(this)->walk_box_contents2(sub, box_dp);\n+    const type_desc *body_td = dp.box_body_td();\n+    if (body_td) {\n+        U body_dp(dp.box_body());\n+        arena arena;\n+        type_param *params = type_param::from_tydesc(body_td, arena);\n+        T sub(*static_cast<T *>(this), body_td->shape, params,\n+              body_td->shape_tables, body_dp);\n+        sub.align = true;\n+        static_cast<T *>(this)->walk_box_contents2(sub);\n+    }\n }\n \n template<typename T,typename U>\n@@ -1006,7 +1034,7 @@ data<T,U>::walk_tag1(tag_info &tinfo) {\n \n template<typename T,typename U>\n void\n-data<T,U>::walk_fn_contents1() {\n+  data<T,U>::walk_fn_contents1() {\n     fn_env_pair pair = bump_dp<fn_env_pair>(dp);\n     if (!pair.env)\n         return;\n@@ -1119,9 +1147,10 @@ class log : public data<log,ptr> {\n \n     void walk_subcontext2(log &sub) { sub.walk(); }\n \n-    void walk_box_contents2(log &sub, ptr &ref_count_dp) {\n+    void walk_box_contents2(log &sub) {\n         out << prefix;\n-        if (!ref_count_dp) {\n+        rust_opaque_box *box_ptr = *(rust_opaque_box **) dp;\n+        if (!box_ptr) {\n             out << \"(null)\";\n         } else {\n             sub.align = true;"}]}