{"sha": "6ac64f19af6280d58d68118f09fd65950fb4aa6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYzY0ZjE5YWY2MjgwZDU4ZDY4MTE4ZjA5ZmQ2NTk1MGZiNGFhNmI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-02T15:05:17Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-02T15:05:17Z"}, "message": "also step through promoteds, constants and statics", "tree": {"sha": "73e4f6acc4c9c1802199348ccf27bb024c66671f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73e4f6acc4c9c1802199348ccf27bb024c66671f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ac64f19af6280d58d68118f09fd65950fb4aa6b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXUEstAAoJEFbW7qD8Z6xGfccP/1eKJfEYrfxgdMo04WpwzvCX\nEDAQH4qV/+egzmSHApWQgbBot2ujwOvwO3O6i4LOUhrgDXlU4Wr/3tzxwDMaUkb0\nK/4/RrqdRUneojcdA0Yt9TT7OGRY+BUSwOoOz7Qfhh56cHmY5j6zwEYpnZRGgQUh\nrjim7kVlY2X+BfmnIM7zyA7E2OH2uZgYYE2AFF9YEoxjxHnx16dxqrn8F37z1qzX\nB1vdsGV+vUUCs47CCwNI+6UVmybrQiyAx6hlvD+i5YzBBO95ClT/pLjbv/pSP7c7\n+Vmdz1E9GIS+4FkCvW4wMp+x5D5iKD/hTF+YgaAFYsWl2vxjag3iN2GsI6laZDjm\n+uJMEhNePNGK+nagFJ1wPjego8Ckxvtq0ZZeiUhvTrVvEIjHIpPyQLoC0DEYA/qG\nuNqbPyxMOBMESvABcD0dbr1geTsETWy6L5MD4/Upu04nx8dQB/Z+LEOoILKZYGZT\n2dqU7YPMABL8PanOL1YI7EY3SVB6WlD2m9mtmqLteqOAkYaVhL6afOrpuonMOofO\nKpOTdwjnHzFp/agRcdus5xtugCVGWNb2a0Lfv98lIpTzGHLk7sCK1xiZRpdUvF0u\n6S9b/JzHHrALdLBn+1HUlTo4F7VfenoT8n5Tl26VCf9xw3vAtKefF8DpNs1QhFnC\nz3Pc1PIlQ2wMuLyFNX5M\n=AeeG\n-----END PGP SIGNATURE-----", "payload": "tree 73e4f6acc4c9c1802199348ccf27bb024c66671f\nparent 52111783771d9e967a63995b3e2d7c6538fc6b52\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1464879917 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1464879917 +0200\n\nalso step through promoteds, constants and statics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac64f19af6280d58d68118f09fd65950fb4aa6b", "html_url": "https://github.com/rust-lang/rust/commit/6ac64f19af6280d58d68118f09fd65950fb4aa6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ac64f19af6280d58d68118f09fd65950fb4aa6b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52111783771d9e967a63995b3e2d7c6538fc6b52", "url": "https://api.github.com/repos/rust-lang/rust/commits/52111783771d9e967a63995b3e2d7c6538fc6b52", "html_url": "https://github.com/rust-lang/rust/commit/52111783771d9e967a63995b3e2d7c6538fc6b52"}], "stats": {"total": 202, "additions": 163, "deletions": 39}, "files": [{"sha": "ec830fd008f888bf0e400a3f55a1b2a0aec92efe", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6ac64f19af6280d58d68118f09fd65950fb4aa6b/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac64f19af6280d58d68118f09fd65950fb4aa6b/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=6ac64f19af6280d58d68118f09fd65950fb4aa6b", "patch": "@@ -20,6 +20,8 @@ use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n use primval::{self, PrimVal};\n \n+use std::collections::HashMap;\n+\n mod stepper;\n \n struct GlobalEvalContext<'a, 'tcx: 'a> {\n@@ -45,6 +47,9 @@ struct GlobalEvalContext<'a, 'tcx: 'a> {\n     ///   * Function DefIds and Substs to print proper substituted function names.\n     ///   * Spans pointing to specific function calls in the source.\n     name_stack: Vec<(DefId, &'tcx Substs<'tcx>, codemap::Span)>,\n+\n+    /// Precomputed statics and constants\n+    statics: DefIdMap<Pointer>,\n }\n \n struct FnEvalContext<'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> {\n@@ -88,6 +93,9 @@ struct Frame<'a, 'tcx: 'a> {\n \n     /// The offset of the first temporary in `self.locals`.\n     temp_offset: usize,\n+\n+    /// List of precomputed promoted constants\n+    promoted: HashMap<usize, Pointer>,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -122,6 +130,13 @@ enum TerminatorTarget {\n     Return,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+enum ConstantId {\n+    Promoted { index: usize },\n+    Static { def_id: DefId },\n+}\n+\n+\n impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         GlobalEvalContext {\n@@ -135,10 +150,11 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n                                    .expect(\"Session::target::uint_type was usize\")/8),\n             substs_stack: Vec::new(),\n             name_stack: Vec::new(),\n+            statics: DefIdMap(),\n         }\n     }\n \n-    fn call(&mut self, mir: &mir::Mir<'tcx>) -> EvalResult<Option<Pointer>> {\n+    fn call(&mut self, mir: &mir::Mir<'tcx>, def_id: DefId) -> EvalResult<Option<Pointer>> {\n         let mut nested_fecx = FnEvalContext::new(self);\n \n         let return_ptr = match mir.return_ty {\n@@ -150,6 +166,7 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n         };\n \n         let substs = nested_fecx.substs();\n+        nested_fecx.name_stack.push((def_id, substs, mir.span));\n         nested_fecx.push_stack_frame(CachedMir::Ref(mir), substs, return_ptr);\n         nested_fecx.run()?;\n         Ok(return_ptr)\n@@ -193,9 +210,9 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             loop {\n                 match stepper.step()? {\n-                    Assignment(statement) => trace!(\"{:?}\", statement),\n-                    Terminator(terminator) => {\n-                        trace!(\"{:?}\", terminator.kind);\n+                    Assignment => trace!(\"{:?}\", stepper.stmt()),\n+                    Terminator => {\n+                        trace!(\"{:?}\", stepper.term().kind);\n                         continue 'outer;\n                     },\n                     Done => return Ok(()),\n@@ -230,6 +247,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             locals: locals,\n             var_offset: num_args,\n             temp_offset: num_args + num_vars,\n+            promoted: HashMap::new(),\n         });\n     }\n \n@@ -983,13 +1001,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                 match *literal {\n                     Value { ref value } => Ok(self.const_to_ptr(value)?),\n                     Item { .. } => Err(EvalError::Unimplemented(format!(\"literal items (e.g. mentions of function items) are unimplemented\"))),\n-                    Promoted { index } => {\n-                        // TODO(solson): Mark constants and statics as read-only and cache their\n-                        // values.\n-                        let current_mir = self.mir();\n-                        let mir = &current_mir.promoted[index];\n-                        self.gecx.call(mir).map(Option::unwrap)\n-                    }\n+                    Promoted { index } => Ok(*self.frame().promoted.get(&index).expect(\"a promoted constant hasn't been precomputed\")),\n                 }\n             }\n         }\n@@ -1004,11 +1016,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             Var(i) => self.frame().locals[self.frame().var_offset + i as usize],\n             Temp(i) => self.frame().locals[self.frame().temp_offset + i as usize],\n \n-            Static(def_id) => {\n-                // TODO(solson): Mark constants and statics as read-only and cache their values.\n-                let mir = self.load_mir(def_id);\n-                self.gecx.call(&mir)?.unwrap()\n-            }\n+            Static(def_id) => *self.gecx.statics.get(&def_id).expect(\"static should have been cached\"),\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n@@ -1412,7 +1420,7 @@ pub fn interpret_start_points<'a, 'tcx>(\n                 debug!(\"Interpreting: {}\", item.name);\n \n                 let mut gecx = GlobalEvalContext::new(tcx, mir_map);\n-                match gecx.call(mir) {\n+                match gecx.call(mir, tcx.map.local_def_id(id)) {\n                     Ok(Some(return_ptr)) => if log_enabled!(::log::LogLevel::Debug) {\n                         gecx.memory.dump(return_ptr.alloc_id);\n                     },"}, {"sha": "0543b40c8f5c35e81028e336b0cd0028c511cfd8", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 121, "deletions": 15, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6ac64f19af6280d58d68118f09fd65950fb4aa6b/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac64f19af6280d58d68118f09fd65950fb4aa6b/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=6ac64f19af6280d58d68118f09fd65950fb4aa6b", "patch": "@@ -2,49 +2,61 @@ use super::{\n     FnEvalContext,\n     CachedMir,\n     TerminatorTarget,\n+    ConstantId,\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n+use rustc::ty::{self, subst};\n+use rustc::mir::visit::Visitor;\n+use syntax::codemap::Span;\n+use memory::Pointer;\n+use std::rc::Rc;\n \n-pub enum Event<'a, 'tcx: 'a> {\n-    Assignment(&'a mir::Statement<'tcx>),\n-    Terminator(&'a mir::Terminator<'tcx>),\n+pub enum Event {\n+    Assignment,\n+    Terminator,\n     Done,\n }\n \n pub struct Stepper<'fncx, 'a: 'fncx, 'b: 'a + 'mir, 'mir: 'fncx, 'tcx: 'b>{\n     fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>,\n     block: mir::BasicBlock,\n-    stmt: usize,\n+    // a stack of statement positions\n+    stmt: Vec<usize>,\n     mir: CachedMir<'mir, 'tcx>,\n     process: fn (&mut Stepper<'fncx, 'a, 'b, 'mir, 'tcx>) -> EvalResult<()>,\n+    // a stack of constants\n+    constants: Vec<Vec<(ConstantId, Span)>>,\n }\n \n impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx> {\n     pub(super) fn new(fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>) -> Self {\n-        Stepper {\n+        let mut stepper = Stepper {\n             block: fncx.frame().next_block,\n             mir: fncx.mir(),\n             fncx: fncx,\n-            stmt: 0,\n+            stmt: vec![0],\n             process: Self::dummy,\n-        }\n+            constants: Vec::new(),\n+        };\n+        stepper.extract_constants();\n+        stepper\n     }\n \n     fn dummy(&mut self) -> EvalResult<()> { Ok(()) }\n \n     fn statement(&mut self) -> EvalResult<()> {\n         let block_data = self.mir.basic_block_data(self.block);\n-        let stmt = &block_data.statements[self.stmt];\n+        let stmt = &block_data.statements[*self.stmt.last().unwrap()];\n         let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n         let result = self.fncx.eval_assignment(lvalue, rvalue);\n         self.fncx.maybe_report(stmt.span, result)?;\n-        self.stmt += 1;\n+        *self.stmt.last_mut().unwrap() += 1;\n         Ok(())\n     }\n \n     fn terminator(&mut self) -> EvalResult<()> {\n-        self.stmt = 0;\n+        *self.stmt.last_mut().unwrap() = 0;\n         let term = {\n             let block_data = self.mir.basic_block_data(self.block);\n             let terminator = block_data.terminator();\n@@ -58,6 +70,9 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n             TerminatorTarget::Return => {\n                 self.fncx.pop_stack_frame();\n                 self.fncx.name_stack.pop();\n+                self.stmt.pop();\n+                assert!(self.constants.last().unwrap().is_empty());\n+                self.constants.pop();\n                 if !self.fncx.stack.is_empty() {\n                     self.block = self.fncx.frame().next_block;\n                     self.mir = self.fncx.mir();\n@@ -66,12 +81,24 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n             TerminatorTarget::Call => {\n                 self.block = self.fncx.frame().next_block;\n                 self.mir = self.fncx.mir();\n+                self.stmt.push(0);\n+                self.extract_constants();\n             },\n         }\n         Ok(())\n     }\n \n-    pub fn step<'step>(&'step mut self) -> EvalResult<Event<'step, 'tcx>> {\n+    fn alloc(&mut self, ty: ty::FnOutput<'tcx>) -> Pointer {\n+        match ty {\n+            ty::FnConverging(ty) => {\n+                let size = self.fncx.type_size(ty);\n+                self.fncx.memory.allocate(size)\n+            }\n+            ty::FnDiverging => panic!(\"there's no such thing as an unreachable static\"),\n+        }\n+    }\n+\n+    pub fn step(&mut self) -> EvalResult<Event> {\n         (self.process)(self)?;\n \n         if self.fncx.stack.is_empty() {\n@@ -80,18 +107,97 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n             return Ok(Event::Done);\n         }\n \n+        match self.constants.last_mut().unwrap().pop() {\n+            Some((ConstantId::Promoted { index }, span)) => {\n+                trace!(\"adding promoted constant {}\", index);\n+                let mir = self.mir.promoted[index].clone();\n+                let return_ptr = self.alloc(mir.return_ty);\n+                self.fncx.frame_mut().promoted.insert(index, return_ptr);\n+                let substs = self.fncx.substs();\n+                // FIXME: somehow encode that this is a promoted constant's frame\n+                println!(\"{}, {}, {}\", self.fncx.stack.len(), self.fncx.name_stack.len(), self.fncx.substs_stack.len());\n+                let def_id = self.fncx.name_stack.last().unwrap().0;\n+                self.fncx.name_stack.push((def_id, substs, span));\n+                self.fncx.push_stack_frame(CachedMir::Owned(Rc::new(mir)), substs, Some(return_ptr));\n+                self.stmt.push(0);\n+                self.constants.push(Vec::new());\n+                self.block = self.fncx.frame().next_block;\n+                self.mir = self.fncx.mir();\n+            },\n+            Some((ConstantId::Static { def_id }, span)) => {\n+                trace!(\"adding static {:?}\", def_id);\n+                let mir = self.fncx.load_mir(def_id);\n+                let return_ptr = self.alloc(mir.return_ty);\n+                self.fncx.gecx.statics.insert(def_id, return_ptr);\n+                let substs = self.fncx.tcx.mk_substs(subst::Substs::empty());\n+                self.fncx.name_stack.push((def_id, substs, span));\n+                self.fncx.push_stack_frame(mir, substs, Some(return_ptr));\n+                self.stmt.push(0);\n+                self.constants.push(Vec::new());\n+                self.block = self.fncx.frame().next_block;\n+                self.mir = self.fncx.mir();\n+            },\n+            None => {},\n+        }\n+\n         let basic_block = self.mir.basic_block_data(self.block);\n \n-        if let Some(stmt) = basic_block.statements.get(self.stmt) {\n+        if basic_block.statements.len() > *self.stmt.last().unwrap() {\n             self.process = Self::statement;\n-            return Ok(Event::Assignment(&stmt));\n+            return Ok(Event::Assignment);\n         }\n \n         self.process = Self::terminator;\n-        Ok(Event::Terminator(basic_block.terminator()))\n+        Ok(Event::Terminator)\n     }\n-    \n+\n+    /// returns the basic block index of the currently processed block\n     pub fn block(&self) -> mir::BasicBlock {\n         self.block\n     }\n+\n+    /// returns the statement that will be processed next\n+    pub fn stmt(&self) -> &mir::Statement {\n+        let block_data = self.mir.basic_block_data(self.block);\n+        &block_data.statements[*self.stmt.last().unwrap()]\n+    }\n+\n+    /// returns the terminator of the current block\n+    pub fn term(&self) -> &mir::Terminator {\n+        let block_data = self.mir.basic_block_data(self.block);\n+        block_data.terminator()\n+    }\n+\n+    fn extract_constants(&mut self) {\n+        let mut extractor = ConstantExtractor {\n+            constants: Vec::new(),\n+        };\n+        extractor.visit_mir(&self.mir);\n+        self.constants.push(extractor.constants);\n+    }\n+}\n+\n+struct ConstantExtractor {\n+    constants: Vec<(ConstantId, Span)>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ConstantExtractor {\n+    fn visit_constant(&mut self, constant: &mir::Constant<'tcx>) {\n+        self.super_constant(constant);\n+        match constant.literal {\n+            // already computed by rustc\n+            mir::Literal::Value { .. } => {}\n+            mir::Literal::Item { .. } => {}, // FIXME: unimplemented\n+            mir::Literal::Promoted { index } => {\n+                self.constants.push((ConstantId::Promoted { index: index }, constant.span));\n+            }\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, block: mir::BasicBlock, stmt: &mir::Statement<'tcx>) {\n+        self.super_statement(block, stmt);\n+        if let mir::StatementKind::Assign(mir::Lvalue::Static(def_id), _) = stmt.kind {\n+            self.constants.push((ConstantId::Static { def_id: def_id }, stmt.span));\n+        }\n+    }\n }"}, {"sha": "7ff4b1c191c1335088a14c1282c43d6b4e06be98", "filename": "tests/compile-fail/unimplemented.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ac64f19af6280d58d68118f09fd65950fb4aa6b/tests%2Fcompile-fail%2Funimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac64f19af6280d58d68118f09fd65950fb4aa6b/tests%2Fcompile-fail%2Funimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funimplemented.rs?ref=6ac64f19af6280d58d68118f09fd65950fb4aa6b", "patch": "@@ -1,16 +1,12 @@\n #![feature(custom_attribute)]\n #![allow(dead_code, unused_attributes)]\n \n-//error-pattern:literal items (e.g. mentions of function items) are unimplemented\n+//error-pattern:static should have been cached\n \n-static mut X: usize = 5;\n \n #[miri_run]\n-fn static_mut() {\n-    unsafe {\n-        X = 6;\n-        assert_eq!(X, 6);\n-    }\n+fn failed_assertions() {\n+    assert_eq!(5, 6);\n }\n \n fn main() {}"}, {"sha": "3006da2c163de0ade3939e0827fbcaf464bc67bd", "filename": "tests/run-pass/bug.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ac64f19af6280d58d68118f09fd65950fb4aa6b/tests%2Frun-pass%2Fbug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac64f19af6280d58d68118f09fd65950fb4aa6b/tests%2Frun-pass%2Fbug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbug.rs?ref=6ac64f19af6280d58d68118f09fd65950fb4aa6b", "patch": "@@ -0,0 +1,14 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+static mut X: usize = 5;\n+\n+#[miri_run]\n+fn static_mut() {\n+    unsafe {\n+        X = 6;\n+        assert_eq!(X, 6);\n+    }\n+}\n+\n+fn main() {}"}]}