{"sha": "3bbdb0dbb6348cfabab8802883e47ad82c1719ff", "node_id": "C_kwDOAAsO6NoAKDNiYmRiMGRiYjYzNDhjZmFiYWI4ODAyODgzZTQ3YWQ4MmMxNzE5ZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T10:19:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-17T10:19:14Z"}, "message": "Auto merge of #12284 - Veykril:inlay-hints, r=Veykril\n\ninternal: Cleanup lifetime elision hints", "tree": {"sha": "90b40ac962c61075570a3f0ddc345474c632bfc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90b40ac962c61075570a3f0ddc345474c632bfc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bbdb0dbb6348cfabab8802883e47ad82c1719ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bbdb0dbb6348cfabab8802883e47ad82c1719ff", "html_url": "https://github.com/rust-lang/rust/commit/3bbdb0dbb6348cfabab8802883e47ad82c1719ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bbdb0dbb6348cfabab8802883e47ad82c1719ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce9b174f8ac08dde64ca295de761ad7a2c605094", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce9b174f8ac08dde64ca295de761ad7a2c605094", "html_url": "https://github.com/rust-lang/rust/commit/ce9b174f8ac08dde64ca295de761ad7a2c605094"}, {"sha": "12d53439938a70f5f559da84f97906043963b905", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d53439938a70f5f559da84f97906043963b905", "html_url": "https://github.com/rust-lang/rust/commit/12d53439938a70f5f559da84f97906043963b905"}], "stats": {"total": 225, "additions": 103, "deletions": 122}, "files": [{"sha": "d3ce350f9b3e4e07be58d8b4a8ca9bb16a03e340", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 103, "deletions": 122, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/3bbdb0dbb6348cfabab8802883e47ad82c1719ff/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bbdb0dbb6348cfabab8802883e47ad82c1719ff/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=3bbdb0dbb6348cfabab8802883e47ad82c1719ff", "patch": "@@ -47,13 +47,13 @@ pub enum ReborrowHints {\n pub enum InlayKind {\n     BindingModeHint,\n     ChainingHint,\n+    ClosingBraceHint,\n     ClosureReturnTypeHint,\n     GenericParamListHint,\n     ImplicitReborrowHint,\n     LifetimeHint,\n     ParameterHint,\n     TypeHint,\n-    ClosingBraceHint,\n }\n \n #[derive(Debug)]\n@@ -127,28 +127,33 @@ fn hints(\n     };\n \n     closing_brace_hints(hints, sema, config, node.clone());\n-\n-    if let Some(expr) = ast::Expr::cast(node.clone()) {\n-        chaining_hints(hints, sema, &famous_defs, config, &expr);\n-        match expr {\n-            ast::Expr::CallExpr(it) => param_name_hints(hints, sema, config, ast::Expr::from(it)),\n-            ast::Expr::MethodCallExpr(it) => {\n-                param_name_hints(hints, sema, config, ast::Expr::from(it))\n-            }\n-            ast::Expr::ClosureExpr(it) => closure_ret_hints(hints, sema, &famous_defs, config, it),\n-            // We could show reborrows for all expressions, but usually that is just noise to the user\n-            // and the main point here is to show why \"moving\" a mutable reference doesn't necessarily move it\n-            ast::Expr::PathExpr(_) => reborrow_hints(hints, sema, config, &expr),\n-            _ => None,\n-        };\n-    } else if let Some(it) = ast::Pat::cast(node.clone()) {\n-        binding_mode_hints(hints, sema, config, &it);\n-        if let ast::Pat::IdentPat(it) = it {\n-            bind_pat_hints(hints, sema, config, &it);\n+    match_ast! {\n+        match node {\n+            ast::Expr(expr) => {\n+                chaining_hints(hints, sema, &famous_defs, config, &expr);\n+                match expr {\n+                    ast::Expr::CallExpr(it) => param_name_hints(hints, sema, config, ast::Expr::from(it)),\n+                    ast::Expr::MethodCallExpr(it) => {\n+                        param_name_hints(hints, sema, config, ast::Expr::from(it))\n+                    }\n+                    ast::Expr::ClosureExpr(it) => closure_ret_hints(hints, sema, &famous_defs, config, it),\n+                    // We could show reborrows for all expressions, but usually that is just noise to the user\n+                    // and the main point here is to show why \"moving\" a mutable reference doesn't necessarily move it\n+                    ast::Expr::PathExpr(_) => reborrow_hints(hints, sema, config, &expr),\n+                    _ => None,\n+                }\n+            },\n+            ast::Pat(it) => {\n+                binding_mode_hints(hints, sema, config, &it);\n+                if let ast::Pat::IdentPat(it) = it {\n+                    bind_pat_hints(hints, sema, config, &it);\n+                }\n+                Some(())\n+            },\n+            ast::Fn(it) => lifetime_fn_hints(hints, config, it),\n+            _ => Some(()),\n         }\n-    } else if let Some(it) = ast::Fn::cast(node) {\n-        lifetime_hints(hints, config, it);\n-    }\n+    };\n }\n \n fn closing_brace_hints(\n@@ -249,7 +254,7 @@ fn closing_brace_hints(\n     None\n }\n \n-fn lifetime_hints(\n+fn lifetime_fn_hints(\n     acc: &mut Vec<InlayHint>,\n     config: &InlayHintsConfig,\n     func: ast::Fn,\n@@ -262,80 +267,75 @@ fn lifetime_hints(\n     let ret_type = func.ret_type();\n     let self_param = param_list.self_param().filter(|it| it.amp_token().is_some());\n \n-    let mut used_names: FxHashMap<SmolStr, usize> = generic_param_list\n-        .iter()\n-        .filter(|_| config.param_names_for_lifetime_elision_hints)\n-        .flat_map(|gpl| gpl.lifetime_params())\n-        .filter_map(|param| param.lifetime())\n-        .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n-        .collect();\n-\n-    let mut allocated_lifetimes = vec![];\n-    let mut gen_idx_name = {\n-        let mut gen = (0u8..).map(|idx| match idx {\n-            idx if idx < 10 => SmolStr::from_iter(['\\'', (idx + 48) as char]),\n-            idx => format!(\"'{idx}\").into(),\n-        });\n-        move || gen.next().unwrap_or_default()\n+    let is_elided = |lt: &Option<ast::Lifetime>| match lt {\n+        Some(lt) => matches!(lt.text().as_str(), \"'_\"),\n+        None => true,\n     };\n \n-    let mut potential_lt_refs: Vec<_> = vec![];\n-    param_list\n-        .params()\n-        .filter_map(|it| {\n-            Some((\n-                config.param_names_for_lifetime_elision_hints.then(|| it.pat()).flatten(),\n-                it.ty()?,\n-            ))\n-        })\n-        .for_each(|(pat, ty)| {\n+    let potential_lt_refs = {\n+        let mut acc: Vec<_> = vec![];\n+        if let Some(self_param) = &self_param {\n+            let lifetime = self_param.lifetime();\n+            let is_elided = is_elided(&lifetime);\n+            acc.push((None, self_param.amp_token(), lifetime, is_elided));\n+        }\n+        param_list.params().filter_map(|it| Some((it.pat(), it.ty()?))).for_each(|(pat, ty)| {\n             // FIXME: check path types\n             walk_ty(&ty, &mut |ty| match ty {\n-                ast::Type::RefType(r) => potential_lt_refs.push((\n-                    pat.as_ref().and_then(|it| match it {\n-                        ast::Pat::IdentPat(p) => p.name(),\n-                        _ => None,\n-                    }),\n-                    r,\n-                )),\n+                ast::Type::RefType(r) => {\n+                    let lifetime = r.lifetime();\n+                    let is_elided = is_elided(&lifetime);\n+                    acc.push((\n+                        pat.as_ref().and_then(|it| match it {\n+                            ast::Pat::IdentPat(p) => p.name(),\n+                            _ => None,\n+                        }),\n+                        r.amp_token(),\n+                        lifetime,\n+                        is_elided,\n+                    ))\n+                }\n                 _ => (),\n             })\n         });\n-\n-    enum LifetimeKind {\n-        Elided,\n-        Named(SmolStr),\n-        Static,\n-    }\n-\n-    let fetch_lt_text = |lt: Option<ast::Lifetime>| match lt {\n-        Some(lt) => match lt.text().as_str() {\n-            \"'_\" => LifetimeKind::Elided,\n-            \"'static\" => LifetimeKind::Static,\n-            name => LifetimeKind::Named(name.into()),\n-        },\n-        None => LifetimeKind::Elided,\n-    };\n-    let is_elided = |lt: Option<ast::Lifetime>| match lt {\n-        Some(lt) => matches!(lt.text().as_str(), \"'_\"),\n-        None => true,\n+        acc\n     };\n \n     // allocate names\n-    if let Some(self_param) = &self_param {\n-        if is_elided(self_param.lifetime()) {\n-            allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n-                // self can't be used as a lifetime, so no need to check for collisions\n-                \"'self\".into()\n-            } else {\n-                gen_idx_name()\n-            });\n+    let mut gen_idx_name = {\n+        let mut gen = (0u8..).map(|idx| match idx {\n+            idx if idx < 10 => SmolStr::from_iter(['\\'', (idx + 48) as char]),\n+            idx => format!(\"'{idx}\").into(),\n+        });\n+        move || gen.next().unwrap_or_default()\n+    };\n+    let mut allocated_lifetimes = vec![];\n+\n+    let mut used_names: FxHashMap<SmolStr, usize> =\n+        match config.param_names_for_lifetime_elision_hints {\n+            true => generic_param_list\n+                .iter()\n+                .flat_map(|gpl| gpl.lifetime_params())\n+                .filter_map(|param| param.lifetime())\n+                .filter_map(|lt| Some((SmolStr::from(lt.text().as_str().get(1..)?), 0)))\n+                .collect(),\n+            false => Default::default(),\n+        };\n+    {\n+        let mut potential_lt_refs = potential_lt_refs.iter().filter(|&&(.., is_elided)| is_elided);\n+        if let Some(_) = &self_param {\n+            if let Some(_) = potential_lt_refs.next() {\n+                allocated_lifetimes.push(if config.param_names_for_lifetime_elision_hints {\n+                    // self can't be used as a lifetime, so no need to check for collisions\n+                    \"'self\".into()\n+                } else {\n+                    gen_idx_name()\n+                });\n+            }\n         }\n-    }\n-    potential_lt_refs.iter().for_each(|(name, it)| {\n-        if is_elided(it.lifetime()) {\n+        potential_lt_refs.for_each(|(name, ..)| {\n             let name = match name {\n-                Some(it) => {\n+                Some(it) if config.param_names_for_lifetime_elision_hints => {\n                     if let Some(c) = used_names.get_mut(it.text().as_str()) {\n                         *c += 1;\n                         SmolStr::from(format!(\"'{text}{c}\", text = it.text().as_str()))\n@@ -347,26 +347,22 @@ fn lifetime_hints(\n                 _ => gen_idx_name(),\n             };\n             allocated_lifetimes.push(name);\n-        }\n-    });\n+        });\n+    }\n \n     // fetch output lifetime if elision rule applies\n-\n-    let output = if let Some(self_param) = &self_param {\n-        match fetch_lt_text(self_param.lifetime()) {\n-            LifetimeKind::Elided => allocated_lifetimes.get(0).cloned(),\n-            LifetimeKind::Named(name) => Some(name),\n-            LifetimeKind::Static => None,\n-        }\n-    } else {\n-        match potential_lt_refs.as_slice() {\n-            [(_, r)] => match fetch_lt_text(r.lifetime()) {\n-                LifetimeKind::Elided => allocated_lifetimes.get(0).cloned(),\n-                LifetimeKind::Named(name) => Some(name),\n-                LifetimeKind::Static => None,\n-            },\n-            [..] => None,\n+    let output = match potential_lt_refs.as_slice() {\n+        [(_, _, lifetime, _), ..] if self_param.is_some() || potential_lt_refs.len() == 1 => {\n+            match lifetime {\n+                Some(lt) => match lt.text().as_str() {\n+                    \"'_\" => allocated_lifetimes.get(0).cloned(),\n+                    \"'static\" => None,\n+                    name => Some(name.into()),\n+                },\n+                None => allocated_lifetimes.get(0).cloned(),\n+            }\n         }\n+        [..] => None,\n     };\n \n     if allocated_lifetimes.is_empty() && output.is_none() {\n@@ -398,27 +394,12 @@ fn lifetime_hints(\n         return None;\n     }\n \n-    let mut idx = match &self_param {\n-        Some(self_param) if is_elided(self_param.lifetime()) => {\n-            if let Some(amp) = self_param.amp_token() {\n-                let lt = allocated_lifetimes[0].clone();\n-                acc.push(InlayHint {\n-                    range: amp.text_range(),\n-                    kind: InlayKind::LifetimeHint,\n-                    label: lt,\n-                });\n-            }\n-            1\n-        }\n-        _ => 0,\n-    };\n-\n-    for (_, p) in potential_lt_refs.iter() {\n-        if is_elided(p.lifetime()) {\n-            let t = p.amp_token()?;\n-            let lt = allocated_lifetimes[idx].clone();\n+    let mut a = allocated_lifetimes.iter();\n+    for (_, amp_token, _, is_elided) in potential_lt_refs {\n+        if is_elided {\n+            let t = amp_token?;\n+            let lt = a.next()?.clone();\n             acc.push(InlayHint { range: t.text_range(), kind: InlayKind::LifetimeHint, label: lt });\n-            idx += 1;\n         }\n     }\n "}]}