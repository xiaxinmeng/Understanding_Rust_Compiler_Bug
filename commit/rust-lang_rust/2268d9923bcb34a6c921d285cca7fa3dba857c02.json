{"sha": "2268d9923bcb34a6c921d285cca7fa3dba857c02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNjhkOTkyM2JjYjM0YTZjOTIxZDI4NWNjYTdmYTNkYmE4NTdjMDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-26T06:09:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-26T06:09:08Z"}, "message": "Auto merge of #61201 - Centril:rollup-975knrk, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #61087 (Tweak `self` arg not as first argument of a method diagnostic)\n - #61114 (Vec: avoid creating slices to the elements)\n - #61144 (Suggest borrowing for loop head on move error)\n - #61149 (Fix spelling in release notes)\n - #61161 (MaybeUninit doctest: remove unnecessary type ascription)\n - #61173 (Auto-derive Encode and Decode implementations of DefPathTable)\n - #61184 (Add additional trace statements to the const propagator)\n - #61189 (Turn turbo \ud83d\udc1f \ud83c\udf68 into an error)\n - #61193 (Add comment to explain why we change the layout for Projection)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "51812c38d2a32da67a7c68f0e5301c500cf2e3ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51812c38d2a32da67a7c68f0e5301c500cf2e3ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2268d9923bcb34a6c921d285cca7fa3dba857c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2268d9923bcb34a6c921d285cca7fa3dba857c02", "html_url": "https://github.com/rust-lang/rust/commit/2268d9923bcb34a6c921d285cca7fa3dba857c02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2268d9923bcb34a6c921d285cca7fa3dba857c02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "572892c324cde896df0c4a1e9ed4896b1832a4fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/572892c324cde896df0c4a1e9ed4896b1832a4fd", "html_url": "https://github.com/rust-lang/rust/commit/572892c324cde896df0c4a1e9ed4896b1832a4fd"}, {"sha": "8d247e716bc1ed4039f9c696ccf0eb975975f295", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d247e716bc1ed4039f9c696ccf0eb975975f295", "html_url": "https://github.com/rust-lang/rust/commit/8d247e716bc1ed4039f9c696ccf0eb975975f295"}], "stats": {"total": 1524, "additions": 870, "deletions": 654}, "files": [{"sha": "91e3c5f721952a65c0b4ddf2a9b269c0d293f732", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -157,7 +157,7 @@ Libraries\n   produce a warning if their returning type is unused.\n - [The methods `checked_pow`, `saturating_pow`, `wrapping_pow`, and\n   `overflowing_pow` are now available for all numeric types.][57873] These are\n-  equivalvent to methods such as `wrapping_add` for the `pow` operation.\n+  equivalent to methods such as `wrapping_add` for the `pow` operation.\n \n \n Stabilized APIs"}, {"sha": "5ddac673c9ff17fe9b72859dc9748abb3a57cbfa", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -1152,3 +1152,24 @@ fn test_try_reserve_exact() {\n     }\n \n }\n+\n+#[test]\n+fn test_stable_push_pop() {\n+    // Test that, if we reserved enough space, adding and removing elements does not\n+    // invalidate references into the vector (such as `v0`).  This test also\n+    // runs in Miri, which would detect such problems.\n+    let mut v = Vec::with_capacity(10);\n+    v.push(13);\n+\n+    // laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n+    let v0 = unsafe { &*(&v[0] as *const _) };\n+\n+    // Now do a bunch of things and occasionally use `v0` again to assert it is still valid.\n+    v.push(1);\n+    v.push(2);\n+    v.insert(1, 1);\n+    assert_eq!(*v0, 13);\n+    v.remove(1);\n+    v.pop().unwrap();\n+    assert_eq!(*v0, 13);\n+}"}, {"sha": "5cb91395b7bf75cd64cdb81e54392b61ec7140c1", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 71, "deletions": 7, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -735,6 +735,75 @@ impl<T> Vec<T> {\n         self\n     }\n \n+    /// Returns a raw pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    /// Modifying the vector may cause its buffer to be reallocated,\n+    /// which would also make any pointers to it invalid.\n+    ///\n+    /// The caller must also ensure that the memory the pointer (non-transitively) points to\n+    /// is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n+    /// derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = vec![1, 2, 4];\n+    /// let x_ptr = x.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         assert_eq!(*x_ptr.add(i), 1 << i);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const T {\n+        // We shadow the slice method of the same name to avoid going through\n+        // `deref`, which creates an intermediate reference.\n+        let ptr = self.buf.ptr();\n+        unsafe { assume(!ptr.is_null()); }\n+        ptr\n+    }\n+\n+    /// Returns an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    /// Modifying the vector may cause its buffer to be reallocated,\n+    /// which would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // Allocate vector big enough for 4 elements.\n+    /// let size = 4;\n+    /// let mut x: Vec<i32> = Vec::with_capacity(size);\n+    /// let x_ptr = x.as_mut_ptr();\n+    ///\n+    /// // Initialize elements via raw pointer writes, then set length.\n+    /// unsafe {\n+    ///     for i in 0..size {\n+    ///         *x_ptr.add(i) = i as i32;\n+    ///     }\n+    ///     x.set_len(size);\n+    /// }\n+    /// assert_eq!(&*x, &[0,1,2,3]);\n+    /// ```\n+    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n+    #[inline]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        // We shadow the slice method of the same name to avoid going through\n+        // `deref_mut`, which creates an intermediate reference.\n+        let ptr = self.buf.ptr();\n+        unsafe { assume(!ptr.is_null()); }\n+        ptr\n+    }\n+\n     /// Forces the length of the vector to `new_len`.\n     ///\n     /// This is a low-level operation that maintains none of the normal\n@@ -1706,9 +1775,7 @@ impl<T> ops::Deref for Vec<T> {\n \n     fn deref(&self) -> &[T] {\n         unsafe {\n-            let p = self.buf.ptr();\n-            assume(!p.is_null());\n-            slice::from_raw_parts(p, self.len)\n+            slice::from_raw_parts(self.as_ptr(), self.len)\n         }\n     }\n }\n@@ -1717,9 +1784,7 @@ impl<T> ops::Deref for Vec<T> {\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut(&mut self) -> &mut [T] {\n         unsafe {\n-            let ptr = self.buf.ptr();\n-            assume(!ptr.is_null());\n-            slice::from_raw_parts_mut(ptr, self.len)\n+            slice::from_raw_parts_mut(self.as_mut_ptr(), self.len)\n         }\n     }\n }\n@@ -1754,7 +1819,6 @@ impl<T> IntoIterator for Vec<T> {\n     fn into_iter(mut self) -> IntoIter<T> {\n         unsafe {\n             let begin = self.as_mut_ptr();\n-            assume(!begin.is_null());\n             let end = if mem::size_of::<T>() == 0 {\n                 arith_offset(begin as *const i8, self.len() as isize) as *const T\n             } else {"}, {"sha": "ce4aee7ebc54f8be0ceed6408e4642a18c4a5918", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -982,7 +982,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n ///     out.write(vec![1, 2, 3]);\n /// }\n ///\n-/// let mut v: MaybeUninit<Vec<i32>> = MaybeUninit::uninit();\n+/// let mut v = MaybeUninit::uninit();\n /// unsafe { make_vec(v.as_mut_ptr()); }\n /// // Now we know `v` is initialized! This also makes sure the vector gets\n /// // properly dropped.\n@@ -1071,7 +1071,7 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// optimizations, potentially resulting in a larger size:\n ///\n /// ```rust\n-/// # use std::mem::{MaybeUninit, size_of, align_of};\n+/// # use std::mem::{MaybeUninit, size_of};\n /// assert_eq!(size_of::<Option<bool>>(), 1);\n /// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n /// ```"}, {"sha": "2324c3f04284ff33483b490f92280ebc07a1afc8", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -10,7 +10,6 @@ use crate::ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n use crate::session::CrateDisambiguator;\n use std::borrow::Borrow;\n use std::fmt::Write;\n@@ -25,14 +24,13 @@ use crate::util::nodemap::NodeMap;\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n /// stores the DefIndex of its parent.\n /// There is one DefPathTable for each crate.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, RustcDecodable, RustcEncodable)]\n pub struct DefPathTable {\n     index_to_key: Vec<DefKey>,\n     def_path_hashes: Vec<DefPathHash>,\n }\n \n impl DefPathTable {\n-\n     fn allocate(&mut self,\n                 key: DefKey,\n                 def_path_hash: DefPathHash)\n@@ -86,28 +84,6 @@ impl DefPathTable {\n     }\n }\n \n-\n-impl Encodable for DefPathTable {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        // Index to key\n-        self.index_to_key.encode(s)?;\n-\n-        // DefPath hashes\n-        self.def_path_hashes.encode(s)?;\n-\n-        Ok(())\n-    }\n-}\n-\n-impl Decodable for DefPathTable {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n-        Ok(DefPathTable {\n-            index_to_key: Decodable::decode(d)?,\n-            def_path_hashes : Decodable::decode(d)?,\n-        })\n-    }\n-}\n-\n /// The definition table containing node definitions.\n /// It holds the `DefPathTable` for local `DefId`s/`DefPath`s and it also stores a\n /// mapping from `NodeId`s to local `DefId`s."}, {"sha": "8022d1f0c7315dfd38dcd6397fb7d19d609b4e05", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -158,18 +158,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         span,\n                         format!(\"value moved{} here, in previous iteration of loop\", move_msg),\n                     );\n-                    if Some(CompilerDesugaringKind::ForLoop) == span.compiler_desugaring_kind() {\n-                        if let Ok(snippet) = self.infcx.tcx.sess.source_map()\n-                            .span_to_snippet(span)\n-                        {\n-                            err.span_suggestion(\n-                                move_span,\n-                                \"consider borrowing this to avoid moving it into the for loop\",\n-                                format!(\"&{}\", snippet),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                    }\n                     is_loop_move = true;\n                 } else if move_site.traversed_back_edge {\n                     err.span_label(\n@@ -185,7 +173,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         &mut err,\n                         format!(\"variable moved due to use{}\", move_spans.describe()),\n                     );\n-                };\n+                }\n+                if Some(CompilerDesugaringKind::ForLoop) == move_span.compiler_desugaring_kind() {\n+                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                        err.span_suggestion(\n+                            move_span,\n+                            \"consider borrowing to avoid moving into the for loop\",\n+                            format!(\"&{}\", snippet),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n             }\n \n             use_spans.var_span_label("}, {"sha": "de788a22886ab70edbafbb89c6ad6080ef39c20f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -475,6 +475,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 PlaceBase::Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n                 PlaceBase::Local(local) => {\n                     // FIXME use place_projection.is_empty() when is available\n+                    // Do not use the layout passed in as argument if the base we are looking at\n+                    // here is not the entire place.\n                     let layout = if let Place::Base(_) = mir_place {\n                         layout\n                     } else {"}, {"sha": "b2976cd501e7f20e37135c87db39ac255d985dcb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -295,6 +295,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     }\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n+        trace!(\"eval_place(place={:?})\", place);\n         match *place {\n             Place::Base(PlaceBase::Local(loc)) => self.places[loc].clone(),\n             Place::Projection(ref proj) => match proj.elem {\n@@ -516,6 +517,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     }\n \n     fn replace_with_const(&self, rval: &mut Rvalue<'tcx>, value: Const<'tcx>, span: Span) {\n+        trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n         self.ecx.validate_operand(\n             value,\n             vec![],\n@@ -579,6 +581,10 @@ impl CanConstProp {\n             // FIXME(oli-obk): lint variables until they are used in a condition\n             // FIXME(oli-obk): lint if return value is constant\n             *val = mir.local_kind(local) == LocalKind::Temp;\n+\n+            if !*val {\n+                trace!(\"local {:?} can't be propagated because it's not a temporary\", local);\n+            }\n         }\n         cpv.visit_mir(mir);\n         cpv.can_const_prop\n@@ -598,6 +604,7 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             // FIXME(oli-obk): we could be more powerful here, if the multiple writes\n             // only occur in independent execution paths\n             MutatingUse(MutatingUseContext::Store) => if self.found_assignment[local] {\n+                trace!(\"local {:?} can't be propagated because of multiple assignments\", local);\n                 self.can_const_prop[local] = false;\n             } else {\n                 self.found_assignment[local] = true\n@@ -609,7 +616,10 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             NonMutatingUse(NonMutatingUseContext::Projection) |\n             MutatingUse(MutatingUseContext::Projection) |\n             NonUse(_) => {},\n-            _ => self.can_const_prop[local] = false,\n+            _ => {\n+                trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n+                self.can_const_prop[local] = false;\n+            },\n         }\n     }\n }"}, {"sha": "b9713e844d6cbaa0fab804449ecfb71e001315af", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -5194,7 +5194,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         res: Res,\n         span: Span,\n-    ) -> Result<(DefKind, DefId, Ty<'tcx>), ErrorReported> {\n+    ) -> Result<Res, ErrorReported> {\n         let tcx = self.tcx;\n         if let Res::SelfCtor(impl_def_id) = res {\n             let ty = self.impl_self_ty(span, impl_def_id).ty;\n@@ -5204,11 +5204,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n                     let ctor_def_id = variant.ctor_def_id.unwrap();\n-                    Ok((\n-                        DefKind::Ctor(CtorOf::Struct, variant.ctor_kind),\n-                        ctor_def_id,\n-                        tcx.type_of(ctor_def_id),\n-                    ))\n+                    Ok(Res::Def(DefKind::Ctor(CtorOf::Struct, variant.ctor_kind), ctor_def_id))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(span,\n@@ -5235,15 +5231,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         } else {\n-            match res {\n-                Res::Def(kind, def_id) => {\n-                    // The things we are substituting into the type should not contain\n-                    // escaping late-bound regions, and nor should the base type scheme.\n-                    let ty = tcx.type_of(def_id);\n-                    Ok((kind, def_id, ty))\n-                }\n-                _ => span_bug!(span, \"unexpected res in rewrite_self_ctor: {:?}\", res),\n-            }\n+            Ok(res)\n         }\n     }\n \n@@ -5266,27 +5254,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        match res {\n-            Res::Local(hid) | Res::Upvar(hid, ..) => {\n-                let ty = self.local_ty(span, hid).decl_ty;\n-                let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(hir_id, ty);\n-                return (ty, res);\n-            }\n-            _ => {}\n-        }\n-\n-        let (kind, def_id, ty) = match self.rewrite_self_ctor(res, span) {\n-            Ok(result) => result,\n+        let res = match self.rewrite_self_ctor(res, span) {\n+            Ok(res) => res,\n             Err(ErrorReported) => return (tcx.types.err, res),\n         };\n-        let path_segs =\n-            AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id);\n+        let path_segs = match res {\n+            Res::Local(_) | Res::Upvar(..) => Vec::new(),\n+            Res::Def(kind, def_id) =>\n+                AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id),\n+            _ => bug!(\"instantiate_value_path on {:?}\", res),\n+        };\n \n         let mut user_self_ty = None;\n         let mut is_alias_variant_ctor = false;\n-        match kind {\n-            DefKind::Ctor(CtorOf::Variant, _) => {\n+        match res {\n+            Res::Def(DefKind::Ctor(CtorOf::Variant, _), _) => {\n                 if let Some(self_ty) = self_ty {\n                     let adt_def = self_ty.ty_adt_def().unwrap();\n                     user_self_ty = Some(UserSelfTy {\n@@ -5296,8 +5278,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     is_alias_variant_ctor = true;\n                 }\n             }\n-            DefKind::Method\n-            | DefKind::AssociatedConst => {\n+            Res::Def(DefKind::Method, def_id)\n+            | Res::Def(DefKind::AssociatedConst, def_id) => {\n                 let container = tcx.associated_item(def_id).container;\n                 debug!(\"instantiate_value_path: def_id={:?} container={:?}\", def_id, container);\n                 match container {\n@@ -5337,6 +5319,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None\n             }\n         }));\n+\n+        match res {\n+            Res::Local(hid) | Res::Upvar(hid, ..) => {\n+                let ty = self.local_ty(span, hid).decl_ty;\n+                let ty = self.normalize_associated_types_in(span, &ty);\n+                self.write_ty(hir_id, ty);\n+                return (ty, res);\n+            }\n+            _ => {}\n+        }\n+\n         if generics_has_err {\n             // Don't try to infer type parameters when prohibited generic arguments were given.\n             user_self_ty = None;\n@@ -5374,6 +5367,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n+        let def_id = res.def_id();\n+\n+        // The things we are substituting into the type should not contain\n+        // escaping late-bound regions, and nor should the base type scheme.\n+        let ty = tcx.type_of(def_id);\n+\n         let substs = AstConv::create_substs_for_generic_args(\n             tcx,\n             def_id,\n@@ -5490,7 +5489,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n-        (ty_substituted, Res::Def(kind, def_id))\n+        (ty_substituted, res)\n     }\n \n     fn check_rustc_args_require_const(&self,"}, {"sha": "9431b559da55ff8c54d8e012c31eab8ca81b3067", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 580, "deletions": 8, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -1,19 +1,101 @@\n use crate::ast;\n use crate::ast::{\n-    BlockCheckMode, Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind, VariantData,\n+    BlockCheckMode, BinOpKind, Expr, ExprKind, Item, ItemKind, Pat, PatKind, PathSegment, QSelf,\n+    Ty, TyKind, VariantData,\n };\n-use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType};\n-use crate::parse::token;\n-use crate::parse::PResult;\n-use crate::parse::Parser;\n+use crate::parse::{SeqSep, token, PResult, Parser};\n+use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, TokenExpectType};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::Spanned;\n use crate::symbol::kw;\n use crate::ThinVec;\n-use errors::{Applicability, DiagnosticBuilder};\n-use log::debug;\n-use syntax_pos::{Span, DUMMY_SP};\n+use crate::util::parser::AssocOp;\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use log::{debug, trace};\n+\n+pub enum Error {\n+    FileNotFoundForModule {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+        dir_path: String,\n+    },\n+    DuplicatePaths {\n+        mod_name: String,\n+        default_path: String,\n+        secondary_path: String,\n+    },\n+    UselessDocComment,\n+    InclusiveRangeWithNoEnd,\n+}\n+\n+impl Error {\n+    fn span_err<S: Into<MultiSpan>>(\n+        self,\n+        sp: S,\n+        handler: &errors::Handler,\n+    ) -> DiagnosticBuilder<'_> {\n+        match self {\n+            Error::FileNotFoundForModule {\n+                ref mod_name,\n+                ref default_path,\n+                ref secondary_path,\n+                ref dir_path,\n+            } => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0583,\n+                    \"file not found for module `{}`\",\n+                    mod_name,\n+                );\n+                err.help(&format!(\n+                    \"name the file either {} or {} inside the directory \\\"{}\\\"\",\n+                    default_path,\n+                    secondary_path,\n+                    dir_path,\n+                ));\n+                err\n+            }\n+            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0584,\n+                    \"file for module `{}` found at both {} and {}\",\n+                    mod_name,\n+                    default_path,\n+                    secondary_path,\n+                );\n+                err.help(\"delete or rename one of them to remove the ambiguity\");\n+                err\n+            }\n+            Error::UselessDocComment => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0585,\n+                    \"found a documentation comment that doesn't document anything\",\n+                );\n+                err.help(\"doc comments must come before what they document, maybe a comment was \\\n+                          intended with `//`?\");\n+                err\n+            }\n+            Error::InclusiveRangeWithNoEnd => {\n+                let mut err = struct_span_err!(\n+                    handler,\n+                    sp,\n+                    E0586,\n+                    \"inclusive range with no end\",\n+                );\n+                err.help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\");\n+                err\n+            }\n+        }\n+    }\n+}\n \n pub trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n@@ -63,6 +145,364 @@ impl RecoverQPath for Expr {\n }\n \n impl<'a> Parser<'a> {\n+    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n+        self.span_fatal(self.span, m)\n+    }\n+\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_fatal(sp, m)\n+    }\n+\n+    pub fn span_fatal_err<S: Into<MultiSpan>>(&self, sp: S, err: Error) -> DiagnosticBuilder<'a> {\n+        err.span_err(sp, self.diagnostic())\n+    }\n+\n+    pub fn bug(&self, m: &str) -> ! {\n+        self.sess.span_diagnostic.span_bug(self.span, m)\n+    }\n+\n+    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n+        self.sess.span_diagnostic.span_err(sp, m)\n+    }\n+\n+    crate fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+        self.sess.span_diagnostic.struct_span_err(sp, m)\n+    }\n+\n+    crate fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n+        self.sess.span_diagnostic.span_bug(sp, m)\n+    }\n+\n+    crate fn cancel(&self, err: &mut DiagnosticBuilder<'_>) {\n+        self.sess.span_diagnostic.cancel(err)\n+    }\n+\n+    crate fn diagnostic(&self) -> &'a errors::Handler {\n+        &self.sess.span_diagnostic\n+    }\n+\n+    crate fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n+        let mut err = self.struct_span_err(\n+            self.span,\n+            &format!(\"expected identifier, found {}\", self.this_token_descr()),\n+        );\n+        if let token::Ident(ident, false) = &self.token {\n+            if ident.is_raw_guess() {\n+                err.span_suggestion(\n+                    self.span,\n+                    \"you can escape reserved keywords to use them as identifiers\",\n+                    format!(\"r#{}\", ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+        if let Some(token_descr) = self.token_descr() {\n+            err.span_label(self.span, format!(\"expected identifier, found {}\", token_descr));\n+        } else {\n+            err.span_label(self.span, \"expected identifier\");\n+            if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n+                err.span_suggestion(\n+                    self.span,\n+                    \"remove this comma\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        err\n+    }\n+\n+    pub fn expected_one_of_not_found(\n+        &mut self,\n+        edible: &[token::Token],\n+        inedible: &[token::Token],\n+    ) -> PResult<'a, bool /* recovered */> {\n+        fn tokens_to_string(tokens: &[TokenType]) -> String {\n+            let mut i = tokens.iter();\n+            // This might be a sign we need a connect method on Iterator.\n+            let b = i.next()\n+                     .map_or(String::new(), |t| t.to_string());\n+            i.enumerate().fold(b, |mut b, (i, a)| {\n+                if tokens.len() > 2 && i == tokens.len() - 2 {\n+                    b.push_str(\", or \");\n+                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n+                    b.push_str(\" or \");\n+                } else {\n+                    b.push_str(\", \");\n+                }\n+                b.push_str(&a.to_string());\n+                b\n+            })\n+        }\n+\n+        let mut expected = edible.iter()\n+            .map(|x| TokenType::Token(x.clone()))\n+            .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n+            .chain(self.expected_tokens.iter().cloned())\n+            .collect::<Vec<_>>();\n+        expected.sort_by_cached_key(|x| x.to_string());\n+        expected.dedup();\n+        let expect = tokens_to_string(&expected[..]);\n+        let actual = self.this_token_to_string();\n+        let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n+            let short_expect = if expected.len() > 6 {\n+                format!(\"{} possible tokens\", expected.len())\n+            } else {\n+                expect.clone()\n+            };\n+            (format!(\"expected one of {}, found `{}`\", expect, actual),\n+                (self.sess.source_map().next_point(self.prev_span),\n+                format!(\"expected one of {} here\", short_expect)))\n+        } else if expected.is_empty() {\n+            (format!(\"unexpected token: `{}`\", actual),\n+                (self.prev_span, \"unexpected token after this\".to_string()))\n+        } else {\n+            (format!(\"expected {}, found `{}`\", expect, actual),\n+                (self.sess.source_map().next_point(self.prev_span),\n+                format!(\"expected {} here\", expect)))\n+        };\n+        self.last_unexpected_token_span = Some(self.span);\n+        let mut err = self.fatal(&msg_exp);\n+        if self.token.is_ident_named(\"and\") {\n+            err.span_suggestion_short(\n+                self.span,\n+                \"use `&&` instead of `and` for the boolean operator\",\n+                \"&&\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        if self.token.is_ident_named(\"or\") {\n+            err.span_suggestion_short(\n+                self.span,\n+                \"use `||` instead of `or` for the boolean operator\",\n+                \"||\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        let sp = if self.token == token::Token::Eof {\n+            // This is EOF, don't want to point at the following char, but rather the last token\n+            self.prev_span\n+        } else {\n+            label_sp\n+        };\n+        match self.recover_closing_delimiter(&expected.iter().filter_map(|tt| match tt {\n+            TokenType::Token(t) => Some(t.clone()),\n+            _ => None,\n+        }).collect::<Vec<_>>(), err) {\n+            Err(e) => err = e,\n+            Ok(recovered) => {\n+                return Ok(recovered);\n+            }\n+        }\n+\n+        let is_semi_suggestable = expected.iter().any(|t| match t {\n+            TokenType::Token(token::Semi) => true, // we expect a `;` here\n+            _ => false,\n+        }) && ( // a `;` would be expected before the current keyword\n+            self.token.is_keyword(kw::Break) ||\n+            self.token.is_keyword(kw::Continue) ||\n+            self.token.is_keyword(kw::For) ||\n+            self.token.is_keyword(kw::If) ||\n+            self.token.is_keyword(kw::Let) ||\n+            self.token.is_keyword(kw::Loop) ||\n+            self.token.is_keyword(kw::Match) ||\n+            self.token.is_keyword(kw::Return) ||\n+            self.token.is_keyword(kw::While)\n+        );\n+        let cm = self.sess.source_map();\n+        match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n+            (Ok(ref a), Ok(ref b)) if a.line != b.line && is_semi_suggestable => {\n+                // The spans are in different lines, expected `;` and found `let` or `return`.\n+                // High likelihood that it is only a missing `;`.\n+                err.span_suggestion_short(\n+                    label_sp,\n+                    \"a semicolon may be missing here\",\n+                    \";\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+                return Ok(true);\n+            }\n+            (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n+                // When the spans are in the same line, it means that the only content between\n+                // them is whitespace, point at the found token in that case:\n+                //\n+                // X |     () => { syntax error };\n+                //   |                    ^^^^^ expected one of 8 possible tokens here\n+                //\n+                // instead of having:\n+                //\n+                // X |     () => { syntax error };\n+                //   |                   -^^^^^ unexpected token\n+                //   |                   |\n+                //   |                   expected one of 8 possible tokens here\n+                err.span_label(self.span, label_exp);\n+            }\n+            _ if self.prev_span == syntax_pos::DUMMY_SP => {\n+                // Account for macro context where the previous span might not be\n+                // available to avoid incorrect output (#54841).\n+                err.span_label(self.span, \"unexpected token\");\n+            }\n+            _ => {\n+                err.span_label(sp, label_exp);\n+                err.span_label(self.span, \"unexpected token\");\n+            }\n+        }\n+        Err(err)\n+    }\n+\n+    /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n+    /// passes through any errors encountered. Used for error recovery.\n+    crate fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n+        let handler = self.diagnostic();\n+\n+        if let Err(ref mut err) = self.parse_seq_to_before_tokens(\n+            kets,\n+            SeqSep::none(),\n+            TokenExpectType::Expect,\n+            |p| Ok(p.parse_token_tree()),\n+        ) {\n+            handler.cancel(err);\n+        }\n+    }\n+\n+    /// This function checks if there are trailing angle brackets and produces\n+    /// a diagnostic to suggest removing them.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n+    ///                                                        ^^ help: remove extra angle brackets\n+    /// ```\n+    crate fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: token::Token) {\n+        // This function is intended to be invoked after parsing a path segment where there are two\n+        // cases:\n+        //\n+        // 1. A specific token is expected after the path segment.\n+        //    eg. `x.foo(`, `x.foo::<u32>(` (parenthesis - method call),\n+        //        `Foo::`, or `Foo::<Bar>::` (mod sep - continued path).\n+        // 2. No specific token is expected after the path segment.\n+        //    eg. `x.foo` (field access)\n+        //\n+        // This function is called after parsing `.foo` and before parsing the token `end` (if\n+        // present). This includes any angle bracket arguments, such as `.foo::<u32>` or\n+        // `Foo::<Bar>`.\n+\n+        // We only care about trailing angle brackets if we previously parsed angle bracket\n+        // arguments. This helps stop us incorrectly suggesting that extra angle brackets be\n+        // removed in this case:\n+        //\n+        // `x.foo >> (3)` (where `x.foo` is a `u32` for example)\n+        //\n+        // This case is particularly tricky as we won't notice it just looking at the tokens -\n+        // it will appear the same (in terms of upcoming tokens) as below (since the `::<u32>` will\n+        // have already been parsed):\n+        //\n+        // `x.foo::<u32>>>(3)`\n+        let parsed_angle_bracket_args = segment.args\n+            .as_ref()\n+            .map(|args| args.is_angle_bracketed())\n+            .unwrap_or(false);\n+\n+        debug!(\n+            \"check_trailing_angle_brackets: parsed_angle_bracket_args={:?}\",\n+            parsed_angle_bracket_args,\n+        );\n+        if !parsed_angle_bracket_args {\n+            return;\n+        }\n+\n+        // Keep the span at the start so we can highlight the sequence of `>` characters to be\n+        // removed.\n+        let lo = self.span;\n+\n+        // We need to look-ahead to see if we have `>` characters without moving the cursor forward\n+        // (since we might have the field access case and the characters we're eating are\n+        // actual operators and not trailing characters - ie `x.foo >> 3`).\n+        let mut position = 0;\n+\n+        // We can encounter `>` or `>>` tokens in any order, so we need to keep track of how\n+        // many of each (so we can correctly pluralize our error messages) and continue to\n+        // advance.\n+        let mut number_of_shr = 0;\n+        let mut number_of_gt = 0;\n+        while self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            if *t == token::BinOp(token::BinOpToken::Shr) {\n+                number_of_shr += 1;\n+                true\n+            } else if *t == token::Gt {\n+                number_of_gt += 1;\n+                true\n+            } else {\n+                false\n+            }\n+        }) {\n+            position += 1;\n+        }\n+\n+        // If we didn't find any trailing `>` characters, then we have nothing to error about.\n+        debug!(\n+            \"check_trailing_angle_brackets: number_of_gt={:?} number_of_shr={:?}\",\n+            number_of_gt, number_of_shr,\n+        );\n+        if number_of_gt < 1 && number_of_shr < 1 {\n+            return;\n+        }\n+\n+        // Finally, double check that we have our end token as otherwise this is the\n+        // second case.\n+        if self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            *t == end\n+        }) {\n+            // Eat from where we started until the end token so that parsing can continue\n+            // as if we didn't have those extra angle brackets.\n+            self.eat_to_tokens(&[&end]);\n+            let span = lo.until(self.span);\n+\n+            let plural = number_of_gt > 1 || number_of_shr >= 1;\n+            self.diagnostic()\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"unmatched angle bracket{}\", if plural { \"s\" } else { \"\" }),\n+                )\n+                .span_suggestion(\n+                    span,\n+                    &format!(\"remove extra angle bracket{}\", if plural { \"s\" } else { \"\" }),\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n+    }\n+\n+    /// Produce an error if comparison operators are chained (RFC #558).\n+    /// We only need to check lhs, not rhs, because all comparison ops\n+    /// have same precedence and are left-associative\n+    crate fn check_no_chained_comparison(&self, lhs: &Expr, outer_op: &AssocOp) {\n+        debug_assert!(outer_op.is_comparison(),\n+                      \"check_no_chained_comparison: {:?} is not comparison\",\n+                      outer_op);\n+        match lhs.node {\n+            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n+                // respan to include both operators\n+                let op_span = op.span.to(self.span);\n+                let mut err = self.diagnostic().struct_span_err(op_span,\n+                    \"chained comparison operators require parentheses\");\n+                if op.node == BinOpKind::Lt &&\n+                    *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n+                    *outer_op == AssocOp::Greater  // even in a case like the following:\n+                {                                  //     Foo<Bar<Baz<Qux, ()>>>\n+                    err.help(\n+                        \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n+                    err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                }\n+                err.emit();\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     crate fn maybe_report_ambiguous_plus(\n         &mut self,\n         allow_plus: bool,\n@@ -594,6 +1034,138 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    crate fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n+        if self.eat_keyword(kw::In) {\n+            // a common typo: `for _ in in bar {}`\n+            let mut err = self.sess.span_diagnostic.struct_span_err(\n+                self.prev_span,\n+                \"expected iterable, found keyword `in`\",\n+            );\n+            err.span_suggestion_short(\n+                in_span.until(self.prev_span),\n+                \"remove the duplicated `in`\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            err.emit();\n+        }\n+    }\n+\n+    crate fn expected_semi_or_open_brace(&mut self) -> PResult<'a, ast::TraitItem> {\n+        let token_str = self.this_token_descr();\n+        let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n+        err.span_label(self.span, \"expected `;` or `{`\");\n+        Err(err)\n+    }\n+\n+    crate fn eat_incorrect_doc_comment(&mut self, applied_to: &str) {\n+        if let token::DocComment(_) = self.token {\n+            let mut err = self.diagnostic().struct_span_err(\n+                self.span,\n+                &format!(\"documentation comments cannot be applied to {}\", applied_to),\n+            );\n+            err.span_label(self.span, \"doc comments are not allowed here\");\n+            err.emit();\n+            self.bump();\n+        } else if self.token == token::Pound && self.look_ahead(1, |t| {\n+            *t == token::OpenDelim(token::Bracket)\n+        }) {\n+            let lo = self.span;\n+            // Skip every token until next possible arg.\n+            while self.token != token::CloseDelim(token::Bracket) {\n+                self.bump();\n+            }\n+            let sp = lo.to(self.span);\n+            self.bump();\n+            let mut err = self.diagnostic().struct_span_err(\n+                sp,\n+                &format!(\"attributes cannot be applied to {}\", applied_to),\n+            );\n+            err.span_label(sp, \"attributes are not allowed here\");\n+            err.emit();\n+        }\n+    }\n+\n+    crate fn argument_without_type(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        pat: P<ast::Pat>,\n+        require_name: bool,\n+        is_trait_item: bool,\n+    ) {\n+        // If we find a pattern followed by an identifier, it could be an (incorrect)\n+        // C-style parameter declaration.\n+        if self.check_ident() && self.look_ahead(1, |t| {\n+            *t == token::Comma || *t == token::CloseDelim(token::Paren)\n+        }) {\n+            let ident = self.parse_ident().unwrap();\n+            let span = pat.span.with_hi(ident.span.hi());\n+\n+            err.span_suggestion(\n+                span,\n+                \"declare the type after the parameter binding\",\n+                String::from(\"<identifier>: <type>\"),\n+                Applicability::HasPlaceholders,\n+            );\n+        } else if require_name && is_trait_item {\n+            if let PatKind::Ident(_, ident, _) = pat.node {\n+                err.span_suggestion(\n+                    pat.span,\n+                    \"explicitly ignore parameter\",\n+                    format!(\"_: {}\", ident),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            err.note(\"anonymous parameters are removed in the 2018 edition (see RFC 1685)\");\n+        }\n+    }\n+\n+    crate fn recover_arg_parse(&mut self) -> PResult<'a, (P<ast::Pat>, P<ast::Ty>)> {\n+        let pat = self.parse_pat(Some(\"argument name\"))?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+\n+        let mut err = self.diagnostic().struct_span_err_with_code(\n+            pat.span,\n+            \"patterns aren't allowed in methods without bodies\",\n+            DiagnosticId::Error(\"E0642\".into()),\n+        );\n+        err.span_suggestion_short(\n+            pat.span,\n+            \"give this argument a name or use an underscore to ignore it\",\n+            \"_\".to_owned(),\n+            Applicability::MachineApplicable,\n+        );\n+        err.emit();\n+\n+        // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n+        let pat = P(Pat {\n+            node: PatKind::Wild,\n+            span: pat.span,\n+            id: ast::DUMMY_NODE_ID\n+        });\n+        Ok((pat, ty))\n+    }\n+\n+    crate fn recover_bad_self_arg(\n+        &mut self,\n+        mut arg: ast::Arg,\n+        is_trait_item: bool,\n+    ) -> PResult<'a, ast::Arg> {\n+        let sp = arg.pat.span;\n+        arg.ty.node = TyKind::Err;\n+        let mut err = self.struct_span_err(sp, \"unexpected `self` parameter in function\");\n+        if is_trait_item {\n+            err.span_label(sp, \"must be the first associated function parameter\");\n+        } else {\n+            err.span_label(sp, \"not valid as function parameter\");\n+            err.note(\"`self` is only valid as the first parameter of an associated function\");\n+        }\n+        err.emit();\n+        Ok(arg)\n+    }\n+\n     crate fn consume_block(&mut self, delim: token::DelimToken) {\n         let mut brace_depth = 0;\n         loop {"}, {"sha": "6c29437362c89cd7f666e8f5843739358021fcfb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 544, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -47,14 +47,12 @@ use crate::parse::PResult;\n use crate::ThinVec;\n use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use crate::symbol::{kw, sym, Symbol};\n+use crate::parse::diagnostics::Error;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n-use syntax_pos::{\n-    BytePos, DUMMY_SP, FileName, MultiSpan, Span,\n-    hygiene::CompilerDesugaringKind,\n-};\n-use log::{debug, trace};\n+use syntax_pos::{Span, BytePos, DUMMY_SP, FileName, hygiene::CompilerDesugaringKind};\n+use log::debug;\n \n use std::borrow::Cow;\n use std::cmp;\n@@ -217,7 +215,7 @@ pub struct Parser<'a> {\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n     crate expected_tokens: Vec<TokenType>,\n-    token_cursor: TokenCursor,\n+    crate token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n     /// Whether we should configure out of line modules as we parse.\n     pub cfg_mods: bool,\n@@ -232,7 +230,7 @@ pub struct Parser<'a> {\n     /// it gets removed from here. Every entry left at the end gets emitted as an independent\n     /// error.\n     crate unclosed_delims: Vec<UnmatchedBrace>,\n-    last_unexpected_token_span: Option<Span>,\n+    crate last_unexpected_token_span: Option<Span>,\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n     crate subparser_name: Option<&'static str>,\n }\n@@ -245,19 +243,19 @@ impl<'a> Drop for Parser<'a> {\n }\n \n #[derive(Clone)]\n-struct TokenCursor {\n-    frame: TokenCursorFrame,\n-    stack: Vec<TokenCursorFrame>,\n+crate struct TokenCursor {\n+    crate frame: TokenCursorFrame,\n+    crate stack: Vec<TokenCursorFrame>,\n }\n \n #[derive(Clone)]\n-struct TokenCursorFrame {\n-    delim: token::DelimToken,\n-    span: DelimSpan,\n-    open_delim: bool,\n-    tree_cursor: tokenstream::Cursor,\n-    close_delim: bool,\n-    last_token: LastToken,\n+crate struct TokenCursorFrame {\n+    crate delim: token::DelimToken,\n+    crate span: DelimSpan,\n+    crate open_delim: bool,\n+    crate tree_cursor: tokenstream::Cursor,\n+    crate close_delim: bool,\n+    crate last_token: LastToken,\n }\n \n /// This is used in `TokenCursorFrame` above to track tokens that are consumed\n@@ -278,7 +276,7 @@ struct TokenCursorFrame {\n /// You can find some more example usage of this in the `collect_tokens` method\n /// on the parser.\n #[derive(Clone)]\n-enum LastToken {\n+crate enum LastToken {\n     Collecting(Vec<TreeAndJoint>),\n     Was(Option<TreeAndJoint>),\n }\n@@ -430,65 +428,6 @@ pub struct ModulePathSuccess {\n     warn: bool,\n }\n \n-pub enum Error {\n-    FileNotFoundForModule {\n-        mod_name: String,\n-        default_path: String,\n-        secondary_path: String,\n-        dir_path: String,\n-    },\n-    DuplicatePaths {\n-        mod_name: String,\n-        default_path: String,\n-        secondary_path: String,\n-    },\n-    UselessDocComment,\n-    InclusiveRangeWithNoEnd,\n-}\n-\n-impl Error {\n-    fn span_err<S: Into<MultiSpan>>(self,\n-                                        sp: S,\n-                                        handler: &errors::Handler) -> DiagnosticBuilder<'_> {\n-        match self {\n-            Error::FileNotFoundForModule { ref mod_name,\n-                                           ref default_path,\n-                                           ref secondary_path,\n-                                           ref dir_path } => {\n-                let mut err = struct_span_err!(handler, sp, E0583,\n-                                               \"file not found for module `{}`\", mod_name);\n-                err.help(&format!(\"name the file either {} or {} inside the directory \\\"{}\\\"\",\n-                                  default_path,\n-                                  secondary_path,\n-                                  dir_path));\n-                err\n-            }\n-            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n-                let mut err = struct_span_err!(handler, sp, E0584,\n-                                               \"file for module `{}` found at both {} and {}\",\n-                                               mod_name,\n-                                               default_path,\n-                                               secondary_path);\n-                err.help(\"delete or rename one of them to remove the ambiguity\");\n-                err\n-            }\n-            Error::UselessDocComment => {\n-                let mut err = struct_span_err!(handler, sp, E0585,\n-                                  \"found a documentation comment that doesn't document anything\");\n-                err.help(\"doc comments must come before what they document, maybe a comment was \\\n-                          intended with `//`?\");\n-                err\n-            }\n-            Error::InclusiveRangeWithNoEnd => {\n-                let mut err = struct_span_err!(handler, sp, E0586,\n-                                               \"inclusive range with no end\");\n-                err.help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\");\n-                err\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n enum LhsExpr {\n     NotYetParsed,\n@@ -529,7 +468,7 @@ fn dummy_arg(span: Span) -> Arg {\n }\n \n #[derive(Copy, Clone, Debug)]\n-enum TokenExpectType {\n+crate enum TokenExpectType {\n     Expect,\n     NoExpect,\n }\n@@ -610,7 +549,7 @@ impl<'a> Parser<'a> {\n         pprust::token_to_string(&self.token)\n     }\n \n-    fn token_descr(&self) -> Option<&'static str> {\n+    crate fn token_descr(&self) -> Option<&'static str> {\n         Some(match &self.token {\n             t if t.is_special_ident() => \"reserved identifier\",\n             t if t.is_used_keyword() => \"keyword\",\n@@ -657,23 +596,6 @@ impl<'a> Parser<'a> {\n         edible: &[token::Token],\n         inedible: &[token::Token],\n     ) -> PResult<'a, bool /* recovered */> {\n-        fn tokens_to_string(tokens: &[TokenType]) -> String {\n-            let mut i = tokens.iter();\n-            // This might be a sign we need a connect method on Iterator.\n-            let b = i.next()\n-                     .map_or(String::new(), |t| t.to_string());\n-            i.enumerate().fold(b, |mut b, (i, a)| {\n-                if tokens.len() > 2 && i == tokens.len() - 2 {\n-                    b.push_str(\", or \");\n-                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n-                    b.push_str(\" or \");\n-                } else {\n-                    b.push_str(\", \");\n-                }\n-                b.push_str(&a.to_string());\n-                b\n-            })\n-        }\n         if edible.contains(&self.token) {\n             self.bump();\n             Ok(false)\n@@ -683,127 +605,15 @@ impl<'a> Parser<'a> {\n         } else if self.last_unexpected_token_span == Some(self.span) {\n             FatalError.raise();\n         } else {\n-            let mut expected = edible.iter()\n-                .map(|x| TokenType::Token(x.clone()))\n-                .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n-                .chain(self.expected_tokens.iter().cloned())\n-                .collect::<Vec<_>>();\n-            expected.sort_by_cached_key(|x| x.to_string());\n-            expected.dedup();\n-            let expect = tokens_to_string(&expected[..]);\n-            let actual = self.this_token_to_string();\n-            let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n-                let short_expect = if expected.len() > 6 {\n-                    format!(\"{} possible tokens\", expected.len())\n-                } else {\n-                    expect.clone()\n-                };\n-                (format!(\"expected one of {}, found `{}`\", expect, actual),\n-                 (self.sess.source_map().next_point(self.prev_span),\n-                  format!(\"expected one of {} here\", short_expect)))\n-            } else if expected.is_empty() {\n-                (format!(\"unexpected token: `{}`\", actual),\n-                 (self.prev_span, \"unexpected token after this\".to_string()))\n-            } else {\n-                (format!(\"expected {}, found `{}`\", expect, actual),\n-                 (self.sess.source_map().next_point(self.prev_span),\n-                  format!(\"expected {} here\", expect)))\n-            };\n-            self.last_unexpected_token_span = Some(self.span);\n-            let mut err = self.fatal(&msg_exp);\n-            if self.token.is_ident_named(\"and\") {\n-                err.span_suggestion_short(\n-                    self.span,\n-                    \"use `&&` instead of `and` for the boolean operator\",\n-                    \"&&\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            if self.token.is_ident_named(\"or\") {\n-                err.span_suggestion_short(\n-                    self.span,\n-                    \"use `||` instead of `or` for the boolean operator\",\n-                    \"||\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            let sp = if self.token == token::Token::Eof {\n-                // This is EOF, don't want to point at the following char, but rather the last token\n-                self.prev_span\n-            } else {\n-                label_sp\n-            };\n-            match self.recover_closing_delimiter(&expected.iter().filter_map(|tt| match tt {\n-                TokenType::Token(t) => Some(t.clone()),\n-                _ => None,\n-            }).collect::<Vec<_>>(), err) {\n-                Err(e) => err = e,\n-                Ok(recovered) => {\n-                    return Ok(recovered);\n-                }\n-            }\n-\n-            let is_semi_suggestable = expected.iter().any(|t| match t {\n-                TokenType::Token(token::Semi) => true, // we expect a `;` here\n-                _ => false,\n-            }) && ( // a `;` would be expected before the current keyword\n-                self.token.is_keyword(kw::Break) ||\n-                self.token.is_keyword(kw::Continue) ||\n-                self.token.is_keyword(kw::For) ||\n-                self.token.is_keyword(kw::If) ||\n-                self.token.is_keyword(kw::Let) ||\n-                self.token.is_keyword(kw::Loop) ||\n-                self.token.is_keyword(kw::Match) ||\n-                self.token.is_keyword(kw::Return) ||\n-                self.token.is_keyword(kw::While)\n-            );\n-            let cm = self.sess.source_map();\n-            match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n-                (Ok(ref a), Ok(ref b)) if a.line != b.line && is_semi_suggestable => {\n-                    // The spans are in different lines, expected `;` and found `let` or `return`.\n-                    // High likelihood that it is only a missing `;`.\n-                    err.span_suggestion_short(\n-                        label_sp,\n-                        \"a semicolon may be missing here\",\n-                        \";\".to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.emit();\n-                    return Ok(true);\n-                }\n-                (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n-                    // When the spans are in the same line, it means that the only content between\n-                    // them is whitespace, point at the found token in that case:\n-                    //\n-                    // X |     () => { syntax error };\n-                    //   |                    ^^^^^ expected one of 8 possible tokens here\n-                    //\n-                    // instead of having:\n-                    //\n-                    // X |     () => { syntax error };\n-                    //   |                   -^^^^^ unexpected token\n-                    //   |                   |\n-                    //   |                   expected one of 8 possible tokens here\n-                    err.span_label(self.span, label_exp);\n-                }\n-                _ if self.prev_span == DUMMY_SP => {\n-                    // Account for macro context where the previous span might not be\n-                    // available to avoid incorrect output (#54841).\n-                    err.span_label(self.span, \"unexpected token\");\n-                }\n-                _ => {\n-                    err.span_label(sp, label_exp);\n-                    err.span_label(self.span, \"unexpected token\");\n-                }\n-            }\n-            Err(err)\n+            self.expected_one_of_not_found(edible, inedible)\n         }\n     }\n \n     /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n-    fn interpolated_or_expr_span(&self,\n-                                 expr: PResult<'a, P<Expr>>)\n-                                 -> PResult<'a, (Span, P<Expr>)> {\n+    fn interpolated_or_expr_span(\n+        &self,\n+        expr: PResult<'a, P<Expr>>,\n+    ) -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n             if self.prev_token_kind == PrevTokenKind::Interpolated {\n                 (self.prev_span, e)\n@@ -813,36 +623,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n-        let mut err = self.struct_span_err(self.span,\n-                                           &format!(\"expected identifier, found {}\",\n-                                                    self.this_token_descr()));\n-        if let token::Ident(ident, false) = &self.token {\n-            if ident.is_raw_guess() {\n-                err.span_suggestion(\n-                    self.span,\n-                    \"you can escape reserved keywords to use them as identifiers\",\n-                    format!(\"r#{}\", ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-        }\n-        if let Some(token_descr) = self.token_descr() {\n-            err.span_label(self.span, format!(\"expected identifier, found {}\", token_descr));\n-        } else {\n-            err.span_label(self.span, \"expected identifier\");\n-            if self.token == token::Comma && self.look_ahead(1, |t| t.is_ident()) {\n-                err.span_suggestion(\n-                    self.span,\n-                    \"remove this comma\",\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        err\n-    }\n-\n     pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n         self.parse_ident_common(true)\n     }\n@@ -925,7 +705,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn check_ident(&mut self) -> bool {\n+    crate fn check_ident(&mut self) -> bool {\n         if self.token.is_ident() {\n             true\n         } else {\n@@ -1115,19 +895,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n-    /// passes through any errors encountered. Used for error recovery.\n-    fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n-        let handler = self.diagnostic();\n-\n-        if let Err(ref mut err) = self.parse_seq_to_before_tokens(kets,\n-                                                                  SeqSep::none(),\n-                                                                  TokenExpectType::Expect,\n-                                                                  |p| Ok(p.parse_token_tree())) {\n-            handler.cancel(err);\n-        }\n-    }\n-\n     /// Parses a sequence, including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -1159,7 +926,7 @@ impl<'a> Parser<'a> {\n         self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n     }\n \n-    fn parse_seq_to_before_tokens<T, F>(\n+    crate fn parse_seq_to_before_tokens<T, F>(\n         &mut self,\n         kets: &[&token::Token],\n         sep: SeqSep,\n@@ -1319,35 +1086,6 @@ impl<'a> Parser<'a> {\n             None => self.look_ahead_span(dist - 1),\n         }\n     }\n-    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_fatal(self.span, m)\n-    }\n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_fatal(sp, m)\n-    }\n-    fn span_fatal_err<S: Into<MultiSpan>>(&self, sp: S, err: Error) -> DiagnosticBuilder<'a> {\n-        err.span_err(sp, self.diagnostic())\n-    }\n-    fn bug(&self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(self.span, m)\n-    }\n-    fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n-        self.sess.span_diagnostic.span_err(sp, m)\n-    }\n-    crate fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_err(sp, m)\n-    }\n-    crate fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(sp, m)\n-    }\n-\n-    fn cancel(&self, err: &mut DiagnosticBuilder<'_>) {\n-        self.sess.span_diagnostic.cancel(err)\n-    }\n-\n-    crate fn diagnostic(&self) -> &'a errors::Handler {\n-        &self.sess.span_diagnostic\n-    }\n \n     /// Is the current token one of the keywords that signals a bare function type?\n     fn token_is_bare_fn_keyword(&mut self) -> bool {\n@@ -1507,20 +1245,12 @@ impl<'a> Parser<'a> {\n                             Some(body)\n                         }\n                         _ => {\n-                            let token_str = self.this_token_descr();\n-                            let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\",\n-                                                              token_str));\n-                            err.span_label(self.span, \"expected `;` or `{`\");\n-                            return Err(err);\n+                            return self.expected_semi_or_open_brace();\n                         }\n                     }\n                 }\n                 _ => {\n-                    let token_str = self.this_token_descr();\n-                    let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\",\n-                                                      token_str));\n-                    err.span_label(self.span, \"expected `;` or `{`\");\n-                    return Err(err);\n+                    return self.expected_semi_or_open_brace();\n                 }\n             };\n             (ident, ast::TraitItemKind::Method(sig, body), generics)\n@@ -1776,79 +1506,24 @@ impl<'a> Parser<'a> {\n \n     /// Skips unexpected attributes and doc comments in this position and emits an appropriate\n     /// error.\n-    fn eat_incorrect_doc_comment(&mut self, applied_to: &str) {\n-        if let token::DocComment(_) = self.token {\n-            let mut err = self.diagnostic().struct_span_err(\n-                self.span,\n-                &format!(\"documentation comments cannot be applied to {}\", applied_to),\n-            );\n-            err.span_label(self.span, \"doc comments are not allowed here\");\n-            err.emit();\n-            self.bump();\n-        } else if self.token == token::Pound && self.look_ahead(1, |t| {\n-            *t == token::OpenDelim(token::Bracket)\n-        }) {\n-            let lo = self.span;\n-            // Skip every token until next possible arg.\n-            while self.token != token::CloseDelim(token::Bracket) {\n-                self.bump();\n-            }\n-            let sp = lo.to(self.span);\n-            self.bump();\n-            let mut err = self.diagnostic().struct_span_err(\n-                sp,\n-                &format!(\"attributes cannot be applied to {}\", applied_to),\n-            );\n-            err.span_label(sp, \"attributes are not allowed here\");\n-            err.emit();\n-        }\n-    }\n-\n     /// This version of parse arg doesn't necessarily require identifier names.\n-    fn parse_arg_general(&mut self, require_name: bool, is_trait_item: bool,\n-                         allow_c_variadic: bool) -> PResult<'a, Arg> {\n-        if let Ok(Some(_)) = self.parse_self_arg() {\n-            let mut err = self.struct_span_err(self.prev_span,\n-                \"unexpected `self` argument in function\");\n-            err.span_label(self.prev_span,\n-                \"`self` is only valid as the first argument of an associated function\");\n-            return Err(err);\n+    fn parse_arg_general(\n+        &mut self,\n+        require_name: bool,\n+        is_trait_item: bool,\n+        allow_c_variadic: bool,\n+    ) -> PResult<'a, Arg> {\n+        if let Ok(Some(arg)) = self.parse_self_arg() {\n+            return self.recover_bad_self_arg(arg, is_trait_item);\n         }\n \n         let (pat, ty) = if require_name || self.is_named_argument() {\n-            debug!(\"parse_arg_general parse_pat (require_name:{})\",\n-                   require_name);\n+            debug!(\"parse_arg_general parse_pat (require_name:{})\", require_name);\n             self.eat_incorrect_doc_comment(\"method arguments\");\n             let pat = self.parse_pat(Some(\"argument name\"))?;\n \n             if let Err(mut err) = self.expect(&token::Colon) {\n-                // If we find a pattern followed by an identifier, it could be an (incorrect)\n-                // C-style parameter declaration.\n-                if self.check_ident() && self.look_ahead(1, |t| {\n-                    *t == token::Comma || *t == token::CloseDelim(token::Paren)\n-                }) {\n-                    let ident = self.parse_ident().unwrap();\n-                    let span = pat.span.with_hi(ident.span.hi());\n-\n-                    err.span_suggestion(\n-                        span,\n-                        \"declare the type after the parameter binding\",\n-                        String::from(\"<identifier>: <type>\"),\n-                        Applicability::HasPlaceholders,\n-                    );\n-                } else if require_name && is_trait_item {\n-                    if let PatKind::Ident(_, ident, _) = pat.node {\n-                        err.span_suggestion(\n-                            pat.span,\n-                            \"explicitly ignore parameter\",\n-                            format!(\"_: {}\", ident),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-\n-                    err.note(\"anonymous parameters are removed in the 2018 edition (see RFC 1685)\");\n-                }\n-\n+                self.argument_without_type(&mut err, pat, require_name, is_trait_item);\n                 return Err(err);\n             }\n \n@@ -1885,42 +1560,14 @@ impl<'a> Parser<'a> {\n                     // Recover from attempting to parse the argument as a type without pattern.\n                     err.cancel();\n                     mem::replace(self, parser_snapshot_before_ty);\n-                    let pat = self.parse_pat(Some(\"argument name\"))?;\n-                    self.expect(&token::Colon)?;\n-                    let ty = self.parse_ty()?;\n-\n-                    let mut err = self.diagnostic().struct_span_err_with_code(\n-                        pat.span,\n-                        \"patterns aren't allowed in methods without bodies\",\n-                        DiagnosticId::Error(\"E0642\".into()),\n-                    );\n-                    err.span_suggestion_short(\n-                        pat.span,\n-                        \"give this argument a name or use an underscore to ignore it\",\n-                        \"_\".to_owned(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-\n-                    // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n-                    let pat = P(Pat {\n-                        node: PatKind::Wild,\n-                        span: pat.span,\n-                        id: ast::DUMMY_NODE_ID\n-                    });\n-                    (pat, ty)\n+                    self.recover_arg_parse()?\n                 }\n             }\n         };\n \n         Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal })\n     }\n \n-    /// Parses a single function argument.\n-    crate fn parse_arg(&mut self) -> PResult<'a, Arg> {\n-        self.parse_arg_general(true, false, false)\n-    }\n-\n     /// Parses an argument in a lambda header (e.g., `|arg, arg|`).\n     fn parse_fn_block_arg(&mut self) -> PResult<'a, Arg> {\n         let pat = self.parse_pat(Some(\"argument name\"))?;\n@@ -2885,116 +2532,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// This function checks if there are trailing angle brackets and produces\n-    /// a diagnostic to suggest removing them.\n-    ///\n-    /// ```ignore (diagnostic)\n-    /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n-    ///                                                        ^^ help: remove extra angle brackets\n-    /// ```\n-    fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: token::Token) {\n-        // This function is intended to be invoked after parsing a path segment where there are two\n-        // cases:\n-        //\n-        // 1. A specific token is expected after the path segment.\n-        //    eg. `x.foo(`, `x.foo::<u32>(` (parenthesis - method call),\n-        //        `Foo::`, or `Foo::<Bar>::` (mod sep - continued path).\n-        // 2. No specific token is expected after the path segment.\n-        //    eg. `x.foo` (field access)\n-        //\n-        // This function is called after parsing `.foo` and before parsing the token `end` (if\n-        // present). This includes any angle bracket arguments, such as `.foo::<u32>` or\n-        // `Foo::<Bar>`.\n-\n-        // We only care about trailing angle brackets if we previously parsed angle bracket\n-        // arguments. This helps stop us incorrectly suggesting that extra angle brackets be\n-        // removed in this case:\n-        //\n-        // `x.foo >> (3)` (where `x.foo` is a `u32` for example)\n-        //\n-        // This case is particularly tricky as we won't notice it just looking at the tokens -\n-        // it will appear the same (in terms of upcoming tokens) as below (since the `::<u32>` will\n-        // have already been parsed):\n-        //\n-        // `x.foo::<u32>>>(3)`\n-        let parsed_angle_bracket_args = segment.args\n-            .as_ref()\n-            .map(|args| args.is_angle_bracketed())\n-            .unwrap_or(false);\n-\n-        debug!(\n-            \"check_trailing_angle_brackets: parsed_angle_bracket_args={:?}\",\n-            parsed_angle_bracket_args,\n-        );\n-        if !parsed_angle_bracket_args {\n-            return;\n-        }\n-\n-        // Keep the span at the start so we can highlight the sequence of `>` characters to be\n-        // removed.\n-        let lo = self.span;\n-\n-        // We need to look-ahead to see if we have `>` characters without moving the cursor forward\n-        // (since we might have the field access case and the characters we're eating are\n-        // actual operators and not trailing characters - ie `x.foo >> 3`).\n-        let mut position = 0;\n-\n-        // We can encounter `>` or `>>` tokens in any order, so we need to keep track of how\n-        // many of each (so we can correctly pluralize our error messages) and continue to\n-        // advance.\n-        let mut number_of_shr = 0;\n-        let mut number_of_gt = 0;\n-        while self.look_ahead(position, |t| {\n-            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n-            if *t == token::BinOp(token::BinOpToken::Shr) {\n-                number_of_shr += 1;\n-                true\n-            } else if *t == token::Gt {\n-                number_of_gt += 1;\n-                true\n-            } else {\n-                false\n-            }\n-        }) {\n-            position += 1;\n-        }\n-\n-        // If we didn't find any trailing `>` characters, then we have nothing to error about.\n-        debug!(\n-            \"check_trailing_angle_brackets: number_of_gt={:?} number_of_shr={:?}\",\n-            number_of_gt, number_of_shr,\n-        );\n-        if number_of_gt < 1 && number_of_shr < 1 {\n-            return;\n-        }\n-\n-        // Finally, double check that we have our end token as otherwise this is the\n-        // second case.\n-        if self.look_ahead(position, |t| {\n-            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n-            *t == end\n-        }) {\n-            // Eat from where we started until the end token so that parsing can continue\n-            // as if we didn't have those extra angle brackets.\n-            self.eat_to_tokens(&[&end]);\n-            let span = lo.until(self.span);\n-\n-            let plural = number_of_gt > 1 || number_of_shr >= 1;\n-            self.diagnostic()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"unmatched angle bracket{}\", if plural { \"s\" } else { \"\" }),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove extra angle bracket{}\", if plural { \"s\" } else { \"\" }),\n-                    String::new(),\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n-        }\n-    }\n-\n     fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let mut hi;\n@@ -3556,33 +3093,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Produce an error if comparison operators are chained (RFC #558).\n-    /// We only need to check lhs, not rhs, because all comparison ops\n-    /// have same precedence and are left-associative\n-    fn check_no_chained_comparison(&self, lhs: &Expr, outer_op: &AssocOp) {\n-        debug_assert!(outer_op.is_comparison(),\n-                      \"check_no_chained_comparison: {:?} is not comparison\",\n-                      outer_op);\n-        match lhs.node {\n-            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n-                // respan to include both operators\n-                let op_span = op.span.to(self.span);\n-                let mut err = self.diagnostic().struct_span_err(op_span,\n-                    \"chained comparison operators require parentheses\");\n-                if op.node == BinOpKind::Lt &&\n-                    *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n-                    *outer_op == AssocOp::Greater  // even in a case like the following:\n-                {                                  //     Foo<Bar<Baz<Qux, ()>>>\n-                    err.help(\n-                        \"use `::<...>` instead of `<...>` if you meant to specify type arguments\");\n-                    err.help(\"or use `(...)` if you meant to specify fn arguments\");\n-                }\n-                err.emit();\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     /// Parse prefix-forms of range notation: `..expr`, `..`, `..=expr`\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinVec<Attribute>>)\n@@ -3609,7 +3119,7 @@ impl<'a> Parser<'a> {\n                     hi = x.span;\n                     x\n                 })?)\n-         } else {\n+        } else {\n             None\n         };\n         let limits = if tok == token::DotDot {\n@@ -3759,20 +3269,7 @@ impl<'a> Parser<'a> {\n             err.emit();\n         }\n         let in_span = self.prev_span;\n-        if self.eat_keyword(kw::In) {\n-            // a common typo: `for _ in in bar {}`\n-            let mut err = self.sess.span_diagnostic.struct_span_err(\n-                self.prev_span,\n-                \"expected iterable, found keyword `in`\",\n-            );\n-            err.span_suggestion_short(\n-                in_span.until(self.prev_span),\n-                \"remove the duplicated `in`\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n-        }\n+        self.check_for_for_in_in_typo(in_span);\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n@@ -6354,7 +5851,9 @@ impl<'a> Parser<'a> {\n             let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let mut decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n+            let mut decl = self.parse_fn_decl_with_self(|p| {\n+                p.parse_arg_general(true, true, false)\n+            })?;\n             generics.where_clause = self.parse_where_clause()?;\n             self.construct_async_arguments(&mut asyncness, &mut decl);\n             *at_end = true;"}, {"sha": "a003a01941bdee3981b4cd322c7273d7be338f4e", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -1,5 +1,6 @@\n fn a(&self) { }\n-//~^ ERROR unexpected `self` argument in function\n-//~| NOTE `self` is only valid as the first argument of an associated function\n+//~^ ERROR unexpected `self` parameter in function\n+//~| NOTE not valid as function parameter\n+//~| NOTE `self` is only valid as the first parameter of an associated function\n \n fn main() { }"}, {"sha": "23de6502094f0e7cf5093f4c92e75980856d1475", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -1,8 +1,10 @@\n-error: unexpected `self` argument in function\n-  --> $DIR/bare-fn-start.rs:1:7\n+error: unexpected `self` parameter in function\n+  --> $DIR/bare-fn-start.rs:1:6\n    |\n LL | fn a(&self) { }\n-   |       ^^^^ `self` is only valid as the first argument of an associated function\n+   |      ^^^^^ not valid as function parameter\n+   |\n+   = note: `self` is only valid as the first parameter of an associated function\n \n error: aborting due to previous error\n "}, {"sha": "73d68e8b7a5ab340375bb570688a08f734313d92", "filename": "src/test/ui/invalid-self-argument/bare-fn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -1,5 +1,6 @@\n fn b(foo: u32, &mut self) { }\n-//~^ ERROR unexpected `self` argument in function\n-//~| NOTE `self` is only valid as the first argument of an associated function\n+//~^ ERROR unexpected `self` parameter in function\n+//~| NOTE not valid as function parameter\n+//~| NOTE `self` is only valid as the first parameter of an associated function\n \n fn main() { }"}, {"sha": "601a51bb4a96a4b8f535477acf4ade088d69e4bc", "filename": "src/test/ui/invalid-self-argument/bare-fn.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -1,8 +1,10 @@\n-error: unexpected `self` argument in function\n-  --> $DIR/bare-fn.rs:1:21\n+error: unexpected `self` parameter in function\n+  --> $DIR/bare-fn.rs:1:16\n    |\n LL | fn b(foo: u32, &mut self) { }\n-   |                     ^^^^ `self` is only valid as the first argument of an associated function\n+   |                ^^^^^^^^^ not valid as function parameter\n+   |\n+   = note: `self` is only valid as the first parameter of an associated function\n \n error: aborting due to previous error\n "}, {"sha": "1e8220d7b4a781743c41f810a3f3957a9e2f7479", "filename": "src/test/ui/invalid-self-argument/trait-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -2,8 +2,8 @@ struct Foo {}\n \n impl Foo {\n     fn c(foo: u32, self) {}\n-    //~^ ERROR unexpected `self` argument in function\n-    //~| NOTE `self` is only valid as the first argument of an associated function\n+    //~^ ERROR unexpected `self` parameter in function\n+    //~| NOTE must be the first associated function parameter\n \n     fn good(&mut self, foo: u32) {}\n }"}, {"sha": "96a2251c036b19658c016a5f6dab9110e7219c60", "filename": "src/test/ui/invalid-self-argument/trait-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -1,8 +1,8 @@\n-error: unexpected `self` argument in function\n+error: unexpected `self` parameter in function\n   --> $DIR/trait-fn.rs:4:20\n    |\n LL |     fn c(foo: u32, self) {}\n-   |                    ^^^^ `self` is only valid as the first argument of an associated function\n+   |                    ^^^^ must be the first associated function parameter\n \n error: aborting due to previous error\n "}, {"sha": "930e98bedce8a08b53399f3c4c72c5d0ab3ce2a2", "filename": "src/test/ui/issues/issue-60989.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -0,0 +1,18 @@\n+struct A {}\n+struct B {}\n+\n+impl From<A> for B {\n+    fn from(a: A) -> B {\n+        B{}\n+    }\n+}\n+\n+fn main() {\n+    let c1 = ();\n+    c1::<()>;\n+    //~^ ERROR type arguments are not allowed for this type\n+\n+    let c1 = A {};\n+    c1::<Into<B>>;\n+    //~^ ERROR type arguments are not allowed for this type\n+}"}, {"sha": "55a0b9626df752c0ba561e42d2f6d6179c564d04", "filename": "src/test/ui/issues/issue-60989.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -0,0 +1,15 @@\n+error[E0109]: type arguments are not allowed for this type\n+  --> $DIR/issue-60989.rs:12:10\n+   |\n+LL |     c1::<()>;\n+   |          ^^ type argument not allowed\n+\n+error[E0109]: type arguments are not allowed for this type\n+  --> $DIR/issue-60989.rs:16:10\n+   |\n+LL |     c1::<Into<B>>;\n+   |          ^^^^^^^ type argument not allowed\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0109`."}, {"sha": "0a883b9581835be74599115c77a87830cc81cc4a", "filename": "src/test/ui/issues/issue-61108.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-61108.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-61108.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut bad_letters = vec!['e', 't', 'o', 'i'];\n+    for l in bad_letters {\n+        // something here\n+    }\n+    bad_letters.push('s'); //~ ERROR borrow of moved value: `bad_letters`\n+}"}, {"sha": "8523a6f6548a6f17d807bbd5a817c6f34da76a3b", "filename": "src/test/ui/issues/issue-61108.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61108.stderr?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -0,0 +1,17 @@\n+error[E0382]: borrow of moved value: `bad_letters`\n+  --> $DIR/issue-61108.rs:6:5\n+   |\n+LL |     let mut bad_letters = vec!['e', 't', 'o', 'i'];\n+   |         --------------- move occurs because `bad_letters` has type `std::vec::Vec<char>`, which does not implement the `Copy` trait\n+LL |     for l in bad_letters {\n+   |              -----------\n+   |              |\n+   |              value moved here\n+   |              help: consider borrowing to avoid moving into the for loop: `&bad_letters`\n+...\n+LL |     bad_letters.push('s');\n+   |     ^^^^^^^^^^^ value borrowed here after move\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "6172ffe1b0347aee9440f8a84b15ea04a82c93b2", "filename": "src/test/ui/parser/self-in-function-arg.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -0,0 +1,3 @@\n+fn foo(x:i32, self: i32) -> i32 { self } //~ ERROR unexpected `self` parameter in function\n+\n+fn main() {}"}, {"sha": "f58df9b9e79b327a20c0c389d42b7affd2a3d444", "filename": "src/test/ui/parser/self-in-function-arg.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -0,0 +1,10 @@\n+error: unexpected `self` parameter in function\n+  --> $DIR/self-in-function-arg.rs:1:15\n+   |\n+LL | fn foo(x:i32, self: i32) -> i32 { self }\n+   |               ^^^^ not valid as function parameter\n+   |\n+   = note: `self` is only valid as the first parameter of an associated function\n+\n+error: aborting due to previous error\n+"}, {"sha": "36bced9e4332bdda069e3aa8e09b51b069d47158", "filename": "src/test/ui/suggestions/borrow-for-loop-head.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2268d9923bcb34a6c921d285cca7fa3dba857c02/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fborrow-for-loop-head.stderr?ref=2268d9923bcb34a6c921d285cca7fa3dba857c02", "patch": "@@ -13,11 +13,10 @@ LL |     let a = vec![1, 2, 3];\n    |         - move occurs because `a` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\n LL |     for i in &a {\n LL |         for j in a {\n-   |                  ^ value moved here, in previous iteration of loop\n-help: consider borrowing this to avoid moving it into the for loop\n-   |\n-LL |         for j in &a {\n-   |                  ^^\n+   |                  ^\n+   |                  |\n+   |                  value moved here, in previous iteration of loop\n+   |                  help: consider borrowing to avoid moving into the for loop: `&a`\n \n error: aborting due to 2 previous errors\n "}]}