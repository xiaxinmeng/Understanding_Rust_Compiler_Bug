{"sha": "3148a322d87a2ba39da28f05b7d26ecac015c607", "node_id": "C_kwDOAAsO6NoAKDMxNDhhMzIyZDg3YTJiYTM5ZGEyOGYwNWI3ZDI2ZWNhYzAxNWM2MDc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-19T09:42:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-19T09:42:15Z"}, "message": "Rollup merge of #92124 - AngelicosPhosphoros:remove_extra_alloc_in_cstring_new_35838, r=Mark-Simulacrum\n\nLittle improves in CString `new` when creating from slice\n\nOld code already contain optimization for cases with `&str` and `&[u8]` args. This commit adds a specialization for `&mut[u8]` too.\n\nAlso, I added usage of old slice in search for zero bytes instead of new buffer because it produce better code for constant inputs on Windows LTO builds. For other platforms, this wouldn't cause any difference because it calls `libc` anyway.\n\nInlined `_new` method into spec trait to reduce amount of code generated to `CString::new` callers.", "tree": {"sha": "9f269dbcc4c607a67c2d21f062e58c2c68388d35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f269dbcc4c607a67c2d21f062e58c2c68388d35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3148a322d87a2ba39da28f05b7d26ecac015c607", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh59z3CRBK7hj4Ov3rIwAAydgIAJgWZUGQ1QwkHZwSiPJdckm5\nz45P+lch9xq54A6hsVu9waZQXM9VSFd2sNzSo+0sROznYP7pQsp+CNQUN1hLnDgy\nb3rgKEke1oP8LyJBIbU5I0iQoZ2pHzbM1pKiqf3X+t4sA/m/0hXNAa28nYyOiWNk\n7nZIfgINCD3YQEkqGmgP8/UK0PJrPq9sUFdj5RrQ8BkCbwqdNN717Me3m7hNdjZB\nnD+SHH6oid3huMekTyjk7kn7RUd9gMPrWWqnsR/y2Y2h7Q09AzstWCho190AClgV\nvsXJTJJR4Z+OxdRBR6aX4PmQBaSboUOsJD4zbbf3VMuliSM99gxcYFBZd3s4HSk=\n=3zGX\n-----END PGP SIGNATURE-----\n", "payload": "tree 9f269dbcc4c607a67c2d21f062e58c2c68388d35\nparent 3a1db90efbdb66663e93e0943a594d1a44f5aedf\nparent 4b62a77e4d76f2f29cd46812e6d7400636790723\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642585335 +0100\ncommitter GitHub <noreply@github.com> 1642585335 +0100\n\nRollup merge of #92124 - AngelicosPhosphoros:remove_extra_alloc_in_cstring_new_35838, r=Mark-Simulacrum\n\nLittle improves in CString `new` when creating from slice\n\nOld code already contain optimization for cases with `&str` and `&[u8]` args. This commit adds a specialization for `&mut[u8]` too.\n\nAlso, I added usage of old slice in search for zero bytes instead of new buffer because it produce better code for constant inputs on Windows LTO builds. For other platforms, this wouldn't cause any difference because it calls `libc` anyway.\n\nInlined `_new` method into spec trait to reduce amount of code generated to `CString::new` callers.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3148a322d87a2ba39da28f05b7d26ecac015c607", "html_url": "https://github.com/rust-lang/rust/commit/3148a322d87a2ba39da28f05b7d26ecac015c607", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3148a322d87a2ba39da28f05b7d26ecac015c607/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a1db90efbdb66663e93e0943a594d1a44f5aedf", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a1db90efbdb66663e93e0943a594d1a44f5aedf", "html_url": "https://github.com/rust-lang/rust/commit/3a1db90efbdb66663e93e0943a594d1a44f5aedf"}, {"sha": "4b62a77e4d76f2f29cd46812e6d7400636790723", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b62a77e4d76f2f29cd46812e6d7400636790723", "html_url": "https://github.com/rust-lang/rust/commit/4b62a77e4d76f2f29cd46812e6d7400636790723"}], "stats": {"total": 67, "additions": 45, "deletions": 22}, "files": [{"sha": "d859bff1a45fa0f348d049adfe84097abc5d49ac", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3148a322d87a2ba39da28f05b7d26ecac015c607/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3148a322d87a2ba39da28f05b7d26ecac015c607/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=3148a322d87a2ba39da28f05b7d26ecac015c607", "patch": "@@ -373,38 +373,61 @@ impl CString {\n     /// the position of the nul byte.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<T: Into<Vec<u8>>>(t: T) -> Result<CString, NulError> {\n-        trait SpecIntoVec {\n-            fn into_vec(self) -> Vec<u8>;\n+        trait SpecNewImpl {\n+            fn spec_new_impl(self) -> Result<CString, NulError>;\n         }\n-        impl<T: Into<Vec<u8>>> SpecIntoVec for T {\n-            default fn into_vec(self) -> Vec<u8> {\n-                self.into()\n+\n+        impl<T: Into<Vec<u8>>> SpecNewImpl for T {\n+            default fn spec_new_impl(self) -> Result<CString, NulError> {\n+                let bytes: Vec<u8> = self.into();\n+                match memchr::memchr(0, &bytes) {\n+                    Some(i) => Err(NulError(i, bytes)),\n+                    None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+                }\n             }\n         }\n-        // Specialization for avoiding reallocation.\n-        impl SpecIntoVec for &'_ [u8] {\n-            fn into_vec(self) -> Vec<u8> {\n-                let mut v = Vec::with_capacity(self.len() + 1);\n-                v.extend(self);\n-                v\n+\n+        // Specialization for avoiding reallocation\n+        #[inline(always)] // Without that it is not inlined into specializations\n+        fn spec_new_impl_bytes(bytes: &[u8]) -> Result<CString, NulError> {\n+            // We cannot have such large slice that we would overflow here\n+            // but using `checked_add` allows LLVM to assume that capacity never overflows\n+            // and generate twice shorter code.\n+            // `saturating_add` doesn't help for some reason.\n+            let capacity = bytes.len().checked_add(1).unwrap();\n+\n+            // Allocate before validation to avoid duplication of allocation code.\n+            // We still need to allocate and copy memory even if we get an error.\n+            let mut buffer = Vec::with_capacity(capacity);\n+            buffer.extend(bytes);\n+\n+            // Check memory of self instead of new buffer.\n+            // This allows better optimizations if lto enabled.\n+            match memchr::memchr(0, bytes) {\n+                Some(i) => Err(NulError(i, buffer)),\n+                None => Ok(unsafe { CString::from_vec_unchecked(buffer) }),\n             }\n         }\n-        impl SpecIntoVec for &'_ str {\n-            fn into_vec(self) -> Vec<u8> {\n-                let mut v = Vec::with_capacity(self.len() + 1);\n-                v.extend(self.as_bytes());\n-                v\n+\n+        impl SpecNewImpl for &'_ [u8] {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self)\n             }\n         }\n \n-        Self::_new(SpecIntoVec::into_vec(t))\n-    }\n+        impl SpecNewImpl for &'_ str {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self.as_bytes())\n+            }\n+        }\n \n-    fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n-        match memchr::memchr(0, &bytes) {\n-            Some(i) => Err(NulError(i, bytes)),\n-            None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+        impl SpecNewImpl for &'_ mut [u8] {\n+            fn spec_new_impl(self) -> Result<CString, NulError> {\n+                spec_new_impl_bytes(self)\n+            }\n         }\n+\n+        t.spec_new_impl()\n     }\n \n     /// Creates a C-compatible string by consuming a byte vector,"}]}