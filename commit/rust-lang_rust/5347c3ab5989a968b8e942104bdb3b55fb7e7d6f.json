{"sha": "5347c3ab5989a968b8e942104bdb3b55fb7e7d6f", "node_id": "C_kwDOAAsO6NoAKDUzNDdjM2FiNTk4OWE5NjhiOGU5NDIxMDRiZGIzYjU1ZmI3ZTdkNmY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-27T13:34:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-27T13:34:52Z"}, "message": "Merge #10353\n\n10353: Remove `GenericParams::new` r=SkiFire13 a=SkiFire13\n\nHelps with #10305\r\n\r\nI made the implementations of `HasChildSource<_>` and `ChildBySource` for `GenericDefId` use their own logic instead of relying on `GenericParams::new`. This in turn means that `GenericParams::new` is unused and can be removed. `SourceMap` becomes also unused because all the rest of the code does is insert into it, so it can be removed too. \r\n\r\nThis also helps avoid creating a completly new `GenericParams` when `GenericDefId::child_source` and `GenericDefId::child_by_source_to` are called, and also creating a `SourceMap` in `item_tree::lower::Ctx::lower_generic_params`.\n\nCo-authored-by: Giacomo Stevanato <giaco.stevanato@gmail.com>", "tree": {"sha": "df310c8f083cdcd1b6b0bfb15495e7d4af061bad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df310c8f083cdcd1b6b0bfb15495e7d4af061bad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhUch8CRBK7hj4Ov3rIwAAbkMIADKU7xsjSppMN65nKuqQuv/1\ngjJDV/P09lK2/cuxG62bQnLuLD+yze19X9gws8Rg5AchGkrI8jMsxVh3jB0YxzHJ\nmX6bO+XyEAiCHTzMMorsGxt+JVdVVWiVPH26rFbT4Lnn7aSgjiKzYOGH5B6R2TIp\nN9+HR1uS8QW8L2XePAQXJNiQTfygWG+Pmt6K4ktr0Sq16pwhmIWfNKfjcgWftxa4\n3Vj6mtFhS1By8SW4BrFfokidpPArvBdt5BTH5CqU+88M8vMe9t5/ydZMmBDdjD7L\nv0MAvPnKpMS1NaThnp9MGHYkjNh/dgLyNIMjAs0Q3I87j2l6olcjejI+TX4XP2w=\n=4DB+\n-----END PGP SIGNATURE-----\n", "payload": "tree df310c8f083cdcd1b6b0bfb15495e7d4af061bad\nparent c4251319fd3acf7b7781275ec77b53cc0efe6140\nparent 72bb49467dbaf3d90455b82447cb3450b843910c\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1632749692 +0000\ncommitter GitHub <noreply@github.com> 1632749692 +0000\n\nMerge #10353\n\n10353: Remove `GenericParams::new` r=SkiFire13 a=SkiFire13\n\nHelps with #10305\r\n\r\nI made the implementations of `HasChildSource<_>` and `ChildBySource` for `GenericDefId` use their own logic instead of relying on `GenericParams::new`. This in turn means that `GenericParams::new` is unused and can be removed. `SourceMap` becomes also unused because all the rest of the code does is insert into it, so it can be removed too. \r\n\r\nThis also helps avoid creating a completly new `GenericParams` when `GenericDefId::child_source` and `GenericDefId::child_by_source_to` are called, and also creating a `SourceMap` in `item_tree::lower::Ctx::lower_generic_params`.\n\nCo-authored-by: Giacomo Stevanato <giaco.stevanato@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f", "html_url": "https://github.com/rust-lang/rust/commit/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4251319fd3acf7b7781275ec77b53cc0efe6140", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4251319fd3acf7b7781275ec77b53cc0efe6140", "html_url": "https://github.com/rust-lang/rust/commit/c4251319fd3acf7b7781275ec77b53cc0efe6140"}, {"sha": "72bb49467dbaf3d90455b82447cb3450b843910c", "url": "https://api.github.com/repos/rust-lang/rust/commits/72bb49467dbaf3d90455b82447cb3450b843910c", "html_url": "https://github.com/rust-lang/rust/commit/72bb49467dbaf3d90455b82447cb3450b843910c"}], "stats": {"total": 253, "additions": 122, "deletions": 131}, "files": [{"sha": "0921ecea6fcad288a441f5fb3439f38560aede78", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 117, "deletions": 124, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=5347c3ab5989a968b8e942104bdb3b55fb7e7d6f", "patch": "@@ -6,7 +6,7 @@\n use base_db::FileId;\n use either::Either;\n use hir_expand::{\n-    name::{name, AsName, Name},\n+    name::{AsName, Name},\n     HirFileId, InFile,\n };\n use la_arena::{Arena, ArenaMap};\n@@ -90,13 +90,6 @@ pub enum WherePredicateTypeTarget {\n     TypeParam(LocalTypeParamId),\n }\n \n-#[derive(Default)]\n-pub(crate) struct SourceMap {\n-    pub(crate) type_params: ArenaMap<LocalTypeParamId, Either<ast::TypeParam, ast::Trait>>,\n-    lifetime_params: ArenaMap<LocalLifetimeParamId, ast::LifetimeParam>,\n-    const_params: ArenaMap<LocalConstParamId, ast::ConstParam>,\n-}\n-\n impl GenericParams {\n     pub(crate) fn generic_params_query(\n         db: &dyn DefDatabase,\n@@ -153,93 +146,9 @@ impl GenericParams {\n         }\n     }\n \n-    fn new(db: &dyn DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n-        let mut generics = GenericParams::default();\n-        let mut sm = SourceMap::default();\n-\n-        // FIXME: add `: Sized` bound for everything except for `Self` in traits\n-        let file_id = match def {\n-            GenericDefId::FunctionId(it) => {\n-                let src = it.lookup(db).source(db);\n-                let lower_ctx = LowerCtx::new(db, src.file_id);\n-                generics.fill(&lower_ctx, &mut sm, &src.value);\n-                // lower `impl Trait` in arguments\n-                let data = db.function_data(it);\n-                for param in &data.params {\n-                    generics.fill_implicit_impl_trait_args(param);\n-                }\n-                src.file_id\n-            }\n-            GenericDefId::AdtId(AdtId::StructId(it)) => {\n-                let src = it.lookup(db).source(db);\n-                let lower_ctx = LowerCtx::new(db, src.file_id);\n-                generics.fill(&lower_ctx, &mut sm, &src.value);\n-                src.file_id\n-            }\n-            GenericDefId::AdtId(AdtId::UnionId(it)) => {\n-                let src = it.lookup(db).source(db);\n-                let lower_ctx = LowerCtx::new(db, src.file_id);\n-                generics.fill(&lower_ctx, &mut sm, &src.value);\n-                src.file_id\n-            }\n-            GenericDefId::AdtId(AdtId::EnumId(it)) => {\n-                let src = it.lookup(db).source(db);\n-                let lower_ctx = LowerCtx::new(db, src.file_id);\n-                generics.fill(&lower_ctx, &mut sm, &src.value);\n-                src.file_id\n-            }\n-            GenericDefId::TraitId(it) => {\n-                let src = it.lookup(db).source(db);\n-                let lower_ctx = LowerCtx::new(db, src.file_id);\n-\n-                // traits get the Self type as an implicit first type parameter\n-                let self_param_id = generics.types.alloc(TypeParamData {\n-                    name: Some(name![Self]),\n-                    default: None,\n-                    provenance: TypeParamProvenance::TraitSelf,\n-                });\n-                sm.type_params.insert(self_param_id, Either::Right(src.value.clone()));\n-                // add super traits as bounds on Self\n-                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n-                let self_param = TypeRef::Path(name![Self].into());\n-                generics.fill_bounds(&lower_ctx, &src.value, Either::Left(self_param));\n-\n-                generics.fill(&lower_ctx, &mut sm, &src.value);\n-                src.file_id\n-            }\n-            GenericDefId::TypeAliasId(it) => {\n-                let src = it.lookup(db).source(db);\n-                let lower_ctx = LowerCtx::new(db, src.file_id);\n-\n-                generics.fill(&lower_ctx, &mut sm, &src.value);\n-                src.file_id\n-            }\n-            // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n-            // type-parameter, but rather is a type-alias for impl's target\n-            // type, so this is handled by the resolver.\n-            GenericDefId::ImplId(it) => {\n-                let src = it.lookup(db).source(db);\n-                let lower_ctx = LowerCtx::new(db, src.file_id);\n-\n-                generics.fill(&lower_ctx, &mut sm, &src.value);\n-                src.file_id\n-            }\n-            // We won't be using this ID anyway\n-            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => FileId(!0).into(),\n-        };\n-\n-        generics.shrink_to_fit();\n-        (generics, InFile::new(file_id, sm))\n-    }\n-\n-    pub(crate) fn fill(\n-        &mut self,\n-        lower_ctx: &LowerCtx,\n-        sm: &mut SourceMap,\n-        node: &dyn HasGenericParams,\n-    ) {\n+    pub(crate) fn fill(&mut self, lower_ctx: &LowerCtx, node: &dyn HasGenericParams) {\n         if let Some(params) = node.generic_param_list() {\n-            self.fill_params(lower_ctx, sm, params)\n+            self.fill_params(lower_ctx, params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n             self.fill_where_predicates(lower_ctx, where_clause);\n@@ -259,12 +168,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_params(\n-        &mut self,\n-        lower_ctx: &LowerCtx,\n-        sm: &mut SourceMap,\n-        params: ast::GenericParamList,\n-    ) {\n+    fn fill_params(&mut self, lower_ctx: &LowerCtx, params: ast::GenericParamList) {\n         for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n@@ -275,27 +179,23 @@ impl GenericParams {\n                 default,\n                 provenance: TypeParamProvenance::TypeParamList,\n             };\n-            let param_id = self.types.alloc(param);\n-            sm.type_params.insert(param_id, Either::Left(type_param.clone()));\n-\n+            self.types.alloc(param);\n             let type_ref = TypeRef::Path(name.into());\n             self.fill_bounds(lower_ctx, &type_param, Either::Left(type_ref));\n         }\n         for lifetime_param in params.lifetime_params() {\n             let name =\n                 lifetime_param.lifetime().map_or_else(Name::missing, |lt| Name::new_lifetime(&lt));\n             let param = LifetimeParamData { name: name.clone() };\n-            let param_id = self.lifetimes.alloc(param);\n-            sm.lifetime_params.insert(param_id, lifetime_param.clone());\n+            self.lifetimes.alloc(param);\n             let lifetime_ref = LifetimeRef::new_name(name);\n             self.fill_bounds(lower_ctx, &lifetime_param, Either::Right(lifetime_ref));\n         }\n         for const_param in params.const_params() {\n             let name = const_param.name().map_or_else(Name::missing, |it| it.as_name());\n             let ty = const_param.ty().map_or(TypeRef::Error, |it| TypeRef::from_ast(lower_ctx, it));\n             let param = ConstParamData { name, ty: Interned::new(ty) };\n-            let param_id = self.consts.alloc(param);\n-            sm.const_params.insert(param_id, const_param.clone());\n+            self.consts.alloc(param);\n         }\n     }\n \n@@ -407,13 +307,71 @@ impl GenericParams {\n     }\n }\n \n+fn file_id_and_params_of(\n+    def: GenericDefId,\n+    db: &dyn DefDatabase,\n+) -> (HirFileId, Option<ast::GenericParamList>) {\n+    match def {\n+        GenericDefId::FunctionId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::AdtId(AdtId::StructId(it)) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::AdtId(AdtId::UnionId(it)) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::AdtId(AdtId::EnumId(it)) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::TraitId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::TypeAliasId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::ImplId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        // We won't be using this ID anyway\n+        GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => (FileId(!0).into(), None),\n+    }\n+}\n+\n impl HasChildSource<LocalTypeParamId> for GenericDefId {\n     type Value = Either<ast::TypeParam, ast::Trait>;\n     fn child_source(\n         &self,\n         db: &dyn DefDatabase,\n     ) -> InFile<ArenaMap<LocalTypeParamId, Self::Value>> {\n-        GenericParams::new(db, *self).1.map(|source_maps| source_maps.type_params)\n+        let generic_params = db.generic_params(*self);\n+        let mut idx_iter = generic_params.types.iter().map(|(idx, _)| idx);\n+\n+        let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n+\n+        let mut params = ArenaMap::default();\n+\n+        // For traits the first type index is `Self`, we need to add it before the other params.\n+        if let GenericDefId::TraitId(id) = *self {\n+            let trait_ref = id.lookup(db).source(db).value.clone();\n+            let idx = idx_iter.next().unwrap();\n+            params.insert(idx, Either::Right(trait_ref))\n+        }\n+\n+        if let Some(generic_params_list) = generic_params_list {\n+            for (idx, ast_param) in idx_iter.zip(generic_params_list.type_params()) {\n+                params.insert(idx, Either::Left(ast_param));\n+            }\n+        }\n+\n+        InFile::new(file_id, params)\n     }\n }\n \n@@ -423,7 +381,20 @@ impl HasChildSource<LocalLifetimeParamId> for GenericDefId {\n         &self,\n         db: &dyn DefDatabase,\n     ) -> InFile<ArenaMap<LocalLifetimeParamId, Self::Value>> {\n-        GenericParams::new(db, *self).1.map(|source_maps| source_maps.lifetime_params)\n+        let generic_params = db.generic_params(*self);\n+        let idx_iter = generic_params.lifetimes.iter().map(|(idx, _)| idx);\n+\n+        let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n+\n+        let mut params = ArenaMap::default();\n+\n+        if let Some(generic_params_list) = generic_params_list {\n+            for (idx, ast_param) in idx_iter.zip(generic_params_list.lifetime_params()) {\n+                params.insert(idx, ast_param);\n+            }\n+        }\n+\n+        InFile::new(file_id, params)\n     }\n }\n \n@@ -433,28 +404,50 @@ impl HasChildSource<LocalConstParamId> for GenericDefId {\n         &self,\n         db: &dyn DefDatabase,\n     ) -> InFile<ArenaMap<LocalConstParamId, Self::Value>> {\n-        GenericParams::new(db, *self).1.map(|source_maps| source_maps.const_params)\n+        let generic_params = db.generic_params(*self);\n+        let idx_iter = generic_params.consts.iter().map(|(idx, _)| idx);\n+\n+        let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n+\n+        let mut params = ArenaMap::default();\n+\n+        if let Some(generic_params_list) = generic_params_list {\n+            for (idx, ast_param) in idx_iter.zip(generic_params_list.const_params()) {\n+                params.insert(idx, ast_param);\n+            }\n+        }\n+\n+        InFile::new(file_id, params)\n     }\n }\n \n impl ChildBySource for GenericDefId {\n     fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, _: HirFileId) {\n-        let (_, sm) = GenericParams::new(db, *self);\n+        let generic_params = db.generic_params(*self);\n+        let mut types_idx_iter = generic_params.types.iter().map(|(idx, _)| idx);\n+        let lts_idx_iter = generic_params.lifetimes.iter().map(|(idx, _)| idx);\n+        let consts_idx_iter = generic_params.consts.iter().map(|(idx, _)| idx);\n \n-        let sm = sm.as_ref();\n-        for (local_id, src) in sm.value.type_params.iter() {\n-            let id = TypeParamId { parent: *self, local_id };\n-            if let Either::Left(type_param) = src {\n-                res[keys::TYPE_PARAM].insert(sm.with_value(type_param.clone()), id)\n-            }\n-        }\n-        for (local_id, src) in sm.value.lifetime_params.iter() {\n-            let id = LifetimeParamId { parent: *self, local_id };\n-            res[keys::LIFETIME_PARAM].insert(sm.with_value(src.clone()), id);\n+        let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n+\n+        // For traits the first type index is `Self`, skip it.\n+        if let GenericDefId::TraitId(_) = *self {\n+            types_idx_iter.next().unwrap(); // advance_by(1);\n         }\n-        for (local_id, src) in sm.value.const_params.iter() {\n-            let id = ConstParamId { parent: *self, local_id };\n-            res[keys::CONST_PARAM].insert(sm.with_value(src.clone()), id);\n+\n+        if let Some(generic_params_list) = generic_params_list {\n+            for (local_id, ast_param) in types_idx_iter.zip(generic_params_list.type_params()) {\n+                let id = TypeParamId { parent: *self, local_id };\n+                res[keys::TYPE_PARAM].insert(InFile::new(file_id, ast_param), id);\n+            }\n+            for (local_id, ast_param) in lts_idx_iter.zip(generic_params_list.lifetime_params()) {\n+                let id = LifetimeParamId { parent: *self, local_id };\n+                res[keys::LIFETIME_PARAM].insert(InFile::new(file_id, ast_param), id);\n+            }\n+            for (local_id, ast_param) in consts_idx_iter.zip(generic_params_list.const_params()) {\n+                let id = ConstParamId { parent: *self, local_id };\n+                res[keys::CONST_PARAM].insert(InFile::new(file_id, ast_param), id);\n+            }\n         }\n     }\n }"}, {"sha": "6d34556b3eafaa0f559575e897aa7c5e5d9db20c", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5347c3ab5989a968b8e942104bdb3b55fb7e7d6f/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=5347c3ab5989a968b8e942104bdb3b55fb7e7d6f", "patch": "@@ -662,11 +662,10 @@ impl<'a> Ctx<'a> {\n         owner: GenericsOwner<'_>,\n         node: &impl ast::HasGenericParams,\n     ) -> Interned<GenericParams> {\n-        let mut sm = &mut Default::default();\n         let mut generics = GenericParams::default();\n         match owner {\n             GenericsOwner::Function(func) => {\n-                generics.fill(&self.body_ctx, sm, node);\n+                generics.fill(&self.body_ctx, node);\n                 // lower `impl Trait` in arguments\n                 for id in func.params.clone() {\n                     if let Param::Normal(ty) = &self.data().params[id] {\n@@ -678,27 +677,26 @@ impl<'a> Ctx<'a> {\n             | GenericsOwner::Enum\n             | GenericsOwner::Union\n             | GenericsOwner::TypeAlias => {\n-                generics.fill(&self.body_ctx, sm, node);\n+                generics.fill(&self.body_ctx, node);\n             }\n             GenericsOwner::Trait(trait_def) => {\n                 // traits get the Self type as an implicit first type parameter\n-                let self_param_id = generics.types.alloc(TypeParamData {\n+                generics.types.alloc(TypeParamData {\n                     name: Some(name![Self]),\n                     default: None,\n                     provenance: TypeParamProvenance::TraitSelf,\n                 });\n-                sm.type_params.insert(self_param_id, Either::Right(trait_def.clone()));\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name![Self].into());\n                 generics.fill_bounds(&self.body_ctx, trait_def, Either::Left(self_param));\n-                generics.fill(&self.body_ctx, &mut sm, node);\n+                generics.fill(&self.body_ctx, node);\n             }\n             GenericsOwner::Impl => {\n                 // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n                 // type-parameter, but rather is a type-alias for impl's target\n                 // type, so this is handled by the resolver.\n-                generics.fill(&self.body_ctx, &mut sm, node);\n+                generics.fill(&self.body_ctx, node);\n             }\n         }\n "}]}