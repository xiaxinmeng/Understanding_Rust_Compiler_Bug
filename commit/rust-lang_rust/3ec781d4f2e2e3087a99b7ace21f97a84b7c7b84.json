{"sha": "3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlYzc4MWQ0ZjJlMmUzMDg3YTk5YjdhY2UyMWY5N2E4NGI3YzdiODQ=", "commit": {"author": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-01-22T00:11:38Z"}, "committer": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-01-22T11:02:21Z"}, "message": "ra_syntax: remove code duplication and token reevaluation from ast::Literal::kind()", "tree": {"sha": "594ad1a64392afa38b438615aec3124c36350b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/594ad1a64392afa38b438615aec3124c36350b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84", "html_url": "https://github.com/rust-lang/rust/commit/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84/comments", "author": null, "committer": null, "parents": [{"sha": "b982d60a4d512602b54f79b39119bde0f7e50f87", "url": "https://api.github.com/repos/rust-lang/rust/commits/b982d60a4d512602b54f79b39119bde0f7e50f87", "html_url": "https://github.com/rust-lang/rust/commit/b982d60a4d512602b54f79b39119bde0f7e50f87"}], "stats": {"total": 54, "additions": 22, "deletions": 32}, "files": [{"sha": "81055746b53d4646f377a675e62a365d8c467251", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84", "patch": "@@ -27,7 +27,7 @@ pub use syntax_kind::SyntaxKind;\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParseError(pub String);\n \n-/// `TokenSource` abstracts the source of the tokens parser operates one.\n+/// `TokenSource` abstracts the source of the tokens parser operates on.\n ///\n /// Hopefully this will allow us to treat text and token trees in the same way!\n pub trait TokenSource {\n@@ -43,7 +43,7 @@ pub trait TokenSource {\n     fn is_keyword(&self, kw: &str) -> bool;\n }\n \n-/// `TokenCursor` abstracts the cursor of `TokenSource` operates one.\n+/// `Token` abstracts the cursor of `TokenSource` operates on.\n #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n pub struct Token {\n     /// What is the current token?"}, {"sha": "e609e02dc7ab799b4ef813df1695cb455a22eb87", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=3ec781d4f2e2e3087a99b7ace21f97a84b7c7b84", "patch": "@@ -305,44 +305,34 @@ impl ast::Literal {\n             .unwrap()\n     }\n \n-    pub fn kind(&self) -> LiteralKind {\n-        match self.token().kind() {\n-            INT_NUMBER => {\n-                let int_suffix_list = [\n-                    \"isize\", \"i128\", \"i64\", \"i32\", \"i16\", \"i8\", \"usize\", \"u128\", \"u64\", \"u32\",\n-                    \"u16\", \"u8\",\n-                ];\n+    fn find_suffix(text: &str, possible_suffixes: &[&str]) -> Option<SmolStr> {\n+        possible_suffixes\n+            .iter()\n+            .find(|&suffix| text.ends_with(suffix))\n+            .map(|&suffix| SmolStr::new(suffix))\n+    }\n \n-                // The lexer treats e.g. `1f64` as an integer literal. See\n-                // https://github.com/rust-analyzer/rust-analyzer/issues/1592\n-                // and the comments on the linked PR.\n-                let float_suffix_list = [\"f32\", \"f64\"];\n+    pub fn kind(&self) -> LiteralKind {\n+        const INT_SUFFIXES: [&'static str; 12] = [\n+            \"u64\", \"u32\", \"u16\", \"u8\", \"usize\", \"isize\", \"i64\", \"i32\", \"i16\", \"i8\", \"u128\", \"i128\",\n+        ];\n+        const FLOAT_SUFFIXES: [&'static str; 2] = [\"f32\", \"f64\"];\n \n-                let text = self.token().text().to_string();\n+        let token = self.token();\n \n-                let float_suffix = float_suffix_list\n-                    .iter()\n-                    .find(|&s| text.ends_with(s))\n-                    .map(|&suf| SmolStr::new(suf));\n+        match token.kind() {\n+            INT_NUMBER => {\n+                let text = token.text();\n \n-                if float_suffix.is_some() {\n-                    LiteralKind::FloatNumber { suffix: float_suffix }\n+                if let suffix @ Some(_) = Self::find_suffix(&text, &FLOAT_SUFFIXES) {\n+                    LiteralKind::FloatNumber { suffix }\n                 } else {\n-                    let suffix = int_suffix_list\n-                        .iter()\n-                        .find(|&s| text.ends_with(s))\n-                        .map(|&suf| SmolStr::new(suf));\n-                    LiteralKind::IntNumber { suffix }\n+                    LiteralKind::IntNumber { suffix: Self::find_suffix(&text, &INT_SUFFIXES) }\n                 }\n             }\n             FLOAT_NUMBER => {\n-                let allowed_suffix_list = [\"f64\", \"f32\"];\n-                let text = self.token().text().to_string();\n-                let suffix = allowed_suffix_list\n-                    .iter()\n-                    .find(|&s| text.ends_with(s))\n-                    .map(|&suf| SmolStr::new(suf));\n-                LiteralKind::FloatNumber { suffix }\n+                let text = token.text();\n+                LiteralKind::FloatNumber { suffix: Self::find_suffix(&text, &FLOAT_SUFFIXES) }\n             }\n             STRING | RAW_STRING => LiteralKind::String,\n             T![true] | T![false] => LiteralKind::Bool,"}]}