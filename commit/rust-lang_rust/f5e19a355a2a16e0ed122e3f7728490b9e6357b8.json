{"sha": "f5e19a355a2a16e0ed122e3f7728490b9e6357b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZTE5YTM1NWEyYTE2ZTBlZDEyMmUzZjc3Mjg0OTBiOWU2MzU3Yjg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-20T10:08:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-20T10:08:12Z"}, "message": "Rollup merge of #76722 - ssomers:btree_send_sync, r=Mark-Simulacrum\n\nTest and fix Send and Sync traits of BTreeMap artefacts\n\nFixes #76686.\n\nI'm not quite sure what all this implies. E.g. comparing with the definitions for `NodeRef` in node.rs,  maybe an extra bound `T: 'a` is useful for something. The test compiles on stable/beta (apart from `drain_filter`) so I bet `Sync` is equally desirable.\n\nr? @Mark-Simulacrum", "tree": {"sha": "ebbafdc843764a89f66e85acc53bf2497964ffea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebbafdc843764a89f66e85acc53bf2497964ffea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5e19a355a2a16e0ed122e3f7728490b9e6357b8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfZyoMCRBK7hj4Ov3rIwAAdHIIADN4dRahrcDRTI2F4dfLBfhH\nEv165/nRswdvWrEZY+qCTNymcqlmMthnm6sZ9QDT1eSOl3Oc+jdGDXqJfCc5CL9I\nnc++X3Do4vVqT2EApvRiZATT4VQab2UuUybOYuwmQZhy59/rCH3ps+yFtB5Nw0pF\nvMbZ9fO8plWUTUVaxl5SzRvrRPkRsnzORENRX3grUMSBYdGyi850tRYTIWOqMpVf\nrWd0mXwaSakrxbQLw3pyp4w3v5i2rgITZjR8oMP6s86NQDg8UUdF89VDDd3pIj9m\nKbJDXKdn3fX+T9OY9g9AAzRpxivRc2sW4kwDnhrH4DrVc/zueqnSXJej65FzUPc=\n=3T2r\n-----END PGP SIGNATURE-----\n", "payload": "tree ebbafdc843764a89f66e85acc53bf2497964ffea\nparent 10b3595ba6a4c658c9dea105488fc562c815e434\nparent 176956c115c2b797471a3f59eef3e17789229007\nauthor Ralf Jung <post@ralfj.de> 1600596492 +0200\ncommitter GitHub <noreply@github.com> 1600596492 +0200\n\nRollup merge of #76722 - ssomers:btree_send_sync, r=Mark-Simulacrum\n\nTest and fix Send and Sync traits of BTreeMap artefacts\n\nFixes #76686.\n\nI'm not quite sure what all this implies. E.g. comparing with the definitions for `NodeRef` in node.rs,  maybe an extra bound `T: 'a` is useful for something. The test compiles on stable/beta (apart from `drain_filter`) so I bet `Sync` is equally desirable.\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5e19a355a2a16e0ed122e3f7728490b9e6357b8", "html_url": "https://github.com/rust-lang/rust/commit/f5e19a355a2a16e0ed122e3f7728490b9e6357b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5e19a355a2a16e0ed122e3f7728490b9e6357b8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b3595ba6a4c658c9dea105488fc562c815e434", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b3595ba6a4c658c9dea105488fc562c815e434", "html_url": "https://github.com/rust-lang/rust/commit/10b3595ba6a4c658c9dea105488fc562c815e434"}, {"sha": "176956c115c2b797471a3f59eef3e17789229007", "url": "https://api.github.com/repos/rust-lang/rust/commits/176956c115c2b797471a3f59eef3e17789229007", "html_url": "https://github.com/rust-lang/rust/commit/176956c115c2b797471a3f59eef3e17789229007"}], "stats": {"total": 143, "additions": 143, "deletions": 0}, "files": [{"sha": "016f139a501a00da5749e941e4c1d47df2fdaccb", "filename": "library/alloc/src/collections/btree/borrow.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5e19a355a2a16e0ed122e3f7728490b9e6357b8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e19a355a2a16e0ed122e3f7728490b9e6357b8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs?ref=f5e19a355a2a16e0ed122e3f7728490b9e6357b8", "patch": "@@ -16,6 +16,9 @@ pub struct DormantMutRef<'a, T> {\n     _marker: PhantomData<&'a mut T>,\n }\n \n+unsafe impl<'a, T> Sync for DormantMutRef<'a, T> where &'a mut T: Sync {}\n+unsafe impl<'a, T> Send for DormantMutRef<'a, T> where &'a mut T: Send {}\n+\n impl<'a, T> DormantMutRef<'a, T> {\n     /// Capture a unique borrow, and immediately reborrow it. For the compiler,\n     /// the lifetime of the new reference is the same as the lifetime of the"}, {"sha": "d2cd6b8e5241ad7e2fbd7dc0ee469eb7bd7826aa", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/f5e19a355a2a16e0ed122e3f7728490b9e6357b8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5e19a355a2a16e0ed122e3f7728490b9e6357b8/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=f5e19a355a2a16e0ed122e3f7728490b9e6357b8", "patch": "@@ -1418,6 +1418,146 @@ fn test_variance() {\n     }\n }\n \n+#[test]\n+#[allow(dead_code)]\n+fn test_sync() {\n+    fn map<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v\n+    }\n+\n+    fn into_iter<T: Sync>(v: BTreeMap<T, T>) -> impl Sync {\n+        v.into_iter()\n+    }\n+\n+    fn into_keys<T: Sync + Ord>(v: BTreeMap<T, T>) -> impl Sync {\n+        v.into_keys()\n+    }\n+\n+    fn into_values<T: Sync + Ord>(v: BTreeMap<T, T>) -> impl Sync {\n+        v.into_values()\n+    }\n+\n+    fn drain_filter<T: Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.drain_filter(|_, _| false)\n+    }\n+\n+    fn iter<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.iter()\n+    }\n+\n+    fn iter_mut<T: Sync>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.iter_mut()\n+    }\n+\n+    fn keys<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.keys()\n+    }\n+\n+    fn values<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.values()\n+    }\n+\n+    fn values_mut<T: Sync>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.values_mut()\n+    }\n+\n+    fn range<T: Sync + Ord>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.range(..)\n+    }\n+\n+    fn range_mut<T: Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.range_mut(..)\n+    }\n+\n+    fn entry<T: Sync + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.entry(Default::default())\n+    }\n+\n+    fn occupied_entry<T: Sync + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        match v.entry(Default::default()) {\n+            Occupied(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn vacant_entry<T: Sync + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        match v.entry(Default::default()) {\n+            Vacant(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[test]\n+#[allow(dead_code)]\n+fn test_send() {\n+    fn map<T: Send>(v: BTreeMap<T, T>) -> impl Send {\n+        v\n+    }\n+\n+    fn into_iter<T: Send>(v: BTreeMap<T, T>) -> impl Send {\n+        v.into_iter()\n+    }\n+\n+    fn into_keys<T: Send + Ord>(v: BTreeMap<T, T>) -> impl Send {\n+        v.into_keys()\n+    }\n+\n+    fn into_values<T: Send + Ord>(v: BTreeMap<T, T>) -> impl Send {\n+        v.into_values()\n+    }\n+\n+    fn drain_filter<T: Send + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.drain_filter(|_, _| false)\n+    }\n+\n+    fn iter<T: Send + Sync>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.iter()\n+    }\n+\n+    fn iter_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.iter_mut()\n+    }\n+\n+    fn keys<T: Send + Sync>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.keys()\n+    }\n+\n+    fn values<T: Send + Sync>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.values()\n+    }\n+\n+    fn values_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.values_mut()\n+    }\n+\n+    fn range<T: Send + Sync + Ord>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.range(..)\n+    }\n+\n+    fn range_mut<T: Send + Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.range_mut(..)\n+    }\n+\n+    fn entry<T: Send + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.entry(Default::default())\n+    }\n+\n+    fn occupied_entry<T: Send + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        match v.entry(Default::default()) {\n+            Occupied(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn vacant_entry<T: Send + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        match v.entry(Default::default()) {\n+            Vacant(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n #[test]\n fn test_occupied_entry_key() {\n     let mut a = BTreeMap::new();"}]}