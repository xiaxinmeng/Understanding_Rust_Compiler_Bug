{"sha": "94796e6447c8af9d7444164c2175ca5dae4a563e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0Nzk2ZTY0NDdjOGFmOWQ3NDQ0MTY0YzIxNzVjYTVkYWU0YTU2M2U=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "github@adolfo.ochagavia.xyz", "date": "2018-11-07T10:35:33Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "github@adolfo.ochagavia.xyz", "date": "2018-11-07T10:35:33Z"}, "message": "Add lots of tests", "tree": {"sha": "7bc99ebcc33cc272ce23823bae3a4d19ec216d34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bc99ebcc33cc272ce23823bae3a4d19ec216d34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94796e6447c8af9d7444164c2175ca5dae4a563e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94796e6447c8af9d7444164c2175ca5dae4a563e", "html_url": "https://github.com/rust-lang/rust/commit/94796e6447c8af9d7444164c2175ca5dae4a563e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94796e6447c8af9d7444164c2175ca5dae4a563e/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdb9f06880ddcf29513a8c2855c3c576cc461014", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdb9f06880ddcf29513a8c2855c3c576cc461014", "html_url": "https://github.com/rust-lang/rust/commit/fdb9f06880ddcf29513a8c2855c3c576cc461014"}], "stats": {"total": 131, "additions": 125, "deletions": 6}, "files": [{"sha": "7e4df51aa892de900e00f31f35cd6836fcbe52d2", "filename": "crates/ra_syntax/src/lexer/ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94796e6447c8af9d7444164c2175ca5dae4a563e/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94796e6447c8af9d7444164c2175ca5dae4a563e/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs?ref=94796e6447c8af9d7444164c2175ca5dae4a563e", "patch": "@@ -30,8 +30,7 @@ impl<'s> Ptr<'s> {\n     /// Gets the nth character from the current.\n     /// For example, 0 will return the current token, 1 will return the next, etc.\n     pub fn nth(&self, n: u32) -> Option<char> {\n-        let mut chars = self.chars().peekable();\n-        chars.by_ref().nth(n as usize)\n+        self.chars().nth(n as usize)\n     }\n \n     /// Checks whether the current character is `c`."}, {"sha": "1778f4b886a20ba80672e25caa283eed1cd5e1f1", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 118, "deletions": 4, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/94796e6447c8af9d7444164c2175ca5dae4a563e/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94796e6447c8af9d7444164c2175ca5dae4a563e/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=94796e6447c8af9d7444164c2175ca5dae4a563e", "patch": "@@ -121,11 +121,13 @@ fn validate_char(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n                         errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n                     }\n                 }\n-\n-                // FIXME: we really need tests for this\n             }\n-            // Code points are always valid\n-            CodePoint => (),\n+            CodePoint => {\n+                // These code points must always be escaped\n+                if text == \"\\t\" || text == \"\\r\" {\n+                    errors.push(SyntaxError::new(UnescapedCodepoint, range));\n+                }\n+            },\n         }\n     }\n \n@@ -148,3 +150,115 @@ fn is_ascii_escape(code: char) -> bool {\n         _ => false,\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::File;\n+\n+    fn build_file(literal: &str) -> File {\n+        let src = format!(\"const C: char = '{}';\", literal);\n+        File::parse(&src)\n+    }\n+\n+    fn assert_valid_char(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() == 0, \"Errors for literal '{}': {:?}\", literal, file.errors());\n+    }\n+\n+    fn assert_invalid_char(literal: &str) { //, expected_errors: HashSet<SyntaxErrorKind>) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+        //let found_errors = file.errors().iter().map(|e| e.kind()).collect();\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..=255u8 {\n+            match byte {\n+                b'\\n' | b'\\r' | b'\\t' => assert_invalid_char(&(byte as char).to_string()),\n+                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n+                _ => assert_valid_char(&(byte as char).to_string()),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let valid = [\n+            \"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let invalid = [\n+            \"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"\n+        ];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_escape() {\n+        let valid = [\n+            r\"\\'\", \"\\\"\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\"\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_escape() {\n+        let invalid = [\n+            r\"\\a\", r\"\\?\", r\"\\\"\n+        ];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_code_escape() {\n+        let valid = [\n+            r\"\\x00\", r\"\\x7F\", r\"\\x55\"\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_code_escape() {\n+        let invalid = [\n+            r\"\\x\", r\"\\x7\", r\"\\xF0\"\n+        ];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+\n+     #[test]\n+    fn test_valid_unicode_escape() {\n+        let valid = [\n+            r\"\\u{FF}\", r\"\\u{0}\", r\"\\u{F}\", r\"\\u{10FFFF}\", r\"\\u{1_0__FF___FF_____}\"\n+        ];\n+        for c in &valid {\n+            assert_valid_char(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let invalid = [\n+            r\"\\u\", r\"\\u{}\", r\"\\u{\", r\"\\u{FF\", r\"\\u{FFFFFF}\", r\"\\u{_F}\", r\"\\u{00FFFFF}\", r\"\\u{110000}\"\n+        ];\n+        for c in &invalid {\n+            assert_invalid_char(c);\n+        }\n+    }\n+}"}, {"sha": "e2e660975b0b4ae80b2a276430eb0ca32d2bf8df", "filename": "crates/ra_syntax/src/yellow/syntax_error.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/94796e6447c8af9d7444164c2175ca5dae4a563e/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94796e6447c8af9d7444164c2175ca5dae4a563e/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs?ref=94796e6447c8af9d7444164c2175ca5dae4a563e", "patch": "@@ -34,6 +34,10 @@ impl SyntaxError {\n         }\n     }\n \n+    pub fn kind(&self) -> SyntaxErrorKind {\n+        self.kind.clone()\n+    }\n+\n     pub fn location(&self) -> Location {\n         self.location.clone()\n     }\n@@ -64,6 +68,7 @@ impl fmt::Display for SyntaxError {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum SyntaxErrorKind {\n     ParseError(ParseError),\n+    UnescapedCodepoint,\n     EmptyChar,\n     UnclosedChar,\n     LongChar,\n@@ -86,6 +91,7 @@ impl fmt::Display for SyntaxErrorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::SyntaxErrorKind::*;\n         match self {\n+            UnescapedCodepoint => write!(f, \"This codepoint should always be escaped\"),\n             EmptyAsciiEscape => write!(f, \"Empty escape sequence\"),\n             InvalidAsciiEscape => write!(f, \"Invalid escape sequence\"),\n             EmptyChar => write!(f, \"Empty char literal\"),"}]}