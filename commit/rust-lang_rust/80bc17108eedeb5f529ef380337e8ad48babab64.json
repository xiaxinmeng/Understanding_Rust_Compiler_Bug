{"sha": "80bc17108eedeb5f529ef380337e8ad48babab64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYmMxNzEwOGVlZGViNWY1MjllZjM4MDMzN2U4YWQ0OGJhYmFiNjQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-09-28T13:25:02Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-10-05T10:04:47Z"}, "message": "Improve diagnostics for borrow-check errors that result from drops of temporary r-values.\n\nChanged `BorrowExplanation::UsedLaterWhenDropped` to handle both named\nlocals and also unnamed (aka temporaries).\n\nIf the dropped temporary does not implement `Drop`, then we print its\nfull type; but when the dropped temporary is itself an ADT `D` that\nimplements `Drop`, then diagnostic points the user directly at `D`.", "tree": {"sha": "7f33afe56970d5ed12386e2052c1b6d3f790075f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f33afe56970d5ed12386e2052c1b6d3f790075f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80bc17108eedeb5f529ef380337e8ad48babab64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80bc17108eedeb5f529ef380337e8ad48babab64", "html_url": "https://github.com/rust-lang/rust/commit/80bc17108eedeb5f529ef380337e8ad48babab64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80bc17108eedeb5f529ef380337e8ad48babab64/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "504ab34e6298bf7c743d1df0cd3f48522355552d", "url": "https://api.github.com/repos/rust-lang/rust/commits/504ab34e6298bf7c743d1df0cd3f48522355552d", "html_url": "https://github.com/rust-lang/rust/commit/504ab34e6298bf7c743d1df0cd3f48522355552d"}], "stats": {"total": 155, "additions": 108, "deletions": 47}, "files": [{"sha": "53a190efb58355b484c19f6dee7be91fc8cf8a28", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80bc17108eedeb5f529ef380337e8ad48babab64/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bc17108eedeb5f529ef380337e8ad48babab64/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=80bc17108eedeb5f529ef380337e8ad48babab64", "patch": "@@ -770,7 +770,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match explanation {\n             BorrowExplanation::UsedLater(..)\n             | BorrowExplanation::UsedLaterInLoop(..)\n-            | BorrowExplanation::UsedLaterWhenDropped(..) => {\n+            | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n                 // Only give this note and suggestion if it could be relevant.\n                 err.note(\"consider using a `let` binding to create a longer lived value\");\n             }"}, {"sha": "e55469436abf0a72b08541f9d4097ae143a4a30c", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 101, "deletions": 46, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/80bc17108eedeb5f529ef380337e8ad48babab64/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bc17108eedeb5f529ef380337e8ad48babab64/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=80bc17108eedeb5f529ef380337e8ad48babab64", "patch": "@@ -12,18 +12,22 @@ use borrow_check::borrow_set::BorrowData;\n use borrow_check::error_reporting::UseSpans;\n use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n-use rustc::ty::{Region, TyCtxt};\n-use rustc::mir::{FakeReadCause, Location, Mir, Operand, Place, StatementKind, TerminatorKind};\n+use rustc::ty::{self, Region, TyCtxt};\n+use rustc::mir::{FakeReadCause, Local, Location, Mir, Operand};\n+use rustc::mir::{Place, StatementKind, TerminatorKind};\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n-use syntax_pos::symbol::Symbol;\n \n mod find_use;\n \n pub(in borrow_check) enum BorrowExplanation<'tcx> {\n     UsedLater(LaterUseKind, Span),\n     UsedLaterInLoop(LaterUseKind, Span),\n-    UsedLaterWhenDropped(Span, Symbol, bool),\n+    UsedLaterWhenDropped {\n+        drop_loc: Location,\n+        dropped_local: Local,\n+        should_note_order: bool,\n+    },\n     MustBeValidFor(Region<'tcx>),\n     Unexplained,\n }\n@@ -40,7 +44,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n     pub(in borrow_check) fn add_explanation_to_diagnostic<'cx, 'gcx>(\n         &self,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        _mir: &Mir<'tcx>,\n+        mir: &Mir<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         borrow_desc: &str,\n     ) {\n@@ -65,23 +69,76 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                 };\n                 err.span_label(var_or_use_span, format!(\"{}{}\", borrow_desc, message));\n             },\n-            BorrowExplanation::UsedLaterWhenDropped(span, local_name, should_note_order) => {\n-                err.span_label(\n-                    span,\n-                    format!(\n-                        \"{}borrow later used here, when `{}` is dropped\",\n-                        borrow_desc,\n-                        local_name,\n-                    ),\n-                );\n+            BorrowExplanation::UsedLaterWhenDropped { drop_loc, dropped_local,\n+                                                      should_note_order } =>\n+            {\n+                let local_decl = &mir.local_decls[dropped_local];\n+                let (dtor_desc, type_desc) = match local_decl.ty.sty {\n+                    // If type is an ADT that implements Drop, then\n+                    // simplify output by reporting just the ADT name.\n+                    ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() =>\n+                        (\"`Drop` code\", format!(\"type `{}`\", tcx.item_path_str(adt.did))),\n+\n+                    // Otherwise, just report the whole type (and use\n+                    // the intentionally fuzzy phrase \"destructor\")\n+                    ty::Closure(..) =>\n+                        (\"destructor\", format!(\"closure\")),\n+                    ty::Generator(..) =>\n+                        (\"destructor\", format!(\"generator\")),\n+\n+                    _ => (\"destructor\", format!(\"type `{}`\", local_decl.ty)),\n+                };\n+\n+                match local_decl.name {\n+                    Some(local_name) => {\n+                        let message =\n+                            format!(\"{B}borrow might be used here, when `{LOC}` is dropped \\\n+                                     and runs the {DTOR} for {TYPE}\",\n+                                    B=borrow_desc, LOC=local_name, TYPE=type_desc, DTOR=dtor_desc);\n+                        err.span_label(mir.source_info(drop_loc).span, message);\n+\n+                        if should_note_order {\n+                            err.note(\n+                                \"values in a scope are dropped \\\n+                                 in the opposite order they are defined\",\n+                            );\n+                        }\n+                    }\n+                    None => {\n+                        err.span_label(local_decl.source_info.span,\n+                                       format!(\"a temporary with access to the {B}borrow \\\n+                                                is created here ...\",\n+                                               B=borrow_desc));\n+                        let message =\n+                            format!(\"... and the {B}borrow might be used here, \\\n+                                     when that temporary is dropped \\\n+                                     and runs the {DTOR} for {TYPE}\",\n+                                    B=borrow_desc, TYPE=type_desc, DTOR=dtor_desc);\n+                        err.span_label(mir.source_info(drop_loc).span, message);\n+\n+                        if let Some(info) = &local_decl.is_block_tail {\n+                            // FIXME: use span_suggestion instead, highlighting the\n+                            // whole block tail expression.\n+                            let msg = if info.tail_result_is_ignored {\n+                                \"The temporary is part of an expression at the end of a block. \\\n+                                 Consider adding semicolon after the expression so its temporaries \\\n+                                 are dropped sooner, before the local variables declared by the \\\n+                                 block are dropped.\"\n+                            } else {\n+                                \"The temporary is part of an expression at the end of a block. \\\n+                                 Consider forcing this temporary to be dropped sooner, before \\\n+                                 the block's local variables are dropped. \\\n+                                 For example, you could save the expression's value in a new \\\n+                                 local variable `x` and then make `x` be the expression \\\n+                                 at the end of the block.\"\n+                            };\n \n-                if should_note_order {\n-                    err.note(\n-                        \"values in a scope are dropped \\\n-                         in the opposite order they are defined\",\n-                    );\n+                            err.note(msg);\n+                        }\n+                    }\n                 }\n-            },\n+            }\n+\n             BorrowExplanation::MustBeValidFor(region) => {\n                 tcx.note_and_explain_free_region(\n                     err,\n@@ -116,8 +173,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n     ) -> BorrowExplanation<'tcx> {\n         debug!(\n-            \"explain_why_borrow_contains_point(context={:?}, borrow={:?})\",\n-            context, borrow,\n+            \"explain_why_borrow_contains_point(context={:?}, borrow={:?}, kind_place={:?})\",\n+            context, borrow, kind_place\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n@@ -154,32 +211,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {\n-                Some(local_name) => {\n-                    let mut should_note_order = false;\n-                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                        if let Place::Local(borrowed_local) = place {\n-                            let dropped_local_scope = mir.local_decls[local].visibility_scope;\n-                            let borrowed_local_scope =\n-                                mir.local_decls[*borrowed_local].visibility_scope;\n+             Some(Cause::DropVar(local, location)) => {\n+                 let mut should_note_order = false;\n+                 if mir.local_decls[local].name.is_some() {\n+                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n+                         if let Place::Local(borrowed_local) = place {\n+                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n+                             let borrowed_local_scope =\n+                                 mir.local_decls[*borrowed_local].visibility_scope;\n \n-                            if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n-                                && local != *borrowed_local\n-                            {\n-                                should_note_order = true;\n-                            }\n-                        }\n-                    }\n-\n-                    BorrowExplanation::UsedLaterWhenDropped(\n-                        mir.source_info(location).span,\n-                        *local_name,\n-                        should_note_order\n-                    )\n-                },\n+                             if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope)\n+                                 && local != *borrowed_local\n+                             {\n+                                 should_note_order = true;\n+                             }\n+                         }\n+                     }\n+                 }\n \n-                None => BorrowExplanation::Unexplained,\n-            },\n+                 BorrowExplanation::UsedLaterWhenDropped {\n+                     drop_loc: location,\n+                     dropped_local: local,\n+                     should_note_order,\n+                 }\n+            }\n \n             None => if let Some(region) = regioncx.to_error_region(region_sub) {\n                 BorrowExplanation::MustBeValidFor(region)"}, {"sha": "d2b39f088b65e8c401ae5a35dd01214a82d6acaa", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80bc17108eedeb5f529ef380337e8ad48babab64/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80bc17108eedeb5f529ef380337e8ad48babab64/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=80bc17108eedeb5f529ef380337e8ad48babab64", "patch": "@@ -20,6 +20,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = this.source_info(expr.span);\n         // Handle a number of expressions that don't need a destination at all. This\n         // avoids needing a mountain of temporary `()` variables.\n+        let expr2 = expr.clone();\n         match expr.kind {\n             ExprKind::Scope {\n                 region_scope,\n@@ -40,6 +41,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // is better for borrowck interaction with overloaded\n                 // operators like x[j] = x[i].\n \n+                debug!(\"stmt_expr Assign block_context.push(SubExpr) : {:?}\", expr2);\n                 this.block_context.push(BlockFrame::SubExpr);\n \n                 // Generate better code for things that don't need to be\n@@ -69,6 +71,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let lhs = this.hir.mirror(lhs);\n                 let lhs_ty = lhs.ty;\n \n+                debug!(\"stmt_expr AssignOp block_context.push(SubExpr) : {:?}\", expr2);\n                 this.block_context.push(BlockFrame::SubExpr);\n \n                 // As above, RTL.\n@@ -120,6 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (break_block, region_scope, break_destination.clone())\n                 };\n                 if let Some(value) = value {\n+                    debug!(\"stmt_expr Break val block_context.push(SubExpr) : {:?}\", expr2);\n                     this.block_context.push(BlockFrame::SubExpr);\n                     unpack!(block = this.into(&destination, block, value));\n                     this.block_context.pop();\n@@ -132,6 +136,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Return { value } => {\n                 block = match value {\n                     Some(value) => {\n+                        debug!(\"stmt_expr Return val block_context.push(SubExpr) : {:?}\", expr2);\n                         this.block_context.push(BlockFrame::SubExpr);\n                         let result = unpack!(this.into(&Place::Local(RETURN_PLACE), block, value));\n                         this.block_context.pop();\n@@ -153,6 +158,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 outputs,\n                 inputs,\n             } => {\n+                debug!(\"stmt_expr InlineAsm block_context.push(SubExpr) : {:?}\", expr2);\n                 this.block_context.push(BlockFrame::SubExpr);\n                 let outputs = outputs\n                     .into_iter()"}]}