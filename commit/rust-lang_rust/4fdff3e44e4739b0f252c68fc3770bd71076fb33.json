{"sha": "4fdff3e44e4739b0f252c68fc3770bd71076fb33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZGZmM2U0NGU0NzM5YjBmMjUyYzY4ZmMzNzcwYmQ3MTA3NmZiMzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T08:07:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T08:09:23Z"}, "message": "native: Fix a possible deadlock in spawn\n\nThe OSX bots have been deadlocking recently in the rustdoc tests. I have only\nbeen able to rarely reproduce the deadlock on my local setup. When reproduced,\nit looks like the child process is spinning on the malloc mutex, which I\npresume is locked with no other threads to unlock it.\n\nI'm not convinced that this is what's happening, because OSX should protect\nagainst this with pthread_atfork by default. Regardless, running as little code\nas possible in the child after fork() is normally a good idea anyway, so this\ncommit moves all allocation to the parent process to run before the child\nexecutes.\n\nAfter running 6k iterations of rustdoc tests, this deadlocked twice before, and\nafter 20k iterations afterwards, it never deadlocked. I draw the conclusion that\nthis is either sweeping the bug under the rug, or it did indeed fix the\nunderlying problem.", "tree": {"sha": "7fb82431c7135a3af6c91539d79a89582899becd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fb82431c7135a3af6c91539d79a89582899becd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fdff3e44e4739b0f252c68fc3770bd71076fb33", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdff3e44e4739b0f252c68fc3770bd71076fb33", "html_url": "https://github.com/rust-lang/rust/commit/4fdff3e44e4739b0f252c68fc3770bd71076fb33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fdff3e44e4739b0f252c68fc3770bd71076fb33/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "739f22f611869d82bc6b5525426ad721c9674040", "url": "https://api.github.com/repos/rust-lang/rust/commits/739f22f611869d82bc6b5525426ad721c9674040", "html_url": "https://github.com/rust-lang/rust/commit/739f22f611869d82bc6b5525426ad721c9674040"}], "stats": {"total": 212, "additions": 105, "deletions": 107}, "files": [{"sha": "28f0817670b8fe1342681837394543640e66bc25", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 105, "deletions": 107, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/4fdff3e44e4739b0f252c68fc3770bd71076fb33/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdff3e44e4739b0f252c68fc3770bd71076fb33/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=4fdff3e44e4739b0f252c68fc3770bd71076fb33", "patch": "@@ -446,132 +446,129 @@ fn spawn_process_os(config: p::ProcessConfig,\n         assert_eq!(ret, 0);\n     }\n \n-    let pipe = os::pipe();\n-    let mut input = file::FileDesc::new(pipe.input, true);\n-    let mut output = file::FileDesc::new(pipe.out, true);\n+    let dirp = dir.map(|p| p.to_c_str());\n+    let dirp = dirp.as_ref().map(|c| c.with_ref(|p| p)).unwrap_or(ptr::null());\n+\n+    with_envp(env, proc(envp) {\n+        with_argv(config.program, config.args, proc(argv) unsafe {\n+            let pipe = os::pipe();\n+            let mut input = file::FileDesc::new(pipe.input, true);\n+            let mut output = file::FileDesc::new(pipe.out, true);\n+\n+            set_cloexec(output.fd());\n+\n+            let pid = fork();\n+            if pid < 0 {\n+                fail!(\"failure in fork: {}\", os::last_os_error());\n+            } else if pid > 0 {\n+                drop(output);\n+                let mut bytes = [0, ..4];\n+                return match input.inner_read(bytes) {\n+                    Ok(4) => {\n+                        let errno = (bytes[0] << 24) as i32 |\n+                                    (bytes[1] << 16) as i32 |\n+                                    (bytes[2] <<  8) as i32 |\n+                                    (bytes[3] <<  0) as i32;\n+                        Err(super::translate_error(errno, false))\n+                    }\n+                    Err(e) => {\n+                        assert!(e.kind == io::BrokenPipe ||\n+                                e.kind == io::EndOfFile,\n+                                \"unexpected error: {}\", e);\n+                        Ok(SpawnProcessResult {\n+                            pid: pid,\n+                            handle: ptr::null()\n+                        })\n+                    }\n+                    Ok(..) => fail!(\"short read on the cloexec pipe\"),\n+                };\n+            }\n+            drop(input);\n+\n+            fn fail(output: &mut file::FileDesc) -> ! {\n+                let errno = os::errno();\n+                let bytes = [\n+                    (errno << 24) as u8,\n+                    (errno << 16) as u8,\n+                    (errno <<  8) as u8,\n+                    (errno <<  0) as u8,\n+                ];\n+                assert!(output.inner_write(bytes).is_ok());\n+                unsafe { libc::_exit(1) }\n+            }\n \n-    unsafe { set_cloexec(output.fd()) };\n+            rustrt::rust_unset_sigprocmask();\n \n-    unsafe {\n-        let pid = fork();\n-        if pid < 0 {\n-            fail!(\"failure in fork: {}\", os::last_os_error());\n-        } else if pid > 0 {\n-            drop(output);\n-            let mut bytes = [0, ..4];\n-            return match input.inner_read(bytes) {\n-                Ok(4) => {\n-                    let errno = (bytes[0] << 24) as i32 |\n-                                (bytes[1] << 16) as i32 |\n-                                (bytes[2] <<  8) as i32 |\n-                                (bytes[3] <<  0) as i32;\n-                    Err(super::translate_error(errno, false))\n-                }\n-                Err(e) => {\n-                    assert!(e.kind == io::BrokenPipe ||\n-                            e.kind == io::EndOfFile,\n-                            \"unexpected error: {}\", e);\n-                    Ok(SpawnProcessResult {\n-                        pid: pid,\n-                        handle: ptr::null()\n-                    })\n+            if in_fd == -1 {\n+                let _ = libc::close(libc::STDIN_FILENO);\n+            } else if retry(|| dup2(in_fd, 0)) == -1 {\n+                fail(&mut output);\n+            }\n+            if out_fd == -1 {\n+                let _ = libc::close(libc::STDOUT_FILENO);\n+            } else if retry(|| dup2(out_fd, 1)) == -1 {\n+                fail(&mut output);\n+            }\n+            if err_fd == -1 {\n+                let _ = libc::close(libc::STDERR_FILENO);\n+            } else if retry(|| dup2(err_fd, 2)) == -1 {\n+                fail(&mut output);\n+            }\n+            // close all other fds\n+            for fd in range(3, getdtablesize()).rev() {\n+                if fd != output.fd() {\n+                    let _ = close(fd as c_int);\n                 }\n-                Ok(..) => fail!(\"short read on the cloexec pipe\"),\n-            };\n-        }\n-        drop(input);\n-\n-        fn fail(output: &mut file::FileDesc) -> ! {\n-            let errno = os::errno();\n-            let bytes = [\n-                (errno << 24) as u8,\n-                (errno << 16) as u8,\n-                (errno <<  8) as u8,\n-                (errno <<  0) as u8,\n-            ];\n-            assert!(output.inner_write(bytes).is_ok());\n-            unsafe { libc::_exit(1) }\n-        }\n-\n-        rustrt::rust_unset_sigprocmask();\n-\n-        if in_fd == -1 {\n-            let _ = libc::close(libc::STDIN_FILENO);\n-        } else if retry(|| dup2(in_fd, 0)) == -1 {\n-            fail(&mut output);\n-        }\n-        if out_fd == -1 {\n-            let _ = libc::close(libc::STDOUT_FILENO);\n-        } else if retry(|| dup2(out_fd, 1)) == -1 {\n-            fail(&mut output);\n-        }\n-        if err_fd == -1 {\n-            let _ = libc::close(libc::STDERR_FILENO);\n-        } else if retry(|| dup2(err_fd, 2)) == -1 {\n-            fail(&mut output);\n-        }\n-        // close all other fds\n-        for fd in range(3, getdtablesize()).rev() {\n-            if fd != output.fd() {\n-                let _ = close(fd as c_int);\n             }\n-        }\n \n-        match config.gid {\n-            Some(u) => {\n-                if libc::setgid(u as libc::gid_t) != 0 {\n-                    fail(&mut output);\n+            match config.gid {\n+                Some(u) => {\n+                    if libc::setgid(u as libc::gid_t) != 0 {\n+                        fail(&mut output);\n+                    }\n                 }\n+                None => {}\n             }\n-            None => {}\n-        }\n-        match config.uid {\n-            Some(u) => {\n-                // When dropping privileges from root, the `setgroups` call will\n-                // remove any extraneous groups. If we don't call this, then\n-                // even though our uid has dropped, we may still have groups\n-                // that enable us to do super-user things. This will fail if we\n-                // aren't root, so don't bother checking the return value, this\n-                // is just done as an optimistic privilege dropping function.\n-                extern {\n-                    fn setgroups(ngroups: libc::c_int,\n-                                 ptr: *libc::c_void) -> libc::c_int;\n-                }\n-                let _ = setgroups(0, 0 as *libc::c_void);\n+            match config.uid {\n+                Some(u) => {\n+                    // When dropping privileges from root, the `setgroups` call will\n+                    // remove any extraneous groups. If we don't call this, then\n+                    // even though our uid has dropped, we may still have groups\n+                    // that enable us to do super-user things. This will fail if we\n+                    // aren't root, so don't bother checking the return value, this\n+                    // is just done as an optimistic privilege dropping function.\n+                    extern {\n+                        fn setgroups(ngroups: libc::c_int,\n+                                     ptr: *libc::c_void) -> libc::c_int;\n+                    }\n+                    let _ = setgroups(0, 0 as *libc::c_void);\n \n-                if libc::setuid(u as libc::uid_t) != 0 {\n-                    fail(&mut output);\n+                    if libc::setuid(u as libc::uid_t) != 0 {\n+                        fail(&mut output);\n+                    }\n                 }\n+                None => {}\n+            }\n+            if config.detach {\n+                // Don't check the error of setsid because it fails if we're the\n+                // process leader already. We just forked so it shouldn't return\n+                // error, but ignore it anyway.\n+                let _ = libc::setsid();\n             }\n-            None => {}\n-        }\n-        if config.detach {\n-            // Don't check the error of setsid because it fails if we're the\n-            // process leader already. We just forked so it shouldn't return\n-            // error, but ignore it anyway.\n-            let _ = libc::setsid();\n-        }\n-\n-        with_dirp(dir, |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n                 fail(&mut output);\n             }\n-        });\n-\n-        with_envp(env, |envp| {\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-            with_argv(config.program, config.args, |argv| {\n-                let _ = execvp(*argv, argv);\n-                fail(&mut output);\n-            })\n+            let _ = execvp(*argv, argv);\n+            fail(&mut output);\n         })\n-    }\n+    })\n }\n \n #[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n+fn with_argv<T>(prog: &str, args: &[~str], cb: proc:(**libc::c_char) -> T) -> T {\n     use std::slice;\n \n     // We can't directly convert `str`s into `*char`s, as someone needs to hold\n@@ -597,7 +594,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n }\n \n #[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n+fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: proc:(*c_void) -> T) -> T {\n     use std::slice;\n \n     // On posixy systems we can pass a char** for envp, which is a\n@@ -645,6 +642,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n     }\n }\n \n+#[cfg(windows)]\n fn with_dirp<T>(d: Option<&Path>, cb: |*libc::c_char| -> T) -> T {\n     match d {\n       Some(dir) => dir.with_c_str(|buf| cb(buf)),"}]}