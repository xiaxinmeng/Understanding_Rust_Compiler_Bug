{"sha": "3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMTg2MmE4MmYwNGY4ZjViY2IxOTc3MTVkMmZmNTA2YzZjZGVjYzM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-11-02T01:06:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-04T22:44:12Z"}, "message": "Don't allow newtype structs to be dereferenced. #6246", "tree": {"sha": "0057a02e6d56e9bea0357d649a420b6e66b5be71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0057a02e6d56e9bea0357d649a420b6e66b5be71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "html_url": "https://github.com/rust-lang/rust/commit/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "html_url": "https://github.com/rust-lang/rust/commit/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e"}], "stats": {"total": 1260, "additions": 590, "deletions": 670}, "files": [{"sha": "988a642e58372521c2adcf2358609070e5168e1e", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -107,7 +107,8 @@ impl<Q:Send> Sem<Q> {\n     pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n-            (**self).with(|state| {\n+            let Sem(ref lock) = *self;\n+            lock.with(|state| {\n                 state.count -= 1;\n                 if state.count < 0 {\n                     // Create waiter nobe, enqueue ourself, and tell\n@@ -126,7 +127,8 @@ impl<Q:Send> Sem<Q> {\n \n     pub fn release(&self) {\n         unsafe {\n-            (**self).with(|state| {\n+            let Sem(ref lock) = *self;\n+            lock.with(|state| {\n                 state.count += 1;\n                 if state.count <= 0 {\n                     state.waiters.signal();\n@@ -206,7 +208,8 @@ impl<'a> Condvar<'a> {\n         let mut out_of_bounds = None;\n         // Release lock, 'atomically' enqueuing ourselves in so doing.\n         unsafe {\n-            (**self.sem).with(|state| {\n+            let Sem(ref queue) = *self.sem;\n+            queue.with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // Drop the lock.\n                     state.count += 1;\n@@ -248,7 +251,8 @@ impl<'a> Condvar<'a> {\n         unsafe {\n             let mut out_of_bounds = None;\n             let mut result = false;\n-            (**self.sem).with(|state| {\n+            let Sem(ref lock) = *self.sem;\n+            lock.with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     result = state.blocked[condvar_id].signal();\n                 } else {\n@@ -270,7 +274,8 @@ impl<'a> Condvar<'a> {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n         unsafe {\n-            (**self.sem).with(|state| {\n+            let Sem(ref lock) = *self.sem;\n+            lock.with(|state| {\n                 if condvar_id < state.blocked.len() {\n                     // To avoid :broadcast_heavy, we make a new waitqueue,\n                     // swap it out with the old one, and broadcast on the\n@@ -336,7 +341,8 @@ pub struct Semaphore { priv sem: Sem<()> }\n impl Clone for Semaphore {\n     /// Create a new handle to the semaphore.\n     fn clone(&self) -> Semaphore {\n-        Semaphore { sem: Sem((*self.sem).clone()) }\n+        let Sem(ref lock) = self.sem;\n+        Semaphore { sem: Sem(lock.clone()) }\n     }\n }\n \n@@ -378,7 +384,9 @@ impl Semaphore {\n pub struct Mutex { priv sem: Sem<~[WaitQueue]> }\n impl Clone for Mutex {\n     /// Create a new handle to the mutex.\n-    fn clone(&self) -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n+    fn clone(&self) -> Mutex {\n+        let Sem(ref queue) = self.sem;\n+        Mutex { sem: Sem(queue.clone()) } }\n }\n \n impl Mutex {\n@@ -467,8 +475,9 @@ impl RWLock {\n \n     /// Create a new handle to the rwlock.\n     pub fn clone(&self) -> RWLock {\n+        let Sem(ref access_lock_queue) = self.access_lock;\n         RWLock { order_lock:  (&(self.order_lock)).clone(),\n-                 access_lock: Sem((*self.access_lock).clone()),\n+                 access_lock: Sem(access_lock_queue.clone()),\n                  state:       self.state.clone() }\n     }\n "}, {"sha": "55d59954224c10f6fb80d8aa9bafb9c7a44a76bd", "filename": "src/libextra/test.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -137,7 +137,8 @@ pub struct MetricMap(TreeMap<~str,Metric>);\n \n impl Clone for MetricMap {\n     fn clone(&self) -> MetricMap {\n-        MetricMap((**self).clone())\n+        let MetricMap(ref map) = *self;\n+        MetricMap(map.clone())\n     }\n }\n \n@@ -584,6 +585,7 @@ impl<T: Writer> ConsoleTestState<T> {\n }\n \n pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n+    let MetricMap(ref mm) = *mm;\n     let v : ~[~str] = mm.iter()\n         .map(|(k,v)| format!(\"{}: {} (+/- {})\",\n                           *k,\n@@ -622,6 +624,7 @@ pub fn run_tests_console(opts: &TestOpts,\n                     TrIgnored => st.ignored += 1,\n                     TrMetrics(mm) => {\n                         let tname = test.name.to_str();\n+                        let MetricMap(mm) = mm;\n                         for (k,v) in mm.iter() {\n                             st.metrics.insert_metric(tname + \".\" + *k,\n                                                      v.value, v.noise);\n@@ -950,7 +953,8 @@ impl MetricMap {\n     /// Write MetricDiff to a file.\n     pub fn save(&self, p: &Path) {\n         let mut file = File::create(p);\n-        self.to_json().to_pretty_writer(&mut file)\n+        let MetricMap(ref map) = *self;\n+        map.to_json().to_pretty_writer(&mut file)\n     }\n \n     /// Compare against another MetricMap. Optionally compare all\n@@ -962,8 +966,10 @@ impl MetricMap {\n     pub fn compare_to_old(&self, old: &MetricMap,\n                           noise_pct: Option<f64>) -> MetricDiff {\n         let mut diff : MetricDiff = TreeMap::new();\n+        let MetricMap(ref selfmap) = *self;\n+        let MetricMap(ref old) = *old;\n         for (k, vold) in old.iter() {\n-            let r = match self.find(k) {\n+            let r = match selfmap.find(k) {\n                 None => MetricRemoved,\n                 Some(v) => {\n                     let delta = (v.value - vold.value);\n@@ -999,7 +1005,8 @@ impl MetricMap {\n             };\n             diff.insert((*k).clone(), r);\n         }\n-        for (k, _) in self.iter() {\n+        let MetricMap(ref map) = *self;\n+        for (k, _) in map.iter() {\n             if !diff.contains_key(k) {\n                 diff.insert((*k).clone(), MetricAdded);\n             }\n@@ -1025,7 +1032,8 @@ impl MetricMap {\n             value: value,\n             noise: noise\n         };\n-        self.insert(name.to_owned(), m);\n+        let MetricMap(ref mut map) = *self;\n+        map.insert(name.to_owned(), m);\n     }\n \n     /// Attempt to \"ratchet\" an external metric file. This involves loading\n@@ -1464,6 +1472,7 @@ mod tests {\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n+        let MetricMap(m3) = m3;\n         assert_eq!(m3.len(), 2);\n         assert_eq!(*(m3.find(&~\"runtime\").unwrap()), Metric { value: 1000.0, noise: 2.0 });\n         assert_eq!(*(m3.find(&~\"throughput\").unwrap()), Metric { value: 50.0, noise: 2.0 });\n@@ -1478,6 +1487,7 @@ mod tests {\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n+        let MetricMap(m4) = m4;\n         assert_eq!(m4.len(), 2);\n         assert_eq!(*(m4.find(&~\"runtime\").unwrap()), Metric { value: 1100.0, noise: 2.0 });\n         assert_eq!(*(m4.find(&~\"throughput\").unwrap()), Metric { value: 50.0, noise: 2.0 });"}, {"sha": "19c5f6f69d817db206644425267b3b362ff821ac", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -116,13 +116,14 @@ impl WorkMap {\n \n     fn insert_work_key(&mut self, k: WorkKey, val: ~str) {\n         let WorkKey { kind, name } = k;\n-        match self.find_mut(&name) {\n+        let WorkMap(ref mut map) = *self;\n+        match map.find_mut(&name) {\n             Some(&KindMap(ref mut m)) => { m.insert(kind, val); return; }\n             None => ()\n         }\n         let mut new_map = TreeMap::new();\n         new_map.insert(kind, val);\n-        self.insert(name, KindMap(new_map));\n+        map.insert(name, KindMap(new_map));\n     }\n }\n \n@@ -328,8 +329,10 @@ impl Exec {\n     // returns pairs of (kind, name)\n     pub fn lookup_discovered_inputs(&self) -> ~[(~str, ~str)] {\n         let mut rs = ~[];\n-        for (k, v) in self.discovered_inputs.iter() {\n-            for (k1, _) in v.iter() {\n+        let WorkMap(ref discovered_inputs) = self.discovered_inputs;\n+        for (k, v) in discovered_inputs.iter() {\n+            let KindMap(ref vmap) = *v;\n+            for (k1, _) in vmap.iter() {\n                 rs.push((k1.clone(), k.clone()));\n             }\n         }\n@@ -348,8 +351,10 @@ impl<'a> Prep<'a> {\n \n     pub fn lookup_declared_inputs(&self) -> ~[~str] {\n         let mut rs = ~[];\n-        for (_, v) in self.declared_inputs.iter() {\n-            for (inp, _) in v.iter() {\n+        let WorkMap(ref declared_inputs) = self.declared_inputs;\n+        for (_, v) in declared_inputs.iter() {\n+            let KindMap(ref vmap) = *v;\n+            for (inp, _) in vmap.iter() {\n                 rs.push(inp.clone());\n             }\n         }\n@@ -386,8 +391,10 @@ impl<'a> Prep<'a> {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n+        let WorkMap(ref map) = *map;\n         for (k_name, kindmap) in map.iter() {\n-            for (k_kind, v) in kindmap.iter() {\n+            let KindMap(ref kindmap_) = *kindmap;\n+            for (k_kind, v) in kindmap_.iter() {\n                if ! self.is_fresh(cat, *k_kind, *k_name, *v) {\n                   return false;\n             }"}, {"sha": "7e6dd02dd67e02807ae064887b205bbbe1ef53dc", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -61,11 +61,11 @@ pub struct StackPool(());\n impl StackPool {\n     pub fn new() -> StackPool { StackPool(()) }\n \n-    fn take_segment(&self, min_size: uint) -> StackSegment {\n+    pub fn take_segment(&self, min_size: uint) -> StackSegment {\n         StackSegment::new(min_size)\n     }\n \n-    fn give_segment(&self, _stack: StackSegment) {\n+    pub fn give_segment(&self, _stack: StackSegment) {\n     }\n }\n "}, {"sha": "a59b58e96c0256202832aec04e2be6e86559297c", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -72,9 +72,15 @@ pub struct FlowedMoveData {\n #[deriving(Eq)]\n pub struct MovePathIndex(uint);\n \n+impl MovePathIndex {\n+    fn get(&self) -> uint {\n+        let MovePathIndex(v) = *self; v\n+    }\n+}\n+\n impl Clone for MovePathIndex {\n     fn clone(&self) -> MovePathIndex {\n-        MovePathIndex(**self)\n+        MovePathIndex(self.get())\n     }\n }\n \n@@ -85,6 +91,12 @@ static InvalidMovePathIndex: MovePathIndex =\n #[deriving(Eq)]\n pub struct MoveIndex(uint);\n \n+impl MoveIndex {\n+    fn get(&self) -> uint {\n+        let MoveIndex(v) = *self; v\n+    }\n+}\n+\n static InvalidMoveIndex: MoveIndex =\n     MoveIndex(uint::max_value);\n \n@@ -177,47 +189,47 @@ impl MoveData {\n \n     fn path_loan_path(&self, index: MovePathIndex) -> @LoanPath {\n         let paths = self.paths.borrow();\n-        paths.get()[*index].loan_path\n+        paths.get()[index.get()].loan_path\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[*index].parent\n+        paths.get()[index.get()].parent\n     }\n \n     fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[*index].first_move\n+        paths.get()[index.get()].first_move\n     }\n \n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[*index].first_child\n+        paths.get()[index.get()].first_child\n     }\n \n     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[*index].next_sibling\n+        paths.get()[index.get()].next_sibling\n     }\n \n     fn set_path_first_move(&self,\n                            index: MovePathIndex,\n                            first_move: MoveIndex) {\n         let mut paths = self.paths.borrow_mut();\n-        paths.get()[*index].first_move = first_move\n+        paths.get()[index.get()].first_move = first_move\n     }\n \n     fn set_path_first_child(&self,\n                             index: MovePathIndex,\n                             first_child: MovePathIndex) {\n         let mut paths = self.paths.borrow_mut();\n-        paths.get()[*index].first_child = first_child\n+        paths.get()[index.get()].first_child = first_child\n     }\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n         let moves = self.moves.borrow();\n-        moves.get()[*index].next_move\n+        moves.get()[index.get()].next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n@@ -291,7 +303,7 @@ impl MoveData {\n                index);\n \n         let paths = self.paths.borrow();\n-        assert_eq!(*index, paths.get().len() - 1);\n+        assert_eq!(index.get(), paths.get().len() - 1);\n \n         let mut path_map = self.path_map.borrow_mut();\n         path_map.get().insert(lp, index);\n@@ -549,7 +561,7 @@ impl MoveData {\n                   kill_id: ast::NodeId,\n                   dfcx_moves: &mut MoveDataFlow) {\n         self.each_applicable_move(path, |move_index| {\n-            dfcx_moves.add_kill(kill_id, *move_index);\n+            dfcx_moves.add_kill(kill_id, move_index.get());\n             true\n         });\n     }"}, {"sha": "3b998f4379d33e89bc8464fdfb79d4b7070c4e41", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -67,6 +67,14 @@ pub struct Direction { priv repr: uint }\n pub static Outgoing: Direction = Direction { repr: 0 };\n pub static Incoming: Direction = Direction { repr: 1 };\n \n+impl NodeIndex {\n+    fn get(&self) -> uint { let NodeIndex(v) = *self; v }\n+}\n+\n+impl EdgeIndex {\n+    fn get(&self) -> uint { let EdgeIndex(v) = *self; v }\n+}\n+\n impl<N,E> Graph<N,E> {\n     pub fn new() -> Graph<N,E> {\n         Graph {nodes: ~[], edges: ~[]}\n@@ -110,15 +118,15 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n-        &mut self.nodes[*idx].data\n+        &mut self.nodes[idx.get()].data\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n-        &self.nodes[*idx].data\n+        &self.nodes[idx.get()].data\n     }\n \n     pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n-        &self.nodes[*idx]\n+        &self.nodes[idx.get()]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -135,8 +143,8 @@ impl<N,E> Graph<N,E> {\n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes[*source].first_edge[Outgoing.repr];\n-        let target_first = self.nodes[*target].first_edge[Incoming.repr];\n+        let source_first = self.nodes[source.get()].first_edge[Outgoing.repr];\n+        let target_first = self.nodes[target.get()].first_edge[Incoming.repr];\n \n         // create the new edge, with the previous firsts from each node\n         // as the next pointers\n@@ -148,38 +156,38 @@ impl<N,E> Graph<N,E> {\n         });\n \n         // adjust the firsts for each node target be the next object.\n-        self.nodes[*source].first_edge[Outgoing.repr] = idx;\n-        self.nodes[*target].first_edge[Incoming.repr] = idx;\n+        self.nodes[source.get()].first_edge[Outgoing.repr] = idx;\n+        self.nodes[target.get()].first_edge[Incoming.repr] = idx;\n \n         return idx;\n     }\n \n     pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n-        &mut self.edges[*idx].data\n+        &mut self.edges[idx.get()].data\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n-        &self.edges[*idx].data\n+        &self.edges[idx.get()].data\n     }\n \n     pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n-        &self.edges[*idx]\n+        &self.edges[idx.get()]\n     }\n \n     pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the index of the first edge adjacent to `node`.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.nodes[*node].first_edge[dir.repr]\n+        self.nodes[node.get()].first_edge[dir.repr]\n     }\n \n     pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the next edge in a given direction.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.edges[*edge].next_edge[dir.repr]\n+        self.edges[edge.get()].next_edge[dir.repr]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -223,7 +231,7 @@ impl<N,E> Graph<N,E> {\n \n         let mut edge_idx = self.first_adjacent(node, dir);\n         while edge_idx != InvalidEdgeIndex {\n-            let edge = &self.edges[*edge_idx];\n+            let edge = &self.edges[edge_idx.get()];\n             if !f(edge_idx, edge) {\n                 return false;\n             }\n@@ -260,7 +268,7 @@ impl<N,E> Graph<N,E> {\n \n pub fn each_edge_index(max_edge_index: EdgeIndex, f: |EdgeIndex| -> bool) {\n     let mut i = 0;\n-    let n = *max_edge_index;\n+    let n = max_edge_index.get();\n     while i < n {\n         if !f(EdgeIndex(i)) {\n             return;\n@@ -319,8 +327,8 @@ mod test {\n         let graph = create_graph();\n         let expected = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n         graph.each_node(|idx, node| {\n-            assert_eq!(&expected[*idx], graph.node_data(idx));\n-            assert_eq!(expected[*idx], node.data);\n+            assert_eq!(&expected[idx.get()], graph.node_data(idx));\n+            assert_eq!(expected[idx.get()], node.data);\n             true\n         });\n     }\n@@ -330,8 +338,8 @@ mod test {\n         let graph = create_graph();\n         let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n         graph.each_edge(|idx, edge| {\n-            assert_eq!(&expected[*idx], graph.edge_data(idx));\n-            assert_eq!(expected[*idx], edge.data);\n+            assert_eq!(&expected[idx.get()], graph.edge_data(idx));\n+            assert_eq!(expected[idx.get()], edge.data);\n             true\n         });\n     }"}, {"sha": "2cc61c51dcc218c21cbfecc09c0841c009efe91c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -129,9 +129,17 @@ struct Variable(uint);\n #[deriving(Eq)]\n struct LiveNode(uint);\n \n+impl Variable {\n+    fn get(&self) -> uint { let Variable(v) = *self; v }\n+}\n+\n+impl LiveNode {\n+    fn get(&self) -> uint { let LiveNode(v) = *self; v }\n+}\n+\n impl Clone for LiveNode {\n     fn clone(&self) -> LiveNode {\n-        LiveNode(**self)\n+        LiveNode(self.get())\n     }\n }\n \n@@ -176,11 +184,11 @@ pub fn check_crate(tcx: ty::ctxt,\n }\n \n impl to_str::ToStr for LiveNode {\n-    fn to_str(&self) -> ~str { format!(\"ln({})\", **self) }\n+    fn to_str(&self) -> ~str { format!(\"ln({})\", self.get()) }\n }\n \n impl to_str::ToStr for Variable {\n-    fn to_str(&self) -> ~str { format!(\"v({})\", **self) }\n+    fn to_str(&self) -> ~str { format!(\"v({})\", self.get()) }\n }\n \n // ______________________________________________________________________\n@@ -207,7 +215,7 @@ impl to_str::ToStr for Variable {\n \n impl LiveNode {\n     pub fn is_valid(&self) -> bool {\n-        **self != uint::max_value\n+        self.get() != uint::max_value\n     }\n }\n \n@@ -326,7 +334,7 @@ impl IrMaps {\n \n     pub fn variable_name(&self, var: Variable) -> @str {\n         let var_kinds = self.var_kinds.borrow();\n-        match var_kinds.get()[*var] {\n+        match var_kinds.get()[var.get()] {\n             Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n                 self.tcx.sess.str_of(nm)\n             },\n@@ -351,7 +359,7 @@ impl IrMaps {\n \n     pub fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n         let lnks = self.lnks.borrow();\n-        lnks.get()[*ln]\n+        lnks.get()[ln.get()]\n     }\n }\n \n@@ -680,7 +688,7 @@ impl Liveness {\n     }\n \n     pub fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n-        *ln * self.ir.num_vars.get() + *var\n+        ln.get() * self.ir.num_vars.get() + var.get()\n     }\n \n     pub fn live_on_entry(&self, ln: LiveNode, var: Variable)\n@@ -698,7 +706,7 @@ impl Liveness {\n                         -> Option<LiveNodeKind> {\n         let successor = {\n             let successors = self.successors.borrow();\n-            successors.get()[*ln]\n+            successors.get()[ln.get()]\n         };\n         self.live_on_entry(successor, var)\n     }\n@@ -721,7 +729,7 @@ impl Liveness {\n                             -> Option<LiveNodeKind> {\n         let successor = {\n             let successors = self.successors.borrow();\n-            successors.get()[*ln]\n+            successors.get()[ln.get()]\n         };\n         self.assigned_on_entry(successor, var)\n     }\n@@ -792,8 +800,8 @@ impl Liveness {\n                 let lnks = self.ir.lnks.try_borrow();\n                 write!(wr,\n                        \"[ln({}) of kind {:?} reads\",\n-                       *ln,\n-                       lnks.and_then(|lnks| Some(lnks.get()[*ln])));\n+                       ln.get(),\n+                       lnks.and_then(|lnks| Some(lnks.get()[ln.get()])));\n             }\n             let users = self.users.try_borrow();\n             match users {\n@@ -809,7 +817,7 @@ impl Liveness {\n             let successors = self.successors.try_borrow();\n             match successors {\n                 Some(successors) => {\n-                    write!(wr, \"  precedes {}]\", successors.get()[*ln].to_str());\n+                    write!(wr, \"  precedes {}]\", successors.get()[ln.get()].to_str());\n                 }\n                 None => {\n                     write!(wr, \"  precedes (successors borrowed)]\");\n@@ -821,7 +829,7 @@ impl Liveness {\n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n         {\n             let mut successors = self.successors.borrow_mut();\n-            successors.get()[*ln] = succ_ln;\n+            successors.get()[ln.get()] = succ_ln;\n         }\n \n         // It is not necessary to initialize the\n@@ -838,7 +846,7 @@ impl Liveness {\n         // more efficient version of init_empty() / merge_from_succ()\n         {\n             let mut successors = self.successors.borrow_mut();\n-            successors.get()[*ln] = succ_ln;\n+            successors.get()[ln.get()] = succ_ln;\n         }\n \n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n@@ -1441,7 +1449,7 @@ impl Liveness {\n                            cont_ln: LiveNode,\n                            f: || -> R)\n                            -> R {\n-        debug!(\"with_loop_nodes: {} {}\", loop_node_id, *break_ln);\n+        debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n         {\n             let mut loop_scope = self.loop_scope.borrow_mut();\n             loop_scope.get().push(loop_node_id);"}, {"sha": "1d677d790ebfd3933c909a976c9a36cc07696697", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -648,7 +648,7 @@ impl mem_categorization_ctxt {\n                                  base_cmt: cmt,\n                                  deref_cnt: uint)\n                                  -> cmt {\n-        let mt = match ty::deref(self.tcx, base_cmt.ty, true) {\n+        let mt = match ty::deref(base_cmt.ty, true) {\n             Some(mt) => mt,\n             None => {\n                 self.tcx.sess.span_bug("}, {"sha": "bc2be163bfae46dd1916a48f258cb2122c64e22f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -642,8 +642,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n \n                 // With type_autoderef, make sure we don't\n                 // allow pointers to violate privacy\n-                let t = ty::type_autoderef(self.tcx,\n-                                           ty::expr_ty(self.tcx, base));\n+                let t = ty::type_autoderef(ty::expr_ty(self.tcx, base));\n                 match ty::get(t).sty {\n                     ty::ty_struct(id, _) => {\n                         self.check_field(expr.span, id, ident);\n@@ -653,8 +652,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n             }\n             ast::ExprMethodCall(_, base, ident, _, _, _) => {\n                 // see above\n-                let t = ty::type_autoderef(self.tcx,\n-                                           ty::expr_ty(self.tcx, base));\n+                let t = ty::type_autoderef(ty::expr_ty(self.tcx, base));\n                 match ty::get(t).sty {\n                     ty::ty_enum(_, _) | ty::ty_struct(_, _) => {\n                         let method_map = self.method_map.borrow();"}, {"sha": "3dc7bf59453413d52a8ce125212f0472776cec86", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -169,6 +169,16 @@ enum ReducedGraphParent {\n     ModuleReducedGraphParent(@Module)\n }\n \n+impl ReducedGraphParent {\n+    fn module(&self) -> @Module {\n+        match *self {\n+            ModuleReducedGraphParent(m) => {\n+                m\n+            }\n+        }\n+    }\n+}\n+\n enum ResolveResult<T> {\n     Failed,         // Failed to resolve the name.\n     Indeterminate,  // Couldn't determine due to unresolved globs.\n@@ -1246,7 +1256,7 @@ impl Resolver {\n                         let name = path_to_ident(path);\n \n                         let existing_parent_opt = {\n-                            let children = parent.children.borrow();\n+                            let children = parent.module().children.borrow();\n                             children.get().find_copy(&name.name)\n                         };\n                         let new_parent = match existing_parent_opt {\n@@ -1523,7 +1533,7 @@ impl Resolver {\n \n                         {\n                             let mut external_module_children =\n-                                parent.external_module_children.borrow_mut();\n+                                parent.module().external_module_children.borrow_mut();\n                             external_module_children.get().insert(\n                                 name.name,\n                                 external_module);"}, {"sha": "f1897a08901f048b0429429c6e50cee3a437dfeb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -1884,7 +1884,7 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: @Block) {\n         // If there's only a single store to the ret slot, we can directly return\n         // the value that was stored and omit the store and the alloca\n         Some(s) => {\n-            let retval = *s.get_operand(0).unwrap();\n+            let retval = s.get_operand(0).unwrap().get();\n             s.erase_from_parent();\n \n             if retptr.has_no_uses() {"}, {"sha": "f3d9cf6933a2594a43abd3b8f37cf7b0425c17c0", "filename": "src/librustc/middle/trans/basic_block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -20,9 +20,13 @@ pub type PredIterator<'a> = Map<'a, Value, BasicBlock, Filter<'a, Value, UserIte\n  * Wrapper for LLVM BasicBlockRef\n  */\n impl BasicBlock {\n+    pub fn get(&self) -> BasicBlockRef {\n+        let BasicBlock(v) = *self; v\n+    }\n+\n     pub fn as_value(self) -> Value {\n         unsafe {\n-            Value(llvm::LLVMBasicBlockAsValue(*self))\n+            Value(llvm::LLVMBasicBlockAsValue(self.get()))\n         }\n     }\n "}, {"sha": "0df11b24a988dde36945ff1e1233ff4af8c97466", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -131,7 +131,7 @@ fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: ty::t)\n \n fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n-    match ty::deref(cx.tcx, t, explicit) {\n+    match ty::deref(t, explicit) {\n         Some(ref mt) => {\n             assert!(mt.mutbl != ast::MutMutable);\n             let dv = match ty::get(t).sty {"}, {"sha": "5fb2f5d41dc8e8555e6371aff991c096ae51bb5f", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -90,7 +90,6 @@\n \n use lib;\n use lib::llvm::ValueRef;\n-use middle::trans::adt;\n use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -107,7 +106,6 @@ use util::ppaux::ty_to_str;\n use std::uint;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::parse::token::special_idents;\n \n #[deriving(Eq)]\n pub enum CopyAction {\n@@ -605,8 +603,6 @@ impl Datum {\n                      derefs: uint,\n                      is_auto: bool)\n                      -> (Option<Datum>, @Block) {\n-        let ccx = bcx.ccx();\n-\n         debug!(\"try_deref(expr_id={:?}, derefs={:?}, is_auto={}, self={:?})\",\n                expr_id, derefs, is_auto, self.to_str(bcx.ccx()));\n \n@@ -628,45 +624,6 @@ impl Datum {\n             ty::ty_rptr(_, mt) => {\n                 return (Some(deref_ptr(bcx, self, mt.ty)), bcx);\n             }\n-            ty::ty_struct(did, ref substs) => {\n-                // Check whether this struct is a newtype struct.\n-                let fields = ty::struct_fields(ccx.tcx, did, substs);\n-                if fields.len() != 1 || fields[0].ident !=\n-                    special_idents::unnamed_field {\n-                    return (None, bcx);\n-                }\n-\n-                let repr = adt::represent_type(ccx, self.ty);\n-                let ty = fields[0].mt.ty;\n-                return match self.mode {\n-                    ByRef(_) => {\n-                        // Recast lv.val as a pointer to the newtype rather\n-                        // than a pointer to the struct type.\n-                        // FIXME #6572: This isn't correct for structs with\n-                        // destructors.\n-                        (\n-                            Some(Datum {\n-                                val: adt::trans_field_ptr(bcx, repr, self.val,\n-                                                    0, 0),\n-                                ty: ty,\n-                                mode: ByRef(ZeroMem)\n-                            }),\n-                            bcx\n-                        )\n-                    }\n-                    ByValue => {\n-                        assert!(type_is_immediate(bcx.ccx(), ty));\n-                        (\n-                            Some(Datum {\n-                                val: ExtractValue(bcx, self.val, 0),\n-                                ty: ty,\n-                                mode: ByValue\n-                            }),\n-                            bcx\n-                        )\n-                    }\n-                }\n-            }\n             _ => { // not derefable.\n                 return (None, bcx);\n             }"}, {"sha": "098b3c1ae73d839f1361e99723ecf3f8169e6693", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -564,7 +564,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n         let loc = span_start(cx, span);\n         let scope = scope_metadata(fcx, node_id, span);\n \n-        set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n+        set_debug_location(cx, DebugLocation::new(scope, loc.line, loc.col.to_uint()));\n     } else {\n         set_debug_location(cx, UnknownLocation);\n     }\n@@ -1032,7 +1032,7 @@ fn declare_local(bcx: @Block,\n         }\n     });\n \n-    set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, *loc.col));\n+    set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, loc.col.to_uint()));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),"}, {"sha": "35fb365ab9964b6d6e5c7ae30934e67eb4264804", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -28,10 +28,15 @@ macro_rules! opt_val ( ($e:expr) => (\n  * Wrapper for LLVM ValueRef\n  */\n impl Value {\n+    /// Returns the native ValueRef\n+    pub fn get(&self) -> ValueRef {\n+        let Value(v) = *self; v\n+    }\n+\n     /// Returns the BasicBlock that contains this value\n     pub fn get_parent(self) -> Option<BasicBlock> {\n         unsafe {\n-            match llvm::LLVMGetInstructionParent(*self) {\n+            match llvm::LLVMGetInstructionParent(self.get()) {\n                 p if p.is_not_null() => Some(BasicBlock(p)),\n                 _ => None\n             }\n@@ -41,7 +46,7 @@ impl Value {\n     /// Removes this value from its containing BasicBlock\n     pub fn erase_from_parent(self) {\n         unsafe {\n-            llvm::LLVMInstructionEraseFromParent(*self);\n+            llvm::LLVMInstructionEraseFromParent(self.get());\n         }\n     }\n \n@@ -55,7 +60,7 @@ impl Value {\n                 store.get_parent().and_then(|store_bb| {\n                     let mut bb = BasicBlock(bcx.llbb);\n                     let mut ret = Some(store);\n-                    while *bb != *store_bb {\n+                    while bb.get() != store_bb.get() {\n                         match bb.get_single_predecessor() {\n                             Some(pred) => bb = pred,\n                             None => { ret = None; break }\n@@ -71,7 +76,7 @@ impl Value {\n     /// Returns the first use of this value, if any\n     pub fn get_first_use(self) -> Option<Use> {\n         unsafe {\n-            match llvm::LLVMGetFirstUse(*self) {\n+            match llvm::LLVMGetFirstUse(self.get()) {\n                 u if u.is_not_null() => Some(Use(u)),\n                 _ => None\n             }\n@@ -103,18 +108,18 @@ impl Value {\n     /// Returns the requested operand of this instruction\n     /// Returns None, if there's no operand at the given index\n     pub fn get_operand(self, i: uint) -> Option<Value> {\n-        opt_val!(llvm::LLVMGetOperand(*self, i as c_uint))\n+        opt_val!(llvm::LLVMGetOperand(self.get(), i as c_uint))\n     }\n \n     /// Returns the Store represent by this value, if any\n     pub fn as_store_inst(self) -> Option<Value> {\n-        opt_val!(llvm::LLVMIsAStoreInst(*self))\n+        opt_val!(llvm::LLVMIsAStoreInst(self.get()))\n     }\n \n     /// Tests if this value is a terminator instruction\n     pub fn is_a_terminator_inst(self) -> bool {\n         unsafe {\n-            llvm::LLVMIsATerminatorInst(*self).is_not_null()\n+            llvm::LLVMIsATerminatorInst(self.get()).is_not_null()\n         }\n     }\n }\n@@ -125,15 +130,19 @@ pub struct Use(UseRef);\n  * Wrapper for LLVM UseRef\n  */\n impl Use {\n+    pub fn get(&self) -> UseRef {\n+        let Use(v) = *self; v\n+    }\n+\n     pub fn get_user(self) -> Value {\n         unsafe {\n-            Value(llvm::LLVMGetUser(*self))\n+            Value(llvm::LLVMGetUser(self.get()))\n         }\n     }\n \n     pub fn get_next_use(self) -> Option<Use> {\n         unsafe {\n-            match llvm::LLVMGetNextUse(*self) {\n+            match llvm::LLVMGetNextUse(self.get()) {\n                 u if u.is_not_null() => Some(Use(u)),\n                 _ => None\n             }"}, {"sha": "c8299b292897eea00e763e3ffd47485ada6aa659", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -815,23 +815,23 @@ pub trait Vid {\n }\n \n impl Vid for TyVid {\n-    fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { let TyVid(v) = *self; v }\n }\n \n impl ToStr for TyVid {\n     fn to_str(&self) -> ~str { format!(\"<V{}>\", self.to_uint()) }\n }\n \n impl Vid for IntVid {\n-    fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { let IntVid(v) = *self; v }\n }\n \n impl ToStr for IntVid {\n     fn to_str(&self) -> ~str { format!(\"<VI{}>\", self.to_uint()) }\n }\n \n impl Vid for FloatVid {\n-    fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { let FloatVid(v) = *self; v }\n }\n \n impl ToStr for FloatVid {\n@@ -2610,11 +2610,11 @@ pub fn type_param(ty: t) -> Option<uint> {\n //\n // The parameter `explicit` indicates if this is an *explicit* dereference.\n // Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n-pub fn deref(cx: ctxt, t: t, explicit: bool) -> Option<mt> {\n-    deref_sty(cx, &get(t).sty, explicit)\n+pub fn deref(t: t, explicit: bool) -> Option<mt> {\n+    deref_sty(&get(t).sty, explicit)\n }\n \n-pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n+pub fn deref_sty(sty: &sty, explicit: bool) -> Option<mt> {\n     match *sty {\n       ty_box(typ) => {\n         Some(mt {\n@@ -2631,24 +2631,14 @@ pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         Some(mt)\n       }\n \n-      ty_struct(did, ref substs) => {\n-        let fields = struct_fields(cx, did, substs);\n-        if fields.len() == 1 && fields[0].ident ==\n-                syntax::parse::token::special_idents::unnamed_field {\n-            Some(mt {ty: fields[0].mt.ty, mutbl: ast::MutImmutable})\n-        } else {\n-            None\n-        }\n-      }\n-\n       _ => None\n     }\n }\n \n-pub fn type_autoderef(cx: ctxt, t: t) -> t {\n+pub fn type_autoderef(t: t) -> t {\n     let mut t = t;\n     loop {\n-        match deref(cx, t, false) {\n+        match deref(t, false) {\n           None => return t,\n           Some(mt) => t = mt.ty\n         }\n@@ -2917,7 +2907,7 @@ pub fn adjust_ty(cx: ctxt,\n \n             if (!ty::type_is_error(adjusted_ty)) {\n                 for i in range(0, adj.autoderefs) {\n-                    match ty::deref(cx, adjusted_ty, true) {\n+                    match ty::deref(adjusted_ty, true) {\n                         Some(mt) => { adjusted_ty = mt.ty; }\n                         None => {\n                             cx.sess.span_bug(\n@@ -4310,7 +4300,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n     struct TypeNormalizer(ctxt);\n \n     impl TypeFolder for TypeNormalizer {\n-        fn tcx(&self) -> ty::ctxt { **self }\n+        fn tcx(&self) -> ty::ctxt { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             let normalized_opt = {"}, {"sha": "90edeea9d84cde7f86eafd1ccb1006ac652eb53d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -265,7 +265,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn deref(&self, ty: ty::t) -> Option<ty::t> {\n-        match ty::deref(self.tcx(), ty, false) {\n+        match ty::deref(ty, false) {\n             None => None,\n             Some(t) => {\n                 Some(structurally_resolved_type(self.fcx,"}, {"sha": "3cac4471305c654a3697c92f5000b72029d94988", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -1365,7 +1365,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n         }\n \n         // Otherwise, deref if type is derefable:\n-        match ty::deref_sty(fcx.ccx.tcx, sty, false) {\n+        match ty::deref_sty(sty, false) {\n             None => {\n                 return (t1, autoderefs);\n             }\n@@ -2758,18 +2758,13 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 }\n                 ast::UnDeref => {\n                     let sty = structure_of(fcx, expr.span, oprnd_t);\n-                    let operand_ty = ty::deref_sty(tcx, sty, true);\n+                    let operand_ty = ty::deref_sty(sty, true);\n                     match operand_ty {\n                         Some(mt) => {\n                             oprnd_t = mt.ty\n                         }\n                         None => {\n                             match *sty {\n-                                ty::ty_struct(..) => {\n-                                    tcx.sess.span_err(\n-                                        expr.span,\n-                                        \"can only dereference structs with one anonymous field\");\n-                                }\n                                 _ => {\n                                     fcx.type_error_message(expr.span,\n                                         |actual| {"}, {"sha": "aed9a406404fcc4f0a1d763d7715b865544ab372", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -628,7 +628,6 @@ fn constrain_derefs(rcx: &mut Rcx,\n      * pointer being derefenced, the lifetime of the pointer includes\n      * the deref expr.\n      */\n-    let tcx = rcx.fcx.tcx();\n     let r_deref_expr = ty::ReScope(deref_expr.id);\n     for i in range(0u, derefs) {\n         debug!(\"constrain_derefs(deref_expr=?, derefd_ty={}, derefs={:?}/{:?}\",\n@@ -644,7 +643,7 @@ fn constrain_derefs(rcx: &mut Rcx,\n             _ => {}\n         }\n \n-        match ty::deref(tcx, derefd_ty, true) {\n+        match ty::deref(derefd_ty, true) {\n             Some(mt) => derefd_ty = mt.ty,\n             /* if this type can't be dereferenced, then there's already an error\n                in the session saying so. Just bail out for now */\n@@ -1193,7 +1192,7 @@ pub mod guarantor {\n         for _ in range(0u, autoderefs) {\n             ct.cat.guarantor = guarantor_of_deref(&ct.cat);\n \n-            match ty::deref(tcx, ct.ty, true) {\n+            match ty::deref(ct.ty, true) {\n                 Some(mt) => {\n                     ct.ty = mt.ty;\n                     ct.cat.pointer = pointer_categorize(ct.ty);"}, {"sha": "a2f94a174cf2318af57ea4b155a70794a73d99c0", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -86,10 +86,14 @@ use syntax::ast;\n pub struct Coerce(CombineFields);\n \n impl Coerce {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields {\n+        let Coerce(ref v) = *self; v\n+    }\n+\n     pub fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {\n         debug!(\"Coerce.tys({} => {})\",\n-               a.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx),\n+               b.inf_str(self.get_ref().infcx));\n         let _indent = indenter();\n \n         // Examine the supertype and consider auto-borrowing.\n@@ -200,21 +204,21 @@ impl Coerce {\n     }\n \n     pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n-        match Sub(**self).tys(a, b) {\n+        match Sub(*self.get_ref()).tys(a, b) {\n             Ok(_) => Ok(None),         // No coercion required.\n             Err(ref e) => Err(*e)\n         }\n     }\n \n     pub fn unpack_actual_value(&self, a: ty::t, f: |&ty::sty| -> CoerceResult)\n                                -> CoerceResult {\n-        match resolve_type(self.infcx, a, try_resolve_tvar_shallow) {\n+        match resolve_type(self.get_ref().infcx, a, try_resolve_tvar_shallow) {\n             Ok(t) => {\n                 f(&ty::get(t).sty)\n             }\n             Err(e) => {\n-                self.infcx.tcx.sess.span_bug(\n-                    self.trace.origin.span(),\n+                self.get_ref().infcx.tcx.sess.span_bug(\n+                    self.get_ref().trace.origin.span(),\n                     format!(\"Failed to resolve even without \\\n                           any force options: {:?}\", e));\n             }\n@@ -228,17 +232,17 @@ impl Coerce {\n                                    mt_b: ty::mt)\n                                    -> CoerceResult {\n         debug!(\"coerce_borrowed_pointer(a={}, sty_a={:?}, b={}, mt_b={:?})\",\n-               a.inf_str(self.infcx), sty_a,\n-               b.inf_str(self.infcx), mt_b);\n+               a.inf_str(self.get_ref().infcx), sty_a,\n+               b.inf_str(self.get_ref().infcx), mt_b);\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n         // meaning that we convert `f(expr)` to `f(&M *expr)`.  Therefore,\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let sub = Sub(**self);\n-        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n+        let sub = Sub(*self.get_ref());\n+        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n \n         let inner_ty = match *sty_a {\n             ty::ty_box(typ) => typ,\n@@ -249,7 +253,7 @@ impl Coerce {\n             }\n         };\n \n-        let a_borrowed = ty::mk_rptr(self.infcx.tcx,\n+        let a_borrowed = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                      r_borrow,\n                                      mt {ty: inner_ty, mutbl: mt_b.mutbl});\n         if_ok!(sub.tys(a_borrowed, b));\n@@ -265,8 +269,8 @@ impl Coerce {\n                                   b: ty::t)\n                                   -> CoerceResult {\n         debug!(\"coerce_borrowed_string(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.infcx), sty_a,\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), sty_a,\n+               b.inf_str(self.get_ref().infcx));\n \n         match *sty_a {\n             ty::ty_estr(vstore_box) |\n@@ -276,8 +280,8 @@ impl Coerce {\n             }\n         };\n \n-        let r_a = self.infcx.next_region_var(Coercion(self.trace));\n-        let a_borrowed = ty::mk_estr(self.infcx.tcx, vstore_slice(r_a));\n+        let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let a_borrowed = ty::mk_estr(self.get_ref().infcx.tcx, vstore_slice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n@@ -292,19 +296,19 @@ impl Coerce {\n                                   mt_b: ty::mt)\n                                   -> CoerceResult {\n         debug!(\"coerce_borrowed_vector(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.infcx), sty_a,\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), sty_a,\n+               b.inf_str(self.get_ref().infcx));\n \n-        let sub = Sub(**self);\n-        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n+        let sub = Sub(*self.get_ref());\n+        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n         let ty_inner = match *sty_a {\n             ty::ty_evec(mt, _) => mt.ty,\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-        let a_borrowed = ty::mk_evec(self.infcx.tcx,\n+        let a_borrowed = ty::mk_evec(self.get_ref().infcx.tcx,\n                                      mt {ty: ty_inner, mutbl: mt_b.mutbl},\n                                      vstore_slice(r_borrow));\n         if_ok!(sub.tys(a_borrowed, b));\n@@ -321,11 +325,11 @@ impl Coerce {\n                               b_mutbl: ast::Mutability) -> CoerceResult\n     {\n         debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.infcx), sty_a,\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), sty_a,\n+               b.inf_str(self.get_ref().infcx));\n \n-        let tcx = self.infcx.tcx;\n-        let r_a = self.infcx.next_region_var(Coercion(self.trace));\n+        let tcx = self.get_ref().infcx.tcx;\n+        let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n \n         let a_borrowed = match *sty_a {\n             ty::ty_trait(did, ref substs, _, _, b) => {\n@@ -350,8 +354,8 @@ impl Coerce {\n                               b: ty::t)\n                               -> CoerceResult {\n         debug!(\"coerce_borrowed_fn(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.infcx), sty_a,\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), sty_a,\n+               b.inf_str(self.get_ref().infcx));\n \n         let fn_ty = match *sty_a {\n             ty::ty_closure(ref f) if f.sigil == ast::ManagedSigil ||\n@@ -366,9 +370,9 @@ impl Coerce {\n             }\n         };\n \n-        let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n+        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n         let a_borrowed = ty::mk_closure(\n-            self.infcx.tcx,\n+            self.get_ref().infcx.tcx,\n             ty::ClosureTy {\n                 sigil: ast::BorrowedSigil,\n                 region: r_borrow,\n@@ -405,7 +409,7 @@ impl Coerce {\n          */\n \n         debug!(\"coerce_from_bare_fn(a={}, b={})\",\n-               a.inf_str(self.infcx), b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n \n         if !fn_ty_a.abis.is_rust() {\n             return self.subtype(a, b);\n@@ -417,7 +421,7 @@ impl Coerce {\n         };\n \n         let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n-        let a_closure = ty::mk_closure(self.infcx.tcx,\n+        let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n                                        ty::ClosureTy {\n                                             sig: fn_ty_a.sig.clone(),\n                                             ..fn_ty_b\n@@ -433,8 +437,8 @@ impl Coerce {\n                              mt_b: ty::mt)\n                              -> CoerceResult {\n         debug!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.infcx), sty_a,\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), sty_a,\n+               b.inf_str(self.get_ref().infcx));\n \n         let mt_a = match *sty_a {\n             ty::ty_rptr(_, mt) => mt,\n@@ -444,7 +448,7 @@ impl Coerce {\n         };\n \n         // check that the types which they point at are compatible\n-        let a_unsafe = ty::mk_ptr(self.infcx.tcx, mt_a);\n+        let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, mt_a);\n         if_ok!(self.subtype(a_unsafe, b));\n \n         // although borrowed ptrs and unsafe ptrs have the same\n@@ -467,8 +471,8 @@ impl Coerce {\n                          bounds: ty::BuiltinBounds) -> CoerceResult {\n \n         debug!(\"coerce_object(a={}, sty_a={:?}, b={})\",\n-               a.inf_str(self.infcx), sty_a,\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), sty_a,\n+               b.inf_str(self.get_ref().infcx));\n \n         let (sigil, region) = match trait_store {\n             ty::BoxTraitStore => (ast::ManagedSigil, None),"}, {"sha": "7222e28b6e1e5042718f14f867e2ba15d01c9880", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -29,18 +29,22 @@ use util::ppaux::mt_to_str;\n \n pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n \n+impl Glb {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields { let Glb(ref v) = *self; v }\n+}\n+\n impl Combine for Glb {\n-    fn infcx(&self) -> @InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n-    fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.trace }\n+    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n \n-    fn sub(&self) -> Sub { Sub(**self) }\n-    fn lub(&self) -> Lub { Lub(**self) }\n-    fn glb(&self) -> Glb { Glb(**self) }\n+    fn sub(&self) -> Sub { Sub(*self.get_ref()) }\n+    fn lub(&self) -> Lub { Lub(*self.get_ref()) }\n+    fn glb(&self) -> Glb { Glb(*self.get_ref()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.infcx.tcx;\n+        let tcx = self.get_ref().infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n@@ -73,7 +77,7 @@ impl Combine for Glb {\n     }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Lub(**self).tys(a, b)\n+        Lub(*self.get_ref()).tys(a, b)\n     }\n \n     fn purities(&self, a: purity, b: purity) -> cres<purity> {\n@@ -100,15 +104,15 @@ impl Combine for Glb {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx),\n+               b.inf_str(self.get_ref().infcx));\n \n-        Ok(self.infcx.region_vars.glb_regions(Subtype(self.trace), a, b))\n+        Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.get_ref().trace), a, b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n-        Lub(**self).regions(a, b)\n+        Lub(*self.get_ref()).regions(a, b)\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n@@ -120,41 +124,41 @@ impl Combine for Glb {\n         // please see the large comment in `region_inference.rs`.\n \n         debug!(\"{}.fn_sigs({:?}, {:?})\",\n-               self.tag(), a.inf_str(self.infcx), b.inf_str(self.infcx));\n+               self.tag(), a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n         let _indenter = indenter();\n \n         // Take a snapshot.  We'll never roll this back, but in later\n         // phases we do want to be able to examine \"all bindings that\n         // were created as part of this type comparison\", and making a\n         // snapshot is a convenient way to do that.\n-        let snapshot = self.infcx.region_vars.start_snapshot();\n+        let snapshot = self.get_ref().infcx.region_vars.start_snapshot();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.trace, a);\n+            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+                self.get_ref().trace, a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n-            self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.trace, b);\n+            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+                self.get_ref().trace, b);\n         let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n+        debug!(\"sig0 = {}\", sig0.inf_str(self.get_ref().infcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n-            self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n+            self.get_ref().infcx.region_vars.vars_created_since_snapshot(snapshot);\n         let sig1 =\n             fold_regions_in_sig(\n-                self.infcx.tcx,\n+                self.get_ref().infcx.tcx,\n                 &sig0,\n                 |r| generalize_region(self, snapshot,\n                                       new_vars, sig0.binder_id,\n                                       &a_map, a_vars, b_vars,\n                                       r));\n-        debug!(\"sig1 = {}\", sig1.inf_str(self.infcx));\n+        debug!(\"sig1 = {}\", sig1.inf_str(self.get_ref().infcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n@@ -170,7 +174,7 @@ impl Combine for Glb {\n                 return r0;\n             }\n \n-            let tainted = this.infcx.region_vars.tainted(snapshot, r0);\n+            let tainted = this.get_ref().infcx.region_vars.tainted(snapshot, r0);\n \n             let mut a_r = None;\n             let mut b_r = None;\n@@ -237,13 +241,13 @@ impl Combine for Glb {\n                     return ty::ReLateBound(new_binder_id, *a_br);\n                 }\n             }\n-            this.infcx.tcx.sess.span_bug(\n-                this.trace.origin.span(),\n+            this.get_ref().infcx.tcx.sess.span_bug(\n+                this.get_ref().trace.origin.span(),\n                 format!(\"could not find original bound region for {:?}\", r))\n         }\n \n         fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {\n-            this.infcx.region_vars.new_bound(binder_id)\n+            this.get_ref().infcx.region_vars.new_bound(binder_id)\n         }\n     }\n }"}, {"sha": "b448c33b8d02d0855c8d78c64b7f59c184edda56", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -335,7 +335,7 @@ pub trait TyLatticeDir {\n }\n \n impl LatticeDir for Lub {\n-    fn combine_fields(&self) -> CombineFields { **self }\n+    fn combine_fields(&self) -> CombineFields { *self.get_ref() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..(*b).clone() }\n@@ -349,7 +349,7 @@ impl TyLatticeDir for Lub {\n }\n \n impl LatticeDir for Glb {\n-    fn combine_fields(&self) -> CombineFields { **self }\n+    fn combine_fields(&self) -> CombineFields { *self.get_ref() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..(*b).clone() }"}, {"sha": "439de728b7c35af847d90823d4f6688502473276", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -29,24 +29,25 @@ use util::ppaux::mt_to_str;\n pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n \n impl Lub {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields { let Lub(ref v) = *self; v }\n     pub fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }\n     pub fn ty_bot(&self, b: ty::t) -> cres<ty::t> {\n         self.bot_ty(b) // commutative\n     }\n }\n \n impl Combine for Lub {\n-    fn infcx(&self) -> @InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n-    fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.trace }\n+    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n \n-    fn sub(&self) -> Sub { Sub(**self) }\n-    fn lub(&self) -> Lub { Lub(**self) }\n-    fn glb(&self) -> Glb { Glb(**self) }\n+    fn sub(&self) -> Sub { Sub(*self.get_ref()) }\n+    fn lub(&self) -> Lub { Lub(*self.get_ref()) }\n+    fn glb(&self) -> Glb { Glb(*self.get_ref()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.infcx.tcx;\n+        let tcx = self.get_ref().infcx.tcx;\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n@@ -64,7 +65,7 @@ impl Combine for Lub {\n           }\n \n           MutMutable => {\n-            self.infcx.try(|| {\n+            self.get_ref().infcx.try(|| {\n                 eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n@@ -74,7 +75,7 @@ impl Combine for Lub {\n     }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Glb(**self).tys(a, b)\n+        Glb(*self.get_ref()).tys(a, b)\n     }\n \n     fn purities(&self, a: purity, b: purity) -> cres<purity> {\n@@ -100,16 +101,16 @@ impl Combine for Lub {\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n-        return Glb(**self).regions(a, b);\n+        return Glb(*self.get_ref()).regions(a, b);\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n-               a.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx),\n+               b.inf_str(self.get_ref().infcx));\n \n-        Ok(self.infcx.region_vars.lub_regions(Subtype(self.trace), a, b))\n+        Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.get_ref().trace), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -120,26 +121,26 @@ impl Combine for Lub {\n         // phases we do want to be able to examine \"all bindings that\n         // were created as part of this type comparison\", and making a\n         // snapshot is a convenient way to do that.\n-        let snapshot = self.infcx.region_vars.start_snapshot();\n+        let snapshot = self.get_ref().infcx.region_vars.start_snapshot();\n \n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n-            self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.trace, a);\n+            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+                self.get_ref().trace, a);\n         let (b_with_fresh, _) =\n-            self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.trace, b);\n+            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+                self.get_ref().trace, b);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.inf_str(self.infcx));\n+        debug!(\"sig0 = {}\", sig0.inf_str(self.get_ref().infcx));\n \n         // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n-            self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n+            self.get_ref().infcx.region_vars.vars_created_since_snapshot(snapshot);\n         let sig1 =\n             fold_regions_in_sig(\n-                self.infcx.tcx,\n+                self.get_ref().infcx.tcx,\n                 &sig0,\n                 |r| generalize_region(self, snapshot, new_vars,\n                                       sig0.binder_id, &a_map, r));\n@@ -159,7 +160,7 @@ impl Combine for Lub {\n                 return r0;\n             }\n \n-            let tainted = this.infcx.region_vars.tainted(snapshot, r0);\n+            let tainted = this.get_ref().infcx.region_vars.tainted(snapshot, r0);\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -186,8 +187,8 @@ impl Combine for Lub {\n                 }\n             }\n \n-            this.infcx.tcx.sess.span_bug(\n-                this.trace.origin.span(),\n+            this.get_ref().infcx.tcx.sess.span_bug(\n+                this.get_ref().trace.origin.span(),\n                 format!(\"Region {:?} is not associated with \\\n                         any bound region from A!\", r0))\n         }"}, {"sha": "e82ae114b9cb1102d2d931b58957787db4fb050f", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 32, "deletions": 28, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -28,42 +28,46 @@ use syntax::ast::{Onceness, purity};\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n+impl Sub {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields { let Sub(ref v) = *self; v }\n+}\n+\n impl Combine for Sub {\n-    fn infcx(&self) -> @InferCtxt { self.infcx }\n+    fn infcx(&self) -> @InferCtxt { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n-    fn a_is_expected(&self) -> bool { self.a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.trace }\n+    fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n \n-    fn sub(&self) -> Sub { Sub(**self) }\n-    fn lub(&self) -> Lub { Lub(**self) }\n-    fn glb(&self) -> Glb { Glb(**self) }\n+    fn sub(&self) -> Sub { Sub(*self.get_ref()) }\n+    fn lub(&self) -> Lub { Lub(*self.get_ref()) }\n+    fn glb(&self) -> Glb { Glb(*self.get_ref()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         let opp = CombineFields {\n-            a_is_expected: !self.a_is_expected,.. **self\n+            a_is_expected: !self.get_ref().a_is_expected,.. *self.get_ref()\n         };\n         Sub(opp).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n         let opp = CombineFields {\n-            a_is_expected: !self.a_is_expected,.. **self\n+            a_is_expected: !self.get_ref().a_is_expected,.. *self.get_ref()\n         };\n         Sub(opp).regions(b, a)\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.inf_str(self.infcx),\n-               b.inf_str(self.infcx));\n-        self.infcx.region_vars.make_subregion(Subtype(self.trace), a, b);\n+               a.inf_str(self.get_ref().infcx),\n+               b.inf_str(self.get_ref().infcx));\n+        self.get_ref().infcx.region_vars.make_subregion(Subtype(self.get_ref().trace), a, b);\n         Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        debug!(\"mts({} <: {})\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n+        debug!(\"mts({} <: {})\", a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -109,7 +113,7 @@ impl Combine for Sub {\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.inf_str(self.infcx), b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n         if a == b { return Ok(a); }\n         let _indenter = indenter();\n         match (&ty::get(a).sty, &ty::get(b).sty) {\n@@ -118,15 +122,15 @@ impl Combine for Sub {\n             }\n \n             (&ty::ty_infer(TyVar(a_id)), &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.var_sub_var(a_id, b_id));\n+                if_ok!(self.get_ref().var_sub_var(a_id, b_id));\n                 Ok(a)\n             }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n-                if_ok!(self.var_sub_t(a_id, b));\n+                if_ok!(self.get_ref().var_sub_t(a_id, b));\n                 Ok(a)\n             }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n-                if_ok!(self.t_sub_var(a, b_id));\n+                if_ok!(self.get_ref().t_sub_var(a, b_id));\n                 Ok(a)\n             }\n \n@@ -142,7 +146,7 @@ impl Combine for Sub {\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         debug!(\"fn_sigs(a={}, b={})\",\n-               a.inf_str(self.infcx), b.inf_str(self.infcx));\n+               a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n         let _indenter = indenter();\n \n         // Rather than checking the subtype relationship between `a` and `b`\n@@ -156,38 +160,38 @@ impl Combine for Sub {\n         // phases we do want to be able to examine \"all bindings that\n         // were created as part of this type comparison\", and making a\n         // snapshot is a convenient way to do that.\n-        let snapshot = self.infcx.region_vars.start_snapshot();\n+        let snapshot = self.get_ref().infcx.region_vars.start_snapshot();\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n         let (a_sig, _) =\n-            self.infcx.replace_bound_regions_with_fresh_regions(\n-                self.trace, a);\n+            self.get_ref().infcx.replace_bound_regions_with_fresh_regions(\n+                self.get_ref().trace, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n         let (skol_map, _, b_sig) = {\n-            replace_bound_regions_in_fn_sig(self.infcx.tcx, None, b, |br| {\n-                let skol = self.infcx.region_vars.new_skolemized(br);\n+            replace_bound_regions_in_fn_sig(self.get_ref().infcx.tcx, None, b, |br| {\n+                let skol = self.get_ref().infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n-                       bound_region_to_str(self.infcx.tcx, \"\", false, br),\n+                       bound_region_to_str(self.get_ref().infcx.tcx, \"\", false, br),\n                        skol);\n                 skol\n             })\n         };\n \n-        debug!(\"a_sig={}\", a_sig.inf_str(self.infcx));\n-        debug!(\"b_sig={}\", b_sig.inf_str(self.infcx));\n+        debug!(\"a_sig={}\", a_sig.inf_str(self.get_ref().infcx));\n+        debug!(\"b_sig={}\", b_sig.inf_str(self.get_ref().infcx));\n \n         // Compare types now that bound regions have been replaced.\n         let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));\n \n         // Presuming type comparison succeeds, we need to check\n         // that the skolemized regions do not \"leak\".\n         let new_vars =\n-            self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n+            self.get_ref().infcx.region_vars.vars_created_since_snapshot(snapshot);\n         for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n+            let tainted = self.get_ref().infcx.region_vars.tainted(snapshot, skol);\n             for tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n@@ -201,7 +205,7 @@ impl Combine for Sub {\n                 };\n \n                 // A is not as polymorphic as B:\n-                if self.a_is_expected {\n+                if self.a_is_expected() {\n                     return Err(ty::terr_regions_insufficiently_polymorphic(\n                             skol_br, *tainted_region));\n                 } else {"}, {"sha": "0f42989855acf981c25b4156c7e5ddf31b872811", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -242,7 +242,7 @@ impl<'a> ToStr for VarianceTerm<'a> {\n             ConstantTerm(c1) => format!(\"{}\", c1.to_str()),\n             TransformTerm(v1, v2) => format!(\"({} \\u00D7 {})\",\n                                           v1.to_str(), v2.to_str()),\n-            InferredTerm(id) => format!(\"[{}]\", *id)\n+            InferredTerm(id) => format!(\"[{}]\", { let InferredIndex(i) = id; i })\n         }\n     }\n }\n@@ -543,8 +543,8 @@ impl<'a> ConstraintContext<'a> {\n             // Parameter on an item defined within current crate:\n             // variance not yet inferred, so return a symbolic\n             // variance.\n-            let index = self.inferred_index(param_def_id.node);\n-            self.terms_cx.inferred_infos[*index].term\n+            let InferredIndex(index) = self.inferred_index(param_def_id.node);\n+            self.terms_cx.inferred_infos[index].term\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -559,11 +559,11 @@ impl<'a> ConstraintContext<'a> {\n     }\n \n     fn add_constraint(&mut self,\n-                      index: InferredIndex,\n+                      InferredIndex(index): InferredIndex,\n                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraint(index={}, variance={})\",\n-                *index, variance.to_str());\n-        self.constraints.push(Constraint { inferred: index,\n+                index, variance.to_str());\n+        self.constraints.push(Constraint { inferred: InferredIndex(index),\n                                            variance: variance });\n     }\n \n@@ -852,19 +852,20 @@ impl<'a> SolveContext<'a> {\n \n             for constraint in self.constraints.iter() {\n                 let Constraint { inferred, variance: term } = *constraint;\n+                let InferredIndex(inferred) = inferred;\n                 let variance = self.evaluate(term);\n-                let old_value = self.solutions[*inferred];\n+                let old_value = self.solutions[inferred];\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n                             from {:?} to {:?} due to {}\",\n-                            *inferred,\n-                            self.terms_cx.inferred_infos[*inferred].param_id,\n+                            inferred,\n+                            self.terms_cx.inferred_infos[inferred].param_id,\n                             old_value,\n                             new_value,\n                             term.to_str());\n \n-                    self.solutions[*inferred] = new_value;\n+                    self.solutions[inferred] = new_value;\n                     changed = true;\n                 }\n             }\n@@ -943,8 +944,8 @@ impl<'a> SolveContext<'a> {\n                 v1.xform(v2)\n             }\n \n-            InferredTerm(index) => {\n-                self.solutions[*index]\n+            InferredTerm(InferredIndex(index)) => {\n+                self.solutions[index]\n             }\n         }\n     }"}, {"sha": "ad7fcd6b0c832abe1871a7c8ab1c61e86991f4ca", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -19,6 +19,7 @@ use syntax::ast_map;\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttributeMethods;\n+use syntax::codemap::Pos;\n \n use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n@@ -289,6 +290,14 @@ impl Clean<TyParamBound> for ast::TyParamBound {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Lifetime(~str);\n \n+impl Lifetime {\n+    pub fn get_ref<'a>(&'a self) -> &'a str {\n+        let Lifetime(ref s) = *self;\n+        let s: &'a str = *s;\n+        return s;\n+    }\n+}\n+\n impl Clean<Lifetime> for ast::Lifetime {\n     fn clean(&self) -> Lifetime {\n         Lifetime(self.ident.clean())\n@@ -798,9 +807,9 @@ impl Clean<Span> for syntax::codemap::Span {\n         Span {\n             filename: filename.to_owned(),\n             loline: lo.line,\n-            locol: *lo.col,\n+            locol: lo.col.to_uint(),\n             hiline: hi.line,\n-            hicol: *hi.col,\n+            hicol: hi.col.to_uint(),\n         }\n     }\n }"}, {"sha": "13e1b8ed6dea291af66be21575555de3e0dfafe9", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -23,6 +23,7 @@ impl<'a> fmt::Default for Escape<'a> {\n     fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n+        let Escape(s) = *s;\n         let pile_o_bits = s.as_slice();\n         let mut last = 0;\n         for (i, ch) in s.bytes().enumerate() {"}, {"sha": "edc47fd2d6930d7304cff3cf09188a0409681eeb", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -35,6 +35,18 @@ pub struct PuritySpace(ast::purity);\n /// Wrapper struct for properly emitting a method declaration.\n pub struct Method<'a>(&'a clean::SelfTy, &'a clean::FnDecl);\n \n+impl VisSpace {\n+    pub fn get(&self) -> Option<ast::visibility> {\n+        let VisSpace(v) = *self; v\n+    }\n+}\n+\n+impl PuritySpace {\n+    pub fn get(&self) -> ast::purity {\n+        let PuritySpace(v) = *self; v\n+    }\n+}\n+\n impl fmt::Default for clean::Generics {\n     fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) {\n         if g.lifetimes.len() == 0 && g.type_params.len() == 0 { return }\n@@ -68,7 +80,7 @@ impl fmt::Default for clean::Generics {\n impl fmt::Default for clean::Lifetime {\n     fn fmt(l: &clean::Lifetime, f: &mut fmt::Formatter) {\n         f.buf.write(\"'\".as_bytes());\n-        f.buf.write(l.as_bytes());\n+        f.buf.write(l.get_ref().as_bytes());\n     }\n }\n \n@@ -424,7 +436,7 @@ impl<'a> fmt::Default for Method<'a> {\n \n impl fmt::Default for VisSpace {\n     fn fmt(v: &VisSpace, f: &mut fmt::Formatter) {\n-        match **v {\n+        match v.get() {\n             Some(ast::public) => { write!(f.buf, \"pub \"); }\n             Some(ast::private) => { write!(f.buf, \"priv \"); }\n             Some(ast::inherited) | None => {}\n@@ -434,7 +446,7 @@ impl fmt::Default for VisSpace {\n \n impl fmt::Default for PuritySpace {\n     fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) {\n-        match **p {\n+        match p.get() {\n             ast::unsafe_fn => write!(f.buf, \"unsafe \"),\n             ast::extern_fn => write!(f.buf, \"extern \"),\n             ast::impure_fn => {}"}, {"sha": "8fa8b573bca93f3d832d350da5ec3b5b6e7c376e", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -209,6 +209,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n \n impl<'a> fmt::Default for Markdown<'a> {\n     fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) {\n+        let Markdown(md) = *md;\n         // This is actually common enough to special-case\n         if md.len() == 0 { return; }\n         render(fmt.buf, md.as_slice());"}, {"sha": "a74b457fbd1ba19e395978eacd3f9552723096ce", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -972,6 +972,7 @@ fn item_module(w: &mut Writer, cx: &Context,\n                 struct Initializer<'a>(&'a str);\n                 impl<'a> fmt::Default for Initializer<'a> {\n                     fn fmt(s: &Initializer<'a>, f: &mut fmt::Formatter) {\n+                        let Initializer(s) = *s;\n                         if s.len() == 0 { return; }\n                         write!(f.buf, \"<code> = </code>\");\n                         let tag = if s.contains(\"\\n\") { \"pre\" } else { \"code\" };\n@@ -1537,6 +1538,7 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n \n impl<'a> fmt::Default for Source<'a> {\n     fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) {\n+        let Source(s) = *s;\n         let lines = s.lines().len();\n         let mut cols = 0;\n         let mut tmp = lines;"}, {"sha": "2740e75b3fceb9c239928b389d4aa75d6809f7d2", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -157,7 +157,8 @@ impl<'a> fold::DocFolder for ImplStripper<'a> {\n             clean::ImplItem(ref imp) => {\n                 match imp.trait_ {\n                     Some(clean::ResolvedPath{ id, .. }) => {\n-                        if !self.contains(&id) {\n+                        let ImplStripper(s) = *self;\n+                        if !s.contains(&id) {\n                             return None;\n                         }\n                     }"}, {"sha": "d9589788c4db164fec15754bbf02ff07a6fca2f5", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -140,8 +140,9 @@ mod test_remote {\n             fn call(&mut self) {\n                 // this can get called more than once, but we only want to send\n                 // once\n-                if self.is_some() {\n-                    self.take_unwrap().send(1);\n+                let MyCallback(ref mut s) = *self;\n+                if s.is_some() {\n+                    s.take_unwrap().send(1);\n                 }\n             }\n         }"}, {"sha": "ccfa5a51b6a129b7dd25bcebff1f9aafa73e051f", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -310,7 +310,8 @@ impl UvError {\n     }\n \n     pub fn is_eof(&self) -> bool {\n-        **self == uvll::EOF\n+        let UvError(handle) = *self;\n+        handle == uvll::EOF\n     }\n }\n \n@@ -331,10 +332,11 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n         // Importing error constants\n \n         // uv error descriptions are static\n-        let c_desc = uvll::uv_strerror(*uverr);\n+        let UvError(errcode) = uverr;\n+        let c_desc = uvll::uv_strerror(errcode);\n         let desc = str::raw::c_str_to_static_slice(c_desc);\n \n-        let kind = match *uverr {\n+        let kind = match errcode {\n             uvll::UNKNOWN => io::OtherIoError,\n             uvll::OK => io::OtherIoError,\n             uvll::EOF => io::EndOfFile,"}, {"sha": "d1b1273d5e0a446721e20972762ffc72fb13e2f3", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -309,7 +309,8 @@ mod tests {\n     struct Bytes<'a>(&'a [u8]);\n     impl<'a> IterBytes for Bytes<'a> {\n         fn iter_bytes(&self, _lsb0: bool, f: |&[u8]| -> bool) -> bool {\n-            f(**self)\n+            let Bytes(v) = *self;\n+            f(v)\n         }\n     }\n "}, {"sha": "fd8fd0c681407d30ad9ef747827c3dafa207c405", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -243,9 +243,31 @@ impl<W: Writer> Decorator<W> for LineBufferedWriter<W> {\n \n struct InternalBufferedWriter<W>(BufferedWriter<W>);\n \n+impl<W> InternalBufferedWriter<W> {\n+    fn get_mut_ref<'a>(&'a mut self) -> &'a mut BufferedWriter<W> {\n+        let InternalBufferedWriter(ref mut w) = *self;\n+        return w;\n+    }\n+}\n+\n+impl<W: Writer> Decorator<W> for InternalBufferedWriter<W> {\n+    fn inner(self) -> W {\n+        let InternalBufferedWriter(s) = self;\n+        s.inner()\n+    }\n+    fn inner_ref<'a>(&'a self) -> &'a W {\n+        let InternalBufferedWriter(ref s) = *self;\n+        s.inner_ref()\n+    }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n+        let InternalBufferedWriter(ref mut s) = *self;\n+        s.inner_mut_ref()\n+    }\n+}\n+\n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n-    fn eof(&mut self) -> bool { self.inner.eof() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.get_mut_ref().inner.read(buf) }\n+    fn eof(&mut self) -> bool { self.get_mut_ref().inner.eof() }\n }\n \n /// Wraps a Stream and buffers input and output to and from it\n@@ -282,15 +304,15 @@ impl<S: Stream> Reader for BufferedStream<S> {\n }\n \n impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) { self.inner.inner.write(buf) }\n-    fn flush(&mut self) { self.inner.inner.flush() }\n+    fn write(&mut self, buf: &[u8]) { self.inner.inner.get_mut_ref().write(buf) }\n+    fn flush(&mut self) { self.inner.inner.get_mut_ref().flush() }\n }\n \n impl<S: Stream> Decorator<S> for BufferedStream<S> {\n     fn inner(self) -> S { self.inner.inner.inner() }\n     fn inner_ref<'a>(&'a self) -> &'a S { self.inner.inner.inner_ref() }\n     fn inner_mut_ref<'a>(&'a mut self) -> &'a mut S {\n-        self.inner.inner.inner_mut_ref()\n+        self.inner.inner.get_mut_ref().inner_mut_ref()\n     }\n }\n "}, {"sha": "cf203f2782cd6527e6eab26a045450932f2b2012", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -706,11 +706,24 @@ mod test {\n \n     struct TempDir(Path);\n \n+    impl TempDir {\n+        fn join(&self, path: &str) -> Path {\n+            let TempDir(ref p) = *self;\n+            p.join(path)\n+        }\n+\n+        fn path<'a>(&'a self) -> &'a Path {\n+            let TempDir(ref p) = *self;\n+            p\n+        }\n+    }\n+\n     impl Drop for TempDir {\n         fn drop(&mut self) {\n             // Gee, seeing how we're testing the fs module I sure hope that we\n             // at least implement this correctly!\n-            io::fs::rmdir_recursive(&**self);\n+            let TempDir(ref p) = *self;\n+            io::fs::rmdir_recursive(p);\n         }\n     }\n \n@@ -961,7 +974,7 @@ mod test {\n \n         let tmpdir = tmpdir();\n \n-        let mut dirpath = tmpdir.clone();\n+        let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n         mkdir(&dirpath, io::UserRWX);\n         assert!(dirpath.is_dir());\n@@ -978,7 +991,7 @@ mod test {\n         assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n         let tmpdir = tmpdir();\n-        let unicode = tmpdir.clone();\n+        let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n         mkdir(&unicode, io::UserRWX);\n         assert!(unicode.exists());\n@@ -1015,7 +1028,7 @@ mod test {\n         let out = tmpdir.join(\"out\");\n \n         File::create(&out);\n-        match io::result(|| copy(&out, &*tmpdir)) {\n+        match io::result(|| copy(&out, tmpdir.path())) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n     })\n@@ -1037,7 +1050,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n-        match io::result(|| copy(&*tmpdir, &out)) {\n+        match io::result(|| copy(tmpdir.path(), &out)) {\n             Ok(..) => fail!(), Err(..) => {}\n         }\n         assert!(!out.exists());\n@@ -1082,7 +1095,7 @@ mod test {\n \n     iotest!(fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n-        match io::result(|| readlink(&*tmpdir)) {\n+        match io::result(|| readlink(tmpdir.path())) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }"}, {"sha": "6164ecd1a2b45c852ece0a061ecf3a395d5793d9", "filename": "src/libstd/rand/distributions/exponential.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -83,7 +83,8 @@ impl Sample<f64> for Exp {\n }\n impl IndependentSample<f64> for Exp {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        (*rng.gen::<Exp1>()) * self.lambda_inverse\n+        let Exp1(n) = rng.gen::<Exp1>();\n+        n * self.lambda_inverse\n     }\n }\n "}, {"sha": "731baa0f3055567c5fe009b49505e599e126b2a6", "filename": "src/libstd/rand/distributions/gamma.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -141,22 +141,22 @@ impl IndependentSample<f64> for Gamma {\n }\n impl IndependentSample<f64> for GammaSmallShape {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let u = *rng.gen::<Open01<f64>>();\n+        let Open01(u) = rng.gen::<Open01<f64>>();\n \n         self.large_shape.ind_sample(rng) * num::pow(u, self.inv_shape)\n     }\n }\n impl IndependentSample<f64> for GammaLargeShape {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n         loop {\n-            let x = *rng.gen::<StandardNormal>();\n+            let StandardNormal(x) = rng.gen::<StandardNormal>();\n             let v_cbrt = 1.0 + self.c * x;\n             if v_cbrt <= 0.0 { // a^3 <= 0 iff a <= 0\n                 continue\n             }\n \n             let v = v_cbrt * v_cbrt * v_cbrt;\n-            let u = *rng.gen::<Open01<f64>>();\n+            let Open01(u) = rng.gen::<Open01<f64>>();\n \n             let x_sqr = x * x;\n             if u < 1.0 - 0.0331 * x_sqr * x_sqr ||\n@@ -213,7 +213,7 @@ impl IndependentSample<f64> for ChiSquared {\n         match *self {\n             DoFExactlyOne => {\n                 // k == 1 => N(0,1)^2\n-                let norm = *rng.gen::<StandardNormal>();\n+                let StandardNormal(norm) = rng.gen::<StandardNormal>();\n                 norm * norm\n             }\n             DoFAnythingElse(ref g) => g.ind_sample(rng)\n@@ -302,7 +302,7 @@ impl Sample<f64> for StudentT {\n }\n impl IndependentSample<f64> for StudentT {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        let norm = *rng.gen::<StandardNormal>();\n+        let StandardNormal(norm) = rng.gen::<StandardNormal>();\n         norm * (self.dof / self.chi.ind_sample(rng)).sqrt()\n     }\n }"}, {"sha": "a297bbee1e6f7232b60d62da1b58d4069cf743e2", "filename": "src/libstd/rand/distributions/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -254,6 +254,7 @@ mod tests {\n     use super::*;\n     use option::{Some, None};\n \n+    #[deriving(Eq)]\n     struct ConstRand(uint);\n     impl Rand for ConstRand {\n         fn rand<R: Rng>(_: &mut R) -> ConstRand {\n@@ -277,8 +278,8 @@ mod tests {\n     fn test_rand_sample() {\n         let mut rand_sample = RandSample::<ConstRand>;\n \n-        assert_eq!(*rand_sample.sample(&mut task_rng()), 0);\n-        assert_eq!(*rand_sample.ind_sample(&mut task_rng()), 0);\n+        assert_eq!(rand_sample.sample(&mut task_rng()), ConstRand(0));\n+        assert_eq!(rand_sample.ind_sample(&mut task_rng()), ConstRand(0));\n     }\n     #[test]\n     fn test_weighted_choice() {"}, {"sha": "4103b859ff88bfc99ad6d3d46c85d92e19fe8595", "filename": "src/libstd/rand/distributions/normal.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -46,8 +46,8 @@ impl Rand for StandardNormal {\n             let mut y = 0.0f64;\n \n             while -2.0 * y < x * x {\n-                let x_ = *rng.gen::<Open01<f64>>();\n-                let y_ = *rng.gen::<Open01<f64>>();\n+                let Open01(x_) = rng.gen::<Open01<f64>>();\n+                let Open01(y_) = rng.gen::<Open01<f64>>();\n \n                 x = x_.ln() / ziggurat_tables::ZIG_NORM_R;\n                 y = y_.ln();\n@@ -102,7 +102,8 @@ impl Sample<f64> for Normal {\n }\n impl IndependentSample<f64> for Normal {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        self.mean + self.std_dev * (*rng.gen::<StandardNormal>())\n+        let StandardNormal(n) = rng.gen::<StandardNormal>();\n+        self.mean + self.std_dev * n\n     }\n }\n "}, {"sha": "0fa436b2447efe27d11457440d1962e092c1e0d9", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -630,13 +630,11 @@ pub fn random<T: Rand>() -> T {\n /// `[0,1)`.\n ///\n /// # Example\n-/// ```rust\n+/// ```rust,ignore\n /// use std::rand::{random, Open01};\n ///\n-/// println!(\"f32 from (0,1): {}\", *random::<Open01<f32>>());\n-///\n-/// let x: Open01<f64> = random();\n-/// println!(\"f64 from (0,1): {}\", *x);\n+/// let Open01(val) = random::<Open01<f32>>();\n+/// println!(\"f32 from (0,1): {}\", val);\n /// ```\n pub struct Open01<F>(F);\n \n@@ -648,13 +646,11 @@ pub struct Open01<F>(F);\n /// `[0,1)`.\n ///\n /// # Example\n-/// ```rust\n+/// ```rust,ignore\n /// use std::rand::{random, Closed01};\n ///\n-/// println!(\"f32 from [0,1]: {}\", *random::<Closed01<f32>>());\n-///\n-/// let x: Closed01<f64> = random();\n-/// println!(\"f64 from [0,1]: {}\", *x);\n+/// let Closed01(val) = random::<Closed01<f32>>();\n+/// println!(\"f32 from [0,1]: {}\", val);\n /// ```\n pub struct Closed01<F>(F);\n "}, {"sha": "dd6edca94ac6bfaeeeab9fe5628fddb74c62afb2", "filename": "src/libstd/rand/rand_impls.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Frand_impls.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -233,10 +233,12 @@ mod tests {\n     struct ConstantRng(u64);\n     impl Rng for ConstantRng {\n         fn next_u32(&mut self) -> u32 {\n-            (**self) as u32\n+            let ConstantRng(v) = *self;\n+            v as u32\n         }\n         fn next_u64(&mut self) -> u64 {\n-            **self\n+            let ConstantRng(v) = *self;\n+            v\n         }\n     }\n \n@@ -254,10 +256,10 @@ mod tests {\n         let mut rng = task_rng();\n         for _ in range(0, 1_000) {\n             // strict inequalities\n-            let f = *rng.gen::<Open01<f64>>();\n+            let Open01(f) = rng.gen::<Open01<f64>>();\n             assert!(0.0 < f && f < 1.0);\n \n-            let f = *rng.gen::<Open01<f32>>();\n+            let Open01(f) = rng.gen::<Open01<f32>>();\n             assert!(0.0 < f && f < 1.0);\n         }\n     }\n@@ -267,10 +269,10 @@ mod tests {\n         let mut rng = task_rng();\n         for _ in range(0, 1_000) {\n             // strict inequalities\n-            let f = *rng.gen::<Closed01<f64>>();\n+            let Closed01(f) = rng.gen::<Closed01<f64>>();\n             assert!(0.0 <= f && f <= 1.0);\n \n-            let f = *rng.gen::<Closed01<f32>>();\n+            let Closed01(f) = rng.gen::<Closed01<f32>>();\n             assert!(0.0 <= f && f <= 1.0);\n         }\n     }"}, {"sha": "3efa979e51515ffb63f5d49a1fc90c74cb86c612", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -153,9 +153,13 @@ impl Task {\n                 // annihilated invoke TLS. Sadly these two operations seemed to\n                 // be intertwined, and miraculously work for now...\n                 let mut task = Local::borrow(None::<Task>);\n-                let storage = task.get().storage.take();\n+                let storage_map = {\n+                    let task = task.get();\n+                    let LocalStorage(ref mut optmap) = task.storage;\n+                    optmap.take()\n+                };\n                 drop(task);\n-                drop(storage);\n+                drop(storage_map);\n \n                 // Destroy remaining boxes. Also may run user dtors.\n                 unsafe { cleanup::annihilate(); }"}, {"sha": "0d4c820e6379ad0ae196a8efe13901e14f4d38c6", "filename": "src/libstd/str.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -4042,7 +4042,8 @@ mod bench {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n             fn matches(&self, c: char) -> bool {\n-                **self == c\n+                let NotAscii(cc) = *self;\n+                cc == c\n             }\n             fn only_ascii(&self) -> bool { false }\n         }\n@@ -4065,7 +4066,10 @@ mod bench {\n         struct NotAscii(char);\n         impl CharEq for NotAscii {\n             #[inline]\n-            fn matches(&self, c: char) -> bool { **self == c }\n+            fn matches(&self, c: char) -> bool {\n+                let NotAscii(cc) = *self;\n+                cc == c\n+            }\n             fn only_ascii(&self) -> bool { false }\n         }\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";"}, {"sha": "8f5c4904c782bfd98a87d06540aeb41b030eb916", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -46,35 +46,35 @@ pub struct CharPos(uint);\n \n impl Pos for BytePos {\n     fn from_uint(n: uint) -> BytePos { BytePos(n as u32) }\n-    fn to_uint(&self) -> uint { **self as uint }\n+    fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n }\n \n impl Add<BytePos, BytePos> for BytePos {\n     fn add(&self, rhs: &BytePos) -> BytePos {\n-        BytePos(**self + **rhs)\n+        BytePos((self.to_uint() + rhs.to_uint()) as u32)\n     }\n }\n \n impl Sub<BytePos, BytePos> for BytePos {\n     fn sub(&self, rhs: &BytePos) -> BytePos {\n-        BytePos(**self - **rhs)\n+        BytePos((self.to_uint() - rhs.to_uint()) as u32)\n     }\n }\n \n impl Pos for CharPos {\n     fn from_uint(n: uint) -> CharPos { CharPos(n) }\n-    fn to_uint(&self) -> uint { **self }\n+    fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n }\n \n impl Add<CharPos,CharPos> for CharPos {\n     fn add(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(**self + **rhs)\n+        CharPos(self.to_uint() + rhs.to_uint())\n     }\n }\n \n impl Sub<CharPos,CharPos> for CharPos {\n     fn sub(&self, rhs: &CharPos) -> CharPos {\n-        CharPos(**self - **rhs)\n+        CharPos(self.to_uint() - rhs.to_uint())\n     }\n }\n "}, {"sha": "fb14ba71b8828c5b2e7a24fa3276780c32a05588", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -172,7 +172,8 @@ impl Colors {\n     }\n \n     fn next(&self) -> u8 {\n-        let val = **self & HEADS;\n+        let Colors(c) = *self;\n+        let val = c & HEADS;\n         if (0u16 == val) {\n             return 0u8;\n         } else {\n@@ -184,7 +185,7 @@ impl Colors {\n \n     fn remove(&mut self, color: u8) {\n         if color != 0u8 {\n-            let val  = **self;\n+            let Colors(val) = *self;\n             let mask = !(1u16 << color);\n             *self    = Colors(val & mask);\n         }"}, {"sha": "fcaba0adc46eb710860019d8cbaf437e51c5ca90", "filename": "src/test/compile-fail/borrowck-assign-to-enum.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-enum.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct foo(int);\n-\n-fn main() {\n-    let x = foo(3);\n-    *x = 4; //~ ERROR cannot assign to immutable anonymous field\n-}"}, {"sha": "b8735fb2d3cf93277c934f4613f3dc77999c069f", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -14,7 +14,8 @@ struct X(Either<(uint,uint),extern fn()>);\n \n impl X {\n     pub fn with(&self, blk: |x: &Either<(uint,uint),extern fn()>|) {\n-        blk(&**self)\n+        let X(ref e) = *self;\n+        blk(e)\n     }\n }\n "}, {"sha": "962b70685460a007f219dab288dc5ce5fdf2efa2", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -12,7 +12,9 @@ struct foo(~uint);\n \n impl Add<foo, foo> for foo {\n     fn add(&self, f: &foo) -> foo {\n-        foo(~(***self + **(*f)))\n+        let foo(~i) = *self;\n+        let foo(~j) = *f;\n+        foo(~(i + j))\n     }\n }\n "}, {"sha": "4faee14e8c72d4afc102ac4ba808bbb3f006004d", "filename": "src/test/compile-fail/borrowck-move-out-of-tuple-struct-with-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-tuple-struct-with-dtor.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -1,6 +1,6 @@\n struct S(~str);\n impl Drop for S {\n-    fn drop(&mut self) { println(**self); }\n+    fn drop(&mut self) { }\n }\n \n fn move_in_match() {"}, {"sha": "77318e6a636a1fb47c4b0a0d0f2739959fce039d", "filename": "src/test/compile-fail/borrowck-mut-deref-comp.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-deref-comp.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-struct foo(~int);\n-\n-fn borrow(x: @foo) {\n-    let _y = &***x;\n-    *x = foo(~4); //~ ERROR cannot assign\n-}\n-\n-fn main() {\n-}"}, {"sha": "dc4530d586eae832ff694eda8b625acc5cd40688", "filename": "src/test/compile-fail/issue-2370-2.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fissue-2370-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fissue-2370-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2370-2.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: can only dereference structs\n-struct cat {\n-    x: ()\n-}\n-\n-fn main() {\n-    let kitty : cat = cat { x: () };\n-    error!(\"{:?}\", *kitty);\n-}"}, {"sha": "656088a00b7dd3ad158745e8f324641ef96d2a99", "filename": "src/test/compile-fail/issue-2370.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fissue-2370.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fissue-2370.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2370.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: can only dereference structs\n-struct cat {\n-    foo: ()\n-}\n-\n-fn main() {\n-    let nyan = cat { foo: () };\n-    error!(\"{:?}\", *nyan);\n-}"}, {"sha": "88414dddd660c2101edbe5ac45399201d8a75028", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -10,7 +10,7 @@\n \n struct thing(uint);\n impl Ord for thing { //~ ERROR not all trait methods implemented, missing: `lt`\n-    fn le(&self, other: &thing) -> bool { **self < **other }\n-    fn ge(&self, other: &thing) -> bool { **self < **other }\n+    fn le(&self, other: &thing) -> bool { true }\n+    fn ge(&self, other: &thing) -> bool { true }\n }\n fn main() {}"}, {"sha": "b9540fe2cf02b365e444b5cce2c194dc67764e7f", "filename": "src/test/compile-fail/issue-5358.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fissue-5358.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Fcompile-fail%2Fissue-5358.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5358.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-enum Either<T, U> { Left(T), Right(U) }\n-struct S(Either<uint, uint>);\n-\n-fn main() {\n-    match *S(Left(5)) {\n-      S(_) => {}  //~ ERROR mismatched types: expected `Either<uint,uint>` but found a structure pattern\n-    }\n-}"}, {"sha": "e00f41426438cf43ecd6e322cac76621003d0910", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -26,7 +26,9 @@ fn make_cycle<A:'static>(a: A) {\n     let g: @RefCell<RecEnum<A>> = @RefCell::new(RecEnum(Rec {val: a, rec: None}));\n     {\n         let mut gb = g.borrow_mut();\n-        gb.get().rec = Some(g);\n+        let gg = gb.get();\n+        let RecEnum(ref mut gg) = *gg;\n+        gg.rec = Some(g);\n     }\n }\n "}, {"sha": "8adc2cfd571906595a3322ca25cce7d602566eaf", "filename": "src/test/run-pass/auto-ref-newtype.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-newtype.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check that we can define inherent methods on newtype enums that use\n-// an auto-ref'd receiver.\n-\n-struct Foo(uint);\n-\n-impl Foo {\n-    pub fn len(&self) -> uint { **self }\n-}\n-\n-pub fn main() {\n-    let m = Foo(3);\n-    assert_eq!(m.len(), 3);\n-}"}, {"sha": "e3a19b23e91bf34ed25fcc646464ed12c1cf18bc", "filename": "src/test/run-pass/autoderef-method-newtype.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-newtype.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait double {\n-    fn double(&self) -> uint;\n-}\n-\n-impl double for uint {\n-    fn double(&self) -> uint { *self * 2u }\n-}\n-\n-struct foo(uint);\n-\n-pub fn main() {\n-    let x = foo(3u);\n-    assert_eq!(x.double(), 6u);\n-}"}, {"sha": "87d42943fac97862f2c30c51cbabe9e8a1cc5d0a", "filename": "src/test/run-pass/borrowck-unary-move-2.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,32 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct noncopyable {\n-    i: (),\n-}\n-\n-impl Drop for noncopyable {\n-    fn drop(&mut self) {\n-        error!(\"dropped\");\n-    }\n-}\n-\n-fn noncopyable() -> noncopyable {\n-    noncopyable {\n-        i: ()\n-    }\n-}\n-\n-struct wrapper(noncopyable);\n-\n-pub fn main() {\n-    let x1 = wrapper(noncopyable());\n-    let _x2 = *x1;\n-}"}, {"sha": "3650564d929caa9ea3d4562fd33d8f85bf47409c", "filename": "src/test/run-pass/cmp-default.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fcmp-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fcmp-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcmp-default.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -14,23 +14,29 @@ struct Fool(bool);\n \n impl Eq for Fool {\n     fn eq(&self, other: &Fool) -> bool {\n-        **self != **other\n+        let Fool(this) = *self;\n+        let Fool(other) = *other;\n+        this != other\n     }\n }\n \n struct Int(int);\n \n impl Ord for Int {\n     fn lt(&self, other: &Int) -> bool {\n-        **self < **other\n+        let Int(this) = *self;\n+        let Int(other) = *other;\n+        this < other\n     }\n }\n \n struct RevInt(int);\n \n impl Ord for RevInt {\n     fn lt(&self, other: &RevInt) -> bool {\n-        **self > **other\n+        let RevInt(this) = *self;\n+        let RevInt(other) = *other;\n+        this > other\n     }\n }\n "}, {"sha": "19dea653a4a278b6a320bf48cac5654a6eced66b", "filename": "src/test/run-pass/const-autoderef-newtype.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef-newtype.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct S(&'static [int]);\n-static C0: S = S([3]);\n-static C1: int = C0[0];\n-\n-pub fn main() {\n-    assert_eq!(C1, 3);\n-}"}, {"sha": "7c2771c3544f75bfe11db55094388125280d6fe3", "filename": "src/test/run-pass/const-deref.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fconst-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-deref.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -10,11 +10,7 @@\n \n static C: &'static int = &1000;\n static D: int = *C;\n-struct S(&'static int);\n-static E: &'static S = &S(C);\n-static F: int = ***E;\n \n pub fn main() {\n     assert_eq!(D, 1000);\n-    assert_eq!(F, 1000);\n }"}, {"sha": "d6aa69c4c13582af5e13e01480f4082d3bc56a22", "filename": "src/test/run-pass/generic-newtype-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fgeneric-newtype-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fgeneric-newtype-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-newtype-struct.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -1,6 +1,5 @@\n struct S<T>(T);\n \n pub fn main() {\n-    let s = S(2i);\n-    println(s.to_str());\n+    let _s = S(2i);\n }"}, {"sha": "b8205d9635b45894f2de9442495fe2d3221220ed", "filename": "src/test/run-pass/issue-4735.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fissue-4735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4735.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -16,7 +16,7 @@ struct NonCopyable(*c_void);\n \n impl Drop for NonCopyable {\n     fn drop(&mut self) {\n-        let p = **self;\n+        let NonCopyable(p) = *self;\n         let _v = unsafe { transmute::<*c_void, ~int>(p) };\n     }\n }"}, {"sha": "543f4bf027bfd10293662e2e1798414a78f6aa9a", "filename": "src/test/run-pass/issue-5917.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fissue-5917.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fissue-5917.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5917.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -11,5 +11,6 @@\n struct T (&'static [int]);\n static t : T = T (&'static [5, 4, 3]);\n pub fn main () {\n-    assert_eq!(t[0], 5);\n+    let T(ref v) = t;\n+    assert_eq!(v[0], 5);\n }"}, {"sha": "b1e05c6887a67683933466658c979dfa7c6e3cb4", "filename": "src/test/run-pass/issue-9446.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fissue-9446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fissue-9446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9446.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -16,7 +16,8 @@ impl Wrapper {\n     }\n \n     pub fn say_hi(&self) {\n-        println!(\"hello {}\", **self);\n+        let Wrapper(ref s) = *self;\n+        println!(\"hello {}\", *s);\n     }\n }\n "}, {"sha": "a06d025f6c7a5d0ea6dee7f096a61eb48a53956c", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -18,6 +18,7 @@ struct Foo(Cell<int>);\n \n impl fmt::Default for Foo {\n     fn fmt(f: &Foo, _fmt: &mut fmt::Formatter) {\n+        let Foo(ref f) = *f;\n         assert!(f.get() == 0);\n         f.set(1);\n     }\n@@ -28,6 +29,7 @@ pub fn main() {\n     do spawn {\n         let mut f = Foo(Cell::new(0));\n         debug!(\"{}\", f);\n+        let Foo(ref mut f) = f;\n         assert!(f.get() == 1);\n         c.send(());\n     }"}, {"sha": "0ca606b2cd33719faa3d9351588af57c1d2cc5c3", "filename": "src/test/run-pass/monomorphize-abi-alignment.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -20,12 +20,14 @@\n \n struct S<T> { i:u8, t:T }\n impl<T> S<T> { fn unwrap(self) -> T { self.t } }\n+#[deriving(Eq)]\n struct A((u32, u32));\n+#[deriving(Eq)]\n struct B(u64);\n \n pub fn main() {\n     static Ca: S<A> = S { i: 0, t: A((13, 104)) };\n     static Cb: S<B> = S { i: 0, t: B(31337) };\n-    assert_eq!(*(Ca.unwrap()), (13, 104));\n-    assert_eq!(*(Cb.unwrap()), 31337);\n+    assert_eq!(Ca.unwrap(), A((13, 104)));\n+    assert_eq!(Cb.unwrap(), B(31337));\n }"}, {"sha": "7bc28e6b00ff58205ccdd01370f7eb6e540ba12d", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -11,13 +11,20 @@\n #[deriving(Clone)]\n struct myvec<X>(~[X]);\n \n-fn myvec_deref<X:Clone>(mv: myvec<X>) -> ~[X] { return (*mv).clone(); }\n+fn myvec_deref<X:Clone>(mv: myvec<X>) -> ~[X] {\n+    let myvec(v) = mv;\n+    return v.clone();\n+}\n \n-fn myvec_elt<X>(mv: myvec<X>) -> X { return mv[0]; }\n+fn myvec_elt<X>(mv: myvec<X>) -> X {\n+    let myvec(v) = mv;\n+    return v[0];\n+}\n \n pub fn main() {\n     let mv = myvec(~[1, 2, 3]);\n     assert_eq!(myvec_deref(mv.clone())[1], 2);\n     assert_eq!(myvec_elt(mv.clone()), 1);\n-    assert_eq!(mv[2], 3);\n+    let myvec(v) = mv;\n+    assert_eq!(v[2], 3);\n }"}, {"sha": "abd9c537fd22dd14ab8fd44c574d661828e171ca", "filename": "src/test/run-pass/newtype-struct-drop-run.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-struct-drop-run.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -19,7 +19,8 @@ struct Foo(@Cell<int>);\n #[unsafe_destructor]\n impl Drop for Foo {\n     fn drop(&mut self) {\n-        self.set(23);\n+        let Foo(i) = *self;\n+        i.set(23);\n     }\n }\n "}, {"sha": "cbbfc387de3d7bc6c9f02f627f2fd06ae56c2f1d", "filename": "src/test/run-pass/newtype-struct-with-dtor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-struct-with-dtor.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -6,7 +6,8 @@ pub struct Fd(c_int);\n impl Drop for Fd {\n     fn drop(&mut self) {\n         unsafe {\n-            libc::close(**self);\n+            let Fd(s) = *self;\n+            libc::close(s);\n         }\n     }\n }"}, {"sha": "3db333f36b8c6ef7c0fb193665656d8f00f8c435", "filename": "src/test/run-pass/newtype-temporary.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-temporary.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[deriving(Eq)]\n struct Foo(uint);\n \n fn foo() -> Foo {\n     Foo(42)\n }\n \n pub fn main() {\n-    assert_eq!(*foo(), 42);\n+    assert_eq!(foo(), Foo(42));\n }"}, {"sha": "b0d2da9773c500f1cc2d5592c882d57f6a591027", "filename": "src/test/run-pass/newtype.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -12,10 +12,14 @@ struct mytype(Mytype);\n \n struct Mytype {compute: extern fn(mytype) -> int, val: int}\n \n-fn compute(i: mytype) -> int { return i.val + 20; }\n+fn compute(i: mytype) -> int {\n+    let mytype(m) = i;\n+    return m.val + 20;\n+}\n \n pub fn main() {\n     let myval = mytype(Mytype{compute: compute, val: 30});\n     println!(\"{}\", compute(myval));\n-    assert_eq!((myval.compute)(myval), 50);\n+    let mytype(m) = myval;\n+    assert_eq!((m.compute)(myval), 50);\n }"}, {"sha": "8fc27cf8ea3b16578548f2bc279ccb57f0786c74", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 77, "deletions": 64, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -34,16 +34,23 @@ fn align(size: uint, align: uint) -> uint {\n \n struct ptr_visit_adaptor<V>(Inner<V>);\n \n+impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n+    fn inner<'a>(&'a mut self) -> &'a mut V {\n+        let ptr_visit_adaptor(ref mut i) = *self;\n+        &mut i.inner\n+    }\n+}\n+\n impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n \n     #[inline(always)]\n     pub fn bump(&mut self, sz: uint) {\n-      self.inner.move_ptr(|p| ((p as uint) + sz) as *c_void)\n+      self.inner().move_ptr(|p| ((p as uint) + sz) as *c_void)\n     }\n \n     #[inline(always)]\n     pub fn align(&mut self, a: uint) {\n-      self.inner.move_ptr(|p| align(p as uint, a) as *c_void)\n+      self.inner().move_ptr(|p| align(p as uint, a) as *c_void)\n     }\n \n     #[inline(always)]\n@@ -62,133 +69,133 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n \n     fn visit_bot(&mut self) -> bool {\n         self.align_to::<()>();\n-        if ! self.inner.visit_bot() { return false; }\n+        if ! self.inner().visit_bot() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n     fn visit_nil(&mut self) -> bool {\n         self.align_to::<()>();\n-        if ! self.inner.visit_nil() { return false; }\n+        if ! self.inner().visit_nil() { return false; }\n         self.bump_past::<()>();\n         true\n     }\n \n     fn visit_bool(&mut self) -> bool {\n         self.align_to::<bool>();\n-        if ! self.inner.visit_bool() { return false; }\n+        if ! self.inner().visit_bool() { return false; }\n         self.bump_past::<bool>();\n         true\n     }\n \n     fn visit_int(&mut self) -> bool {\n         self.align_to::<int>();\n-        if ! self.inner.visit_int() { return false; }\n+        if ! self.inner().visit_int() { return false; }\n         self.bump_past::<int>();\n         true\n     }\n \n     fn visit_i8(&mut self) -> bool {\n         self.align_to::<i8>();\n-        if ! self.inner.visit_i8() { return false; }\n+        if ! self.inner().visit_i8() { return false; }\n         self.bump_past::<i8>();\n         true\n     }\n \n     fn visit_i16(&mut self) -> bool {\n         self.align_to::<i16>();\n-        if ! self.inner.visit_i16() { return false; }\n+        if ! self.inner().visit_i16() { return false; }\n         self.bump_past::<i16>();\n         true\n     }\n \n     fn visit_i32(&mut self) -> bool {\n         self.align_to::<i32>();\n-        if ! self.inner.visit_i32() { return false; }\n+        if ! self.inner().visit_i32() { return false; }\n         self.bump_past::<i32>();\n         true\n     }\n \n     fn visit_i64(&mut self) -> bool {\n         self.align_to::<i64>();\n-        if ! self.inner.visit_i64() { return false; }\n+        if ! self.inner().visit_i64() { return false; }\n         self.bump_past::<i64>();\n         true\n     }\n \n     fn visit_uint(&mut self) -> bool {\n         self.align_to::<uint>();\n-        if ! self.inner.visit_uint() { return false; }\n+        if ! self.inner().visit_uint() { return false; }\n         self.bump_past::<uint>();\n         true\n     }\n \n     fn visit_u8(&mut self) -> bool {\n         self.align_to::<u8>();\n-        if ! self.inner.visit_u8() { return false; }\n+        if ! self.inner().visit_u8() { return false; }\n         self.bump_past::<u8>();\n         true\n     }\n \n     fn visit_u16(&mut self) -> bool {\n         self.align_to::<u16>();\n-        if ! self.inner.visit_u16() { return false; }\n+        if ! self.inner().visit_u16() { return false; }\n         self.bump_past::<u16>();\n         true\n     }\n \n     fn visit_u32(&mut self) -> bool {\n         self.align_to::<u32>();\n-        if ! self.inner.visit_u32() { return false; }\n+        if ! self.inner().visit_u32() { return false; }\n         self.bump_past::<u32>();\n         true\n     }\n \n     fn visit_u64(&mut self) -> bool {\n         self.align_to::<u64>();\n-        if ! self.inner.visit_u64() { return false; }\n+        if ! self.inner().visit_u64() { return false; }\n         self.bump_past::<u64>();\n         true\n     }\n \n     fn visit_f32(&mut self) -> bool {\n         self.align_to::<f32>();\n-        if ! self.inner.visit_f32() { return false; }\n+        if ! self.inner().visit_f32() { return false; }\n         self.bump_past::<f32>();\n         true\n     }\n \n     fn visit_f64(&mut self) -> bool {\n         self.align_to::<f64>();\n-        if ! self.inner.visit_f64() { return false; }\n+        if ! self.inner().visit_f64() { return false; }\n         self.bump_past::<f64>();\n         true\n     }\n \n     fn visit_char(&mut self) -> bool {\n         self.align_to::<char>();\n-        if ! self.inner.visit_char() { return false; }\n+        if ! self.inner().visit_char() { return false; }\n         self.bump_past::<char>();\n         true\n     }\n \n     fn visit_estr_box(&mut self) -> bool {\n         self.align_to::<@str>();\n-        if ! self.inner.visit_estr_box() { return false; }\n+        if ! self.inner().visit_estr_box() { return false; }\n         self.bump_past::<@str>();\n         true\n     }\n \n     fn visit_estr_uniq(&mut self) -> bool {\n         self.align_to::<~str>();\n-        if ! self.inner.visit_estr_uniq() { return false; }\n+        if ! self.inner().visit_estr_uniq() { return false; }\n         self.bump_past::<~str>();\n         true\n     }\n \n     fn visit_estr_slice(&mut self) -> bool {\n         self.align_to::<&'static str>();\n-        if ! self.inner.visit_estr_slice() { return false; }\n+        if ! self.inner().visit_estr_slice() { return false; }\n         self.bump_past::<&'static str>();\n         true\n     }\n@@ -197,42 +204,42 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n                         sz: uint,\n                         align: uint) -> bool {\n         self.align(align);\n-        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n+        if ! self.inner().visit_estr_fixed(n, sz, align) { return false; }\n         self.bump(sz);\n         true\n     }\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@u8>();\n-        if ! self.inner.visit_box(mtbl, inner) { return false; }\n+        if ! self.inner().visit_box(mtbl, inner) { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n     fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n+        if ! self.inner().visit_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n     fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n+        if ! self.inner().visit_uniq_managed(mtbl, inner) { return false; }\n         self.bump_past::<~u8>();\n         true\n     }\n \n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n-        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n+        if ! self.inner().visit_ptr(mtbl, inner) { return false; }\n         self.bump_past::<*u8>();\n         true\n     }\n \n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static u8>();\n-        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n+        if ! self.inner().visit_rptr(mtbl, inner) { return false; }\n         self.bump_past::<&'static u8>();\n         true\n     }\n@@ -243,49 +250,49 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n         // or else possibly we could have some weird interface wherein we\n         // read-off a word from inner's pointers, but the read-word has to\n         // always be the same in all sub-pointers? Dubious.\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        if ! self.inner().visit_vec(mtbl, inner) { return false; }\n         true\n     }\n \n     fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n+        if ! self.inner().visit_vec(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<@[u8]>();\n-        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n+        if ! self.inner().visit_evec_box(mtbl, inner) { return false; }\n         self.bump_past::<@[u8]>();\n         true\n     }\n \n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[u8]>();\n-        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n+        if ! self.inner().visit_evec_uniq(mtbl, inner) { return false; }\n         self.bump_past::<~[u8]>();\n         true\n     }\n \n     fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<~[@u8]>();\n-        if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n+        if ! self.inner().visit_evec_uniq_managed(mtbl, inner) { return false; }\n         self.bump_past::<~[@u8]>();\n         true\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n-        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n+        if ! self.inner().visit_evec_slice(mtbl, inner) { return false; }\n         self.bump_past::<&'static [u8]>();\n         true\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool {\n         self.align(align);\n-        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n+        if ! self.inner().visit_evec_fixed(n, sz, align, mtbl, inner) {\n             return false;\n         }\n         self.bump(sz);\n@@ -294,83 +301,83 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n \n     fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n-        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n+        if ! self.inner().visit_enter_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n     fn visit_rec_field(&mut self, i: uint, name: &str,\n                        mtbl: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_rec_field(i, name, mtbl, inner) { return false; }\n+        if ! self.inner().visit_rec_field(i, name, mtbl, inner) { return false; }\n         true\n     }\n \n     fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n+        if ! self.inner().visit_leave_rec(n_fields, sz, align) { return false; }\n         true\n     }\n \n     fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n                          align: uint) -> bool {\n         self.align(align);\n-        if ! self.inner.visit_enter_class(name, named_fields, n_fields, sz, align) {\n+        if ! self.inner().visit_enter_class(name, named_fields, n_fields, sz, align) {\n             return false;\n         }\n         true\n     }\n \n     fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n                          mtbl: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_class_field(i, name, named, mtbl, inner) {\n+        if ! self.inner().visit_class_field(i, name, named, mtbl, inner) {\n             return false;\n         }\n         true\n     }\n \n     fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n                          align: uint) -> bool {\n-        if ! self.inner.visit_leave_class(name, named_fields, n_fields, sz, align) {\n+        if ! self.inner().visit_leave_class(name, named_fields, n_fields, sz, align) {\n             return false;\n         }\n         true\n     }\n \n     fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n         self.align(align);\n-        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n+        if ! self.inner().visit_enter_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n     fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_tup_field(i, inner) { return false; }\n+        if ! self.inner().visit_tup_field(i, inner) { return false; }\n         true\n     }\n \n     fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n+        if ! self.inner().visit_leave_tup(n_fields, sz, align) { return false; }\n         true\n     }\n \n     fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n+        if ! self.inner().visit_enter_fn(purity, proto, n_inputs, retstyle) {\n             return false\n         }\n         true\n     }\n \n     fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n+        if ! self.inner().visit_fn_input(i, mode, inner) { return false; }\n         true\n     }\n \n     fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n+        if ! self.inner().visit_fn_output(retstyle, variadic, inner) { return false; }\n         true\n     }\n \n     fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n                       n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n+        if ! self.inner().visit_leave_fn(purity, proto, n_inputs, retstyle) {\n             return false;\n         }\n         true\n@@ -381,31 +388,31 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n                         sz: uint, align: uint)\n                      -> bool {\n         self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, get_disr, sz, align) { return false; }\n+        if ! self.inner().visit_enter_enum(n_variants, get_disr, sz, align) { return false; }\n         true\n     }\n \n     fn visit_enter_enum_variant(&mut self, variant: uint,\n                                 disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n-        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n+        if ! self.inner().visit_enter_enum_variant(variant, disr_val,\n                                                  n_fields, name) {\n             return false;\n         }\n         true\n     }\n \n     fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n+        if ! self.inner().visit_enum_variant_field(i, offset, inner) { return false; }\n         true\n     }\n \n     fn visit_leave_enum_variant(&mut self, variant: uint,\n                                 disr_val: Disr,\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n-        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n+        if ! self.inner().visit_leave_enum_variant(variant, disr_val,\n                                                  n_fields, name) {\n             return false;\n         }\n@@ -416,44 +423,44 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n                         get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n                         sz: uint, align: uint)\n                      -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) { return false; }\n+        if ! self.inner().visit_leave_enum(n_variants, get_disr, sz, align) { return false; }\n         true\n     }\n \n     fn visit_trait(&mut self, name: &str) -> bool {\n         self.align_to::<@TyVisitor>();\n-        if ! self.inner.visit_trait(name) { return false; }\n+        if ! self.inner().visit_trait(name) { return false; }\n         self.bump_past::<@TyVisitor>();\n         true\n     }\n \n     fn visit_param(&mut self, i: uint) -> bool {\n-        if ! self.inner.visit_param(i) { return false; }\n+        if ! self.inner().visit_param(i) { return false; }\n         true\n     }\n \n     fn visit_self(&mut self) -> bool {\n         self.align_to::<&'static u8>();\n-        if ! self.inner.visit_self() { return false; }\n+        if ! self.inner().visit_self() { return false; }\n         self.align_to::<&'static u8>();\n         true\n     }\n \n     fn visit_type(&mut self) -> bool {\n-        if ! self.inner.visit_type() { return false; }\n+        if ! self.inner().visit_type() { return false; }\n         true\n     }\n \n     fn visit_opaque_box(&mut self) -> bool {\n         self.align_to::<@u8>();\n-        if ! self.inner.visit_opaque_box() { return false; }\n+        if ! self.inner().visit_opaque_box() { return false; }\n         self.bump_past::<@u8>();\n         true\n     }\n \n     fn visit_closure_ptr(&mut self, ck: uint) -> bool {\n         self.align_to::<(uint,uint)>();\n-        if ! self.inner.visit_closure_ptr(ck) { return false; }\n+        if ! self.inner().visit_closure_ptr(ck) { return false; }\n         self.bump_past::<(uint,uint)>();\n         true\n     }\n@@ -471,13 +478,15 @@ struct Stuff {\n impl my_visitor {\n     pub fn get<T:Clone>(&mut self, f: |T|) {\n         unsafe {\n-            f((*((**self).get().ptr1 as *T)).clone());\n+            let my_visitor(s) = *self;\n+            f((*((*s).get().ptr1 as *T)).clone());\n         }\n     }\n \n     pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n         unsafe {\n-            let u = my_visitor(**self);\n+            let my_visitor(s) = *self;\n+            let u = my_visitor(s);\n             let mut v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});\n             visit_tydesc(inner, &mut v as &mut TyVisitor);\n             true\n@@ -489,7 +498,8 @@ struct Inner<V> { inner: V }\n \n impl movable_ptr for my_visitor {\n     fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n-        let mut this = self.borrow_mut();\n+        let my_visitor(s) = *self;\n+        let mut this = s.borrow_mut();\n         this.get().ptr1 = adjustment(this.get().ptr1);\n         this.get().ptr2 = adjustment(this.get().ptr2);\n     }\n@@ -501,14 +511,16 @@ impl TyVisitor for my_visitor {\n     fn visit_nil(&mut self) -> bool { true }\n     fn visit_bool(&mut self) -> bool {\n         self.get::<bool>(|b| {\n-            let mut this = self.borrow_mut();\n+            let my_visitor(s) = *self;\n+            let mut this = s.borrow_mut();\n             this.get().vals.push(b.to_str());\n         });\n         true\n     }\n     fn visit_int(&mut self) -> bool {\n         self.get::<int>(|i| {\n-            let mut this = self.borrow_mut();\n+            let my_visitor(s) = *self;\n+            let mut this = s.borrow_mut();\n             this.get().vals.push(i.to_str());\n         });\n         true\n@@ -640,7 +652,8 @@ pub fn main() {\n                (*td).size, (*td).align);\n         visit_tydesc(td, &mut v as &mut TyVisitor);\n \n-        let mut ub = u.borrow_mut();\n+        let my_visitor(m) = u;\n+        let mut ub = m.borrow_mut();\n         let r = ub.get().vals.clone();\n         for s in r.iter() {\n             println!(\"val: {}\", *s);"}, {"sha": "8d6f08583dbe431878c0899072db7a35e3877687", "filename": "src/test/run-pass/static-vec-autoref.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fstatic-vec-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fstatic-vec-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-vec-autoref.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct T(&'static [int]);\n-\n-static A: T = T(&'static [5, 4, 3]);\n-static B: T = T(&[5, 4, 3]);\n-static C: T = T([5, 4, 3]);\n-\n-pub fn main() {\n-    assert_eq!(A[0], 5);\n-    assert_eq!(B[1], 4);\n-    assert_eq!(C[2], 3);\n-}"}, {"sha": "b1de9880d4b4f898bcc8357c985b6a40b267e341", "filename": "src/test/run-pass/struct-deref.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fstruct-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e/src%2Ftest%2Frun-pass%2Fstruct-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-deref.rs?ref=18cef3fad47f90c6c5ec1f2ad4dbc12b86b7ee7e", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Foo(int);\n-\n-pub fn main() {\n-    let x: Foo = Foo(2);\n-    assert_eq!(*x, 2);\n-}"}, {"sha": "339afb47fa6dddb8e1d5ca19078aa49c5cc9df12", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b1862a82f04f8f5bcb197715d2ff506c6cdecc3/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=3b1862a82f04f8f5bcb197715d2ff506c6cdecc3", "patch": "@@ -40,7 +40,8 @@ impl to_str for int {\n \n impl to_str for Tree {\n     fn to_str_(&self) -> ~str {\n-        let this = self.borrow();\n+        let Tree(t) = *self;\n+        let this = t.borrow();\n         let (l, r) = (this.get().left, this.get().right);\n         let val = &this.get().val;\n         format!(\"[{}, {}, {}]\", val.to_str_(), l.to_str_(), r.to_str_())\n@@ -61,7 +62,8 @@ pub fn main() {\n     assert!(foo(t2) == expected);\n \n     {\n-        let mut t1 = t1.borrow_mut();\n+        let Tree(t1_) = t1;\n+        let mut t1 = t1_.borrow_mut();\n         t1.get().left = Some(t2); // create cycle\n     }\n }"}]}