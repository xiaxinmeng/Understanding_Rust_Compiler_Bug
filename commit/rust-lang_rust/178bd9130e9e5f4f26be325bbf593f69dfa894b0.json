{"sha": "178bd9130e9e5f4f26be325bbf593f69dfa894b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OGJkOTEzMGU5ZTVmNGYyNmJlMzI1YmJmNTkzZjY5ZGZhODk0YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-13T09:47:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-13T09:47:07Z"}, "message": "Auto merge of #82878 - sexxi-goose:repr_packed, r=nikomatsakis\n\n2229: Handle capturing a reference into a repr packed struct\n\nRFC 1240 states that it is unsafe to capture references into a\npacked-struct. This PR ensures that when a closure captures a precise\npath, we aren't violating this safety constraint.\n\nTo acheive so we restrict the capture precision to the struct itself.\n\nAn interesting edge case where we decided to restrict precision:\n```rust\nstruct Foo(String);\n\nlet foo: Foo;\nlet c = || {\n    println!(\"{}\", foo.0);\n    let x = foo.0;\n}\n```\n\nGiven how closures get desugared today, foo.0 will be moved into the\nclosure, making the `println!`, safe. However this can be very subtle\nand also will be unsafe if the closure gets inline.\n\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/33\n\nr? `@nikomatsakis`", "tree": {"sha": "a91396b3b6d891ac8628b015876d0cd71c5233f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a91396b3b6d891ac8628b015876d0cd71c5233f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/178bd9130e9e5f4f26be325bbf593f69dfa894b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/178bd9130e9e5f4f26be325bbf593f69dfa894b0", "html_url": "https://github.com/rust-lang/rust/commit/178bd9130e9e5f4f26be325bbf593f69dfa894b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/178bd9130e9e5f4f26be325bbf593f69dfa894b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec487bf3cfc9ce386da25169509fae8f2b4d4eec", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec487bf3cfc9ce386da25169509fae8f2b4d4eec", "html_url": "https://github.com/rust-lang/rust/commit/ec487bf3cfc9ce386da25169509fae8f2b4d4eec"}, {"sha": "612a9b2f95fc44dd140a3545dc303058d98100a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/612a9b2f95fc44dd140a3545dc303058d98100a9", "html_url": "https://github.com/rust-lang/rust/commit/612a9b2f95fc44dd140a3545dc303058d98100a9"}], "stats": {"total": 387, "additions": 381, "deletions": 6}, "files": [{"sha": "254f12b95630495a5b9d39994020a3dc1a7db73c", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/178bd9130e9e5f4f26be325bbf593f69dfa894b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178bd9130e9e5f4f26be325bbf593f69dfa894b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=178bd9130e9e5f4f26be325bbf593f69dfa894b0", "patch": "@@ -1053,6 +1053,52 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n+/// Truncate the capture so that the place being borrowed is in accordance with RFC 1240,\n+/// which states that it's unsafe to take a reference into a struct marked `repr(packed)`.\n+fn restrict_repr_packed_field_ref_capture<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    place: &Place<'tcx>,\n+) -> Place<'tcx> {\n+    let pos = place.projections.iter().enumerate().position(|(i, p)| {\n+        let ty = place.ty_before_projection(i);\n+\n+        // Return true for fields of packed structs, unless those fields have alignment 1.\n+        match p.kind {\n+            ProjectionKind::Field(..) => match ty.kind() {\n+                ty::Adt(def, _) if def.repr.packed() => {\n+                    match tcx.layout_raw(param_env.and(p.ty)) {\n+                        Ok(layout) if layout.align.abi.bytes() == 1 => {\n+                            // if the alignment is 1, the type can't be further\n+                            // disaligned.\n+                            debug!(\n+                                \"restrict_repr_packed_field_ref_capture: ({:?}) - align = 1\",\n+                                place\n+                            );\n+                            false\n+                        }\n+                        _ => {\n+                            debug!(\"restrict_repr_packed_field_ref_capture: ({:?}) - true\", place);\n+                            true\n+                        }\n+                    }\n+                }\n+\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    });\n+\n+    let mut place = place.clone();\n+\n+    if let Some(pos) = pos {\n+        place.projections.truncate(pos);\n+    }\n+\n+    place\n+}\n+\n struct InferBorrowKind<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n@@ -1391,8 +1437,15 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, bk\n         );\n \n+        let place = restrict_repr_packed_field_ref_capture(\n+            self.fcx.tcx,\n+            self.fcx.param_env,\n+            &place_with_id.place,\n+        );\n+        let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n+\n         if !self.capture_information.contains_key(&place_with_id.place) {\n-            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n+            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n \n         match bk {\n@@ -1409,11 +1462,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n         debug!(\"mutate(assignee_place={:?}, diag_expr_id={:?})\", assignee_place, diag_expr_id);\n \n-        if !self.capture_information.contains_key(&assignee_place.place) {\n-            self.init_capture_info_for_place(assignee_place, diag_expr_id);\n-        }\n-\n-        self.adjust_upvar_borrow_kind_for_mut(assignee_place, diag_expr_id);\n+        self.borrow(assignee_place, diag_expr_id, ty::BorrowKind::MutBorrow);\n     }\n }\n "}, {"sha": "6fce2951505822b4adc69bc2a205440d287b2d00", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.rs?ref=178bd9130e9e5f4f26be325bbf593f69dfa894b0", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+// Given how the closure desugaring is implemented (at least at the time of writing this test),\n+// we don't need to truncate the captured path to a reference into a packed-struct if the field\n+// being referenced will be moved into the closure, since it's safe to move out a field from a\n+// packed-struct.\n+//\n+// However to avoid surprises for the user, or issues when the closure is\n+// inlined we will truncate the capture to access just the struct regardless of if the field\n+// might get moved into the closure.\n+//\n+// It is possible for someone to try writing the code that relies on the desugaring to access a ref\n+// into a packed-struct without explicity using unsafe. Here we test that the compiler warns the\n+// user that such an access is still unsafe.\n+fn test_missing_unsafe_warning_on_repr_packed() {\n+    #[repr(packed)]\n+    struct Foo { x: String }\n+\n+    let foo = Foo { x: String::new() };\n+\n+    let c = || {\n+        println!(\"{}\", foo.x);\n+        //~^ WARNING: borrow of packed field is unsafe and requires unsafe function or block\n+        //~| WARNING: this was previously accepted by the compiler but is being phased out\n+        let _z = foo.x;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_missing_unsafe_warning_on_repr_packed();\n+}"}, {"sha": "440b2c54c0a010a3e155811b4fcad29568a16629", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/repr_packed.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Frepr_packed.stderr?ref=178bd9130e9e5f4f26be325bbf593f69dfa894b0", "patch": "@@ -0,0 +1,22 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/repr_packed.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+  --> $DIR/repr_packed.rs:25:24\n+   |\n+LL |         println!(\"{}\", foo.x);\n+   |                        ^^^^^\n+   |\n+   = note: `#[warn(safe_packed_borrows)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "2b9ef2a76bba74cc739eae4c95443262d1af82b1", "filename": "src/test/ui/closures/2229_closure_analysis/repr_packed.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.rs?ref=178bd9130e9e5f4f26be325bbf593f69dfa894b0", "patch": "@@ -0,0 +1,103 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+#![feature(rustc_attrs)]\n+\n+// `u8` aligned at a byte and are unaffected by repr(packed).\n+// Therefore we can precisely (and safely) capture references to both the fields.\n+fn test_alignment_not_affected() {\n+    #[repr(packed)]\n+    struct Foo { x: u8, y: u8 }\n+\n+    let mut foo = Foo { x: 0, y: 0 };\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let z1: &u8 = &foo.x;\n+        //~^ NOTE: Capturing foo[(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture foo[(0, 0)] -> ImmBorrow\n+        let z2: &mut u8 = &mut foo.y;\n+        //~^ NOTE: Capturing foo[(1, 0)] -> MutBorrow\n+        //~| NOTE: Min Capture foo[(1, 0)] -> MutBorrow\n+\n+        *z2 = 42;\n+\n+        println!(\"({}, {})\", z1, z2);\n+    };\n+\n+    c();\n+}\n+\n+// `String`, `u16` are not aligned at a one byte boundry and are thus affected by repr(packed).\n+//\n+// Here we test that the closure doesn't capture a reference point to `foo.x` but\n+// rather capture `foo` entirely.\n+fn test_alignment_affected() {\n+    #[repr(packed)]\n+    struct Foo { x: String, y: u16 }\n+\n+    let mut foo = Foo { x: String::new(), y: 0 };\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let z1: &String = &foo.x;\n+        let z2: &mut u16 = &mut foo.y;\n+        //~^ NOTE: Capturing foo[] -> MutBorrow\n+        //~| NOTE: Min Capture foo[] -> MutBorrow\n+\n+\n+        *z2 = 42;\n+\n+        println!(\"({}, {})\", z1, z2);\n+    };\n+\n+    c();\n+}\n+\n+// Given how the closure desugaring is implemented (at least at the time of writing this test),\n+// we don't need to truncate the captured path to a reference into a packed-struct if the field\n+// being referenced will be moved into the closure, since it's safe to move out a field from a\n+// packed-struct.\n+//\n+// However to avoid surprises for the user, or issues when the closure is\n+// inlined we will truncate the capture to access just the struct regardless of if the field\n+// might get moved into the closure.\n+fn test_truncation_when_ref_and_move() {\n+    #[repr(packed)]\n+    struct Foo { x: String }\n+\n+    let mut foo = Foo { x: String::new() };\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{}\", foo.x);\n+        //~^ NOTE: Capturing foo[] -> ImmBorrow\n+        //~| NOTE: Min Capture foo[] -> ByValue\n+        //~| NOTE: foo[] used here\n+        let _z = foo.x;\n+        //~^ NOTE: Capturing foo[(0, 0)] -> ByValue\n+        //~| NOTE: foo[] captured as ByValue here\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    test_truncation_when_ref_and_move();\n+    test_alignment_affected();\n+    test_alignment_not_affected();\n+}"}, {"sha": "0517dd04b6f44696a483ff4cd1f4f4ad7bed3a50", "filename": "src/test/ui/closures/2229_closure_analysis/repr_packed.stderr", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/178bd9130e9e5f4f26be325bbf593f69dfa894b0/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frepr_packed.stderr?ref=178bd9130e9e5f4f26be325bbf593f69dfa894b0", "patch": "@@ -0,0 +1,165 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/repr_packed.rs:16:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/repr_packed.rs:47:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/repr_packed.rs:81:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/repr_packed.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/repr_packed.rs:19:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let z1: &u8 = &foo.x;\n+...  |\n+LL | |         println!(\"({}, {})\", z1, z2);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing foo[(0, 0)] -> ImmBorrow\n+  --> $DIR/repr_packed.rs:22:24\n+   |\n+LL |         let z1: &u8 = &foo.x;\n+   |                        ^^^^^\n+note: Capturing foo[(1, 0)] -> MutBorrow\n+  --> $DIR/repr_packed.rs:25:32\n+   |\n+LL |         let z2: &mut u8 = &mut foo.y;\n+   |                                ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/repr_packed.rs:19:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let z1: &u8 = &foo.x;\n+...  |\n+LL | |         println!(\"({}, {})\", z1, z2);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture foo[(0, 0)] -> ImmBorrow\n+  --> $DIR/repr_packed.rs:22:24\n+   |\n+LL |         let z1: &u8 = &foo.x;\n+   |                        ^^^^^\n+note: Min Capture foo[(1, 0)] -> MutBorrow\n+  --> $DIR/repr_packed.rs:25:32\n+   |\n+LL |         let z2: &mut u8 = &mut foo.y;\n+   |                                ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/repr_packed.rs:50:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let z1: &String = &foo.x;\n+...  |\n+LL | |         println!(\"({}, {})\", z1, z2);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing foo[] -> MutBorrow\n+  --> $DIR/repr_packed.rs:54:33\n+   |\n+LL |         let z2: &mut u16 = &mut foo.y;\n+   |                                 ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/repr_packed.rs:50:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let z1: &String = &foo.x;\n+...  |\n+LL | |         println!(\"({}, {})\", z1, z2);\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture foo[] -> MutBorrow\n+  --> $DIR/repr_packed.rs:54:33\n+   |\n+LL |         let z2: &mut u16 = &mut foo.y;\n+   |                                 ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/repr_packed.rs:84:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", foo.x);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing foo[] -> ImmBorrow\n+  --> $DIR/repr_packed.rs:87:24\n+   |\n+LL |         println!(\"{}\", foo.x);\n+   |                        ^^^^^\n+note: Capturing foo[(0, 0)] -> ByValue\n+  --> $DIR/repr_packed.rs:91:18\n+   |\n+LL |         let _z = foo.x;\n+   |                  ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/repr_packed.rs:84:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         println!(\"{}\", foo.x);\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture foo[] -> ByValue\n+  --> $DIR/repr_packed.rs:87:24\n+   |\n+LL |         println!(\"{}\", foo.x);\n+   |                        ^^^^^ foo[] used here\n+...\n+LL |         let _z = foo.x;\n+   |                  ^^^^^ foo[] captured as ByValue here\n+\n+error: aborting due to 9 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}]}