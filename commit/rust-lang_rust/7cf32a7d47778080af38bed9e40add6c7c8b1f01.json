{"sha": "7cf32a7d47778080af38bed9e40add6c7c8b1f01", "node_id": "C_kwDOAAsO6NoAKDdjZjMyYTdkNDc3NzgwODBhZjM4YmVkOWU0MGFkZDZjN2M4YjFmMDE", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-10-19T01:24:16Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-20T20:19:06Z"}, "message": "code reuse for sync ids", "tree": {"sha": "0847d1a17b3d4cf7e367d07f8c14f88bd979cbb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0847d1a17b3d4cf7e367d07f8c14f88bd979cbb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cf32a7d47778080af38bed9e40add6c7c8b1f01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf32a7d47778080af38bed9e40add6c7c8b1f01", "html_url": "https://github.com/rust-lang/rust/commit/7cf32a7d47778080af38bed9e40add6c7c8b1f01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cf32a7d47778080af38bed9e40add6c7c8b1f01/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ca6b175b49410259303827c2101c0a251806830", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ca6b175b49410259303827c2101c0a251806830", "html_url": "https://github.com/rust-lang/rust/commit/7ca6b175b49410259303827c2101c0a251806830"}], "stats": {"total": 272, "additions": 110, "deletions": 162}, "files": [{"sha": "2ec852b413e8ccd47fce968a4c08df2f11a4a6ee", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=7cf32a7d47778080af38bed9e40add6c7c8b1f01", "patch": "@@ -11,6 +11,11 @@ use super::thread::MachineCallback;\n use super::vector_clock::VClock;\n use crate::*;\n \n+pub trait SyncId {\n+    fn from_u32(id: u32) -> Self;\n+    fn to_u32_scalar(&self) -> Scalar<Provenance>;\n+}\n+\n /// We cannot use the `newtype_index!` macro because we have to use 0 as a\n /// sentinel value meaning that the identifier is not assigned. This is because\n /// the pthreads static initializers initialize memory with zeros (see the\n@@ -22,11 +27,14 @@ macro_rules! declare_id {\n         #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n         pub struct $name(NonZeroU32);\n \n-        impl $name {\n+        impl SyncId for $name {\n             // Panics if `id == 0`.\n-            pub fn from_u32(id: u32) -> Self {\n+            fn from_u32(id: u32) -> Self {\n                 Self(NonZeroU32::new(id).unwrap())\n             }\n+            fn to_u32_scalar(&self) -> Scalar<Provenance> {\n+                Scalar::from_u32(self.0.get())\n+            }\n         }\n \n         impl Idx for $name {\n@@ -166,7 +174,7 @@ impl<'mir, 'tcx> std::fmt::Debug for InitOnceWaiter<'mir, 'tcx> {\n     }\n }\n \n-#[derive(Default, Debug, Copy, Clone, PartialEq, Eq,)]\n+#[derive(Default, Debug, Copy, Clone, PartialEq, Eq)]\n /// The current status of a one time initialization.\n pub enum InitOnceStatus {\n     #[default]\n@@ -212,6 +220,37 @@ impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n // Private extension trait for local helper methods\n impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    #[inline]\n+    // Miri sync structures contain zero-initialized ids stored at some offset behind a pointer\n+    fn get_or_create_id<Id: SyncId>(\n+        &mut self,\n+        next_id: Id,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, Option<Id>> {\n+        let this = self.eval_context_mut();\n+        let value_place =\n+            this.deref_operand_and_offset(lock_op, offset, this.machine.layouts.u32)?;\n+\n+        let (old, success) = this\n+            .atomic_compare_exchange_scalar(\n+                &value_place,\n+                &ImmTy::from_uint(0u32, this.machine.layouts.u32),\n+                next_id.to_u32_scalar(),\n+                AtomicRwOrd::Relaxed,\n+                AtomicReadOrd::Relaxed,\n+                false,\n+            )?\n+            .to_scalar_pair();\n+\n+        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n+            // Caller of the closure needs to allocate next_id\n+            None\n+        } else {\n+            Some(Id::from_u32(old.to_u32().expect(\"layout is u32\")))\n+        })\n+    }\n+\n     /// Take a reader out of the queue waiting for the lock.\n     /// Returns `true` if some thread got the rwlock.\n     #[inline]\n@@ -261,6 +300,48 @@ trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n // situations.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn mutex_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, MutexId> {\n+        let this = self.eval_context_mut();\n+        this.mutex_get_or_create(|ecx, next_id| Ok(ecx.get_or_create_id(next_id, lock_op, offset)?))\n+    }\n+\n+    fn rwlock_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, RwLockId> {\n+        let this = self.eval_context_mut();\n+        this.rwlock_get_or_create(\n+            |ecx, next_id| Ok(ecx.get_or_create_id(next_id, lock_op, offset)?),\n+        )\n+    }\n+\n+    fn condvar_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, CondvarId> {\n+        let this = self.eval_context_mut();\n+        this.condvar_get_or_create(|ecx, next_id| {\n+            Ok(ecx.get_or_create_id(next_id, lock_op, offset)?)\n+        })\n+    }\n+\n+    fn init_once_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        offset: u64,\n+    ) -> InterpResult<'tcx, InitOnceId> {\n+        let this = self.eval_context_mut();\n+        this.init_once_get_or_create(|ecx, next_id| {\n+            Ok(ecx.get_or_create_id(next_id, lock_op, offset)?)\n+        })\n+    }\n+\n     #[inline]\n     /// Create state for a new mutex.\n     fn mutex_create(&mut self) -> MutexId {"}, {"sha": "5c4094378ac3d8c407be0d67201db344a9f1d85c", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=7cf32a7d47778080af38bed9e40add6c7c8b1f01", "patch": "@@ -87,7 +87,7 @@ pub use crate::concurrency::{\n         AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n         EvalContextExt as DataRaceEvalContextExt,\n     },\n-    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, InitOnceId, MutexId, RwLockId},\n+    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, InitOnceId, MutexId, RwLockId, SyncId},\n     thread::{\n         EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n         ThreadState, Time,"}, {"sha": "7857fa4bcc992a962604068f736590e9b730bf2c", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 17, "deletions": 98, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=7cf32a7d47778080af38bed9e40add6c7c8b1f01", "patch": "@@ -108,33 +108,6 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n     )\n }\n \n-fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, MutexId> {\n-    let value_place = ecx.deref_operand_and_offset(mutex_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.mutex_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(MutexId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n \n // Our chosen memory layout for the emulated rwlock (does not have to match the platform layout!):\n@@ -149,33 +122,6 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n-fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    rwlock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, RwLockId> {\n-    let value_place = ecx.deref_operand_and_offset(rwlock_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.rwlock_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n // pthread_condattr_t\n \n // Our chosen memory layout for emulation (does not have to match the platform layout!):\n@@ -232,33 +178,6 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n     )\n }\n \n-fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, CondvarId> {\n-    let value_place = ecx.deref_operand_and_offset(cond_op, 4, ecx.machine.layouts.u32)?;\n-\n-    ecx.condvar_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(CondvarId::from_u32(old.to_u32().expect(\"layout is u32\")))\n-        })\n-    })\n-}\n-\n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n@@ -435,7 +354,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -475,7 +394,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -511,7 +430,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread) {\n@@ -545,7 +464,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.mutex_get_or_create_id(mutex_op, 4)?;\n \n         if this.mutex_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked mutex\");\n@@ -568,7 +487,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -586,7 +505,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -603,7 +522,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -633,7 +552,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -650,7 +569,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         #[allow(clippy::if_same_then_else)]\n@@ -669,7 +588,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = rwlock_get_or_create_id(this, rwlock_op)?;\n+        let id = this.rwlock_get_or_create_id(rwlock_op, 4)?;\n \n         if this.rwlock_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked rwlock\");\n@@ -772,7 +691,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n         }\n@@ -785,7 +704,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         cond_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n \n         while let Some((thread, mutex)) = this.condvar_signal(id) {\n             post_cond_signal(this, thread, mutex)?;\n@@ -801,8 +720,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n-        let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n@@ -822,8 +741,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         this.check_no_isolation(\"`pthread_cond_timedwait`\")?;\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n-        let mutex_id = mutex_get_or_create_id(this, mutex_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n+        let mutex_id = this.mutex_get_or_create_id(mutex_op, 4)?;\n         let active_thread = this.get_active_thread();\n \n         // Extract the timeout.\n@@ -899,7 +818,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = cond_get_or_create_id(this, cond_op)?;\n+        let id = this.condvar_get_or_create_id(cond_op, 4)?;\n         if this.condvar_is_awaited(id) {\n             throw_ub_format!(\"destroying an awaited conditional variable\");\n         }"}, {"sha": "3eca86d38604c59405e31ff45a5b8e2c0d4e9fdc", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 8, "deletions": 60, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf32a7d47778080af38bed9e40add6c7c8b1f01/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=7cf32a7d47778080af38bed9e40add6c7c8b1f01", "patch": "@@ -2,65 +2,13 @@ use crate::concurrency::sync::InitOnceStatus;\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n-impl<'mir, 'tcx> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n-trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    // These synchronization structures are pointer-sized pieces of data, initialized to 0.\n-    // We use the first 4 bytes to store the id.\n-    fn get_or_create_id(\n-        &mut self,\n-        next_id: Scalar<Provenance>,\n-        lock_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, Option<u32>> {\n-        let this = self.eval_context_mut();\n-        let value_place = this.deref_operand_and_offset(lock_op, 0, this.machine.layouts.u32)?;\n-\n-        let (old, success) = this\n-            .atomic_compare_exchange_scalar(\n-                &value_place,\n-                &ImmTy::from_uint(0u32, this.machine.layouts.u32),\n-                next_id,\n-                AtomicRwOrd::Relaxed,\n-                AtomicReadOrd::Relaxed,\n-                false,\n-            )?\n-            .to_scalar_pair();\n-\n-        Ok(if success.to_bool().expect(\"compare_exchange's second return value is a bool\") {\n-            // Caller of the closure needs to allocate next_id\n-            None\n-        } else {\n-            Some(old.to_u32().expect(\"layout is u32\"))\n-        })\n-    }\n-\n-    fn srwlock_get_or_create_id(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, RwLockId> {\n-        let this = self.eval_context_mut();\n-        this.rwlock_get_or_create(|ecx, next_id| {\n-            Ok(ecx.get_or_create_id(next_id.to_u32_scalar(), lock_op)?.map(RwLockId::from_u32))\n-        })\n-    }\n-\n-    fn init_once_get_or_create_id(\n-        &mut self,\n-        lock_op: &OpTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, InitOnceId> {\n-        let this = self.eval_context_mut();\n-        this.init_once_get_or_create(|ecx, next_id| {\n-            Ok(ecx.get_or_create_id(next_id.to_u32_scalar(), lock_op)?.map(InitOnceId::from_u32))\n-        })\n-    }\n-}\n-\n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n #[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.srwlock_get_or_create_id(lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -84,7 +32,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = this.srwlock_get_or_create_id(lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -98,7 +46,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.srwlock_get_or_create_id(lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_writer_unlock(id, active_thread) {\n@@ -113,7 +61,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.srwlock_get_or_create_id(lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -130,7 +78,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = this.srwlock_get_or_create_id(lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -143,7 +91,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = this.srwlock_get_or_create_id(lock_op)?;\n+        let id = this.rwlock_get_or_create_id(lock_op, 0)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_reader_unlock(id, active_thread) {\n@@ -166,7 +114,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n \n-        let id = this.init_once_get_or_create_id(init_once_op)?;\n+        let id = this.init_once_get_or_create_id(init_once_op, 0)?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;\n         let pending_place = this.deref_operand(pending_op)?.into();\n         let context = this.read_pointer(context_op)?;\n@@ -232,7 +180,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let id = this.init_once_get_or_create_id(init_once_op)?;\n+        let id = this.init_once_get_or_create_id(init_once_op, 0)?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;\n         let context = this.read_pointer(context_op)?;\n "}]}