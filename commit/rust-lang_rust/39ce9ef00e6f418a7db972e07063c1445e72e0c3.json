{"sha": "39ce9ef00e6f418a7db972e07063c1445e72e0c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5Y2U5ZWYwMGU2ZjQxOGE3ZGI5NzJlMDcwNjNjMTQ0NWU3MmUwYzM=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2018-07-13T19:38:49Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-14T04:06:50Z"}, "message": "#[feature(uniform_paths)]: allow `use x::y;` to resolve through `self::x`, not just `::x`.", "tree": {"sha": "c443718e1f99883959dcc87786c02fc6a15d28e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c443718e1f99883959dcc87786c02fc6a15d28e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ce9ef00e6f418a7db972e07063c1445e72e0c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ce9ef00e6f418a7db972e07063c1445e72e0c3", "html_url": "https://github.com/rust-lang/rust/commit/39ce9ef00e6f418a7db972e07063c1445e72e0c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ce9ef00e6f418a7db972e07063c1445e72e0c3/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9b1176eefb84686c76dde1b53a47ee0eb765d89", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b1176eefb84686c76dde1b53a47ee0eb765d89", "html_url": "https://github.com/rust-lang/rust/commit/f9b1176eefb84686c76dde1b53a47ee0eb765d89"}], "stats": {"total": 374, "additions": 367, "deletions": 7}, "files": [{"sha": "a4144d705b29e32b5ec81d5d35064ac03ed0353c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=39ce9ef00e6f418a7db972e07063c1445e72e0c3", "patch": "@@ -142,8 +142,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if source.name == keywords::SelfValue.name() {\n                         type_ns_only = true;\n \n-                        let last_segment = *module_path.last().unwrap();\n-                        if last_segment.name == keywords::CrateRoot.name() {\n+                        let empty_prefix = module_path.last().map_or(true, |ident| {\n+                            ident.name == keywords::CrateRoot.name()\n+                        });\n+                        if empty_prefix {\n                             resolve_error(\n                                 self,\n                                 use_tree.span,\n@@ -154,10 +156,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         }\n \n                         // Replace `use foo::self;` with `use foo;`\n-                        let _ = module_path.pop();\n-                        source = last_segment;\n+                        source = module_path.pop().unwrap();\n                         if rename.is_none() {\n-                            ident = last_segment;\n+                            ident = source;\n                         }\n                     }\n                 } else {\n@@ -169,7 +170,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n \n                     // Disallow `use $crate;`\n-                    if source.name == keywords::DollarCrate.name() && path.segments.len() == 1 {\n+                    if source.name == keywords::DollarCrate.name() && module_path.is_empty() {\n                         let crate_root = self.resolve_crate_root(source);\n                         let crate_name = match crate_root.kind {\n                             ModuleKind::Def(_, name) => name,\n@@ -179,6 +180,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         // in `source` breaks `src/test/compile-fail/import-crate-var.rs`,\n                         // while the current crate doesn't have a valid `crate_name`.\n                         if crate_name != keywords::Invalid.name() {\n+                            // `crate_name` should not be interpreted as relative.\n+                            module_path.push(Ident {\n+                                name: keywords::CrateRoot.name(),\n+                                span: source.span,\n+                            });\n                             source.name = crate_name;\n                         }\n                         if rename.is_none() {\n@@ -283,9 +289,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n+                let uniform_paths =\n+                    self.session.rust_2018() &&\n+                    self.session.features_untracked().uniform_paths;\n                 // Imports are resolved as global by default, add starting root segment.\n+                let root = if !uniform_paths {\n+                    use_tree.prefix.make_root()\n+                } else {\n+                    // Except when `#![feature(uniform_paths)]` is on.\n+                    None\n+                };\n                 let prefix = ast::Path {\n-                    segments: use_tree.prefix.make_root().into_iter().collect(),\n+                    segments: root.into_iter().collect(),\n                     span: use_tree.span,\n                 };\n "}, {"sha": "7209291aebdb5ce86bf588f5e3a3d7668ca7e472", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=39ce9ef00e6f418a7db972e07063c1445e72e0c3", "patch": "@@ -144,6 +144,50 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n             ModuleOrUniformRoot::UniformRoot(root) => {\n+                // HACK(eddyb): `resolve_path` uses `keywords::Invalid` to indicate\n+                // paths of length 0, and currently these are relative `use` paths.\n+                let can_be_relative = !ident.is_path_segment_keyword() &&\n+                    root == keywords::Invalid.name();\n+                if can_be_relative {\n+                    // Relative paths should only get here if the feature-gate is on.\n+                    assert!(self.session.rust_2018() &&\n+                            self.session.features_untracked().uniform_paths);\n+\n+                    // Try first to resolve relatively.\n+                    let mut ctxt = ident.span.ctxt().modern();\n+                    let self_module = self.resolve_self(&mut ctxt, self.current_module);\n+\n+                    let binding = self.resolve_ident_in_module_unadjusted(\n+                        ModuleOrUniformRoot::Module(self_module),\n+                        ident,\n+                        ns,\n+                        restricted_shadowing,\n+                        record_used,\n+                        path_span,\n+                    );\n+\n+                    // FIXME(eddyb) This may give false negatives, specifically\n+                    // if a crate with the same name is found in `extern_prelude`,\n+                    // preventing the check below this one from returning `binding`\n+                    // in all cases.\n+                    //\n+                    // That is, if there's no crate with the same name, `binding`\n+                    // is always returned, which is the result of doing the exact\n+                    // same lookup of `ident`, in the `self` module.\n+                    // But when a crate does exist, it will get chosen even when\n+                    // macro expansion could result in a success from the lookup\n+                    // in the `self` module, later on.\n+                    if binding.is_ok() {\n+                        return binding;\n+                    }\n+\n+                    // Fall back to resolving to an external crate.\n+                    if !self.extern_prelude.contains(&ident.name) {\n+                        // ... unless the crate name is not in the `extern_prelude`.\n+                        return binding;\n+                    }\n+                }\n+\n                 let crate_root = if\n                     root != keywords::Extern.name() &&\n                     ("}, {"sha": "086fd58cffa9e1d5cb2d9244edd7fd4b933f600c", "filename": "src/test/run-pass/uniform-paths/basic-nested.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic-nested.rs?ref=39ce9ef00e6f418a7db972e07063c1445e72e0c3", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `basic.rs`, but nested in modules.\n+\n+mod foo {\n+    // Test that ambiguity errors are not emitted between `self::test` and\n+    // `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+    mod test {\n+        pub struct Foo(pub ());\n+    }\n+    pub use test::Foo;\n+\n+    // Test that qualified paths can refer to both the external crate and local item.\n+    mod std {\n+        pub struct io(pub ());\n+    }\n+    pub use ::std::io as std_io;\n+    pub use self::std::io as local_io;\n+}\n+\n+// Test that we can refer to the external crate unqualified\n+// (when there isn't a local item with the same name).\n+use std::io;\n+\n+mod bar {\n+    // Also test the unqualified external crate import in a nested module,\n+    // to show that the above import doesn't resolve through a local `std`\n+    // item, e.g. the automatically injected `extern crate std;`, which in\n+    // the Rust 2018 should no longer be visible through `crate::std`.\n+    pub use std::io;\n+}\n+\n+\n+fn main() {\n+    foo::Foo(());\n+    foo::std_io::stdout();\n+    foo::local_io(());\n+    io::stdout();\n+    bar::io::stdout();\n+}"}, {"sha": "59a0404e4c360b8588e44de1d44d4633bc4f70ea", "filename": "src/test/run-pass/uniform-paths/basic.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fbasic.rs?ref=39ce9ef00e6f418a7db972e07063c1445e72e0c3", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// Test that ambiguity errors are not emitted between `self::test` and\n+// `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+mod test {\n+    pub struct Foo(pub ());\n+}\n+use test::Foo;\n+\n+// Test that qualified paths can refer to both the external crate and local item.\n+mod std {\n+    pub struct io(pub ());\n+}\n+use ::std::io as std_io;\n+use self::std::io as local_io;\n+\n+fn main() {\n+    Foo(());\n+    std_io::stdout();\n+    local_io(());\n+}"}, {"sha": "9cf05cd956039235881b3c7d0164d4997bc9c26c", "filename": "src/test/run-pass/uniform-paths/macros-nested.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros-nested.rs?ref=39ce9ef00e6f418a7db972e07063c1445e72e0c3", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `macros.rs`, but nested in modules.\n+\n+mod foo {\n+    // Test that ambiguity errors are not emitted between `self::test` and\n+    // `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+    macro_rules! m1 {\n+        () => {\n+            mod test {\n+                pub struct Foo(pub ());\n+            }\n+        }\n+    }\n+    pub use test::Foo;\n+    m1!();\n+\n+    // Test that qualified paths can refer to both the external crate and local item.\n+    macro_rules! m2 {\n+        () => {\n+            mod std {\n+                pub struct io(pub ());\n+            }\n+        }\n+    }\n+    pub use ::std::io as std_io;\n+    pub use self::std::io as local_io;\n+    m2!();\n+}\n+\n+// Test that we can refer to the external crate unqualified\n+// (when there isn't a local item with the same name).\n+use std::io;\n+\n+mod bar {\n+    // Also test the unqualified external crate import in a nested module,\n+    // to show that the above import doesn't resolve through a local `std`\n+    // item, e.g. the automatically injected `extern crate std;`, which in\n+    // the Rust 2018 should no longer be visible through `crate::std`.\n+    pub use std::io;\n+}\n+\n+\n+fn main() {\n+    foo::Foo(());\n+    foo::std_io::stdout();\n+    foo::local_io(());\n+    io::stdout();\n+    bar::io::stdout();\n+}"}, {"sha": "ad74f5d0876bb94c3a713a03d37ec27003fad2a1", "filename": "src/test/run-pass/uniform-paths/macros.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fmacros.rs?ref=39ce9ef00e6f418a7db972e07063c1445e72e0c3", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `basic.rs`, but with macros defining local items.\n+\n+// Test that ambiguity errors are not emitted between `self::test` and\n+// `::test`, assuming the latter (crate) is not in `extern_prelude`.\n+macro_rules! m1 {\n+    () => {\n+        mod test {\n+            pub struct Foo(pub ());\n+        }\n+    }\n+}\n+use test::Foo;\n+m1!();\n+\n+// Test that qualified paths can refer to both the external crate and local item.\n+macro_rules! m2 {\n+    () => {\n+        mod std {\n+            pub struct io(pub ());\n+        }\n+    }\n+}\n+use ::std::io as std_io;\n+use self::std::io as local_io;\n+m2!();\n+\n+fn main() {\n+    Foo(());\n+    std_io::stdout();\n+    local_io(());\n+}"}, {"sha": "a3eefa7134c470ee4a17cdcae09cc69519ae225e", "filename": "src/test/run-pass/uniform-paths/same-crate.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fsame-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ce9ef00e6f418a7db972e07063c1445e72e0c3/src%2Ftest%2Frun-pass%2Funiform-paths%2Fsame-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiform-paths%2Fsame-crate.rs?ref=39ce9ef00e6f418a7db972e07063c1445e72e0c3", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+pub const A: usize = 0;\n+\n+pub mod foo {\n+    pub const B: usize = 1;\n+\n+    pub mod bar {\n+        pub const C: usize = 2;\n+\n+        pub enum E {\n+            V1(usize),\n+            V2(String),\n+        }\n+\n+        pub fn test() -> String {\n+            format!(\"{} {} {}\", crate::A, crate::foo::B, C)\n+        }\n+\n+        pub fn test_use() -> String {\n+            use crate::A;\n+            use crate::foo::B;\n+\n+            format!(\"{} {} {}\", A, B, C)\n+        }\n+\n+        pub fn test_enum() -> String {\n+            use E::*;\n+            match E::V1(10) {\n+                V1(i) => { format!(\"V1: {}\", i) }\n+                V2(s) => { format!(\"V2: {}\", s) }\n+            }\n+        }\n+    }\n+\n+    pub fn test() -> String {\n+        format!(\"{} {} {}\", crate::A, B, bar::C)\n+    }\n+\n+    pub fn test_use() -> String {\n+        use crate::A;\n+        use bar::C;\n+\n+        format!(\"{} {} {}\", A, B, C)\n+    }\n+\n+    pub fn test_enum() -> String {\n+        use bar::E::*;\n+        match bar::E::V1(10) {\n+            V1(i) => { format!(\"V1: {}\", i) }\n+            V2(s) => { format!(\"V2: {}\", s) }\n+        }\n+    }\n+}\n+\n+pub fn test() -> String {\n+    format!(\"{} {} {}\", A, foo::B, foo::bar::C)\n+}\n+\n+pub fn test_use() -> String {\n+    use foo::B;\n+    use foo::bar::C;\n+\n+    format!(\"{} {} {}\", A, B, C)\n+}\n+\n+pub fn test_enum() -> String {\n+    use foo::bar::E::*;\n+    match foo::bar::E::V1(10) {\n+        V1(i) => { format!(\"V1: {}\", i) }\n+        V2(s) => { format!(\"V2: {}\", s) }\n+    }\n+}\n+\n+fn main() {\n+    let output = [\n+        test(),\n+        foo::test(),\n+        foo::bar::test(),\n+        test_use(),\n+        foo::test_use(),\n+        foo::bar::test_use(),\n+        test_enum(),\n+        foo::test_enum(),\n+        foo::bar::test_enum(),\n+    ].join(\"\\n\");\n+    assert_eq!(output, \"\\\n+0 1 2\n+0 1 2\n+0 1 2\n+0 1 2\n+0 1 2\n+0 1 2\n+V1: 10\n+V1: 10\n+V1: 10\");\n+}"}]}