{"sha": "b0522a497ccfcc7b124d77121d8f076af7f09b71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNTIyYTQ5N2NjZmNjN2IxMjRkNzcxMjFkOGYwNzZhZjdmMDliNzE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-22T21:27:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-29T21:30:53Z"}, "message": "librustc: Remove `ptr::addr_of`.", "tree": {"sha": "fd6ce4ae9b4ff0ea4e538240bdef8ac72712dc93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd6ce4ae9b4ff0ea4e538240bdef8ac72712dc93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0522a497ccfcc7b124d77121d8f076af7f09b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0522a497ccfcc7b124d77121d8f076af7f09b71", "html_url": "https://github.com/rust-lang/rust/commit/b0522a497ccfcc7b124d77121d8f076af7f09b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0522a497ccfcc7b124d77121d8f076af7f09b71/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58791c2fd884ad1af626df478c2b509e894b29ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/58791c2fd884ad1af626df478c2b509e894b29ee", "html_url": "https://github.com/rust-lang/rust/commit/58791c2fd884ad1af626df478c2b509e894b29ee"}], "stats": {"total": 576, "additions": 276, "deletions": 300}, "files": [{"sha": "20054818b0b6fa3880663c16ab6ac3a25bcce284", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -14,7 +14,6 @@ use cast::transmute;\n use kinds::Copy;\n use old_iter;\n use option::Option;\n-use ptr::addr_of;\n use sys;\n use uint;\n use vec;\n@@ -40,8 +39,7 @@ pub mod rustrt {\n #[inline(always)]\n pub fn capacity<T>(v: @[T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr =\n-            ::cast::transmute(addr_of(&v));\n+        let repr: **raw::VecRepr = transmute(&v);\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n@@ -189,11 +187,10 @@ pub mod raw {\n     use at_vec::{capacity, rustrt};\n     use cast::transmute;\n     use libc;\n-    use unstable::intrinsics::{move_val_init};\n-    use ptr::addr_of;\n     use ptr;\n     use sys;\n     use uint;\n+    use unstable::intrinsics::{move_val_init};\n     use vec;\n \n     pub type VecRepr = vec::raw::VecRepr;\n@@ -208,7 +205,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: @[T], new_len: uint) {\n-        let repr: **mut VecRepr = ::cast::transmute(addr_of(&v));\n+        let repr: **mut VecRepr = transmute(&v);\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n@@ -229,7 +226,7 @@ pub mod raw {\n         let repr: **mut VecRepr = ::cast::transmute(v);\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n-        let p = addr_of(&((**repr).unboxed.data));\n+        let p = &((**repr).unboxed.data);\n         let p = ptr::offset(p, fill) as *mut T;\n         move_val_init(&mut(*p), initval);\n     }"}, {"sha": "abe8bd7c8d16f1067e935884d1f6a0d62f4db20b", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -327,6 +327,7 @@ impl<T: Owned> ::clone::Clone for SharedChan<T> {\n #[allow(non_camel_case_types)]\n pub mod oneshot {\n     priv use core::kinds::Owned;\n+    use ptr::to_unsafe_ptr;\n \n     pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n         pub use core::pipes::HasBuffer;\n@@ -341,7 +342,7 @@ pub mod oneshot {\n         do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n             {\n                 data.Oneshot.set_buffer(buffer);\n-                ::ptr::addr_of(&(data.Oneshot))\n+                to_unsafe_ptr(&data.Oneshot)\n             }\n         }\n     }"}, {"sha": "c3518cc8b6ee25c9175cf06c3e62a57bf8a2e26e", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -53,7 +53,7 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n             let res =\n                 rustrt::tdefl_compress_mem_to_heap(b as *c_void,\n                                                    len as size_t,\n-                                                   ptr::addr_of(&outsz),\n+                                                   &outsz,\n                                                    lz_norm);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,\n@@ -71,7 +71,7 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n             let res =\n                 rustrt::tinfl_decompress_mem_to_heap(b as *c_void,\n                                                      len as size_t,\n-                                                     ptr::addr_of(&outsz),\n+                                                     &outsz,\n                                                      0);\n             assert!(res as int != 0);\n             let out = vec::raw::from_buf_raw(res as *u8,"}, {"sha": "0d0a98359d14c54818c52410c97f08f2d94c1e72", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -338,7 +338,7 @@ pub fn cleanup_stack_for_failure() {\n         // own stack roots on the stack anyway.\n         let sentinel_box = ~0;\n         let sentinel: **Word = if expect_sentinel() {\n-            cast::transmute(ptr::addr_of(&sentinel_box))\n+            cast::transmute(&sentinel_box)\n         } else {\n             ptr::null()\n         };"}, {"sha": "debca1ead82f88a69104325dce6463bf9f8066b2", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -10,7 +10,7 @@\n \n //! Operations on managed box types\n \n-use ptr;\n+use ptr::to_unsafe_ptr;\n \n #[cfg(notest)] use cmp::{Eq, Ord};\n \n@@ -38,13 +38,15 @@ pub mod raw {\n #[inline(always)]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n-    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n+    let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n+    a_ptr == b_ptr\n }\n \n #[inline(always)]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     //! Determine if two mutable shared boxes point to the same object\n-    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n+    let a_ptr: *T = to_unsafe_ptr(&*a), b_ptr: *T = to_unsafe_ptr(&*b);\n+    a_ptr == b_ptr\n }\n \n #[cfg(notest)]"}, {"sha": "0fae64c09308f8aed599b586bd7cb3e392cd4793", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -49,7 +49,6 @@ use num::Zero;\n use old_iter::{BaseIter, MutableIter, ExtendedIter};\n use old_iter;\n \n-#[cfg(test)] use ptr;\n #[cfg(test)] use str;\n \n /// The option type\n@@ -481,12 +480,14 @@ pub impl<T:Copy + Zero> Option<T> {\n \n #[test]\n fn test_unwrap_ptr() {\n-    let x = ~0;\n-    let addr_x = ptr::addr_of(&(*x));\n-    let opt = Some(x);\n-    let y = opt.unwrap();\n-    let addr_y = ptr::addr_of(&(*y));\n-    assert!(addr_x == addr_y);\n+    unsafe {\n+        let x = ~0;\n+        let addr_x: *int = transmute(&*x);\n+        let opt = Some(x);\n+        let y = opt.unwrap();\n+        let addr_y: *int = transmute(&*y);\n+        assert!(addr_x == addr_y);\n+    }\n }\n \n #[test]"}, {"sha": "92e68112148c2c77b8ab0d0d5046b89203c510c9", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -95,7 +95,7 @@ use vec;\n static SPIN_COUNT: uint = 0;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n )\n \n #[deriving(Eq)]\n@@ -218,7 +218,7 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n \n pub fn packet<T>() -> *Packet<T> {\n     let b = unibuffer();\n-    let p = ptr::addr_of(&(b.data));\n+    let p = ptr::to_unsafe_ptr(&(b.data));\n     // We'll take over memory management from here.\n     unsafe { forget(b) }\n     p\n@@ -305,7 +305,7 @@ impl<T> ::ops::Drop for BufferResource<T> {\n     fn finalize(&self) {\n         unsafe {\n             let b = move_it!(self.buffer);\n-            //let p = ptr::addr_of(*b);\n+            //let p = ptr::to_unsafe_ptr(*b);\n             //error!(\"drop %?\", p);\n             let old_count = intrinsics::atomic_xsub_rel(&mut b.header.ref_count, 1);\n             //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n@@ -322,7 +322,7 @@ impl<T> ::ops::Drop for BufferResource<T> {\n }\n \n fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n-    //let p = ptr::addr_of(*b);\n+    //let p = ptr::to_unsafe_ptr(*b);\n     //error!(\"take %?\", p);\n     unsafe { intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1) };\n \n@@ -336,7 +336,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n-    assert!(ptr::addr_of(&(p.header)) == header);\n+    assert!(ptr::to_unsafe_ptr(&(p.header)) == header);\n     assert!(p.payload.is_none());\n     p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n@@ -356,7 +356,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n                 unsafe {\n                     rustrt::task_signal_event(\n                         old_task,\n-                        ptr::addr_of(&(p.header)) as *libc::c_void);\n+                        ptr::to_unsafe_ptr(&(p.header)) as *libc::c_void);\n                     rustrt::rust_task_deref(old_task);\n                 }\n             }\n@@ -521,7 +521,7 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n             unsafe {\n                 rustrt::task_signal_event(\n                     old_task,\n-                    ptr::addr_of(&(p.header)) as *libc::c_void);\n+                    ptr::to_unsafe_ptr(&(p.header)) as *libc::c_void);\n                 rustrt::rust_task_deref(old_task);\n             }\n         }\n@@ -665,7 +665,7 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n         p: Some(p),\n         buffer: unsafe {\n             Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n+                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n         }\n     }\n }\n@@ -681,7 +681,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n-            let header = ptr::addr_of(&(packet.header));\n+            let header = ptr::to_unsafe_ptr(&(packet.header));\n             //forget(packet);\n             header\n           },\n@@ -747,7 +747,7 @@ impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n-            let header = ptr::addr_of(&(packet.header));\n+            let header = ptr::to_unsafe_ptr(&(packet.header));\n             //forget(packet);\n             header\n           },\n@@ -763,7 +763,7 @@ pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n         p: Some(p),\n         buffer: unsafe {\n             Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n+                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n         }\n     }\n }"}, {"sha": "d069a6c7d56a6c9c56cf3443ec03a59544088d81", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -39,17 +39,6 @@ pub mod libc_ {\n     }\n }\n \n-pub mod rusti {\n-    #[abi = \"rust-intrinsic\"]\n-    pub extern \"rust-intrinsic\" {\n-        fn addr_of<T>(&&val: T) -> *T;\n-    }\n-}\n-\n-/// Get an unsafe pointer to a value\n-#[inline(always)]\n-pub fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n-\n /// Calculate the offset from a pointer\n #[inline(always)]\n pub fn offset<T>(ptr: *T, count: uint) -> *T {"}, {"sha": "c9a696fcd15ca6e169da18957d650dd2e504e4b6", "filename": "src/libcore/rt/uvll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Frt%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Frt%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvll.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -252,7 +252,7 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n-    let out_buf_ptr = ptr::addr_of(&out_buf);\n+    let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n     rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     return out_buf;\n }\n@@ -330,7 +330,7 @@ pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n \n pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n@@ -339,7 +339,7 @@ pub unsafe fn get_last_err_info(uv_loop: *c_void) -> ~str {\n \n pub unsafe fn get_last_err_data(uv_loop: *c_void) -> uv_err_data {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr = ptr::to_unsafe_ptr(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     uv_err_data { err_name: err_name, err_msg: err_msg }"}, {"sha": "064bffa00561f80924354ffcca070f40f5d712ea", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -18,6 +18,7 @@\n  */\n \n use at_vec;\n+use cast::transmute;\n use cast;\n use char;\n use clone::Clone;\n@@ -2045,7 +2046,7 @@ pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n #[inline(always)]\n pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n     unsafe {\n-        let v : *(*u8,uint) = ::cast::transmute(ptr::addr_of(&s));\n+        let v : *(*u8,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len)\n     }"}, {"sha": "96429932b184ad8b9cec7917b1d99ffc55e324fb", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -1028,10 +1028,10 @@ fn avoid_copying_the_body(spawnfn: &fn(v: ~fn())) {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n-    let x_in_parent = ptr::addr_of(&(*x)) as uint;\n+    let x_in_parent = ptr::to_unsafe_ptr(&*x) as uint;\n \n     do spawnfn || {\n-        let x_in_child = ptr::addr_of(&(*x)) as uint;\n+        let x_in_child = ptr::to_unsafe_ptr(&*x) as uint;\n         ch.send(x_in_child);\n     }\n "}, {"sha": "507643ea5ec30c714283679595fb68d45d1d722b", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -93,7 +93,7 @@ use util;\n #[cfg(test)] use task::default_task_opts;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } )\n )\n \n type TaskSet = HashSet<*rust_task>;"}, {"sha": "1b11f6d902edcf8a830221192048a86ceb4674a9", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -48,8 +48,6 @@ pub extern \"rust-intrinsic\" {\n \n     // XXX: intrinsic uses legacy modes\n     fn reinterpret_cast<T,U>(&&src: T) -> U;\n-    // XXX: intrinsic uses legacy modes\n-    fn addr_of<T>(&&scr: T) -> *T;\n \n     pub fn needs_drop<T>() -> bool;\n "}, {"sha": "86767dc5bad859003205af2e16c20f53349023e4", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -26,11 +26,11 @@ use iterator::Iterator;\n use kinds::Copy;\n use libc;\n use option::{None, Option, Some};\n-use unstable::intrinsics;\n+use ptr::to_unsafe_ptr;\n use ptr;\n-use ptr::addr_of;\n use sys;\n use uint;\n+use unstable::intrinsics;\n use vec;\n \n #[cfg(notest)] use cmp::Equiv;\n@@ -117,7 +117,7 @@ pub fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n #[inline(always)]\n pub fn capacity<T>(v: &const ~[T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::transmute(v);\n+        let repr: **raw::VecRepr = transmute(v);\n         (**repr).unboxed.alloc / sys::nonzero_size_of::<T>()\n     }\n }\n@@ -131,7 +131,7 @@ pub fn len<T>(v: &const [T]) -> uint {\n // A botch to tide us over until core and std are fully demuted.\n pub fn uniq_len<T>(v: &const ~[T]) -> uint {\n     unsafe {\n-        let v: &~[T] = ::cast::transmute(v);\n+        let v: &~[T] = transmute(v);\n         as_const_buf(*v, |_p, len| len)\n     }\n }\n@@ -280,9 +280,8 @@ pub fn slice<'r,T>(v: &'r [T], start: uint, end: uint) -> &'r [T] {\n     assert!(end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n-            ::cast::transmute(\n-                (ptr::offset(p, start),\n-                  (end - start) * sys::nonzero_size_of::<T>()))\n+            transmute((ptr::offset(p, start),\n+                       (end - start) * sys::nonzero_size_of::<T>()))\n         }\n     }\n }\n@@ -295,9 +294,8 @@ pub fn mut_slice<'r,T>(v: &'r mut [T], start: uint, end: uint)\n     assert!(end <= v.len());\n     do as_mut_buf(v) |p, _len| {\n         unsafe {\n-            ::cast::transmute(\n-                (ptr::mut_offset(p, start),\n-                  (end - start) * sys::nonzero_size_of::<T>()))\n+            transmute((ptr::mut_offset(p, start),\n+                       (end - start) * sys::nonzero_size_of::<T>()))\n         }\n     }\n }\n@@ -310,9 +308,8 @@ pub fn const_slice<'r,T>(v: &'r const [T], start: uint, end: uint)\n     assert!(end <= len(v));\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n-            ::cast::transmute(\n-                (ptr::const_offset(p, start),\n-                  (end - start) * sys::nonzero_size_of::<T>()))\n+            transmute((ptr::const_offset(p, start),\n+                       (end - start) * sys::nonzero_size_of::<T>()))\n         }\n     }\n }\n@@ -489,14 +486,14 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n         {\n             let first_slice = slice(*v, 0, 1);\n             let last_slice = slice(*v, next_ln, ln);\n-            raw::copy_memory(::cast::transmute(last_slice), first_slice, 1);\n+            raw::copy_memory(transmute(last_slice), first_slice, 1);\n         }\n \n         // Memcopy everything to the left one element\n         {\n             let init_slice = slice(*v, 0, next_ln);\n             let tail_slice = slice(*v, 1, ln);\n-            raw::copy_memory(::cast::transmute(init_slice),\n+            raw::copy_memory(transmute(init_slice),\n                              tail_slice,\n                              next_ln);\n         }\n@@ -626,7 +623,7 @@ pub fn swap_remove<T>(v: &mut ~[T], index: uint) -> T {\n #[inline(always)]\n pub fn push<T>(v: &mut ~[T], initval: T) {\n     unsafe {\n-        let repr: **raw::VecRepr = ::cast::transmute(&mut *v);\n+        let repr: **raw::VecRepr = transmute(&mut *v);\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, initval);\n@@ -640,10 +637,10 @@ pub fn push<T>(v: &mut ~[T], initval: T) {\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n-    let repr: **mut raw::VecRepr = ::cast::transmute(v);\n+    let repr: **mut raw::VecRepr = transmute(v);\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n-    let p = addr_of(&((**repr).unboxed.data));\n+    let p = to_unsafe_ptr(&((**repr).unboxed.data));\n     let p = ptr::offset(p, fill) as *mut T;\n     intrinsics::move_val_init(&mut(*p), initval);\n }\n@@ -1622,8 +1619,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n     // instead!\n \n     unsafe {\n-        let v : *(*T,uint) =\n-            ::cast::transmute(addr_of(&s));\n+        let v : *(*T,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len / sys::nonzero_size_of::<T>())\n     }\n@@ -1633,8 +1629,7 @@ pub fn as_imm_buf<T,U>(s: &[T],\n #[inline(always)]\n pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n     unsafe {\n-        let v : *(*const T,uint) =\n-            ::cast::transmute(addr_of(&s));\n+        let v : *(*const T,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len / sys::nonzero_size_of::<T>())\n     }\n@@ -1644,8 +1639,7 @@ pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n #[inline(always)]\n pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n     unsafe {\n-        let v : *(*mut T,uint) =\n-            ::cast::transmute(addr_of(&s));\n+        let v : *(*mut T,uint) = transmute(&s);\n         let (buf,len) = *v;\n         f(buf, len / sys::nonzero_size_of::<T>())\n     }\n@@ -2429,13 +2423,13 @@ pub struct UnboxedVecRepr {\n \n /// Unsafe operations\n pub mod raw {\n+    use cast::transmute;\n     use kinds::Copy;\n     use managed;\n     use option::{None, Some};\n-    use unstable::intrinsics;\n-    use ptr::addr_of;\n     use ptr;\n     use sys;\n+    use unstable::intrinsics;\n     use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, len, with_capacity};\n \n     /// The internal representation of a (boxed) vector\n@@ -2458,7 +2452,7 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn set_len<T>(v: &mut ~[T], new_len: uint) {\n-        let repr: **mut VecRepr = ::cast::transmute(v);\n+        let repr: **mut VecRepr = transmute(v);\n         (**repr).unboxed.fill = new_len * sys::nonzero_size_of::<T>();\n     }\n \n@@ -2473,22 +2467,22 @@ pub mod raw {\n      */\n     #[inline(always)]\n     pub unsafe fn to_ptr<T>(v: &[T]) -> *T {\n-        let repr: **SliceRepr = ::cast::transmute(&v);\n-        ::cast::transmute(addr_of(&((**repr).data)))\n+        let repr: **SliceRepr = transmute(&v);\n+        transmute(&((**repr).data))\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     pub unsafe fn to_const_ptr<T>(v: &const [T]) -> *const T {\n-        let repr: **SliceRepr = ::cast::transmute(&v);\n-        ::cast::transmute(addr_of(&((**repr).data)))\n+        let repr: **SliceRepr = transmute(&v);\n+        transmute(&((**repr).data))\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     pub unsafe fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n-        let repr: **SliceRepr = ::cast::transmute(&v);\n-        ::cast::transmute(addr_of(&((**repr).data)))\n+        let repr: **SliceRepr = transmute(&v);\n+        transmute(&((**repr).data))\n     }\n \n     /**\n@@ -2500,8 +2494,7 @@ pub mod raw {\n                                     len: uint,\n                                     f: &fn(v: &[T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&'blk [T]) =\n-            ::cast::transmute(addr_of(&pair));\n+        let v : *(&'blk [T]) = transmute(&pair);\n         f(*v)\n     }\n \n@@ -2514,8 +2507,7 @@ pub mod raw {\n                                         len: uint,\n                                         f: &fn(v: &mut [T]) -> U) -> U {\n         let pair = (p, len * sys::nonzero_size_of::<T>());\n-        let v : *(&'blk mut [T]) =\n-            ::cast::transmute(addr_of(&pair));\n+        let v : *(&'blk mut [T]) = transmute(&pair);\n         f(*v)\n     }\n "}, {"sha": "2de12b9eb9746ec7e9c0213cf12f54d304fb34dd", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -28,8 +28,8 @@ use syntax::ast_util::local_def;\n use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::visit_crate;\n \n+use core::cast::transmute;\n use core::hashmap::HashMap;\n-use core::ptr;\n \n pub enum LangItem {\n     ConstTraitLangItem,         // 0\n@@ -366,20 +366,22 @@ pub impl<'self> LanguageItemCollector<'self> {\n     }\n \n     fn collect_local_language_items(&self) {\n-        let this = ptr::addr_of(&self);\n-        visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n-            visit_item: |item| {\n-                for item.attrs.each |attribute| {\n-                    unsafe {\n-                        (*this).match_and_collect_meta_item(\n-                            local_def(item.id),\n-                            attribute.node.value\n-                        );\n+        unsafe {\n+            let this: *LanguageItemCollector<'self> = transmute(self);\n+            visit_crate(self.crate, (), mk_simple_visitor(@SimpleVisitor {\n+                visit_item: |item| {\n+                    for item.attrs.each |attribute| {\n+                        unsafe {\n+                            (*this).match_and_collect_meta_item(\n+                                local_def(item.id),\n+                                attribute.node.value\n+                            );\n+                        }\n                     }\n-                }\n-            },\n-            .. *default_simple_visitor()\n-        }));\n+                },\n+                .. *default_simple_visitor()\n+            }));\n+        }\n     }\n \n     fn collect_external_language_items(&self) {"}, {"sha": "fa491705df1737c1cedca612ae3593e3cdf096ce", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -110,6 +110,7 @@ use middle::typeck;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n+use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::util::with;\n use syntax::ast::*;\n@@ -418,7 +419,9 @@ fn visit_fn(fk: &visit::fn_kind,\n                               self.last_use_map,\n                               self.cur_item);\n \n-    debug!(\"creating fn_maps: %x\", ptr::addr_of(&(*fn_maps)) as uint);\n+    unsafe {\n+        debug!(\"creating fn_maps: %x\", transmute(&*fn_maps));\n+    }\n \n     for decl.inputs.each |arg| {\n         let mode = ty::resolved_mode(self.tcx, arg.mode);"}, {"sha": "f5c496484a03767b3ee9c797a580e4748daaf033", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -170,7 +170,7 @@ pub fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n pub fn noname() -> *c_char {\n     unsafe {\n         static cnull: uint = 0u;\n-        return cast::transmute(ptr::addr_of(&cnull));\n+        return cast::transmute(&cnull);\n     }\n }\n \n@@ -827,8 +827,8 @@ pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     unsafe {\n         if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n-        let valptr = cast::transmute(ptr::addr_of(&val));\n-        let bbptr = cast::transmute(ptr::addr_of(&bb));\n+        let valptr = cast::transmute(&val);\n+        let bbptr = cast::transmute(&bb);\n         llvm::LLVMAddIncoming(phi, valptr, bbptr, 1 as c_uint);\n     }\n }"}, {"sha": "96071377a451366b17440b4e39421be27e6654ac", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -750,13 +750,11 @@ pub impl block_ {\n         t.repr(self.tcx())\n     }\n     fn to_str(@mut self) -> ~str {\n-        match self.node_info {\n-          Some(node_info) => {\n-            fmt!(\"[block %d]\", node_info.id)\n-          }\n-          None => {\n-            fmt!(\"[block %x]\", ptr::addr_of(&(*self)) as uint)\n-          }\n+        unsafe {\n+            match self.node_info {\n+                Some(node_info) => fmt!(\"[block %d]\", node_info.id),\n+                None => fmt!(\"[block %x]\", transmute(&*self)),\n+            }\n         }\n     }\n }"}, {"sha": "eab8f3c3d6cc83d104c1f1f777b0650353b4f639", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -745,9 +745,6 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n               call_memcpy(bcx, llretptr, llcast, llsize_of(ccx, lltp_ty));\n           }\n         }\n-        ~\"addr_of\" => {\n-            Store(bcx, get_param(decl, first_real_arg), fcx.llretptr.get());\n-        }\n         ~\"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n             Store(bcx,"}, {"sha": "ea00f66448fa80eedf290a9d91f223884ebdf76a", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -135,8 +135,8 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                 ~\"atomic_xsub_acq\" | ~\"atomic_xchg_rel\" |\n                 ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => 0,\n \n-                ~\"visit_tydesc\"  | ~\"forget\" | ~\"addr_of\" |\n-                ~\"frame_address\" | ~\"morestack_addr\" => 0,\n+                ~\"visit_tydesc\"  | ~\"forget\" | ~\"frame_address\" |\n+                ~\"morestack_addr\" => 0,\n \n                 ~\"memmove32\" | ~\"memmove64\" => 0,\n "}, {"sha": "ea878d397d831d0943c3e752c003e01400281c49", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -107,6 +107,7 @@ use util::common::{block_query, indenter, loop_query};\n use util::ppaux::{bound_region_to_str};\n use util::ppaux;\n \n+use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::util::replace;\n use std::list::Nil;\n@@ -706,7 +707,11 @@ impl region_scope for FnCtxt {\n }\n \n pub impl FnCtxt {\n-    fn tag(&self) -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n+    fn tag(&self) -> ~str {\n+        unsafe {\n+            fmt!(\"%x\", transmute(self))\n+        }\n+    }\n \n     fn local_ty(&self, span: span, nid: ast::node_id) -> ty::t {\n         match self.inh.locals.find(&nid) {\n@@ -3436,8 +3441,6 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                     ty::mk_nil()),\n       ~\"reinterpret_cast\" => (2u, ~[arg(ast::by_ref, param(ccx, 0u))],\n                               param(ccx, 1u)),\n-      ~\"addr_of\" => (1u, ~[arg(ast::by_ref, param(ccx, 0u))],\n-                      ty::mk_imm_ptr(tcx, param(ccx, 0u))),\n       ~\"move_val\" | ~\"move_val_init\" => {\n           (1u, ~[arg(ast::by_copy,\n                      ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)),"}, {"sha": "34dd6390ecc12f98c11edb8d49aa4c11a986e375", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -11,7 +11,6 @@\n //! Unsafe debugging functions for inspecting values.\n \n use core::cast::transmute;\n-use core::ptr;\n use core::sys;\n \n pub mod rustrt {\n@@ -37,36 +36,31 @@ pub fn debug_tydesc<T>() {\n \n pub fn debug_opaque<T>(x: T) {\n     unsafe {\n-        rustrt::debug_opaque(sys::get_type_desc::<T>(),\n-                             ptr::addr_of(&x) as *());\n+        rustrt::debug_opaque(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_box<T>(x: @T) {\n     unsafe {\n-        rustrt::debug_box(sys::get_type_desc::<T>(),\n-                          ptr::addr_of(&x) as *());\n+        rustrt::debug_box(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_tag<T>(x: T) {\n     unsafe {\n-        rustrt::debug_tag(sys::get_type_desc::<T>(),\n-                          ptr::addr_of(&x) as *());\n+        rustrt::debug_tag(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub fn debug_fn<T>(x: T) {\n     unsafe {\n-        rustrt::debug_fn(sys::get_type_desc::<T>(),\n-                         ptr::addr_of(&x) as *());\n+        rustrt::debug_fn(sys::get_type_desc::<T>(), transmute(&x));\n     }\n }\n \n pub unsafe fn ptr_cast<T, U>(x: @T) -> @U {\n     transmute(\n-        rustrt::debug_ptrcast(sys::get_type_desc::<T>(),\n-                              transmute(x)))\n+        rustrt::debug_ptrcast(sys::get_type_desc::<T>(), transmute(x)))\n }\n \n /// Triggers a debugger breakpoint"}, {"sha": "bf1b9dc0cda967e1e57f45cbc8f72cc8ff6b16e3", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -110,18 +110,18 @@ enum IpGetAddrErr {\n  * object in the case of failure\n */\n pub fn get_addr(node: &str, iotask: &iotask)\n-    -> result::Result<~[IpAddr], IpGetAddrErr> {\n+                -> result::Result<~[IpAddr], IpGetAddrErr> {\n     let (output_po, output_ch) = stream();\n     let mut output_ch = Some(SharedChan::new(output_ch));\n     do str::as_buf(node) |node_ptr, len| {\n         let output_ch = output_ch.swap_unwrap();\n         debug!(\"slice len %?\", len);\n         let handle = create_uv_getaddrinfo_t();\n-        let handle_ptr = ptr::addr_of(&handle);\n+        let handle_ptr: *uv_getaddrinfo_t = &handle;\n         let handle_data = GetAddrData {\n             output_ch: output_ch.clone()\n         };\n-        let handle_data_ptr = ptr::addr_of(&handle_data);\n+        let handle_data_ptr: *GetAddrData = &handle_data;\n         do interact(iotask) |loop_ptr| {\n             unsafe {\n                 let result = uv_getaddrinfo(\n@@ -189,7 +189,8 @@ pub mod v4 {\n     impl AsUnsafeU32 for Ipv4Rep {\n         // this is pretty dastardly, i know\n         unsafe fn as_u32(&self) -> u32 {\n-            *((ptr::addr_of(self)) as *u32)\n+            let this: &mut u32 = transmute(self);\n+            *this\n         }\n     }\n     pub fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n@@ -297,7 +298,8 @@ struct GetAddrData {\n     output_ch: SharedChan<result::Result<~[IpAddr],IpGetAddrErr>>\n }\n \n-extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n+extern fn get_addr_cb(handle: *uv_getaddrinfo_t,\n+                      status: libc::c_int,\n                       res: *addrinfo) {\n     unsafe {\n         debug!(\"in get_addr_cb\");"}, {"sha": "764152d6812c50c1fda60ea94a3edec25ef3db26", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -156,7 +156,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n             result_ch: result_ch,\n             closed_signal_ch: closed_signal_ch\n         };\n-        let conn_data_ptr = ptr::addr_of(&conn_data);\n+        let conn_data_ptr: *ConnectReqData = &conn_data;\n         let (reader_po, reader_ch) = stream::<Result<~[u8], TcpErrData>>();\n         let reader_ch = SharedChan::new(reader_ch);\n         let stream_handle_ptr = malloc_uv_tcp_t();\n@@ -173,7 +173,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n             },\n             iotask: iotask.clone()\n         };\n-        let socket_data_ptr = ptr::addr_of(&(*socket_data));\n+        let socket_data_ptr: *TcpSocketData = &*socket_data;\n         // get an unsafe representation of our stream_handle_ptr that\n         // we can send into the interact cb to be handled in libuv..\n         debug!(\"stream_handle_ptr outside interact %?\",\n@@ -187,8 +187,8 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                     0i32 => {\n                         debug!(\"tcp_init successful\");\n                         debug!(\"dealing w/ ipv4 connection..\");\n-                        let connect_req_ptr =\n-                            ptr::addr_of(&((*socket_data_ptr).connect_req));\n+                        let connect_req_ptr: *uv::ll::uv_connect_t =\n+                            &(*socket_data_ptr).connect_req;\n                         let addr_str = ip::format_addr(&input_ip);\n                         let connect_result = match input_ip {\n                             ip::Ipv4(ref addr) => {\n@@ -205,7 +205,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                 uv::ll::tcp_connect(\n                                     connect_req_ptr,\n                                     stream_handle_ptr,\n-                                    ptr::addr_of(&in_addr),\n+                                    &in_addr,\n                                     tcp_connect_on_connect_cb)\n                             }\n                             ip::Ipv6(ref addr) => {\n@@ -215,7 +215,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                 uv::ll::tcp_connect6(\n                                     connect_req_ptr,\n                                     stream_handle_ptr,\n-                                    ptr::addr_of(&in_addr),\n+                                    &in_addr,\n                                     tcp_connect_on_connect_cb)\n                             }\n                         };\n@@ -303,9 +303,8 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n  * `TcpErrData` value as the `Err` variant\n  */\n pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> result::Result<(), TcpErrData>\n-{\n-    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+             -> result::Result<(), TcpErrData> {\n+    let socket_data_ptr: *TcpSocketData = &*sock.socket_data;\n     write_common_impl(socket_data_ptr, raw_write_data)\n }\n \n@@ -343,7 +342,7 @@ pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n     -> future::Future<result::Result<(), TcpErrData>>\n {\n-    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+    let socket_data_ptr: *TcpSocketData = &*sock.socket_data;\n     do future_spawn {\n         let data_copy = copy(raw_write_data);\n         write_common_impl(socket_data_ptr, data_copy)\n@@ -366,9 +365,10 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  * `TcpErrData` record\n  */\n pub fn read_start(sock: &TcpSocket)\n-    -> result::Result<@Port<\n-        result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+                  -> result::Result<@Port<result::Result<~[u8],\n+                                                         TcpErrData>>,\n+                                    TcpErrData> {\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     read_start_common_impl(socket_data)\n }\n \n@@ -380,7 +380,7 @@ pub fn read_start(sock: &TcpSocket)\n  * * `sock` - a `net::tcp::TcpSocket` that you wish to stop reading on\n  */\n pub fn read_stop(sock: &TcpSocket) -> result::Result<(), TcpErrData> {\n-    let socket_data = ptr::addr_of(&(*sock.socket_data));\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     read_stop_common_impl(socket_data)\n }\n \n@@ -400,8 +400,8 @@ pub fn read_stop(sock: &TcpSocket) -> result::Result<(), TcpErrData> {\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n pub fn read(sock: &TcpSocket, timeout_msecs: uint)\n-    -> result::Result<~[u8],TcpErrData> {\n-    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+            -> result::Result<~[u8],TcpErrData> {\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     read_common_impl(socket_data, timeout_msecs)\n }\n \n@@ -435,8 +435,8 @@ pub fn read(sock: &TcpSocket, timeout_msecs: uint)\n  * read attempt. Pass `0u` to wait indefinitely\n  */\n fn read_future(sock: &TcpSocket, timeout_msecs: uint)\n-    -> future::Future<result::Result<~[u8],TcpErrData>> {\n-    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+               -> future::Future<result::Result<~[u8],TcpErrData>> {\n+    let socket_data: *TcpSocketData = &*sock.socket_data;\n     do future_spawn {\n         read_common_impl(socket_data, timeout_msecs)\n     }\n@@ -534,8 +534,8 @@ pub fn accept(new_conn: TcpNewConnection)\n                     ipv6: (*server_data_ptr).ipv6,\n                     iotask : iotask.clone()\n                 };\n-                let client_socket_data_ptr = ptr::addr_of(\n-                    &(*client_socket_data));\n+                let client_socket_data_ptr: *TcpSocketData =\n+                    &*client_socket_data;\n                 let client_stream_handle_ptr =\n                     (*client_socket_data_ptr).stream_handle_ptr;\n \n@@ -661,7 +661,7 @@ fn listen_common(host_ip: ip::IpAddr,\n     let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n     let kill_ch = SharedChan::new(kill_ch);\n     let server_stream = uv::ll::tcp_t();\n-    let server_stream_ptr = ptr::addr_of(&server_stream);\n+    let server_stream_ptr: *uv::ll::uv_tcp_t = &server_stream;\n     let server_data: TcpListenFcData = TcpListenFcData {\n         server_stream_ptr: server_stream_ptr,\n         stream_closed_ch: stream_closed_ch,\n@@ -674,7 +674,7 @@ fn listen_common(host_ip: ip::IpAddr,\n         },\n         mut active: true\n     };\n-    let server_data_ptr = ptr::addr_of(&server_data);\n+    let server_data_ptr: *TcpListenFcData = &server_data;\n \n     let (setup_po, setup_ch) = stream();\n \n@@ -699,16 +699,14 @@ fn listen_common(host_ip: ip::IpAddr,\n                             let in_addr = uv::ll::ip4_addr(\n                                 addr_str,\n                                 port as int);\n-                            uv::ll::tcp_bind(server_stream_ptr,\n-                                             ptr::addr_of(&in_addr))\n+                            uv::ll::tcp_bind(server_stream_ptr, &in_addr)\n                         }\n                         ip::Ipv6(ref addr) => {\n                             debug!(\"addr: %?\", addr);\n                             let in_addr = uv::ll::ip6_addr(\n                                 addr_str,\n                                 port as int);\n-                            uv::ll::tcp_bind6(server_stream_ptr,\n-                                              ptr::addr_of(&in_addr))\n+                            uv::ll::tcp_bind6(server_stream_ptr, &in_addr)\n                         }\n                     };\n                     match bind_result {\n@@ -856,12 +854,12 @@ pub impl TcpSocket {\n             if self.socket_data.ipv6 {\n                 let addr = uv::ll::ip6_addr(\"\", 0);\n                 uv::ll::tcp_getpeername6(self.socket_data.stream_handle_ptr,\n-                                         ptr::addr_of(&addr));\n+                                         &addr);\n                 ip::Ipv6(addr)\n             } else {\n                 let addr = uv::ll::ip4_addr(\"\", 0);\n                 uv::ll::tcp_getpeername(self.socket_data.stream_handle_ptr,\n-                                        ptr::addr_of(&addr));\n+                                        &addr);\n                 ip::Ipv4(addr)\n             }\n         }\n@@ -973,13 +971,12 @@ impl io::Reader for TcpSocketBuf {\n impl io::Writer for TcpSocketBuf {\n     pub fn write(&self, data: &const [u8]) {\n         unsafe {\n-            let socket_data_ptr =\n-                ptr::addr_of(&(*((*(self.data)).sock).socket_data));\n+            let socket_data_ptr: *TcpSocketData =\n+                &(*((*(self.data)).sock).socket_data);\n             let w_result = write_common_impl(socket_data_ptr,\n-                                            vec::slice(data,\n-                                                       0,\n-                                                       vec::len(data)\n-                                                      ).to_vec());\n+                                             vec::slice(data,\n+                                                        0,\n+                                                        data.len()).to_vec());\n             if w_result.is_err() {\n                 let err_data = w_result.get_err();\n                 debug!(\n@@ -1012,7 +1009,7 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) {\n         let close_data = TcpSocketCloseData {\n             closed_ch: closed_ch\n         };\n-        let close_data_ptr = ptr::addr_of(&close_data);\n+        let close_data_ptr: *TcpSocketCloseData = &close_data;\n         let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n         do iotask::interact(&(*socket_data).iotask) |loop_ptr| {\n             unsafe {\n@@ -1150,19 +1147,21 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n                      raw_write_data: ~[u8])\n     -> result::Result<(), TcpErrData> {\n     unsafe {\n-        let write_req_ptr = ptr::addr_of(&((*socket_data_ptr).write_req));\n+        let write_req_ptr: *uv::ll::uv_write_t =\n+            &(*socket_data_ptr).write_req;\n         let stream_handle_ptr =\n             (*socket_data_ptr).stream_handle_ptr;\n-        let write_buf_vec =  ~[ uv::ll::buf_init(\n-            vec::raw::to_ptr(raw_write_data),\n-            vec::len(raw_write_data)) ];\n-        let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n+        let write_buf_vec = ~[\n+            uv::ll::buf_init(vec::raw::to_ptr(raw_write_data),\n+                             raw_write_data.len())\n+        ];\n+        let write_buf_vec_ptr: *~[uv::ll::uv_buf_t] = &write_buf_vec;\n         let (result_po, result_ch) = stream::<TcpWriteResult>();\n         let result_ch = SharedChan::new(result_ch);\n         let write_data = WriteReqData {\n             result_ch: result_ch\n         };\n-        let write_data_ptr = ptr::addr_of(&write_data);\n+        let write_data_ptr: *WriteReqData = &write_data;\n         do iotask::interact(&(*socket_data_ptr).iotask) |loop_ptr| {\n             unsafe {\n                 debug!(\"in interact cb for tcp::write %?\","}, {"sha": "6f40882341097936810878b16353743a2c2e56ec", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -151,7 +151,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n \n     priv fn siftup(&mut self, start: uint, mut pos: uint) {\n         unsafe {\n-            let new = *addr_of(&self.data[pos]);\n+            let new = *ptr::to_unsafe_ptr(&self.data[pos]);\n \n             while pos > start {\n                 let parent = (pos - 1) >> 1;\n@@ -171,7 +171,7 @@ pub impl <T:Ord> PriorityQueue<T> {\n     priv fn siftdown_range(&mut self, mut pos: uint, end: uint) {\n         unsafe {\n             let start = pos;\n-            let new = *addr_of(&self.data[pos]);\n+            let new = *ptr::to_unsafe_ptr(&self.data[pos]);\n \n             let mut child = 2 * pos + 1;\n             while child < end {"}, {"sha": "21a6153380cb70d3c73db7f14bbc9b812372e1ce", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -828,7 +828,7 @@ mod tests {\n         let m = ~Mutex();\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n-        let ptr = ptr::addr_of(&(*sharedstate));\n+        let ptr: *int = &*sharedstate;\n         do task::spawn || {\n             let sharedstate: &mut int =\n                 unsafe { cast::transmute(ptr) };\n@@ -1106,7 +1106,7 @@ mod tests {\n         let (p,c) = comm::stream();\n         let x2 = (*x).clone();\n         let mut sharedstate = ~0;\n-        let ptr = ptr::addr_of(&(*sharedstate));\n+        let ptr: *int = &*sharedstate;\n         do task::spawn || {\n             let sharedstate: &mut int =\n                 unsafe { cast::transmute(ptr) };"}, {"sha": "b19b2f2889e718b5a53f71266191af055947275e", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -42,7 +42,7 @@ pub fn delayed_send<T:Owned>(iotask: &IoTask,\n     let (timer_done_po, timer_done_ch) = stream::<()>();\n     let timer_done_ch = SharedChan::new(timer_done_ch);\n     let timer = uv::ll::timer_t();\n-    let timer_ptr = ptr::addr_of(&timer);\n+    let timer_ptr: *uv::ll::uv_timer_t = &timer;\n     do iotask::interact(iotask) |loop_ptr| {\n         unsafe {\n             let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);"}, {"sha": "e49cee434f81f9e443f91454f32f169254263f74", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -162,7 +162,7 @@ mod test {\n             debug!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n                             exit_ch_ptr);\n             let timer_handle = ll::timer_t();\n-            let timer_ptr = ptr::addr_of(&timer_handle);\n+            let timer_ptr: *ll::uv_timer_t = &timer_handle;\n             do iotask::interact(iotask) |loop_ptr| {\n                 unsafe {\n                     debug!(~\"user code inside interact loop!!!\");"}, {"sha": "e19010e8552a280c8b971c468d9719d6b47b0644", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -17,10 +17,9 @@\n \n use ll = uv_ll;\n \n+use core::comm::{stream, Port, Chan, SharedChan};\n use core::libc::c_void;\n use core::libc;\n-use core::comm::{stream, Port, Chan, SharedChan};\n-use core::ptr::addr_of;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n pub struct IoTask {\n@@ -106,7 +105,7 @@ fn run_loop(iotask_ch: &Chan<IoTask>) {\n         // set up the special async handle we'll use to allow multi-task\n         // communication with this loop\n         let async = ll::async_t();\n-        let async_handle = addr_of(&async);\n+        let async_handle: *ll::uv_async_t = &async;\n \n         // associate the async handle with the loop\n         ll::async_init(loop_ptr, async_handle, wake_up_cb);\n@@ -118,11 +117,11 @@ fn run_loop(iotask_ch: &Chan<IoTask>) {\n             async_handle: async_handle,\n             msg_po: msg_po\n         };\n-        ll::set_data_for_uv_handle(async_handle, addr_of(&data));\n+        ll::set_data_for_uv_handle(async_handle, &data);\n \n         // Send out a handle through which folks can talk to us\n         // while we dwell in the I/O loop\n-        let iotask = IoTask{\n+        let iotask = IoTask {\n             async_handle: async_handle,\n             op_chan: SharedChan::new(msg_ch)\n         };\n@@ -223,7 +222,7 @@ struct AhData {\n #[cfg(test)]\n fn impl_uv_iotask_async(iotask: &IoTask) {\n     let async_handle = ll::async_t();\n-    let ah_ptr = ptr::addr_of(&async_handle);\n+    let ah_ptr: *ll::uv_async_t = &async_handle;\n     let (exit_po, exit_ch) = stream::<()>();\n     let ah_data = AhData {\n         iotask: iotask.clone(),"}, {"sha": "8e5b3274bbb8c06ad2d9c1c97defa23c608ccfb4", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -1021,19 +1021,17 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n-    let out_buf_ptr = ptr::addr_of(&out_buf);\n+    let out_buf_ptr: *uv_buf_t = &out_buf;\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     return out_buf;\n }\n-pub unsafe fn ip4_addr(ip: &str, port: int)\n--> sockaddr_in {\n+pub unsafe fn ip4_addr(ip: &str, port: int) -> sockaddr_in {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip4_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n     }\n }\n-pub unsafe fn ip6_addr(ip: &str, port: int)\n--> sockaddr_in6 {\n+pub unsafe fn ip6_addr(ip: &str, port: int) -> sockaddr_in6 {\n     do str::as_c_str(ip) |ip_buf| {\n         rustrt::rust_uv_ip6_addr(ip_buf as *u8,\n                                  port as libc::c_int)\n@@ -1183,7 +1181,7 @@ pub unsafe fn free_base_of_buf(buf: uv_buf_t) {\n \n pub unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr: *uv_err_t = &err;\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     return fmt!(\"LIBUV ERROR: name: %s msg: %s\",\n@@ -1192,7 +1190,7 @@ pub unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n \n pub unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n     let err = last_error(uv_loop);\n-    let err_ptr = ptr::addr_of(&err);\n+    let err_ptr: *uv_err_t = &err;\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n     uv_err_data { err_name: err_name, err_msg: err_msg }\n@@ -1347,9 +1345,9 @@ mod test {\n         unsafe {\n             let test_loop = loop_new();\n             let tcp_handle = tcp_t();\n-            let tcp_handle_ptr = ptr::addr_of(&tcp_handle);\n+            let tcp_handle_ptr: *uv_tcp_t = &tcp_handle;\n             let connect_handle = connect_t();\n-            let connect_req_ptr = ptr::addr_of(&connect_handle);\n+            let connect_req_ptr: *uv_connect_t = &connect_handle;\n \n             // this is the persistent payload of data that we\n             // need to pass around to get this example to work.\n@@ -1365,43 +1363,42 @@ mod test {\n             // this is the enclosing record, we'll pass a ptr to\n             // this to C..\n             let write_handle = write_t();\n-            let write_handle_ptr = ptr::addr_of(&write_handle);\n+            let write_handle_ptr: *uv_write_t = &write_handle;\n             debug!(\"tcp req: tcp stream: %d write_handle: %d\",\n                              tcp_handle_ptr as int,\n                              write_handle_ptr as int);\n             let client_data = request_wrapper {\n                 write_req: write_handle_ptr,\n-                req_buf: ptr::addr_of(&req_msg),\n+                req_buf: &req_msg,\n                 read_chan: client_chan\n             };\n \n-            let tcp_init_result = tcp_init(\n-                test_loop as *libc::c_void, tcp_handle_ptr);\n-            if (tcp_init_result == 0i32) {\n+            let tcp_init_result = tcp_init(test_loop as *libc::c_void,\n+                                           tcp_handle_ptr);\n+            if (tcp_init_result == 0) {\n                 debug!(~\"sucessful tcp_init_result\");\n \n                 debug!(~\"building addr...\");\n                 let addr = ip4_addr(ip, port);\n                 // FIXME ref #2064\n-                let addr_ptr = ptr::addr_of(&addr);\n+                let addr_ptr: *sockaddr_in = &addr;\n                 debug!(\"after build addr in rust. port: %u\",\n-                                 addr.sin_port as uint);\n+                       addr.sin_port as uint);\n \n                 // this should set up the connection request..\n                 debug!(\"b4 call tcp_connect connect cb: %u \",\n-                                on_connect_cb as uint);\n-                let tcp_connect_result = tcp_connect(\n-                    connect_req_ptr, tcp_handle_ptr,\n-                    addr_ptr, on_connect_cb);\n-                if (tcp_connect_result == 0i32) {\n+                       on_connect_cb as uint);\n+                let tcp_connect_result = tcp_connect(connect_req_ptr,\n+                                                     tcp_handle_ptr,\n+                                                     addr_ptr,\n+                                                     on_connect_cb);\n+                if (tcp_connect_result == 0) {\n                     // not set the data on the connect_req\n                     // until its initialized\n-                    set_data_for_req(\n-                        connect_req_ptr as *libc::c_void,\n-                        ptr::addr_of(&client_data) as *libc::c_void);\n-                    set_data_for_uv_handle(\n-                        tcp_handle_ptr as *libc::c_void,\n-                        ptr::addr_of(&client_data) as *libc::c_void);\n+                    set_data_for_req(connect_req_ptr as *libc::c_void,\n+                                     transmute(&client_data));\n+                    set_data_for_uv_handle(tcp_handle_ptr as *libc::c_void,\n+                                           transmute(&client_data));\n                     debug!(~\"before run tcp req loop\");\n                     run(test_loop);\n                     debug!(~\"after run tcp req loop\");\n@@ -1607,37 +1604,37 @@ mod test {\n         unsafe {\n             let test_loop = loop_new();\n             let tcp_server = tcp_t();\n-            let tcp_server_ptr = ptr::addr_of(&tcp_server);\n+            let tcp_server_ptr: *uv_tcp_t = &tcp_server;\n \n             let tcp_client = tcp_t();\n-            let tcp_client_ptr = ptr::addr_of(&tcp_client);\n+            let tcp_client_ptr: *uv_tcp_t = &tcp_client;\n \n             let server_write_req = write_t();\n-            let server_write_req_ptr = ptr::addr_of(&server_write_req);\n+            let server_write_req_ptr: *uv_write_t = &server_write_req;\n \n             let resp_str_bytes = str::to_bytes(server_resp_msg);\n             let resp_msg_ptr: *u8 = vec::raw::to_ptr(resp_str_bytes);\n             debug!(\"resp_msg ptr: %u\", resp_msg_ptr as uint);\n             let resp_msg = ~[\n-                buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n+                buf_init(resp_msg_ptr, resp_str_bytes.len())\n             ];\n \n             let continue_async_handle = async_t();\n-            let continue_async_handle_ptr =\n-                ptr::addr_of(&continue_async_handle);\n+            let continue_async_handle_ptr: *uv_async_t =\n+                &continue_async_handle;\n             let async_data =\n                 async_handle_data { continue_chan: continue_chan };\n-            let async_data_ptr = ptr::addr_of(&async_data);\n+            let async_data_ptr: *async_handle_data = &async_data;\n \n             let server_data = tcp_server_data {\n                 client: tcp_client_ptr,\n                 server: tcp_server_ptr,\n                 server_kill_msg: kill_server_msg,\n-                server_resp_buf: ptr::addr_of(&resp_msg),\n+                server_resp_buf: &resp_msg,\n                 server_chan: server_chan,\n                 server_write_req: server_write_req_ptr\n             };\n-            let server_data_ptr = ptr::addr_of(&server_data);\n+            let server_data_ptr: *tcp_server_data = &server_data;\n             set_data_for_uv_handle(tcp_server_ptr as *libc::c_void,\n                                            server_data_ptr as *libc::c_void);\n \n@@ -1647,11 +1644,10 @@ mod test {\n             if (tcp_init_result == 0i32) {\n                 let server_addr = ip4_addr(server_ip, server_port);\n                 // FIXME ref #2064\n-                let server_addr_ptr = ptr::addr_of(&server_addr);\n+                let server_addr_ptr: *sockaddr_in = &server_addr;\n \n                 // uv_tcp_bind()\n-                let bind_result = tcp_bind(tcp_server_ptr,\n-                                                   server_addr_ptr);\n+                let bind_result = tcp_bind(tcp_server_ptr, server_addr_ptr);\n                 if (bind_result == 0i32) {\n                     debug!(~\"successful uv_tcp_bind, listening\");\n "}, {"sha": "9c309c1b9f9374d6b170220565286dbc81edb18c", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -75,10 +75,10 @@ impl gen_send for message {\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n                 body += fmt!(\"let %s = ::core::pipes::SendPacketBuffered(\\\n-                              ::ptr::addr_of(&(b.buffer.data.%s)));\\n\",\n+                              &(b.buffer.data.%s));\\n\",\n                              sp, next.name);\n                 body += fmt!(\"let %s = ::core::pipes::RecvPacketBuffered(\\\n-                              ::ptr::addr_of(&(b.buffer.data.%s)));\\n\",\n+                              &(b.buffer.data.%s));\\n\",\n                              rp, next.name);\n             }\n             else {\n@@ -365,9 +365,7 @@ impl gen_init for protocol {\n                     |s| ext_cx.parse_stmt(\n                         fmt!(\"data.%s.set_buffer(buffer)\",\n                              s.name))),\n-                ext_cx.parse_expr(\n-                    fmt!(\"::ptr::addr_of(&(data.%s))\",\n-                         self.states[0].name))));\n+                ext_cx.parse_expr(fmt!(\"&(data.%s)\", self.states[0].name))));\n \n         quote_expr!({\n             let buffer = $buffer;"}, {"sha": "20a1a586f44e6fa10cc549513165ad75af12a7b7", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -27,7 +27,7 @@ use core::io::WriterUtil;\n use core::comm::{Port, Chan, SharedChan};\n \n macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n+    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n )\n \n enum request {"}, {"sha": "a183738a968b9c6a485e7063d83e5e6b83c30e0d", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -23,7 +23,7 @@ use core::io::WriterUtil;\n use core::comm::{Port, PortSet, Chan, stream};\n \n macro_rules! move_out (\n-    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n+    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n )\n \n enum request {"}, {"sha": "14e955dd7bdae71fd1a823c13a5cdec7d8cb7c95", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -30,7 +30,7 @@ proto! ring (\n )\n \n macro_rules! move_out (\n-    ($x:expr) => { unsafe { let y = *ptr::addr_of(&$x); y } }\n+    ($x:expr) => { unsafe { let y = *ptr::to_unsafe_ptr(&$x); y } }\n )\n \n fn thread_ring(i: uint,"}, {"sha": "4a6e90f411686876d7ad1ce8fc436de50fbb61a6", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -44,7 +44,7 @@ proto! pingpong_unbounded (\n \n // This stuff should go in libcore::pipes\n macro_rules! move_it (\n-    { $x:expr } => { let t = *ptr::addr_of(&($x)); t }\n+    { $x:expr } => { let t = *ptr::to_unsafe_ptr(&($x)); t }\n )\n \n macro_rules! follow ("}, {"sha": "da13d450273ba380192764f5fb4420b2691fbe64", "filename": "src/test/compile-fail/issue-3096-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3096-2.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -11,6 +11,6 @@\n enum bottom { } \n \n fn main() {\n-    let x = ptr::addr_of(&()) as *bottom;\n+    let x = ptr::to_unsafe_ptr(&()) as *bottom;\n     match x { } //~ ERROR non-exhaustive patterns\n }"}, {"sha": "b89e22582bb3acfe27b7624cf1eedd52860758e8", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x : *~[int] = ptr::addr_of(&~[1,2,3]);\n+    let x : *~[int] = &~[1,2,3];\n     let y : *libc::c_void = x as *libc::c_void;\n     unsafe {\n         let _z = copy *y;"}, {"sha": "9c74e5688efc05a036291181d9e26455ee90810b", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -107,8 +107,8 @@ fn test_class() {\n   \n   unsafe {\n   error!(\"q = %x, r = %x\",\n-         (::core::cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(&q))),\n-         (::core::cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(&r))));\n+         (::core::cast::reinterpret_cast::<*p, uint>(& &q)),\n+         (::core::cast::reinterpret_cast::<*p, uint>(& &r)));\n   }\n   assert!((q == r));\n   r.y = 17;"}, {"sha": "d65a043bf47e943f7c97aa539a778a75bff0cd22", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -14,7 +14,7 @@ fn borrow(x: &int, f: &fn(x: &int)) {\n \n fn test1(x: @~int) {\n     do borrow(&*(*x).clone()) |p| {\n-        let x_a = ptr::addr_of(&(**x));\n+        let x_a = ptr::to_unsafe_ptr(&**x);\n         assert!((x_a as uint) != ptr::to_uint(p));\n         assert!(unsafe{*x_a} == *p);\n     }"}, {"sha": "db88646631357485c420ca01153ee484e9559416", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -17,13 +17,14 @@ pub fn main() {\n     match x {\n       @F {f: ref b_x} => {\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(**b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(**b_x)));\n \n         x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(**b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(**b_x)) as uint);\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(**b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n       }\n     }\n }"}, {"sha": "3c95054d10c9358f65ea0aca7653a3f616214383", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -23,11 +23,12 @@ pub fn main() {\n     let mut x = @F {f: ~3};\n     do borrow(x.f) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n         x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "ad0c5b69ba849b3669cdbaf25d8b8a3fba3b32fd", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -17,13 +17,14 @@ pub fn main() {\n     match x {\n       @@F{f: ref b_x} => {\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(x.f)) == ptr::addr_of(b_x));\n+        assert!(ptr::to_unsafe_ptr(&(x.f)) == ptr::to_unsafe_ptr(b_x));\n \n         *x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(**b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(**b_x)) as uint);\n         assert!(**b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(**b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(**b_x)));\n       }\n     }\n }"}, {"sha": "cce08ab235613fc014e7180375c3955879867329", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -23,11 +23,12 @@ pub fn main() {\n     let mut x = ~@F{f: ~3};\n     do borrow(x.f) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n         *x = @F{f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "104b0ae6bc551103311de1638cbf1a5db3efb9d0", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -21,11 +21,12 @@ pub fn main() {\n     let mut x = @3;\n     do borrow(x) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x)) == ptr::to_unsafe_ptr(&(*b_x)));\n         x = @22;\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "4c5b9f9bf1f82f8481eb70c657642e7e96eef7d6", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -23,11 +23,12 @@ pub fn main() {\n     let mut x = @F {f: ~3};\n     do borrow((*x).f) |b_x| {\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) == ptr::to_unsafe_ptr(&(*b_x)));\n         x = @F {f: ~4};\n \n-        debug!(\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(&(*b_x)) as uint);\n+        debug!(\"ptr::to_unsafe_ptr(*b_x) = %x\",\n+               ptr::to_unsafe_ptr(&(*b_x)) as uint);\n         assert!(*b_x == 3);\n-        assert!(ptr::addr_of(&(*x.f)) != ptr::addr_of(&(*b_x)));\n+        assert!(ptr::to_unsafe_ptr(&(*x.f)) != ptr::to_unsafe_ptr(&(*b_x)));\n     }\n }"}, {"sha": "5d20990a5a93b3b1f0ddc2e1fb6555bf61a86e5f", "filename": "src/test/run-pass/cap-clause-move.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcap-clause-move.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -10,22 +10,22 @@\n \n pub fn main() {\n     let x = ~1;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: @fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(lam_move() == y);\n \n     let x = ~2;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: @fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let lam_move: @fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(lam_move() == y);\n \n     let x = ~3;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let snd_move: ~fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let snd_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(snd_move() == y);\n \n     let x = ~4;\n-    let y = ptr::addr_of(&(*x)) as uint;\n-    let lam_move: ~fn() -> uint = || ptr::addr_of(&(*x)) as uint;\n+    let y = ptr::to_unsafe_ptr(&(*x)) as uint;\n+    let lam_move: ~fn() -> uint = || ptr::to_unsafe_ptr(&(*x)) as uint;\n     assert!(lam_move() == y);\n }"}, {"sha": "b8812649fd1c1884bd9dd5dd6d387dc4c34bca35", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -14,5 +14,5 @@ static x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n \n pub fn main() {\n-    assert!(ptr::addr_of(x) == ptr::addr_of(y.b));\n+    assert!(ptr::to_unsafe_ptr(x) == ptr::to_unsafe_ptr(y.b));\n }"}, {"sha": "a4fbfd4674885d43f315e4e8597d6f852c0f0c32", "filename": "src/test/run-pass/enum-alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fenum-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-alignment.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n fn addr_of<T>(ptr: &T) -> uint {\n-    let ptr = ptr::addr_of(ptr);\n+    let ptr = ptr::to_unsafe_ptr(ptr);\n     unsafe { ptr as uint }\n }\n \n fn is_aligned<T>(ptr: &T) -> bool {\n-    (addr_of(ptr) % sys::min_align_of::<T>()) == 0\n+    (to_unsafe_ptr(ptr) % sys::min_align_of::<T>()) == 0\n }\n \n pub fn main() {"}, {"sha": "f54d3d39831f4e797c3549c6f7c88b2de789768c", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -232,7 +232,7 @@ pub mod pingpong {\n     pub fn liberate_ping(+p: ping) -> ::pipes::send_packet<pong> {\n         unsafe {\n             let addr : *::pipes::send_packet<pong> = match &p {\n-              &ping(ref x) => { cast::transmute(ptr::addr_of(x)) }\n+              &ping(ref x) => { cast::transmute(x) }\n             };\n             let liberated_value = *addr;\n             cast::forget(p);\n@@ -243,7 +243,7 @@ pub mod pingpong {\n     pub fn liberate_pong(+p: pong) -> ::pipes::send_packet<ping> {\n         unsafe {\n             let addr : *::pipes::send_packet<ping> = match &p {\n-              &pong(ref x) => { cast::transmute(ptr::addr_of(x)) }\n+              &pong(ref x) => { cast::transmute(x) }\n             };\n             let liberated_value = *addr;\n             cast::forget(p);"}, {"sha": "c4ce1434165e36b098f68e15d1c4e00754c3329f", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -45,7 +45,7 @@ proto! bank (\n )\n \n macro_rules! move_it (\n-    { $x:expr } => { unsafe { let y = *ptr::addr_of(&($x)); y } }\n+    { $x:expr } => { unsafe { let y = *ptr::to_unsafe_ptr(&($x)); y } }\n )\n \n fn switch<T:Owned,U>(+endp: pipes::RecvPacket<T>,"}, {"sha": "6d82663d19560942d206957abc5522224216339c", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -40,7 +40,7 @@ mod pingpong {\n         do pipes::entangle_buffer(buffer) |buffer, data| {\n             data.ping.set_buffer(buffer);\n             data.pong.set_buffer(buffer);\n-            ptr::addr_of(&(data.ping))\n+            ptr::to_unsafe_ptr(&(data.ping))\n         }\n     }\n     pub struct ping(server::pong);\n@@ -53,8 +53,8 @@ mod pingpong {\n         pub fn ping(+pipe: ping) -> pong {\n             {\n                 let b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n-                let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.pong)));\n+                let s = SendPacketBuffered(&b.buffer.data.pong);\n+                let c = RecvPacketBuffered(&b.buffer.data.pong);\n                 let message = ::pingpong::ping(s);\n                 send(pipe, message);\n                 c\n@@ -75,8 +75,8 @@ mod pingpong {\n         pub fn pong(+pipe: pong) -> ping {\n             {\n                 let b = pipe.reuse_buffer();\n-                let s = SendPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n-                let c = RecvPacketBuffered(ptr::addr_of(&(b.buffer.data.ping)));\n+                let s = SendPacketBuffered(&b.buffer.data.ping);\n+                let c = RecvPacketBuffered(&b.buffer.data.ping);\n                 let message = ::pingpong::pong(s);\n                 send(pipe, message);\n                 c"}, {"sha": "e520d221c9935888053ed2a912f86ba4f6846444", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -642,7 +642,7 @@ struct Triple { x: int, y: int, z: int }\n pub fn main() {\n     unsafe {\n         let r = (1,2,3,true,false, Triple {x:5,y:4,z:3}, (12,));\n-        let p = ptr::addr_of(&r) as *c_void;\n+        let p = ptr::to_unsafe_ptr(&r) as *c_void;\n         let u = my_visitor(@mut Stuff {ptr1: p,\n                                        ptr2: p,\n                                        vals: ~[]});"}, {"sha": "5e0735cf31cd039d560dc24934a9c66240c8d4a7", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -18,8 +18,8 @@ impl Drop for r {\n     fn finalize(&self) {\n         unsafe {\n             debug!(\"r's dtor: self = %x, self.v = %x, self.v's value = %x\",\n-              cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(self)),\n-              cast::reinterpret_cast::<**int, uint>(&ptr::addr_of(&(self.v))),\n+              cast::reinterpret_cast::<*r, uint>(&self),\n+              cast::reinterpret_cast::<**int, uint>(& &(self.v)),\n               cast::reinterpret_cast::<*int, uint>(&self.v));\n             let v2: ~int = cast::reinterpret_cast(&self.v);\n         }\n@@ -54,28 +54,26 @@ pub fn main() {\n             next: None,\n               r: {\n               let rs = r(i1p);\n-              debug!(\"r = %x\",\n-                     cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n+              debug!(\"r = %x\", cast::reinterpret_cast::<*r, uint>(& &rs));\n               rs }\n         });\n         \n         debug!(\"x1 = %x, x1.r = %x\",\n             cast::reinterpret_cast::<@mut t, uint>(&x1),\n-            cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x1.r))));\n+            cast::reinterpret_cast::<*r, uint>(& &(x1.r)));\n \n         let mut x2 = @mut t(Node{\n             next: None,\n               r: {\n               let rs = r(i2p);\n-              debug!(\"r2 = %x\",\n-                     cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&rs)));\n+              debug!(\"r2 = %x\", cast::reinterpret_cast::<*r, uint>(& &rs));\n               rs\n                 }\n         });\n         \n         debug!(\"x2 = %x, x2.r = %x\",\n                cast::reinterpret_cast::<@mut t, uint>(&x2),\n-               cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(&(x2.r))));\n+               cast::reinterpret_cast::<*r, uint>(& &(x2.r)));\n \n         x1.next = Some(x2);\n         x2.next = Some(x1);"}, {"sha": "aaef027bd264323711d519c2c87ba681ea1e2708", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -48,7 +48,7 @@ pub fn main() {\n                 ch.send(());\n             }\n         };\n-        let fptr = cast::reinterpret_cast(&ptr::addr_of(&f));\n+        let fptr = cast::reinterpret_cast(& &f);\n         rustrt::start_task(new_task_id, fptr);\n         cast::forget(f);\n         po.recv();"}, {"sha": "3731f41f8f81cba22ea42858d13ebf2d5abe09bd", "filename": "src/test/run-pass/stable-addr-of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -12,5 +12,5 @@\n \n pub fn main() {\n     let foo = 1;\n-    assert!(ptr::addr_of(&foo) == ptr::addr_of(&foo));\n+    assert!(ptr::to_unsafe_ptr(&foo) == ptr::to_unsafe_ptr(&foo));\n }"}, {"sha": "a9c59de49eeaa8c7b947ff39f663223b447b3bf9", "filename": "src/test/run-pass/tag-align-dyn-u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-u64.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -24,7 +24,7 @@ fn mk_rec() -> t_rec {\n }\n \n fn is_8_byte_aligned(&&u: a_tag<u64>) -> bool {\n-    let p = ptr::addr_of(u) as uint;\n+    let p = ptr::to_unsafe_ptr(u) as uint;\n     return (p & 7u) == 0u;\n }\n "}, {"sha": "4fc6410f8f3d04553d6f8f75d120624d69958c02", "filename": "src/test/run-pass/tag-align-dyn-variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-dyn-variants.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -27,7 +27,7 @@ fn mk_rec<A:copy,B:copy>(a: A, b: B) -> t_rec<A,B> {\n }\n \n fn is_aligned<A>(amnt: uint, &&u: A) -> bool {\n-    let p = ptr::addr_of(u) as uint;\n+    let p = ptr::to_unsafe_ptr(u) as uint;\n     return (p & (amnt-1u)) == 0u;\n }\n "}, {"sha": "fd96d7d0242c3c92343fa9afc62d87f67c2fc36c", "filename": "src/test/run-pass/tag-align-u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -24,7 +24,7 @@ fn mk_rec() -> t_rec {\n }\n \n fn is_8_byte_aligned(&&u: a_tag) -> bool {\n-    let p = ptr::addr_of(u) as u64;\n+    let p = ptr::to_unsafe_ptr(u) as u64;\n     return (p & 7u64) == 0u64;\n }\n "}, {"sha": "7cd08695da0f04ba082e4359f7604f6993470881", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -26,7 +26,7 @@ impl Drop for notify {\n         unsafe {\n             error!(\"notify: task=%? v=%x unwinding=%b b=%b\",\n                    task::get_task(),\n-                   ptr::addr_of(&(*(self.v))) as uint,\n+                   ptr::to_unsafe_ptr(&(*(self.v))) as uint,\n                    task::failing(),\n                    *(self.v));\n             let b = *(self.v);\n@@ -47,7 +47,7 @@ fn joinable(f: ~fn()) -> Port<bool> {\n         let b = @mut false;\n         error!(\"wrapper: task=%? allocated v=%x\",\n                task::get_task(),\n-               ptr::addr_of(&(*b)) as uint);\n+               ptr::to_unsafe_ptr(&(*b)) as uint);\n         let _r = notify(c, b);\n         f();\n         *b = true;"}, {"sha": "ba10bfb670452c5aa8f6c39829c6410393d843b9", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -14,10 +14,10 @@ pub fn main() {\n     let (p, ch) = stream::<uint>();\n \n     let x = ~1;\n-    let x_in_parent = ptr::addr_of(&(*x)) as uint;\n+    let x_in_parent = ptr::to_unsafe_ptr(&(*x)) as uint;\n \n     task::spawn(|| {\n-        let x_in_child = ptr::addr_of(&(*x)) as uint;\n+        let x_in_child = ptr::to_unsafe_ptr(&(*x)) as uint;\n         ch.send(x_in_child);\n     });\n "}, {"sha": "7327f4a3498e0c17be8fe8f73ff9f492ba8a0f4a", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0522a497ccfcc7b124d77121d8f076af7f09b71/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=b0522a497ccfcc7b124d77121d8f076af7f09b71", "patch": "@@ -19,7 +19,7 @@ struct Pointy {\n }\n \n fn make_uniq_closure<A:Owned + Copy>(a: A) -> ~fn() -> uint {\n-    let result: ~fn() -> uint = || ptr::addr_of(&a) as uint;\n+    let result: ~fn() -> uint = || ptr::to_unsafe_ptr(&a) as uint;\n     result\n }\n "}]}