{"sha": "e1251f7b0045281123dcbb1ffc80320b324bd814", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMjUxZjdiMDA0NTI4MTEyM2RjYmIxZmZjODAzMjBiMzI0YmQ4MTQ=", "commit": {"author": {"name": "Paul Woolcock", "email": "pwoolcoc+github@gmail.com", "date": "2012-01-30T02:33:08Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-30T17:21:01Z"}, "message": "Change all ternary ops to if/then/else\n\nAll the files below had at least one instance of the ternary operator\npresent in the source.  All have been changed to the equivalent\nif/then/else expression.", "tree": {"sha": "3cfcc51c163d2450c41c2e59621131478ec9177f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cfcc51c163d2450c41c2e59621131478ec9177f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1251f7b0045281123dcbb1ffc80320b324bd814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1251f7b0045281123dcbb1ffc80320b324bd814", "html_url": "https://github.com/rust-lang/rust/commit/e1251f7b0045281123dcbb1ffc80320b324bd814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1251f7b0045281123dcbb1ffc80320b324bd814/comments", "author": null, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1f15a71e3dc1d24454594e068ed3df2271448e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f15a71e3dc1d24454594e068ed3df2271448e3", "html_url": "https://github.com/rust-lang/rust/commit/e1f15a71e3dc1d24454594e068ed3df2271448e3"}], "stats": {"total": 251, "additions": 183, "deletions": 68}, "files": [{"sha": "78ec0330dd96adb231f71ab5d46c66da3b6dda8b", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -333,7 +333,11 @@ fn host_triple() -> str {\n     // grabbing (at compile time) the target triple that this rustc is\n     // built with and calling that (at runtime) the host triple.\n     let ht = #env(\"CFG_HOST_TRIPLE\");\n-    ret ht != \"\" ? ht : fail \"rustc built without CFG_HOST_TRIPLE\";\n+    ret if ht != \"\" {\n+            ht\n+        } else {\n+            fail \"rustc built without CFG_HOST_TRIPLE\"\n+        };\n }\n \n fn build_session_options(match: getopts::match,"}, {"sha": "79ed35093261046a511823b22514896fe7d66402", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -244,7 +244,7 @@ fn mk_path(cx: test_ctxt, path: [ast::ident]) -> [ast::ident] {\n           _ { false }\n         }\n     };\n-    (is_std ? [] : [\"std\"]) + path\n+    (if is_std { [] } else { [\"std\"] }) + path\n }\n \n // The ast::ty of [std::test::test_desc]"}, {"sha": "0d4ecee7dea8f50e3e277a9f23fc406ce1332977", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -602,23 +602,26 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n           ast::pat_rec(fs, _) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             for f in fs {\n-                let m = ty::get_field(tcx, ty, f.ident).mt.mut != ast::imm;\n-                walk(tcx, m ? some(contains(ty)) : mut, f.pat, set);\n+                let m = ty::get_field(tcx, ty, f.ident).mt.mut != ast::imm,\n+                    c = if m { some(contains(ty)) } else { mut };\n+                walk(tcx, c, f.pat, set);\n             }\n           }\n           ast::pat_box(p) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             let m = alt ty::struct(tcx, ty) {\n               ty::ty_box(mt) { mt.mut != ast::imm }\n-            };\n-            walk(tcx, m ? some(contains(ty)) : mut, p, set);\n+            },\n+                c = if m  {some(contains(ty)) } else { mut };\n+            walk(tcx, c, p, set);\n           }\n           ast::pat_uniq(p) {\n             let ty = ty::node_id_to_type(tcx, pat.id);\n             let m = alt ty::struct(tcx, ty) {\n               ty::ty_uniq(mt) { mt.mut != ast::imm }\n-            };\n-            walk(tcx, m ? some(contains(ty)) : mut, p, set);\n+            },\n+                c = if m { some(contains(ty)) } else { mut };\n+            walk(tcx, c, p, set);\n           }\n         }\n     }"}, {"sha": "d04abffb3201dc297bc2d76ec6ac85c6f1f6c767", "filename": "src/comp/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_const.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -73,14 +73,14 @@ fn check_expr(sess: session, method_map: typeck::method_map, e: @expr,\n       expr_lit(@{node: lit_int(v, t), _}) {\n         if t != ty_char {\n             if (v as u64) > ast_util::int_ty_max(\n-                t == ty_i ? sess.targ_cfg.int_type : t) {\n+                if t == ty_i { sess.targ_cfg.int_type } else { t }) {\n                 sess.span_err(e.span, \"literal out of range for its type\");\n             }\n         }\n       }\n       expr_lit(@{node: lit_uint(v, t), _}) {\n         if v > ast_util::uint_ty_max(\n-            t == ty_u ? sess.targ_cfg.uint_type : t) {\n+            if t == ty_u { sess.targ_cfg.uint_type } else { t }) {\n             sess.span_err(e.span, \"literal out of range for its type\");\n         }\n       }"}, {"sha": "c16dedc1bd49295d217f641ab911cfd6daa89882", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -465,10 +465,16 @@ fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n                   lli64(align), // align\n                   lli64(offset), // offset\n                   lli32(0), // flags\n-                  option::is_none(derived) ? llnull() : // derived from\n-                                             option::get(derived),\n-                  option::is_none(members) ? llnull() : // members\n-                                             llmdnode(option::get(members)),\n+                  if option::is_none(derived) {\n+                      llnull()\n+                  } else { // derived from\n+                      option::get(derived)\n+                  },\n+                  if option::is_none(members) {\n+                      llnull()\n+                  } else { //members\n+                      llmdnode(option::get(members))\n+                  },\n                   lli32(0),  // runtime language\n                   llnull()\n                  ];\n@@ -776,7 +782,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        sp.lo);\n     let file_node = create_file(cx, loc.filename).node;\n-    let key = cx.item_symbols.contains_key(fcx.id) ? fcx.id : id;\n+    let key = if cx.item_symbols.contains_key(fcx.id) { fcx.id } else { id };\n     let mangled = cx.item_symbols.get(key);\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n         alt ret_ty.node {"}, {"sha": "2d3b9adc9bbc8d22d71dbff71277b5a8728d5674", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -1986,7 +1986,7 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n           _ {}\n         }\n     }\n-    let sc = vec::len(impls) > 0u ? cons(@impls, @sc) : sc;\n+    let sc = if vec::len(impls) > 0u { cons(@impls, @sc) } else { sc };\n     visit::visit_block(b, sc, v);\n }\n \n@@ -1998,8 +1998,11 @@ fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n     }\n     for i in m.items { find_impls_in_item(*e, i, impls, none, none); }\n     let impls = @impls;\n-    visit::visit_mod(m, s, id,\n-                     vec::len(*impls) > 0u ? cons(impls, @sc) : sc, v);\n+    visit::visit_mod(m, s, id, if vec::len(*impls) > 0u {\n+                                   cons(impls, @sc)\n+                               } else {\n+                                   sc\n+                               }, v);\n     e.impl_map.insert(id, cons(impls, @nil));\n }\n "}, {"sha": "9cd237828ffb363375a348c58d8b61c3cfa842c1", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -402,8 +402,11 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n     let col = pick_col(m);\n     let val = vals[col];\n-    let m = has_nested_bindings(m, col) ?\n-        expand_nested_bindings(m, col, val) : m;\n+    let m = if has_nested_bindings(m, col) {\n+                expand_nested_bindings(m, col, val)\n+            } else {\n+                m\n+            };\n \n     let vals_left =\n         vec::slice(vals, 0u, col) +\n@@ -493,7 +496,11 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n           lit(l) {\n             test_val = Load(bcx, val);\n             let pty = ty::node_id_to_type(ccx.tcx, pat_id);\n-            kind = ty::type_is_integral(ccx.tcx, pty) ? switch : compare;\n+            kind = if ty::type_is_integral(ccx.tcx, pty) {\n+                       switch\n+                   } else {\n+                       compare\n+                   };\n           }\n           range(_, _) {\n             test_val = Load(bcx, val);"}, {"sha": "2ac1ca102f599525743a99238aec164719819962", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -68,7 +68,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) ->\n         // that would obviate the need for this check\n         check non_ty_var(cx, arg_ty);\n         let llty = type_of_inner(cx, arg_ty);\n-        atys += [arg.mode == ast::by_val ? llty : T_ptr(llty)];\n+        atys += [if arg.mode == ast::by_val { llty } else { T_ptr(llty) }];\n     }\n     ret atys;\n }\n@@ -2015,8 +2015,11 @@ fn store_temp_expr(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     -> @block_ctxt {\n     // Lvals in memory are not temporaries. Copy them.\n     if src.kind != temporary && !last_use {\n-        let v = src.kind == owned ? load_if_immediate(cx, src.val, t)\n-                                  : src.val;\n+        let v = if src.kind == owned {\n+                    load_if_immediate(cx, src.val, t)\n+                } else {\n+                    src.val\n+                };\n         ret copy_val(cx, action, dst, v, t);\n     }\n     ret move_val(cx, action, dst, src, t);\n@@ -3417,7 +3420,7 @@ fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n     -> @block_ctxt {\n     let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n     let do_ignore = ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t);\n-    ret trans_expr(bcx, e, do_ignore ? ignore : save_in(dest));\n+    ret trans_expr(bcx, e, if do_ignore { ignore } else { save_in(dest) });\n }\n \n // Call this to compile an expression that you need as an intermediate value,\n@@ -4256,7 +4259,7 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n       some(e) {\n         let bt = ty::type_is_bot(bcx_tcx(bcx), ty::expr_ty(bcx_tcx(bcx), e));\n         debuginfo::update_source_pos(bcx, e.span);\n-        bcx = trans_expr(bcx, e, bt ? ignore : dest);\n+        bcx = trans_expr(bcx, e, if bt { ignore } else { dest });\n       }\n       _ { assert dest == ignore || bcx.unreachable; }\n     }\n@@ -4493,7 +4496,11 @@ fn trans_fn(cx: @local_ctxt, sp: span, decl: ast::fn_decl, body: ast::blk,\n             llfndecl: ValueRef, ty_self: self_arg, ty_params: [ast::ty_param],\n             id: ast::node_id) {\n     let do_time = cx.ccx.sess.opts.stats;\n-    let start = do_time ? time::get_time() : {sec: 0u32, usec: 0u32};\n+    let start = if do_time {\n+                    time::get_time()\n+                } else {\n+                    {sec: 0u32, usec: 0u32}\n+                };\n     let fcx = option::none;\n     trans_closure(cx, sp, decl, body, llfndecl, ty_self, ty_params, id,\n                   {|new_fcx| fcx = option::some(new_fcx);});\n@@ -5396,7 +5403,7 @@ fn decl_crate_map(sess: session::session, mapname: str,\n     let n_subcrates = 1;\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n-    let mapname = sess.building_library ? mapname : \"toplevel\";\n+    let mapname = if sess.building_library { mapname } else { \"toplevel\" };\n     let sym_name = \"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n     let maptype = T_struct([int_type, arrtype]);"}, {"sha": "0b7df351d7aa18d43b3a1ba1eeda5e1e49d8a6c9", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -149,9 +149,13 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let ccx = bcx_ccx(cx);\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n     let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n-    let (lhsptr, rhs) = !dynamic ? (lhsptr, rhs) :\n-        (PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type))),\n-         PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type)));\n+    let (lhsptr, rhs) =\n+        if !dynamic {\n+            (lhsptr, rhs)\n+        } else {\n+            (PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type))),\n+             PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type)))\n+        };\n     let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n       ty::ty_str { true }\n       ty::ty_vec(_) { false }\n@@ -187,7 +191,11 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n                              copy_val(bcx, INIT, write_ptr,\n                                       load_if_immediate(bcx, addr, unit_ty),\n                                       unit_ty);\n-                         let incr = dynamic ? unit_sz : C_int(ccx, 1);\n+                         let incr = if dynamic {\n+                                        unit_sz\n+                                    } else {\n+                                        C_int(ccx, 1)\n+                                    };\n                          Store(bcx, InBoundsGEP(bcx, write_ptr, [incr]),\n                                write_ptr_ptr);\n                          ret bcx;\n@@ -244,8 +252,11 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n         let incr =\n-            ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) ?\n-            llunitsz : C_int(ccx, 1);\n+            if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+                llunitsz\n+            } else {\n+                C_int(ccx, 1)\n+            };\n         Store(bcx, InBoundsGEP(bcx, write_ptr, [incr]),\n               write_ptr_ptr);\n         ret bcx;"}, {"sha": "567353bc0d9ce6a0a38100634f0841605b67884e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -1578,9 +1578,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             fcx.ccx.tcx.sess.span_err(\n                 sp, #fmt[\"this function takes %u parameter%s but %u \\\n                           parameter%s supplied\", expected_arg_count,\n-                         expected_arg_count == 1u ? \"\" : \"s\",\n+                         if expected_arg_count == 1u {\n+                             \"\"\n+                         } else {\n+                             \"s\"\n+                         },\n                          supplied_arg_count,\n-                         supplied_arg_count == 1u ? \" was\" : \"s were\"]);\n+                         if supplied_arg_count == 1u {\n+                             \" was\"\n+                         } else {\n+                             \"s were\"\n+                         }]);\n             // HACK: build an arguments list with dummy arguments to\n             // check against\n             let dummy = {mode: ast::by_ref, ty: ty::mk_bot(fcx.ccx.tcx)};"}, {"sha": "32df1e95fdd62726448c3071e162a81b847eb4a2", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -305,10 +305,42 @@ fn lit_to_const(lit: @lit) -> const_val {\n \n fn compare_const_vals(a: const_val, b: const_val) -> int {\n   alt (a, b) {\n-    (const_int(a), const_int(b)) { a == b ? 0 : a < b ? -1 : 1 }\n-    (const_uint(a), const_uint(b)) { a == b ? 0 : a < b ? -1 : 1 }\n-    (const_float(a), const_float(b)) { a == b ? 0 : a < b ? -1 : 1 }\n-    (const_str(a), const_str(b)) { a == b ? 0 : a < b ? -1 : 1 }\n+    (const_int(a), const_int(b)) {\n+        if a == b {\n+            0\n+        } else if a < b {\n+            -1\n+        } else {\n+            1\n+        }\n+    }\n+    (const_uint(a), const_uint(b)) {\n+        if a == b {\n+            0\n+        } else if a < b {\n+            -1\n+        } else {\n+            1\n+        }\n+    }\n+    (const_float(a), const_float(b)) {\n+        if a == b {\n+            0\n+        } else if a < b {\n+            -1\n+        } else {\n+            1\n+        }\n+    }\n+    (const_str(a), const_str(b)) {\n+        if a == b {\n+            0\n+        } else if a < b {\n+            -1\n+        } else {\n+            1\n+        }\n+    }\n   }\n }\n "}, {"sha": "c7c0f32cff92886786cf4ca85108568f68389b0a", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -197,31 +197,31 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n     c = rdr.curr;\n     n = rdr.next();\n     if c == 'u' || c == 'i' {\n-        let signed = c == 'i', tp = signed ? either::left(ast::ty_i)\n-                                           : either::right(ast::ty_u);\n+        let signed = c == 'i', tp = if signed { either::left(ast::ty_i) }\n+                                         else { either::right(ast::ty_u) };\n         rdr.bump();\n         c = rdr.curr;\n         if c == '8' {\n             rdr.bump();\n-            tp = signed ? either::left(ast::ty_i8)\n-                        : either::right(ast::ty_u8);\n+            tp = if signed { either::left(ast::ty_i8) }\n+                      else { either::right(ast::ty_u8) };\n         }\n         n = rdr.next();\n         if c == '1' && n == '6' {\n             rdr.bump();\n             rdr.bump();\n-            tp = signed ? either::left(ast::ty_i16)\n-                        : either::right(ast::ty_u16);\n+            tp = if signed { either::left(ast::ty_i16) }\n+                      else { either::right(ast::ty_u16) };\n         } else if c == '3' && n == '2' {\n             rdr.bump();\n             rdr.bump();\n-            tp = signed ? either::left(ast::ty_i32)\n-                        : either::right(ast::ty_u32);\n+            tp = if signed { either::left(ast::ty_i32) }\n+                      else { either::right(ast::ty_u32) };\n         } else if c == '6' && n == '4' {\n             rdr.bump();\n             rdr.bump();\n-            tp = signed ? either::left(ast::ty_i64)\n-                        : either::right(ast::ty_u64);\n+            tp = if signed { either::left(ast::ty_i64) }\n+                      else { either::right(ast::ty_u64) };\n         }\n         let parsed = u64::from_str(num_str, base as u64);\n         alt tp {"}, {"sha": "9678c69b1df35b8e8e7a879e8f9b818e01b5efdb", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -538,8 +538,11 @@ fn parse_arg(p: parser) -> ast::arg {\n fn parse_fn_block_arg(p: parser) -> ast::arg {\n     let m = parse_arg_mode(p);\n     let i = parse_value_ident(p);\n-    let t = eat(p, token::COLON) ? parse_ty(p, false) :\n-        @spanned(p.span.lo, p.span.hi, ast::ty_infer);\n+    let t = if eat(p, token::COLON) {\n+                parse_ty(p, false)\n+            } else {\n+                @spanned(p.span.lo, p.span.hi, ast::ty_infer)\n+            };\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n@@ -676,7 +679,12 @@ fn parse_path(p: parser) -> @ast::path {\n fn parse_path_and_ty_param_substs(p: parser, colons: bool) -> @ast::path {\n     let lo = p.span.lo;\n     let path = parse_path(p);\n-    if colons ? eat(p, token::MOD_SEP) : p.token == token::LT {\n+    let b = if colons {\n+                eat(p, token::MOD_SEP)\n+            } else {\n+                p.token == token::LT\n+            };\n+    if b {\n         let seq = parse_seq_lt_gt(some(token::COMMA),\n                                   {|p| parse_ty(p, false)}, p);\n         @spanned(lo, seq.span.hi, {types: seq.node with path.node})\n@@ -1504,7 +1512,11 @@ fn parse_pat(p: parser) -> @ast::pat {\n                         _ { true }\n                       } {\n             let name = parse_path(p);\n-            let sub = eat(p, token::AT) ? some(parse_pat(p)) : none;\n+            let sub = if eat(p, token::AT) {\n+                          some(parse_pat(p))\n+                      } else {\n+                          none\n+                      };\n             pat = ast::pat_ident(name, sub);\n         } else {\n             let enum_path = parse_path_and_ty_param_substs(p, true);\n@@ -1546,7 +1558,11 @@ fn parse_local(p: parser, allow_init: bool) -> @ast::local {\n \n fn parse_let(p: parser) -> @ast::decl {\n     fn parse_let_style(p: parser) -> ast::let_style {\n-        eat(p, token::BINOP(token::AND)) ? ast::let_ref : ast::let_copy\n+        if eat(p, token::BINOP(token::AND)) {\n+            ast::let_ref\n+        } else {\n+            ast::let_copy\n+        }\n     }\n     let lo = p.span.lo;\n     let locals = [(parse_let_style(p), parse_local(p, true))];\n@@ -1786,11 +1802,19 @@ fn parse_fn_decl(p: parser, purity: ast::purity)\n }\n \n fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n-    let inputs = eat(p, token::OROR) ? [] :\n-        parse_seq(token::BINOP(token::OR), token::BINOP(token::OR),\n-                  seq_sep(token::COMMA), parse_fn_block_arg, p).node;\n-    let output = eat(p, token::RARROW) ? parse_ty(p, false) :\n-        @spanned(p.span.lo, p.span.hi, ast::ty_infer);\n+    let inputs = if eat(p, token::OROR) {\n+                     []\n+                 } else {\n+                     parse_seq(token::BINOP(token::OR),\n+                               token::BINOP(token::OR),\n+                               seq_sep(token::COMMA),\n+                               parse_fn_block_arg, p).node\n+                 };\n+    let output = if eat(p, token::RARROW) {\n+                     parse_ty(p, false)\n+                 } else {\n+                     @spanned(p.span.lo, p.span.hi, ast::ty_infer)\n+                 };\n     ret {inputs: inputs,\n          output: output,\n          purity: ast::impure_fn,"}, {"sha": "dd563048293543f2dc4df3a1c1c5c4d8cdcc10aa", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -24,10 +24,10 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n        str {\n         let modestr = alt input.mode {\n           ast::by_ref {\n-            ty::type_is_immediate(cx, input.ty) ? \"&&\" : \"\"\n+            if ty::type_is_immediate(cx, input.ty) { \"&&\" } else { \"\" }\n           }\n           ast::by_val {\n-            ty::type_is_immediate(cx, input.ty) ? \"\" : \"++\"\n+            if ty::type_is_immediate(cx, input.ty) { \"\" } else { \"++\" }\n           }\n           _ { mode_str(input.mode) }\n         };"}, {"sha": "ffa56129d4f5ac13057fd8a98e5d88dfa1a28daa", "filename": "src/libcore/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -46,7 +46,7 @@ exact - Whether to enforce the exact number of significant digits\n */\n fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     if is_NaN(num) { ret \"NaN\"; }\n-    let (num, accum) = num < 0.0 ? (-num, \"-\") : (num, \"\");\n+    let (num, accum) = if num < 0.0 { (-num, \"-\") } else { (num, \"\") };\n     let trunc = num as uint;\n     let frac = num - (trunc as float);\n     accum += uint::str(trunc);"}, {"sha": "2552d58b4a2d6ff78ada202af8cbac422d6cefea", "filename": "src/libcore/math.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Flibcore%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Flibcore%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmath.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -7,14 +7,14 @@ Function: min\n \n Returns the minimum of two values\n */\n-pure fn min<T: copy>(x: T, y: T) -> T { x < y ? x : y }\n+pure fn min<T: copy>(x: T, y: T) -> T { if x < y { x } else { y} }\n \n /*\n Function: max\n \n Returns the maximum of two values\n */\n-pure fn max<T: copy>(x: T, y: T) -> T { x < y ? y : x }\n+pure fn max<T: copy>(x: T, y: T) -> T { if x < y { y } else { x } }\n \n #[test]\n fn test_max_min() {\n@@ -310,4 +310,4 @@ fn test_log_functions() {\n     assert ln1p(float::infinity) == float::infinity;\n }\n \n-*/\n\\ No newline at end of file\n+*/"}, {"sha": "1d6540f04e88ad69a811d6eaae370c89a109cc9d", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -65,7 +65,7 @@ fn md4(msg: [u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n \n         let j = 0u, q = 0x6ed9eba1u32;\n         while j < 8u {\n-            let jj = j > 2u ? j - 3u : j;\n+            let jj = if j > 2u { j - 3u } else { j };\n             a = rot(3, a + (b ^ c ^ d) + x[jj] + q);\n             d = rot(9, d + (a ^ b ^ c) + x[jj + 8u] + q);\n             c = rot(11, c + (d ^ a ^ b) + x[jj + 4u] + q);"}, {"sha": "d1a7a9b85acfc52c6747752236a4c674f9ca34c3", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1251f7b0045281123dcbb1ffc80320b324bd814/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=e1251f7b0045281123dcbb1ffc80320b324bd814", "patch": "@@ -24,7 +24,17 @@ fn test7() -> uint {\n     (*regs < 2) as uint\n }\n \n-fn test8() -> int { let val = @0; alt true { true { } } if *val < 1 { 0 } else { 1 } }\n+fn test8() -> int {\n+    let val = @0;\n+    alt true {\n+        true { }\n+    }\n+    if *val < 1 {\n+        0\n+    } else {\n+        1\n+    }\n+}\n \n fn test9() { let regs = @mutable 0; alt true { true { } } *regs += 1; }\n "}]}