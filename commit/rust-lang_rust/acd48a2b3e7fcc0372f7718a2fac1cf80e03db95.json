{"sha": "acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjZDQ4YTJiM2U3ZmNjMDM3MmY3NzE4YTJmYWMxY2Y4MGUwM2RiOTU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-27T18:12:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-30T21:08:40Z"}, "message": "std: Standardize (input, output) param orderings\n\nThis functions swaps the order of arguments to a few functions that previously\ntook (output, input) parameters, but now take (input, output) parameters (in\nthat order).\n\nThe affected functions are:\n\n* ptr::copy\n* ptr::copy_nonoverlapping\n* slice::bytes::copy_memory\n* intrinsics::copy\n* intrinsics::copy_nonoverlapping\n\nCloses #22890\n[breaking-change]", "tree": {"sha": "bf57c82936ee2c1e1df23edd0a750ec6aa75021d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf57c82936ee2c1e1df23edd0a750ec6aa75021d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "html_url": "https://github.com/rust-lang/rust/commit/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14192d6df5cc714e5c9a3ca70b08f2514d977be2", "url": "https://api.github.com/repos/rust-lang/rust/commits/14192d6df5cc714e5c9a3ca70b08f2514d977be2", "html_url": "https://github.com/rust-lang/rust/commit/14192d6df5cc714e5c9a3ca70b08f2514d977be2"}], "stats": {"total": 254, "additions": 147, "deletions": 107}, "files": [{"sha": "c6c86e46b444306de395553422060d277aa36d6a", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -301,7 +301,7 @@ mod imp {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n         } else {\n             let new_ptr = allocate(size, align);\n-            ptr::copy(new_ptr, ptr, cmp::min(size, old_size));\n+            ptr::copy(ptr, new_ptr, cmp::min(size, old_size));\n             deallocate(ptr, old_size, align);\n             new_ptr\n         }"}, {"sha": "847ee7c19ce94d7b7f8329938a9267c7418a4b36", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -1133,13 +1133,13 @@ impl<K, V> Node<K, V> {\n     #[inline]\n     unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n         ptr::copy(\n-            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n             self.keys().as_ptr().offset(index as isize),\n+            self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n             self.len() - index\n         );\n         ptr::copy(\n-            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n             self.vals().as_ptr().offset(index as isize),\n+            self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n             self.len() - index\n         );\n \n@@ -1155,8 +1155,8 @@ impl<K, V> Node<K, V> {\n     #[inline]\n     unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n         ptr::copy(\n-            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n             self.edges().as_ptr().offset(index as isize),\n+            self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n             self.len() - index\n         );\n         ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n@@ -1188,13 +1188,13 @@ impl<K, V> Node<K, V> {\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n         ptr::copy(\n-            self.keys_mut().as_mut_ptr().offset(index as isize),\n             self.keys().as_ptr().offset(index as isize + 1),\n+            self.keys_mut().as_mut_ptr().offset(index as isize),\n             self.len() - index - 1\n         );\n         ptr::copy(\n-            self.vals_mut().as_mut_ptr().offset(index as isize),\n             self.vals().as_ptr().offset(index as isize + 1),\n+            self.vals_mut().as_mut_ptr().offset(index as isize),\n             self.len() - index - 1\n         );\n \n@@ -1209,8 +1209,8 @@ impl<K, V> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n         ptr::copy(\n-            self.edges_mut().as_mut_ptr().offset(index as isize),\n             self.edges().as_ptr().offset(index as isize + 1),\n+            self.edges_mut().as_mut_ptr().offset(index as isize),\n             // index can be == len+1, so do the +1 first to avoid underflow.\n             (self.len() + 1) - index\n         );\n@@ -1237,19 +1237,19 @@ impl<K, V> Node<K, V> {\n             right._len = self.len() / 2;\n             let right_offset = self.len() - right.len();\n             ptr::copy_nonoverlapping(\n-                right.keys_mut().as_mut_ptr(),\n                 self.keys().as_ptr().offset(right_offset as isize),\n+                right.keys_mut().as_mut_ptr(),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping(\n-                right.vals_mut().as_mut_ptr(),\n                 self.vals().as_ptr().offset(right_offset as isize),\n+                right.vals_mut().as_mut_ptr(),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping(\n-                    right.edges_mut().as_mut_ptr(),\n                     self.edges().as_ptr().offset(right_offset as isize),\n+                    right.edges_mut().as_mut_ptr(),\n                     right.len() + 1\n                 );\n             }\n@@ -1278,19 +1278,19 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n             ptr::copy_nonoverlapping(\n-                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.keys().as_ptr(),\n+                self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.len()\n             );\n             ptr::copy_nonoverlapping(\n-                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.vals().as_ptr(),\n+                self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.len()\n             );\n             if !self.is_leaf() {\n                 ptr::copy_nonoverlapping(\n-                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.edges().as_ptr(),\n+                    self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.len() + 1\n                 );\n             }"}, {"sha": "0ca297765ff6d6fa82b5a5913a271c8324248197", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -1320,10 +1320,10 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n             if i != j {\n                 let tmp = ptr::read(read_ptr);\n-                ptr::copy(buf_v.offset(j + 1),\n-                          &*buf_v.offset(j),\n+                ptr::copy(&*buf_v.offset(j),\n+                          buf_v.offset(j + 1),\n                           (i - j) as usize);\n-                ptr::copy_nonoverlapping(buf_v.offset(j), &tmp, 1);\n+                ptr::copy_nonoverlapping(&tmp, buf_v.offset(j), 1);\n                 mem::forget(tmp);\n             }\n         }\n@@ -1396,10 +1396,10 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // j + 1 could be `len` (for the last `i`), but in\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n-                ptr::copy(buf_dat.offset(j + 1),\n-                          &*buf_dat.offset(j),\n+                ptr::copy(&*buf_dat.offset(j),\n+                          buf_dat.offset(j + 1),\n                           i - j as usize);\n-                ptr::copy_nonoverlapping(buf_dat.offset(j), read_ptr, 1);\n+                ptr::copy_nonoverlapping(read_ptr, buf_dat.offset(j), 1);\n             }\n         }\n     }\n@@ -1447,11 +1447,11 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     if left == right_start {\n                         // the number remaining in this run.\n                         let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(out, &*right, elems);\n+                        ptr::copy_nonoverlapping(&*right, out, elems);\n                         break;\n                     } else if right == right_end {\n                         let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(out, &*left, elems);\n+                        ptr::copy_nonoverlapping(&*left, out, elems);\n                         break;\n                     }\n \n@@ -1465,7 +1465,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     } else {\n                         step(&mut left)\n                     };\n-                    ptr::copy_nonoverlapping(out, &*to_copy, 1);\n+                    ptr::copy_nonoverlapping(&*to_copy, out, 1);\n                     step(&mut out);\n                 }\n             }\n@@ -1479,7 +1479,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // write the result to `v` in one go, so that there are never two copies\n     // of the same object in `v`.\n     unsafe {\n-        ptr::copy_nonoverlapping(v.as_mut_ptr(), &*buf_dat, len);\n+        ptr::copy_nonoverlapping(&*buf_dat, v.as_mut_ptr(), len);\n     }\n \n     // increment the pointer, returning the old pointer."}, {"sha": "923826a1bf0eefb86ea279724bb512b6b2232460", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -592,8 +592,8 @@ impl String {\n         let ch = self.char_at(idx);\n         let next = idx + ch.len_utf8();\n         unsafe {\n-            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n-                      self.vec.as_ptr().offset(next as isize),\n+            ptr::copy(self.vec.as_ptr().offset(next as isize),\n+                      self.vec.as_mut_ptr().offset(idx as isize),\n                       len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n@@ -622,11 +622,11 @@ impl String {\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n \n         unsafe {\n-            ptr::copy(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n-                      self.vec.as_ptr().offset(idx as isize),\n+            ptr::copy(self.vec.as_ptr().offset(idx as isize),\n+                      self.vec.as_mut_ptr().offset((idx + amt) as isize),\n                       len - idx);\n-            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n-                      bits.as_ptr(),\n+            ptr::copy(bits.as_ptr(),\n+                      self.vec.as_mut_ptr().offset(idx as isize),\n                       amt);\n             self.vec.set_len(len + amt);\n         }"}, {"sha": "3595288a6c94067d0126c23d74365932dc50913e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -260,16 +260,17 @@ impl<T> Vec<T> {\n \n     /// Creates a vector by copying the elements from a raw pointer.\n     ///\n-    /// This function will copy `elts` contiguous elements starting at `ptr` into a new allocation\n-    /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n-    /// without cloning, as if `ptr::read()` were called on them.\n+    /// This function will copy `elts` contiguous elements starting at `ptr`\n+    /// into a new allocation owned by the returned `Vec<T>`. The elements of\n+    /// the buffer are copied into the vector without cloning, as if\n+    /// `ptr::read()` were called on them.\n     #[inline]\n     #[unstable(feature = \"collections\",\n                reason = \"may be better expressed via composition\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n-        ptr::copy_nonoverlapping(dst.as_mut_ptr(), ptr, elts);\n+        ptr::copy_nonoverlapping(ptr, dst.as_mut_ptr(), elts);\n         dst\n     }\n \n@@ -288,8 +289,9 @@ impl<T> Vec<T> {\n         self.cap\n     }\n \n-    /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the given `Vec<T>`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -541,7 +543,7 @@ impl<T> Vec<T> {\n                 let p = self.as_mut_ptr().offset(index as isize);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n-                ptr::copy(p.offset(1), &*p, len - index);\n+                ptr::copy(&*p, p.offset(1), len - index);\n                 // Write it in, overwriting the first copy of the `index`th\n                 // element.\n                 ptr::write(&mut *p, element);\n@@ -579,7 +581,7 @@ impl<T> Vec<T> {\n                 ret = ptr::read(ptr);\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy(ptr, &*ptr.offset(1), len - index - 1);\n+                ptr::copy(&*ptr.offset(1), ptr, len - index - 1);\n             }\n             self.set_len(len - 1);\n             ret\n@@ -721,8 +723,8 @@ impl<T> Vec<T> {\n         let len = self.len();\n         unsafe {\n             ptr::copy_nonoverlapping(\n-                self.get_unchecked_mut(len),\n                 other.as_ptr(),\n+                self.get_unchecked_mut(len),\n                 other.len());\n         }\n \n@@ -1042,8 +1044,8 @@ impl<T> Vec<T> {\n             other.set_len(other_len);\n \n             ptr::copy_nonoverlapping(\n-                other.as_mut_ptr(),\n                 self.as_ptr().offset(at as isize),\n+                other.as_mut_ptr(),\n                 other.len());\n         }\n         other"}, {"sha": "abe8e7cf3aa0fd9de1df96657391104ac3b381f2", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -142,8 +142,8 @@ impl<T> VecDeque<T> {\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy(\n-            self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n+            self.ptr.offset(dst as isize),\n             len);\n     }\n \n@@ -155,8 +155,8 @@ impl<T> VecDeque<T> {\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n         ptr::copy_nonoverlapping(\n-            self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n+            self.ptr.offset(dst as isize),\n             len);\n     }\n }\n@@ -1361,21 +1361,21 @@ impl<T> VecDeque<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping(*other.ptr,\n-                                         first_half.as_ptr().offset(at as isize),\n+                ptr::copy_nonoverlapping(first_half.as_ptr().offset(at as isize),\n+                                         *other.ptr,\n                                          amount_in_first);\n \n                 // just take all of the second half.\n-                ptr::copy_nonoverlapping(other.ptr.offset(amount_in_first as isize),\n-                                         second_half.as_ptr(),\n+                ptr::copy_nonoverlapping(second_half.as_ptr(),\n+                                         other.ptr.offset(amount_in_first as isize),\n                                          second_len);\n             } else {\n                 // `at` lies in the second half, need to factor in the elements we skipped\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping(*other.ptr,\n-                                         second_half.as_ptr().offset(offset as isize),\n+                ptr::copy_nonoverlapping(second_half.as_ptr().offset(offset as isize),\n+                                         *other.ptr,\n                                          amount_in_second);\n             }\n         }"}, {"sha": "6a5943265ca88fee04ccecb1ba986b6d7ab85ad0", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -316,8 +316,8 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             impl<'a> fmt::Write for Filler<'a> {\n                 fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(&mut self.buf[(*self.end)..],\n-                                              s.as_bytes());\n+                    slice::bytes::copy_memory(s.as_bytes(),\n+                                              &mut self.buf[(*self.end)..]);\n                     *self.end += s.len();\n                     Ok(())\n                 }"}, {"sha": "43cf64bf3ad9dfbe2af6ec10269dd70c06aa7d94", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -293,9 +293,9 @@ extern \"rust-intrinsic\" {\n     ///         let mut t: T = mem::uninitialized();\n     ///\n     ///         // Perform the swap, `&mut` pointers never alias\n-    ///         ptr::copy_nonoverlapping(&mut t, &*x, 1);\n-    ///         ptr::copy_nonoverlapping(x, &*y, 1);\n-    ///         ptr::copy_nonoverlapping(y, &t, 1);\n+    ///         ptr::copy_nonoverlapping(x, &mut t, 1);\n+    ///         ptr::copy_nonoverlapping(y, x, 1);\n+    ///         ptr::copy_nonoverlapping(&t, y, 1);\n     ///\n     ///         // y and t now point to the same thing, but we need to completely forget `tmp`\n     ///         // because it's no longer relevant.\n@@ -304,6 +304,12 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// dox\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(stage0)]\n     pub fn copy_nonoverlapping<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -329,12 +335,18 @@ extern \"rust-intrinsic\" {\n     /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n     ///     dst.set_len(elts);\n-    ///     ptr::copy(dst.as_mut_ptr(), ptr, elts);\n+    ///     ptr::copy(ptr, dst.as_mut_ptr(), elts);\n     ///     dst\n     /// }\n     /// ```\n     ///\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(not(stage0))]\n+    pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n+\n+    /// dox\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[cfg(stage0)]\n     pub fn copy<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`"}, {"sha": "98e8668239bb8ee67e9aed5fcd3cce856c291838", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -229,9 +229,9 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n         let mut t: T = uninitialized();\n \n         // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping(&mut t, &*x, 1);\n-        ptr::copy_nonoverlapping(x, &*y, 1);\n-        ptr::copy_nonoverlapping(y, &t, 1);\n+        ptr::copy_nonoverlapping(&*x, &mut t, 1);\n+        ptr::copy_nonoverlapping(&*y, x, 1);\n+        ptr::copy_nonoverlapping(&t, y, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `t`\n         // because it's no longer relevant."}, {"sha": "41a70ef708f30d85a5a49ff63c175cad0ccdb826", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -104,11 +104,28 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n pub use intrinsics::copy_nonoverlapping;\n \n+/// dox\n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n+    intrinsics::copy_nonoverlapping(dst, src, count)\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n pub use intrinsics::copy;\n \n+/// dox\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n+    intrinsics::copy(dst, src, count)\n+}\n+\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::write_bytes;\n \n@@ -167,12 +184,11 @@ pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = mem::uninitialized();\n-    let t: *mut T = &mut tmp;\n \n     // Perform the swap\n-    copy_nonoverlapping(t, &*x, 1);\n-    copy(x, &*y, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping(y, &*t, 1);\n+    copy_nonoverlapping(x, &mut tmp, 1);\n+    copy(y, x, 1); // `x` and `y` may overlap\n+    copy_nonoverlapping(&tmp, y, 1);\n \n     // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant.\n@@ -208,7 +224,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n-    copy_nonoverlapping(&mut tmp, src, 1);\n+    copy_nonoverlapping(src, &mut tmp, 1);\n     tmp\n }\n "}, {"sha": "223a0bdae36cd8c3cebe763a4192e2950732c4e6", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -1577,14 +1577,14 @@ pub mod bytes {\n     ///\n     /// Panics if the length of `dst` is less than the length of `src`.\n     #[inline]\n-    pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n+    pub fn copy_memory(src: &[u8], dst: &mut [u8]) {\n         let len_src = src.len();\n         assert!(dst.len() >= len_src);\n         // `dst` is unaliasable, so we know statically it doesn't overlap\n         // with `src`.\n         unsafe {\n-            ptr::copy_nonoverlapping(dst.as_mut_ptr(),\n-                                     src.as_ptr(),\n+            ptr::copy_nonoverlapping(src.as_ptr(),\n+                                     dst.as_mut_ptr(),\n                                      len_src);\n         }\n     }"}, {"sha": "8f1017c50a39d318b76152ffd7913294cae344d2", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -35,18 +35,15 @@ fn test() {\n         let v0 = vec![32000u16, 32001u16, 32002u16];\n         let mut v1 = vec![0u16, 0u16, 0u16];\n \n-        copy(v1.as_mut_ptr().offset(1),\n-             v0.as_ptr().offset(1), 1);\n+        copy(v0.as_ptr().offset(1), v1.as_mut_ptr().offset(1), 1);\n         assert!((v1[0] == 0u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 0u16));\n-        copy(v1.as_mut_ptr(),\n-             v0.as_ptr().offset(2), 1);\n+        copy(v0.as_ptr().offset(2), v1.as_mut_ptr(), 1);\n         assert!((v1[0] == 32002u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 0u16));\n-        copy(v1.as_mut_ptr().offset(2),\n-             v0.as_ptr(), 1);\n+        copy(v0.as_ptr(), v1.as_mut_ptr().offset(2), 1);\n         assert!((v1[0] == 32002u16 &&\n                  v1[1] == 32001u16 &&\n                  v1[2] == 32000u16));"}, {"sha": "80341fa1a7a2f886f904fc96cd9e9da46750e60b", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -449,21 +449,21 @@ pub mod reader {\n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2);\n         let mut b = [0; 2];\n-        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n         unsafe { (*(b.as_ptr() as *const u16)).to_be() }\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4);\n         let mut b = [0; 4];\n-        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n         unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8);\n         let mut b = [0; 8];\n-        bytes::copy_memory(&mut b, &d.data[d.start..d.end]);\n+        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n         unsafe { (*(b.as_ptr() as *const u64)).to_be() }\n     }\n \n@@ -938,7 +938,7 @@ pub mod writer {\n                 {\n                     let last_size_pos = last_size_pos as usize;\n                     let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as usize];\n-                    bytes::copy_memory(&mut buf, data);\n+                    bytes::copy_memory(data, &mut buf);\n                 }\n \n                 // overwrite the size and data and continue"}, {"sha": "1cff7c448a96277892835fe32a8c8c91ae17836a", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -62,7 +62,7 @@ pub type Cmd<'a> = &'a crate_metadata;\n \n fn u32_from_be_bytes(bytes: &[u8]) -> u32 {\n     let mut b = [0; 4];\n-    bytes::copy_memory(&mut b, &bytes[..4]);\n+    bytes::copy_memory(&bytes[..4], &mut b);\n     unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n }\n "}, {"sha": "f0e1427e6db60a80a258a62a7719c754663239de", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -139,15 +139,15 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        &mut self.buffer[self.buffer_idx..size],\n-                        &input[..buffer_remaining]);\n+                        &input[..buffer_remaining],\n+                        &mut self.buffer[self.buffer_idx..size]);\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    &mut self.buffer[self.buffer_idx..self.buffer_idx + input.len()],\n-                    input);\n+                    input,\n+                    &mut self.buffer[self.buffer_idx..self.buffer_idx + input.len()]);\n                 self.buffer_idx += input.len();\n                 return;\n             }\n@@ -165,8 +165,8 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            &mut self.buffer[..input_remaining],\n-            &input[i..]);\n+            &input[i..],\n+            &mut self.buffer[..input_remaining]);\n         self.buffer_idx += input_remaining;\n     }\n "}, {"sha": "62a6ede4c2f936bdcdefaec91e8e21c5e12cca96", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -398,8 +398,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                            false,\n                            false,\n                            *substs.types.get(FnSpace, 0),\n-                           llargs[0],\n                            llargs[1],\n+                           llargs[0],\n                            llargs[2],\n                            call_debug_location)\n         }\n@@ -408,8 +408,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                            true,\n                            false,\n                            *substs.types.get(FnSpace, 0),\n-                           llargs[0],\n                            llargs[1],\n+                           llargs[0],\n                            llargs[2],\n                            call_debug_location)\n         }"}, {"sha": "7f2f48c0748bf817745f3d032dbbe4f6dc2af39a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -5417,7 +5417,21 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                    mutbl: ast::MutImmutable\n                }))\n             }\n-            \"copy\" | \"copy_nonoverlapping\" |\n+            \"copy\" | \"copy_nonoverlapping\" => {\n+              (1,\n+               vec!(\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.types.usize,\n+               ),\n+               ty::mk_nil(tcx))\n+            }\n             \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n               (1,\n                vec!("}, {"sha": "aa3195cbf018b2e43178fc19968d4da6db1641c1", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -480,8 +480,8 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            ptr::copy_nonoverlapping(self.gap.raw.key, self.full.raw.key, 1);\n-            ptr::copy_nonoverlapping(self.gap.raw.val, self.full.raw.val, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.key, self.gap.raw.key, 1);\n+            ptr::copy_nonoverlapping(self.full.raw.val, self.gap.raw.val, 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;"}, {"sha": "8eea06bf6b0c729f672d0bff9ebbc4843bf277b4", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -177,8 +177,8 @@ impl<W: Write> BufWriter<W> {\n         if written > 0 {\n             // NB: would be better expressed as .remove(0..n) if it existed\n             unsafe {\n-                ptr::copy(self.buf.as_mut_ptr(),\n-                          self.buf.as_ptr().offset(written as isize),\n+                ptr::copy(self.buf.as_ptr().offset(written as isize),\n+                          self.buf.as_mut_ptr(),\n                           len - written);\n             }\n         }"}, {"sha": "c8a41beecbc2248d78cf5178954eb0c1a4a1b41f", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -151,7 +151,7 @@ impl Write for Cursor<Vec<u8>> {\n         // there (left), and what will be appended on the end (right)\n         let space = self.inner.len() - pos as usize;\n         let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n-        slice::bytes::copy_memory(&mut self.inner[(pos as usize)..], left);\n+        slice::bytes::copy_memory(left, &mut self.inner[(pos as usize)..]);\n         self.inner.push_all(right);\n \n         // Bump us forward"}, {"sha": "52daba362131eda7392c0d0c71e49faa5350ff49", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -149,7 +149,7 @@ impl<'a> Read for &'a [u8] {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let amt = cmp::min(buf.len(), self.len());\n         let (a, b) = self.split_at(amt);\n-        slice::bytes::copy_memory(buf, a);\n+        slice::bytes::copy_memory(a, buf);\n         *self = b;\n         Ok(amt)\n     }\n@@ -170,7 +170,7 @@ impl<'a> Write for &'a mut [u8] {\n     fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n         let amt = cmp::min(data.len(), self.len());\n         let (a, b) = mem::replace(self, &mut []).split_at_mut(amt);\n-        slice::bytes::copy_memory(a, &data[..amt]);\n+        slice::bytes::copy_memory(&data[..amt], a);\n         *self = b;\n         Ok(amt)\n     }"}, {"sha": "ad6cac621733b815472affd508d80c5210ddf09f", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -118,7 +118,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, &available[..nread]);\n+            slice::bytes::copy_memory(&available[..nread], buf);\n             nread\n         };\n         self.pos += nread;\n@@ -225,7 +225,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n             self.inner.as_mut().unwrap().write_all(buf)\n         } else {\n             let dst = &mut self.buf[self.pos..];\n-            slice::bytes::copy_memory(dst, buf);\n+            slice::bytes::copy_memory(buf, dst);\n             self.pos += buf.len();\n             Ok(())\n         }"}, {"sha": "5ebf931e95c375f60f2358faae6b3112b756c3a8", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -91,7 +91,7 @@ impl Reader for ChanReader {\n                 Some(src) => {\n                     let dst = &mut buf[num_read..];\n                     let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(dst, &src[..count]);\n+                    bytes::copy_memory(&src[..count], dst);\n                     count\n                 },\n                 None => 0,"}, {"sha": "0e5dd3aa4aac2862fca5478d305b3d7dc2304de1", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -171,7 +171,7 @@ pub fn u64_from_be_bytes(data: &[u8], start: usize, size: usize) -> u64 {\n     unsafe {\n         let ptr = data.as_ptr().offset(start as isize);\n         let out = buf.as_mut_ptr();\n-        copy_nonoverlapping(out.offset((8 - size) as isize), ptr, size);\n+        copy_nonoverlapping(ptr, out.offset((8 - size) as isize), size);\n         (*(out as *const u64)).to_be()\n     }\n }"}, {"sha": "64803191d4f14e7a51235d62c2de629665240385", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -168,7 +168,7 @@ impl Reader for MemReader {\n             let input = &self.buf[self.pos.. self.pos + write_len];\n             let output = &mut buf[..write_len];\n             assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(input, output);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());\n@@ -212,7 +212,7 @@ impl<'a> Reader for &'a [u8] {\n         {\n             let input = &self[..write_len];\n             let output = &mut buf[.. write_len];\n-            slice::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(input, output);\n         }\n \n         *self = &self[write_len..];\n@@ -287,13 +287,13 @@ impl<'a> Writer for BufWriter<'a> {\n         let src_len = src.len();\n \n         if dst_len >= src_len {\n-            slice::bytes::copy_memory(dst, src);\n+            slice::bytes::copy_memory(src, dst);\n \n             self.pos += src_len;\n \n             Ok(())\n         } else {\n-            slice::bytes::copy_memory(dst, &src[..dst_len]);\n+            slice::bytes::copy_memory(&src[..dst_len], dst);\n \n             self.pos += dst_len;\n \n@@ -360,7 +360,7 @@ impl<'a> Reader for BufReader<'a> {\n             let input = &self.buf[self.pos.. self.pos + write_len];\n             let output = &mut buf[..write_len];\n             assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(output, input);\n+            slice::bytes::copy_memory(input, output);\n         }\n         self.pos += write_len;\n         assert!(self.pos <= self.buf.len());"}, {"sha": "8f788988e557adfd7f8cfe481a397b9a4b03492a", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -344,8 +344,8 @@ impl Wtf8Buf {\n                 Some((surrogate_pos, _)) => {\n                     pos = surrogate_pos + 3;\n                     slice::bytes::copy_memory(\n+                        UTF8_REPLACEMENT_CHARACTER,\n                         &mut self.bytes[surrogate_pos .. pos],\n-                        UTF8_REPLACEMENT_CHARACTER\n                     );\n                 },\n                 None => return unsafe { String::from_utf8_unchecked(self.bytes) }"}, {"sha": "7c4cc0eaab7ce403267064511da85cb858aedba3", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -126,10 +126,9 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n         let mut buf = repeat(0).take(alu_len + LINE_LEN).collect::<Vec<_>>();\n         let alu: &[u8] = self.alu.as_bytes();\n \n-        copy_memory(&mut buf, alu);\n+        copy_memory(alu, &mut buf);\n         let buf_len = buf.len();\n-        copy_memory(&mut buf[alu_len..buf_len],\n-                    &alu[..LINE_LEN]);\n+        copy_memory(&alu[..LINE_LEN], &mut buf[alu_len..buf_len]);\n \n         let mut pos = 0;\n         let mut bytes;"}, {"sha": "cda90c08f23ad121df4e70b0565e7d83ebeae794", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -181,8 +181,8 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n     let mut i = LINE_LEN;\n     while i < len {\n         unsafe {\n-            copy(seq.as_mut_ptr().offset((i - off + 1) as isize),\n-                 seq.as_ptr().offset((i - off) as isize), off);\n+            copy(seq.as_ptr().offset((i - off) as isize),\n+                 seq.as_mut_ptr().offset((i - off + 1) as isize), off);\n             *seq.get_unchecked_mut(i - off) = b'\\n';\n         }\n         i += LINE_LEN + 1;"}, {"sha": "7cc762c93482665fac08891ed2119e393f2f98b5", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acd48a2b3e7fcc0372f7718a2fac1cf80e03db95/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=acd48a2b3e7fcc0372f7718a2fac1cf80e03db95", "patch": "@@ -26,7 +26,7 @@ trait MyWriter {\n \n impl<'a> MyWriter for &'a mut [u8] {\n     fn my_write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        slice::bytes::copy_memory(*self, buf);\n+        slice::bytes::copy_memory(buf, *self);\n \n         let write_len = buf.len();\n         unsafe {"}]}