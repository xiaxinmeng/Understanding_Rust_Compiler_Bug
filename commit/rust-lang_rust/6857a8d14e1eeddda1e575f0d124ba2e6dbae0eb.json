{"sha": "6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "node_id": "C_kwDOAAsO6NoAKDY4NTdhOGQxNGUxZWVkZGRhMWU1NzVmMGQxMjRiYTJlNmRiYWUwZWI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-20T18:13:42Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-27T20:03:12Z"}, "message": "Create a specific struct for lifetime capture.", "tree": {"sha": "1a448ab443783b11f8513cb3ffe0eaffb2d3aa60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a448ab443783b11f8513cb3ffe0eaffb2d3aa60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "html_url": "https://github.com/rust-lang/rust/commit/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a621b8499f61edfda48a87b993dde07e34d67998", "url": "https://api.github.com/repos/rust-lang/rust/commits/a621b8499f61edfda48a87b993dde07e34d67998", "html_url": "https://github.com/rust-lang/rust/commit/a621b8499f61edfda48a87b993dde07e34d67998"}], "stats": {"total": 311, "additions": 172, "deletions": 139}, "files": [{"sha": "096cacff9106d6a793a0947019b1720b097bfb6a", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 147, "deletions": 112, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "patch": "@@ -32,6 +32,7 @@\n \n #![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n@@ -135,24 +136,8 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n     in_scope_lifetimes: Vec<(ParamName, LocalDefId)>,\n \n-    /// Used to handle lifetimes appearing in impl-traits.  When we lower a lifetime,\n-    /// it is inserted in the `FxHashMap`, and the resolution is modified so to point\n-    /// to the lifetime parameter impl-trait will generate.\n-    /// When traversing `for<...>` binders, they are inserted in the `FxHashSet` so\n-    /// we know *not* to rebind the introduced lifetimes.\n-    captured_lifetimes: Option<(\n-        LocalDefId, // parent def_id for new definitions\n-        FxHashMap<\n-            LocalDefId, // original parameter id\n-            (\n-                Span,        // Span\n-                NodeId,      // synthetized parameter id\n-                ParamName,   // parameter name\n-                LifetimeRes, // original resolution\n-            ),\n-        >,\n-        FxHashSet<NodeId>, // traversed binders, to ignore\n-    )>,\n+    /// Used to handle lifetimes appearing in impl-traits.\n+    captured_lifetimes: Option<LifetimeCaptureContext>,\n \n     current_hir_id_owner: LocalDefId,\n     item_local_id_counter: hir::ItemLocalId,\n@@ -179,6 +164,9 @@ pub enum LifetimeRes {\n         /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n         /// - a BareFn type's id;\n         /// - a Path's id when this path has parenthesized generic args.\n+        ///\n+        /// This information is used for impl-trait lifetime captures, to know when to or not to\n+        /// capture any given lifetime.\n         binder: NodeId,\n     },\n     /// Created a generic parameter for an anonymous lifetime.\n@@ -206,6 +194,28 @@ pub enum LifetimeRes {\n     ElidedAnchor { start: NodeId, end: NodeId },\n }\n \n+/// When we lower a lifetime, it is inserted in `captures`, and the resolution is modified so\n+/// to point to the lifetime parameter impl-trait will generate.\n+/// When traversing `for<...>` binders, they are inserted in `binders_to_ignore` so we know *not*\n+/// to rebind the introduced lifetimes.\n+#[derive(Debug)]\n+struct LifetimeCaptureContext {\n+    /// parent def_id for new definitions\n+    parent_def_id: LocalDefId,\n+    /// Set of lifetimes to rebind.\n+    captures: FxHashMap<\n+        LocalDefId, // original parameter id\n+        (\n+            Span,        // Span\n+            NodeId,      // synthetized parameter id\n+            ParamName,   // parameter name\n+            LifetimeRes, // original resolution\n+        ),\n+    >,\n+    /// Traversed binders.  The ids in this set should *not* be rebound.\n+    binders_to_ignore: FxHashSet<NodeId>,\n+}\n+\n pub trait ResolverAstLowering {\n     fn def_key(&self, id: DefId) -> DefKey;\n \n@@ -790,6 +800,45 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         (lowered_generics, res)\n     }\n \n+    /// Setup lifetime capture for and impl-trait.\n+    /// The captures will be added to `captures`.\n+    fn while_capturing_lifetimes<T>(\n+        &mut self,\n+        parent_def_id: LocalDefId,\n+        captures: &mut FxHashMap<LocalDefId, (Span, NodeId, ParamName, LifetimeRes)>,\n+        f: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        let lifetime_stash = std::mem::replace(\n+            &mut self.captured_lifetimes,\n+            Some(LifetimeCaptureContext {\n+                parent_def_id,\n+                captures: std::mem::take(captures),\n+                binders_to_ignore: Default::default(),\n+            }),\n+        );\n+\n+        let ret = f(self);\n+\n+        let ctxt = std::mem::replace(&mut self.captured_lifetimes, lifetime_stash).unwrap();\n+        *captures = ctxt.captures;\n+\n+        ret\n+    }\n+\n+    /// Register a binder to be ignored for lifetime capture.\n+    #[tracing::instrument(level = \"debug\", skip(self, f))]\n+    #[inline]\n+    fn with_lifetime_binder<T>(&mut self, binder: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n+        if let Some(ctxt) = &mut self.captured_lifetimes {\n+            ctxt.binders_to_ignore.insert(binder);\n+        }\n+        let ret = f(self);\n+        if let Some(ctxt) = &mut self.captured_lifetimes {\n+            ctxt.binders_to_ignore.remove(&binder);\n+        }\n+        ret\n+    }\n+\n     fn with_dyn_type_scope<T>(&mut self, in_scope: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n         let was_in_dyn_type = self.is_in_dyn_type;\n         self.is_in_dyn_type = in_scope;\n@@ -1197,25 +1246,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(&f.generic_params, |this| {\n-                if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n-                    binders.insert(t.id);\n-                }\n-\n-                let ret = hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                    generic_params: this.lower_generic_params(\n-                        &f.generic_params,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n-                    unsafety: this.lower_unsafety(f.unsafety),\n-                    abi: this.lower_extern(f.ext),\n-                    decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n-                    param_names: this.lower_fn_params_to_names(&f.decl),\n-                }));\n-\n-                if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n-                    binders.remove(&t.id);\n-                }\n-                ret\n+                this.with_lifetime_binder(t.id, |this| {\n+                    hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n+                        generic_params: this.lower_generic_params(\n+                            &f.generic_params,\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                        ),\n+                        unsafety: this.lower_unsafety(f.unsafety),\n+                        abi: this.lower_extern(f.ext),\n+                        decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                        param_names: this.lower_fn_params_to_names(&f.decl),\n+                    }))\n+                })\n             }),\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => {\n@@ -1366,15 +1408,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let mut collected_lifetimes = FxHashMap::default();\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n-            let capture_framework = if origin == hir::OpaqueTyOrigin::TyAlias {\n-                None\n+            let hir_bounds = if origin == hir::OpaqueTyOrigin::TyAlias {\n+                lower_bounds(lctx)\n             } else {\n-                Some((opaque_ty_def_id, FxHashMap::default(), FxHashSet::default()))\n+                lctx.while_capturing_lifetimes(\n+                    opaque_ty_def_id,\n+                    &mut collected_lifetimes,\n+                    lower_bounds,\n+                )\n             };\n-            let lifetime_stash = std::mem::replace(&mut lctx.captured_lifetimes, capture_framework);\n-            let hir_bounds = lower_bounds(lctx);\n-            collected_lifetimes = std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash)\n-                .map_or_else(FxHashMap::default, |c| c.1);\n             debug!(?collected_lifetimes);\n \n             let lifetime_defs = lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(\n@@ -1716,24 +1758,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(?captures);\n \n         self.with_hir_id_owner(opaque_ty_node_id, |this| {\n-            let lifetime_stash = std::mem::replace(\n-                &mut this.captured_lifetimes,\n-                Some((opaque_ty_def_id, std::mem::take(&mut captures), FxHashSet::default())),\n-            );\n             debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n-\n-            // We have to be careful to get elision right here. The\n-            // idea is that we create a lifetime parameter for each\n-            // lifetime in the return type.  So, given a return type\n-            // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n-            // Future<Output = &'1 [ &'2 u32 ]>`.\n-            //\n-            // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n-            // hence the elision takes place at the fn site.\n             let future_bound =\n-                this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span);\n+                this.while_capturing_lifetimes(opaque_ty_def_id, &mut captures, |this| {\n+                    // We have to be careful to get elision right here. The\n+                    // idea is that we create a lifetime parameter for each\n+                    // lifetime in the return type.  So, given a return type\n+                    // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n+                    // Future<Output = &'1 [ &'2 u32 ]>`.\n+                    //\n+                    // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n+                    // hence the elision takes place at the fn site.\n+                    this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n+                });\n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n-            captures = std::mem::replace(&mut this.captured_lifetimes, lifetime_stash).unwrap().1;\n             debug!(\"lower_async_fn_ret_ty: captures={:#?}\", captures);\n \n             let generic_params =\n@@ -1882,22 +1920,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Param { param, binder } => {\n                 debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n                 let p_name = ParamName::Plain(ident);\n-                if let Some((parent_def_id, captures, binders)) = &mut self.captured_lifetimes {\n+                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n+                    &mut self.captured_lifetimes\n+                    && !binders_to_ignore.contains(&binder)\n+                {\n                     match captures.entry(param) {\n                         Entry::Occupied(_) => {}\n                         Entry::Vacant(v) => {\n-                            if !binders.contains(&binder) {\n-                                let p_id = self.resolver.next_node_id();\n-                                self.resolver.create_def(\n-                                    *parent_def_id,\n-                                    p_id,\n-                                    DefPathData::LifetimeNs(p_name.ident().name),\n-                                    ExpnId::root(),\n-                                    span.with_parent(None),\n-                                );\n-\n-                                v.insert((span, p_id, p_name, res));\n-                            }\n+                            let p_id = self.resolver.next_node_id();\n+                            self.resolver.create_def(\n+                                *parent_def_id,\n+                                p_id,\n+                                DefPathData::LifetimeNs(p_name.ident().name),\n+                                ExpnId::root(),\n+                                span.with_parent(None),\n+                            );\n+\n+                            v.insert((span, p_id, p_name, res));\n                         }\n                     }\n                 }\n@@ -1908,24 +1947,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Only items are allowed to introduce fresh lifetimes,\n                 // so we know `binder` has a `LocalDefId`.\n                 let binder_def_id = self.resolver.local_def_id(binder);\n-                if let Some((parent_def_id, captures, binders)) = &mut self.captured_lifetimes {\n+                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n+                    &mut self.captured_lifetimes\n+                    && !binders_to_ignore.contains(&binder)\n+                {\n                     match captures.entry(param) {\n                         Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n                         Entry::Vacant(v) => {\n-                            if !binders.contains(&binder) {\n-                                let p_id = self.resolver.next_node_id();\n-                                let p_def_id = self.resolver.create_def(\n-                                    *parent_def_id,\n-                                    p_id,\n-                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                                    ExpnId::root(),\n-                                    span.with_parent(None),\n-                                );\n-\n-                                let p_name = ParamName::Fresh(param);\n-                                v.insert((span, p_id, p_name, res));\n-                                param = p_def_id;\n-                            }\n+                            let p_id = self.resolver.next_node_id();\n+                            let p_def_id = self.resolver.create_def(\n+                                *parent_def_id,\n+                                p_id,\n+                                DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                ExpnId::root(),\n+                                span.with_parent(None),\n+                            );\n+\n+                            let p_name = ParamName::Fresh(param);\n+                            v.insert((span, p_id, p_name, res));\n+                            param = p_def_id;\n                         }\n                     }\n                 } else if let Some(introducer) = introducer {\n@@ -1948,21 +1988,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 } else {\n                     hir::LifetimeName::Underscore\n                 };\n-                match &mut self.captured_lifetimes {\n-                    Some((parent_def_id, captures, binders)) if !binders.contains(&binder) => {\n-                        let p_id = self.resolver.next_node_id();\n-                        let p_def_id = self.resolver.create_def(\n-                            *parent_def_id,\n-                            p_id,\n-                            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                            ExpnId::root(),\n-                            span.with_parent(None),\n-                        );\n-                        let p_name = ParamName::Fresh(p_def_id);\n-                        captures.insert(p_def_id, (span, p_id, p_name, res));\n-                        hir::LifetimeName::Param(p_name)\n-                    }\n-                    _ => l_name,\n+                if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n+                    &mut self.captured_lifetimes\n+                    && !binders_to_ignore.contains(&binder)\n+                {\n+                    let p_id = self.resolver.next_node_id();\n+                    let p_def_id = self.resolver.create_def(\n+                        *parent_def_id,\n+                        p_id,\n+                        DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                        ExpnId::root(),\n+                        span.with_parent(None),\n+                    );\n+                    let p_name = ParamName::Fresh(p_def_id);\n+                    captures.insert(p_def_id, (span, p_id, p_name, res));\n+                    hir::LifetimeName::Param(p_name)\n+                } else {\n+                    l_name\n                 }\n             }\n             LifetimeRes::Static => hir::LifetimeName::Static,\n@@ -2069,16 +2111,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.lower_generic_params(&p.bound_generic_params, itctx.reborrow());\n \n         let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n-            if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n-                binders.insert(p.trait_ref.ref_id);\n-            }\n-\n-            let trait_ref = this.lower_trait_ref(&p.trait_ref, itctx.reborrow());\n-\n-            if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n-                binders.remove(&p.trait_ref.ref_id);\n-            }\n-            trait_ref\n+            this.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n+                this.lower_trait_ref(&p.trait_ref, itctx.reborrow())\n+            })\n         });\n \n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }"}, {"sha": "3c9399c1fdf80af168b4e5eacea26519addfb1d0", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=6857a8d14e1eeddda1e575f0d124ba2e6dbae0eb", "patch": "@@ -353,33 +353,31 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n         // we generally don't permit such things (see #51008).\n-        if let Some((_, _, binders)) = &mut self.captured_lifetimes {\n-            binders.insert(id);\n-        }\n-        let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n-        let inputs = self.arena.alloc_from_iter(inputs.iter().map(|ty| {\n-            self.lower_ty_direct(ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n-        }));\n-        let output_ty = match output {\n-            FnRetTy::Ty(ty) => {\n-                self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n-            }\n-            FnRetTy::Default(_) => self.arena.alloc(self.ty_tup(*span, &[])),\n-        };\n-        let args = smallvec![GenericArg::Type(self.ty_tup(*inputs_span, inputs))];\n-        let binding = self.output_ty_binding(output_ty.span, output_ty);\n-        if let Some((_, _, binders)) = &mut self.captured_lifetimes {\n-            binders.remove(&id);\n-        }\n-        (\n-            GenericArgsCtor {\n-                args,\n-                bindings: arena_vec![self; binding],\n-                parenthesized: true,\n-                span: data.inputs_span,\n-            },\n-            false,\n-        )\n+        self.with_lifetime_binder(id, |this| {\n+            let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n+            let inputs = this.arena.alloc_from_iter(inputs.iter().map(|ty| {\n+                this.lower_ty_direct(\n+                    ty,\n+                    ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam),\n+                )\n+            }));\n+            let output_ty = match output {\n+                FnRetTy::Ty(ty) => this\n+                    .lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn)),\n+                FnRetTy::Default(_) => this.arena.alloc(this.ty_tup(*span, &[])),\n+            };\n+            let args = smallvec![GenericArg::Type(this.ty_tup(*inputs_span, inputs))];\n+            let binding = this.output_ty_binding(output_ty.span, output_ty);\n+            (\n+                GenericArgsCtor {\n+                    args,\n+                    bindings: arena_vec![this; binding],\n+                    parenthesized: true,\n+                    span: data.inputs_span,\n+                },\n+                false,\n+            )\n+        })\n     }\n \n     /// An associated type binding `Output = $ty`."}]}