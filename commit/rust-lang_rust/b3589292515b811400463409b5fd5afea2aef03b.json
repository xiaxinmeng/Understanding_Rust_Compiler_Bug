{"sha": "b3589292515b811400463409b5fd5afea2aef03b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNTg5MjkyNTE1YjgxMTQwMDQ2MzQwOWI1ZmQ1YWZlYTJhZWYwM2I=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-05T15:46:44Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-12T09:39:26Z"}, "message": "Split `rustc_mir::{build, hair, lints}` into their own crate", "tree": {"sha": "20ff8dfe835e97bcbfa76ca3c52d8acda2628320", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20ff8dfe835e97bcbfa76ca3c52d8acda2628320"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3589292515b811400463409b5fd5afea2aef03b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3589292515b811400463409b5fd5afea2aef03b", "html_url": "https://github.com/rust-lang/rust/commit/b3589292515b811400463409b5fd5afea2aef03b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3589292515b811400463409b5fd5afea2aef03b/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1389494ac145a84dba025ff65969f7ab150c3f02", "url": "https://api.github.com/repos/rust-lang/rust/commits/1389494ac145a84dba025ff65969f7ab150c3f02", "html_url": "https://github.com/rust-lang/rust/commit/1389494ac145a84dba025ff65969f7ab150c3f02"}], "stats": {"total": 1146, "additions": 621, "deletions": 525}, "files": [{"sha": "38e7f7c9fe92eeb92af604425406dae8f7f34f3e", "filename": "Cargo.lock", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -3633,6 +3633,7 @@ dependencies = [\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n+ \"rustc_mir_build\",\n  \"rustc_parse\",\n  \"rustc_passes\",\n  \"rustc_plugin_impl\",\n@@ -3721,7 +3722,6 @@ dependencies = [\n name = \"rustc_mir\"\n version = \"0.0.0\"\n dependencies = [\n- \"arena\",\n  \"either\",\n  \"graphviz\",\n  \"itertools 0.8.0\",\n@@ -3744,6 +3744,28 @@ dependencies = [\n  \"syntax\",\n ]\n \n+[[package]]\n+name = \"rustc_mir_build\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena\",\n+ \"itertools 0.8.0\",\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_apfloat\",\n+ \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"serialize\",\n+ \"smallvec 1.0.0\",\n+ \"syntax\",\n+]\n+\n [[package]]\n name = \"rustc_parse\"\n version = \"0.0.0\""}, {"sha": "ccd2a968ded4cb3e61fbcea42ca56479ca2c08cd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 221, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! MIR datatypes and passes. See the [rustc guide] for more info.\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/index.html\n@@ -23,14 +21,12 @@ use polonius_engine::Atom;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::graph::{self, GraphSuccessors};\n-use rustc_data_structures::sync::Lrc;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n-use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n use std::ops::Index;\n@@ -39,13 +35,15 @@ use std::{iter, mem, option, u32};\n pub use syntax::ast::Mutability;\n use syntax::ast::Name;\n \n-pub use crate::mir::cache::{BodyAndCache, ReadOnlyBodyAndCache};\n-pub use crate::mir::interpret::AssertMessage;\n+pub use self::cache::{BodyAndCache, ReadOnlyBodyAndCache};\n+pub use self::interpret::AssertMessage;\n+pub use self::query::*;\n pub use crate::read_only;\n \n mod cache;\n pub mod interpret;\n pub mod mono;\n+mod query;\n pub mod tcx;\n pub mod traversal;\n pub mod visit;\n@@ -2581,221 +2579,6 @@ impl Location {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum UnsafetyViolationKind {\n-    General,\n-    /// Permitted both in `const fn`s and regular `fn`s.\n-    GeneralAndConstFn,\n-    BorrowPacked(hir::HirId),\n-}\n-\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UnsafetyViolation {\n-    pub source_info: SourceInfo,\n-    pub description: Symbol,\n-    pub details: Symbol,\n-    pub kind: UnsafetyViolationKind,\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct UnsafetyCheckResult {\n-    /// Violations that are propagated *upwards* from this function.\n-    pub violations: Lrc<[UnsafetyViolation]>,\n-    /// `unsafe` blocks in this function, along with whether they are used. This is\n-    /// used for the \"unused_unsafe\" lint.\n-    pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n-}\n-\n-rustc_index::newtype_index! {\n-    pub struct GeneratorSavedLocal {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"_{}\",\n-    }\n-}\n-\n-/// The layout of generator state.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct GeneratorLayout<'tcx> {\n-    /// The type of every local stored inside the generator.\n-    pub field_tys: IndexVec<GeneratorSavedLocal, Ty<'tcx>>,\n-\n-    /// Which of the above fields are in each variant. Note that one field may\n-    /// be stored in multiple variants.\n-    pub variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>>,\n-\n-    /// Which saved locals are storage-live at the same time. Locals that do not\n-    /// have conflicts with each other are allowed to overlap in the computed\n-    /// layout.\n-    pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n-}\n-\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct BorrowCheckResult<'tcx> {\n-    pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n-    pub used_mut_upvars: SmallVec<[Field; 8]>,\n-}\n-\n-/// The result of the `mir_const_qualif` query.\n-///\n-/// Each field corresponds to an implementer of the `Qualif` trait in\n-/// `librustc_mir/transform/check_consts/qualifs.rs`. See that file for more information on each\n-/// `Qualif`.\n-#[derive(Clone, Copy, Debug, Default, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct ConstQualifs {\n-    pub has_mut_interior: bool,\n-    pub needs_drop: bool,\n-}\n-\n-/// After we borrow check a closure, we are left with various\n-/// requirements that we have inferred between the free regions that\n-/// appear in the closure's signature or on its field types. These\n-/// requirements are then verified and proved by the closure's\n-/// creating function. This struct encodes those requirements.\n-///\n-/// The requirements are listed as being between various\n-/// `RegionVid`. The 0th region refers to `'static`; subsequent region\n-/// vids refer to the free regions that appear in the closure (or\n-/// generator's) type, in order of appearance. (This numbering is\n-/// actually defined by the `UniversalRegions` struct in the NLL\n-/// region checker. See for example\n-/// `UniversalRegions::closure_mapping`.) Note that we treat the free\n-/// regions in the closure's type \"as if\" they were erased, so their\n-/// precise identity is not important, only their position.\n-///\n-/// Example: If type check produces a closure with the closure substs:\n-///\n-/// ```text\n-/// ClosureSubsts = [\n-///     i8,                                  // the \"closure kind\"\n-///     for<'x> fn(&'a &'x u32) -> &'x u32,  // the \"closure signature\"\n-///     &'a String,                          // some upvar\n-/// ]\n-/// ```\n-///\n-/// here, there is one unique free region (`'a`) but it appears\n-/// twice. We would \"renumber\" each occurrence to a unique vid, as follows:\n-///\n-/// ```text\n-/// ClosureSubsts = [\n-///     i8,                                  // the \"closure kind\"\n-///     for<'x> fn(&'1 &'x u32) -> &'x u32,  // the \"closure signature\"\n-///     &'2 String,                          // some upvar\n-/// ]\n-/// ```\n-///\n-/// Now the code might impose a requirement like `'1: '2`. When an\n-/// instance of the closure is created, the corresponding free regions\n-/// can be extracted from its type and constrained to have the given\n-/// outlives relationship.\n-///\n-/// In some cases, we have to record outlives requirements between\n-/// types and regions as well. In that case, if those types include\n-/// any regions, those regions are recorded as `ReClosureBound`\n-/// instances assigned one of these same indices. Those regions will\n-/// be substituted away by the creator. We use `ReClosureBound` in\n-/// that case because the regions must be allocated in the global\n-/// `TyCtxt`, and hence we cannot use `ReVar` (which is what we use\n-/// internally within the rest of the NLL code).\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct ClosureRegionRequirements<'tcx> {\n-    /// The number of external regions defined on the closure. In our\n-    /// example above, it would be 3 -- one for `'static`, then `'1`\n-    /// and `'2`. This is just used for a sanity check later on, to\n-    /// make sure that the number of regions we see at the callsite\n-    /// matches.\n-    pub num_external_vids: usize,\n-\n-    /// Requirements between the various free regions defined in\n-    /// indices.\n-    pub outlives_requirements: Vec<ClosureOutlivesRequirement<'tcx>>,\n-}\n-\n-/// Indicates an outlives-constraint between a type or between two\n-/// free regions declared on the closure.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct ClosureOutlivesRequirement<'tcx> {\n-    // This region or type ...\n-    pub subject: ClosureOutlivesSubject<'tcx>,\n-\n-    // ... must outlive this one.\n-    pub outlived_free_region: ty::RegionVid,\n-\n-    // If not, report an error here ...\n-    pub blame_span: Span,\n-\n-    // ... due to this reason.\n-    pub category: ConstraintCategory,\n-}\n-\n-/// Outlives-constraints can be categorized to determine whether and why they\n-/// are interesting (for error reporting). Order of variants indicates sort\n-/// order of the category, thereby influencing diagnostic output.\n-///\n-/// See also [rustc_mir::borrow_check::nll::constraints].\n-#[derive(\n-    Copy,\n-    Clone,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    RustcEncodable,\n-    RustcDecodable,\n-    HashStable\n-)]\n-pub enum ConstraintCategory {\n-    Return,\n-    Yield,\n-    UseAsConst,\n-    UseAsStatic,\n-    TypeAnnotation,\n-    Cast,\n-\n-    /// A constraint that came from checking the body of a closure.\n-    ///\n-    /// We try to get the category that the closure used when reporting this.\n-    ClosureBounds,\n-    CallArgument,\n-    CopyBound,\n-    SizedBound,\n-    Assignment,\n-    OpaqueType,\n-\n-    /// A \"boring\" constraint (caused by the given location) is one that\n-    /// the user probably doesn't want to see described in diagnostics,\n-    /// because it is kind of an artifact of the type system setup.\n-    /// Example: `x = Foo { field: y }` technically creates\n-    /// intermediate regions representing the \"type of `Foo { field: y\n-    /// }`\", and data flows from `y` into those variables, but they\n-    /// are not very interesting. The assignment into `x` on the other\n-    /// hand might be.\n-    Boring,\n-    // Boring and applicable everywhere.\n-    BoringNoLocation,\n-\n-    /// A constraint that doesn't correspond to anything the user sees.\n-    Internal,\n-}\n-\n-/// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n-/// that must outlive some region.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum ClosureOutlivesSubject<'tcx> {\n-    /// Subject is a type, typically a type parameter, but could also\n-    /// be a projection. Indicates a requirement like `T: 'a` being\n-    /// passed to the caller, where the type here is `T`.\n-    ///\n-    /// The type here is guaranteed not to contain any free regions at\n-    /// present.\n-    Ty(Ty<'tcx>),\n-\n-    /// Subject is a free region from the closure. Indicates a requirement\n-    /// like `'a: 'b` being passed to the caller; the region here is `'a`.\n-    Region(ty::RegionVid),\n-}\n-\n /*\n  * `TypeFoldable` implementations for MIR types\n */"}, {"sha": "34f58ab89b10757117e6054326e5e0fce599ca30", "filename": "src/librustc/mir/query.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fquery.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -0,0 +1,223 @@\n+//! Values computed by queries that use MIR.\n+\n+use crate::ty::{self, Ty};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir as hir;\n+use rustc_index::bit_set::BitMatrix;\n+use rustc_index::vec::IndexVec;\n+use rustc_span::{Span, Symbol};\n+use rustc_target::abi::VariantIdx;\n+use smallvec::SmallVec;\n+\n+use super::{Field, SourceInfo};\n+\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum UnsafetyViolationKind {\n+    General,\n+    /// Permitted both in `const fn`s and regular `fn`s.\n+    GeneralAndConstFn,\n+    BorrowPacked(hir::HirId),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct UnsafetyViolation {\n+    pub source_info: SourceInfo,\n+    pub description: Symbol,\n+    pub details: Symbol,\n+    pub kind: UnsafetyViolationKind,\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct UnsafetyCheckResult {\n+    /// Violations that are propagated *upwards* from this function.\n+    pub violations: Lrc<[UnsafetyViolation]>,\n+    /// `unsafe` blocks in this function, along with whether they are used. This is\n+    /// used for the \"unused_unsafe\" lint.\n+    pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct GeneratorSavedLocal {\n+        derive [HashStable]\n+        DEBUG_FORMAT = \"_{}\",\n+    }\n+}\n+\n+/// The layout of generator state.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct GeneratorLayout<'tcx> {\n+    /// The type of every local stored inside the generator.\n+    pub field_tys: IndexVec<GeneratorSavedLocal, Ty<'tcx>>,\n+\n+    /// Which of the above fields are in each variant. Note that one field may\n+    /// be stored in multiple variants.\n+    pub variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>>,\n+\n+    /// Which saved locals are storage-live at the same time. Locals that do not\n+    /// have conflicts with each other are allowed to overlap in the computed\n+    /// layout.\n+    pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n+}\n+\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct BorrowCheckResult<'tcx> {\n+    pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n+    pub used_mut_upvars: SmallVec<[Field; 8]>,\n+}\n+\n+/// The result of the `mir_const_qualif` query.\n+///\n+/// Each field corresponds to an implementer of the `Qualif` trait in\n+/// `librustc_mir/transform/check_consts/qualifs.rs`. See that file for more information on each\n+/// `Qualif`.\n+#[derive(Clone, Copy, Debug, Default, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct ConstQualifs {\n+    pub has_mut_interior: bool,\n+    pub needs_drop: bool,\n+}\n+\n+/// After we borrow check a closure, we are left with various\n+/// requirements that we have inferred between the free regions that\n+/// appear in the closure's signature or on its field types. These\n+/// requirements are then verified and proved by the closure's\n+/// creating function. This struct encodes those requirements.\n+///\n+/// The requirements are listed as being between various\n+/// `RegionVid`. The 0th region refers to `'static`; subsequent region\n+/// vids refer to the free regions that appear in the closure (or\n+/// generator's) type, in order of appearance. (This numbering is\n+/// actually defined by the `UniversalRegions` struct in the NLL\n+/// region checker. See for example\n+/// `UniversalRegions::closure_mapping`.) Note that we treat the free\n+/// regions in the closure's type \"as if\" they were erased, so their\n+/// precise identity is not important, only their position.\n+///\n+/// Example: If type check produces a closure with the closure substs:\n+///\n+/// ```text\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'a &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'a String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// here, there is one unique free region (`'a`) but it appears\n+/// twice. We would \"renumber\" each occurrence to a unique vid, as follows:\n+///\n+/// ```text\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'1 &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'2 String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// Now the code might impose a requirement like `'1: '2`. When an\n+/// instance of the closure is created, the corresponding free regions\n+/// can be extracted from its type and constrained to have the given\n+/// outlives relationship.\n+///\n+/// In some cases, we have to record outlives requirements between\n+/// types and regions as well. In that case, if those types include\n+/// any regions, those regions are recorded as `ReClosureBound`\n+/// instances assigned one of these same indices. Those regions will\n+/// be substituted away by the creator. We use `ReClosureBound` in\n+/// that case because the regions must be allocated in the global\n+/// `TyCtxt`, and hence we cannot use `ReVar` (which is what we use\n+/// internally within the rest of the NLL code).\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct ClosureRegionRequirements<'tcx> {\n+    /// The number of external regions defined on the closure. In our\n+    /// example above, it would be 3 -- one for `'static`, then `'1`\n+    /// and `'2`. This is just used for a sanity check later on, to\n+    /// make sure that the number of regions we see at the callsite\n+    /// matches.\n+    pub num_external_vids: usize,\n+\n+    /// Requirements between the various free regions defined in\n+    /// indices.\n+    pub outlives_requirements: Vec<ClosureOutlivesRequirement<'tcx>>,\n+}\n+\n+/// Indicates an outlives-constraint between a type or between two\n+/// free regions declared on the closure.\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct ClosureOutlivesRequirement<'tcx> {\n+    // This region or type ...\n+    pub subject: ClosureOutlivesSubject<'tcx>,\n+\n+    // ... must outlive this one.\n+    pub outlived_free_region: ty::RegionVid,\n+\n+    // If not, report an error here ...\n+    pub blame_span: Span,\n+\n+    // ... due to this reason.\n+    pub category: ConstraintCategory,\n+}\n+\n+/// Outlives-constraints can be categorized to determine whether and why they\n+/// are interesting (for error reporting). Order of variants indicates sort\n+/// order of the category, thereby influencing diagnostic output.\n+///\n+/// See also [rustc_mir::borrow_check::nll::constraints].\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ConstraintCategory {\n+    Return,\n+    Yield,\n+    UseAsConst,\n+    UseAsStatic,\n+    TypeAnnotation,\n+    Cast,\n+\n+    /// A constraint that came from checking the body of a closure.\n+    ///\n+    /// We try to get the category that the closure used when reporting this.\n+    ClosureBounds,\n+    CallArgument,\n+    CopyBound,\n+    SizedBound,\n+    Assignment,\n+    OpaqueType,\n+\n+    /// A \"boring\" constraint (caused by the given location) is one that\n+    /// the user probably doesn't want to see described in diagnostics,\n+    /// because it is kind of an artifact of the type system setup.\n+    /// Example: `x = Foo { field: y }` technically creates\n+    /// intermediate regions representing the \"type of `Foo { field: y\n+    /// }`\", and data flows from `y` into those variables, but they\n+    /// are not very interesting. The assignment into `x` on the other\n+    /// hand might be.\n+    Boring,\n+    // Boring and applicable everywhere.\n+    BoringNoLocation,\n+\n+    /// A constraint that doesn't correspond to anything the user sees.\n+    Internal,\n+}\n+\n+/// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n+/// that must outlive some region.\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ClosureOutlivesSubject<'tcx> {\n+    /// Subject is a type, typically a type parameter, but could also\n+    /// be a projection. Indicates a requirement like `T: 'a` being\n+    /// passed to the caller, where the type here is `T`.\n+    ///\n+    /// The type here is guaranteed not to contain any free regions at\n+    /// present.\n+    Ty(Ty<'tcx>),\n+\n+    /// Subject is a free region from the closure. Indicates a requirement\n+    /// like `'a: 'b` being passed to the caller; the region here is `'a`.\n+    Region(ty::RegionVid),\n+}\n+\n+/// The constituent parts of an ADT or array.\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub struct DestructuredConst<'tcx> {\n+    pub variant: VariantIdx,\n+    pub fields: &'tcx [&'tcx ty::Const<'tcx>],\n+}"}, {"sha": "a35b55ff129ce6f58dc38498d4d1b75d6a878774", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -505,6 +505,15 @@ rustc_queries! {\n             desc { \"extract field of const\" }\n         }\n \n+        /// Destructure a constant ADT or array into its variant indent and its\n+        /// field values.\n+        query destructure_const(\n+            key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n+        ) -> mir::DestructuredConst<'tcx> {\n+            no_force\n+            desc { \"destructure constant\" }\n+        }\n+\n         query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> &'tcx ty::Const<'tcx> {\n             no_force\n             desc { \"get a &core::panic::Location referring to a span\" }"}, {"sha": "d64f27d9cc26ca75ffba41d0fb2d5e0789ac3193", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -142,7 +142,7 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Key for ty::Const<'tcx> {\n+impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "98f7def7e36cbabca54f6c4e698a6593ee8f7f81", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -32,6 +32,7 @@ rustc_codegen_llvm = { path = \"../librustc_codegen_llvm\", optional = true }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n+rustc_mir_build = { path = \"../librustc_mir_build\" }\n rustc_passes = { path = \"../librustc_passes\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_lint = { path = \"../librustc_lint\" }"}, {"sha": "f40ad93e6797af9227f01257f967ee0e793da9ed", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -28,6 +28,7 @@ use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental;\n use rustc_mir as mir;\n+use rustc_mir_build as mir_build;\n use rustc_parse::{parse_crate_from_file, parse_crate_from_source_str};\n use rustc_passes::{self, hir_stats, layout_test};\n use rustc_plugin_impl as plugin;\n@@ -670,6 +671,7 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     plugin::build::provide(providers);\n     rustc::hir::provide(providers);\n     mir::provide(providers);\n+    mir_build::provide(providers);\n     rustc_privacy::provide(providers);\n     typeck::provide(providers);\n     ty::provide(providers);"}, {"sha": "f9b61b9e2c9d8dfd75f7f9ad0444e2b97adc2410", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -10,7 +10,6 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-arena = { path = \"../libarena\" }\n either = \"1.5.0\"\n dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n itertools = \"0.8\""}, {"sha": "aa7be3d80e1dcca997421f7fa3f723a2e7c239e9", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -61,15 +61,32 @@ pub(crate) fn const_caller_location<'tcx>(\n     tcx.mk_const(loc_const)\n }\n \n-// this function uses `unwrap` copiously, because an already validated constant must have valid\n-// fields and can thus never fail outside of compiler bugs\n-pub(crate) fn const_variant_index<'tcx>(\n+// this function uses `unwrap` copiously, because an already validated constant\n+// must have valid fields and can thus never fail outside of compiler bugs\n+pub(crate) fn destructure_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n-) -> VariantIdx {\n-    trace!(\"const_variant_index: {:?}\", val);\n+) -> mir::DestructuredConst<'tcx> {\n+    trace!(\"destructure_const: {:?}\", val);\n     let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.eval_const_to_op(val, None).unwrap();\n-    ecx.read_discriminant(op).unwrap().1\n+\n+    let variant = ecx.read_discriminant(op).unwrap().1;\n+\n+    let field_count = match val.ty.kind {\n+        ty::Array(_, len) => len.eval_usize(tcx, param_env),\n+        ty::Adt(def, _) => def.variants[variant].fields.len() as u64,\n+        ty::Tuple(substs) => substs.len() as u64,\n+        _ => bug!(\"cannot destructure constant {:?}\", val),\n+    };\n+\n+    let down = ecx.operand_downcast(op, variant).unwrap();\n+    let fields_iter = (0..field_count).map(|i| {\n+        let field_op = ecx.operand_field(down, i).unwrap();\n+        op_to_const(&ecx, field_op)\n+    });\n+    let fields = tcx.arena.alloc_from_iter(fields_iter);\n+\n+    mir::DestructuredConst { variant, fields }\n }"}, {"sha": "1ff529181f7058e375fd33767e3a44169f1d37ec", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -36,12 +36,9 @@ extern crate log;\n extern crate rustc;\n \n mod borrow_check;\n-mod build;\n pub mod const_eval;\n pub mod dataflow;\n-mod hair;\n pub mod interpret;\n-mod lints;\n pub mod monomorphize;\n mod shim;\n pub mod transform;\n@@ -57,10 +54,13 @@ pub fn provide(providers: &mut Providers<'_>) {\n     monomorphize::partitioning::provide(providers);\n     providers.const_eval_validated = const_eval::const_eval_validated_provider;\n     providers.const_eval_raw = const_eval::const_eval_raw_provider;\n-    providers.check_match = hair::pattern::check_match;\n     providers.const_caller_location = const_eval::const_caller_location;\n     providers.const_field = |tcx, param_env_and_value| {\n         let (param_env, (value, field)) = param_env_and_value.into_parts();\n         const_eval::const_field(tcx, param_env, None, field, value)\n     };\n+    providers.destructure_const = |tcx, param_env_and_value| {\n+        let (param_env, value) = param_env_and_value.into_parts();\n+        const_eval::destructure_const(tcx, param_env, value)\n+    }\n }"}, {"sha": "22aed9a9e66bd0383e0ebdb50b1f90444ef326ac", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -1,4 +1,4 @@\n-use crate::{build, shim};\n+use crate::{shim, util};\n use rustc::hir::map::Map;\n use rustc::mir::{BodyAndCache, ConstQualifs, MirPhase, Promoted};\n use rustc::ty::query::Providers;\n@@ -41,7 +41,6 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n     self::check_unsafety::provide(providers);\n     *providers = Providers {\n         mir_keys,\n-        mir_built,\n         mir_const,\n         mir_const_qualif,\n         mir_validated,\n@@ -98,11 +97,6 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyAndCache<'_>> {\n-    let mir = build::mir_build(tcx, def_id);\n-    tcx.alloc_steal_mir(mir)\n-}\n-\n /// Where a specific `mir::Body` comes from.\n #[derive(Debug, Copy, Clone)]\n pub struct MirSource<'tcx> {\n@@ -222,6 +216,9 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<BodyAndCache<'_>> {\n     let _ = tcx.unsafety_check_result(def_id);\n \n     let mut body = tcx.mir_built(def_id).steal();\n+\n+    util::dump_mir(tcx, None, \"mir_map\", &0, MirSource::item(def_id), &body, |_, _| Ok(()));\n+\n     run_passes(\n         tcx,\n         &mut body,"}, {"sha": "79c730327559783bc5c60bc77c57d20eaa10b910", "filename": "src/librustc_mir_build/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_mir_build\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_mir_build\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+arena = { path = \"../libarena\" }\n+itertools = \"0.8\"\n+log = \"0.4\"\n+rustc = { path = \"../librustc\" }\n+rustc_apfloat = { path = \"../librustc_apfloat\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n+rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+rustc_span = { path = \"../librustc_span\" }\n+rustc_target = { path = \"../librustc_target\" }\n+syntax = { path = \"../libsyntax\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+rustc_error_codes = { path = \"../librustc_error_codes\" }"}, {"sha": "c517d3113c65937f582aa6274f834375610edea7", "filename": "src/librustc_mir_build/build/block.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -7,7 +7,7 @@ use rustc_hir as hir;\n use rustc_span::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn ast_block(\n+    crate fn ast_block(\n         &mut self,\n         destination: &Place<'tcx>,\n         block: BasicBlock,", "previous_filename": "src/librustc_mir/build/block.rs"}, {"sha": "e1971102832b536b79033731776facd652713f62", "filename": "src/librustc_mir_build/build/cfg.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fcfg.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -4,33 +4,33 @@ use crate::build::CFG;\n use rustc::mir::*;\n \n impl<'tcx> CFG<'tcx> {\n-    pub fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n+    crate fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n         &self.basic_blocks[blk]\n     }\n \n-    pub fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n+    crate fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n         &mut self.basic_blocks[blk]\n     }\n \n     // llvm.org/PR32488 makes this function use an excess of stack space. Mark\n     // it as #[inline(never)] to keep rustc's stack use in check.\n     #[inline(never)]\n-    pub fn start_new_block(&mut self) -> BasicBlock {\n+    crate fn start_new_block(&mut self) -> BasicBlock {\n         self.basic_blocks.push(BasicBlockData::new(None))\n     }\n \n-    pub fn start_new_cleanup_block(&mut self) -> BasicBlock {\n+    crate fn start_new_cleanup_block(&mut self) -> BasicBlock {\n         let bb = self.start_new_block();\n         self.block_data_mut(bb).is_cleanup = true;\n         bb\n     }\n \n-    pub fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n+    crate fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n         debug!(\"push({:?}, {:?})\", block, statement);\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    pub fn push_assign(\n+    crate fn push_assign(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -43,7 +43,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    pub fn push_assign_constant(\n+    crate fn push_assign_constant(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -53,7 +53,7 @@ impl<'tcx> CFG<'tcx> {\n         self.push_assign(block, source_info, temp, Rvalue::Use(Operand::Constant(box constant)));\n     }\n \n-    pub fn push_assign_unit(\n+    crate fn push_assign_unit(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -67,7 +67,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    pub fn push_fake_read(\n+    crate fn push_fake_read(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -79,7 +79,7 @@ impl<'tcx> CFG<'tcx> {\n         self.push(block, stmt);\n     }\n \n-    pub fn terminate(\n+    crate fn terminate(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -96,7 +96,7 @@ impl<'tcx> CFG<'tcx> {\n     }\n \n     /// In the `origin` block, push a `goto -> target` terminator.\n-    pub fn goto(&mut self, origin: BasicBlock, source_info: SourceInfo, target: BasicBlock) {\n+    crate fn goto(&mut self, origin: BasicBlock, source_info: SourceInfo, target: BasicBlock) {\n         self.terminate(origin, source_info, TerminatorKind::Goto { target })\n     }\n }", "previous_filename": "src/librustc_mir/build/cfg.rs"}, {"sha": "e4856262975e7c376b11f7ab92ea7ade6c8143b5", "filename": "src/librustc_mir_build/build/expr/as_constant.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_constant.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -8,7 +8,7 @@ use rustc::ty::CanonicalUserTypeAnnotation;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    pub fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>\n+    crate fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {", "previous_filename": "src/librustc_mir/build/expr/as_constant.rs"}, {"sha": "efe328d2b3c1e7e6a44e879cfebbeb84f8dacee0", "filename": "src/librustc_mir_build/build/expr/as_operand.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -13,7 +13,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// The operand returned from this function will *not be valid* after\n     /// an ExprKind::Scope is passed, so please do *not* return it from\n     /// functions to avoid bad miscompiles.\n-    pub fn as_local_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n+    crate fn as_local_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -27,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// this time.\n     ///\n     /// The operand is known to be live until the end of `scope`.\n-    pub fn as_operand<M>(\n+    crate fn as_operand<M>(\n         &mut self,\n         block: BasicBlock,\n         scope: Option<region::Scope>,", "previous_filename": "src/librustc_mir/build/expr/as_operand.rs"}, {"sha": "fd6882fa19fdf324c4d92ffd7dc8a10c45af3016", "filename": "src/librustc_mir_build/build/expr/as_place.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -24,7 +24,7 @@ struct PlaceBuilder<'tcx> {\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n-impl PlaceBuilder<'tcx> {\n+impl<'tcx> PlaceBuilder<'tcx> {\n     fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n         Place { local: self.local, projection: tcx.intern_place_elems(&self.projection) }\n     }\n@@ -47,7 +47,7 @@ impl PlaceBuilder<'tcx> {\n     }\n }\n \n-impl From<Local> for PlaceBuilder<'tcx> {\n+impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n         Self { local, projection: Vec::new() }\n     }\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Extra care is needed if any user code is allowed to run between calling\n     /// this method and using it, as is the case for `match` and index\n     /// expressions.\n-    pub fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    crate fn as_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -89,7 +89,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    pub fn as_read_only_place<M>(&mut self, mut block: BasicBlock, expr: M) -> BlockAnd<Place<'tcx>>\n+    crate fn as_read_only_place<M>(\n+        &mut self,\n+        mut block: BasicBlock,\n+        expr: M,\n+    ) -> BlockAnd<Place<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {", "previous_filename": "src/librustc_mir/build/expr/as_place.rs"}, {"sha": "5959b8522567485c7519f14d8f2e57b300bc3ef5", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -18,7 +18,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// The operand returned from this function will *not be valid* after\n     /// an ExprKind::Scope is passed, so please do *not* return it from\n     /// functions to avoid bad miscompiles.\n-    pub fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n+    crate fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n@@ -276,7 +276,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn build_binary_op(\n+    crate fn build_binary_op(\n         &mut self,\n         mut block: BasicBlock,\n         op: BinOp,", "previous_filename": "src/librustc_mir/build/expr/as_rvalue.rs"}, {"sha": "f47987c56174ccdc48fd8615d9c55028ef9f4079", "filename": "src/librustc_mir_build/build/expr/as_temp.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::sym;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    pub fn as_temp<M>(\n+    crate fn as_temp<M>(\n         &mut self,\n         block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,", "previous_filename": "src/librustc_mir/build/expr/as_temp.rs"}, {"sha": "c4d340953c92586eeb30de4e072349550f4dabc9", "filename": "src/librustc_mir_build/build/expr/category.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -1,7 +1,7 @@\n use crate::hair::*;\n \n #[derive(Debug, PartialEq)]\n-pub enum Category {\n+crate enum Category {\n     // An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n     // sort of thing. Something that could appear on the LHS of an `=`\n     // sign.\n@@ -19,7 +19,7 @@ pub enum Category {\n // Rvalues fall into different \"styles\" that will determine which fn\n // is best suited to generate them.\n #[derive(Debug, PartialEq)]\n-pub enum RvalueFunc {\n+crate enum RvalueFunc {\n     // Best generated by `into`. This is generally exprs that\n     // cause branching, like `match`, but also includes calls.\n     Into,\n@@ -31,7 +31,7 @@ pub enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    pub fn of(ek: &ExprKind<'_>) -> Option<Category> {\n+    crate fn of(ek: &ExprKind<'_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n ", "previous_filename": "src/librustc_mir/build/expr/category.rs"}, {"sha": "503dfb6ef5b6149faeb9ad15c6f01289d66b6a35", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -14,7 +14,7 @@ use rustc_target::spec::abi::Abi;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    pub fn into_expr(\n+    crate fn into_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n         mut block: BasicBlock,", "previous_filename": "src/librustc_mir/build/expr/into.rs"}, {"sha": "ac8c7e725e1b4190a1a075935422993e013cc9bc", "filename": "src/librustc_mir_build/build/expr/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "previous_filename": "src/librustc_mir/build/expr/mod.rs"}, {"sha": "fd61cb833b1bcb84b159c111bfdd6c0eed86905b", "filename": "src/librustc_mir_build/build/expr/stmt.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -10,7 +10,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// (e.g., `some().code(&here());`) then `opt_stmt_span` is the\n     /// span of that statement (including its semicolon, if any).\n     /// The scope is used if a statement temporary must be dropped.\n-    pub fn stmt_expr(\n+    crate fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,\n         expr: Expr<'tcx>,", "previous_filename": "src/librustc_mir/build/expr/stmt.rs"}, {"sha": "1a2a9d2bc05fc550988b73af3956c7c9ae5f33d7", "filename": "src/librustc_mir_build/build/into.rs", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -18,7 +18,12 @@ pub(in crate::build) trait EvalInto<'tcx> {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn into<E>(&mut self, destination: &Place<'tcx>, block: BasicBlock, expr: E) -> BlockAnd<()>\n+    crate fn into<E>(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        block: BasicBlock,\n+        expr: E,\n+    ) -> BlockAnd<()>\n     where\n         E: EvalInto<'tcx>,\n     {", "previous_filename": "src/librustc_mir/build/into.rs"}, {"sha": "f9f10b55495fad6218004f73bdee85d89800c85c", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// * From each prebinding block to the next prebinding block.\n     /// * From each otherwise block to the next prebinding block.\n-    pub fn match_expr(\n+    crate fn match_expr(\n         &mut self,\n         destination: &Place<'tcx>,\n         span: Span,\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn place_into_pattern(\n+    crate fn place_into_pattern(\n         &mut self,\n         block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n@@ -488,7 +488,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n-    pub fn declare_bindings(\n+    crate fn declare_bindings(\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         visibility_scope\n     }\n \n-    pub fn storage_live_binding(\n+    crate fn storage_live_binding(\n         &mut self,\n         block: BasicBlock,\n         var: HirId,\n@@ -540,7 +540,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         Place::from(local_id)\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n+    crate fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n         let region_scope = self.hir.region_scope_tree.var_scope(var.local_id);\n         self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n@@ -641,7 +641,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n #[derive(Debug)]\n-pub struct Candidate<'pat, 'tcx> {\n+crate struct Candidate<'pat, 'tcx> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n \n@@ -685,7 +685,7 @@ struct Ascription<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub struct MatchPair<'pat, 'tcx> {\n+crate struct MatchPair<'pat, 'tcx> {\n     // this place...\n     place: Place<'tcx>,\n \n@@ -739,15 +739,15 @@ enum TestKind<'tcx> {\n }\n \n #[derive(Debug)]\n-pub struct Test<'tcx> {\n+crate struct Test<'tcx> {\n     span: Span,\n     kind: TestKind<'tcx>,\n }\n \n /// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n-pub(crate) struct ArmHasGuard(pub bool);\n+crate struct ArmHasGuard(crate bool);\n \n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm", "previous_filename": "src/librustc_mir/build/matches/mod.rs"}, {"sha": "a5f691add65c12102f50d0fb4b09ffafd3f680d9", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -24,7 +24,7 @@ use syntax::attr::{SignedInt, UnsignedInt};\n use std::mem;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn simplify_candidate<'pat>(&mut self, candidate: &mut Candidate<'pat, 'tcx>) {\n+    crate fn simplify_candidate<'pat>(&mut self, candidate: &mut Candidate<'pat, 'tcx>) {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::take(&mut candidate.match_pairs);", "previous_filename": "src/librustc_mir/build/matches/simplify.rs"}, {"sha": "31fc0d121052a63787c65f80e5287119b421231f", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n     /// It is a bug to call this with a simplifiable pattern.\n-    pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n+    crate fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::Variant { ref adt_def, substs: _, variant_index: _, subpatterns: _ } => Test {\n                 span: match_pair.pattern.span,\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn add_cases_to_switch<'pat>(\n+    crate fn add_cases_to_switch<'pat>(\n         &mut self,\n         test_place: &Place<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n@@ -129,7 +129,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn add_variants_to_switch<'pat>(\n+    crate fn add_variants_to_switch<'pat>(\n         &mut self,\n         test_place: &Place<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n@@ -156,7 +156,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn perform_test(\n+    crate fn perform_test(\n         &mut self,\n         block: BasicBlock,\n         place: &Place<'tcx>,\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// that it *doesn't* apply. For now, we return false, indicate that the\n     /// test does not apply to this candidate, but it might be we can get\n     /// tighter match code if we do something a bit different.\n-    pub fn sort_candidate<'pat>(\n+    crate fn sort_candidate<'pat>(\n         &mut self,\n         test_place: &Place<'tcx>,\n         test: &Test<'tcx>,", "previous_filename": "src/librustc_mir/build/matches/test.rs"}, {"sha": "def8d1b2fd8bad12b2ab46ad710260f08af175fa", "filename": "src/librustc_mir_build/build/matches/util.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Futil.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -8,7 +8,7 @@ use std::convert::TryInto;\n use std::u32;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn field_match_pairs<'pat>(\n+    crate fn field_match_pairs<'pat>(\n         &mut self,\n         place: Place<'tcx>,\n         subpatterns: &'pat [FieldPat<'tcx>],\n@@ -26,7 +26,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .collect()\n     }\n \n-    pub fn prefix_slice_suffix<'pat>(\n+    crate fn prefix_slice_suffix<'pat>(\n         &mut self,\n         match_pairs: &mut SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n         place: &Place<'tcx>,\n@@ -77,7 +77,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Creates a false edge to `imaginary_target` and a real edge to\n     /// real_target. If `imaginary_target` is none, or is the same as the real\n     /// target, a Goto is generated instead to simplify the generated MIR.\n-    pub fn false_edges(\n+    crate fn false_edges(\n         &mut self,\n         from_block: BasicBlock,\n         real_target: BasicBlock,\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    crate fn new(place: Place<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair { place, pattern }\n     }\n }", "previous_filename": "src/librustc_mir/build/matches/util.rs"}, {"sha": "3d5145b6960f5a1405ba5f383324eed2b5b00295", "filename": "src/librustc_mir_build/build/misc.rs", "status": "renamed", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmisc.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -14,7 +14,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// N.B., **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n-    pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n+    crate fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));\n         let place = Place::from(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\", place, self.local_decls[temp].ty);\n@@ -23,24 +23,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    pub fn literal_operand(&mut self, span: Span, literal: &'tcx ty::Const<'tcx>) -> Operand<'tcx> {\n+    crate fn literal_operand(\n+        &mut self,\n+        span: Span,\n+        literal: &'tcx ty::Const<'tcx>,\n+    ) -> Operand<'tcx> {\n         let constant = box Constant { span, user_ty: None, literal };\n         Operand::Constant(constant)\n     }\n \n-    pub fn unit_rvalue(&mut self) -> Rvalue<'tcx> {\n+    crate fn unit_rvalue(&mut self) -> Rvalue<'tcx> {\n         Rvalue::Aggregate(box AggregateKind::Tuple, vec![])\n     }\n \n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n-    pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n+    crate fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, literal)\n     }\n \n-    pub fn push_usize(\n+    crate fn push_usize(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -61,7 +65,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         temp\n     }\n \n-    pub fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n+    crate fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.hir.tcx();\n         let ty = place.ty(&self.local_decls, tcx).ty;\n         if !self.hir.type_is_copy_modulo_regions(ty, DUMMY_SP) {", "previous_filename": "src/librustc_mir/build/misc.rs"}, {"sha": "6214453e64f7866144c1fe9b58c4ab0dd1bfaccd", "filename": "src/librustc_mir_build/build/mod.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -2,8 +2,6 @@ use crate::build;\n use crate::build::scope::DropKind;\n use crate::hair::cx::Cx;\n use crate::hair::{BindingMode, LintLevel, PatKind};\n-use crate::transform::MirSource;\n-use crate::util as mir_util;\n use rustc::middle::lang_items;\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -22,8 +20,12 @@ use syntax::attr::{self, UnwindAttr};\n \n use super::lints;\n \n+crate fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::steal::Steal<BodyAndCache<'_>> {\n+    tcx.alloc_steal_mir(mir_build(tcx, def_id))\n+}\n+\n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n+fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -172,8 +174,6 @@ pub fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        mir_util::dump_mir(tcx, None, \"mir_map\", &0, MirSource::item(def_id), &body, |_, _| Ok(()));\n-\n         lints::check(tcx, &body, def_id);\n \n         let mut body = BodyAndCache::new(body);\n@@ -202,7 +202,7 @@ fn liberated_closure_env_ty(\n }\n \n #[derive(Debug, PartialEq, Eq)]\n-pub enum BlockFrame {\n+enum BlockFrame {\n     /// Evaluation is currently within a statement.\n     ///\n     /// Examples include:\n@@ -461,7 +461,7 @@ struct CFG<'tcx> {\n }\n \n rustc_index::newtype_index! {\n-    pub struct ScopeId { .. }\n+    struct ScopeId { .. }\n }\n \n ///////////////////////////////////////////////////////////////////////////", "previous_filename": "src/librustc_mir/build/mod.rs"}, {"sha": "d994b870853c1ead609383732d8c439d5177e3c4", "filename": "src/librustc_mir_build/build/scope.rs", "status": "renamed", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -123,7 +123,7 @@ struct Scope {\n }\n \n #[derive(Debug, Default)]\n-pub struct Scopes<'tcx> {\n+crate struct Scopes<'tcx> {\n     scopes: Vec<Scope>,\n     /// The current set of breakable scopes. See module comment for more details.\n     breakable_scopes: Vec<BreakableScope<'tcx>>,\n@@ -183,7 +183,7 @@ struct BreakableScope<'tcx> {\n \n /// The target of an expression that breaks out of a scope\n #[derive(Clone, Copy, Debug)]\n-pub enum BreakableTarget {\n+crate enum BreakableTarget {\n     Continue(region::Scope),\n     Break(region::Scope),\n     Return,\n@@ -371,7 +371,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // ==========================\n     //  Start a breakable scope, which tracks where `continue`, `break` and\n     //  `return` should branch to.\n-    pub fn in_breakable_scope<F, R>(\n+    crate fn in_breakable_scope<F, R>(\n         &mut self,\n         loop_block: Option<BasicBlock>,\n         break_block: BasicBlock,\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         res\n     }\n \n-    pub fn in_opt_scope<F, R>(\n+    crate fn in_opt_scope<F, R>(\n         &mut self,\n         opt_scope: Option<(region::Scope, SourceInfo)>,\n         f: F,\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n-    pub fn in_scope<F, R>(\n+    crate fn in_scope<F, R>(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n         lint_level: LintLevel,\n@@ -463,14 +463,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n+    crate fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n         self.scopes.push_scope(region_scope, self.source_scope);\n     }\n \n     /// Pops a scope, which should have region scope `region_scope`,\n     /// adding any drops onto the end of `block` that are needed.\n     /// This must match 1-to-1 with `push_scope`.\n-    pub fn pop_scope(\n+    crate fn pop_scope(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n         mut block: BasicBlock,\n@@ -500,7 +500,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block.unit()\n     }\n \n-    pub fn break_scope(\n+    crate fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n         value: Option<ExprRef<'tcx>>,\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Branch out of `block` to `target`, exiting all scopes up to\n     /// and including `region_scope`. This will insert whatever drops are\n     /// needed. See module comment for details.\n-    pub fn exit_scope(\n+    crate fn exit_scope(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n@@ -604,7 +604,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This path terminates in GeneratorDrop. Returns the start of the path.\n     /// None indicates there\u2019s no cleanup to do at this point.\n-    pub fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n+    crate fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n         // Fill in the cache for unwinds\n         self.diverge_cleanup_gen(true);\n \n@@ -656,7 +656,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Creates a new source scope, nested in the current one.\n-    pub fn new_source_scope(\n+    crate fn new_source_scope(\n         &mut self,\n         span: Span,\n         lint_level: LintLevel,\n@@ -689,7 +689,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Given a span and the current source scope, make a SourceInfo.\n-    pub fn source_info(&self, span: Span) -> SourceInfo {\n+    crate fn source_info(&self, span: Span) -> SourceInfo {\n         SourceInfo { span, scope: self.source_scope }\n     }\n \n@@ -717,7 +717,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// When building statics/constants, returns `None` since\n     /// intermediate values do not have to be dropped in that case.\n-    pub fn local_scope(&self) -> Option<region::Scope> {\n+    crate fn local_scope(&self) -> Option<region::Scope> {\n         match self.hir.body_owner_kind {\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) =>\n             // No need to free storage in this context.\n@@ -729,7 +729,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     // Schedule an abort block - this is used for some ABIs that cannot unwind\n-    pub fn schedule_abort(&mut self) -> BasicBlock {\n+    crate fn schedule_abort(&mut self) -> BasicBlock {\n         let source_info = self.scopes.source_info(self.scopes.len(), self.fn_span);\n         let abortblk = self.cfg.start_new_cleanup_block();\n         self.cfg.terminate(abortblk, source_info, TerminatorKind::Abort);\n@@ -739,7 +739,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Scheduling drops\n     // ================\n-    pub fn schedule_drop_storage_and_value(\n+    crate fn schedule_drop_storage_and_value(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// When called with `DropKind::Storage`, `place` should be a local\n     /// with an index higher than the current `self.arg_count`.\n-    pub fn schedule_drop(\n+    crate fn schedule_drop(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n@@ -884,7 +884,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// spurious borrow-check errors -- the problem, ironically, is\n     /// not the `DROP(_X)` itself, but the (spurious) unwind pathways\n     /// that it creates. See #64391 for an example.\n-    pub fn record_operands_moved(&mut self, operands: &[Operand<'tcx>]) {\n+    crate fn record_operands_moved(&mut self, operands: &[Operand<'tcx>]) {\n         let scope = match self.local_scope() {\n             None => {\n                 // if there is no local scope, operands won't be dropped anyway\n@@ -921,7 +921,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This is a special case because the temporary for the condition needs to\n     /// be dropped on both the true and the false arm.\n-    pub fn test_bool(\n+    crate fn test_bool(\n         &mut self,\n         mut block: BasicBlock,\n         condition: Expr<'tcx>,\n@@ -978,7 +978,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This path terminates in Resume. Returns the start of the path.\n     /// See module comment for more details.\n-    pub fn diverge_cleanup(&mut self) -> BasicBlock {\n+    crate fn diverge_cleanup(&mut self) -> BasicBlock {\n         self.diverge_cleanup_gen(false)\n     }\n \n@@ -1033,7 +1033,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n-    pub fn build_drop_and_replace(\n+    crate fn build_drop_and_replace(\n         &mut self,\n         block: BasicBlock,\n         span: Span,\n@@ -1059,7 +1059,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Creates an Assert terminator and return the success block.\n     /// If the boolean condition operand is not the expected value,\n     /// a runtime panic will be caused with the given message.\n-    pub fn assert(\n+    crate fn assert(\n         &mut self,\n         block: BasicBlock,\n         cond: Operand<'tcx>,\n@@ -1293,7 +1293,7 @@ fn build_diverge_scope<'tcx>(\n     target\n }\n \n-fn push_storage_deads(\n+fn push_storage_deads<'tcx>(\n     cfg: &mut CFG<'tcx>,\n     target: BasicBlock,\n     storage_deads: &mut Vec<Statement<'tcx>>,", "previous_filename": "src/librustc_mir/build/scope.rs"}, {"sha": "a4bedfa6490e20599073369387d1d241bbcf607d", "filename": "src/librustc_mir_build/hair/constant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fconstant.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "previous_filename": "src/librustc_mir/hair/constant.rs"}, {"sha": "a883b84f8fe2f2d07da2779d15d815d02ed691b8", "filename": "src/librustc_mir_build/hair/cx/block.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fblock.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -101,7 +101,7 @@ fn mirror_stmts<'a, 'tcx>(\n     return result;\n }\n \n-pub fn to_expr_ref<'a, 'tcx>(\n+crate fn to_expr_ref<'a, 'tcx>(\n     cx: &mut Cx<'a, 'tcx>,\n     block: &'tcx hir::Block<'tcx>,\n ) -> ExprRef<'tcx> {", "previous_filename": "src/librustc_mir/hair/cx/block.rs"}, {"sha": "97e718118292d3d7ff6dc3a183bade320a9df448", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -577,8 +577,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n     Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind }\n }\n \n-fn user_substs_applied_to_res(\n-    cx: &mut Cx<'a, 'tcx>,\n+fn user_substs_applied_to_res<'tcx>(\n+    cx: &mut Cx<'_, 'tcx>,\n     hir_id: hir::HirId,\n     res: Res,\n ) -> Option<ty::CanonicalUserType<'tcx>> {\n@@ -775,7 +775,7 @@ fn convert_path_expr<'a, 'tcx>(\n     }\n }\n \n-fn convert_var(\n+fn convert_var<'tcx>(\n     cx: &mut Cx<'_, 'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,\n     var_hir_id: hir::HirId,", "previous_filename": "src/librustc_mir/hair/cx/expr.rs"}, {"sha": "5fc9a1ecad555b6b540d90cc93f4f1153f58b4dd", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "renamed", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -21,18 +21,18 @@ use syntax::ast;\n use syntax::attr;\n \n #[derive(Clone)]\n-pub struct Cx<'a, 'tcx> {\n+crate struct Cx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n \n-    pub root_lint_level: hir::HirId,\n-    pub param_env: ty::ParamEnv<'tcx>,\n+    crate root_lint_level: hir::HirId,\n+    crate param_env: ty::ParamEnv<'tcx>,\n \n     /// Identity `InternalSubsts` for use with const-evaluation.\n-    pub identity_substs: &'tcx InternalSubsts<'tcx>,\n+    crate identity_substs: &'tcx InternalSubsts<'tcx>,\n \n-    pub region_scope_tree: &'tcx region::ScopeTree,\n-    pub tables: &'a ty::TypeckTables<'tcx>,\n+    crate region_scope_tree: &'tcx region::ScopeTree,\n+    crate tables: &'a ty::TypeckTables<'tcx>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,\n     /// `const`, or the body of a `const fn`.\n@@ -42,7 +42,7 @@ pub struct Cx<'a, 'tcx> {\n     body_owner: DefId,\n \n     /// What kind of body is being compiled.\n-    pub body_owner_kind: hir::BodyOwnerKind,\n+    crate body_owner_kind: hir::BodyOwnerKind,\n \n     /// Whether this constant/function needs overflow checks.\n     check_overflow: bool,\n@@ -52,7 +52,7 @@ pub struct Cx<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Cx<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>, src_id: hir::HirId) -> Cx<'a, 'tcx> {\n+    crate fn new(infcx: &'a InferCtxt<'a, 'tcx>, src_id: hir::HirId) -> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let src_def_id = tcx.hir().local_def_id(src_id);\n         let tables = tcx.typeck_tables_of(src_def_id);\n@@ -92,42 +92,42 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn control_flow_destroyed(self) -> Vec<(Span, String)> {\n+    crate fn control_flow_destroyed(self) -> Vec<(Span, String)> {\n         self.control_flow_destroyed\n     }\n }\n \n impl<'a, 'tcx> Cx<'a, 'tcx> {\n     /// Normalizes `ast` into the appropriate \"mirror\" type.\n-    pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n+    crate fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n         ast.make_mirror(self)\n     }\n \n-    pub fn usize_ty(&mut self) -> Ty<'tcx> {\n+    crate fn usize_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.types.usize\n     }\n \n-    pub fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n+    crate fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n         ty::Const::from_usize(self.tcx, value)\n     }\n \n-    pub fn bool_ty(&mut self) -> Ty<'tcx> {\n+    crate fn bool_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.types.bool\n     }\n \n-    pub fn unit_ty(&mut self) -> Ty<'tcx> {\n+    crate fn unit_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.mk_unit()\n     }\n \n-    pub fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n+    crate fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n         ty::Const::from_bool(self.tcx, true)\n     }\n \n-    pub fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n+    crate fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n         ty::Const::from_bool(self.tcx, false)\n     }\n \n-    pub fn const_eval_literal(\n+    crate fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n         ty: Ty<'tcx>,\n@@ -151,15 +151,15 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         }\n     }\n \n-    pub fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n+    crate fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),\n         };\n-        Pat::from_hir(self.tcx, self.param_env.and(self.identity_substs), self.tables(), p)\n+        Pat::from_hir(self.tcx, self.param_env, self.tables(), p)\n     }\n \n-    pub fn trait_method(\n+    crate fn trait_method(\n         &mut self,\n         trait_def_id: DefId,\n         method_name: Symbol,\n@@ -168,6 +168,8 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     ) -> &'tcx ty::Const<'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n+            // The unhygienic comparison here is acceptable because this is only\n+            // used on known traits.\n             if item.kind == ty::AssocKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n@@ -178,32 +180,32 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n-    pub fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: VariantIdx) -> Vec<Field> {\n+    crate fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: VariantIdx) -> Vec<Field> {\n         (0..adt_def.variants[variant_index].fields.len()).map(Field::new).collect()\n     }\n \n-    pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n+    crate fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n         ty.needs_drop(self.tcx, self.param_env)\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'tcx> {\n+    crate fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n-    pub fn tables(&self) -> &'a ty::TypeckTables<'tcx> {\n+    crate fn tables(&self) -> &'a ty::TypeckTables<'tcx> {\n         self.tables\n     }\n \n-    pub fn check_overflow(&self) -> bool {\n+    crate fn check_overflow(&self) -> bool {\n         self.check_overflow\n     }\n \n-    pub fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+    crate fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n     }\n }\n \n-impl UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n+impl<'tcx> UserAnnotatedTyHelpers<'tcx> for Cx<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx()\n     }", "previous_filename": "src/librustc_mir/hair/cx/mod.rs"}, {"sha": "6cf8122e200dbaec731b9585ee8933a933b4b216", "filename": "src/librustc_mir_build/hair/cx/to_ref.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fto_ref.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -2,7 +2,7 @@ use crate::hair::*;\n \n use rustc_hir as hir;\n \n-pub trait ToRef {\n+crate trait ToRef {\n     type Output;\n     fn to_ref(self) -> Self::Output;\n }", "previous_filename": "src/librustc_mir/hair/cx/to_ref.rs"}, {"sha": "3257f282dc1cba005c24ab084cce9e735d9164d0", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "renamed", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -17,52 +17,52 @@ use rustc_hir::def_id::DefId;\n use rustc_span::Span;\n \n mod constant;\n-pub mod cx;\n+crate mod cx;\n \n-pub mod pattern;\n-pub(crate) use self::pattern::PatTyProj;\n-pub use self::pattern::{BindingMode, FieldPat, Pat, PatKind, PatRange};\n+crate mod pattern;\n+crate use self::pattern::PatTyProj;\n+crate use self::pattern::{BindingMode, FieldPat, Pat, PatKind, PatRange};\n \n mod util;\n \n #[derive(Copy, Clone, Debug)]\n-pub enum LintLevel {\n+crate enum LintLevel {\n     Inherited,\n     Explicit(hir::HirId),\n }\n \n #[derive(Clone, Debug)]\n-pub struct Block<'tcx> {\n-    pub targeted_by_break: bool,\n-    pub region_scope: region::Scope,\n-    pub opt_destruction_scope: Option<region::Scope>,\n-    pub span: Span,\n-    pub stmts: Vec<StmtRef<'tcx>>,\n-    pub expr: Option<ExprRef<'tcx>>,\n-    pub safety_mode: BlockSafety,\n+crate struct Block<'tcx> {\n+    crate targeted_by_break: bool,\n+    crate region_scope: region::Scope,\n+    crate opt_destruction_scope: Option<region::Scope>,\n+    crate span: Span,\n+    crate stmts: Vec<StmtRef<'tcx>>,\n+    crate expr: Option<ExprRef<'tcx>>,\n+    crate safety_mode: BlockSafety,\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum BlockSafety {\n+crate enum BlockSafety {\n     Safe,\n     ExplicitUnsafe(hir::HirId),\n     PushUnsafe,\n     PopUnsafe,\n }\n \n #[derive(Clone, Debug)]\n-pub enum StmtRef<'tcx> {\n+crate enum StmtRef<'tcx> {\n     Mirror(Box<Stmt<'tcx>>),\n }\n \n #[derive(Clone, Debug)]\n-pub struct Stmt<'tcx> {\n-    pub kind: StmtKind<'tcx>,\n-    pub opt_destruction_scope: Option<region::Scope>,\n+crate struct Stmt<'tcx> {\n+    crate kind: StmtKind<'tcx>,\n+    crate opt_destruction_scope: Option<region::Scope>,\n }\n \n #[derive(Clone, Debug)]\n-pub enum StmtKind<'tcx> {\n+crate enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n         scope: region::Scope,\n@@ -112,23 +112,23 @@ rustc_data_structures::static_assert_size!(Expr<'_>, 168);\n /// example, method calls and overloaded operators are absent: they are\n /// expected to be converted into `Expr::Call` instances.\n #[derive(Clone, Debug)]\n-pub struct Expr<'tcx> {\n+crate struct Expr<'tcx> {\n     /// type of this expression\n-    pub ty: Ty<'tcx>,\n+    crate ty: Ty<'tcx>,\n \n     /// lifetime of this expression if it should be spilled into a\n     /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<region::Scope>,\n+    crate temp_lifetime: Option<region::Scope>,\n \n     /// span of the expression in the source\n-    pub span: Span,\n+    crate span: Span,\n \n     /// kind of expression\n-    pub kind: ExprKind<'tcx>,\n+    crate kind: ExprKind<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub enum ExprKind<'tcx> {\n+crate enum ExprKind<'tcx> {\n     Scope {\n         region_scope: region::Scope,\n         lint_level: LintLevel,\n@@ -288,37 +288,37 @@ pub enum ExprKind<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum ExprRef<'tcx> {\n+crate enum ExprRef<'tcx> {\n     Hair(&'tcx hir::Expr<'tcx>),\n     Mirror(Box<Expr<'tcx>>),\n }\n \n #[derive(Clone, Debug)]\n-pub struct FieldExprRef<'tcx> {\n-    pub name: Field,\n-    pub expr: ExprRef<'tcx>,\n+crate struct FieldExprRef<'tcx> {\n+    crate name: Field,\n+    crate expr: ExprRef<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct FruInfo<'tcx> {\n-    pub base: ExprRef<'tcx>,\n-    pub field_types: Vec<Ty<'tcx>>,\n+crate struct FruInfo<'tcx> {\n+    crate base: ExprRef<'tcx>,\n+    crate field_types: Vec<Ty<'tcx>>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Arm<'tcx> {\n-    pub pattern: Pat<'tcx>,\n-    pub guard: Option<Guard<'tcx>>,\n-    pub body: ExprRef<'tcx>,\n-    pub lint_level: LintLevel,\n-    pub scope: region::Scope,\n-    pub span: Span,\n+crate struct Arm<'tcx> {\n+    crate pattern: Pat<'tcx>,\n+    crate guard: Option<Guard<'tcx>>,\n+    crate body: ExprRef<'tcx>,\n+    crate lint_level: LintLevel,\n+    crate scope: region::Scope,\n+    crate span: Span,\n }\n \n-impl Arm<'tcx> {\n+impl<'tcx> Arm<'tcx> {\n     // HACK(or_patterns; Centril | dlrobertson): Remove this and\n     // correctly handle each case in which this method is used.\n-    pub fn top_pats_hack(&self) -> &[Pat<'tcx>] {\n+    crate fn top_pats_hack(&self) -> &[Pat<'tcx>] {\n         match &*self.pattern.kind {\n             PatKind::Or { pats } => pats,\n             _ => std::slice::from_ref(&self.pattern),\n@@ -327,18 +327,18 @@ impl Arm<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum Guard<'tcx> {\n+crate enum Guard<'tcx> {\n     If(ExprRef<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum LogicalOp {\n+crate enum LogicalOp {\n     And,\n     Or,\n }\n \n impl<'tcx> ExprRef<'tcx> {\n-    pub fn span(&self) -> Span {\n+    crate fn span(&self) -> Span {\n         match self {\n             ExprRef::Hair(expr) => expr.span,\n             ExprRef::Mirror(expr) => expr.span,\n@@ -361,7 +361,7 @@ impl<'tcx> ExprRef<'tcx> {\n /// mirrored. This allows a single AST node from the compiler to\n /// expand into one or more Hair nodes, which lets the Hair nodes be\n /// simpler.\n-pub trait Mirror<'tcx> {\n+crate trait Mirror<'tcx> {\n     type Output;\n \n     fn make_mirror(self, cx: &mut Cx<'_, 'tcx>) -> Self::Output;\n@@ -378,7 +378,7 @@ impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror(self, hir: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror(self, hir: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n         match self {\n             ExprRef::Hair(h) => h.make_mirror(hir),\n             ExprRef::Mirror(m) => *m,", "previous_filename": "src/librustc_mir/hair/mod.rs"}, {"sha": "8fcaa1e8082fb67ac3f16220c45f29e8690ecdb8", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "renamed", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -230,7 +230,6 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n use super::{compare_const_vals, PatternFoldable, PatternFolder};\n@@ -260,7 +259,7 @@ use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n use std::u128;\n \n-pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n+crate fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n     LiteralExpander { tcx: cx.tcx, param_env: cx.param_env }.fold_pattern(&pat)\n }\n \n@@ -269,7 +268,7 @@ struct LiteralExpander<'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl LiteralExpander<'tcx> {\n+impl<'tcx> LiteralExpander<'tcx> {\n     /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n     ///\n     /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n@@ -323,7 +322,7 @@ impl LiteralExpander<'tcx> {\n     }\n }\n \n-impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander<'tcx> {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind, pat.kind);\n         match (&pat.ty.kind, &*pat.kind) {\n@@ -381,10 +380,10 @@ impl<'tcx> Pat<'tcx> {\n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n /// works well.\n #[derive(Debug, Clone)]\n-pub struct PatStack<'p, 'tcx>(SmallVec<[&'p Pat<'tcx>; 2]>);\n+crate struct PatStack<'p, 'tcx>(SmallVec<[&'p Pat<'tcx>; 2]>);\n \n impl<'p, 'tcx> PatStack<'p, 'tcx> {\n-    pub fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n+    crate fn from_pattern(pat: &'p Pat<'tcx>) -> Self {\n         PatStack(smallvec![pat])\n     }\n \n@@ -472,15 +471,15 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n \n /// A 2D matrix.\n #[derive(Clone)]\n-pub struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n+crate struct Matrix<'p, 'tcx>(Vec<PatStack<'p, 'tcx>>);\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n-    pub fn empty() -> Self {\n+    crate fn empty() -> Self {\n         Matrix(vec![])\n     }\n \n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this expands it.\n-    pub fn push(&mut self, row: PatStack<'p, 'tcx>) {\n+    crate fn push(&mut self, row: PatStack<'p, 'tcx>) {\n         if let Some(rows) = row.expand_or_pat() {\n             self.0.extend(rows);\n         } else {\n@@ -569,22 +568,21 @@ impl<'p, 'tcx> FromIterator<PatStack<'p, 'tcx>> for Matrix<'p, 'tcx> {\n     }\n }\n \n-pub struct MatchCheckCtxt<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n+crate struct MatchCheckCtxt<'a, 'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n     /// not. E.g., `struct Foo { _private: ! }` cannot be seen to be empty\n     /// outside it's module and should not be matchable with an empty match\n     /// statement.\n-    pub module: DefId,\n+    crate module: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    pub pattern_arena: &'a TypedArena<Pat<'tcx>>,\n-    pub byte_array_map: FxHashMap<*const Pat<'tcx>, Vec<&'a Pat<'tcx>>>,\n+    crate pattern_arena: &'a TypedArena<Pat<'tcx>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n-    pub fn create_and_enter<F, R>(\n+    crate fn create_and_enter<F, R>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         module: DefId,\n@@ -595,13 +593,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     {\n         let pattern_arena = TypedArena::default();\n \n-        f(MatchCheckCtxt {\n-            tcx,\n-            param_env,\n-            module,\n-            pattern_arena: &pattern_arena,\n-            byte_array_map: FxHashMap::default(),\n-        })\n+        f(MatchCheckCtxt { tcx, param_env, module, pattern_arena: &pattern_arena })\n     }\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n@@ -613,7 +605,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n \n     // Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n-    pub fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n+    crate fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.kind {\n             ty::Adt(def, ..) => {\n                 def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did.is_local()\n@@ -773,13 +765,13 @@ impl<'tcx> Constructor<'tcx> {\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         adt: &'tcx ty::AdtDef,\n     ) -> VariantIdx {\n-        match self {\n-            Variant(id) => adt.variant_index_with_id(*id),\n+        match *self {\n+            Variant(id) => adt.variant_index_with_id(id),\n             Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            ConstantValue(c) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n+            ConstantValue(c) => cx.tcx.destructure_const(cx.param_env.and(c)).variant,\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n@@ -1058,7 +1050,7 @@ impl<'tcx> Constructor<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-pub enum Usefulness<'tcx, 'p> {\n+crate enum Usefulness<'tcx, 'p> {\n     /// Carries a list of unreachable subpatterns. Used only in the presence of or-patterns.\n     Useful(Vec<&'p Pat<'tcx>>),\n     /// Carries a list of witnesses of non-exhaustiveness.\n@@ -1146,7 +1138,7 @@ impl<'tcx, 'p> Usefulness<'tcx, 'p> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum WitnessPreference {\n+crate enum WitnessPreference {\n     ConstructWitness,\n     LeaveOutWitness,\n }\n@@ -1190,10 +1182,10 @@ struct PatCtxt<'tcx> {\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n #[derive(Clone, Debug)]\n-pub struct Witness<'tcx>(Vec<Pat<'tcx>>);\n+crate struct Witness<'tcx>(Vec<Pat<'tcx>>);\n \n impl<'tcx> Witness<'tcx> {\n-    pub fn single_pattern(self) -> Pat<'tcx> {\n+    crate fn single_pattern(self) -> Pat<'tcx> {\n         assert_eq!(self.0.len(), 1);\n         self.0.into_iter().next().unwrap()\n     }\n@@ -1358,9 +1350,9 @@ fn all_constructors<'a, 'tcx>(\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n #[derive(Clone, Debug)]\n struct IntRange<'tcx> {\n-    pub range: RangeInclusive<u128>,\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n+    range: RangeInclusive<u128>,\n+    ty: Ty<'tcx>,\n+    span: Span,\n }\n \n impl<'tcx> IntRange<'tcx> {\n@@ -1631,7 +1623,7 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-pub fn is_useful<'p, 'tcx>(\n+crate fn is_useful<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n@@ -2238,7 +2230,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n     split_ctors\n }\n \n-fn lint_overlapping_patterns(\n+fn lint_overlapping_patterns<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     hir_id: Option<HirId>,\n     ctor_range: IntRange<'tcx>,", "previous_filename": "src/librustc_mir/hair/pattern/_match.rs"}, {"sha": "84d57a89c983e28a1efef295813493dad96109ca", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "renamed", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -8,7 +8,6 @@ use rustc::hir::map::Map;\n use rustc::lint;\n use rustc::session::parse::feature_err;\n use rustc::session::Session;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_error_codes::*;\n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder};\n@@ -29,12 +28,8 @@ crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n         Some(id) => tcx.hir().body_owned_by(id),\n     };\n \n-    let mut visitor = MatchVisitor {\n-        tcx,\n-        tables: tcx.body_tables(body_id),\n-        param_env: tcx.param_env(def_id),\n-        identity_substs: InternalSubsts::identity_for_item(tcx, def_id),\n-    };\n+    let mut visitor =\n+        MatchVisitor { tcx, tables: tcx.body_tables(body_id), param_env: tcx.param_env(def_id) };\n     visitor.visit_body(tcx.hir().body(body_id));\n }\n \n@@ -46,7 +41,6 @@ struct MatchVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    identity_substs: SubstsRef<'tcx>,\n }\n \n impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n@@ -153,11 +147,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             let inlined_arms: Vec<_> = arms\n                 .iter()\n                 .map(|arm| {\n-                    let mut patcx = PatCtxt::new(\n-                        self.tcx,\n-                        self.param_env.and(self.identity_substs),\n-                        self.tables,\n-                    );\n+                    let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n                     patcx.include_lint_checks();\n                     let pattern = patcx.lower_pattern(&arm.pat);\n                     let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n@@ -189,8 +179,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n-            let mut patcx =\n-                PatCtxt::new(self.tcx, self.param_env.and(self.identity_substs), self.tables);\n+            let mut patcx = PatCtxt::new(self.tcx, self.param_env, self.tables);\n             patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;", "previous_filename": "src/librustc_mir/hair/pattern/check_match.rs"}, {"sha": "a21a0ee8a1b200371524873b6209c833a144e215", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "renamed", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -1,5 +1,3 @@\n-use crate::const_eval::const_variant_index;\n-\n use rustc::infer::InferCtxt;\n use rustc::lint;\n use rustc::mir::Field;\n@@ -167,18 +165,14 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let adt_subpattern = |i, variant_opt| {\n-            let field = Field::new(i);\n-            let val = crate::const_eval::const_field(tcx, param_env, variant_opt, field, cv);\n-            self.recur(val)\n-        };\n-        let adt_subpatterns = |n, variant_opt| {\n-            (0..n)\n-                .map(|i| {\n-                    let field = Field::new(i);\n-                    FieldPat { field, pattern: adt_subpattern(i, variant_opt) }\n+        let field_pats = |vals: &[&'tcx ty::Const<'tcx>]| {\n+            vals.iter()\n+                .enumerate()\n+                .map(|(idx, val)| {\n+                    let field = Field::new(idx);\n+                    FieldPat { field, pattern: self.recur(val) }\n                 })\n-                .collect::<Vec<_>>()\n+                .collect()\n         };\n \n         let kind = match cv.ty.kind {\n@@ -235,21 +229,28 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let variant_index = const_variant_index(tcx, self.param_env, cv);\n-                let subpatterns = adt_subpatterns(\n-                    adt_def.variants[variant_index].fields.len(),\n-                    Some(variant_index),\n-                );\n-                PatKind::Variant { adt_def, substs, variant_index, subpatterns }\n+                let destructured = tcx.destructure_const(param_env.and(cv));\n+                PatKind::Variant {\n+                    adt_def,\n+                    substs,\n+                    variant_index: destructured.variant,\n+                    subpatterns: field_pats(destructured.fields),\n+                }\n+            }\n+            ty::Adt(_, _) => {\n+                let destructured = tcx.destructure_const(param_env.and(cv));\n+                PatKind::Leaf { subpatterns: field_pats(destructured.fields) }\n             }\n-            ty::Adt(adt_def, _) => {\n-                let struct_var = adt_def.non_enum_variant();\n-                PatKind::Leaf { subpatterns: adt_subpatterns(struct_var.fields.len(), None) }\n+            ty::Tuple(_) => {\n+                let destructured = tcx.destructure_const(param_env.and(cv));\n+                PatKind::Leaf { subpatterns: field_pats(destructured.fields) }\n             }\n-            ty::Tuple(fields) => PatKind::Leaf { subpatterns: adt_subpatterns(fields.len(), None) },\n-            ty::Array(_, n) => PatKind::Array {\n-                prefix: (0..n.eval_usize(tcx, self.param_env))\n-                    .map(|i| adt_subpattern(i as usize, None))\n+            ty::Array(..) => PatKind::Array {\n+                prefix: tcx\n+                    .destructure_const(param_env.and(cv))\n+                    .fields\n+                    .iter()\n+                    .map(|val| self.recur(val))\n                     .collect(),\n                 slice: None,\n                 suffix: Vec::new(),", "previous_filename": "src/librustc_mir/hair/pattern/const_to_pat.rs"}, {"sha": "9e00c4ea53a0fda4d4a753cd48462d9ffc816278", "filename": "src/librustc_mir_build/hair/pattern/mod.rs", "status": "renamed", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fmod.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -31,30 +31,30 @@ use std::fmt;\n use rustc_error_codes::*;\n \n #[derive(Clone, Debug)]\n-pub enum PatternError {\n+crate enum PatternError {\n     AssocConstInPattern(Span),\n     StaticInPattern(Span),\n     FloatBug,\n     NonConstPath(Span),\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum BindingMode {\n+crate enum BindingMode {\n     ByValue,\n     ByRef(BorrowKind),\n }\n \n #[derive(Clone, Debug)]\n-pub struct FieldPat<'tcx> {\n-    pub field: Field,\n-    pub pattern: Pat<'tcx>,\n+crate struct FieldPat<'tcx> {\n+    crate field: Field,\n+    crate pattern: Pat<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Pat<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n-    pub kind: Box<PatKind<'tcx>>,\n+crate struct Pat<'tcx> {\n+    crate ty: Ty<'tcx>,\n+    crate span: Span,\n+    crate kind: Box<PatKind<'tcx>>,\n }\n \n impl<'tcx> Pat<'tcx> {\n@@ -64,8 +64,8 @@ impl<'tcx> Pat<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatTyProj<'tcx> {\n-    pub user_ty: CanonicalUserType<'tcx>,\n+crate struct PatTyProj<'tcx> {\n+    crate user_ty: CanonicalUserType<'tcx>,\n }\n \n impl<'tcx> PatTyProj<'tcx> {\n@@ -91,8 +91,8 @@ impl<'tcx> PatTyProj<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct Ascription<'tcx> {\n-    pub user_ty: PatTyProj<'tcx>,\n+crate struct Ascription<'tcx> {\n+    crate user_ty: PatTyProj<'tcx>,\n     /// Variance to use when relating the type `user_ty` to the **type of the value being\n     /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n     /// have a type that is some subtype of the ascribed type.\n@@ -111,12 +111,12 @@ pub struct Ascription<'tcx> {\n     /// requires that `&'static str <: T_x`, where `T_x` is the type of `x`. Really, we should\n     /// probably be checking for a `PartialEq` impl instead, but this preserves the behavior\n     /// of the old type-check for now. See #57280 for details.\n-    pub variance: ty::Variance,\n-    pub user_ty_span: Span,\n+    crate variance: ty::Variance,\n+    crate user_ty_span: Span,\n }\n \n #[derive(Clone, Debug)]\n-pub enum PatKind<'tcx> {\n+crate enum PatKind<'tcx> {\n     Wild,\n \n     AscribeUserType {\n@@ -184,10 +184,10 @@ pub enum PatKind<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatRange<'tcx> {\n-    pub lo: &'tcx ty::Const<'tcx>,\n-    pub hi: &'tcx ty::Const<'tcx>,\n-    pub end: RangeEnd,\n+crate struct PatRange<'tcx> {\n+    crate lo: &'tcx ty::Const<'tcx>,\n+    crate hi: &'tcx ty::Const<'tcx>,\n+    crate end: RangeEnd,\n }\n \n impl<'tcx> fmt::Display for Pat<'tcx> {\n@@ -342,23 +342,22 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n     }\n }\n \n-pub struct PatCtxt<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub param_env: ty::ParamEnv<'tcx>,\n-    pub tables: &'a ty::TypeckTables<'tcx>,\n-    pub substs: SubstsRef<'tcx>,\n-    pub errors: Vec<PatternError>,\n+crate struct PatCtxt<'a, 'tcx> {\n+    crate tcx: TyCtxt<'tcx>,\n+    crate param_env: ty::ParamEnv<'tcx>,\n+    crate tables: &'a ty::TypeckTables<'tcx>,\n+    crate errors: Vec<PatternError>,\n     include_lint_checks: bool,\n }\n \n impl<'a, 'tcx> Pat<'tcx> {\n-    pub fn from_hir(\n+    crate fn from_hir(\n         tcx: TyCtxt<'tcx>,\n-        param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n         tables: &'a ty::TypeckTables<'tcx>,\n         pat: &'tcx hir::Pat<'tcx>,\n     ) -> Self {\n-        let mut pcx = PatCtxt::new(tcx, param_env_and_substs, tables);\n+        let mut pcx = PatCtxt::new(tcx, param_env, tables);\n         let result = pcx.lower_pattern(pat);\n         if !pcx.errors.is_empty() {\n             let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n@@ -370,27 +369,20 @@ impl<'a, 'tcx> Pat<'tcx> {\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n-    pub fn new(\n+    crate fn new(\n         tcx: TyCtxt<'tcx>,\n-        param_env_and_substs: ty::ParamEnvAnd<'tcx, SubstsRef<'tcx>>,\n+        param_env: ty::ParamEnv<'tcx>,\n         tables: &'a ty::TypeckTables<'tcx>,\n     ) -> Self {\n-        PatCtxt {\n-            tcx,\n-            param_env: param_env_and_substs.param_env,\n-            tables,\n-            substs: param_env_and_substs.value,\n-            errors: vec![],\n-            include_lint_checks: false,\n-        }\n+        PatCtxt { tcx, param_env, tables, errors: vec![], include_lint_checks: false }\n     }\n \n-    pub fn include_lint_checks(&mut self) -> &mut Self {\n+    crate fn include_lint_checks(&mut self) -> &mut Self {\n         self.include_lint_checks = true;\n         self\n     }\n \n-    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n+    crate fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -863,7 +855,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     }\n }\n \n-impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n+impl<'tcx> UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -873,15 +865,15 @@ impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     }\n }\n \n-pub trait PatternFoldable<'tcx>: Sized {\n+crate trait PatternFoldable<'tcx>: Sized {\n     fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n     }\n \n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n-pub trait PatternFolder<'tcx>: Sized {\n+crate trait PatternFolder<'tcx>: Sized {\n     fn fold_pattern(&mut self, pattern: &Pat<'tcx>) -> Pat<'tcx> {\n         pattern.super_fold_with(self)\n     }\n@@ -1009,7 +1001,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n     }\n }\n \n-pub fn compare_const_vals<'tcx>(\n+crate fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,", "previous_filename": "src/librustc_mir/hair/pattern/mod.rs"}, {"sha": "c27844ed0d0328996389ece84596a7386a865241", "filename": "src/librustc_mir_build/hair/util.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Futil.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "previous_filename": "src/librustc_mir/hair/util.rs"}, {"sha": "96032a732abd67afc1a72685c088f1fe7a31021c", "filename": "src/librustc_mir_build/lib.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flib.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -0,0 +1,26 @@\n+//! Construction of MIR from HIR.\n+//!\n+//! This crate also contains the match exhaustiveness and usefulness checking.\n+\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(slice_patterns)]\n+#![feature(bool_to_option)]\n+#![recursion_limit = \"256\"]\n+\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate rustc;\n+\n+mod build;\n+mod hair;\n+mod lints;\n+\n+use rustc::ty::query::Providers;\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.check_match = hair::pattern::check_match;\n+    providers.mir_built = build::mir_built;\n+}"}, {"sha": "4244e1b8d80a668ca8e22daacabf21259a702bb9", "filename": "src/librustc_mir_build/lints.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -7,15 +7,15 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::FnKind;\n use rustc_index::bit_set::BitSet;\n \n-pub fn check(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n+crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n         check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), body, def_id);\n     }\n }\n \n-fn check_fn_for_unconditional_recursion(\n+fn check_fn_for_unconditional_recursion<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     fn_kind: FnKind<'_>,\n     body: &Body<'tcx>,", "previous_filename": "src/librustc_mir/lints.rs"}, {"sha": "7217fe1b02f4e1741ee466db8313b136fc272424", "filename": "src/test/ui/pattern/const-pat-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3589292515b811400463409b5fd5afea2aef03b/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b3589292515b811400463409b5fd5afea2aef03b/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr?ref=b3589292515b811400463409b5fd5afea2aef03b", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:LL:CC\n+thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir_build/hair/pattern/_match.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}]}