{"sha": "c818a1df9b4e3b518dcd839d18818f25cf1237a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MThhMWRmOWI0ZTNiNTE4ZGNkODM5ZDE4ODE4ZjI1Y2YxMjM3YTI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-26T12:11:39Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:21:08Z"}, "message": "Remove specific parameter iterators from hir::Generics", "tree": {"sha": "60d6fc898f6ace8f7900d8dff95f6866442a8044", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60d6fc898f6ace8f7900d8dff95f6866442a8044"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c818a1df9b4e3b518dcd839d18818f25cf1237a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c818a1df9b4e3b518dcd839d18818f25cf1237a2", "html_url": "https://github.com/rust-lang/rust/commit/c818a1df9b4e3b518dcd839d18818f25cf1237a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c818a1df9b4e3b518dcd839d18818f25cf1237a2/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5", "html_url": "https://github.com/rust-lang/rust/commit/82dba3d419d3cfac00cc90bc8d078e6ae0a724f5"}], "stats": {"total": 350, "additions": 214, "deletions": 136}, "files": [{"sha": "ae7d8bd84037ca897bf76dee5dbacabb2bd35366", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -379,22 +379,29 @@ impl<'a> LoweringContext<'a> {\n                     let item_lifetimes = match self.lctx.items.get(&item.id).unwrap().node {\n                         hir::Item_::ItemImpl(_, _, _, ref generics, ..)\n                         | hir::Item_::ItemTrait(_, _, ref generics, ..) => {\n-                            generics.lifetimes().cloned().collect::<Vec<_>>()\n+                            generics.params\n+                                    .iter()\n+                                    .filter_map(|param| match param.kind {\n+                                        hir::GenericParamKind::Lifetime { .. } => {\n+                                            Some(param.clone())\n+                                        }\n+                                        _ => None,\n+                                    })\n+                            .collect::<Vec<_>>()\n                         }\n                         _ => Vec::new(),\n                     };\n \n-                    self.lctx\n-                        .with_parent_impl_lifetime_defs(&item_lifetimes, |this| {\n-                            let this = &mut ItemLowerer { lctx: this };\n-                            if let ItemKind::Impl(_, _, _, _, ref opt_trait_ref, _, _) = item.node {\n-                                this.with_trait_impl_ref(opt_trait_ref, |this| {\n-                                    visit::walk_item(this, item)\n-                                });\n-                            } else {\n-                                visit::walk_item(this, item);\n-                            }\n-                        });\n+                    self.lctx.with_parent_impl_lifetime_defs(&item_lifetimes, |this| {\n+                        let this = &mut ItemLowerer { lctx: this };\n+                        if let ItemKind::Impl(_, _, _, _, ref opt_trait_ref, _, _) = item.node {\n+                            this.with_trait_impl_ref(opt_trait_ref, |this| {\n+                                visit::walk_item(this, item)\n+                            });\n+                        } else {\n+                            visit::walk_item(this, item);\n+                        }\n+                    });\n                 }\n             }\n "}, {"sha": "9193f309e37481e9b461b1d1f58ac9113e964792", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 19, "deletions": 31, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -519,6 +519,11 @@ impl GenericParam {\n     }\n }\n \n+pub struct GenericParamCount {\n+    pub lifetimes: usize,\n+    pub types: usize,\n+}\n+\n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -540,40 +545,23 @@ impl Generics {\n         }\n     }\n \n-    pub fn is_lt_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => true,\n-                _ => false,\n-            }\n-        })\n-    }\n-\n-    pub fn is_type_parameterized(&self) -> bool {\n-        self.params.iter().any(|param| {\n-            match param.kind {\n-                GenericParamKind::Type { .. } => true,\n-                _ => false,\n-            }\n-        })\n-    }\n+    pub fn own_counts(&self) -> GenericParamCount {\n+        // We could cache this as a property of `GenericParamCount`, but\n+        // the aim is to refactor this away entirely eventually and the\n+        // presence of this method will be a constant reminder.\n+        let mut own_counts = GenericParamCount {\n+            lifetimes: 0,\n+            types: 0,\n+        };\n \n-    pub fn lifetimes<'a>(&'a self) -> impl DoubleEndedIterator<Item = &'a GenericParam> {\n-        self.params.iter().filter(|param| {\n+        for param in &self.params {\n             match param.kind {\n-                GenericParamKind::Lifetime { .. } => true,\n-                _ => false,\n-            }\n-        })\n-    }\n+                GenericParamKind::Lifetime { .. } => own_counts.lifetimes += 1,\n+                GenericParamKind::Type { .. } => own_counts.types += 1,\n+            };\n+        }\n \n-    pub fn ty_params<'a>(&'a self) -> impl DoubleEndedIterator<Item = &'a GenericParam> {\n-        self.params.iter().filter(|param| {\n-            match param.kind {\n-                GenericParamKind::Type { .. } => true,\n-                _ => false,\n-            }\n-        })\n+        own_counts\n     }\n }\n "}, {"sha": "c65a0e6d1729af6f2a57ff139aabe52a3080e225", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 97, "deletions": 45, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -532,11 +532,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 } else {\n                     0\n                 };\n-                let lifetimes = generics\n-                    .lifetimes()\n-                    .map(|def| Region::early(&self.tcx.hir, &mut index, def))\n-                    .collect();\n-                let next_early_index = index + generics.ty_params().count() as u32;\n+                let mut next_early_index = index;\n+                let lifetimes = generics.params.iter().filter_map(|param| {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                            None\n+                        }\n+                    }\n+                }).collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n@@ -691,19 +698,25 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                 let mut elision = None;\n                 let mut lifetimes = FxHashMap();\n-                for lt_def in generics.lifetimes() {\n-                    let (lt_name, region) = Region::early(&self.tcx.hir, &mut index, &lt_def);\n-                    if let hir::LifetimeName::Underscore = lt_name {\n-                        // Pick the elided lifetime \"definition\" if one exists and use it to make\n-                        // an elision scope.\n-                        elision = Some(region);\n-                    } else {\n-                        lifetimes.insert(lt_name, region);\n+                let mut next_early_index = index;\n+                for param in &generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n+                            if let hir::LifetimeName::Underscore = name {\n+                                // Pick the elided lifetime \"definition\" if one exists\n+                                // and use it to make an elision scope.\n+                                elision = Some(reg);\n+                            } else {\n+                                lifetimes.insert(name, reg);\n+                            }\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                        }\n                     }\n                 }\n \n-                let next_early_index = index + generics.ty_params().count() as u32;\n-\n                 if let Some(elision_region) = elision {\n                     let scope = Scope::Elision {\n                         elide: Elide::Exact(elision_region),\n@@ -760,12 +773,22 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let generics = &trait_item.generics;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n-                    .lifetimes()\n-                    .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n+                let mut next_early_index = index;\n+                let lifetimes = generics.params\n+                    .iter()\n+                    .filter_map(|param| {\n+                        match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            }\n+                            GenericParamKind::Type { .. } => {\n+                                next_early_index += 1;\n+                                None\n+                            }\n+                        }\n+                    })\n                     .collect();\n \n-                let next_early_index = index + generics.ty_params().count() as u32;\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n@@ -806,13 +829,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             Type(ref ty) => {\n                 let generics = &impl_item.generics;\n                 let mut index = self.next_early_index();\n+                let mut next_early_index = index;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n-                    .lifetimes()\n-                    .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n+                let lifetimes = generics.params\n+                    .iter()\n+                    .filter_map(|param| {\n+                        match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some(Region::early(&self.tcx.hir, &mut index, param))\n+                            }\n+                            GenericParamKind::Type { .. } => {\n+                                next_early_index += 1;\n+                                None\n+                            }\n+                        }\n+                    })\n                     .collect();\n \n-                let next_early_index = index + generics.ty_params().count() as u32;\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n@@ -863,9 +896,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+\n         check_mixed_explicit_and_in_band_defs(\n             self.tcx,\n-            &generics.lifetimes().cloned().collect::<Vec<_>>(),\n+            &generics.params.iter().filter_map(|param| {\n+                match param.kind {\n+                    GenericParamKind::Lifetime { .. } => Some(param.clone()),\n+                    _ => None,\n+                }\n+            }).collect::<Vec<_>>()\n         );\n         for param in &generics.params {\n             match param.kind {\n@@ -1216,12 +1255,18 @@ fn compute_object_lifetime_defaults(\n                         .map(|set| match *set {\n                             Set1::Empty => \"BaseDefault\".to_string(),\n                             Set1::One(Region::Static) => \"'static\".to_string(),\n-                            Set1::One(Region::EarlyBound(i, _, _)) => generics\n-                                .lifetimes()\n-                                .nth(i as usize)\n-                                .unwrap()\n-                                .name()\n-                                .to_string(),\n+                            Set1::One(Region::EarlyBound(i, _, _)) => {\n+                                let mut j = 0;\n+                                generics.params.iter().find(|param| {\n+                                    match param.kind {\n+                                        GenericParamKind::Lifetime { .. } => j += 1,\n+                                        _ => {}\n+                                    }\n+                                    i == j\n+                                }).unwrap()\n+                                  .name()\n+                                  .to_string()\n+                            }\n                             Set1::One(_) => bug!(),\n                             Set1::Many => \"Ambiguous\".to_string(),\n                         })\n@@ -1485,19 +1530,26 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        let lifetimes = generics\n-            .lifetimes()\n-            .map(|param| {\n-                if self.map.late_bound.contains(&param.id) {\n-                    Region::late(&self.tcx.hir, param)\n-                } else {\n-                    Region::early(&self.tcx.hir, &mut index, param)\n+        let mut next_early_index = index;\n+        let lifetimes = generics.params\n+            .iter()\n+            .filter_map(|param| {\n+                match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {\n+                        if self.map.late_bound.contains(&param.id) {\n+                            Some(Region::late(&self.tcx.hir, param))\n+                        } else {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                    }\n+                    GenericParamKind::Type { .. } => {\n+                        next_early_index += 1;\n+                        None\n+                    }\n                 }\n             })\n             .collect();\n \n-        let next_early_index = index + generics.ty_params().count() as u32;\n-\n         let scope = Scope::Binder {\n             lifetimes,\n             next_early_index,\n@@ -2513,10 +2565,10 @@ fn insert_late_bound_lifetimes(\n     // - appear in the inputs\n     // - do not appear in the where-clauses\n     // - are not implicitly captured by `impl Trait`\n-    for lifetime in generics.lifetimes() {\n-        let name = match lifetime.kind {\n+    for param in &generics.params {\n+        let name = match param.kind {\n             GenericParamKind::Lifetime { name, .. } => name,\n-            _ => bug!(),\n+            _ => continue,\n         };\n \n         // appears in the where clauses? early-bound.\n@@ -2533,10 +2585,10 @@ fn insert_late_bound_lifetimes(\n \n         debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n                name,\n-               lifetime.id);\n+               param.id);\n \n-        let inserted = map.late_bound.insert(lifetime.id);\n-        assert!(inserted, \"visited lifetime {:?} twice\", lifetime.id);\n+        let inserted = map.late_bound.insert(param.id);\n+        assert!(inserted, \"visited lifetime {:?} twice\", param.id);\n     }\n \n     return;"}, {"sha": "18b7024a8986d9420a5b5a5384949df564aa6cae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -1196,15 +1196,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         }\n                         err.emit();\n                     }\n-                    if generics.is_type_parameterized() {\n-                        let mut err = cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS,\n-                                                          it.span,\n-                                                          \"functions generic over \\\n-                                                           types must be mangled\");\n-                        err.span_suggestion_short(no_mangle_attr.span,\n-                                                  \"remove this attribute\",\n-                                                  \"\".to_owned());\n-                        err.emit();\n+                    for param in &generics.params {\n+                        match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {}\n+                            GenericParamKind::Type { .. } => {\n+                                let mut err = cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS,\n+                                                                  it.span,\n+                                                                  \"functions generic over \\\n+                                                                   types must be mangled\");\n+                                err.span_suggestion_short(no_mangle_attr.span,\n+                                                          \"remove this attribute\",\n+                                                          \"\".to_owned());\n+                                err.emit();\n+                                break;\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "a4299f3bf377cca150bc8e460f953df0cc364115", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -1236,9 +1236,14 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 }\n                 hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n                 hir::ItemFn(_, _, constness, _, ref generics, _) => {\n-                    let has_tps = generics.ty_params().next().is_some();\n+                    let has_types = generics.params.iter().find(|param| {\n+                        match param.kind {\n+                            hir::GenericParamKind::Type { .. } => true,\n+                            _ => false,\n+                        }\n+                    }).is_some();\n                     let needs_inline =\n-                        (has_tps || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n+                        (has_types || tcx.codegen_fn_attrs(def_id).requests_inline()) &&\n                             !self.metadata_output_only();\n                     let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n                     if needs_inline || constness == hir::Constness::Const || always_encode_mir {"}, {"sha": "9f5b9d405a1efdd5265bb7e7947d8997f91af703", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -1105,8 +1105,11 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       ref generics,\n                       ..,\n                       ref impl_item_refs) => {\n-            if generics.is_type_parameterized() {\n-                return\n+            for param in &generics.params {\n+                match param.kind {\n+                    hir::GenericParamKind::Lifetime { .. } => {}\n+                    hir::GenericParamKind::Type { .. } => return,\n+                }\n             }\n \n             let impl_def_id = tcx.hir.local_def_id(item.id);"}, {"sha": "8faef103f81c8c58996fb574182c398c1d68a3ee", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -5166,27 +5166,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        generics: &hir::Generics,\n                                        ty: Ty<'tcx>) {\n-    debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n-           generics.ty_params().count(),  ty);\n+    let own_counts = generics.own_counts();\n+    debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\", own_counts.types, ty);\n \n-    // make a vector of booleans initially false, set to true when used\n-    if generics.ty_params().next().is_none() { return; }\n-    let mut tps_used = vec![false; generics.ty_params().count()];\n-\n-    let lifetime_count = generics.lifetimes().count();\n+    if own_counts.types == 0 {\n+        return;\n+    }\n+    // Make a vector of booleans initially false, set to true when used.\n+    let mut types_used = vec![false; own_counts.types];\n \n     for leaf_ty in ty.walk() {\n-        if let ty::TyParam(ty::ParamTy {idx, ..}) = leaf_ty.sty {\n+        if let ty::TyParam(ty::ParamTy { idx, .. }) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n-            tps_used[idx as usize - lifetime_count] = true;\n+            types_used[idx as usize - own_counts.lifetimes] = true;\n         } else if let ty::TyError = leaf_ty.sty {\n-            // If there already another error, do not emit an error for not using a type Parameter\n+            // If there is already another error, do not emit\n+            // an error for not using a type Parameter.\n             assert!(tcx.sess.err_count() > 0);\n             return;\n         }\n     }\n \n-    for (&used, param) in tps_used.iter().zip(generics.ty_params()) {\n+    let types = generics.params.iter().filter(|param| {\n+        match param.kind {\n+            hir::GenericParamKind::Type { .. } => true,\n+            _ => false,\n+        }\n+    });\n+    for (&used, param) in types_used.iter().zip(types) {\n         if !used {\n             struct_span_err!(tcx.sess, param.span, E0091, \"type parameter `{}` is unused\",\n                              param.name())"}, {"sha": "ef34c1a1c9c7583779d6d83e1eb5e015d6d9c653", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -756,10 +756,15 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             outer_index: ty::INNERMOST,\n             has_late_bound_regions: None,\n         };\n-        for lifetime in generics.lifetimes() {\n-            let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n-            if tcx.is_late_bound(hir_id) {\n-                return Some(lifetime.span);\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    let hir_id = tcx.hir.node_to_hir_id(param.id);\n+                    if tcx.is_late_bound(hir_id) {\n+                        return Some(param.span);\n+                    }\n+                }\n+                _ => {},\n             }\n         }\n         visitor.visit_fn_decl(decl);\n@@ -915,7 +920,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Now create the real type parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n-    params.extend(ast_generics.ty_params().enumerate().map(|(i, param)| {\n+    let mut i = 0;\n+    params.extend(ast_generics.params.iter().filter_map(|param| {\n         match param.kind {\n             GenericParamKind::Type { ref default, synthetic, .. } => {\n                 if param.name() == keywords::SelfType.name() {\n@@ -934,7 +940,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     }\n                 }\n \n-                ty::GenericParamDef {\n+                let ty_param = ty::GenericParamDef {\n                     index: type_start + i as u32,\n                     name: param.name().as_interned_str(),\n                     def_id: tcx.hir.local_def_id(param.id),\n@@ -945,9 +951,11 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             object_lifetime_defaults.as_ref().map_or(rl::Set1::Empty, |o| o[i]),\n                         synthetic,\n                     },\n-                }\n+                };\n+                i += 1;\n+                Some(ty_param)\n             }\n-            _ => bug!()\n+            _ => None,\n         }\n     }));\n \n@@ -1462,20 +1470,22 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n-    for param in ast_generics.ty_params() {\n-        let param_ty = ty::ParamTy::new(index, param.name().as_interned_str()).to_ty(tcx);\n-        index += 1;\n-\n-        let bounds = match param.kind {\n-            GenericParamKind::Type { ref bounds, .. } => bounds,\n-            _ => bug!(),\n-        };\n-        let bounds = compute_bounds(&icx,\n-                                    param_ty,\n-                                    bounds,\n-                                    SizedByDefault::Yes,\n-                                    param.span);\n-        predicates.extend(bounds.predicates(tcx, param_ty));\n+    for param in &ast_generics.params {\n+        match param.kind {\n+            GenericParamKind::Type { ref bounds, .. } => {\n+                let param_ty = ty::ParamTy::new(index, param.name().as_interned_str())\n+                                           .to_ty(tcx);\n+                index += 1;\n+\n+                let bounds = compute_bounds(&icx,\n+                                            param_ty,\n+                                            bounds,\n+                                            SizedByDefault::Yes,\n+                                            param.span);\n+                predicates.extend(bounds.predicates(tcx, param_ty));\n+            }\n+            _ => {}\n+        }\n     }\n \n     // Add in the bounds that appear in the where-clause"}, {"sha": "352c65f792876c5782a1c1f0db08a359d143fd09", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c818a1df9b4e3b518dcd839d18818f25cf1237a2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c818a1df9b4e3b518dcd839d18818f25cf1237a2", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::def_id::DefIndexAddressSpace;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind, GenericParamCount};\n+use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n@@ -2863,7 +2863,7 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     provided_params.with_generic_args(|generic_args| {\n-                        let mut indices = GenericParamCount {\n+                        let mut indices = ty::GenericParamCount {\n                             lifetimes: 0,\n                             types: 0\n                         };"}]}