{"sha": "2867c40925e8f7b440ff50a421a2d3726b9ff334", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NjdjNDA5MjVlOGY3YjQ0MGZmNTBhNDIxYTJkMzcyNmI5ZmYzMzQ=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-09-16T10:48:54Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-09-19T16:38:27Z"}, "message": "introduce FromSource trait", "tree": {"sha": "95a8f33d0c334debf5eec41c2edf6fb01a5dcb49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95a8f33d0c334debf5eec41c2edf6fb01a5dcb49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2867c40925e8f7b440ff50a421a2d3726b9ff334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2867c40925e8f7b440ff50a421a2d3726b9ff334", "html_url": "https://github.com/rust-lang/rust/commit/2867c40925e8f7b440ff50a421a2d3726b9ff334", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2867c40925e8f7b440ff50a421a2d3726b9ff334/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c35ef7e1ed97172ab644248185b75dceebb0d35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c35ef7e1ed97172ab644248185b75dceebb0d35a", "html_url": "https://github.com/rust-lang/rust/commit/c35ef7e1ed97172ab644248185b75dceebb0d35a"}], "stats": {"total": 432, "additions": 294, "deletions": 138}, "files": [{"sha": "28002f7400f3bf076899a40506624fa82c813b8a", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -313,7 +313,7 @@ pub struct StructField {\n     pub(crate) id: StructFieldId,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq)]\n pub enum FieldSource {\n     Named(ast::RecordFieldDef),\n     Pos(ast::TupleFieldDef),"}, {"sha": "c6ad85fc7ca6c0037af54acff00158db942d5c71", "filename": "crates/ra_hir/src/from_source.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -0,0 +1,211 @@\n+use ra_db::{FileId, FilePosition};\n+use ra_syntax::{\n+    algo::find_node_at_offset,\n+    ast::{self, AstNode, NameOwner},\n+    SyntaxNode,\n+};\n+\n+use crate::{\n+    db::{AstDatabase, DefDatabase, HirDatabase},\n+    ids::{AstItemDef, LocationCtx},\n+    name::AsName,\n+    Const, Crate, Enum, EnumVariant, FieldSource, Function, HasSource, ImplBlock, Module,\n+    ModuleSource, Source, Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+};\n+\n+pub trait FromSource: Sized {\n+    type Ast;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self>;\n+}\n+\n+impl FromSource for Struct {\n+    type Ast = ast::StructDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(Struct { id })\n+    }\n+}\n+impl FromSource for Union {\n+    type Ast = ast::StructDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(Union { id })\n+    }\n+}\n+impl FromSource for Enum {\n+    type Ast = ast::EnumDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(Enum { id })\n+    }\n+}\n+impl FromSource for Trait {\n+    type Ast = ast::TraitDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(Trait { id })\n+    }\n+}\n+impl FromSource for Function {\n+    type Ast = ast::FnDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(Function { id })\n+    }\n+}\n+impl FromSource for Const {\n+    type Ast = ast::ConstDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(Const { id })\n+    }\n+}\n+impl FromSource for Static {\n+    type Ast = ast::StaticDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(Static { id })\n+    }\n+}\n+impl FromSource for TypeAlias {\n+    type Ast = ast::TypeAliasDef;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let id = from_source(db, src)?;\n+        Some(TypeAlias { id })\n+    }\n+}\n+// FIXME: add impl FromSource for MacroDef\n+\n+impl FromSource for ImplBlock {\n+    type Ast = ast::ImplBlock;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let module_src = crate::ModuleSource::from_child_node(\n+            db,\n+            src.file_id.original_file(db),\n+            &src.ast.syntax(),\n+        );\n+        let module = Module::from_definition(db, Source { file_id: src.file_id, ast: module_src })?;\n+        let impls = module.impl_blocks(db);\n+        impls.into_iter().find(|b| b.source(db) == src)\n+    }\n+}\n+\n+impl FromSource for EnumVariant {\n+    type Ast = ast::EnumVariant;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let parent_enum = src.ast.parent_enum();\n+        let src_enum = Source { file_id: src.file_id, ast: parent_enum };\n+        let variants = Enum::from_source(db, src_enum)?.variants(db);\n+        variants.into_iter().find(|v| v.source(db) == src)\n+    }\n+}\n+\n+impl FromSource for StructField {\n+    type Ast = FieldSource;\n+    fn from_source(db: &(impl DefDatabase + AstDatabase), src: Source<Self::Ast>) -> Option<Self> {\n+        let variant_def: VariantDef = match src.ast {\n+            FieldSource::Named(ref field) => {\n+                let ast = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n+                let src = Source { file_id: src.file_id, ast };\n+                let def = Struct::from_source(db, src)?;\n+                VariantDef::from(def)\n+            }\n+            FieldSource::Pos(ref field) => {\n+                let ast = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n+                let src = Source { file_id: src.file_id, ast };\n+                let def = EnumVariant::from_source(db, src)?;\n+                VariantDef::from(def)\n+            }\n+        };\n+        variant_def\n+            .variant_data(db)\n+            .fields()\n+            .into_iter()\n+            .flat_map(|it| it.iter())\n+            .map(|(id, _)| StructField { parent: variant_def.clone(), id })\n+            .find(|f| f.source(db) == src)\n+    }\n+}\n+\n+// FIXME: simplify it\n+impl ModuleSource {\n+    pub fn from_position(\n+        db: &(impl DefDatabase + AstDatabase),\n+        position: FilePosition,\n+    ) -> ModuleSource {\n+        let parse = db.parse(position.file_id);\n+        match &find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n+            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n+            _ => {\n+                let source_file = parse.tree().to_owned();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+        }\n+    }\n+\n+    pub fn from_child_node(\n+        db: &(impl DefDatabase + AstDatabase),\n+        file_id: FileId,\n+        child: &SyntaxNode,\n+    ) -> ModuleSource {\n+        if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n+            ModuleSource::Module(m.clone())\n+        } else {\n+            let source_file = db.parse(file_id).tree().to_owned();\n+            ModuleSource::SourceFile(source_file)\n+        }\n+    }\n+\n+    pub fn from_file_id(db: &(impl DefDatabase + AstDatabase), file_id: FileId) -> ModuleSource {\n+        let source_file = db.parse(file_id).tree().to_owned();\n+        ModuleSource::SourceFile(source_file)\n+    }\n+}\n+\n+impl Module {\n+    pub fn from_declaration(db: &impl HirDatabase, src: Source<ast::Module>) -> Option<Self> {\n+        let src_parent = Source {\n+            file_id: src.file_id,\n+            ast: ModuleSource::new(db, Some(src.file_id.original_file(db)), None),\n+        };\n+        let parent_module = Module::from_definition(db, src_parent)?;\n+        let child_name = src.ast.name()?;\n+        parent_module.child(db, &child_name.as_name())\n+    }\n+\n+    pub fn from_definition(\n+        db: &(impl DefDatabase + AstDatabase),\n+        src: Source<ModuleSource>,\n+    ) -> Option<Self> {\n+        let decl_id = match src.ast {\n+            ModuleSource::Module(ref module) => {\n+                assert!(!module.has_semi());\n+                let ast_id_map = db.ast_id_map(src.file_id);\n+                let item_id = ast_id_map.ast_id(module).with_file_id(src.file_id);\n+                Some(item_id)\n+            }\n+            ModuleSource::SourceFile(_) => None,\n+        };\n+\n+        let source_root_id = db.file_source_root(src.file_id.original_file(db));\n+        db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map(\n+            |krate| {\n+                let def_map = db.crate_def_map(krate);\n+                let module_id = def_map.find_module_by_source(src.file_id, decl_id)?;\n+                Some(Module { krate, module_id })\n+            },\n+        )\n+    }\n+}\n+\n+fn from_source<N, DEF>(db: &(impl DefDatabase + AstDatabase), src: Source<N>) -> Option<DEF>\n+where\n+    N: AstNode,\n+    DEF: AstItemDef<N>,\n+{\n+    let module_src =\n+        crate::ModuleSource::from_child_node(db, src.file_id.original_file(db), &src.ast.syntax());\n+    let module = Module::from_definition(db, Source { file_id: src.file_id, ast: module_src })?;\n+    let ctx = LocationCtx::new(db, module, src.file_id);\n+    Some(DEF::from_ast(ctx, &src.ast))\n+}"}, {"sha": "a9de9fb6b1c425451bafb6f5226069fc0302d158", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -53,6 +53,8 @@ pub mod diagnostics;\n \n mod code_model;\n \n+pub mod from_source;\n+\n #[cfg(test)]\n mod marks;\n \n@@ -67,6 +69,7 @@ pub use self::{\n     adt::VariantDef,\n     either::Either,\n     expr::ExprScopes,\n+    from_source::FromSource,\n     generics::{GenericParam, GenericParams, HasGenericParams},\n     ids::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n     impl_block::ImplBlock,"}, {"sha": "cb405091ee141f39aa498859fc82151d144b0ccf", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -93,7 +93,11 @@ impl MockDatabase {\n         let mut files: Vec<FileId> = self.files.values().copied().collect();\n         files.sort();\n         for file in files {\n-            let module = crate::source_binder::module_from_file_id(self, file).unwrap();\n+            let src = crate::Source {\n+                file_id: file.into(),\n+                ast: crate::ModuleSource::new(self, Some(file), None),\n+            };\n+            let module = crate::Module::from_definition(self, src).unwrap();\n             module.diagnostics(\n                 self,\n                 &mut DiagnosticSink::new(|d| {"}, {"sha": "c41862a0bd4408160955eb2438e6a469da30230d", "filename": "crates/ra_hir/src/nameres/tests/incremental.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -114,7 +114,11 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n     );\n     {\n         let events = db.log_executed(|| {\n-            let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+            let src = crate::Source {\n+                file_id: pos.file_id.into(),\n+                ast: crate::ModuleSource::new(&db, Some(pos.file_id), None),\n+            };\n+            let module = crate::Module::from_definition(&db, src).unwrap();\n             let decls = module.declarations(&db);\n             assert_eq!(decls.len(), 18);\n         });\n@@ -124,7 +128,11 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n \n     {\n         let events = db.log_executed(|| {\n-            let module = crate::source_binder::module_from_file_id(&db, pos.file_id).unwrap();\n+            let src = crate::Source {\n+                file_id: pos.file_id.into(),\n+                ast: crate::ModuleSource::new(&db, Some(pos.file_id), None),\n+            };\n+            let module = crate::Module::from_definition(&db, src).unwrap();\n             let decls = module.declarations(&db);\n             assert_eq!(decls.len(), 18);\n         });"}, {"sha": "296acc3642a49d9a0e8b368a04e537e625158237", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 17, "deletions": 107, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -7,10 +7,9 @@\n /// purely for \"IDE needs\".\n use std::sync::Arc;\n \n-use ra_db::{FileId, FilePosition};\n+use ra_db::FileId;\n use ra_syntax::{\n-    algo::find_node_at_offset,\n-    ast::{self, AstNode, NameOwner},\n+    ast::{self, AstNode},\n     AstPtr,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxNodePtr, TextRange, TextUnit,\n@@ -28,119 +27,28 @@ use crate::{\n     path::known,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::implements_trait,\n-    AsName, AstId, Const, Crate, DefWithBody, Either, Enum, Function, HasBody, HirFileId, MacroDef,\n-    Module, Name, Path, Resolver, Static, Struct, Trait, Ty,\n+    AsName, Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId, MacroDef,\n+    Module, Name, Path, Resolver, Static, Struct, Ty,\n };\n \n-/// Locates the module by `FileId`. Picks topmost module in the file.\n-pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Option<Module> {\n-    module_from_source(db, file_id.into(), None)\n-}\n-\n-/// Locates the child module by `mod child;` declaration.\n-pub fn module_from_declaration(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    decl: ast::Module,\n-) -> Option<Module> {\n-    let parent_module = module_from_file_id(db, file_id);\n-    let child_name = decl.name();\n-    match (parent_module, child_name) {\n-        (Some(parent_module), Some(child_name)) => parent_module.child(db, &child_name.as_name()),\n-        _ => None,\n-    }\n-}\n-\n-/// Locates the module by position in the source code.\n-pub fn module_from_position(db: &impl HirDatabase, position: FilePosition) -> Option<Module> {\n-    let parse = db.parse(position.file_id);\n-    match &find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n-        Some(m) if !m.has_semi() => module_from_inline(db, position.file_id, m.clone()),\n-        _ => module_from_file_id(db, position.file_id),\n-    }\n-}\n-\n-fn module_from_inline(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    module: ast::Module,\n-) -> Option<Module> {\n-    assert!(!module.has_semi());\n-    let file_id = file_id.into();\n-    let ast_id_map = db.ast_id_map(file_id);\n-    let item_id = ast_id_map.ast_id(&module).with_file_id(file_id);\n-    module_from_source(db, file_id, Some(item_id))\n-}\n-\n-/// Locates the module by child syntax element within the module\n-pub fn module_from_child_node(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    child: &SyntaxNode,\n-) -> Option<Module> {\n-    if let Some(m) = child.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi()) {\n-        module_from_inline(db, file_id, m)\n-    } else {\n-        module_from_file_id(db, file_id)\n-    }\n-}\n-\n-fn module_from_source(\n-    db: &impl HirDatabase,\n-    file_id: HirFileId,\n-    decl_id: Option<AstId<ast::Module>>,\n-) -> Option<Module> {\n-    let source_root_id = db.file_source_root(file_id.as_original_file());\n-    db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map(\n-        |krate| {\n-            let def_map = db.crate_def_map(krate);\n-            let module_id = def_map.find_module_by_source(file_id, decl_id)?;\n-            Some(Module { krate, module_id })\n-        },\n-    )\n-}\n-\n-pub fn struct_from_module(\n-    db: &impl HirDatabase,\n-    module: Module,\n-    struct_def: &ast::StructDef,\n-) -> Struct {\n-    let file_id = module.definition_source(db).file_id;\n-    let ctx = LocationCtx::new(db, module, file_id);\n-    Struct { id: ctx.to_def(struct_def) }\n-}\n-\n-pub fn enum_from_module(db: &impl HirDatabase, module: Module, enum_def: &ast::EnumDef) -> Enum {\n-    let file_id = module.definition_source(db).file_id;\n-    let ctx = LocationCtx::new(db, module, file_id);\n-    Enum { id: ctx.to_def(enum_def) }\n-}\n-\n-pub fn trait_from_module(\n-    db: &impl HirDatabase,\n-    module: Module,\n-    trait_def: &ast::TraitDef,\n-) -> Trait {\n-    let file_id = module.definition_source(db).file_id;\n-    let ctx = LocationCtx::new(db, module, file_id);\n-    Trait { id: ctx.to_def(trait_def) }\n-}\n-\n fn try_get_resolver_for_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<Resolver> {\n     if let Some(module) = ast::Module::cast(node.clone()) {\n-        Some(module_from_declaration(db, file_id, module)?.resolver(db))\n-    } else if let Some(_) = ast::SourceFile::cast(node.clone()) {\n-        Some(module_from_source(db, file_id.into(), None)?.resolver(db))\n+        let src = crate::Source { file_id: file_id.into(), ast: module };\n+        Some(crate::Module::from_declaration(db, src)?.resolver(db))\n+    } else if let Some(file) = ast::SourceFile::cast(node.clone()) {\n+        let src =\n+            crate::Source { file_id: file_id.into(), ast: crate::ModuleSource::SourceFile(file) };\n+        Some(crate::Module::from_definition(db, src)?.resolver(db))\n     } else if let Some(s) = ast::StructDef::cast(node.clone()) {\n-        let module = module_from_child_node(db, file_id, s.syntax())?;\n-        Some(struct_from_module(db, module, &s).resolver(db))\n+        let src = crate::Source { file_id: file_id.into(), ast: s };\n+        Some(Struct::from_source(db, src)?.resolver(db))\n     } else if let Some(e) = ast::EnumDef::cast(node.clone()) {\n-        let module = module_from_child_node(db, file_id, e.syntax())?;\n-        Some(enum_from_module(db, module, &e).resolver(db))\n+        let src = crate::Source { file_id: file_id.into(), ast: e };\n+        Some(Enum::from_source(db, src)?.resolver(db))\n     } else if node.kind() == FN_DEF || node.kind() == CONST_DEF || node.kind() == STATIC_DEF {\n         Some(def_with_body_from_child_node(db, file_id, node)?.resolver(db))\n     } else {\n@@ -154,8 +62,10 @@ fn def_with_body_from_child_node(\n     file_id: FileId,\n     node: &SyntaxNode,\n ) -> Option<DefWithBody> {\n-    let module = module_from_child_node(db, file_id, node)?;\n+    let src = crate::ModuleSource::from_child_node(db, file_id, node);\n+    let module = Module::from_definition(db, crate::Source { file_id: file_id.into(), ast: src })?;\n     let ctx = LocationCtx::new(db, module, file_id.into());\n+\n     node.ancestors().find_map(|node| {\n         if let Some(def) = ast::FnDef::cast(node.clone()) {\n             return Some(Function { id: ctx.to_def(&def) }.into());"}, {"sha": "59bd3689b51668f62eb8ee9f2590633855cf4e63", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -1,4 +1,3 @@\n-use hir::source_binder;\n use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n     ast, AstNode, Parse, SourceFile,\n@@ -47,7 +46,11 @@ impl<'a> CompletionContext<'a> {\n         original_parse: &'a Parse<ast::SourceFile>,\n         position: FilePosition,\n     ) -> Option<CompletionContext<'a>> {\n-        let module = source_binder::module_from_position(db, position);\n+        let src = hir::ModuleSource::from_position(db, position);\n+        let module = hir::Module::from_definition(\n+            db,\n+            hir::Source { file_id: position.file_id.into(), ast: src },\n+        );\n         let token =\n             original_parse.tree().syntax().token_at_offset(position.offset).left_biased()?;\n         let analyzer ="}, {"sha": "1ae152e5b107917b7b3bf648e022f549e9e8df3f", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -1,9 +1,6 @@\n use std::cell::RefCell;\n \n-use hir::{\n-    diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink},\n-    source_binder,\n-};\n+use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n use ra_assists::ast_editor::{AstBuilder, AstEditor};\n use ra_db::SourceDatabase;\n@@ -89,7 +86,10 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             fix: Some(fix),\n         })\n     });\n-    if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n+    let source_file = db.parse(file_id).tree().to_owned();\n+    let src =\n+        hir::Source { file_id: file_id.into(), ast: hir::ModuleSource::SourceFile(source_file) };\n+    if let Some(m) = hir::Module::from_definition(db, src) {\n         m.diagnostics(db, &mut sink);\n     };\n     drop(sink);"}, {"sha": "bc8863dadb0d15fb8d5c6674c01c9188a6124648", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -96,9 +96,8 @@ pub(crate) fn name_definition(\n \n     if let Some(module) = ast::Module::cast(parent.clone()) {\n         if module.has_semi() {\n-            if let Some(child_module) =\n-                hir::source_binder::module_from_declaration(db, file_id, module)\n-            {\n+            let src = hir::Source { file_id: file_id.into(), ast: module };\n+            if let Some(child_module) = hir::Module::from_declaration(db, src) {\n                 let nav = NavigationTarget::from_module(db, child_module);\n                 return Some(vec![nav]);\n             }"}, {"sha": "f57f9a21b6d02ac735690067d087505710bae95e", "filename": "crates/ra_ide_api/src/impls.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimpls.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::HirDatabase, source_binder, ApplicationTy, Ty, TypeCtor};\n+use hir::{db::HirDatabase, ApplicationTy, FromSource, Ty, TypeCtor};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n@@ -11,17 +11,21 @@ pub(crate) fn goto_implementation(\n     let parse = db.parse(position.file_id);\n     let syntax = parse.tree().syntax().clone();\n \n-    let module = source_binder::module_from_position(db, position)?;\n+    let src = hir::ModuleSource::from_position(db, position);\n+    let module = hir::Module::from_definition(\n+        db,\n+        hir::Source { file_id: position.file_id.into(), ast: src },\n+    )?;\n \n     if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             nominal_def.syntax().text_range(),\n-            impls_for_def(db, &nominal_def, module)?,\n+            impls_for_def(db, position, &nominal_def, module)?,\n         ));\n     } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             trait_def.syntax().text_range(),\n-            impls_for_trait(db, &trait_def, module)?,\n+            impls_for_trait(db, position, &trait_def, module)?,\n         ));\n     }\n \n@@ -30,14 +34,19 @@ pub(crate) fn goto_implementation(\n \n fn impls_for_def(\n     db: &RootDatabase,\n+    position: FilePosition,\n     node: &ast::NominalDef,\n     module: hir::Module,\n ) -> Option<Vec<NavigationTarget>> {\n     let ty = match node {\n         ast::NominalDef::StructDef(def) => {\n-            source_binder::struct_from_module(db, module, &def).ty(db)\n+            let src = hir::Source { file_id: position.file_id.into(), ast: def.clone() };\n+            hir::Struct::from_source(db, src)?.ty(db)\n+        }\n+        ast::NominalDef::EnumDef(def) => {\n+            let src = hir::Source { file_id: position.file_id.into(), ast: def.clone() };\n+            hir::Enum::from_source(db, src)?.ty(db)\n         }\n-        ast::NominalDef::EnumDef(def) => source_binder::enum_from_module(db, module, &def).ty(db),\n     };\n \n     let krate = module.krate(db)?;\n@@ -54,10 +63,12 @@ fn impls_for_def(\n \n fn impls_for_trait(\n     db: &RootDatabase,\n+    position: FilePosition,\n     node: &ast::TraitDef,\n     module: hir::Module,\n ) -> Option<Vec<NavigationTarget>> {\n-    let tr = source_binder::trait_from_module(db, module, node);\n+    let src = hir::Source { file_id: position.file_id.into(), ast: node.clone() };\n+    let tr = hir::Trait::from_source(db, src)?;\n \n     let krate = module.krate(db)?;\n     let impls = db.impls_in_crate(krate);"}, {"sha": "3668da8d7470b0e15aca2a260acb526af895a6b7", "filename": "crates/ra_ide_api/src/parent_module.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fparent_module.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -5,7 +5,11 @@ use crate::{db::RootDatabase, NavigationTarget};\n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {\n-    let module = match hir::source_binder::module_from_position(db, position) {\n+    let src = hir::ModuleSource::from_position(db, position);\n+    let module = match hir::Module::from_definition(\n+        db,\n+        hir::Source { file_id: position.file_id.into(), ast: src },\n+    ) {\n         None => return Vec::new(),\n         Some(it) => it,\n     };\n@@ -15,10 +19,12 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n \n /// Returns `Vec` for the same reason as `parent_module`\n pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n-    let module = match hir::source_binder::module_from_file_id(db, file_id) {\n-        Some(it) => it,\n-        None => return Vec::new(),\n-    };\n+    let src = hir::ModuleSource::from_file_id(db, file_id);\n+    let module =\n+        match hir::Module::from_definition(db, hir::Source { file_id: file_id.into(), ast: src }) {\n+            Some(it) => it,\n+            None => return Vec::new(),\n+        };\n     let krate = match module.krate(db) {\n         Some(it) => it,\n         None => return Vec::new(),"}, {"sha": "acca71f2a8052761ee869c183df3f00c09dc891b", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -1,4 +1,4 @@\n-use hir::{source_binder, Either, ModuleSource};\n+use hir::{Either, ModuleSource};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SourceFile, SyntaxNode};\n use relative_path::{RelativePath, RelativePathBuf};\n@@ -135,9 +135,8 @@ fn rename_mod(\n ) -> Option<SourceChange> {\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n-    if let Some(module) =\n-        source_binder::module_from_declaration(db, position.file_id, ast_module.clone())\n-    {\n+    let module_src = hir::Source { file_id: position.file_id.into(), ast: ast_module.clone() };\n+    if let Some(module) = hir::Module::from_declaration(db, module_src) {\n         let src = module.definition_source(db);\n         let file_id = src.file_id.as_original_file();\n         match src.ast {"}, {"sha": "095ca56c4c879a5d1f8a4874901b545ec21c1d61", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2867c40925e8f7b440ff50a421a2d3726b9ff334/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=2867c40925e8f7b440ff50a421a2d3726b9ff334", "patch": "@@ -63,7 +63,9 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Opti\n         return None;\n     }\n     let range = module.syntax().text_range();\n-    let module = hir::source_binder::module_from_child_node(db, file_id, module.syntax())?;\n+    let src = hir::ModuleSource::from_child_node(db, file_id, &module.syntax());\n+    let module =\n+        hir::Module::from_definition(db, hir::Source { file_id: file_id.into(), ast: src })?;\n \n     let path = module.path_to_root(db).into_iter().rev().filter_map(|it| it.name(db)).join(\"::\");\n     Some(Runnable { range, kind: RunnableKind::TestMod { path } })"}]}