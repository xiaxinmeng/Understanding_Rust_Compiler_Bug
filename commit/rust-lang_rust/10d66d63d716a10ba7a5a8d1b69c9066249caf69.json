{"sha": "10d66d63d716a10ba7a5a8d1b69c9066249caf69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZDY2ZDYzZDcxNmExMGJhN2E1YThkMWI2OWM5MDY2MjQ5Y2FmNjk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-10T08:15:55Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-11T13:29:33Z"}, "message": "introduce SourceAnalyzer", "tree": {"sha": "3897deea123f2bec49c28cdeb453ae0cfa0f49f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3897deea123f2bec49c28cdeb453ae0cfa0f49f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10d66d63d716a10ba7a5a8d1b69c9066249caf69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10d66d63d716a10ba7a5a8d1b69c9066249caf69", "html_url": "https://github.com/rust-lang/rust/commit/10d66d63d716a10ba7a5a8d1b69c9066249caf69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10d66d63d716a10ba7a5a8d1b69c9066249caf69/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6e2571bdf780d304c792d4317bbaf1d6f5d7a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6e2571bdf780d304c792d4317bbaf1d6f5d7a0a", "html_url": "https://github.com/rust-lang/rust/commit/e6e2571bdf780d304c792d4317bbaf1d6f5d7a0a"}], "stats": {"total": 393, "additions": 206, "deletions": 187}, "files": [{"sha": "c50db4e2102ab5697f43371d23abce943718affc", "filename": "crates/ra_assists/src/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -1,7 +1,6 @@\n use hir::{\n     HirDisplay, Ty,\n     db::HirDatabase,\n-    source_binder::function_from_child_node,\n };\n use ra_syntax::{\n     SyntaxKind,\n@@ -30,11 +29,8 @@ pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<\n     }\n     // Infer type\n     let db = ctx.db;\n-    let func = function_from_child_node(db, ctx.frange.file_id, pat.syntax())?;\n-    let inference_res = func.infer(db);\n-    let source_map = func.body_source_map(db);\n-    let expr_id = source_map.node_expr(expr.into())?;\n-    let ty = inference_res[expr_id].clone();\n+    let analyzer = hir::SourceAnalyser::new(db, ctx.frange.file_id, stmt.syntax());\n+    let ty = analyzer.type_of(db, expr)?;\n     // Assist not applicable if the type is unknown\n     if is_unknown(&ty) {\n         return None;"}, {"sha": "0b2127e1180c0ddf7bd8c0ef3246bd45f0396854", "filename": "crates/ra_assists/src/add_missing_impl_members.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_missing_impl_members.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -2,7 +2,6 @@ use std::fmt::Write;\n \n use crate::{Assist, AssistId, AssistCtx};\n \n-use hir::Resolver;\n use hir::db::HirDatabase;\n use ra_syntax::{SmolStr, SyntaxKind, TextRange, TextUnit, TreeArc};\n use ra_syntax::ast::{self, AstNode, AstToken, FnDef, ImplItem, ImplItemKind, NameOwner};\n@@ -46,9 +45,9 @@ fn add_missing_impl_members_inner(\n     let trait_def = {\n         let file_id = ctx.frange.file_id;\n         let position = FilePosition { file_id, offset: impl_node.syntax().range().start() };\n-        let resolver = hir::source_binder::resolver_for_position(ctx.db, position);\n+        let analyser = hir::SourceAnalyser::new(ctx.db, position.file_id, impl_node.syntax());\n \n-        resolve_target_trait_def(ctx.db, &resolver, impl_node)?\n+        resolve_target_trait_def(ctx.db, &analyser, impl_node)?\n     };\n \n     let missing_fns: Vec<_> = {\n@@ -122,14 +121,14 @@ fn add_missing_impl_members_inner(\n /// implemented) to a `ast::TraitDef`.\n fn resolve_target_trait_def(\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    binder: &hir::SourceAnalyser,\n     impl_block: &ast::ImplBlock,\n ) -> Option<TreeArc<ast::TraitDef>> {\n-    let ast_path = impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?;\n-    let hir_path = ast_path.path().and_then(hir::Path::from_ast)?;\n+    let ast_path =\n+        impl_block.target_trait().map(AstNode::syntax).and_then(ast::PathType::cast)?.path()?;\n \n-    match resolver.resolve_path(db, &hir_path).take_types() {\n-        Some(hir::Resolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).1),\n+    match binder.resolve_path(db, &ast_path) {\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def.source(db).1),\n         _ => None,\n     }\n }"}, {"sha": "050b1c73f31d7fb7ef56da69d515b05f8367dd79", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::Write;\n \n use hir::{\n-    AdtDef, FieldSource, source_binder,\n+    AdtDef, FieldSource,\n     db::HirDatabase,\n };\n use ra_syntax::ast::{self, AstNode};\n@@ -20,12 +20,8 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     }\n \n     let expr = match_expr.expr()?;\n-    let function =\n-        source_binder::function_from_child_node(ctx.db, ctx.frange.file_id, expr.syntax())?;\n-    let infer_result = function.infer(ctx.db);\n-    let source_map = function.body_source_map(ctx.db);\n-    let node_expr = source_map.node_expr(expr)?;\n-    let match_expr_ty = infer_result[node_expr].clone();\n+    let analyzer = hir::SourceAnalyser::new(ctx.db, ctx.frange.file_id, expr.syntax());\n+    let match_expr_ty = analyzer.type_of(ctx.db, expr)?;\n     let enum_def = match_expr_ty.autoderef(ctx.db).find_map(|ty| match ty.as_adt() {\n         Some((AdtDef::Enum(e), _)) => Some(e),\n         _ => None,"}, {"sha": "e23cccbb8f02517db018b04ee32ea1494cce0f47", "filename": "crates/ra_assists/src/fill_struct_fields.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -1,6 +1,6 @@\n use std::fmt::Write;\n \n-use hir::{AdtDef, db::HirDatabase, source_binder::function_from_child_node};\n+use hir::{AdtDef, db::HirDatabase};\n \n use ra_syntax::ast::{self, AstNode};\n \n@@ -51,15 +51,12 @@ where\n     }\n \n     fn evaluate_struct_def_fields(&mut self) -> Option<()> {\n-        let function = function_from_child_node(\n+        let analyzer = hir::SourceAnalyser::new(\n             self.ctx.db,\n             self.ctx.frange.file_id,\n             self.struct_lit.syntax(),\n-        )?;\n-        let infer_result = function.infer(self.ctx.db);\n-        let source_map = function.body_source_map(self.ctx.db);\n-        let node_expr = source_map.node_expr(self.struct_lit.into())?;\n-        let struct_lit_ty = infer_result[node_expr].clone();\n+        );\n+        let struct_lit_ty = analyzer.type_of(self.ctx.db, self.struct_lit.into())?;\n         let struct_def = match struct_lit_ty.as_adt() {\n             Some((AdtDef::Struct(s), _)) => s,\n             _ => return None,"}, {"sha": "660edf006dc61e1dff3b1813e50463c53029a270", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -450,10 +450,6 @@ impl DefWithBody {\n         db.infer(*self)\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n-        db.body_with_source_map(*self).1\n-    }\n-\n     pub fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n         db.body_hir(*self)\n     }\n@@ -523,7 +519,7 @@ impl Function {\n         self.signature(db).name.clone()\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+    pub(crate) fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n         db.body_with_source_map((*self).into()).1\n     }\n \n@@ -606,7 +602,7 @@ impl Const {\n         db.infer((*self).into())\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+    pub(crate) fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n         db.body_with_source_map((*self).into()).1\n     }\n \n@@ -679,7 +675,7 @@ impl Static {\n         db.infer((*self).into())\n     }\n \n-    pub fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n+    pub(crate) fn body_source_map(&self, db: &impl HirDatabase) -> Arc<BodySourceMap> {\n         db.body_with_source_map((*self).into()).1\n     }\n }"}, {"sha": "3806a3605956c3114216e3ab6020c8023b176328", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -117,31 +117,27 @@ impl Index<PatId> for Body {\n }\n \n impl BodySourceMap {\n-    pub fn expr_syntax(&self, expr: ExprId) -> Option<SyntaxNodePtr> {\n+    pub(crate) fn expr_syntax(&self, expr: ExprId) -> Option<SyntaxNodePtr> {\n         self.expr_map_back.get(expr).cloned()\n     }\n \n-    pub fn syntax_expr(&self, ptr: SyntaxNodePtr) -> Option<ExprId> {\n+    pub(crate) fn syntax_expr(&self, ptr: SyntaxNodePtr) -> Option<ExprId> {\n         self.expr_map.get(&ptr).cloned()\n     }\n \n-    pub fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n+    pub(crate) fn node_expr(&self, node: &ast::Expr) -> Option<ExprId> {\n         self.expr_map.get(&SyntaxNodePtr::new(node.syntax())).cloned()\n     }\n \n-    pub fn pat_syntax(&self, pat: PatId) -> Option<PatPtr> {\n+    pub(crate) fn pat_syntax(&self, pat: PatId) -> Option<PatPtr> {\n         self.pat_map_back.get(pat).cloned()\n     }\n \n-    pub fn syntax_pat(&self, ptr: PatPtr) -> Option<PatId> {\n-        self.pat_map.get(&ptr).cloned()\n-    }\n-\n-    pub fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n+    pub(crate) fn node_pat(&self, node: &ast::Pat) -> Option<PatId> {\n         self.pat_map.get(&Either::A(AstPtr::new(node))).cloned()\n     }\n \n-    pub fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::NamedField> {\n+    pub(crate) fn field_syntax(&self, expr: ExprId, field: usize) -> AstPtr<ast::NamedField> {\n         self.field_map[&(expr, field)].clone()\n     }\n }"}, {"sha": "404c979eb1fde774690d24e83d1d1299050999c7", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -109,7 +109,7 @@ impl ExprScopes {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ScopesWithSourceMap {\n-    pub source_map: Arc<BodySourceMap>,\n+    pub(crate) source_map: Arc<BodySourceMap>,\n     pub scopes: Arc<ExprScopes>,\n }\n "}, {"sha": "59b402c57837ee9b87dbf730f3ec820724e355f0", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -66,6 +66,7 @@ pub use self::{\n     adt::AdtDef,\n     expr::{ExprScopes, ScopesWithSourceMap, ScopeEntryWithSyntax},\n     resolve::{Resolver, Resolution},\n+    source_binder::{SourceAnalyser, PathResolution},\n };\n \n pub use self::code_model_api::{"}, {"sha": "79e304383a0ebd790e08324a4c642d3cc79cfdaf", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 98, "deletions": 2, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -5,15 +5,17 @@\n ///\n /// So, this modules should not be used during hir construction, it exists\n /// purely for \"IDE needs\".\n+use std::sync::Arc;\n+\n use ra_db::{FileId, FilePosition};\n use ra_syntax::{\n-    SyntaxNode,\n+    SyntaxNode, AstPtr,\n     ast::{self, AstNode, NameOwner},\n     algo::{find_node_at_offset, find_token_at_offset},\n };\n \n use crate::{\n-    HirDatabase, Function, Struct, Enum,Const,Static,\n+    HirDatabase, Function, Struct, Enum, Const, Static, Either,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n     ids::LocationCtx,\n     expr, AstId\n@@ -258,3 +260,97 @@ fn try_get_resolver_for_node(\n         None\n     }\n }\n+\n+// Name is bad, don't use inside HIR\n+#[derive(Debug)]\n+pub struct SourceAnalyser {\n+    resolver: Resolver,\n+    body_source_map: Option<Arc<crate::expr::BodySourceMap>>,\n+    infer: Option<Arc<crate::ty::InferenceResult>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum PathResolution {\n+    /// An item\n+    Def(crate::ModuleDef),\n+    /// A local binding (only value namespace)\n+    LocalBinding(crate::expr::PatId),\n+    /// A generic parameter\n+    GenericParam(u32),\n+    SelfType(crate::ImplBlock),\n+    AssocItem(crate::ImplItem),\n+}\n+\n+impl SourceAnalyser {\n+    pub fn new(db: &impl HirDatabase, file_id: FileId, node: &SyntaxNode) -> SourceAnalyser {\n+        let resolver = resolver_for_node(db, file_id, node);\n+        let function = function_from_child_node(db, file_id, node);\n+        if let Some(function) = function {\n+            SourceAnalyser {\n+                resolver,\n+                body_source_map: Some(function.body_source_map(db)),\n+                infer: Some(function.infer(db)),\n+            }\n+        } else {\n+            SourceAnalyser { resolver, body_source_map: None, infer: None }\n+        }\n+    }\n+\n+    pub fn type_of(&self, _db: &impl HirDatabase, expr: &ast::Expr) -> Option<crate::Ty> {\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(expr)?;\n+        Some(self.infer.as_ref()?[expr_id].clone())\n+    }\n+\n+    pub fn type_of_pat(&self, _db: &impl HirDatabase, pat: &ast::Pat) -> Option<crate::Ty> {\n+        let pat_id = self.body_source_map.as_ref()?.node_pat(pat)?;\n+        Some(self.infer.as_ref()?[pat_id].clone())\n+    }\n+\n+    pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(call.into())?;\n+        self.infer.as_ref()?.method_resolution(expr_id)\n+    }\n+\n+    pub fn resolve_field(&self, field: &ast::FieldExpr) -> Option<crate::StructField> {\n+        let expr_id = self.body_source_map.as_ref()?.node_expr(field.into())?;\n+        self.infer.as_ref()?.field_resolution(expr_id)\n+    }\n+\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n+        if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n+            let expr_id = self.body_source_map.as_ref()?.node_expr(path_expr.into())?;\n+            if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n+                return Some(PathResolution::AssocItem(assoc));\n+            }\n+        }\n+        if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n+            let pat_id = self.body_source_map.as_ref()?.node_pat(path_pat.into())?;\n+            if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n+                return Some(PathResolution::AssocItem(assoc));\n+            }\n+        }\n+        let hir_path = crate::Path::from_ast(path)?;\n+        let res = self.resolver.resolve_path(db, &hir_path);\n+        let res = res.clone().take_types().or_else(|| res.take_values())?;\n+        Some(res.into())\n+    }\n+\n+    pub fn pat_syntax(\n+        &self,\n+        _db: &impl HirDatabase,\n+        pat: crate::expr::PatId,\n+    ) -> Option<Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>> {\n+        self.body_source_map.as_ref()?.pat_syntax(pat)\n+    }\n+}\n+\n+impl From<crate::Resolution> for PathResolution {\n+    fn from(res: crate::Resolution) -> PathResolution {\n+        match res {\n+            crate::Resolution::Def(it) => PathResolution::Def(it),\n+            crate::Resolution::LocalBinding(it) => PathResolution::LocalBinding(it),\n+            crate::Resolution::GenericParam(it) => PathResolution::GenericParam(it),\n+            crate::Resolution::SelfType(it) => PathResolution::SelfType(it),\n+        }\n+    }\n+}"}, {"sha": "3580573647c3012d861b76edfd221dbf29f566e5", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -4,17 +4,10 @@ use crate::completion::{CompletionContext, Completions};\n \n /// Complete dot accesses, i.e. fields or methods (currently only fields).\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (function, receiver) = match (&ctx.function, ctx.dot_receiver) {\n-        (Some(function), Some(receiver)) => (function, receiver),\n-        _ => return,\n-    };\n-    let infer_result = function.infer(ctx.db);\n-    let source_map = function.body_source_map(ctx.db);\n-    let expr = match source_map.node_expr(receiver) {\n-        Some(expr) => expr,\n+    let receiver_ty = match ctx.dot_receiver.and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n+        Some(it) => it,\n         None => return,\n     };\n-    let receiver_ty = infer_result[expr].clone();\n     if !ctx.is_call {\n         complete_fields(acc, ctx, receiver_ty.clone());\n     }"}, {"sha": "48fbf67f74f906448037ba75579dc956ae0e0fcd", "filename": "crates/ra_ide_api/src/completion/complete_struct_literal.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_struct_literal.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -4,17 +4,10 @@ use crate::completion::{CompletionContext, Completions};\n \n /// Complete fields in fields literals.\n pub(super) fn complete_struct_literal(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (function, struct_lit) = match (&ctx.function, ctx.struct_lit_syntax) {\n-        (Some(function), Some(struct_lit)) => (function, struct_lit),\n-        _ => return,\n-    };\n-    let infer_result = function.infer(ctx.db);\n-    let source_map = function.body_source_map(ctx.db);\n-    let expr = match source_map.node_expr(struct_lit.into()) {\n-        Some(expr) => expr,\n+    let ty = match ctx.struct_lit_syntax.and_then(|it| ctx.analyzer.type_of(ctx.db, it.into())) {\n+        Some(it) => it,\n         None => return,\n     };\n-    let ty = infer_result[expr].clone();\n     let (adt, substs) = match ty.as_adt() {\n         Some(res) => res,\n         _ => return,"}, {"sha": "ce21fca9b0dcd4e9ecbad2b5fa150fe233d9d06c", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -14,6 +14,7 @@ use crate::{db, FilePosition};\n #[derive(Debug)]\n pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a db::RootDatabase,\n+    pub(super) analyzer: hir::SourceAnalyser,\n     pub(super) offset: TextUnit,\n     pub(super) token: SyntaxToken<'a>,\n     pub(super) resolver: Resolver,\n@@ -50,8 +51,10 @@ impl<'a> CompletionContext<'a> {\n         let resolver = source_binder::resolver_for_position(db, position);\n         let module = source_binder::module_from_position(db, position);\n         let token = find_token_at_offset(original_file.syntax(), position.offset).left_biased()?;\n+        let analyzer = hir::SourceAnalyser::new(db, position.file_id, token.parent());\n         let mut ctx = CompletionContext {\n             db,\n+            analyzer,\n             token,\n             offset: position.offset,\n             resolver,"}, {"sha": "84645287d7497d4e44b95a4d20375d10d7619a6b", "filename": "crates/ra_ide_api/src/display/navigation_target.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -1,11 +1,11 @@\n use ra_db::{FileId, SourceDatabase};\n use ra_syntax::{\n-    SyntaxNode, SyntaxNodePtr, AstNode, SmolStr, TextRange, TreeArc,\n+    SyntaxNode, AstNode, SmolStr, TextRange, TreeArc, AstPtr,\n     SyntaxKind::{self, NAME},\n     ast::{self, NameOwner, VisibilityOwner, TypeAscriptionOwner},\n     algo::visit::{visitor, Visitor},\n };\n-use hir::{ModuleSource, FieldSource, Name, ImplItem};\n+use hir::{ModuleSource, FieldSource, ImplItem, Either};\n \n use crate::{FileSymbol, db::RootDatabase};\n \n@@ -74,15 +74,25 @@ impl NavigationTarget {\n         }\n     }\n \n-    pub(crate) fn from_scope_entry(\n+    pub(crate) fn from_pat(\n+        db: &RootDatabase,\n         file_id: FileId,\n-        name: Name,\n-        ptr: SyntaxNodePtr,\n+        pat: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n     ) -> NavigationTarget {\n+        let file = db.parse(file_id);\n+        let (name, full_range) = match pat {\n+            Either::A(pat) => match pat.to_node(&file).kind() {\n+                ast::PatKind::BindPat(pat) => {\n+                    return NavigationTarget::from_bind_pat(file_id, &pat)\n+                }\n+                _ => (\"_\".into(), pat.syntax_node_ptr().range()),\n+            },\n+            Either::B(slf) => (\"self\".into(), slf.syntax_node_ptr().range()),\n+        };\n         NavigationTarget {\n             file_id,\n-            name: name.to_string().into(),\n-            full_range: ptr.range(),\n+            name,\n+            full_range,\n             focus_range: None,\n             kind: NAME,\n             container_name: None,\n@@ -229,6 +239,7 @@ impl NavigationTarget {\n \n     /// Allows `NavigationTarget` to be created from a `NameOwner`\n     pub(crate) fn from_named(file_id: FileId, node: &impl ast::NameOwner) -> NavigationTarget {\n+        //FIXME: use `_` instead of empty string\n         let name = node.name().map(|it| it.text().clone()).unwrap_or_default();\n         let focus_range = node.name().map(|it| it.syntax().range());\n         NavigationTarget::from_syntax(file_id, name, focus_range, node.syntax())"}, {"sha": "7f93f50c441cab4004afbe5d3aa7c322b4520173", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 48, "deletions": 104, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -5,7 +5,6 @@ use ra_syntax::{\n     SyntaxNode,\n };\n use test_utils::tested_by;\n-use hir::Resolution;\n \n use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n \n@@ -48,127 +47,72 @@ pub(crate) fn reference_definition(\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let function = hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax());\n-\n-    if let Some(function) = function {\n-        // Check if it is a method\n-        if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n-            tested_by!(goto_definition_works_for_methods);\n-            let infer_result = function.infer(db);\n-            let source_map = function.body_source_map(db);\n-            let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n-            if let Some(func) =\n-                source_map.node_expr(expr).and_then(|it| infer_result.method_resolution(it))\n-            {\n-                return Exact(NavigationTarget::from_function(db, func));\n-            };\n-        }\n-        // It could also be a field access\n-        if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n-            tested_by!(goto_definition_works_for_fields);\n-            let infer_result = function.infer(db);\n-            let source_map = function.body_source_map(db);\n-            let expr = ast::Expr::cast(field_expr.syntax()).unwrap();\n-            if let Some(field) =\n-                source_map.node_expr(expr).and_then(|it| infer_result.field_resolution(it))\n-            {\n-                return Exact(NavigationTarget::from_field(db, field));\n-            };\n-        }\n+    let analyzer = hir::SourceAnalyser::new(db, file_id, name_ref.syntax());\n \n-        // It could also be a named field\n-        if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::NamedField::cast) {\n-            tested_by!(goto_definition_works_for_named_fields);\n+    // Special cases:\n \n-            let infer_result = function.infer(db);\n-            let source_map = function.body_source_map(db);\n+    // Check if it is a method\n+    if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n+        tested_by!(goto_definition_works_for_methods);\n+        if let Some(func) = analyzer.resolve_method_call(method_call) {\n+            return Exact(NavigationTarget::from_function(db, func));\n+        }\n+    }\n+    // It could also be a field access\n+    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::FieldExpr::cast) {\n+        tested_by!(goto_definition_works_for_fields);\n+        if let Some(field) = analyzer.resolve_field(field_expr) {\n+            return Exact(NavigationTarget::from_field(db, field));\n+        };\n+    }\n \n-            let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n+    // It could also be a named field\n+    if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::NamedField::cast) {\n+        tested_by!(goto_definition_works_for_named_fields);\n \n-            if let Some(expr) = struct_lit.and_then(|lit| source_map.node_expr(lit.into())) {\n-                let ty = infer_result[expr].clone();\n-                if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n-                    let hir_path = hir::Path::from_name_ref(name_ref);\n-                    let hir_name = hir_path.as_ident().unwrap();\n+        let struct_lit = field_expr.syntax().ancestors().find_map(ast::StructLit::cast);\n \n-                    if let Some(field) = s.field(db, hir_name) {\n-                        return Exact(NavigationTarget::from_field(db, field));\n-                    }\n+        if let Some(ty) = struct_lit.and_then(|lit| analyzer.type_of(db, lit.into())) {\n+            if let Some((hir::AdtDef::Struct(s), _)) = ty.as_adt() {\n+                let hir_path = hir::Path::from_name_ref(name_ref);\n+                let hir_name = hir_path.as_ident().unwrap();\n+\n+                if let Some(field) = s.field(db, hir_name) {\n+                    return Exact(NavigationTarget::from_field(db, field));\n                 }\n             }\n         }\n     }\n \n-    // Try name resolution\n-    let resolver = hir::source_binder::resolver_for_node(db, file_id, name_ref.syntax());\n-    if let Some(path) =\n-        name_ref.syntax().ancestors().find_map(ast::Path::cast).and_then(hir::Path::from_ast)\n-    {\n-        let resolved = resolver.resolve_path(db, &path);\n-        match resolved.clone().take_types().or_else(|| resolved.take_values()) {\n-            Some(Resolution::Def(def)) => return Exact(NavigationTarget::from_def(db, def)),\n-            Some(Resolution::LocalBinding(pat)) => {\n-                let body = resolver.body().expect(\"no body for local binding\");\n-                let source_map = body.owner().body_source_map(db);\n-                let ptr = source_map.pat_syntax(pat).expect(\"pattern not found in syntax mapping\");\n-                let name =\n-                    path.as_ident().cloned().expect(\"local binding from a multi-segment path\");\n-                let ptr = ptr.either(|it| it.into(), |it| it.into());\n-                let nav = NavigationTarget::from_scope_entry(file_id, name, ptr);\n-                return Exact(nav);\n-            }\n-            Some(Resolution::GenericParam(..)) => {\n-                // FIXME: go to the generic param def\n-            }\n-            Some(Resolution::SelfType(impl_block)) => {\n-                let ty = impl_block.target_ty(db);\n-\n-                if let Some((def_id, _)) = ty.as_adt() {\n-                    return Exact(NavigationTarget::from_adt_def(db, def_id));\n-                }\n-            }\n-            None => {\n-                // If we failed to resolve then check associated items\n-                if let Some(function) = function {\n-                    // Resolve associated item for path expressions\n-                    if let Some(path_expr) =\n-                        name_ref.syntax().ancestors().find_map(ast::PathExpr::cast)\n-                    {\n-                        let infer_result = function.infer(db);\n-                        let source_map = function.body_source_map(db);\n-\n-                        if let Some(expr) = ast::Expr::cast(path_expr.syntax()) {\n-                            if let Some(res) = source_map\n-                                .node_expr(expr)\n-                                .and_then(|it| infer_result.assoc_resolutions_for_expr(it.into()))\n-                            {\n-                                return Exact(NavigationTarget::from_impl_item(db, res));\n-                            }\n-                        }\n+    // General case, a path or a local:\n+    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n+        if let Some(resolved) = analyzer.resolve_path(db, path) {\n+            match resolved {\n+                hir::PathResolution::Def(def) => return Exact(NavigationTarget::from_def(db, def)),\n+                hir::PathResolution::LocalBinding(pat) => {\n+                    if let Some(pat) = analyzer.pat_syntax(db, pat) {\n+                        let nav = NavigationTarget::from_pat(db, file_id, pat);\n+                        return Exact(nav);\n                     }\n+                }\n+                hir::PathResolution::GenericParam(..) => {\n+                    // FIXME: go to the generic param def\n+                }\n+                hir::PathResolution::SelfType(impl_block) => {\n+                    let ty = impl_block.target_ty(db);\n \n-                    // Resolve associated item for path patterns\n-                    if let Some(path_pat) =\n-                        name_ref.syntax().ancestors().find_map(ast::PathPat::cast)\n-                    {\n-                        let infer_result = function.infer(db);\n-                        let source_map = function.body_source_map(db);\n-\n-                        let pat: &ast::Pat = path_pat.into();\n-\n-                        if let Some(res) = source_map\n-                            .node_pat(pat)\n-                            .and_then(|it| infer_result.assoc_resolutions_for_pat(it.into()))\n-                        {\n-                            return Exact(NavigationTarget::from_impl_item(db, res));\n-                        }\n+                    if let Some((def_id, _)) = ty.as_adt() {\n+                        return Exact(NavigationTarget::from_adt_def(db, def_id));\n                     }\n                 }\n+                hir::PathResolution::AssocItem(assoc) => {\n+                    return Exact(NavigationTarget::from_impl_item(db, assoc))\n+                }\n             }\n         }\n     }\n \n-    // If that fails try the index based approach.\n+    // Fallback index based approach:\n     let navs = crate::symbol_index::index_resolve(db, name_ref)\n         .into_iter()\n         .map(NavigationTarget::from_symbol)"}, {"sha": "ec167a196511c5952abeded9bbf7e89c7dcf9f1e", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d66d63d716a10ba7a5a8d1b69c9066249caf69/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=10d66d63d716a10ba7a5a8d1b69c9066249caf69", "patch": "@@ -132,17 +132,15 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {\n         .ancestors()\n         .take_while(|it| it.range() == leaf_node.range())\n         .find(|&it| ast::Expr::cast(it).is_some() || ast::Pat::cast(it).is_some())?;\n-    let parent_fn = node.ancestors().find_map(ast::FnDef::cast)?;\n-    let function = hir::source_binder::function_from_source(db, frange.file_id, parent_fn)?;\n-    let infer = function.infer(db);\n-    let source_map = function.body_source_map(db);\n-    if let Some(expr) = ast::Expr::cast(node).and_then(|e| source_map.node_expr(e)) {\n-        Some(infer[expr].display(db).to_string())\n-    } else if let Some(pat) = ast::Pat::cast(node).and_then(|p| source_map.node_pat(p)) {\n-        Some(infer[pat].display(db).to_string())\n+    let analyzer = hir::SourceAnalyser::new(db, frange.file_id, node);\n+    let ty = if let Some(ty) = ast::Expr::cast(node).and_then(|e| analyzer.type_of(db, e)) {\n+        ty\n+    } else if let Some(ty) = ast::Pat::cast(node).and_then(|p| analyzer.type_of_pat(db, p)) {\n+        ty\n     } else {\n-        None\n-    }\n+        return None;\n+    };\n+    Some(ty.display(db).to_string())\n }\n \n #[cfg(test)]"}]}