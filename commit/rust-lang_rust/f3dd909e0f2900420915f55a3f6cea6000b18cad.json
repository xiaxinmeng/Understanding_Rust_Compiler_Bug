{"sha": "f3dd909e0f2900420915f55a3f6cea6000b18cad", "node_id": "C_kwDOAAsO6NoAKGYzZGQ5MDllMGYyOTAwNDIwOTE1ZjU1YTNmNmNlYTYwMDBiMThjYWQ", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T19:25:53Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:26Z"}, "message": "Split out `match_bool`", "tree": {"sha": "e7d686b145d430e08854cf59af5860fa7c355e3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d686b145d430e08854cf59af5860fa7c355e3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3dd909e0f2900420915f55a3f6cea6000b18cad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3dd909e0f2900420915f55a3f6cea6000b18cad", "html_url": "https://github.com/rust-lang/rust/commit/f3dd909e0f2900420915f55a3f6cea6000b18cad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3dd909e0f2900420915f55a3f6cea6000b18cad/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f23dc16e1df17e7d2c62d11bc3b180aba644624b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f23dc16e1df17e7d2c62d11bc3b180aba644624b", "html_url": "https://github.com/rust-lang/rust/commit/f23dc16e1df17e7d2c62d11bc3b180aba644624b"}], "stats": {"total": 149, "additions": 80, "deletions": 69}, "files": [{"sha": "90c50b994d2bfe11245881843feef728b1829ad5", "filename": "clippy_lints/src/matches/match_bool.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f3dd909e0f2900420915f55a3f6cea6000b18cad/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3dd909e0f2900420915f55a3f6cea6000b18cad/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs?ref=f3dd909e0f2900420915f55a3f6cea6000b18cad", "patch": "@@ -0,0 +1,75 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_unit_expr;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::sugg::Sugg;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_BOOL;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    // Type of expression is `bool`.\n+    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n+        span_lint_and_then(\n+            cx,\n+            MATCH_BOOL,\n+            expr.span,\n+            \"you seem to be trying to match on a boolean expression\",\n+            move |diag| {\n+                if arms.len() == 2 {\n+                    // no guards\n+                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n+                            match lit.node {\n+                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                                _ => None,\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    };\n+\n+                    if let Some((true_expr, false_expr)) = exprs {\n+                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n+                            (false, false) => Some(format!(\n+                                \"if {} {} else {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n+                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (false, true) => Some(format!(\n+                                \"if {} {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (true, false) => {\n+                                let test = Sugg::hir(cx, ex, \"..\");\n+                                Some(format!(\n+                                    \"if {} {}\",\n+                                    !test,\n+                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                ))\n+                            },\n+                            (true, true) => None,\n+                        };\n+\n+                        if let Some(sugg) = sugg {\n+                            diag.span_suggestion(\n+                                expr.span,\n+                                \"consider using an `if`/`else` expression\",\n+                                sugg,\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                    }\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "4775e07d24bdba5f56fe61aa222e58fa7144cc25", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 69, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f3dd909e0f2900420915f55a3f6cea6000b18cad/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3dd909e0f2900420915f55a3f6cea6000b18cad/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=f3dd909e0f2900420915f55a3f6cea6000b18cad", "patch": "@@ -4,17 +4,16 @@ use clippy_utils::diagnostics::{\n };\n use clippy_utils::macros::{is_panic, root_macro_call};\n use clippy_utils::peel_blocks_with_stmt;\n-use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n+use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n-    get_parent_expr, is_lang_ctor, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs, path_to_local_id,\n-    peel_blocks, peel_hir_pat_refs, recurse_or_patterns, strip_pat_refs,\n+    get_parent_expr, is_lang_ctor, is_refutable, is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks,\n+    peel_hir_pat_refs, recurse_or_patterns, strip_pat_refs,\n };\n use core::iter::once;\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -29,6 +28,7 @@ use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, symbol::kw, Span};\n use std::cmp::Ordering;\n \n+mod match_bool;\n mod match_like_matches;\n mod match_same_arms;\n mod redundant_pattern_match;\n@@ -631,7 +631,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n \n         if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n             single_match::check(cx, ex, arms, expr);\n-            check_match_bool(cx, ex, arms, expr);\n+            match_bool::check(cx, ex, arms, expr);\n             check_overlapping_arms(cx, ex, arms);\n             check_wild_err_arm(cx, ex, arms);\n             check_wild_enum_match(cx, ex, arms);\n@@ -710,70 +710,6 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    // Type of expression is `bool`.\n-    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n-        span_lint_and_then(\n-            cx,\n-            MATCH_BOOL,\n-            expr.span,\n-            \"you seem to be trying to match on a boolean expression\",\n-            move |diag| {\n-                if arms.len() == 2 {\n-                    // no guards\n-                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n-                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n-                            match lit.node {\n-                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                                _ => None,\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    };\n-\n-                    if let Some((true_expr, false_expr)) = exprs {\n-                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                            (false, false) => Some(format!(\n-                                \"if {} {} else {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n-                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (false, true) => Some(format!(\n-                                \"if {} {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (true, false) => {\n-                                let test = Sugg::hir(cx, ex, \"..\");\n-                                Some(format!(\n-                                    \"if {} {}\",\n-                                    !test,\n-                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                                ))\n-                            },\n-                            (true, true) => None,\n-                        };\n-\n-                        if let Some(sugg) = sugg {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"consider using an `if`/`else` expression\",\n-                                sugg,\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        }\n-                    }\n-                }\n-            },\n-        );\n-    }\n-}\n-\n fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n     if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));"}]}