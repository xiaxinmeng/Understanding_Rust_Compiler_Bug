{"sha": "be334d582435a05ea56c1ca7fcb2e512cfc51f24", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMzM0ZDU4MjQzNWEwNWVhNTZjMWNhN2ZjYjJlNTEyY2ZjNTFmMjQ=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-04-16T02:29:36Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2014-04-16T02:29:36Z"}, "message": "Make Vec::clone and slice::to_owned failure-safe", "tree": {"sha": "900da71bc36964d4cbe260b94db3d1163b74f48a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/900da71bc36964d4cbe260b94db3d1163b74f48a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be334d582435a05ea56c1ca7fcb2e512cfc51f24", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be334d582435a05ea56c1ca7fcb2e512cfc51f24", "html_url": "https://github.com/rust-lang/rust/commit/be334d582435a05ea56c1ca7fcb2e512cfc51f24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be334d582435a05ea56c1ca7fcb2e512cfc51f24/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42b39924d87739f2dcda3e788c6e8655d310954f", "url": "https://api.github.com/repos/rust-lang/rust/commits/42b39924d87739f2dcda3e788c6e8655d310954f", "html_url": "https://github.com/rust-lang/rust/commit/42b39924d87739f2dcda3e788c6e8655d310954f"}], "stats": {"total": 36, "additions": 19, "deletions": 17}, "files": [{"sha": "153e21c780c098cf69e4b8031502fa4186b61fd1", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/be334d582435a05ea56c1ca7fcb2e512cfc51f24/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be334d582435a05ea56c1ca7fcb2e512cfc51f24/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=be334d582435a05ea56c1ca7fcb2e512cfc51f24", "patch": "@@ -762,18 +762,23 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     fn to_owned(&self) -> ~[T] {\n         let len = self.len();\n         let mut result = with_capacity(len);\n+        // Unsafe code so this can be optimised to a memcpy (or something\n+        // similarly fast) when T is Copy. LLVM is easily confused, so any\n+        // extra operations during the loop can prevent this optimisation\n         unsafe {\n-            // Unsafe code so this can be optimised to a memcpy (or something\n-            // similarly fast) when T is Copy. LLVM is easily confused, so any\n-            // extra operations during the loop can prevent this optimisation\n-            result.set_len(len);\n             let mut i = 0;\n-            while i < len {\n-                mem::move_val_init(\n-                    result.unsafe_mut_ref(i),\n-                    self.unsafe_ref(i).clone());\n-                i = i + 1;\n-            }\n+            let p = result.as_mut_ptr();\n+            // Use try_finally here otherwise the write to length\n+            // inside the loop stops LLVM from optimising this.\n+            try_finally(\n+                &mut i, (),\n+                |i, ()| while *i < len {\n+                    mem::move_val_init(\n+                        &mut(*p.offset(*i as int)),\n+                        self.unsafe_ref(*i).clone());\n+                    *i += 1;\n+                },\n+                |i| result.set_len(*i));\n         }\n         result\n     }"}, {"sha": "96cbac8869ef212d4452c59900ed436e3a9345bd", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/be334d582435a05ea56c1ca7fcb2e512cfc51f24/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be334d582435a05ea56c1ca7fcb2e512cfc51f24/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=be334d582435a05ea56c1ca7fcb2e512cfc51f24", "patch": "@@ -313,21 +313,18 @@ impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> {\n         let len = self.len;\n         let mut vector = Vec::with_capacity(len);\n-        vector.len = len;\n         // Unsafe code so this can be optimised to a memcpy (or something\n         // similarly fast) when T is Copy. LLVM is easily confused, so any\n         // extra operations during the loop can prevent this optimisation\n         {\n-            let slice = vector.as_mut_slice();\n             let this_slice = self.as_slice();\n-            let mut i = 0;\n-            while i < len {\n+            while vector.len < len {\n                 unsafe {\n                     mem::move_val_init(\n-                        slice.unsafe_mut_ref(i),\n-                        this_slice.unsafe_ref(i).clone());\n+                        vector.as_mut_slice().unsafe_mut_ref(vector.len),\n+                        this_slice.unsafe_ref(vector.len).clone());\n                 }\n-                i = i + 1;\n+                vector.len += 1;\n             }\n         }\n         vector"}]}