{"sha": "74bd074eefcf4915c73d1ab91bc90859664729e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YmQwNzRlZWZjZjQ5MTVjNzNkMWFiOTFiYzkwODU5NjY0NzI5ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-03T20:56:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-03T20:56:05Z"}, "message": "Auto merge of #70747 - Centril:rollup-2vx9bve, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #69860 (Use associated numeric consts in documentation)\n - #70576 (Update the description of the ticket to point at RFC 1721)\n - #70597 (Fix double-free and undefined behaviour in libstd::syn::unix::Thread::new)\n - #70640 (Hide `task_context` when lowering body)\n - #70641 (Remove duplicated code in trait selection)\n - #70707 (Remove unused graphviz emitter)\n - #70720 (Place TLS initializers with relocations in .tdata)\n - #70735 (Clean up E0502 explanation)\n - #70741 (Add test for #59023)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "4eb869837e228d81b08b2fb4db3ad1af00942039", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb869837e228d81b08b2fb4db3ad1af00942039"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74bd074eefcf4915c73d1ab91bc90859664729e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74bd074eefcf4915c73d1ab91bc90859664729e6", "html_url": "https://github.com/rust-lang/rust/commit/74bd074eefcf4915c73d1ab91bc90859664729e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74bd074eefcf4915c73d1ab91bc90859664729e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "html_url": "https://github.com/rust-lang/rust/commit/f6fe99c798cb65280a9a56f442b371adcb7b8aa2"}, {"sha": "4c41ea36cda77748b532cf6d989a8d5d2fcc872e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c41ea36cda77748b532cf6d989a8d5d2fcc872e", "html_url": "https://github.com/rust-lang/rust/commit/4c41ea36cda77748b532cf6d989a8d5d2fcc872e"}], "stats": {"total": 992, "additions": 283, "deletions": 709}, "files": [{"sha": "2ce5bc8ed2f9db71a570c49fb114f0781308ad86", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -432,7 +432,7 @@ impl<T> [T] {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// b\"0123456789abcdef\".repeat(usize::max_value());\n+    /// b\"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T>"}, {"sha": "70860c09a2c31d0b031b753253265b667e391311", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -499,7 +499,7 @@ impl str {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// \"0123456789abcdef\".repeat(usize::max_value());\n+    /// \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {"}, {"sha": "8c542136a7fa6523a804a2a97f82ae6d2ee9b00e", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -817,7 +817,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// When comparison is impossible:\n     ///\n     /// ```\n-    /// let result = std::f64::NAN.partial_cmp(&1.0);\n+    /// let result = f64::NAN.partial_cmp(&1.0);\n     /// assert_eq!(result, None);\n     /// ```\n     #[must_use]"}, {"sha": "95411b525d0db3934f1dd40d703be0c505455f83", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -852,7 +852,7 @@ pub trait LowerHex {\n ///     }\n /// }\n ///\n-/// let l = Length(i32::max_value());\n+/// let l = Length(i32::MAX);\n ///\n /// assert_eq!(format!(\"l as hex is: {:X}\", l), \"l as hex is: 7FFFFFFF\");\n ///"}, {"sha": "d406b3ce6ef6e88c0c1e54155e88b1eb57f7dded", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -43,7 +43,7 @@ use crate::intrinsics;\n ///\n /// assert_eq!(div_1(7, 0), 7);\n /// assert_eq!(div_1(9, 1), 4);\n-/// assert_eq!(div_1(11, std::u32::MAX), 0);\n+/// assert_eq!(div_1(11, u32::MAX), 0);\n /// ```\n #[inline]\n #[stable(feature = \"unreachable\", since = \"1.27.0\")]"}, {"sha": "4a11fb393899f26acccfe05b13f9d23f33c0394e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1739,19 +1739,19 @@ extern \"rust-intrinsic\" {\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n-    /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n+    /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n-    /// where y = 0 or x = `T::min_value()` and y = -1\n+    /// where y = 0 or x = `T::MIN` and y = -1\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_div` method. For example,\n     /// [`std::u32::checked_div`](../../std/primitive.u32.html#method.checked_div)\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n-    /// undefined behavior where y = 0 or x = `T::min_value()` and y = -1\n+    /// undefined behavior where y = 0 or x = `T::MIN` and y = -1\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n     /// primitives via the `checked_rem` method. For example,\n@@ -1777,17 +1777,17 @@ extern \"rust-intrinsic\" {\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n-    /// undefined behavior when `x + y > T::max_value()` or `x + y < T::min_value()`.\n+    /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n-    /// undefined behavior when `x - y > T::max_value()` or `x - y < T::min_value()`.\n+    /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n-    /// undefined behavior when `x * y > T::max_value()` or `x * y < T::min_value()`.\n+    /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n "}, {"sha": "c8829817e190cbdd00e516c68fcd6a53461bec94", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -198,7 +198,7 @@ pub trait Iterator {\n     /// // and the maximum possible lower bound\n     /// let iter = 0..;\n     ///\n-    /// assert_eq!((usize::max_value(), None), iter.size_hint());\n+    /// assert_eq!((usize::MAX, None), iter.size_hint());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2920,7 +2920,7 @@ pub trait Iterator {\n     /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n     /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n     ///\n-    /// assert_eq!([std::f64::NAN].iter().partial_cmp([1.].iter()), None);\n+    /// assert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);\n     /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n@@ -3170,7 +3170,7 @@ pub trait Iterator {\n     /// assert!(![1, 3, 2, 4].iter().is_sorted());\n     /// assert!([0].iter().is_sorted());\n     /// assert!(std::iter::empty::<i32>().is_sorted());\n-    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted());\n+    /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n@@ -3197,7 +3197,7 @@ pub trait Iterator {\n     /// assert!(![1, 3, 2, 4].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// assert!([0].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// assert!(std::iter::empty::<i32>().is_sorted_by(|a, b| a.partial_cmp(b)));\n-    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![0.0, 1.0, f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n     /// ```\n     ///\n     /// [`is_sorted`]: trait.Iterator.html#method.is_sorted"}, {"sha": "4ab82add32b533825feca583522dcb6f0fd7c2b4", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -470,7 +470,7 @@ impl f32 {\n     ///\n     /// let value = -128.9_f32;\n     /// let rounded = unsafe { value.to_int_unchecked::<i8>() };\n-    /// assert_eq!(rounded, std::i8::MIN);\n+    /// assert_eq!(rounded, i8::MIN);\n     /// ```\n     ///\n     /// # Safety"}, {"sha": "20818a9b750f4c8d3c2678d4f82b96933256d6bb", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -484,7 +484,7 @@ impl f64 {\n     ///\n     /// let value = -128.9_f32;\n     /// let rounded = unsafe { value.to_int_unchecked::<i8>() };\n-    /// assert_eq!(rounded, std::i8::MIN);\n+    /// assert_eq!(rounded, i8::MIN);\n     /// ```\n     ///\n     /// # Safety"}, {"sha": "7ba4004d8609c0ad5d7d743845240e30e98db765", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -174,7 +174,7 @@ NonZeroI8 NonZeroI16 NonZeroI32 NonZeroI64 NonZeroI128 NonZeroIsize }\n /// let zero = Wrapping(0u32);\n /// let one = Wrapping(1u32);\n ///\n-/// assert_eq!(std::u32::MAX, (zero - one).0);\n+/// assert_eq!(u32::MAX, (zero - one).0);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]"}, {"sha": "946a765e18f3ba5bdf043ee0261ee32e21104cf2", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -139,10 +139,9 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// ```\n     /// #![feature(range_is_empty)]\n     ///\n-    /// use std::f32::NAN;\n     /// assert!(!(3.0..5.0).is_empty());\n-    /// assert!( (3.0..NAN).is_empty());\n-    /// assert!( (NAN..5.0).is_empty());\n+    /// assert!( (3.0..f32::NAN).is_empty());\n+    /// assert!( (f32::NAN..5.0).is_empty());\n     /// ```\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n     pub fn is_empty(&self) -> bool {\n@@ -496,10 +495,9 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// ```\n     /// #![feature(range_is_empty)]\n     ///\n-    /// use std::f32::NAN;\n     /// assert!(!(3.0..=5.0).is_empty());\n-    /// assert!( (3.0..=NAN).is_empty());\n-    /// assert!( (NAN..=5.0).is_empty());\n+    /// assert!( (3.0..=f32::NAN).is_empty());\n+    /// assert!( (f32::NAN..=5.0).is_empty());\n     /// ```\n     ///\n     /// This method returns `true` after iteration has finished:"}, {"sha": "52e224d2a026f218b0f86d2c734b6c1f159468ce", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -659,8 +659,8 @@ impl<T: ?Sized> *const T {\n     /// `align`.\n     ///\n     /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`. It is permissible for the implementation to *always*\n-    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// `usize::MAX`. It is permissible for the implementation to *always*\n+    /// return `usize::MAX`. Only your algorithm's performance can depend\n     /// on getting a usable offset here, not its correctness.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be"}, {"sha": "9f85d781d698a5b7b88414b29eda74a1e10736ee", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -847,8 +847,8 @@ impl<T: ?Sized> *mut T {\n     /// `align`.\n     ///\n     /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`. It is permissible for the implementation to *always*\n-    /// return `usize::max_value()`. Only your algorithm's performance can depend\n+    /// `usize::MAX`. It is permissible for the implementation to *always*\n+    /// return `usize::MAX`. Only your algorithm's performance can depend\n     /// on getting a usable offset here, not its correctness.\n     ///\n     /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be"}, {"sha": "9be52e2dfb06b25cf4e3d41dfaab6e691b22873b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -2588,7 +2588,7 @@ impl<T> [T] {\n     /// assert!(![1, 3, 2, 4].is_sorted());\n     /// assert!([0].is_sorted());\n     /// assert!(empty.is_sorted());\n-    /// assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n+    /// assert!(![0.0, 1.0, f32::NAN].is_sorted());\n     /// ```\n     #[inline]\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]"}, {"sha": "924a64847a794fa568ecba9f0e556c5faa361cbb", "filename": "src/libcore/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -389,7 +389,7 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 0).checked_add(Duration::new(0, 1)), Some(Duration::new(0, 1)));\n-    /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(std::u64::MAX, 0)), None);\n+    /// assert_eq!(Duration::new(1, 0).checked_add(Duration::new(u64::MAX, 0)), None);\n     /// ```\n     #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]\n@@ -460,7 +460,7 @@ impl Duration {\n     /// use std::time::Duration;\n     ///\n     /// assert_eq!(Duration::new(0, 500_000_001).checked_mul(2), Some(Duration::new(1, 2)));\n-    /// assert_eq!(Duration::new(std::u64::MAX - 1, 0).checked_mul(2), None);\n+    /// assert_eq!(Duration::new(u64::MAX - 1, 0).checked_mul(2), None);\n     /// ```\n     #[stable(feature = \"duration_checked_ops\", since = \"1.16.0\")]\n     #[inline]"}, {"sha": "6005b607026fb4d006f32ecc26639c072d606157", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -972,8 +972,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         f: impl FnOnce(&mut Self) -> (&'hir [hir::Param<'hir>], hir::Expr<'hir>),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n+        let task_context = self.task_context.take();\n         let (parameters, result) = f(self);\n         let body_id = self.record_body(parameters, result);\n+        self.task_context = task_context;\n         self.generator_kind = prev_gen_kind;\n         body_id\n     }"}, {"sha": "9fd22c8b07bddf2b6961aa72e0ab0817efbd92d0", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -436,24 +436,21 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 //\n                 // We could remove this hack whenever we decide to drop macOS 10.10 support.\n                 if self.tcx.sess.target.target.options.is_like_osx {\n-                    assert_eq!(alloc.relocations().len(), 0);\n-\n-                    let is_zeroed = {\n-                        // Treats undefined bytes as if they were defined with the byte value that\n-                        // happens to be currently assigned in mir. This is valid since reading\n-                        // undef bytes may yield arbitrary values.\n-                        //\n-                        // FIXME: ignore undef bytes even with representation `!= 0`.\n-                        //\n-                        // The `inspect` method is okay here because we checked relocations, and\n-                        // because we are doing this access to inspect the final interpreter state\n-                        // (not as part of the interpreter execution).\n-                        alloc\n+                    // The `inspect` method is okay here because we checked relocations, and\n+                    // because we are doing this access to inspect the final interpreter state\n+                    // (not as part of the interpreter execution).\n+                    //\n+                    // FIXME: This check requires that the (arbitrary) value of undefined bytes\n+                    // happens to be zero. Instead, we should only check the value of defined bytes\n+                    // and set all undefined bytes to zero if this allocation is headed for the\n+                    // BSS.\n+                    let all_bytes_are_zero = alloc.relocations().is_empty()\n+                        && alloc\n                             .inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n-                            .all(|b| *b == 0)\n-                    };\n-                    let sect_name = if is_zeroed {\n+                            .all(|&byte| byte == 0);\n+\n+                    let sect_name = if all_bytes_are_zero {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n                     } else {\n                         CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")"}, {"sha": "b90c59f5807379247904c6735e6bda3357f75182", "filename": "src/librustc_error_codes/error_codes/E0502.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,5 +1,4 @@\n-This error indicates that you are trying to borrow a variable as mutable when it\n-has already been borrowed as immutable.\n+A variable already borrowed as immutable was borrowed as mutable.\n \n Erroneous code example:\n "}, {"sha": "758a0b39d43ee21c8c8606c5f6a99c8e3a4cb66b", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -6,7 +6,7 @@ mod engine;\n pub mod error_reporting;\n mod project;\n mod structural_impls;\n-mod util;\n+pub mod util;\n \n use rustc_hir as hir;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};"}, {"sha": "4fa74f93ddcb05675785a46709636f8f78183abb", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 78, "deletions": 2, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -2,9 +2,12 @@ use smallvec::smallvec;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::outlives::Component;\n-use rustc_middle::ty::{self, ToPolyTraitRef, TyCtxt};\n+use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, TyCtxt, WithConstness};\n \n-fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+pub fn anonymize_predicate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    pred: &ty::Predicate<'tcx>,\n+) -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data, constness) => {\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n@@ -88,6 +91,21 @@ pub struct Elaborator<'tcx> {\n     visited: PredicateSet<'tcx>,\n }\n \n+pub fn elaborate_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Elaborator<'tcx> {\n+    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n+}\n+\n+pub fn elaborate_trait_refs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Elaborator<'tcx> {\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n+    elaborate_predicates(tcx, predicates)\n+}\n+\n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>,\n@@ -98,6 +116,10 @@ pub fn elaborate_predicates<'tcx>(\n }\n \n impl Elaborator<'tcx> {\n+    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits::new(self)\n+    }\n+\n     fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n         let tcx = self.visited.tcx;\n         match *predicate {\n@@ -223,3 +245,57 @@ impl Iterator for Elaborator<'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n+\n+pub fn supertraits<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n+}\n+\n+pub fn transitive_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Other\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// A filter around an iterator of predicates that makes it yield up\n+/// just trait references.\n+pub struct FilterToTraits<I> {\n+    base_iterator: I,\n+}\n+\n+impl<I> FilterToTraits<I> {\n+    fn new(base: I) -> FilterToTraits<I> {\n+        FilterToTraits { base_iterator: base }\n+    }\n+}\n+\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+    type Item = ty::PolyTraitRef<'tcx>;\n+\n+    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let ty::Predicate::Trait(data, _) = pred {\n+                return Some(data.to_poly_trait_ref());\n+            }\n+        }\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.base_iterator.size_hint();\n+        (0, upper)\n+    }\n+}"}, {"sha": "4b92a2205c211ec6e9759ecce25003d0deda4d01", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -162,8 +162,13 @@ impl Collector<'tcx> {\n             }\n         }\n         if lib.cfg.is_some() && !self.tcx.features().link_cfg {\n-            feature_err(&self.tcx.sess.parse_sess, sym::link_cfg, span.unwrap(), \"is unstable\")\n-                .emit();\n+            feature_err(\n+                &self.tcx.sess.parse_sess,\n+                sym::link_cfg,\n+                span.unwrap(),\n+                \"kind=\\\"link_cfg\\\" is unstable\",\n+            )\n+            .emit();\n         }\n         if lib.kind == cstore::NativeStaticNobundle && !self.tcx.features().static_nobundle {\n             feature_err("}, {"sha": "e74d27bafb2d90c588c1163e605fe45bfa9c1bf0", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "removed", "additions": 0, "deletions": 277, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6fe99c798cb65280a9a56f442b371adcb7b8aa2/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "patch": "@@ -1,277 +0,0 @@\n-//! Hook into libgraphviz for rendering dataflow graphs for MIR.\n-\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::mir::{BasicBlock, Body};\n-\n-use std::fs;\n-use std::io;\n-use std::marker::PhantomData;\n-use std::path::Path;\n-\n-use crate::util::graphviz_safe_def_name;\n-\n-use super::DataflowBuilder;\n-use super::DebugFormatted;\n-use super::{BitDenotation, DataflowState};\n-\n-pub trait MirWithFlowState<'tcx> {\n-    type BD: BitDenotation<'tcx>;\n-    fn def_id(&self) -> DefId;\n-    fn body(&self) -> &Body<'tcx>;\n-    fn flow_state(&self) -> &DataflowState<'tcx, Self::BD>;\n-}\n-\n-impl<'a, 'tcx, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    type BD = BD;\n-    fn def_id(&self) -> DefId {\n-        self.def_id\n-    }\n-    fn body(&self) -> &Body<'tcx> {\n-        self.flow_state.body()\n-    }\n-    fn flow_state(&self) -> &DataflowState<'tcx, Self::BD> {\n-        &self.flow_state.flow_state\n-    }\n-}\n-\n-struct Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-{\n-    mbcx: &'a MWF,\n-    phantom: PhantomData<&'tcx ()>,\n-    render_idx: P,\n-}\n-\n-pub(crate) fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n-    mbcx: &DataflowBuilder<'a, 'tcx, BD>,\n-    path: &Path,\n-    render_idx: P,\n-) -> io::Result<()>\n-where\n-    BD: BitDenotation<'tcx>,\n-    P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-{\n-    let g = Graph { mbcx, phantom: PhantomData, render_idx };\n-    let mut v = Vec::new();\n-    dot::render(&g, &mut v)?;\n-    debug!(\"print_borrowck_graph_to path: {} def_id: {:?}\", path.display(), mbcx.def_id);\n-    fs::write(path, v)\n-}\n-\n-pub type Node = BasicBlock;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub struct Edge {\n-    source: BasicBlock,\n-    index: usize,\n-}\n-\n-fn outgoing(body: &Body<'_>, bb: BasicBlock) -> Vec<Edge> {\n-    (0..body[bb].terminator().successors().count())\n-        .map(|index| Edge { source: bb, index })\n-        .collect()\n-}\n-\n-impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-    P: Fn(&MWF::BD, <MWF::BD as BitDenotation<'tcx>>::Idx) -> DebugFormatted,\n-{\n-    type Node = Node;\n-    type Edge = Edge;\n-    fn graph_id(&self) -> dot::Id<'_> {\n-        let name = graphviz_safe_def_name(self.mbcx.def_id());\n-        dot::Id::new(format!(\"graph_for_def_id_{}\", name)).unwrap()\n-    }\n-\n-    fn node_id(&self, n: &Node) -> dot::Id<'_> {\n-        dot::Id::new(format!(\"bb_{}\", n.index())).unwrap()\n-    }\n-\n-    fn node_label(&self, n: &Node) -> dot::LabelText<'_> {\n-        // Node label is something like this:\n-        // +---------+----------------------------------+------------------+------------------+\n-        // | ENTRY   | MIR                              | GEN              | KILL             |\n-        // +---------+----------------------------------+------------------+------------------+\n-        // |         |  0: StorageLive(_7)              | bb3[2]: reserved | bb2[0]: reserved |\n-        // |         |  1: StorageLive(_8)              | bb3[2]: active   | bb2[0]: active   |\n-        // |         |  2: _8 = &mut _1                 |                  | bb4[2]: reserved |\n-        // |         |                                  |                  | bb4[2]: active   |\n-        // |         |                                  |                  | bb9[0]: reserved |\n-        // |         |                                  |                  | bb9[0]: active   |\n-        // |         |                                  |                  | bb10[0]: reserved|\n-        // |         |                                  |                  | bb10[0]: active  |\n-        // |         |                                  |                  | bb11[0]: reserved|\n-        // |         |                                  |                  | bb11[0]: active  |\n-        // +---------+----------------------------------+------------------+------------------+\n-        // | [00-00] | _7 = const Foo::twiddle(move _8) | [0c-00]          | [f3-0f]          |\n-        // +---------+----------------------------------+------------------+------------------+\n-        let mut v = Vec::new();\n-        self.node_label_internal(n, &mut v, *n, self.mbcx.body()).unwrap();\n-        dot::LabelText::html(String::from_utf8(v).unwrap())\n-    }\n-\n-    fn node_shape(&self, _n: &Node) -> Option<dot::LabelText<'_>> {\n-        Some(dot::LabelText::label(\"none\"))\n-    }\n-\n-    fn edge_label(&'a self, e: &Edge) -> dot::LabelText<'a> {\n-        let term = self.mbcx.body()[e.source].terminator();\n-        let label = &term.kind.fmt_successor_labels()[e.index];\n-        dot::LabelText::label(label.clone())\n-    }\n-}\n-\n-impl<'a, 'tcx, MWF, P> Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-    P: Fn(&MWF::BD, <MWF::BD as BitDenotation<'tcx>>::Idx) -> DebugFormatted,\n-{\n-    /// Generate the node label\n-    fn node_label_internal<W: io::Write>(\n-        &self,\n-        n: &Node,\n-        w: &mut W,\n-        block: BasicBlock,\n-        body: &Body<'_>,\n-    ) -> io::Result<()> {\n-        // Header rows\n-        const HDRS: [&str; 4] = [\"ENTRY\", \"MIR\", \"BLOCK GENS\", \"BLOCK KILLS\"];\n-        const HDR_FMT: &str = \"bgcolor=\\\"grey\\\"\";\n-        write!(w, \"<table><tr><td rowspan=\\\"{}\\\">\", HDRS.len())?;\n-        write!(w, \"{:?}\", block.index())?;\n-        write!(w, \"</td></tr><tr>\")?;\n-        for hdr in &HDRS {\n-            write!(w, \"<td {}>{}</td>\", HDR_FMT, hdr)?;\n-        }\n-        write!(w, \"</tr>\")?;\n-\n-        // Data row\n-        self.node_label_verbose_row(n, w, block, body)?;\n-        self.node_label_final_row(n, w, block, body)?;\n-        write!(w, \"</table>\")?;\n-\n-        Ok(())\n-    }\n-\n-    /// Builds the verbose row: full MIR data, and detailed gen/kill/entry sets.\n-    fn node_label_verbose_row<W: io::Write>(\n-        &self,\n-        n: &Node,\n-        w: &mut W,\n-        block: BasicBlock,\n-        body: &Body<'_>,\n-    ) -> io::Result<()> {\n-        let i = n.index();\n-\n-        macro_rules! dump_set_for {\n-            ($set:ident, $interpret:ident) => {\n-                write!(w, \"<td>\")?;\n-\n-                let flow = self.mbcx.flow_state();\n-                let entry_interp =\n-                    flow.$interpret(&flow.operator, flow.sets.$set(i), &self.render_idx);\n-                for e in &entry_interp {\n-                    write!(w, \"{:?}<br/>\", e)?;\n-                }\n-                write!(w, \"</td>\")?;\n-            };\n-        }\n-\n-        write!(w, \"<tr>\")?;\n-        // Entry\n-        dump_set_for!(entry_set_for, interpret_set);\n-\n-        // MIR statements\n-        write!(w, \"<td>\")?;\n-        {\n-            let data = &body[block];\n-            for (i, statement) in data.statements.iter().enumerate() {\n-                write!(\n-                    w,\n-                    \"{}<br align=\\\"left\\\"/>\",\n-                    dot::escape_html(&format!(\"{:3}: {:?}\", i, statement))\n-                )?;\n-            }\n-        }\n-        write!(w, \"</td>\")?;\n-\n-        // Gen\n-        dump_set_for!(gen_set_for, interpret_hybrid_set);\n-\n-        // Kill\n-        dump_set_for!(kill_set_for, interpret_hybrid_set);\n-\n-        write!(w, \"</tr>\")?;\n-\n-        Ok(())\n-    }\n-\n-    /// Builds the summary row: terminator, gen/kill/entry bit sets.\n-    fn node_label_final_row<W: io::Write>(\n-        &self,\n-        n: &Node,\n-        w: &mut W,\n-        block: BasicBlock,\n-        body: &Body<'_>,\n-    ) -> io::Result<()> {\n-        let i = n.index();\n-\n-        let flow = self.mbcx.flow_state();\n-\n-        write!(w, \"<tr>\")?;\n-\n-        // Entry\n-        let set = flow.sets.entry_set_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string()))?;\n-\n-        // Terminator\n-        write!(w, \"<td>\")?;\n-        {\n-            let data = &body[block];\n-            let mut terminator_head = String::new();\n-            data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n-            write!(w, \"{}\", dot::escape_html(&terminator_head))?;\n-        }\n-        write!(w, \"</td>\")?;\n-\n-        // Gen/Kill\n-        let trans = flow.sets.trans_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", trans.gen_set)))?;\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&format!(\"{:?}\", trans.kill_set)))?;\n-\n-        write!(w, \"</tr>\")?;\n-\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n-where\n-    MWF: MirWithFlowState<'tcx>,\n-{\n-    type Node = Node;\n-    type Edge = Edge;\n-    fn nodes(&self) -> dot::Nodes<'_, Node> {\n-        self.mbcx.body().basic_blocks().indices().collect::<Vec<_>>().into()\n-    }\n-\n-    fn edges(&self) -> dot::Edges<'_, Edge> {\n-        let body = self.mbcx.body();\n-\n-        body.basic_blocks().indices().flat_map(|bb| outgoing(body, bb)).collect::<Vec<_>>().into()\n-    }\n-\n-    fn source(&self, edge: &Edge) -> Node {\n-        edge.source\n-    }\n-\n-    fn target(&self, edge: &Edge) -> Node {\n-        let body = self.mbcx.body();\n-        *body[edge.source].terminator().successors().nth(edge.index).unwrap()\n-    }\n-}"}, {"sha": "4c25363a6575fb22b366295e23b8b1b984940b19", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -577,7 +577,7 @@ pub struct Scalar {\n     pub value: Primitive,\n \n     /// Inclusive wrap-around range of valid values, that is, if\n-    /// start > end, it represents `start..=max_value()`,\n+    /// start > end, it represents `start..=MAX`,\n     /// followed by `0..=end`.\n     ///\n     /// That is, for an i8 primitive, a range of `254..=2` means following"}, {"sha": "725c41c1e2c72de04c993d4c534eac1f6875dfb8", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 2, "deletions": 295, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -5,270 +5,11 @@ use smallvec::SmallVec;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n-use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n \n use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n-\n-fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n-    match *pred {\n-        ty::Predicate::Trait(ref data, constness) => {\n-            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n-        }\n-\n-        ty::Predicate::RegionOutlives(ref data) => {\n-            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::TypeOutlives(ref data) => {\n-            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::Projection(ref data) => {\n-            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::WellFormed(data) => ty::Predicate::WellFormed(data),\n-\n-        ty::Predicate::ObjectSafe(data) => ty::Predicate::ObjectSafe(data),\n-\n-        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n-        }\n-\n-        ty::Predicate::Subtype(ref data) => {\n-            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-            ty::Predicate::ConstEvaluatable(def_id, substs)\n-        }\n-    }\n-}\n-\n-struct PredicateSet<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    set: FxHashSet<ty::Predicate<'tcx>>,\n-}\n-\n-impl PredicateSet<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx, set: Default::default() }\n-    }\n-\n-    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n-        // We have to be careful here because we want\n-        //\n-        //    for<'a> Foo<&'a int>\n-        //\n-        // and\n-        //\n-        //    for<'b> Foo<&'b int>\n-        //\n-        // to be considered equivalent. So normalize all late-bound\n-        // regions before we throw things into the underlying set.\n-        self.set.insert(anonymize_predicate(self.tcx, pred))\n-    }\n-}\n-\n-impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n-    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n-        for pred in iter {\n-            self.insert(pred.as_ref());\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// `Elaboration` iterator\n-///////////////////////////////////////////////////////////////////////////\n-\n-/// \"Elaboration\" is the process of identifying all the predicates that\n-/// are implied by a source predicate. Currently, this basically means\n-/// walking the \"supertraits\" and other similar assumptions. For example,\n-/// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n-/// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n-/// `T: Foo`, then we know that `T: 'static`.\n-pub struct Elaborator<'tcx> {\n-    stack: Vec<ty::Predicate<'tcx>>,\n-    visited: PredicateSet<'tcx>,\n-}\n-\n-pub fn elaborate_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n-}\n-\n-pub fn elaborate_trait_refs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n-    elaborate_predicates(tcx, predicates)\n-}\n-\n-pub fn elaborate_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mut predicates: Vec<ty::Predicate<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let mut visited = PredicateSet::new(tcx);\n-    predicates.retain(|pred| visited.insert(pred));\n-    Elaborator { stack: predicates, visited }\n-}\n-\n-impl Elaborator<'tcx> {\n-    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n-        FilterToTraits::new(self)\n-    }\n-\n-    fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n-        let tcx = self.visited.tcx;\n-        match *predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n-                // Get predicates declared on the trait.\n-                let predicates = tcx.super_predicates_of(data.def_id());\n-\n-                let predicates = predicates\n-                    .predicates\n-                    .iter()\n-                    .map(|(pred, _)| pred.subst_supertrait(tcx, &data.to_poly_trait_ref()));\n-                debug!(\"super_predicates: data={:?} predicates={:?}\", data, predicates.clone());\n-\n-                // Only keep those bounds that we haven't already seen.\n-                // This is necessary to prevent infinite recursion in some\n-                // cases. One common case is when people define\n-                // `trait Sized: Sized { }` rather than `trait Sized { }`.\n-                let visited = &mut self.visited;\n-                let predicates = predicates.filter(|pred| visited.insert(pred));\n-\n-                self.stack.extend(predicates);\n-            }\n-            ty::Predicate::WellFormed(..) => {\n-                // Currently, we do not elaborate WF predicates,\n-                // although we easily could.\n-            }\n-            ty::Predicate::ObjectSafe(..) => {\n-                // Currently, we do not elaborate object-safe\n-                // predicates.\n-            }\n-            ty::Predicate::Subtype(..) => {\n-                // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n-                // though conceivably we might.\n-            }\n-            ty::Predicate::Projection(..) => {\n-                // Nothing to elaborate in a projection predicate.\n-            }\n-            ty::Predicate::ClosureKind(..) => {\n-                // Nothing to elaborate when waiting for a closure's kind to be inferred.\n-            }\n-            ty::Predicate::ConstEvaluatable(..) => {\n-                // Currently, we do not elaborate const-evaluatable\n-                // predicates.\n-            }\n-            ty::Predicate::RegionOutlives(..) => {\n-                // Nothing to elaborate from `'a: 'b`.\n-            }\n-            ty::Predicate::TypeOutlives(ref data) => {\n-                // We know that `T: 'a` for some type `T`. We can\n-                // often elaborate this. For example, if we know that\n-                // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n-                // we know `&'a U: 'b`, then we know that `'a: 'b` and\n-                // `U: 'b`.\n-                //\n-                // We can basically ignore bound regions here. So for\n-                // example `for<'c> Foo<'a,'c>: 'b` can be elaborated to\n-                // `'a: 'b`.\n-\n-                // Ignore `for<'a> T: 'a` -- we might in the future\n-                // consider this as evidence that `T: 'static`, but\n-                // I'm a bit wary of such constructions and so for now\n-                // I want to be conservative. --nmatsakis\n-                let ty_max = data.skip_binder().0;\n-                let r_min = data.skip_binder().1;\n-                if r_min.is_late_bound() {\n-                    return;\n-                }\n-\n-                let visited = &mut self.visited;\n-                let mut components = smallvec![];\n-                tcx.push_outlives_components(ty_max, &mut components);\n-                self.stack.extend(\n-                    components\n-                        .into_iter()\n-                        .filter_map(|component| match component {\n-                            Component::Region(r) => {\n-                                if r.is_late_bound() {\n-                                    None\n-                                } else {\n-                                    Some(ty::Predicate::RegionOutlives(ty::Binder::dummy(\n-                                        ty::OutlivesPredicate(r, r_min),\n-                                    )))\n-                                }\n-                            }\n-\n-                            Component::Param(p) => {\n-                                let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::Predicate::TypeOutlives(ty::Binder::dummy(\n-                                    ty::OutlivesPredicate(ty, r_min),\n-                                )))\n-                            }\n-\n-                            Component::UnresolvedInferenceVariable(_) => None,\n-\n-                            Component::Projection(_) | Component::EscapingProjection(_) => {\n-                                // We can probably do more here. This\n-                                // corresponds to a case like `<T as\n-                                // Foo<'a>>::U: 'b`.\n-                                None\n-                            }\n-                        })\n-                        .filter(|p| visited.insert(p)),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-impl Iterator for Elaborator<'tcx> {\n-    type Item = ty::Predicate<'tcx>;\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.stack.len(), None)\n-    }\n-\n-    fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n-        // Extract next item from top-most stack frame, if any.\n-        if let Some(pred) = self.stack.pop() {\n-            self.elaborate(&pred);\n-            Some(pred)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Supertrait iterator\n-///////////////////////////////////////////////////////////////////////////\n-\n-pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n-\n-pub fn supertraits<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n-}\n-\n-pub fn transitive_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n-}\n+pub use rustc_infer::traits::util::*;\n \n ///////////////////////////////////////////////////////////////////////////\n // `TraitAliasExpander` iterator\n@@ -450,40 +191,6 @@ impl Iterator for SupertraitDefIds<'tcx> {\n // Other\n ///////////////////////////////////////////////////////////////////////////\n \n-/// A filter around an iterator of predicates that makes it yield up\n-/// just trait references.\n-pub struct FilterToTraits<I> {\n-    base_iterator: I,\n-}\n-\n-impl<I> FilterToTraits<I> {\n-    fn new(base: I) -> FilterToTraits<I> {\n-        FilterToTraits { base_iterator: base }\n-    }\n-}\n-\n-impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n-    type Item = ty::PolyTraitRef<'tcx>;\n-\n-    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n-        while let Some(pred) = self.base_iterator.next() {\n-            if let ty::Predicate::Trait(data, _) = pred {\n-                return Some(data.to_poly_trait_ref());\n-            }\n-        }\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.base_iterator.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Other\n-///////////////////////////////////////////////////////////////////////////\n-\n /// Instantiate all bound parameters of the impl with the given substs,\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization."}, {"sha": "ac8f305ae9127cd54e6546308210442ba5ca681c", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -284,7 +284,7 @@ impl f32 {\n     /// assert_eq!(a.rem_euclid(-b), 3.0);\n     /// assert_eq!((-a).rem_euclid(-b), 1.0);\n     /// // limitation due to round-off error\n-    /// assert!((-std::f32::EPSILON).rem_euclid(3.0) != 0.0);\n+    /// assert!((-f32::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n@@ -962,7 +962,7 @@ impl f32 {\n     /// assert!((-3.0f32).clamp(-2.0, 1.0) == -2.0);\n     /// assert!((0.0f32).clamp(-2.0, 1.0) == 0.0);\n     /// assert!((2.0f32).clamp(-2.0, 1.0) == 1.0);\n-    /// assert!((std::f32::NAN).clamp(-2.0, 1.0).is_nan());\n+    /// assert!((f32::NAN).clamp(-2.0, 1.0).is_nan());\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[unstable(feature = \"clamp\", issue = \"44095\")]"}, {"sha": "798738e50a75484e18aaaa6ee6916c11b3064584", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -280,7 +280,7 @@ impl f64 {\n     /// assert_eq!(a.rem_euclid(-b), 3.0);\n     /// assert_eq!((-a).rem_euclid(-b), 1.0);\n     /// // limitation due to round-off error\n-    /// assert!((-std::f64::EPSILON).rem_euclid(3.0) != 0.0);\n+    /// assert!((-f64::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n@@ -928,7 +928,7 @@ impl f64 {\n     /// assert!((-3.0f64).clamp(-2.0, 1.0) == -2.0);\n     /// assert!((0.0f64).clamp(-2.0, 1.0) == 0.0);\n     /// assert!((2.0f64).clamp(-2.0, 1.0) == 1.0);\n-    /// assert!((std::f64::NAN).clamp(-2.0, 1.0).is_nan());\n+    /// assert!((f64::NAN).clamp(-2.0, 1.0).is_nan());\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[unstable(feature = \"clamp\", issue = \"44095\")]"}, {"sha": "9339b143731052799342e021d6bc1b37624e876f", "filename": "src/libstd/sys/cloudabi/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,13 +1,5 @@\n #![cfg_attr(test, allow(dead_code))]\n \n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n pub unsafe fn init() {}\n \n pub unsafe fn cleanup() {}"}, {"sha": "a15dc8653e83a256d01ba17618caedd905e3b473", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -5,7 +5,6 @@ use crate::mem;\n use crate::ptr;\n use crate::sys::cloudabi::abi;\n use crate::sys::time::checked_dur2intervals;\n-use crate::sys_common::thread::*;\n use crate::time::Duration;\n \n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n@@ -22,27 +21,33 @@ unsafe impl Sync for Thread {}\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n         assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n+        // Note: if the thread creation fails and this assert fails, then p will\n+        // be leaked. However, an alternative design could cause double-free\n+        // which is clearly worse.\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n \n         extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             ptr::null_mut()\n         }"}, {"sha": "121fe42011da5ac355e4e507d06455cea1e3280d", "filename": "src/libstd/sys/hermit/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,11 +1,3 @@\n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n #[inline]\n pub unsafe fn init() {}\n "}, {"sha": "c7bea168f34d846c7b62b613aa11c84940c71ae7", "filename": "src/libstd/sys/hermit/thread.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -8,8 +8,6 @@ use crate::sys::hermit::abi;\n use crate::time::Duration;\n use core::u32;\n \n-use crate::sys_common::thread::*;\n-\n pub type Tid = abi::Tid;\n \n /// Priority of a task\n@@ -49,26 +47,29 @@ impl Thread {\n         p: Box<dyn FnOnce()>,\n         core_id: isize,\n     ) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut tid: Tid = u32::MAX;\n         let ret = abi::spawn(\n             &mut tid as *mut Tid,\n             thread_start,\n-            &*p as *const _ as *const u8 as usize,\n+            p as usize,\n             Priority::into(NORMAL_PRIO),\n             core_id,\n         );\n \n-        return if ret == 0 {\n-            mem::forget(p); // ownership passed to pthread_create\n-            Ok(Thread { tid: tid })\n-        } else {\n+        return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n+        } else {\n+            Ok(Thread { tid: tid })\n         };\n \n         extern \"C\" fn thread_start(main: usize) {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n         }\n     }"}, {"sha": "b96652a8330e9f490465ccd6dc4837de74fedb42", "filename": "src/libstd/sys/sgx/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,11 +1,3 @@\n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n #[cfg_attr(test, allow(dead_code))]\n pub unsafe fn init() {}\n "}, {"sha": "aab5a92a7ad2a481b89d77f231a1276f1ff72218", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -3,11 +3,9 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n use crate::ptr;\n-use crate::sys::os;\n+use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-use crate::sys_common::thread::*;\n-\n #[cfg(not(target_os = \"l4re\"))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n #[cfg(target_os = \"l4re\")]\n@@ -43,7 +41,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -65,19 +63,28 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n+        // Note: if the thread creation fails and this assert fails, then p will\n+        // be leaked. However, an alternative design could cause double-free\n+        // which is clearly worse.\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n \n         extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Next, set up our stack overflow handler which may get triggered if we run\n+                // out of stack.\n+                let _handler = stack_overflow::Handler::new();\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             ptr::null_mut()\n         }"}, {"sha": "4d0196e4b4de5877faeab1110102b3233c7adc68", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -3,11 +3,9 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n use crate::ptr;\n-use crate::sys::os;\n+use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-use crate::sys_common::thread::*;\n-\n pub const DEFAULT_MIN_STACK_SIZE: usize = 0x40000; // 256K\n \n pub struct Thread {\n@@ -31,7 +29,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -53,19 +51,28 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n+        // Note: if the thread creation fails and this assert fails, then p will\n+        // be leaked. However, an alternative design could cause double-free\n+        // which is clearly worse.\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n \n         extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Next, set up our stack overflow handler which may get triggered if we run\n+                // out of stack.\n+                let _handler = stack_overflow::Handler::new();\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             ptr::null_mut()\n         }"}, {"sha": "32555394cd5a58fa3f5347bafd85af5f91350aab", "filename": "src/libstd/sys/wasm/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,11 +1,3 @@\n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n pub unsafe fn init() {}\n \n pub unsafe fn cleanup() {}"}, {"sha": "38839ea5e90ed3a729d1830dbe19a5f8c3ebe830", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,10 +1,9 @@\n use crate::ffi::CStr;\n use crate::io;\n-use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n-use crate::sys_common::thread::*;\n+use crate::sys::stack_overflow;\n use crate::time::Duration;\n \n use libc::c_void;\n@@ -20,7 +19,7 @@ pub struct Thread {\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n@@ -34,21 +33,27 @@ impl Thread {\n             ptr::null_mut(),\n             stack_size,\n             thread_start,\n-            &*p as *const _ as *mut _,\n+            p as *mut _,\n             c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n             ptr::null_mut(),\n         );\n \n         return if ret as usize == 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::last_os_error())\n         } else {\n-            mem::forget(p); // ownership passed to CreateThread\n             Ok(Thread { handle: Handle::new(ret) })\n         };\n \n         extern \"system\" fn thread_start(main: *mut c_void) -> c::DWORD {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Next, set up our stack overflow handler which may get triggered if we run\n+                // out of stack.\n+                let _handler = stack_overflow::Handler::new();\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             0\n         }"}, {"sha": "f3a8bef8f718f3079384c8039a25174526de1d39", "filename": "src/libstd/sys_common/thread.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,18 +1,7 @@\n use crate::env;\n use crate::sync::atomic::{self, Ordering};\n-use crate::sys::stack_overflow;\n use crate::sys::thread as imp;\n \n-#[allow(dead_code)]\n-pub unsafe fn start_thread(main: *mut u8) {\n-    // Next, set up our stack overflow handler which may get triggered if we run\n-    // out of stack.\n-    let _handler = stack_overflow::Handler::new();\n-\n-    // Finally, let's run some code.\n-    Box::from_raw(main as *mut Box<dyn FnOnce()>)()\n-}\n-\n pub fn min_stack() -> usize {\n     static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n     match MIN.load(Ordering::SeqCst) {"}, {"sha": "e78231a68512daf1f306cb1e24f6f19ee5841551", "filename": "src/test/ui/async-await/issue-70594.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+\n+async fn fun() {\n+    [1; ().await];\n+    //~^ error: `await` is only allowed inside `async` functions and blocks\n+    //~| error: `.await` is not allowed in a `const`\n+    //~| error: `loop` is not allowed in a `const`\n+    //~| error: `.await` is not allowed in a `const`\n+    //~| error: the trait bound `(): std::future::Future` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "d2fa7e58f6a9b7ec5e0ef540a071452959f53a5e", "filename": "src/test/ui/async-await/issue-70594.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-70594.stderr?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -0,0 +1,44 @@\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/issue-70594.rs:4:9\n+   |\n+LL | async fn fun() {\n+   |          --- this is not `async`\n+LL |     [1; ().await];\n+   |         ^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0744]: `.await` is not allowed in a `const`\n+  --> $DIR/issue-70594.rs:4:9\n+   |\n+LL |     [1; ().await];\n+   |         ^^^^^^^^\n+\n+error[E0658]: `loop` is not allowed in a `const`\n+  --> $DIR/issue-70594.rs:4:9\n+   |\n+LL |     [1; ().await];\n+   |         ^^^^^^^^\n+   |\n+   = note: see issue #52000 <https://github.com/rust-lang/rust/issues/52000> for more information\n+   = help: add `#![feature(const_loop)]` to the crate attributes to enable\n+\n+error[E0744]: `.await` is not allowed in a `const`\n+  --> $DIR/issue-70594.rs:4:9\n+   |\n+LL |     [1; ().await];\n+   |         ^^^^^^^^\n+\n+error[E0277]: the trait bound `(): std::future::Future` is not satisfied\n+  --> $DIR/issue-70594.rs:4:9\n+   |\n+LL |     [1; ().await];\n+   |         ^^^^^^^^ the trait `std::future::Future` is not implemented for `()`\n+   | \n+  ::: $SRC_DIR/libcore/future/mod.rs:LL:COL\n+   |\n+LL |     F: Future,\n+   |        ------ required by this bound in `std::future::poll_with_context`\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0277, E0658, E0728, E0744.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "41a7dfc3f379fc554160f6c54817d889e580a189", "filename": "src/test/ui/feature-gates/feature-gate-link_cfg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-link_cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-link_cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-link_cfg.stderr?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: is unstable\n+error[E0658]: kind=\"link_cfg\" is unstable\n   --> $DIR/feature-gate-link_cfg.rs:1:1\n    |\n LL | #[link(name = \"foo\", cfg(foo))]"}, {"sha": "3561f40127737b960043c5fd2eac34e2557a9329", "filename": "src/test/ui/issues/issue-70673.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Fissues%2Fissue-70673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Fissues%2Fissue-70673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70673.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -0,0 +1,12 @@\n+// Regression test for https://github.com/rust-lang/rust/issues/70673.\n+\n+// run-pass\n+\n+#![feature(thread_local)]\n+\n+#[thread_local]\n+static A: &u8 = &42;\n+\n+fn main() {\n+    dbg!(*A);\n+}"}, {"sha": "c3325fd80ca0cc964c91412450c23cbe79c58152", "filename": "src/test/ui/traits/impl_trait_as_trait_return_position.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Ftraits%2Fimpl_trait_as_trait_return_position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74bd074eefcf4915c73d1ab91bc90859664729e6/src%2Ftest%2Fui%2Ftraits%2Fimpl_trait_as_trait_return_position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fimpl_trait_as_trait_return_position.rs?ref=74bd074eefcf4915c73d1ab91bc90859664729e6", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+\n+trait A {\n+    type Foo;\n+}\n+\n+impl<T> A for T {\n+    type Foo = ();\n+}\n+\n+fn foo() -> impl std::borrow::Borrow<<u8 as A>::Foo> {\n+    ()\n+}\n+\n+fn main() {\n+    foo();\n+}"}]}