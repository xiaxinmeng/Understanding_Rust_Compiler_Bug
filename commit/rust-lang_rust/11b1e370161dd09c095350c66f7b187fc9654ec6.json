{"sha": "11b1e370161dd09c095350c66f7b187fc9654ec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYjFlMzcwMTYxZGQwOWMwOTUzNTBjNjZmN2IxODdmYzk2NTRlYzY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-01-18T21:47:37Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-01-20T23:09:32Z"}, "message": "Force token collection to run when parsing nonterminals\n\nFixes #81007\n\nPreviously, we would fail to collect tokens in the proper place when\nonly builtin attributes were present. As a result, we would end up with\nattribute tokens in the collected `TokenStream`, leading to duplication\nwhen we attempted to prepend the attributes from the AST node.\n\nWe now explicitly track when token collection must be performed due to\nnomterminal parsing.", "tree": {"sha": "c46df174a600d0557fe310f927cdabfec2ef06fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c46df174a600d0557fe310f927cdabfec2ef06fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11b1e370161dd09c095350c66f7b187fc9654ec6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmAIuCwACgkQtAh+UQ6Y\nsWQPew/+JcfWOVFe8XjA9LLbbLxZ3hnC0xCAaGE+n4NTIim0DQpflEEhbY6+d9+I\nKHBe9QCtVNwsaFajoCMZ0FdgUmzgAz3oz4lsz7hhEwTLtZNRnD/As6Pe4iatY2L0\n2XA37hP3TmZW3IrKG4BsdxpdaMSYxg7dNynH4zRlifIHkDjVSCpMupFEotgu8ca9\nS6Jy5My9XT5o2RvErMNrhby+CaAbEfBJNj7b9qfbjyYk6nd97uZ9Si+IxY5lQYdj\nI1fZXICCVrKmgMZgCHxzrxjqLM2wHCOtJPBincxFFBenfsfuOzZgkd2DXAiUdR4W\nBT73+nvEiq7lGIr1a8iy0xyw0Jl7Ym8tCTfYK6W6C0BidcfH7FOqaqqDaxihQc/q\nMTJil+bCxc2xsi5rFCx4nusZEhrAK05R79idPRIY+ZoXA86O1AjdDIQas634/oCc\nKG5v7FBARybG78kCBGnFI2rfhuyhFZVwcSTSzn+FXSEESLz1uDZ8Ad8fy+mkMiH0\n2ZibkGsStQvcjlO9IYFNNreGqj+Hb9bLu7bdPuBtG3K545CVCK8m4ukFUxEYIFLK\nHiIOy6Uxs/SfJCaf/gNZuZGEqfgGqLF0bGMQmC3RQJO77MmkPgiPI9/ZWm3loG36\na+LGL/NOFy/lJ3PVWj+51n09SxQbxK6U5exIZ61yJyATdxVsnbg=\n=F0Nw\n-----END PGP SIGNATURE-----", "payload": "tree c46df174a600d0557fe310f927cdabfec2ef06fc\nparent a4cbb44ae2c80545db957763b502dc7f6ea22085\nauthor Aaron Hill <aa1ronham@gmail.com> 1611006457 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1611184172 -0500\n\nForce token collection to run when parsing nonterminals\n\nFixes #81007\n\nPreviously, we would fail to collect tokens in the proper place when\nonly builtin attributes were present. As a result, we would end up with\nattribute tokens in the collected `TokenStream`, leading to duplication\nwhen we attempted to prepend the attributes from the AST node.\n\nWe now explicitly track when token collection must be performed due to\nnomterminal parsing.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11b1e370161dd09c095350c66f7b187fc9654ec6", "html_url": "https://github.com/rust-lang/rust/commit/11b1e370161dd09c095350c66f7b187fc9654ec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11b1e370161dd09c095350c66f7b187fc9654ec6/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4cbb44ae2c80545db957763b502dc7f6ea22085", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cbb44ae2c80545db957763b502dc7f6ea22085", "html_url": "https://github.com/rust-lang/rust/commit/a4cbb44ae2c80545db957763b502dc7f6ea22085"}], "stats": {"total": 305, "additions": 233, "deletions": 72}, "files": [{"sha": "28efd483c8670ae5cba9a5fbe9020ebe01bbf398", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -5,7 +5,8 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n use rustc_expand::module::DirectoryOwnership;\n-use rustc_parse::{self, new_parser_from_file, parser::Parser};\n+use rustc_parse::parser::{ForceCollect, Parser};\n+use rustc_parse::{self, new_parser_from_file};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n use rustc_span::symbol::Symbol;\n use rustc_span::{self, Pos, Span};\n@@ -139,7 +140,7 @@ pub fn expand_include<'cx>(\n         fn make_items(mut self: Box<ExpandResult<'a>>) -> Option<SmallVec<[P<ast::Item>; 1]>> {\n             let mut ret = SmallVec::new();\n             while self.p.token != token::Eof {\n-                match self.p.parse_item() {\n+                match self.p.parse_item(ForceCollect::No) {\n                     Err(mut err) => {\n                         err.emit();\n                         break;"}, {"sha": "5d398935ce8157827dc1319be1d7ba09e0b70397", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -20,7 +20,7 @@ use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{struct_span_err, Applicability, PResult};\n use rustc_feature::Features;\n-use rustc_parse::parser::{AttemptLocalParseRecovery, Parser};\n+use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, Parser};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -913,7 +913,7 @@ pub fn parse_ast_fragment<'a>(\n     Ok(match kind {\n         AstFragmentKind::Items => {\n             let mut items = SmallVec::new();\n-            while let Some(item) = this.parse_item()? {\n+            while let Some(item) = this.parse_item(ForceCollect::No)? {\n                 items.push(item);\n             }\n             AstFragment::Items(items)"}, {"sha": "f4fcaf5c0a4520184d243935606355dee2d8a2db", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -8,6 +8,7 @@ use rustc_ast::{self as ast, PatKind};\n use rustc_ast_pretty::pprust::item_to_string;\n use rustc_errors::PResult;\n use rustc_parse::new_parser_from_source_str;\n+use rustc_parse::parser::ForceCollect;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::FilePathMapping;\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -29,7 +30,7 @@ fn parse_item_from_source_str(\n     source: String,\n     sess: &ParseSess,\n ) -> PResult<'_, Option<P<ast::Item>>> {\n-    new_parser_from_source_str(sess, name, source).parse_item()\n+    new_parser_from_source_str(sess, name, source).parse_item(ForceCollect::No)\n }\n \n // Produces a `rustc_span::span`.\n@@ -44,7 +45,7 @@ fn string_to_expr(source_str: String) -> P<ast::Expr> {\n \n /// Parses a string, returns an item.\n fn string_to_item(source_str: String) -> Option<P<ast::Item>> {\n-    with_error_checking_parse(source_str, &sess(), |p| p.parse_item())\n+    with_error_checking_parse(source_str, &sess(), |p| p.parse_item(ForceCollect::No))\n }\n \n #[should_panic]"}, {"sha": "6779734cfc1768004d467c21760679d8d8fccfe0", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, ErrorReported};\n use rustc_lexer::is_ident;\n use rustc_parse::nt_to_tokenstream;\n+use rustc_parse::parser::ForceCollect;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -117,7 +118,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         let mut items = vec![];\n \n         loop {\n-            match parser.parse_item() {\n+            match parser.parse_item(ForceCollect::No) {\n                 Ok(None) => break,\n                 Ok(Some(item)) => {\n                     if is_stmt {"}, {"sha": "47869f775fe6e2496822c225eb0e7ddb6721318d", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -472,7 +472,11 @@ impl<'a> Parser<'a> {\n     /// Parses a prefix-unary-operator expr.\n     fn parse_prefix_expr(&mut self, attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n-        let needs_tokens = super::attr::maybe_needs_tokens(&attrs);\n+        // FIXME: Use super::attr::maybe_needs_tokens(&attrs) once we come up\n+        // with a good way of passing `force_tokens` through from `parse_nonterminal`.\n+        // Checking !attrs.is_empty() is correct, but will cause us to unnecessarily\n+        // capture tokens in some circumstances.\n+        let needs_tokens = !attrs.is_empty();\n         let do_parse = |this: &mut Parser<'a>| {\n             let lo = this.token.span;\n             // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()"}, {"sha": "28067f0216c746d631d81aec8dfd7309313c44b1", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -1,8 +1,8 @@\n use super::diagnostics::{dummy_arg, ConsumeClosingDelim, Error};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n-use super::{FollowedByType, Parser, PathStyle};\n+use super::{FollowedByType, ForceCollect, Parser, PathStyle};\n \n-use crate::maybe_whole;\n+use crate::{maybe_collect_tokens, maybe_whole};\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, TokenKind};\n@@ -69,7 +69,7 @@ impl<'a> Parser<'a> {\n         unsafety: Unsafe,\n     ) -> PResult<'a, Mod> {\n         let mut items = vec![];\n-        while let Some(item) = self.parse_item()? {\n+        while let Some(item) = self.parse_item(ForceCollect::No)? {\n             items.push(item);\n             self.maybe_consume_incorrect_semicolon(&items);\n         }\n@@ -93,13 +93,17 @@ impl<'a> Parser<'a> {\n pub(super) type ItemInfo = (Ident, ItemKind);\n \n impl<'a> Parser<'a> {\n-    pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n-        self.parse_item_(|_| true).map(|i| i.map(P))\n+    pub fn parse_item(&mut self, force_collect: ForceCollect) -> PResult<'a, Option<P<Item>>> {\n+        self.parse_item_(|_| true, force_collect).map(|i| i.map(P))\n     }\n \n-    fn parse_item_(&mut self, req_name: ReqName) -> PResult<'a, Option<Item>> {\n+    fn parse_item_(\n+        &mut self,\n+        req_name: ReqName,\n+        force_collect: ForceCollect,\n+    ) -> PResult<'a, Option<Item>> {\n         let attrs = self.parse_outer_attributes()?;\n-        self.parse_item_common(attrs, true, false, req_name)\n+        self.parse_item_common(attrs, true, false, req_name, force_collect)\n     }\n \n     pub(super) fn parse_item_common(\n@@ -108,6 +112,7 @@ impl<'a> Parser<'a> {\n         mac_allowed: bool,\n         attrs_allowed: bool,\n         req_name: ReqName,\n+        force_collect: ForceCollect,\n     ) -> PResult<'a, Option<Item>> {\n         maybe_whole!(self, NtItem, |item| {\n             let mut item = item;\n@@ -116,16 +121,12 @@ impl<'a> Parser<'a> {\n             Some(item.into_inner())\n         });\n \n-        let needs_tokens = super::attr::maybe_needs_tokens(&attrs);\n-\n         let mut unclosed_delims = vec![];\n-        let parse_item = |this: &mut Self| {\n+        let item = maybe_collect_tokens!(self, force_collect, &attrs, |this: &mut Self| {\n             let item = this.parse_item_common_(attrs, mac_allowed, attrs_allowed, req_name);\n             unclosed_delims.append(&mut this.unclosed_delims);\n             item\n-        };\n-\n-        let item = if needs_tokens { self.collect_tokens(parse_item) } else { parse_item(self) }?;\n+        })?;\n \n         self.unclosed_delims.append(&mut unclosed_delims);\n         Ok(item)\n@@ -731,20 +732,22 @@ impl<'a> Parser<'a> {\n \n     /// Parses associated items.\n     fn parse_assoc_item(&mut self, req_name: ReqName) -> PResult<'a, Option<Option<P<AssocItem>>>> {\n-        Ok(self.parse_item_(req_name)?.map(|Item { attrs, id, span, vis, ident, kind, tokens }| {\n-            let kind = match AssocItemKind::try_from(kind) {\n-                Ok(kind) => kind,\n-                Err(kind) => match kind {\n-                    ItemKind::Static(a, _, b) => {\n-                        self.struct_span_err(span, \"associated `static` items are not allowed\")\n-                            .emit();\n-                        AssocItemKind::Const(Defaultness::Final, a, b)\n-                    }\n-                    _ => return self.error_bad_item_kind(span, &kind, \"`trait`s or `impl`s\"),\n-                },\n-            };\n-            Some(P(Item { attrs, id, span, vis, ident, kind, tokens }))\n-        }))\n+        Ok(self.parse_item_(req_name, ForceCollect::No)?.map(\n+            |Item { attrs, id, span, vis, ident, kind, tokens }| {\n+                let kind = match AssocItemKind::try_from(kind) {\n+                    Ok(kind) => kind,\n+                    Err(kind) => match kind {\n+                        ItemKind::Static(a, _, b) => {\n+                            self.struct_span_err(span, \"associated `static` items are not allowed\")\n+                                .emit();\n+                            AssocItemKind::Const(Defaultness::Final, a, b)\n+                        }\n+                        _ => return self.error_bad_item_kind(span, &kind, \"`trait`s or `impl`s\"),\n+                    },\n+                };\n+                Some(P(Item { attrs, id, span, vis, ident, kind, tokens }))\n+            },\n+        ))\n     }\n \n     /// Parses a `type` alias with the following grammar:\n@@ -921,19 +924,21 @@ impl<'a> Parser<'a> {\n \n     /// Parses a foreign item (one in an `extern { ... }` block).\n     pub fn parse_foreign_item(&mut self) -> PResult<'a, Option<Option<P<ForeignItem>>>> {\n-        Ok(self.parse_item_(|_| true)?.map(|Item { attrs, id, span, vis, ident, kind, tokens }| {\n-            let kind = match ForeignItemKind::try_from(kind) {\n-                Ok(kind) => kind,\n-                Err(kind) => match kind {\n-                    ItemKind::Const(_, a, b) => {\n-                        self.error_on_foreign_const(span, ident);\n-                        ForeignItemKind::Static(a, Mutability::Not, b)\n-                    }\n-                    _ => return self.error_bad_item_kind(span, &kind, \"`extern` blocks\"),\n-                },\n-            };\n-            Some(P(Item { attrs, id, span, vis, ident, kind, tokens }))\n-        }))\n+        Ok(self.parse_item_(|_| true, ForceCollect::No)?.map(\n+            |Item { attrs, id, span, vis, ident, kind, tokens }| {\n+                let kind = match ForeignItemKind::try_from(kind) {\n+                    Ok(kind) => kind,\n+                    Err(kind) => match kind {\n+                        ItemKind::Const(_, a, b) => {\n+                            self.error_on_foreign_const(span, ident);\n+                            ForeignItemKind::Static(a, Mutability::Not, b)\n+                        }\n+                        _ => return self.error_bad_item_kind(span, &kind, \"`extern` blocks\"),\n+                    },\n+                };\n+                Some(P(Item { attrs, id, span, vis, ident, kind, tokens }))\n+            },\n+        ))\n     }\n \n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n@@ -1515,7 +1520,7 @@ impl<'a> Parser<'a> {\n         {\n             let kw_token = self.token.clone();\n             let kw_str = pprust::token_to_string(&kw_token);\n-            let item = self.parse_item()?;\n+            let item = self.parse_item(ForceCollect::No)?;\n \n             self.struct_span_err(\n                 kw_token.span,"}, {"sha": "c85b7a00732d3a56fef7a2bf5e8a450f1ebee1e1", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -54,6 +54,13 @@ enum BlockMode {\n     Ignore,\n }\n \n+/// Whether or not we should force collection of tokens for an AST node,\n+/// regardless of whether or not it has attributes\n+pub enum ForceCollect {\n+    Yes,\n+    No,\n+}\n+\n /// Like `maybe_whole_expr`, but for things other than expressions.\n #[macro_export]\n macro_rules! maybe_whole {\n@@ -1413,3 +1420,16 @@ fn make_token_stream(\n     assert!(stack.is_empty(), \"Stack should be empty: final_buf={:?} stack={:?}\", final_buf, stack);\n     TokenStream::new(final_buf.inner)\n }\n+\n+#[macro_export]\n+macro_rules! maybe_collect_tokens {\n+    ($self:ident, $force_collect:expr, $attrs:expr, $f:expr) => {\n+        if matches!($force_collect, ForceCollect::Yes)\n+            || $crate::parser::attr::maybe_needs_tokens($attrs)\n+        {\n+            $self.collect_tokens($f)\n+        } else {\n+            $f($self)\n+        }\n+    };\n+}"}, {"sha": "012b76d3d188704c342f38222809e337b79c56c8", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -5,7 +5,7 @@ use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n use crate::parser::pat::{GateOr, RecoverComma};\n-use crate::parser::{FollowedByType, Parser, PathStyle};\n+use crate::parser::{FollowedByType, ForceCollect, Parser, PathStyle};\n \n impl<'a> Parser<'a> {\n     /// Checks whether a non-terminal may begin with a particular token.\n@@ -98,7 +98,7 @@ impl<'a> Parser<'a> {\n         // in advance whether or not a proc-macro will be (transitively) invoked,\n         // we always capture tokens for any `Nonterminal` which needs them.\n         Ok(match kind {\n-            NonterminalKind::Item => match self.collect_tokens(|this| this.parse_item())? {\n+            NonterminalKind::Item => match self.parse_item(ForceCollect::Yes)? {\n                 Some(item) => token::NtItem(item),\n                 None => {\n                     return Err(self.struct_span_err(self.token.span, \"expected an item keyword\"));\n@@ -107,7 +107,7 @@ impl<'a> Parser<'a> {\n             NonterminalKind::Block => {\n                 token::NtBlock(self.collect_tokens(|this| this.parse_block())?)\n             }\n-            NonterminalKind::Stmt => match self.collect_tokens(|this| this.parse_stmt())? {\n+            NonterminalKind::Stmt => match self.parse_stmt(ForceCollect::Yes)? {\n                 Some(s) => token::NtStmt(s),\n                 None => {\n                     return Err(self.struct_span_err(self.token.span, \"expected a statement\"));"}, {"sha": "da60ba8472ba3f7143138bdb2b4d77f20ffbdf1f", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -3,8 +3,8 @@ use super::diagnostics::{AttemptLocalParseRecovery, Error};\n use super::expr::LhsExpr;\n use super::pat::{GateOr, RecoverComma};\n use super::path::PathStyle;\n-use super::{BlockMode, Parser, Restrictions, SemiColonMode};\n-use crate::maybe_whole;\n+use super::{BlockMode, ForceCollect, Parser, Restrictions, SemiColonMode};\n+use crate::{maybe_collect_tokens, maybe_whole};\n \n use rustc_ast as ast;\n use rustc_ast::attr::HasAttrs;\n@@ -24,17 +24,21 @@ impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n     // Public for rustfmt usage.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n+    pub fn parse_stmt(&mut self, force_collect: ForceCollect) -> PResult<'a, Option<Stmt>> {\n+        Ok(self.parse_stmt_without_recovery(force_collect).unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n             None\n         }))\n     }\n \n-    fn parse_stmt_without_recovery(&mut self) -> PResult<'a, Option<Stmt>> {\n+    /// If `force_capture` is true, forces collection of tokens regardless of whether\n+    /// or not we have attributes\n+    fn parse_stmt_without_recovery(\n+        &mut self,\n+        force_collect: ForceCollect,\n+    ) -> PResult<'a, Option<Stmt>> {\n         let mut attrs = self.parse_outer_attributes()?;\n-        let has_attrs = !attrs.is_empty();\n         let lo = self.token.span;\n \n         maybe_whole!(self, NtStmt, |stmt| {\n@@ -46,7 +50,7 @@ impl<'a> Parser<'a> {\n             Some(stmt)\n         });\n \n-        let parse_stmt_inner = |this: &mut Self| {\n+        maybe_collect_tokens!(self, force_collect, &attrs, |this: &mut Self| {\n             let stmt = if this.eat_keyword(kw::Let) {\n                 this.parse_local_mk(lo, attrs.into())?\n             } else if this.is_kw_followed_by_ident(kw::Mut) {\n@@ -69,7 +73,7 @@ impl<'a> Parser<'a> {\n                 // Also, we avoid stealing syntax from `parse_item_`.\n                 this.parse_stmt_path_start(lo, attrs)?\n             } else if let Some(item) =\n-                this.parse_item_common(attrs.clone(), false, true, |_| true)?\n+                this.parse_item_common(attrs.clone(), false, true, |_| true, force_collect)?\n             {\n                 // FIXME: Bad copy of attrs\n                 this.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))\n@@ -86,14 +90,7 @@ impl<'a> Parser<'a> {\n                 return Ok(None);\n             };\n             Ok(Some(stmt))\n-        };\n-\n-        let stmt = if has_attrs {\n-            self.collect_tokens(parse_stmt_inner)?\n-        } else {\n-            parse_stmt_inner(self)?\n-        };\n-        Ok(stmt)\n+        })\n     }\n \n     fn parse_stmt_path_start(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, Stmt> {\n@@ -292,7 +289,7 @@ impl<'a> Parser<'a> {\n         //      bar;\n         //\n         // which is valid in other languages, but not Rust.\n-        match self.parse_stmt_without_recovery() {\n+        match self.parse_stmt_without_recovery(ForceCollect::No) {\n             // If the next token is an open brace (e.g., `if a b {`), the place-\n             // inside-a-block suggestion would be more likely wrong than right.\n             Ok(Some(_))\n@@ -395,7 +392,7 @@ impl<'a> Parser<'a> {\n         // Skip looking for a trailing semicolon when we have an interpolated statement.\n         maybe_whole!(self, NtStmt, |x| Some(x));\n \n-        let mut stmt = match self.parse_stmt_without_recovery()? {\n+        let mut stmt = match self.parse_stmt_without_recovery(ForceCollect::No)? {\n             Some(stmt) => stmt,\n             None => return Ok(None),\n         };"}, {"sha": "c87ab833f7a5e443d430b0e210556934e6a4273c", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -423,6 +423,7 @@ crate fn make_test(\n             use rustc_errors::emitter::{Emitter, EmitterWriter};\n             use rustc_errors::Handler;\n             use rustc_parse::maybe_new_parser_from_source_str;\n+            use rustc_parse::parser::ForceCollect;\n             use rustc_session::parse::ParseSess;\n             use rustc_span::source_map::FilePathMapping;\n \n@@ -459,7 +460,7 @@ crate fn make_test(\n             };\n \n             loop {\n-                match parser.parse_item() {\n+                match parser.parse_item(ForceCollect::No) {\n                     Ok(Some(item)) => {\n                         if !found_main {\n                             if let ast::ItemKind::Fn(..) = item.kind {"}, {"sha": "ea27d54ee4148123d11bc6fea2cdcc9b1b271c06", "filename": "src/test/ui/proc-macro/issue-81007-item-attrs.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81007-item-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81007-item-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81007-item-attrs.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+// edition:2018\n+// compile-flags: -Z span-debug\n+// aux-build:test-macros.rs\n+\n+#![feature(rustc_attrs)]\n+\n+#![no_std] // Don't load unnecessary hygiene information from std\n+extern crate std;\n+\n+#[macro_use] extern crate test_macros;\n+\n+macro_rules! capture_item {\n+    ($item:item) => {\n+        #[print_attr]\n+        $item\n+    }\n+}\n+\n+capture_item! {\n+    /// A doc comment\n+    struct Foo {}\n+}\n+\n+capture_item! {\n+    #[rustc_dummy]\n+    /// Another comment comment\n+    struct Bar {}\n+}\n+\n+fn main() {}"}, {"sha": "6f880a120217002560b131b202a6b9068f006997", "filename": "src/test/ui/proc-macro/issue-81007-item-attrs.stdout", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81007-item-attrs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81007-item-attrs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-81007-item-attrs.stdout?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -0,0 +1,99 @@\n+PRINT-ATTR INPUT (DISPLAY): #[doc = r\" A doc comment\"] struct Foo { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/issue-81007-item-attrs.rs:21:5: 21:22 (#0),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"doc\",\n+                span: $DIR/issue-81007-item-attrs.rs:21:5: 21:22 (#0),\n+            },\n+            Punct {\n+                ch: '=',\n+                spacing: Alone,\n+                span: $DIR/issue-81007-item-attrs.rs:21:5: 21:22 (#0),\n+            },\n+            Literal {\n+                kind: StrRaw(0),\n+                symbol: \" A doc comment\",\n+                suffix: None,\n+                span: $DIR/issue-81007-item-attrs.rs:21:5: 21:22 (#0),\n+            },\n+        ],\n+        span: $DIR/issue-81007-item-attrs.rs:21:5: 21:22 (#0),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/issue-81007-item-attrs.rs:22:5: 22:11 (#0),\n+    },\n+    Ident {\n+        ident: \"Foo\",\n+        span: $DIR/issue-81007-item-attrs.rs:22:12: 22:15 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/issue-81007-item-attrs.rs:22:16: 22:18 (#0),\n+    },\n+]\n+PRINT-ATTR INPUT (DISPLAY): #[rustc_dummy] #[doc = r\" Another comment comment\"] struct Bar { }\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/issue-81007-item-attrs.rs:26:5: 26:6 (#0),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"rustc_dummy\",\n+                span: $DIR/issue-81007-item-attrs.rs:26:7: 26:18 (#0),\n+            },\n+        ],\n+        span: $DIR/issue-81007-item-attrs.rs:26:6: 26:19 (#0),\n+    },\n+    Punct {\n+        ch: '#',\n+        spacing: Alone,\n+        span: $DIR/issue-81007-item-attrs.rs:27:5: 27:32 (#0),\n+    },\n+    Group {\n+        delimiter: Bracket,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"doc\",\n+                span: $DIR/issue-81007-item-attrs.rs:27:5: 27:32 (#0),\n+            },\n+            Punct {\n+                ch: '=',\n+                spacing: Alone,\n+                span: $DIR/issue-81007-item-attrs.rs:27:5: 27:32 (#0),\n+            },\n+            Literal {\n+                kind: StrRaw(0),\n+                symbol: \" Another comment comment\",\n+                suffix: None,\n+                span: $DIR/issue-81007-item-attrs.rs:27:5: 27:32 (#0),\n+            },\n+        ],\n+        span: $DIR/issue-81007-item-attrs.rs:27:5: 27:32 (#0),\n+    },\n+    Ident {\n+        ident: \"struct\",\n+        span: $DIR/issue-81007-item-attrs.rs:28:5: 28:11 (#0),\n+    },\n+    Ident {\n+        ident: \"Bar\",\n+        span: $DIR/issue-81007-item-attrs.rs:28:12: 28:15 (#0),\n+    },\n+    Group {\n+        delimiter: Brace,\n+        stream: TokenStream [],\n+        span: $DIR/issue-81007-item-attrs.rs:28:16: 28:18 (#0),\n+    },\n+]"}, {"sha": "3a754f4991782e128c340f2ca0670cd4f92d9cc2", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11b1e370161dd09c095350c66f7b187fc9654ec6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=11b1e370161dd09c095350c66f7b187fc9654ec6", "patch": "@@ -12,6 +12,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_parse::maybe_new_parser_from_source_str;\n+use rustc_parse::parser::ForceCollect;\n use rustc_session::parse::ParseSess;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::edition::Edition;\n@@ -483,7 +484,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n \n                 let mut relevant_main_found = false;\n                 loop {\n-                    match parser.parse_item() {\n+                    match parser.parse_item(ForceCollect::No) {\n                         Ok(Some(item)) => match &item.kind {\n                             // Tests with one of these items are ignored\n                             ItemKind::Static(..)"}]}