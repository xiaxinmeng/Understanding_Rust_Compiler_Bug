{"sha": "a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZWM4ZTVjYjcwM2E1OTA0ZThlYTk2ZGM0YTdiMmQ5NmFhMjVmNTc=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-12T14:57:19Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-09-18T06:48:39Z"}, "message": "A few cleanups and minor improvements to rustc/traits", "tree": {"sha": "21cee51030feef44f10ec024feef74cb847b5460", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21cee51030feef44f10ec024feef74cb847b5460"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "html_url": "https://github.com/rust-lang/rust/commit/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1aefb48d2ec7ac38a66c964396a5aec729b7a28", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1aefb48d2ec7ac38a66c964396a5aec729b7a28", "html_url": "https://github.com/rust-lang/rust/commit/f1aefb48d2ec7ac38a66c964396a5aec729b7a28"}], "stats": {"total": 880, "additions": 414, "deletions": 466}, "files": [{"sha": "4bed3c5935cd7829ec7111c6a5516cc9e608d018", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -112,17 +112,18 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 orig_params,\n                 trait_pred.to_poly_trait_predicate(),\n             ));\n+\n             match result {\n                 Ok(Some(Vtable::VtableImpl(_))) => {\n                     debug!(\n                         \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n                          manual impl found, bailing out\",\n                         did, trait_did, generics\n                     );\n-                    return true;\n+                    true\n                 }\n-                _ => return false,\n-            };\n+                _ => false\n+            }\n         });\n \n         // If an explicit impl exists, it always takes priority over an auto impl\n@@ -426,6 +427,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     if new_trait.def_id() == old_trait.def_id() {\n                         let new_substs = new_trait.skip_binder().trait_ref.substs;\n                         let old_substs = old_trait.skip_binder().trait_ref.substs;\n+\n                         if !new_substs.types().eq(old_substs.types()) {\n                             // We can't compare lifetimes if the types are different,\n                             // so skip checking old_pred\n@@ -489,12 +491,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n     pub fn get_lifetime(&self, region: Region, names_map: &FxHashMap<String, String>) -> String {\n         self.region_name(region)\n-            .map(|name| {\n-                names_map.get(&name).unwrap_or_else(|| {\n+            .map(|name|\n+                names_map.get(&name).unwrap_or_else(||\n                     panic!(\"Missing lifetime with name {:?} for {:?}\", name, region)\n-                })\n-            })\n-            .unwrap_or(&\"'static\".to_string())\n+                )\n+            )\n+            .unwrap_or(&\"'static\".to_owned())\n             .clone()\n     }\n "}, {"sha": "4e88150a18acc65b60325eefdf85238450b5cbb7", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -39,7 +39,7 @@ pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n     let trait_ref = ty.erase_regions(&trait_ref);\n \n     debug!(\"codegen_fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-            (param_env, trait_ref), trait_ref.def_id());\n+        (param_env, trait_ref), trait_ref.def_id());\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n@@ -48,8 +48,8 @@ pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let obligation_cause = ObligationCause::dummy();\n         let obligation = Obligation::new(obligation_cause,\n-                                            param_env,\n-                                            trait_ref.to_poly_trait_predicate());\n+                                         param_env,\n+                                         trait_ref.to_poly_trait_predicate());\n \n         let selection = match selcx.select(&obligation) {\n             Ok(Some(selection)) => selection,\n@@ -61,12 +61,11 @@ pub fn codegen_fulfill_obligation<'a, 'tcx>(ty: TyCtxt<'a, 'tcx, 'tcx>,\n                 // overflow bug, since I believe this is the only case\n                 // where ambiguity can result.\n                 bug!(\"Encountered ambiguity selecting `{:?}` during codegen, \\\n-                        presuming due to overflow\",\n-                        trait_ref)\n+                      presuming due to overflow\",\n+                      trait_ref)\n             }\n             Err(e) => {\n-                bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\",\n-                            e, trait_ref)\n+                bug!(\"Encountered error `{:?}` selecting `{:?}` during codegen\", e, trait_ref)\n             }\n         };\n \n@@ -163,22 +162,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // In principle, we only need to do this so long as `result`\n         // contains unbound type parameters. It could be a slight\n         // optimization to stop iterating early.\n-        match fulfill_cx.select_all_or_error(self) {\n-            Ok(()) => { }\n-            Err(errors) => {\n-                span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n-                          errors);\n-            }\n+        if let Err(errors) = fulfill_cx.select_all_or_error(self) {\n+            span_bug!(span, \"Encountered errors `{:?}` resolving bounds after type-checking\",\n+                      errors);\n         }\n \n         let result = self.resolve_type_vars_if_possible(result);\n         let result = self.tcx.erase_regions(&result);\n \n-        match self.tcx.lift_to_global(&result) {\n-            Some(result) => result,\n-            None => {\n-                span_bug!(span, \"Uninferred types/regions in `{:?}`\", result);\n-            }\n-        }\n+        self.tcx.lift_to_global(&result).unwrap_or_else(||\n+            span_bug!(span, \"Uninferred types/regions in `{:?}`\", result)\n+        )\n     }\n }"}, {"sha": "251743b0d3bb41a2477cad2f5d8bbbd9e9bee5b7", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -115,9 +115,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                             b_def_id: DefId)\n                             -> Option<OverlapResult<'tcx>>\n {\n-    debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n-           a_def_id,\n-           b_def_id);\n+    debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n \n     // For the purposes of this check, we don't bring any skolemized\n     // types into scope; instead, we replace the generic types with\n@@ -133,10 +131,9 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n \n     // Do `a` and `b` unify? If not, no overlap.\n     let obligations = match selcx.infcx().at(&ObligationCause::dummy(), param_env)\n-                                         .eq_impl_headers(&a_impl_header, &b_impl_header) {\n-        Ok(InferOk { obligations, value: () }) => {\n-            obligations\n-        }\n+                                         .eq_impl_headers(&a_impl_header, &b_impl_header)\n+    {\n+        Ok(InferOk { obligations, value: () }) => obligations,\n         Err(_) => return None\n     };\n \n@@ -164,7 +161,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n         return None\n     }\n \n-    let impl_header =  selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n+    let impl_header = selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes })\n@@ -471,14 +468,12 @@ fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n \n         ty::Dynamic(ref tt, ..) => {\n-            tt.principal().map_or(false, |p| {\n+            tt.principal().map_or(false, |p|\n                 def_id_is_local(p.def_id(), in_crate)\n-            })\n+            )\n         }\n \n-        ty::Error => {\n-            true\n-        }\n+        ty::Error => true,\n \n         ty::Closure(..) |\n         ty::Generator(..) |"}, {"sha": "82d4bfa521f4dd96544594d716e5b74ac5b38525", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 67, "deletions": 78, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -34,6 +34,7 @@ use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n use std::fmt;\n+use std::iter;\n use syntax::ast;\n use session::DiagnosticMessageId;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n@@ -58,7 +59,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             index: Option<usize>, // None if this is an old error\n         }\n \n-        let mut error_map : FxHashMap<_, Vec<_>> =\n+        let mut error_map: FxHashMap<_, Vec<_>> =\n             self.reported_trait_errors.borrow().iter().map(|(&span, predicates)| {\n                 (span, predicates.iter().map(|predicate| ErrorDescriptor {\n                     predicate: predicate.clone(),\n@@ -80,7 +81,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // We do this in 2 passes because we want to display errors in order, tho\n         // maybe it *is* better to sort errors by span or something.\n-        let mut is_suppressed: Vec<bool> = errors.iter().map(|_| false).collect();\n+        let mut is_suppressed = vec![false; errors.len()];\n         for (_, error_set) in error_map.iter() {\n             // We want to suppress \"duplicate\" errors with the same span.\n             for error in error_set {\n@@ -349,7 +350,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 // this is a \"direct\", user-specified, rather than derived,\n                 // obligation.\n-                flags.push((\"direct\".to_string(), None));\n+                flags.push((\"direct\".to_owned(), None));\n             }\n         }\n \n@@ -361,24 +362,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // Currently I'm leaving it for what I need for `try`.\n             if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n                 let method = self.tcx.item_name(item);\n-                flags.push((\"from_method\".to_string(), None));\n-                flags.push((\"from_method\".to_string(), Some(method.to_string())));\n+                flags.push((\"from_method\".to_owned(), None));\n+                flags.push((\"from_method\".to_owned(), Some(method.to_string())));\n             }\n         }\n \n         if let Some(k) = obligation.cause.span.compiler_desugaring_kind() {\n-            flags.push((\"from_desugaring\".to_string(), None));\n-            flags.push((\"from_desugaring\".to_string(), Some(k.name().to_string())));\n+            flags.push((\"from_desugaring\".to_owned(), None));\n+            flags.push((\"from_desugaring\".to_owned(), Some(k.name().to_string())));\n         }\n         let generics = self.tcx.generics_of(def_id);\n         let self_ty = trait_ref.self_ty();\n         // This is also included through the generics list as `Self`,\n         // but the parser won't allow you to use it\n-        flags.push((\"_Self\".to_string(), Some(self_ty.to_string())));\n+        flags.push((\"_Self\".to_owned(), Some(self_ty.to_string())));\n         if let Some(def) = self_ty.ty_adt_def() {\n             // We also want to be able to select self's original\n             // signature with no type arguments resolved\n-            flags.push((\"_Self\".to_string(), Some(self.tcx.type_of(def.did).to_string())));\n+            flags.push((\"_Self\".to_owned(), Some(self.tcx.type_of(def.did).to_string())));\n         }\n \n         for param in generics.params.iter() {\n@@ -393,7 +394,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((\"crate_local\".to_string(), None));\n+            flags.push((\"crate_local\".to_owned(), None));\n         }\n \n         if let Ok(Some(command)) = OnUnimplementedDirective::of_item(\n@@ -412,27 +413,26 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let simp = fast_reject::simplify_type(self.tcx,\n                                               trait_ref.skip_binder().self_ty(),\n                                               true);\n-        let mut impl_candidates = Vec::new();\n+        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n \n         match simp {\n-            Some(simp) => self.tcx.for_each_impl(trait_ref.def_id(), |def_id| {\n+            Some(simp) => all_impls.iter().filter_map(|&def_id| {\n                 let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let imp_simp = fast_reject::simplify_type(self.tcx,\n                                                           imp.self_ty(),\n                                                           true);\n                 if let Some(imp_simp) = imp_simp {\n                     if simp != imp_simp {\n-                        return;\n+                        return None\n                     }\n                 }\n-                impl_candidates.push(imp);\n-            }),\n-            None => self.tcx.for_each_impl(trait_ref.def_id(), |def_id| {\n-                impl_candidates.push(\n-                    self.tcx.impl_trait_ref(def_id).unwrap());\n-            })\n-        };\n-        impl_candidates\n+\n+                Some(imp)\n+            }).collect(),\n+            None => all_impls.iter().map(|&def_id|\n+                self.tcx.impl_trait_ref(def_id).unwrap()\n+            ).collect()\n+        }\n     }\n \n     fn report_similar_impl_candidates(&self,\n@@ -603,10 +603,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             span,\n                             E0277,\n                             \"{}\",\n-                            message.unwrap_or_else(|| {\n+                            message.unwrap_or_else(||\n                                 format!(\"the trait bound `{}` is not satisfied{}\",\n                                          trait_ref.to_predicate(), post_message)\n-                            }));\n+                            ));\n \n                         let explanation =\n                             if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n@@ -645,7 +645,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             //     \"the type `T` can't be frobnicated\"\n                             // which is somewhat confusing.\n                             err.help(&format!(\"consider adding a `where {}` bound\",\n-                                                trait_ref.to_predicate()));\n+                                              trait_ref.to_predicate()));\n                         } else if !have_alt_message {\n                             // Can't show anything else useful, try to find similar impls.\n                             let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n@@ -693,7 +693,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     ty::Predicate::RegionOutlives(ref predicate) => {\n                         let predicate = self.resolve_type_vars_if_possible(predicate);\n                         let err = self.region_outlives_predicate(&obligation.cause,\n-                                                                    &predicate).err().unwrap();\n+                                                                 &predicate).err().unwrap();\n                         struct_span_err!(self.tcx.sess, span, E0279,\n                             \"the requirement `{}` is not satisfied (`{}`)\",\n                             predicate, err)\n@@ -722,7 +722,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess, closure_span, E0525,\n                             \"expected a closure that implements the `{}` trait, \\\n-                                but this closure only implements `{}`\",\n+                             but this closure only implements `{}`\",\n                             kind,\n                             found_kind);\n \n@@ -779,40 +779,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n                 let found_trait_ref = self.resolve_type_vars_if_possible(&*found_trait_ref);\n                 let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n+\n                 if expected_trait_ref.self_ty().references_error() {\n                     return;\n                 }\n+\n                 let found_trait_ty = found_trait_ref.self_ty();\n \n                 let found_did = match found_trait_ty.sty {\n-                    ty::Closure(did, _) |\n-                    ty::Foreign(did) |\n-                    ty::FnDef(did, _) => Some(did),\n+                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n                     ty::Adt(def, _) => Some(def.did),\n                     _ => None,\n                 };\n-                let found_span = found_did.and_then(|did| {\n+\n+                let found_span = found_did.and_then(|did|\n                     self.tcx.hir.span_if_local(did)\n-                }).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+                ).map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n \n                 let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n-                    ty::Tuple(ref tys) => tys.iter()\n-                        .map(|_| ArgKind::empty()).collect::<Vec<_>>(),\n+                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n                     _ => vec![ArgKind::empty()],\n                 };\n+\n                 let expected = match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n                     ty::Tuple(ref tys) => tys.iter()\n-                        .map(|t| match t.sty {\n-                            ty::Tuple(ref tys) => ArgKind::Tuple(\n-                                Some(span),\n-                                tys.iter()\n-                                    .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))\n-                                    .collect::<Vec<_>>()\n-                            ),\n-                            _ => ArgKind::Arg(\"_\".to_owned(), t.sty.to_string()),\n-                        }).collect(),\n+                        .map(|t| ArgKind::from_expected_ty(t, Some(span))).collect(),\n                     ref sty => vec![ArgKind::Arg(\"_\".to_owned(), sty.to_string())],\n                 };\n+\n                 if found.len() == expected.len() {\n                     self.report_closure_arg_mismatch(span,\n                                                      found_span,\n@@ -836,8 +830,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             TraitNotObjectSafe(did) => {\n                 let violations = self.tcx.object_safety_violations(did);\n-                self.tcx.report_object_safety_error(span, did,\n-                                                    violations)\n+                self.tcx.report_object_safety_error(span, did, violations)\n             }\n \n             ConstEvalFailure(ref err) => {\n@@ -981,11 +974,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         .map(|arg| match arg.clone().node {\n                     hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n                         Some(arg.span),\n-                        tys.iter()\n-                            .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n-                            .collect::<Vec<_>>(),\n+                        vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()]\n                     ),\n-                    _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+                    _ => ArgKind::empty()\n                 }).collect::<Vec<ArgKind>>())\n             }\n             Node::Variant(&hir::Variant {\n@@ -997,15 +988,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ..\n             }) => {\n                 (self.tcx.sess.source_map().def_span(span),\n-                 fields.iter().map(|field| {\n+                 fields.iter().map(|field|\n                      ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n-                 }).collect::<Vec<_>>())\n+                 ).collect::<Vec<_>>())\n             }\n             Node::StructCtor(ref variant_data) => {\n                 (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n-                 variant_data.fields()\n-                    .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))\n-                    .collect())\n+                 vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n         }\n@@ -1054,7 +1043,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             found_str,\n         );\n \n-        err.span_label(span, format!( \"expected {} that takes {}\", kind, expected_str));\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n \n         if let Some(found_span) = found_span {\n             err.span_label(found_span, format!(\"takes {}\", found_str));\n@@ -1063,9 +1052,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // found arguments is empty (assume the user just wants to ignore args in this case).\n             // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n             if found_args.is_empty() && is_closure {\n-                let underscores = \"_\".repeat(expected_args.len())\n-                                      .split(\"\")\n-                                      .filter(|s| !s.is_empty())\n+                let underscores = iter::repeat(\"_\")\n+                                      .take(expected_args.len())\n                                       .collect::<Vec<_>>()\n                                       .join(\", \");\n                 err.span_suggestion_with_applicability(\n@@ -1087,7 +1075,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 if fields.len() == expected_args.len() {\n                     let sugg = fields.iter()\n                         .map(|(name, _)| name.to_owned())\n-                        .collect::<Vec<String>>().join(\", \");\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n                     err.span_suggestion_with_applicability(found_span,\n                                                            \"change the closure to take multiple \\\n                                                             arguments instead of a single tuple\",\n@@ -1146,7 +1135,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let inputs = trait_ref.substs.type_at(1);\n             let sig = if let ty::Tuple(inputs) = inputs.sty {\n                 tcx.mk_fn_sig(\n-                    inputs.iter().map(|&x| x),\n+                    inputs.iter().cloned(),\n                     tcx.mk_infer(ty::TyVar(ty::TyVid { index: 0 })),\n                     false,\n                     hir::Unsafety::Normal,\n@@ -1220,10 +1209,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let mut reported_violations = FxHashSet();\n         for violation in violations {\n-            if !reported_violations.insert(violation.clone()) {\n-                continue;\n+            if reported_violations.insert(violation.clone()) {\n+                err.note(&violation.error_msg());\n             }\n-            err.note(&violation.error_msg());\n         }\n         err\n     }\n@@ -1289,10 +1277,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         self.need_type_info_err(body_id, span, self_ty).emit();\n                     } else {\n                         let mut err = struct_span_err!(self.tcx.sess,\n-                                                        span, E0283,\n-                                                        \"type annotations required: \\\n+                                                       span, E0283,\n+                                                       \"type annotations required: \\\n                                                         cannot resolve `{}`\",\n-                                                        predicate);\n+                                                       predicate);\n                         self.note_obligation_cause(&mut err, obligation);\n                         err.emit();\n                     }\n@@ -1438,6 +1426,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n                 let item_name = tcx.item_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n+\n                 if let Some(sp) = tcx.hir.span_if_local(item_def_id) {\n                     let sp = tcx.sess.source_map().def_span(sp);\n                     err.span_note(sp, &msg);\n@@ -1529,9 +1518,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                              parent_trait_ref.skip_binder().self_ty()));\n                 let parent_predicate = parent_trait_ref.to_predicate();\n                 self.note_obligation_cause_code(err,\n-                                            &parent_predicate,\n-                                            &data.parent_code,\n-                                            obligated_types);\n+                                                &parent_predicate,\n+                                                &data.parent_code,\n+                                                obligated_types);\n             }\n             ObligationCauseCode::CompareImplMethodObligation { .. } => {\n                 err.note(\n@@ -1560,21 +1549,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn is_recursive_obligation(&self,\n-                                   obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n-                                   cause_code: &ObligationCauseCode<'tcx>) -> bool {\n+                               obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+                               cause_code: &ObligationCauseCode<'tcx>) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n             let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            for obligated_type in obligated_types {\n-                if obligated_type == &parent_trait_ref.skip_binder().self_ty() {\n-                    return true;\n-                }\n+\n+            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n+                return true;\n             }\n         }\n-        return false;\n+        false\n     }\n }\n \n /// Summarizes information\n+#[derive(Clone)]\n pub enum ArgKind {\n     /// An argument of non-tuple type. Parameters are (name, ty)\n     Arg(String, String),\n@@ -1592,11 +1581,11 @@ impl ArgKind {\n     }\n \n     /// Creates an `ArgKind` from the expected type of an\n-    /// argument. This has no name (`_`) and no source spans..\n-    pub fn from_expected_ty(t: Ty<'_>) -> ArgKind {\n+    /// argument. It has no name (`_`) and an optional source span.\n+    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n         match t.sty {\n             ty::Tuple(ref tys) => ArgKind::Tuple(\n-                None,\n+                span,\n                 tys.iter()\n                    .map(|ty| (\"_\".to_owned(), ty.sty.to_string()))\n                    .collect::<Vec<_>>()"}, {"sha": "707af02acbf4757f4253ee5d34e662ec3b2fd33f", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -526,7 +526,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n         if self.selcx.coinductive_match(cycle.clone().map(|s| s.obligation.predicate)) {\n             debug!(\"process_child_obligations: coinductive match\");\n         } else {\n-            let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n+            let cycle: Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n             self.selcx.infcx().report_overflow_error_cycle(&cycle);\n         }\n     }"}, {"sha": "edf7772f2f78ef76f907275f62fd7700fce9da06", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -661,7 +661,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let predicates: Vec<_> =\n         util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec())\n-        .collect();\n+            .collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\",\n            predicates);\n@@ -707,7 +707,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n-            predicates);\n+               predicates);\n \n         let region_scope_tree = region::ScopeTree::default();\n \n@@ -851,16 +851,16 @@ fn vtable_methods<'a, 'tcx>(\n \n                 // the method may have some early-bound lifetimes, add\n                 // regions for those\n-                let substs = trait_ref.map_bound(|trait_ref| {\n-                    Substs::for_item(tcx, def_id, |param, _| {\n+                let substs = trait_ref.map_bound(|trait_ref|\n+                    Substs::for_item(tcx, def_id, |param, _|\n                         match param.kind {\n                             GenericParamDefKind::Lifetime => tcx.types.re_erased.into(),\n                             GenericParamDefKind::Type {..} => {\n                                 trait_ref.substs[param.index as usize]\n                             }\n                         }\n-                    })\n-                });\n+                    )\n+                );\n \n                 // the trait type may have higher-ranked lifetimes in it;\n                 // so erase them if they appear, so that we get the type"}, {"sha": "0046a23a085e70cf308b1db304f7f6f1997cbba6", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -124,20 +124,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Check methods for violations.\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssociatedKind::Method)\n-            .filter_map(|item| {\n+            .filter_map(|item|\n                 self.object_safety_violation_for_method(trait_def_id, &item)\n                     .map(|code| ObjectSafetyViolation::Method(item.ident.name, code))\n-            }).filter(|violation| {\n+            ).filter(|violation| {\n                 if let ObjectSafetyViolation::Method(_,\n-                                MethodViolationCode::WhereClauseReferencesSelf(span)) = violation {\n-                    // Using`CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n+                    MethodViolationCode::WhereClauseReferencesSelf(span)) = violation\n+                {\n+                    // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n                     // It's also hard to get a use site span, so we use the method definition span.\n                     self.lint_node_note(\n                         lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n                         ast::CRATE_NODE_ID,\n                         *span,\n                         &format!(\"the trait `{}` cannot be made into an object\",\n-                                self.item_path_str(trait_def_id)),\n+                                 self.item_path_str(trait_def_id)),\n                         &violation.error_msg());\n                     false\n                 } else {\n@@ -213,24 +214,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let predicates = self.predicates_of(def_id);\n         let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n-            .any(|predicate| {\n-                match predicate {\n-                    ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                        trait_pred.skip_binder().self_ty().is_self()\n-                    }\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Subtype(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::WellFormed(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n-                    ty::Predicate::ConstEvaluatable(..) => {\n-                        false\n-                    }\n+            .any(|predicate| match predicate {\n+                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                    trait_pred.skip_binder().self_ty().is_self()\n                 }\n-            })\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Subtype(..) |\n+                ty::Predicate::RegionOutlives(..) |\n+                ty::Predicate::WellFormed(..) |\n+                ty::Predicate::ObjectSafe(..) |\n+                ty::Predicate::ClosureKind(..) |\n+                ty::Predicate::TypeOutlives(..) |\n+                ty::Predicate::ConstEvaluatable(..) => {\n+                    false\n+                }\n+            }\n+        )\n     }\n \n     /// Returns `Some(_)` if this method makes the containing trait not object safe."}, {"sha": "f59812c0eea984f4212a3367aa585a35bf9df4c0", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -74,17 +74,17 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         let condition = if is_root {\n             None\n         } else {\n-            let cond = item_iter.next().ok_or_else(|| {\n+            let cond = item_iter.next().ok_or_else(||\n                 parse_error(tcx, span,\n                             \"empty `on`-clause in `#[rustc_on_unimplemented]`\",\n                             \"empty on-clause here\",\n                             None)\n-            })?.meta_item().ok_or_else(|| {\n+            )?.meta_item().ok_or_else(||\n                 parse_error(tcx, span,\n                             \"invalid `on`-clause in `#[rustc_on_unimplemented]`\",\n                             \"invalid on-clause here\",\n                             None)\n-            })?;\n+            )?;\n             attr::eval_condition(cond, &tcx.sess.parse_sess, &mut |_| true);\n             Some(cond.clone())\n         };\n@@ -259,9 +259,9 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                     // `{from_desugaring}` is allowed\n                     Position::ArgumentNamed(s) if s == \"from_desugaring\" => (),\n                     // So is `{A}` if A is a type parameter\n-                    Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n+                    Position::ArgumentNamed(s) => match generics.params.iter().find(|param|\n                         param.name == s\n-                    }) {\n+                    ) {\n                         Some(_) => (),\n                         None => {\n                             span_err!(tcx.sess, span, E0230,\n@@ -304,7 +304,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let empty_string = String::new();\n \n         let parser = Parser::new(&self.0, None);\n-        parser.map(|p| {\n+        parser.map(|p|\n             match p {\n                 Piece::String(s) => s,\n                 Piece::NextArgument(a) => match a.position {\n@@ -326,11 +326,9 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                             }\n                         }\n                     },\n-                    _ => {\n-                        bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0)\n-                    }\n+                    _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0)\n                 }\n             }\n-        }).collect()\n+        ).collect()\n     }\n }"}, {"sha": "5ea936f750e2e24398963263b4b46a649defc494", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -171,7 +171,7 @@ impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n                 match (current, candidate) {\n                     (ParamEnv(..), ParamEnv(..)) => convert_to_ambiguous = (),\n                     (ParamEnv(..), _) => return false,\n-                    (_, ParamEnv(..)) => { unreachable!(); }\n+                    (_, ParamEnv(..)) => unreachable!(),\n                     (_, _) => convert_to_ambiguous = (),\n                 }\n             }\n@@ -419,9 +419,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 normalized_ty\n             }\n \n-            _ => {\n-                ty\n-            }\n+            _ => ty\n         }\n     }\n \n@@ -437,12 +435,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                             instance,\n                             promoted: None\n                         };\n-                        match tcx.const_eval(param_env.and(cid)) {\n-                            Ok(evaluated) => {\n-                                let evaluated = evaluated.subst(self.tcx(), substs);\n-                                return self.fold_const(evaluated);\n-                            }\n-                            Err(_) => {}\n+                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n+                            let evaluated = evaluated.subst(self.tcx(), substs);\n+                            return self.fold_const(evaluated);\n                         }\n                     }\n                 } else {\n@@ -453,9 +448,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                                 instance,\n                                 promoted: None\n                             };\n-                            match tcx.const_eval(param_env.and(cid)) {\n-                                Ok(evaluated) => return self.fold_const(evaluated),\n-                                Err(_) => {}\n+                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n+                                return self.fold_const(evaluated)\n                             }\n                         }\n                     }\n@@ -993,7 +987,7 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n             candidate_set.mark_ambiguous();\n             return;\n         }\n-        _ => { return; }\n+        _ => return\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n@@ -1023,33 +1017,30 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\",\n                predicate);\n-        match predicate {\n-            ty::Predicate::Projection(data) => {\n-                let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n-\n-                let is_match = same_def_id && infcx.probe(|_| {\n-                    let data_poly_trait_ref =\n-                        data.to_poly_trait_ref(infcx.tcx);\n-                    let obligation_poly_trait_ref =\n-                        obligation_trait_ref.to_poly_trait_ref();\n-                    infcx.at(&obligation.cause, obligation.param_env)\n-                         .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n-                         .map(|InferOk { obligations: _, value: () }| {\n-                             // FIXME(#32730) -- do we need to take obligations\n-                             // into account in any way? At the moment, no.\n-                         })\n-                         .is_ok()\n-                });\n-\n-                debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n-                                                             is_match={} same_def_id={}\",\n-                       data, is_match, same_def_id);\n-\n-                if is_match {\n-                    candidate_set.push_candidate(ctor(data));\n-                }\n+        if let ty::Predicate::Projection(data) = predicate {\n+            let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n+\n+            let is_match = same_def_id && infcx.probe(|_| {\n+                let data_poly_trait_ref =\n+                    data.to_poly_trait_ref(infcx.tcx);\n+                let obligation_poly_trait_ref =\n+                    obligation_trait_ref.to_poly_trait_ref();\n+                infcx.at(&obligation.cause, obligation.param_env)\n+                     .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+                     .map(|InferOk { obligations: _, value: () }| {\n+                         // FIXME(#32730) -- do we need to take obligations\n+                         // into account in any way? At the moment, no.\n+                     })\n+                     .is_ok()\n+            });\n+\n+            debug!(\"assemble_candidates_from_predicates: candidate={:?} \\\n+                    is_match={} same_def_id={}\",\n+                   data, is_match, same_def_id);\n+\n+            if is_match {\n+                candidate_set.push_candidate(ctor(data));\n             }\n-            _ => {}\n         }\n     }\n }\n@@ -1072,8 +1063,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 return Err(());\n             }\n             Err(e) => {\n-                debug!(\"assemble_candidates_from_impls: selection error {:?}\",\n-                       e);\n+                debug!(\"assemble_candidates_from_impls: selection error {:?}\", e);\n                 candidate_set.mark_error(e);\n                 return Err(());\n             }\n@@ -1295,11 +1285,11 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n         let mut env_predicates = env_predicates.filter(|data| {\n             let data_poly_trait_ref = data.to_poly_trait_ref(selcx.tcx());\n             let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-            selcx.infcx().probe(|_| {\n+            selcx.infcx().probe(|_|\n                 selcx.infcx().at(&obligation.cause, obligation.param_env)\n                              .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n                              .is_ok()\n-            })\n+            )\n         });\n \n         // select the first matching one; there really ought to be one or\n@@ -1447,7 +1437,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n                                               obligation.predicate.self_ty(),\n                                               fn_sig,\n                                               flag)\n-        .map_bound(|(trait_ref, ret_type)| {\n+        .map_bound(|(trait_ref, ret_type)|\n             ty::ProjectionPredicate {\n                 projection_ty: ty::ProjectionTy::from_ref_and_name(\n                     tcx,\n@@ -1456,7 +1446,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n                 ),\n                 ty: ret_type\n             }\n-        });\n+        );\n \n     confirm_param_env_candidate(selcx, obligation, predicate)\n }"}, {"sha": "f5fb183ec1a5d2d36873515861c93b7a9e9ba677", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -57,22 +57,19 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n         debug!(\"c_ty = {:?}\", c_ty);\n         match &gcx.dropck_outlives(c_ty) {\n             Ok(result) if result.is_proven() => {\n-                match self.infcx.instantiate_query_result_and_region_obligations(\n+                if let Ok(InferOk { value, obligations }) =\n+                    self.infcx.instantiate_query_result_and_region_obligations(\n                     self.cause,\n                     self.param_env,\n                     &orig_values,\n-                    result,\n-                ) {\n-                    Ok(InferOk { value, obligations }) => {\n-                        let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n-                        let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n-                        return InferOk {\n-                            value: kinds,\n-                            obligations,\n-                        };\n-                    }\n-\n-                    Err(_) => { /* fallthrough to error-handling code below */ }\n+                    result)\n+                {\n+                    let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                    let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n+                    return InferOk {\n+                        value: kinds,\n+                        obligations,\n+                    };\n                 }\n             }\n \n@@ -161,12 +158,7 @@ impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n     fn from_iter<I: IntoIterator<Item = DtorckConstraint<'tcx>>>(iter: I) -> Self {\n         let mut result = Self::empty();\n \n-        for DtorckConstraint {\n-            outlives,\n-            dtorck_types,\n-            overflows,\n-        } in iter\n-        {\n+        for DtorckConstraint { outlives, dtorck_types, overflows } in iter {\n             result.outlives.extend(outlives);\n             result.dtorck_types.extend(dtorck_types);\n             result.overflows.extend(overflows);\n@@ -254,7 +246,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n             }\n         }\n \n-        // The following *might* require a destructor: it would deeper inspection to tell.\n+        // The following *might* require a destructor: needs deeper inspection.\n         ty::Dynamic(..)\n         | ty::Projection(..)\n         | ty::Param(_)"}, {"sha": "9b9643aab97d596d1d098e5fd25578297fc16ede", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -48,6 +48,13 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n             value,\n             self.param_env,\n         );\n+        if !value.has_projections() {\n+            return Ok(Normalized {\n+                value: value.clone(),\n+                obligations: vec![],\n+            });\n+        }\n+\n         let mut normalizer = QueryNormalizer {\n             infcx: self.infcx,\n             cause: self.cause,\n@@ -56,12 +63,6 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n             error: false,\n             anon_depth: 0,\n         };\n-        if !value.has_projections() {\n-            return Ok(Normalized {\n-                value: value.clone(),\n-                obligations: vec![],\n-            });\n-        }\n \n         let value1 = value.fold_with(&mut normalizer);\n         if normalizer.error {\n@@ -154,8 +155,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 let gcx = self.infcx.tcx.global_tcx();\n \n                 let mut orig_values = SmallVec::new();\n-                let c_data = self.infcx\n-                    .canonicalize_query(&self.param_env.and(*data), &mut orig_values);\n+                let c_data = self.infcx.canonicalize_query(\n+                    &self.param_env.and(*data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n                 match gcx.normalize_projection_ty(c_data) {\n@@ -170,12 +171,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                             self.cause,\n                             self.param_env,\n                             &orig_values,\n-                            &result,\n-                        ) {\n-                            Ok(InferOk {\n-                                value: result,\n-                                obligations,\n-                            }) => {\n+                            &result)\n+                        {\n+                            Ok(InferOk { value: result, obligations }) => {\n                                 debug!(\"QueryNormalizer: result = {:#?}\", result);\n                                 debug!(\"QueryNormalizer: obligations = {:#?}\", obligations);\n                                 self.obligations.extend(obligations);\n@@ -212,12 +210,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                             instance,\n                             promoted: None,\n                         };\n-                        match tcx.const_eval(param_env.and(cid)) {\n-                            Ok(evaluated) => {\n-                                let evaluated = evaluated.subst(self.tcx(), substs);\n-                                return self.fold_const(evaluated);\n-                            }\n-                            Err(_) => {}\n+                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n+                            let evaluated = evaluated.subst(self.tcx(), substs);\n+                            return self.fold_const(evaluated);\n                         }\n                     }\n                 } else {\n@@ -228,9 +223,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                                 instance,\n                                 promoted: None,\n                             };\n-                            match tcx.const_eval(param_env.and(cid)) {\n-                                Ok(evaluated) => return self.fold_const(evaluated),\n-                                Err(_) => {}\n+                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n+                                return self.fold_const(evaluated)\n                             }\n                         }\n                     }"}, {"sha": "781cfe615a9aa3f9a8ffd6f783cddf76d8230255", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 163, "deletions": 178, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -55,7 +55,6 @@ use rustc_target::spec::abi::Abi;\n use hir;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n-\n pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n@@ -149,7 +148,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n     hashmap: Lock<FxHashMap<ty::TraitRef<'tcx>,\n-                               WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>>>,\n+                            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>>>,\n }\n \n /// The selection process begins by considering all impls, where\n@@ -623,9 +622,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                            obligation: &PredicateObligation<'tcx>)\n                                            -> Result<EvaluationResult, OverflowError>\n     {\n-        self.probe(|this, _| {\n+        self.probe(|this, _|\n             this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n-        })\n+        )\n     }\n \n     /// Evaluates the predicates in `predicates` recursively. Note that\n@@ -717,13 +716,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                             self.infcx.projection_cache.borrow_mut().complete(key);\n                         }\n                         result\n-                    }\n-                    Ok(None) => {\n-                        Ok(EvaluatedToAmbig)\n-                    }\n-                    Err(_) => {\n-                        Ok(EvaluatedToErr)\n-                    }\n+                    },\n+                    Ok(None) => Ok(EvaluatedToAmbig),\n+                    Err(_) => Ok(EvaluatedToErr)\n                 }\n             }\n \n@@ -735,10 +730,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         } else {\n                             Ok(EvaluatedToErr)\n                         }\n-                    }\n-                    None => {\n-                        Ok(EvaluatedToAmbig)\n-                    }\n+                    },\n+                    None => Ok(EvaluatedToAmbig)\n                 }\n             }\n \n@@ -901,13 +894,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // same unbound type variable.\n         if let Some(rec_index) =\n             stack.iter()\n-            .skip(1) // skip top-most frame\n-            .position(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n-                      stack.fresh_trait_ref == prev.fresh_trait_ref)\n+                 .skip(1) // skip top-most frame\n+                 .position(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                                  stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\",\n                    stack.fresh_trait_ref);\n-            let cycle = stack.iter().skip(1).take(rec_index+1);\n+            let cycle = stack.iter().skip(1).take(rec_index + 1);\n             let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\",\n@@ -947,10 +940,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let result = match predicate {\n             ty::Predicate::Trait(ref data) => {\n                 self.tcx().trait_is_auto(data.def_id())\n-            }\n-            _ => {\n-                false\n-            }\n+            },\n+            _ => false\n         };\n         debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n         result\n@@ -1088,9 +1079,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // If no match, compute result and insert into cache.\n-        let (candidate, dep_node) = self.in_task(|this| {\n+        let (candidate, dep_node) = self.in_task(|this|\n             this.candidate_from_obligation_no_cache(stack)\n-        });\n+        );\n \n         debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n                cache_fresh_trait_pred, candidate);\n@@ -1104,9 +1095,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn in_task<OP, R>(&mut self, op: OP) -> (R, DepNodeIndex)\n         where OP: FnOnce(&mut Self) -> R\n     {\n-        let (result, dep_node) = self.tcx().dep_graph.with_anon_task(DepKind::TraitSelect, || {\n+        let (result, dep_node) = self.tcx().dep_graph.with_anon_task(DepKind::TraitSelect, ||\n             op(self)\n-        });\n+        );\n         self.tcx().dep_graph.read_index(dep_node);\n         (result, dep_node)\n     }\n@@ -1138,46 +1129,53 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(None);\n         }\n \n-        match self.is_knowable(stack) {\n-            None => {}\n-            Some(conflict) => {\n-                debug!(\"coherence stage: not knowable\");\n-                if self.intercrate_ambiguity_causes.is_some() {\n-                    debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                    // Heuristics: show the diagnostics when there are no candidates in crate.\n-                    if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                        let no_candidates_apply =\n-                            candidate_set\n-                            .vec\n-                            .iter()\n-                            .map(|c| self.evaluate_candidate(stack, &c))\n-                            .collect::<Result<Vec<_>, OverflowError>>()?\n-                            .iter()\n-                            .all(|r| !r.may_apply());\n-                        if !candidate_set.ambiguous && no_candidates_apply {\n-                            let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                            let self_ty = trait_ref.self_ty();\n-                            let trait_desc = trait_ref.to_string();\n-                            let self_desc = if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            };\n-                            let cause = if let Conflict::Upstream = conflict {\n-                                IntercrateAmbiguityCause::UpstreamCrateUpdate {\n-                                    trait_desc,\n-                                    self_desc,\n-                                }\n-                            } else {\n-                                IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                            };\n-                            debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n-                            self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+        if let Some(conflict) = self.is_knowable(stack) {\n+            debug!(\"coherence stage: not knowable\");\n+            if self.intercrate_ambiguity_causes.is_some() {\n+                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                    let mut no_candidates_apply = true;\n+                    {\n+                        let evaluated_candidates = candidate_set.vec.iter().map(|c|\n+                            self.evaluate_candidate(stack, &c));\n+\n+                        for ec in evaluated_candidates {\n+                            match ec {\n+                                Ok(c) => {\n+                                    if c.may_apply() {\n+                                        no_candidates_apply = false;\n+                                        break\n+                                    }\n+                                },\n+                                Err(e) => return Err(e.into())\n+                            }\n                         }\n                     }\n+\n+                    if !candidate_set.ambiguous && no_candidates_apply {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let trait_desc = trait_ref.to_string();\n+                        let self_desc = if self_ty.has_concrete_skeleton() {\n+                            Some(self_ty.to_string())\n+                        } else {\n+                            None\n+                        };\n+                        let cause = if let Conflict::Upstream = conflict {\n+                            IntercrateAmbiguityCause::UpstreamCrateUpdate {\n+                                trait_desc,\n+                                self_desc,\n+                            }\n+                        } else {\n+                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                        };\n+                        debug!(\"evaluate_stack: pushing cause = {:?}\", cause);\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().push(cause);\n+                    }\n                 }\n-                return Ok(None);\n             }\n+            return Ok(None);\n         }\n \n         let candidate_set = self.assemble_candidates(stack)?;\n@@ -1434,9 +1432,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n-\n         let def_id = obligation.predicate.def_id();\n         let lang_items = self.tcx().lang_items();\n+\n         if lang_items.copy_trait() == Some(def_id) {\n             debug!(\"obligation self ty is {:?}\",\n                    obligation.predicate.skip_binder().self_ty());\n@@ -1495,15 +1493,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::Projection(_) | ty::Opaque(..) => {}\n             ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(obligation.cause.span,\n-                    \"Self=_ should have been handled by assemble_candidates\");\n+                          \"Self=_ should have been handled by assemble_candidates\");\n             }\n             _ => return\n         }\n \n-        let result = self.probe(|this, snapshot| {\n+        let result = self.probe(|this, snapshot|\n             this.match_projection_obligation_against_definition_bounds(obligation,\n                                                                        snapshot)\n-        });\n+        );\n \n         if result {\n             candidates.vec.push(ProjectionCandidate);\n@@ -1533,7 +1531,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 span_bug!(\n                     obligation.cause.span,\n                     \"match_projection_obligation_against_definition_bounds() called \\\n-                     but self-ty not a projection: {:?}\",\n+                     but self-ty is not a projection: {:?}\",\n                     skol_trait_predicate.trait_ref.self_ty());\n             }\n         };\n@@ -1637,14 +1635,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                  -> Result<EvaluationResult, OverflowError>\n     {\n-        self.probe(move |this, _| {\n+        self.probe(move |this, _|\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n                     this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => Ok(EvaluatedToErr)\n             }\n-        })\n+        )\n     }\n \n     fn assemble_generator_candidates(&mut self,\n@@ -1667,15 +1665,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                        obligation);\n \n                 candidates.vec.push(GeneratorCandidate);\n-                Ok(())\n             }\n             ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_generator_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n-                return Ok(());\n             }\n-            _ => { return Ok(()); }\n+            _ => {}\n         }\n+\n+        Ok(())\n     }\n \n     /// Check for the artificial impl that the compiler will create for an obligation like `X :\n@@ -1712,16 +1710,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         debug!(\"assemble_unboxed_candidates: closure_kind not yet known\");\n                         candidates.vec.push(ClosureCandidate);\n                     }\n-                };\n-                Ok(())\n+                }\n             }\n             ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n-                return Ok(());\n             }\n-            _ => { return Ok(()); }\n+            _ => {}\n         }\n+\n+        Ok(())\n     }\n \n     /// Implement one of the `Fn()` family for a fn pointer.\n@@ -1742,7 +1740,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n-\n             // provide an impl, but only for suitable `fn` pointers\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 if let ty::FnSig {\n@@ -1754,8 +1751,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     candidates.vec.push(FnPointerCandidate);\n                 }\n             }\n-\n-            _ => { }\n+            _ => {}\n         }\n \n         Ok(())\n@@ -1773,18 +1769,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.def_id(),\n             obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.probe(|this, snapshot| { /* [1] */\n-                    match this.match_impl(impl_def_id, obligation, snapshot) {\n-                        Ok(skol_map) => {\n-                            candidates.vec.push(ImplCandidate(impl_def_id));\n-\n-                            // NB: we can safely drop the skol map\n-                            // since we are in a probe [1]\n-                            mem::drop(skol_map);\n-                        }\n-                        Err(_) => { }\n+                self.probe(|this, snapshot| /* [1] */\n+                    if let Ok(skol_map) = this.match_impl(impl_def_id, obligation, snapshot) {\n+                        candidates.vec.push(ImplCandidate(impl_def_id));\n+\n+                        // NB: we can safely drop the skol map\n+                        // since we are in a probe [1]\n+                        mem::drop(skol_map);\n                     }\n-                });\n+                );\n             }\n         );\n \n@@ -1874,7 +1867,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n                         debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                                    pushing candidate\");\n+                                pushing candidate\");\n                         candidates.vec.push(BuiltinObjectCandidate);\n                         return;\n                     }\n@@ -1889,9 +1882,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     candidates.ambiguous = true; // could wind up being an object type\n                     return;\n                 }\n-                _ => {\n-                    return;\n-                }\n+                _ => return\n             };\n \n             debug!(\"assemble_candidates_from_object_ty: poly_trait_ref={:?}\",\n@@ -1904,12 +1895,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // but `Foo` is declared as `trait Foo : Bar<u32>`.\n             let upcast_trait_refs =\n                 util::supertraits(this.tcx(), poly_trait_ref)\n-                .filter(|upcast_trait_ref| {\n+                .filter(|upcast_trait_ref|\n                     this.probe(|this, _| {\n                         let upcast_trait_ref = upcast_trait_ref.clone();\n                         this.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n                     })\n-                })\n+                )\n                 .count();\n \n             if upcast_trait_refs > 1 {\n@@ -2028,27 +2019,26 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         other: &EvaluatedCandidate<'tcx>)\n         -> bool\n     {\n+        if victim.candidate == other.candidate {\n+            return true;\n+        }\n+\n         // Check if a bound would previously have been removed when normalizing\n         // the param_env so that it can be given the lowest priority. See\n         // #50825 for the motivation for this.\n         let is_global = |cand: &ty::PolyTraitRef<'_>| {\n             cand.is_global() && !cand.has_late_bound_regions()\n         };\n \n-        if victim.candidate == other.candidate {\n-            return true;\n-        }\n-\n         match other.candidate {\n             // Prefer BuiltinCandidate { has_nested: false } to anything else.\n             // This is a fix for #53123 and prevents winnowing from accidentally extending the\n             // lifetime of a variable.\n             BuiltinCandidate { has_nested: false } => true,\n             ParamCandidate(ref cand) => match victim.candidate {\n                 AutoImplCandidate(..) => {\n-                    bug!(\n-                        \"default implementations shouldn't be recorded \\\n-                         when there are other valid candidates\");\n+                    bug!(\"default implementations shouldn't be recorded \\\n+                          when there are other valid candidates\");\n                 }\n                 // Prefer BuiltinCandidate { has_nested: false } to anything else.\n                 // This is a fix for #53123 and prevents winnowing from accidentally extending the\n@@ -2077,9 +2067,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ObjectCandidate |\n             ProjectionCandidate => match victim.candidate {\n                 AutoImplCandidate(..) => {\n-                    bug!(\n-                        \"default implementations shouldn't be recorded \\\n-                         when there are other valid candidates\");\n+                    bug!(\"default implementations shouldn't be recorded \\\n+                          when there are other valid candidates\");\n                 }\n                 // Prefer BuiltinCandidate { has_nested: false } to anything else.\n                 // This is a fix for #53123 and prevents winnowing from accidentally extending the\n@@ -2151,26 +2140,28 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn assemble_builtin_bound_candidates<'o>(&mut self,\n                                              conditions: BuiltinImplConditions<'tcx>,\n                                              candidates: &mut SelectionCandidateSet<'tcx>)\n-                                             -> Result<(),SelectionError<'tcx>>\n+                                             -> Result<(), SelectionError<'tcx>>\n     {\n         match conditions {\n             BuiltinImplConditions::Where(nested) => {\n                 debug!(\"builtin_bound: nested={:?}\", nested);\n                 candidates.vec.push(BuiltinCandidate {\n                     has_nested: nested.skip_binder().len() > 0\n                 });\n-                Ok(())\n             }\n-            BuiltinImplConditions::None => { Ok(()) }\n+            BuiltinImplConditions::None => {}\n             BuiltinImplConditions::Ambiguous => {\n                 debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n-                Ok(candidates.ambiguous = true)\n+                candidates.ambiguous = true;\n             }\n         }\n+\n+        Ok(())\n     }\n \n-    fn sized_conditions(&mut self, obligation: &TraitObligation<'tcx>)\n-                     -> BuiltinImplConditions<'tcx>\n+    fn sized_conditions(&mut self,\n+                        obligation: &TraitObligation<'tcx>)\n+                        -> BuiltinImplConditions<'tcx>\n     {\n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n@@ -2216,8 +2207,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn copy_clone_conditions(&mut self, obligation: &TraitObligation<'tcx>)\n-                     -> BuiltinImplConditions<'tcx>\n+    fn copy_clone_conditions(&mut self,\n+                             obligation: &TraitObligation<'tcx>)\n+                             -> BuiltinImplConditions<'tcx>\n     {\n         // NOTE: binder moved to (*)\n         let self_ty = self.infcx.shallow_resolve(\n@@ -2551,17 +2543,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let lang_items = self.tcx().lang_items();\n         let obligations = if has_nested {\n             let trait_def = obligation.predicate.def_id();\n-            let conditions = match trait_def {\n-                _ if Some(trait_def) == lang_items.sized_trait() => {\n+            let conditions =\n+                if Some(trait_def) == lang_items.sized_trait() {\n                     self.sized_conditions(obligation)\n-                }\n-                _ if Some(trait_def) == lang_items.copy_trait() => {\n+                } else if Some(trait_def) == lang_items.copy_trait() {\n                     self.copy_clone_conditions(obligation)\n-                }\n-                _ if Some(trait_def) == lang_items.clone_trait() => {\n+                } else if Some(trait_def) == lang_items.clone_trait() {\n                     self.copy_clone_conditions(obligation)\n-                }\n-                _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n+                } else {\n+                    bug!(\"unexpected builtin trait {:?}\", trait_def)\n             };\n             let nested = match conditions {\n                 BuiltinImplConditions::Where(nested) => nested,\n@@ -2608,10 +2598,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     /// See `confirm_auto_impl_candidate`\n     fn vtable_auto_impl(&mut self,\n-                           obligation: &TraitObligation<'tcx>,\n-                           trait_def_id: DefId,\n-                           nested: ty::Binder<Vec<Ty<'tcx>>>)\n-                           -> VtableAutoImplData<PredicateObligation<'tcx>>\n+                        obligation: &TraitObligation<'tcx>,\n+                        trait_def_id: DefId,\n+                        nested: ty::Binder<Vec<Ty<'tcx>>>)\n+                        -> VtableAutoImplData<PredicateObligation<'tcx>>\n     {\n         debug!(\"vtable_auto_impl: nested={:?}\", nested);\n \n@@ -2731,10 +2721,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::Dynamic(ref data, ..) => {\n                 data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n             }\n-            _ => {\n-                span_bug!(obligation.cause.span,\n-                          \"object candidate with non-object\");\n-            }\n+            _ => span_bug!(obligation.cause.span,\n+                           \"object candidate with non-object\")\n         };\n \n         let mut upcast_trait_ref = None;\n@@ -2752,10 +2740,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // record it for later.)\n             let nonmatching =\n                 util::supertraits(tcx, poly_trait_ref)\n-                .take_while(|&t| {\n-                    match\n-                        self.commit_if_ok(\n-                            |this, _| this.match_poly_trait_ref(obligation, t))\n+                .take_while(|&t|\n+                    match self.commit_if_ok(|this, _|\n+                        this.match_poly_trait_ref(obligation, t))\n                     {\n                         Ok(obligations) => {\n                             upcast_trait_ref = Some(t);\n@@ -2764,16 +2751,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         }\n                         Err(_) => { true }\n                     }\n-                });\n+                );\n \n             // Additionally, for each of the nonmatching predicates that\n             // we pass over, we sum up the set of number of vtable\n             // entries, so that we can compute the offset for the selected\n             // trait.\n-            vtable_base =\n-                nonmatching.map(|t| tcx.count_own_vtable_entries(t))\n-                           .sum();\n-\n+            vtable_base = nonmatching.map(|t| tcx.count_own_vtable_entries(t)).sum();\n         }\n \n         VtableObjectData {\n@@ -2816,7 +2800,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn confirm_generator_candidate(&mut self,\n                                    obligation: &TraitObligation<'tcx>)\n                                    -> Result<VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n-                                           SelectionError<'tcx>>\n+                                             SelectionError<'tcx>>\n     {\n         // ok to skip binder because the substs on generator types never\n         // touch bound regions, they just capture the in-scope\n@@ -2869,10 +2853,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"confirm_closure_candidate({:?})\", obligation);\n \n-        let kind = match self.tcx().lang_items().fn_trait_kind(obligation.predicate.def_id()) {\n-            Some(k) => k,\n-            None => bug!(\"closure candidate for non-fn trait {:?}\", obligation)\n-        };\n+        let kind = self.tcx()\n+                       .lang_items()\n+                       .fn_trait_kind(obligation.predicate.def_id())\n+                       .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\",\n+                                               obligation));\n \n         // ok to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n@@ -2901,9 +2886,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         obligations.extend(\n             self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                        obligation.param_env,\n-                                        obligation.predicate.to_poly_trait_ref(),\n-                                        trait_ref)?);\n+                                         obligation.param_env,\n+                                         obligation.predicate.to_poly_trait_ref(),\n+                                         trait_ref)?);\n \n         obligations.push(Obligation::new(\n             obligation.cause.clone(),\n@@ -3008,20 +2993,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (_, &ty::Dynamic(ref data, r)) => {\n                 let mut object_dids =\n                     data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n-                if let Some(did) = object_dids.find(|did| {\n-                    !tcx.is_object_safe(*did)\n-                }) {\n+                if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n                     return Err(TraitNotObjectSafe(did))\n                 }\n \n                 let cause = ObligationCause::new(obligation.cause.span,\n                                                  obligation.cause.body_id,\n                                                  ObjectCastObligation(target));\n-                let mut push = |predicate| {\n-                    nested.push(Obligation::with_depth(cause.clone(),\n-                                                       obligation.recursion_depth + 1,\n-                                                       obligation.param_env,\n-                                                       predicate));\n+\n+                let predicate_to_obligation = |predicate| {\n+                    Obligation::with_depth(cause.clone(),\n+                                           obligation.recursion_depth + 1,\n+                                           obligation.param_env,\n+                                           predicate)\n                 };\n \n                 // Create obligations:\n@@ -3030,21 +3014,22 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 //  words, if the object type is Foo+Send, this would create an obligation for the\n                 //  Send check.)\n                 //  - Projection predicates\n-                for predicate in data.iter() {\n-                    push(predicate.with_self_ty(tcx, source));\n-                }\n+                nested.extend(data.iter().map(|d|\n+                    predicate_to_obligation(d.with_self_ty(tcx, source))\n+                ));\n \n                 // We can only make objects from sized types.\n                 let tr = ty::TraitRef {\n                     def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem),\n                     substs: tcx.mk_substs_trait(source, &[]),\n                 };\n-                push(tr.to_predicate());\n+                nested.push(predicate_to_obligation(tr.to_predicate()));\n \n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n                 let outlives = ty::OutlivesPredicate(source, r);\n-                push(ty::Binder::dummy(outlives).to_predicate());\n+                nested.push(predicate_to_obligation(\n+                    ty::Binder::dummy(outlives).to_predicate()));\n             }\n \n             // [T; n] -> [T].\n@@ -3105,13 +3090,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source struct with the target's\n                 // unsized parameters is equal to the target.\n-                let params = substs_a.iter().enumerate().map(|(i, &k)| {\n+                let params = substs_a.iter().enumerate().map(|(i, &k)|\n                     if ty_params.contains(i) {\n                         substs_b.type_at(i).into()\n                     } else {\n                         k\n                     }\n-                });\n+                );\n                 let new_struct = tcx.mk_adt(def, tcx.mk_substs(params));\n                 let InferOk { obligations, .. } =\n                     self.infcx.at(&obligation.cause, obligation.param_env)\n@@ -3236,10 +3221,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let InferOk { obligations, .. } =\n             self.infcx.at(&obligation.cause, obligation.param_env)\n                       .eq(skol_obligation_trait_ref, impl_trait_ref)\n-                      .map_err(|e| {\n-                          debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n-                          ()\n-                      })?;\n+                      .map_err(|e|\n+                          debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e)\n+                      )?;\n         nested_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false,\n@@ -3288,7 +3272,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_where_clause_trait_ref(&mut self,\n                                     obligation: &TraitObligation<'tcx>,\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Result<Vec<PredicateObligation<'tcx>>,()>\n+                                    -> Result<Vec<PredicateObligation<'tcx>>, ()>\n     {\n         self.match_poly_trait_ref(obligation, where_clause_trait_ref)\n     }\n@@ -3298,7 +3282,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n-                            -> Result<Vec<PredicateObligation<'tcx>>,()>\n+                            -> Result<Vec<PredicateObligation<'tcx>>, ()>\n     {\n         debug!(\"match_poly_trait_ref: obligation={:?} poly_trait_ref={:?}\",\n                obligation,\n@@ -3350,20 +3334,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // in fact unparameterized (or at least does not reference any\n         // regions bound in the obligation). Still probably some\n         // refactoring could make this nicer.\n-\n         self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n                                                      obligation.predicate\n-                                                         .skip_binder().self_ty(), // (1)\n+                                                               .skip_binder()\n+                                                               .self_ty(), // (1)\n                                                      closure_type,\n                                                      util::TupleArgumentsFlag::No)\n             .map_bound(|(trait_ref, _)| trait_ref)\n     }\n \n     fn generator_trait_ref_unnormalized(&mut self,\n-                                      obligation: &TraitObligation<'tcx>,\n-                                      closure_def_id: DefId,\n-                                      substs: ty::GeneratorSubsts<'tcx>)\n-                                      -> ty::PolyTraitRef<'tcx>\n+                                        obligation: &TraitObligation<'tcx>,\n+                                        closure_def_id: DefId,\n+                                        substs: ty::GeneratorSubsts<'tcx>)\n+                                        -> ty::PolyTraitRef<'tcx>\n     {\n         let gen_sig = substs.poly_sig(closure_def_id, self.tcx());\n \n@@ -3375,7 +3359,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         self.tcx().generator_trait_ref_and_outputs(obligation.predicate.def_id(),\n                                                    obligation.predicate\n-                                                       .skip_binder().self_ty(), // (1)\n+                                                             .skip_binder()\n+                                                             .self_ty(), // (1)\n                                                    gen_sig)\n             .map_bound(|(trait_ref, ..)| trait_ref)\n     }\n@@ -3453,8 +3438,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n impl<'tcx> TraitObligation<'tcx> {\n     #[allow(unused_comparisons)]\n     pub fn derived_cause(&self,\n-                        variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n-                        -> ObligationCause<'tcx>\n+                         variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n+                         -> ObligationCause<'tcx>\n     {\n         /*!\n          * Creates a cause for obligations that are derived from"}, {"sha": "dbd84397b597d37542a038d9ff1675a9f98b2863", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -100,10 +100,10 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n             }\n \n             fulfill_implication(infcx, param_env, source_trait_ref, target_impl)\n-                .unwrap_or_else(|_| {\n+                .unwrap_or_else(|_|\n                     bug!(\"When translating substitutions for specialization, the expected \\\n                           specialization failed to hold\")\n-                })\n+                )\n         }\n         specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n     };\n@@ -137,17 +137,15 @@ pub fn find_associated_item<'a, 'tcx>(\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);\n                 let substs = infcx.tcx.erase_regions(&substs);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n+                tcx.lift(&substs).unwrap_or_else(||\n                     bug!(\"find_method: translate_substs \\\n                           returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n+                         substs)\n+                )\n             });\n             (node_item.item.def_id, substs)\n         }\n-        None => {\n-            bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id)\n-        }\n+        None => bug!(\"{:?} not found in {:?}\", item, impl_data.impl_def_id)\n     }\n }\n \n@@ -312,8 +310,7 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                                                       -> Lrc<specialization_graph::Graph> {\n     let mut sg = specialization_graph::Graph::new();\n \n-    let mut trait_impls = Vec::new();\n-    tcx.for_each_impl(trait_id, |impl_did| trait_impls.push(impl_did));\n+    let mut trait_impls = tcx.all_impls(trait_id);\n \n     // The coherence checking implementation seems to rely on impls being\n     // iterated over (roughly) in definition order, so we are sorting by\n@@ -367,9 +364,9 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                                        \"first implementation here\".to_string());\n                         err.span_label(impl_span,\n                                        format!(\"conflicting implementation{}\",\n-                                                overlap.self_desc\n-                                                    .map_or(String::new(),\n-                                                            |ty| format!(\" for `{}`\", ty))));\n+                                               overlap.self_desc\n+                                                      .map_or(String::new(),\n+                                                          |ty| format!(\" for `{}`\", ty))));\n                     }\n                     Err(cname) => {\n                         let msg = match to_pretty_impl_header(tcx, overlap.with_impl) {\n@@ -428,7 +425,9 @@ fn to_pretty_impl_header(tcx: TyCtxt, impl_def_id: DefId) -> Option<String> {\n     // The predicates will contain default bounds like `T: Sized`. We need to\n     // remove these bounds, and add `T: ?Sized` to any untouched type parameters.\n     let predicates = tcx.predicates_of(impl_def_id).predicates;\n-    let mut pretty_predicates = Vec::with_capacity(predicates.len());\n+    let mut pretty_predicates = Vec::with_capacity(\n+        predicates.len() + types_without_default_bounds.len());\n+\n     for p in predicates {\n         if let Some(poly_trait_ref) = p.to_opt_poly_trait_ref() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n@@ -438,9 +437,11 @@ fn to_pretty_impl_header(tcx: TyCtxt, impl_def_id: DefId) -> Option<String> {\n         }\n         pretty_predicates.push(p.to_string());\n     }\n+\n     pretty_predicates.extend(\n         types_without_default_bounds.iter().map(|ty| format!(\"{}: ?Sized\", ty))\n     );\n+\n     if !pretty_predicates.is_empty() {\n         write!(w, \"\\n  where {}\", pretty_predicates.join(\", \")).unwrap();\n     }"}, {"sha": "756f55545bc45a87090a52085df7588197cbf1a8", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -390,11 +390,12 @@ impl Iterator for Ancestors {\n         let cur = self.current_source.take();\n         if let Some(Node::Impl(cur_impl)) = cur {\n             let parent = self.specialization_graph.parent(cur_impl);\n-            if parent == self.trait_def_id {\n-                self.current_source = Some(Node::Trait(parent));\n+\n+            self.current_source = if parent == self.trait_def_id {\n+                Some(Node::Trait(parent))\n             } else {\n-                self.current_source = Some(Node::Impl(parent));\n-            }\n+                Some(Node::Impl(parent))\n+            };\n         }\n         cur\n     }"}, {"sha": "a4230707b70cae5b449760c5812d58bdc5195111", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -166,10 +166,10 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n         match *self {\n             super::Unimplemented => Some(super::Unimplemented),\n             super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)| {\n+                tcx.lift(&(a, b)).and_then(|(a, b)|\n                     tcx.lift(err)\n                         .map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                })\n+                )\n             }\n             super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n             super::ConstEvalFailure(ref err) => tcx.lift(&**err).map(|err| super::ConstEvalFailure(\n@@ -193,10 +193,10 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ReferenceOutlivesReferent(ty) => {\n                 tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n             }\n-            super::ObjectTypeBound(ty, r) => tcx.lift(&ty).and_then(|ty| {\n+            super::ObjectTypeBound(ty, r) => tcx.lift(&ty).and_then(|ty|\n                 tcx.lift(&r)\n-                    .and_then(|r| Some(super::ObjectTypeBound(ty, r)))\n-            }),\n+                   .and_then(|r| Some(super::ObjectTypeBound(ty, r)))\n+            ),\n             super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n             super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n             super::TupleInitializerSized => Some(super::TupleInitializerSized),\n@@ -245,13 +245,13 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n+        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref|\n             tcx.lift(&*self.parent_code)\n-                .map(|code| traits::DerivedObligationCause {\n-                    parent_trait_ref: trait_ref,\n-                    parent_code: Rc::new(code),\n-                })\n-        })\n+               .map(|code| traits::DerivedObligationCause {\n+                   parent_trait_ref: trait_ref,\n+                   parent_code: Rc::new(code),\n+               })\n+        )\n     }\n }\n \n@@ -275,54 +275,54 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                 impl_def_id,\n                 substs,\n                 nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n+            }) => tcx.lift(&substs).map(|substs|\n                 traits::VtableImpl(traits::VtableImplData {\n                     impl_def_id,\n                     substs,\n                     nested,\n                 })\n-            }),\n+            ),\n             traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n             traits::VtableGenerator(traits::VtableGeneratorData {\n                 generator_def_id,\n                 substs,\n                 nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n+            }) => tcx.lift(&substs).map(|substs|\n                 traits::VtableGenerator(traits::VtableGeneratorData {\n                     generator_def_id: generator_def_id,\n                     substs: substs,\n                     nested: nested,\n                 })\n-            }),\n+            ),\n             traits::VtableClosure(traits::VtableClosureData {\n                 closure_def_id,\n                 substs,\n                 nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n+            }) => tcx.lift(&substs).map(|substs|\n                 traits::VtableClosure(traits::VtableClosureData {\n                     closure_def_id,\n                     substs,\n                     nested,\n                 })\n-            }),\n+            ),\n             traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty| {\n+                tcx.lift(&fn_ty).map(|fn_ty|\n                     traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n-                })\n+                )\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n             traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n                 vtable_base,\n                 nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref|\n                 traits::VtableObject(traits::VtableObjectData {\n                     upcast_trait_ref: trait_ref,\n                     vtable_base,\n                     nested,\n                 })\n-            }),\n+            ),\n         }\n     }\n }"}, {"sha": "2ca8214daf768cd829550a99e5184a63f4c46a7f", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -346,8 +346,7 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n                 Some(ty::Predicate::Trait(data)) => {\n                     return Some(data.to_poly_trait_ref());\n                 }\n-                Some(_) => {\n-                }\n+                Some(_) => {}\n             }\n         }\n     }"}, {"sha": "fd3f7a12376d8440724f85d2e21c0b9fbfe0ca8a", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -138,6 +138,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n     }\n+\n+    /// Return a vector containing all impls\n+    pub fn all_impls(self, def_id: DefId) -> Vec<DefId> {\n+        let impls = self.trait_impls_of(def_id);\n+\n+        impls.blanket_impls.iter().chain(\n+            impls.non_blanket_impls.values().flatten()\n+        ).cloned().collect()\n+    }\n }\n \n // Query provider for `trait_impls_of`."}, {"sha": "f2c20238734e63b2f54ff89be711a240e8679c06", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a8ec8e5cb703a5904e8ea96dc4a7b2d96aa25f57", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .sig\n             .inputs()\n             .iter()\n-            .map(|ty| ArgKind::from_expected_ty(ty))\n+            .map(|ty| ArgKind::from_expected_ty(ty, None))\n             .collect();\n         let (closure_span, found_args) = self.get_fn_like_arguments(expr_map_node);\n         let expected_span = expected_sig.cause_span.unwrap_or(closure_span);"}]}