{"sha": "6580010551063718462f9dfe41c9490d92994d0e", "node_id": "C_kwDOAAsO6NoAKDY1ODAwMTA1NTEwNjM3MTg0NjJmOWRmZTQxYzk0OTBkOTI5OTRkMGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-24T14:37:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-24T14:37:01Z"}, "message": "Auto merge of #102234 - matthiaskrgr:rollup-5cb20l1, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #100823 (Refactor some `std` code that works with pointer offstes)\n - #102088 (Fix wrongly refactored Lift impl)\n - #102109 (resolve: Set effective visibilities for imports more precisely)\n - #102186 (Add const_closure, Constify Try trait)\n - #102203 (rustdoc: remove no-op CSS `#source-sidebar { z-index }`)\n - #102204 (Make `ManuallyDrop` satisfy `~const Destruct`)\n - #102210 (diagnostics: avoid syntactically invalid suggestion in if conditionals)\n - #102226 (bootstrap/miri: switch to non-deprecated env var for setting the sysroot folder)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f5f3e22a1046b32ed8bc4af2d06a70182d524b35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5f3e22a1046b32ed8bc4af2d06a70182d524b35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6580010551063718462f9dfe41c9490d92994d0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6580010551063718462f9dfe41c9490d92994d0e", "html_url": "https://github.com/rust-lang/rust/commit/6580010551063718462f9dfe41c9490d92994d0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6580010551063718462f9dfe41c9490d92994d0e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdb76db493fa5e0382b18ecd9f8da7ef00ceb951", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb76db493fa5e0382b18ecd9f8da7ef00ceb951", "html_url": "https://github.com/rust-lang/rust/commit/cdb76db493fa5e0382b18ecd9f8da7ef00ceb951"}, {"sha": "6900638c532b2b009cbec3d2aef98541fa7e15f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6900638c532b2b009cbec3d2aef98541fa7e15f6", "html_url": "https://github.com/rust-lang/rust/commit/6900638c532b2b009cbec3d2aef98541fa7e15f6"}], "stats": {"total": 412, "additions": 310, "deletions": 102}, "files": [{"sha": "1164cf3e01aa09e5b925c0300ba64b415a03c60e", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -272,7 +272,10 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C)\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self?).map(Some)\n+        Some(match self {\n+            Some(x) => Some(tcx.lift(x)?),\n+            None => None,\n+        })\n     }\n }\n "}, {"sha": "d806441716fdabd860a841e2b02d6962301320d5", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -1,4 +1,3 @@\n-use crate::imports::ImportKind;\n use crate::NameBinding;\n use crate::NameBindingKind;\n use crate::Resolver;\n@@ -54,15 +53,11 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n         // sets the rest of the `use` chain to `AccessLevel::Exported` until\n         // we hit the actual exported item.\n         let set_import_binding_access_level =\n-            |this: &mut Self, mut binding: &NameBinding<'a>, mut access_level| {\n+            |this: &mut Self, mut binding: &NameBinding<'a>, mut access_level, ns| {\n                 while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                     binding.kind\n                 {\n-                    this.set_access_level(import.id, access_level);\n-                    if let ImportKind::Single { additional_ids, .. } = import.kind {\n-                        this.set_access_level(additional_ids.0, access_level);\n-                        this.set_access_level(additional_ids.1, access_level);\n-                    }\n+                    this.set_access_level(this.r.import_id_for_ns(import, ns), access_level);\n \n                     access_level = Some(AccessLevel::Exported);\n                     binding = nested_binding;\n@@ -72,11 +67,11 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n         let module = self.r.get_module(module_id.to_def_id()).unwrap();\n         let resolutions = self.r.resolutions(module);\n \n-        for (.., name_resolution) in resolutions.borrow().iter() {\n+        for (key, name_resolution) in resolutions.borrow().iter() {\n             if let Some(binding) = name_resolution.borrow().binding() && binding.vis.is_public() && !binding.is_ambiguity() {\n                 let access_level = match binding.is_import() {\n                     true => {\n-                        set_import_binding_access_level(self, binding, module_level);\n+                        set_import_binding_access_level(self, binding, module_level, key.ns);\n                         Some(AccessLevel::Exported)\n                     },\n                     false => module_level,"}, {"sha": "5bdb4274781994f3228b26e73262e6b00d259950", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -2,7 +2,7 @@\n \n use crate::diagnostics::Suggestion;\n use crate::Determinacy::{self, *};\n-use crate::Namespace::{MacroNS, TypeNS};\n+use crate::Namespace::{self, *};\n use crate::{module_to_string, names_to_string};\n use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n@@ -371,6 +371,31 @@ impl<'a> Resolver<'a> {\n             self.used_imports.insert(import.id);\n         }\n     }\n+\n+    /// Take primary and additional node IDs from an import and select one that corresponds to the\n+    /// given namespace. The logic must match the corresponding logic from `fn lower_use_tree` that\n+    /// assigns resolutons to IDs.\n+    pub(crate) fn import_id_for_ns(&self, import: &Import<'_>, ns: Namespace) -> NodeId {\n+        if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n+            if let Some(resolutions) = self.import_res_map.get(&import.id) {\n+                assert!(resolutions[ns].is_some(), \"incorrectly finalized import\");\n+                return match ns {\n+                    TypeNS => import.id,\n+                    ValueNS => match resolutions.type_ns {\n+                        Some(_) => id1,\n+                        None => import.id,\n+                    },\n+                    MacroNS => match (resolutions.type_ns, resolutions.value_ns) {\n+                        (Some(_), Some(_)) => id2,\n+                        (Some(_), None) | (None, Some(_)) => id1,\n+                        (None, None) => import.id,\n+                    },\n+                };\n+            }\n+        }\n+\n+        import.id\n+    }\n }\n \n /// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved"}, {"sha": "27fbfb6dd21fb84a30964c94c75940a647833ad0", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -1224,6 +1224,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | ty::Never\n                 | ty::Foreign(_) => {}\n \n+                // `ManuallyDrop` is trivially drop\n+                ty::Adt(def, _) if Some(def.did()) == tcx.lang_items().manually_drop() => {}\n+\n                 // These types are built-in, so we can fast-track by registering\n                 // nested predicates for their constituent type(s)\n                 ty::Array(ty, _) | ty::Slice(ty) => {"}, {"sha": "2c07c333a6f98a8dea0b5fcb15d940e2037482fd", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -417,6 +417,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     hir::def::CtorKind::Const => unreachable!(),\n                 };\n \n+                // Suggest constructor as deep into the block tree as possible.\n+                // This fixes https://github.com/rust-lang/rust/issues/101065,\n+                // and also just helps make the most minimal suggestions.\n+                let mut expr = expr;\n+                while let hir::ExprKind::Block(block, _) = &expr.kind\n+                    && let Some(expr_) = &block.expr\n+                {\n+                    expr = expr_\n+                }\n+\n                 vec![\n                     (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}{open}\")),\n                     (expr.span.shrink_to_hi(), close.to_owned()),"}, {"sha": "d2e80e8e7e5dfaf446ec1a0f3ce0981bfbb16e32", "filename": "library/core/src/const_closure.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fconst_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fconst_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconst_closure.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -0,0 +1,63 @@\n+use crate::marker::Destruct;\n+\n+/// Struct representing a closure with mutably borrowed data.\n+///\n+/// Example:\n+/// ```no_build\n+/// #![feature(const_mut_refs)]\n+/// use crate::const_closure::ConstFnMutClosure;\n+/// const fn imp(state: &mut i32, (arg,): (i32,)) -> i32 {\n+///   *state += arg;\n+///   *state\n+/// }\n+/// let mut i = 5;\n+/// let mut cl = ConstFnMutClosure::new(&mut i, imp);\n+///\n+/// assert!(7 == cl(2));\n+/// assert!(8 == cl(1));\n+/// ```\n+pub(crate) struct ConstFnMutClosure<'a, CapturedData: ?Sized, Function> {\n+    data: &'a mut CapturedData,\n+    func: Function,\n+}\n+\n+impl<'a, CapturedData: ?Sized, Function> ConstFnMutClosure<'a, CapturedData, Function> {\n+    /// Function for creating a new closure.\n+    ///\n+    /// `data` is the a mutable borrow of data that is captured from the environment.\n+    ///\n+    /// `func` is the function of the closure, it gets the data and a tuple of the arguments closure\n+    ///   and return the return value of the closure.\n+    pub(crate) const fn new<ClosureArguments, ClosureReturnValue>(\n+        data: &'a mut CapturedData,\n+        func: Function,\n+    ) -> Self\n+    where\n+        Function: ~const Fn(&mut CapturedData, ClosureArguments) -> ClosureReturnValue,\n+    {\n+        Self { data, func }\n+    }\n+}\n+\n+impl<'a, CapturedData: ?Sized, ClosureArguments, Function, ClosureReturnValue> const\n+    FnOnce<ClosureArguments> for ConstFnMutClosure<'a, CapturedData, Function>\n+where\n+    Function:\n+        ~const Fn(&mut CapturedData, ClosureArguments) -> ClosureReturnValue + ~const Destruct,\n+{\n+    type Output = ClosureReturnValue;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: ClosureArguments) -> Self::Output {\n+        self.call_mut(args)\n+    }\n+}\n+\n+impl<'a, CapturedData: ?Sized, ClosureArguments, Function, ClosureReturnValue> const\n+    FnMut<ClosureArguments> for ConstFnMutClosure<'a, CapturedData, Function>\n+where\n+    Function: ~const Fn(&mut CapturedData, ClosureArguments) -> ClosureReturnValue,\n+{\n+    extern \"rust-call\" fn call_mut(&mut self, args: ClosureArguments) -> Self::Output {\n+        (self.func)(self.data, args)\n+    }\n+}"}, {"sha": "d8365ae9bf92034c4b6c592b780c93ebb2ec77f4", "filename": "library/core/src/fmt/num.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fnum.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -211,7 +211,7 @@ macro_rules! impl_Display {\n         fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n             let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n-            let mut curr = buf.len() as isize;\n+            let mut curr = buf.len();\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n@@ -228,7 +228,7 @@ macro_rules! impl_Display {\n \n                 // eagerly decode 4 characters at a time\n                 while n >= 10000 {\n-                    let rem = (n % 10000) as isize;\n+                    let rem = (n % 10000) as usize;\n                     n /= 10000;\n \n                     let d1 = (rem / 100) << 1;\n@@ -238,37 +238,37 @@ macro_rules! impl_Display {\n                     // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since\n                     // otherwise `curr < 0`. But then `n` was originally at least `10000^10`\n                     // which is `10^40 > 2^128 > n`.\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d2), buf_ptr.offset(curr + 2), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(curr + 2), 2);\n                 }\n \n                 // if we reach here numbers are <= 9999, so at most 4 chars long\n-                let mut n = n as isize; // possibly reduce 64bit math\n+                let mut n = n as usize; // possibly reduce 64bit math\n \n                 // decode 2 more chars, if > 2 chars\n                 if n >= 100 {\n                     let d1 = (n % 100) << 1;\n                     n /= 100;\n                     curr -= 2;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n \n                 // decode last 1 or 2 chars\n                 if n < 10 {\n                     curr -= 1;\n-                    *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                    *buf_ptr.add(curr) = (n as u8) + b'0';\n                 } else {\n                     let d1 = n << 1;\n                     curr -= 2;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n             }\n \n             // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid\n             // UTF-8 since `DEC_DIGITS_LUT` is\n             let buf_slice = unsafe {\n                 str::from_utf8_unchecked(\n-                    slice::from_raw_parts(buf_ptr.offset(curr), buf.len() - curr as usize))\n+                    slice::from_raw_parts(buf_ptr.add(curr), buf.len() - curr))\n             };\n             f.pad_integral(is_nonnegative, \"\", buf_slice)\n         }\n@@ -339,18 +339,18 @@ macro_rules! impl_Exp {\n             // Since `curr` always decreases by the number of digits copied, this means\n             // that `curr >= 0`.\n             let mut buf = [MaybeUninit::<u8>::uninit(); 40];\n-            let mut curr = buf.len() as isize; //index for buf\n+            let mut curr = buf.len(); //index for buf\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             // decode 2 chars at a time\n             while n >= 100 {\n-                let d1 = ((n % 100) as isize) << 1;\n+                let d1 = ((n % 100) as usize) << 1;\n                 curr -= 2;\n                 // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since\n                 // `DEC_DIGITS_LUT` has a length of 200.\n                 unsafe {\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(d1), buf_ptr.offset(curr), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);\n                 }\n                 n /= 100;\n                 exponent += 2;\n@@ -362,7 +362,7 @@ macro_rules! impl_Exp {\n                 curr -= 1;\n                 // SAFETY: Safe since `40 > curr >= 0` (see comment)\n                 unsafe {\n-                    *buf_ptr.offset(curr) = (n as u8 % 10_u8) + b'0';\n+                    *buf_ptr.add(curr) = (n as u8 % 10_u8) + b'0';\n                 }\n                 n /= 10;\n                 exponent += 1;\n@@ -372,18 +372,18 @@ macro_rules! impl_Exp {\n                 curr -= 1;\n                 // SAFETY: Safe since `40 > curr >= 0`\n                 unsafe {\n-                    *buf_ptr.offset(curr) = b'.';\n+                    *buf_ptr.add(curr) = b'.';\n                 }\n             }\n \n             // SAFETY: Safe since `40 > curr >= 0`\n             let buf_slice = unsafe {\n                 // decode last character\n                 curr -= 1;\n-                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                *buf_ptr.add(curr) = (n as u8) + b'0';\n \n                 let len = buf.len() - curr as usize;\n-                slice::from_raw_parts(buf_ptr.offset(curr), len)\n+                slice::from_raw_parts(buf_ptr.add(curr), len)\n             };\n \n             // stores 'e' (or 'E') and the up to 2-digit exponent\n@@ -392,13 +392,13 @@ macro_rules! impl_Exp {\n             // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`\n             // is contained within `exp_buf` since `len <= 3`.\n             let exp_slice = unsafe {\n-                *exp_ptr.offset(0) = if upper { b'E' } else { b'e' };\n+                *exp_ptr.add(0) = if upper { b'E' } else { b'e' };\n                 let len = if exponent < 10 {\n-                    *exp_ptr.offset(1) = (exponent as u8) + b'0';\n+                    *exp_ptr.add(1) = (exponent as u8) + b'0';\n                     2\n                 } else {\n                     let off = exponent << 1;\n-                    ptr::copy_nonoverlapping(lut_ptr.offset(off), exp_ptr.offset(1), 2);\n+                    ptr::copy_nonoverlapping(lut_ptr.add(off), exp_ptr.add(1), 2);\n                     3\n                 };\n                 slice::from_raw_parts(exp_ptr, len)\n@@ -479,7 +479,7 @@ mod imp {\n impl_Exp!(i128, u128 as u128 via to_u128 named exp_u128);\n \n /// Helper function for writing a u64 into `buf` going from last to first, with `curr`.\n-fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut isize) {\n+fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut usize) {\n     let buf_ptr = MaybeUninit::slice_as_mut_ptr(buf);\n     let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n     assert!(*curr > 19);\n@@ -505,14 +505,14 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n \n             *curr -= 16;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d5 as isize), buf_ptr.offset(*curr + 8), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d6 as isize), buf_ptr.offset(*curr + 10), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d7 as isize), buf_ptr.offset(*curr + 12), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d8 as isize), buf_ptr.offset(*curr + 14), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d5 as usize), buf_ptr.add(*curr + 8), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d6 as usize), buf_ptr.add(*curr + 10), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d7 as usize), buf_ptr.add(*curr + 12), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d8 as usize), buf_ptr.add(*curr + 14), 2);\n         }\n         if n >= 1e8 as u64 {\n             let to_parse = n % 1e8 as u64;\n@@ -525,10 +525,10 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             let d4 = ((to_parse / 1e0 as u64) % 100) << 1;\n             *curr -= 8;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d3 as isize), buf_ptr.offset(*curr + 4), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d4 as isize), buf_ptr.offset(*curr + 6), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add(*curr + 4), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add(*curr + 6), 2);\n         }\n         // `n` < 1e8 < (1 << 32)\n         let mut n = n as u32;\n@@ -540,8 +540,8 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             let d2 = (to_parse % 100) << 1;\n             *curr -= 4;\n \n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr + 0), 2);\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d2 as isize), buf_ptr.offset(*curr + 2), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr + 0), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add(*curr + 2), 2);\n         }\n \n         // `n` < 1e4 < (1 << 16)\n@@ -550,17 +550,17 @@ fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], cu\n             let d1 = (n % 100) << 1;\n             n /= 100;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr), 2);\n         }\n \n         // decode last 1 or 2 chars\n         if n < 10 {\n             *curr -= 1;\n-            *buf_ptr.offset(*curr) = (n as u8) + b'0';\n+            *buf_ptr.add(*curr) = (n as u8) + b'0';\n         } else {\n             let d1 = n << 1;\n             *curr -= 2;\n-            ptr::copy_nonoverlapping(lut_ptr.offset(d1 as isize), buf_ptr.offset(*curr), 2);\n+            ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add(*curr), 2);\n         }\n     }\n }\n@@ -593,21 +593,21 @@ impl fmt::Display for i128 {\n fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n     // 2^128 is about 3*10^38, so 39 gives an extra byte of space\n     let mut buf = [MaybeUninit::<u8>::uninit(); 39];\n-    let mut curr = buf.len() as isize;\n+    let mut curr = buf.len();\n \n     let (n, rem) = udiv_1e19(n);\n     parse_u64_into(rem, &mut buf, &mut curr);\n \n     if n != 0 {\n         // 0 pad up to point\n-        let target = (buf.len() - 19) as isize;\n+        let target = buf.len() - 19;\n         // SAFETY: Guaranteed that we wrote at most 19 bytes, and there must be space\n         // remaining since it has length 39\n         unsafe {\n             ptr::write_bytes(\n-                MaybeUninit::slice_as_mut_ptr(&mut buf).offset(target),\n+                MaybeUninit::slice_as_mut_ptr(&mut buf).add(target),\n                 b'0',\n-                (curr - target) as usize,\n+                curr - target,\n             );\n         }\n         curr = target;\n@@ -616,16 +616,16 @@ fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::R\n         parse_u64_into(rem, &mut buf, &mut curr);\n         // Should this following branch be annotated with unlikely?\n         if n != 0 {\n-            let target = (buf.len() - 38) as isize;\n+            let target = buf.len() - 38;\n             // The raw `buf_ptr` pointer is only valid until `buf` is used the next time,\n             // buf `buf` is not used in this scope so we are good.\n             let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);\n             // SAFETY: At this point we wrote at most 38 bytes, pad up to that point,\n             // There can only be at most 1 digit remaining.\n             unsafe {\n-                ptr::write_bytes(buf_ptr.offset(target), b'0', (curr - target) as usize);\n+                ptr::write_bytes(buf_ptr.add(target), b'0', curr - target);\n                 curr = target - 1;\n-                *buf_ptr.offset(curr) = (n as u8) + b'0';\n+                *buf_ptr.add(curr) = (n as u8) + b'0';\n             }\n         }\n     }\n@@ -634,8 +634,8 @@ fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::R\n     // UTF-8 since `DEC_DIGITS_LUT` is\n     let buf_slice = unsafe {\n         str::from_utf8_unchecked(slice::from_raw_parts(\n-            MaybeUninit::slice_as_mut_ptr(&mut buf).offset(curr),\n-            buf.len() - curr as usize,\n+            MaybeUninit::slice_as_mut_ptr(&mut buf).add(curr),\n+            buf.len() - curr,\n         ))\n     };\n     f.pad_integral(is_nonnegative, \"\", buf_slice)"}, {"sha": "489fb13c0dc97aff6df6fd8bd16f7c26c4283bb8", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -1,4 +1,5 @@\n use crate::array;\n+use crate::const_closure::ConstFnMutClosure;\n use crate::iter::{ByRefSized, FusedIterator, Iterator};\n use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n \n@@ -82,12 +83,12 @@ where\n         }\n     }\n \n-    fn fold<B, F>(mut self, init: B, f: F) -> B\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_fold(init, NeverShortCircuit::wrap_mut_2(f)).0\n+        self.try_fold(init, ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp)).0\n     }\n }\n \n@@ -126,12 +127,12 @@ where\n         try { acc }\n     }\n \n-    fn rfold<B, F>(mut self, init: B, f: F) -> B\n+    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_rfold(init, NeverShortCircuit::wrap_mut_2(f)).0\n+        self.try_rfold(init, ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp)).0\n     }\n }\n "}, {"sha": "1945e402ff50ed8e4875cebd8f7bb7c98202f9fa", "filename": "library/core/src/iter/adapters/by_ref_sized.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -1,4 +1,7 @@\n-use crate::ops::{NeverShortCircuit, Try};\n+use crate::{\n+    const_closure::ConstFnMutClosure,\n+    ops::{NeverShortCircuit, Try},\n+};\n \n /// Like `Iterator::by_ref`, but requiring `Sized` so it can forward generics.\n ///\n@@ -36,12 +39,13 @@ impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n     }\n \n     #[inline]\n-    fn fold<B, F>(self, init: B, f: F) -> B\n+    fn fold<B, F>(self, init: B, mut f: F) -> B\n     where\n         F: FnMut(B, Self::Item) -> B,\n     {\n         // `fold` needs ownership, so this can't forward directly.\n-        I::try_fold(self.0, init, NeverShortCircuit::wrap_mut_2(f)).0\n+        I::try_fold(self.0, init, ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp))\n+            .0\n     }\n \n     #[inline]\n@@ -72,12 +76,17 @@ impl<I: DoubleEndedIterator> DoubleEndedIterator for ByRefSized<'_, I> {\n     }\n \n     #[inline]\n-    fn rfold<B, F>(self, init: B, f: F) -> B\n+    fn rfold<B, F>(self, init: B, mut f: F) -> B\n     where\n         F: FnMut(B, Self::Item) -> B,\n     {\n         // `rfold` needs ownership, so this can't forward directly.\n-        I::try_rfold(self.0, init, NeverShortCircuit::wrap_mut_2(f)).0\n+        I::try_rfold(\n+            self.0,\n+            init,\n+            ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp),\n+        )\n+        .0\n     }\n \n     #[inline]"}, {"sha": "de3a534f81b8adf4b0655e4f1471232ec45fde64", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -1,3 +1,4 @@\n+use crate::const_closure::ConstFnMutClosure;\n use crate::iter::{InPlaceIterable, Iterator};\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, NeverShortCircuit, Residual, Try};\n \n@@ -203,12 +204,12 @@ where\n             .into_try()\n     }\n \n-    fn fold<B, F>(mut self, init: B, fold: F) -> B\n+    fn fold<B, F>(mut self, init: B, mut fold: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_fold(init, NeverShortCircuit::wrap_mut_2(fold)).0\n+        self.try_fold(init, ConstFnMutClosure::new(&mut fold, NeverShortCircuit::wrap_mut_2_imp)).0\n     }\n }\n "}, {"sha": "6fbe7ade7325501d19382edf185f599abc6182cc", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -356,6 +356,8 @@ mod bool;\n mod tuple;\n mod unit;\n \n+mod const_closure;\n+\n #[stable(feature = \"core_primitive\", since = \"1.43.0\")]\n pub mod primitive;\n "}, {"sha": "72ebe653caff3483b4dd1c75424805684d11e7b6", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -126,7 +126,8 @@ impl<B, C> const ops::FromResidual for ControlFlow<B, C> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-impl<B, C> ops::Residual<C> for ControlFlow<B, convert::Infallible> {\n+#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n+impl<B, C> const ops::Residual<C> for ControlFlow<B, convert::Infallible> {\n     type TryType = ControlFlow<B, C>;\n }\n "}, {"sha": "4d0d4e12adbf899fc1b4b86772fc8580ac5e9d86", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -129,7 +129,7 @@ use crate::ops::ControlFlow;\n #[doc(alias = \"?\")]\n #[lang = \"Try\"]\n #[const_trait]\n-pub trait Try: FromResidual {\n+pub trait Try: ~const FromResidual {\n     /// The type of the value produced by `?` when *not* short-circuiting.\n     #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n     type Output;\n@@ -438,10 +438,11 @@ where\n /// and in the other direction,\n /// `<Result<Infallible, E> as Residual<T>>::TryType = Result<T, E>`.\n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n+#[const_trait]\n pub trait Residual<O> {\n     /// The \"return\" type of this meta-function.\n     #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-    type TryType: Try<Output = O, Residual = Self>;\n+    type TryType: ~const Try<Output = O, Residual = Self>;\n }\n \n #[unstable(feature = \"pub_crate_should_not_need_unstable_attr\", issue = \"none\")]\n@@ -460,14 +461,17 @@ pub(crate) struct NeverShortCircuit<T>(pub T);\n impl<T> NeverShortCircuit<T> {\n     /// Wrap a binary `FnMut` to return its result wrapped in a `NeverShortCircuit`.\n     #[inline]\n-    pub fn wrap_mut_2<A, B>(mut f: impl FnMut(A, B) -> T) -> impl FnMut(A, B) -> Self {\n-        move |a, b| NeverShortCircuit(f(a, b))\n+    pub const fn wrap_mut_2_imp<A, B, F: ~const FnMut(A, B) -> T>(\n+        f: &mut F,\n+        (a, b): (A, B),\n+    ) -> NeverShortCircuit<T> {\n+        NeverShortCircuit(f(a, b))\n     }\n }\n \n pub(crate) enum NeverShortCircuitResidual {}\n \n-impl<T> Try for NeverShortCircuit<T> {\n+impl<T> const Try for NeverShortCircuit<T> {\n     type Output = T;\n     type Residual = NeverShortCircuitResidual;\n \n@@ -482,14 +486,14 @@ impl<T> Try for NeverShortCircuit<T> {\n     }\n }\n \n-impl<T> FromResidual for NeverShortCircuit<T> {\n+impl<T> const FromResidual for NeverShortCircuit<T> {\n     #[inline]\n     fn from_residual(never: NeverShortCircuitResidual) -> Self {\n         match never {}\n     }\n }\n \n-impl<T> Residual<T> for NeverShortCircuitResidual {\n+impl<T> const Residual<T> for NeverShortCircuitResidual {\n     type TryType = NeverShortCircuit<T>;\n }\n "}, {"sha": "96b16b13256ce7398159fcbeedf91d0372861c75", "filename": "library/core/src/option.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -2321,7 +2321,8 @@ impl<T> ops::FromResidual<ops::Yeet<()>> for Option<T> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-impl<T> ops::Residual<T> for Option<convert::Infallible> {\n+#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n+impl<T> const ops::Residual<T> for Option<convert::Infallible> {\n     type TryType = Option<T>;\n }\n "}, {"sha": "dc90e90402c8ecddbe5991b63840bb955c6fc6b0", "filename": "library/core/src/result.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -2116,6 +2116,7 @@ impl<T, E, F: From<E>> ops::FromResidual<ops::Yeet<E>> for Result<T, F> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-impl<T, E> ops::Residual<T> for Result<convert::Infallible, E> {\n+#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n+impl<T, E> const ops::Residual<T> for Result<convert::Infallible, E> {\n     type TryType = Result<T, E>;\n }"}, {"sha": "c848c2e18e9b5293a132e2c926cb8ae3e7508b8c", "filename": "library/core/src/slice/memchr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmemchr.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -141,8 +141,8 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n         // SAFETY: offset starts at len - suffix.len(), as long as it is greater than\n         // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.\n         unsafe {\n-            let u = *(ptr.offset(offset as isize - 2 * chunk_bytes as isize) as *const Chunk);\n-            let v = *(ptr.offset(offset as isize - chunk_bytes as isize) as *const Chunk);\n+            let u = *(ptr.add(offset - 2 * chunk_bytes) as *const Chunk);\n+            let v = *(ptr.add(offset - chunk_bytes) as *const Chunk);\n \n             // Break if there is a matching byte.\n             let zu = contains_zero_byte(u ^ repeated_x);"}, {"sha": "0d934318c22a45a2db6269ddfc44907d6bc99a24", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -316,9 +316,9 @@ where\n //   | small1 | Chunk smaller than 8 bytes\n //   +--------+\n fn region_as_aligned_chunks(ptr: *const u8, len: usize) -> (usize, usize, usize) {\n-    let small0_size = if ptr as usize % 8 == 0 { 0 } else { 8 - ptr as usize % 8 };\n-    let small1_size = (len - small0_size as usize) % 8;\n-    let big_size = len - small0_size as usize - small1_size as usize;\n+    let small0_size = if ptr.is_aligned_to(8) { 0 } else { 8 - ptr.addr() % 8 };\n+    let small1_size = (len - small0_size) % 8;\n+    let big_size = len - small0_size - small1_size;\n \n     (small0_size, big_size, small1_size)\n }\n@@ -364,8 +364,8 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n                     mfence\n                     lfence\n                     \",\n-                    val = in(reg_byte) *src.offset(off as isize),\n-                    dst = in(reg) dst.offset(off as isize),\n+                    val = in(reg_byte) *src.add(off),\n+                    dst = in(reg) dst.add(off),\n                     seg_sel = in(reg) &mut seg_sel,\n                     options(nostack, att_syntax)\n                 );\n@@ -378,8 +378,8 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n     assert!(is_enclave_range(src, len));\n     assert!(is_user_range(dst, len));\n     assert!(len < isize::MAX as usize);\n-    assert!(!(src as usize).overflowing_add(len).1);\n-    assert!(!(dst as usize).overflowing_add(len).1);\n+    assert!(!src.addr().overflowing_add(len).1);\n+    assert!(!dst.addr().overflowing_add(len).1);\n \n     if len < 8 {\n         // Can't align on 8 byte boundary: copy safely byte per byte\n@@ -404,17 +404,17 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n \n         unsafe {\n             // Copy small0\n-            copy_bytewise_to_userspace(src, dst, small0_size as _);\n+            copy_bytewise_to_userspace(src, dst, small0_size);\n \n             // Copy big\n-            let big_src = src.offset(small0_size as _);\n-            let big_dst = dst.offset(small0_size as _);\n-            copy_quadwords(big_src as _, big_dst, big_size);\n+            let big_src = src.add(small0_size);\n+            let big_dst = dst.add(small0_size);\n+            copy_quadwords(big_src, big_dst, big_size);\n \n             // Copy small1\n-            let small1_src = src.offset(big_size as isize + small0_size as isize);\n-            let small1_dst = dst.offset(big_size as isize + small0_size as isize);\n-            copy_bytewise_to_userspace(small1_src, small1_dst, small1_size as _);\n+            let small1_src = src.add(big_size + small0_size);\n+            let small1_dst = dst.add(big_size + small0_size);\n+            copy_bytewise_to_userspace(small1_src, small1_dst, small1_size);\n         }\n     }\n }"}, {"sha": "01f4cacd771ffcd4d8b4d60bc7d5e83ab313352b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -520,7 +520,7 @@ impl Step for Miri {\n         cargo.arg(\"--\").arg(\"miri\").arg(\"setup\");\n \n         // Tell `cargo miri setup` where to find the sources.\n-        cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"library\"));\n+        cargo.env(\"MIRI_LIB_SRC\", builder.src.join(\"library\"));\n         // Tell it where to find Miri.\n         cargo.env(\"MIRI\", &miri);\n         // Debug things."}, {"sha": "4136cb6cab33af241ac0cbd8fdb0acea7c83d270", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -1412,7 +1412,6 @@ pre.rust {\n }\n #source-sidebar {\n \twidth: 100%;\n-\tz-index: 1;\n \toverflow: auto;\n }\n #source-sidebar > .title {\n@@ -1918,10 +1917,6 @@ in storage.js plus the media query with (min-width: 701px)\n \t\tborder-bottom: 1px solid;\n \t}\n \n-\t#source-sidebar {\n-\t\tz-index: 11;\n-\t}\n-\n \t#main-content > .line-numbers {\n \t\tmargin-top: 0;\n \t}"}, {"sha": "bf94d980678f506c74d004ae62b77a2ac69bbc09", "filename": "src/test/ui/privacy/access_levels.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -55,8 +55,21 @@ mod outer { //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(sel\n     }\n }\n \n-pub use outer::inner1;\n+#[rustc_effective_visibility]\n+pub use outer::inner1; //~ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n \n pub fn foo() -> outer::ReachableStruct { outer::ReachableStruct {a: 0} }\n \n+mod half_public_import {\n+    #[rustc_effective_visibility]\n+    pub type HalfPublicImport = u8; //~ ERROR Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+    #[rustc_effective_visibility]\n+    #[allow(non_upper_case_globals)]\n+    pub(crate) const HalfPublicImport: u8 = 0; //~ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+}\n+\n+#[rustc_effective_visibility]\n+pub use half_public_import::HalfPublicImport; //~ ERROR Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+                                              //~^ ERROR Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+\n fn main() {}"}, {"sha": "81514d1fbab45a04ad2c7406cf2fd44395d36c35", "filename": "src/test/ui/privacy/access_levels.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -88,6 +88,36 @@ error: Public: pub(self), Exported: pub(self), Reachable: pub, ReachableFromImpl\n LL |         pub a: u8,\n    |         ^^^^^^^^^\n \n+error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+  --> $DIR/access_levels.rs:59:9\n+   |\n+LL | pub use outer::inner1;\n+   |         ^^^^^^^^^^^^^\n+\n+error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+  --> $DIR/access_levels.rs:65:5\n+   |\n+LL |     pub type HalfPublicImport = u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+  --> $DIR/access_levels.rs:68:5\n+   |\n+LL |     pub(crate) const HalfPublicImport: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Public: pub, Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n+  --> $DIR/access_levels.rs:72:9\n+   |\n+LL | pub use half_public_import::HalfPublicImport;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Public: pub(self), Exported: pub(self), Reachable: pub(self), ReachableFromImplTrait: pub(self)\n+  --> $DIR/access_levels.rs:72:9\n+   |\n+LL | pub use half_public_import::HalfPublicImport;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait: pub\n   --> $DIR/access_levels.rs:14:13\n    |\n@@ -100,5 +130,5 @@ error: Public: pub(self), Exported: pub, Reachable: pub, ReachableFromImplTrait:\n LL |             type B;\n    |             ^^^^^^\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "88c716cc86ce8977f7b40ecdd6dccbabcbb25887", "filename": "src/test/ui/suggestions/issue-101065.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.fixed?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -0,0 +1,14 @@\n+// check-fail\n+// run-rustfix\n+\n+enum FakeResult<T> {\n+    Ok(T)\n+}\n+\n+fn main() {\n+    let _x = if true {\n+        FakeResult::Ok(FakeResult::Ok(()))\n+    } else {\n+        FakeResult::Ok(FakeResult::Ok(())) //~ERROR E0308\n+    };\n+}"}, {"sha": "2715f1027082fd82b368c1ada9ebd11f2ee85047", "filename": "src/test/ui/suggestions/issue-101065.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.rs?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -0,0 +1,14 @@\n+// check-fail\n+// run-rustfix\n+\n+enum FakeResult<T> {\n+    Ok(T)\n+}\n+\n+fn main() {\n+    let _x = if true {\n+        FakeResult::Ok(FakeResult::Ok(()))\n+    } else {\n+        FakeResult::Ok(()) //~ERROR E0308\n+    };\n+}"}, {"sha": "6f7ecd24ca4287a24a63eae9a6292ddf2537326a", "filename": "src/test/ui/suggestions/issue-101065.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6580010551063718462f9dfe41c9490d92994d0e/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101065.stderr?ref=6580010551063718462f9dfe41c9490d92994d0e", "patch": "@@ -0,0 +1,23 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/issue-101065.rs:12:9\n+   |\n+LL |       let _x = if true {\n+   |  ______________-\n+LL | |         FakeResult::Ok(FakeResult::Ok(()))\n+   | |         ---------------------------------- expected because of this\n+LL | |     } else {\n+LL | |         FakeResult::Ok(())\n+   | |         ^^^^^^^^^^^^^^^^^^ expected enum `FakeResult`, found `()`\n+LL | |     };\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+   = note: expected enum `FakeResult<FakeResult<()>>`\n+              found enum `FakeResult<()>`\n+help: try wrapping the expression in `FakeResult::Ok`\n+   |\n+LL |         FakeResult::Ok(FakeResult::Ok(()))\n+   |         +++++++++++++++                  +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}