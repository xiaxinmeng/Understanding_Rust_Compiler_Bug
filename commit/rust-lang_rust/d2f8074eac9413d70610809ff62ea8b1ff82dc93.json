{"sha": "d2f8074eac9413d70610809ff62ea8b1ff82dc93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZjgwNzRlYWM5NDEzZDcwNjEwODA5ZmY2MmVhOGIxZmY4MmRjOTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-30T01:29:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-03T22:41:01Z"}, "message": "Add a 4th space for associated types defined in a trait (currently unused)", "tree": {"sha": "8008129c80cae105d26f70e423e295e18d4ac193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8008129c80cae105d26f70e423e295e18d4ac193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2f8074eac9413d70610809ff62ea8b1ff82dc93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8074eac9413d70610809ff62ea8b1ff82dc93", "html_url": "https://github.com/rust-lang/rust/commit/d2f8074eac9413d70610809ff62ea8b1ff82dc93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8074eac9413d70610809ff62ea8b1ff82dc93/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94d142b596465989958db270e1c6bec83ee1eb99", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d142b596465989958db270e1c6bec83ee1eb99", "html_url": "https://github.com/rust-lang/rust/commit/94d142b596465989958db270e1c6bec83ee1eb99"}], "stats": {"total": 154, "additions": 85, "deletions": 69}, "files": [{"sha": "d1d81b9a915cc1f8a24a2fae756575db709d7513", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -717,8 +717,9 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     {\n         let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n+        let assocs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        VecPerParamSpace::new(types, selfs, fns)\n+        VecPerParamSpace::new(types, selfs, assocs, fns)\n     }\n \n     fn read_vtable_res_with_key(&mut self,"}, {"sha": "c322b4aae7ef050c9d7b7b20010ef3da2503da0e", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -112,17 +112,17 @@ impl Substs {\n                     r: Vec<ty::Region>)\n                     -> Substs\n     {\n-        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, Vec::new(), Vec::new(), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n     pub fn new_trait(t: Vec<ty::t>,\n                      r: Vec<ty::Region>,\n                      s: ty::t)\n                     -> Substs\n     {\n-        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new()),\n-                    VecPerParamSpace::new(r, Vec::new(), Vec::new()))\n+        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new(), Vec::new()),\n+                    VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n \n     pub fn erased(t: VecPerParamSpace<ty::t>) -> Substs\n@@ -226,29 +226,32 @@ impl RegionSubsts {\n #[deriving(PartialOrd, Ord, PartialEq, Eq,\n            Clone, Hash, Encodable, Decodable, Show)]\n pub enum ParamSpace {\n-    TypeSpace, // Type parameters attached to a type definition, trait, or impl\n-    SelfSpace, // Self parameter on a trait\n-    FnSpace,   // Type parameters attached to a method or fn\n+    TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n+    SelfSpace,  // Self parameter on a trait\n+    AssocSpace, // Assoc types defined in a trait/impl\n+    FnSpace,    // Type parameters attached to a method or fn\n }\n \n impl ParamSpace {\n-    pub fn all() -> [ParamSpace, ..3] {\n-        [TypeSpace, SelfSpace, FnSpace]\n+    pub fn all() -> [ParamSpace, ..4] {\n+        [TypeSpace, SelfSpace, AssocSpace, FnSpace]\n     }\n \n     pub fn to_uint(self) -> uint {\n         match self {\n             TypeSpace => 0,\n             SelfSpace => 1,\n-            FnSpace => 2,\n+            AssocSpace => 2,\n+            FnSpace => 3,\n         }\n     }\n \n     pub fn from_uint(u: uint) -> ParamSpace {\n         match u {\n             0 => TypeSpace,\n             1 => SelfSpace,\n-            2 => FnSpace,\n+            2 => AssocSpace,\n+            3 => FnSpace,\n             _ => panic!(\"Invalid ParamSpace: {}\", u)\n         }\n     }\n@@ -268,11 +271,13 @@ pub struct VecPerParamSpace<T> {\n     // Here is how the representation corresponds to the abstraction\n     // i.e. the \"abstraction function\" AF:\n     //\n-    // AF(self) = (self.content.slice_to(self.type_limit),\n-    //             self.content.slice(self.type_limit, self.self_limit),\n-    //             self.content.slice_from(self.self_limit))\n+    // AF(self) = (self.content[..self.type_limit],\n+    //             self.content[self.type_limit..self.self_limit],\n+    //             self.content[self.self_limit..self.assoc_limit],\n+    //             self.content[self.assoc_limit..])\n     type_limit: uint,\n     self_limit: uint,\n+    assoc_limit: uint,\n     content: Vec<T>,\n }\n \n@@ -292,14 +297,16 @@ impl<T> VecPerParamSpace<T> {\n         match space {\n             TypeSpace => (0, self.type_limit),\n             SelfSpace => (self.type_limit, self.self_limit),\n-            FnSpace => (self.self_limit, self.content.len()),\n+            AssocSpace => (self.self_limit, self.assoc_limit),\n+            FnSpace => (self.assoc_limit, self.content.len()),\n         }\n     }\n \n     pub fn empty() -> VecPerParamSpace<T> {\n         VecPerParamSpace {\n             type_limit: 0,\n             self_limit: 0,\n+            assoc_limit: 0,\n             content: Vec::new()\n         }\n     }\n@@ -310,26 +317,33 @@ impl<T> VecPerParamSpace<T> {\n \n     /// `t` is the type space.\n     /// `s` is the self space.\n+    /// `a` is the assoc space.\n     /// `f` is the fn space.\n-    pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n+    pub fn new(t: Vec<T>, s: Vec<T>, a: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n         let type_limit = t.len();\n-        let self_limit = t.len() + s.len();\n+        let self_limit = type_limit + s.len();\n+        let assoc_limit = self_limit + a.len();\n+\n         let mut content = t;\n         content.extend(s.into_iter());\n+        content.extend(a.into_iter());\n         content.extend(f.into_iter());\n+\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n+            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n \n-    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n+    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint, assoc_limit: uint)\n                     -> VecPerParamSpace<T>\n     {\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,\n+            assoc_limit: assoc_limit,\n             content: content,\n         }\n     }\n@@ -341,9 +355,10 @@ impl<T> VecPerParamSpace<T> {\n     pub fn push(&mut self, space: ParamSpace, value: T) {\n         let (_, limit) = self.limits(space);\n         match space {\n-            TypeSpace => { self.type_limit += 1; self.self_limit += 1; }\n-            SelfSpace => { self.self_limit += 1; }\n-            FnSpace   => {}\n+            TypeSpace => { self.type_limit += 1; self.self_limit += 1; self.assoc_limit += 1; }\n+            SelfSpace => { self.self_limit += 1; self.assoc_limit += 1; }\n+            AssocSpace => { self.assoc_limit += 1; }\n+            FnSpace => { }\n         }\n         self.content.insert(limit, value);\n     }\n@@ -354,9 +369,10 @@ impl<T> VecPerParamSpace<T> {\n             None\n         } else {\n             match space {\n-                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; }\n-                SelfSpace => { self.self_limit -= 1; }\n-                FnSpace   => {}\n+                TypeSpace => { self.type_limit -= 1; self.self_limit -= 1; self.assoc_limit -= 1; }\n+                SelfSpace => { self.self_limit -= 1; self.assoc_limit -= 1; }\n+                AssocSpace => { self.assoc_limit -= 1; }\n+                FnSpace => {}\n             }\n             self.content.remove(limit - 1)\n         }\n@@ -442,35 +458,29 @@ impl<T> VecPerParamSpace<T> {\n         let result = self.iter().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n                                        self.type_limit,\n-                                       self.self_limit)\n+                                       self.self_limit,\n+                                       self.assoc_limit)\n     }\n \n     pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n-        let (t, s, f) = self.split();\n+        let (t, s, a, f) = self.split();\n         VecPerParamSpace::new(t.into_iter().map(|p| pred(p)).collect(),\n                               s.into_iter().map(|p| pred(p)).collect(),\n+                              a.into_iter().map(|p| pred(p)).collect(),\n                               f.into_iter().map(|p| pred(p)).collect())\n     }\n \n-    pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>) {\n-        // FIXME (#15418): this does two traversals when in principle\n-        // one would suffice.  i.e. change to use `move_iter`.\n-        let VecPerParamSpace { type_limit, self_limit, content } = self;\n-        let mut i = 0;\n-        let (prefix, fn_vec) = content.partition(|_| {\n-            let on_left = i < self_limit;\n-            i += 1;\n-            on_left\n-        });\n+    pub fn split(self) -> (Vec<T>, Vec<T>, Vec<T>, Vec<T>) {\n+        let VecPerParamSpace { type_limit, self_limit, assoc_limit, content } = self;\n+\n+        let mut content_iter = content.into_iter();\n \n-        let mut i = 0;\n-        let (type_vec, self_vec) = prefix.partition(|_| {\n-            let on_left = i < type_limit;\n-            i += 1;\n-            on_left\n-        });\n+        let types = content_iter.by_ref().take(type_limit).collect();\n+        let selfs = content_iter.by_ref().take(self_limit - type_limit).collect();\n+        let assocs = content_iter.by_ref().take(assoc_limit - self_limit).collect();\n+        let fns = content_iter.collect();\n \n-        (type_vec, self_vec, fn_vec)\n+        (types, selfs, assocs, fns)\n     }\n \n     pub fn with_vec(mut self, space: ParamSpace, vec: Vec<T>)\n@@ -616,12 +626,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     this.tcx().sess.span_bug(\n                         span,\n                         format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n-                                 when substituting (root type={})\",\n+                                 when substituting (root type={}) substs={}\",\n                                 p.repr(this.tcx()),\n                                 source_ty.repr(this.tcx()),\n                                 space,\n                                 index,\n-                                this.root_ty.repr(this.tcx())).as_slice());\n+                                this.root_ty.repr(this.tcx()),\n+                                this.substs.repr(this.tcx())).as_slice());\n                 }\n             }\n         }"}, {"sha": "a665e1f0a264e89924b88df43988f80cf8582663", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -1607,7 +1607,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n         };\n-        let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n+        let obligations = VecPerParamSpace::new(obligations, Vec::new(),\n+                                                Vec::new(), Vec::new());\n         VtableBuiltinData { nested: obligations }\n     }\n "}, {"sha": "e54d50c8b5f594c630b9d7046d5d014d923119a5", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -205,7 +205,7 @@ pub fn trans_static_method_callee(bcx: Block,\n     // type parameters that belong to the trait but also some that\n     // belong to the method:\n     let rcvr_substs = node_id_substs(bcx, ExprId(expr_id));\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.split();\n+    let (rcvr_type, rcvr_self, rcvr_assoc, rcvr_method) = rcvr_substs.types.split();\n \n     // Lookup the precise impl being called. To do that, we need to\n     // create a trait reference identifying the self type and other\n@@ -232,6 +232,7 @@ pub fn trans_static_method_callee(bcx: Block,\n     let trait_substs =\n         Substs::erased(VecPerParamSpace::new(rcvr_type,\n                                              rcvr_self,\n+                                             rcvr_assoc,\n                                              Vec::new()));\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n     let trait_ref = Rc::new(ty::TraitRef { def_id: trait_id,\n@@ -265,10 +266,11 @@ pub fn trans_static_method_callee(bcx: Block,\n             // that with the `rcvr_method` from before, which tells us\n             // the type parameters from the *method*, to yield\n             // `callee_substs=[[T=int],[],[U=String]]`.\n-            let (impl_type, impl_self, _) = impl_substs.types.split();\n+            let (impl_type, impl_self, impl_assoc, _) = impl_substs.types.split();\n             let callee_substs =\n                 Substs::erased(VecPerParamSpace::new(impl_type,\n                                                      impl_self,\n+                                                     impl_assoc,\n                                                      rcvr_method));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n@@ -397,12 +399,12 @@ fn combine_impl_and_methods_tps(bcx: Block,\n \n     // Break apart the type parameters from the node and type\n     // parameters from the receiver.\n-    let (_, _, node_method) = node_substs.types.split();\n-    let (rcvr_type, rcvr_self, rcvr_method) = rcvr_substs.types.clone().split();\n+    let (_, _, _, node_method) = node_substs.types.split();\n+    let (rcvr_type, rcvr_self, rcvr_assoc, rcvr_method) = rcvr_substs.types.clone().split();\n     assert!(rcvr_method.is_empty());\n     subst::Substs {\n         regions: subst::ErasedRegions,\n-        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, node_method)\n+        types: subst::VecPerParamSpace::new(rcvr_type, rcvr_self, rcvr_assoc, node_method)\n     }\n }\n "}, {"sha": "1d769572ffee27ebdbfc1b48e3eaa45c200eec25", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -666,10 +666,11 @@ impl Repr for subst::Substs {\n \n impl<T:Repr> Repr for subst::VecPerParamSpace<T> {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"[{};{};{}]\",\n-                       self.get_slice(subst::TypeSpace).repr(tcx),\n-                       self.get_slice(subst::SelfSpace).repr(tcx),\n-                       self.get_slice(subst::FnSpace).repr(tcx))\n+        format!(\"[{};{};{};{}]\",\n+                self.get_slice(subst::TypeSpace).repr(tcx),\n+                self.get_slice(subst::SelfSpace).repr(tcx),\n+                self.get_slice(subst::AssocSpace).repr(tcx),\n+                self.get_slice(subst::FnSpace).repr(tcx))\n     }\n }\n "}, {"sha": "48813ff142c1895c90d06c86e0fd3bf28a6ba71b", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -14,7 +14,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n+struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[];[]]\n     x: &'a int,\n     y: &'b [int],\n     c: &'c str\n@@ -23,7 +23,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[[-, -, -];[];[]]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n+struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[];[]]\n     x: extern \"Rust\" fn(&'a int),\n     y: extern \"Rust\" fn(&'b [int]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -32,15 +32,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[[+, +, +];[];[]]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test4<'a, 'b:'a> { //~ ERROR regions=[[-, o];[];[];[]]\n     x: &'a mut &'b int,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n+struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[];[]]\n     x: extern \"Rust\" fn(&'a mut &'b int),\n }\n \n@@ -50,21 +50,21 @@ struct Test5<'a, 'b> { //~ ERROR regions=[[+, o];[];[]]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[]]\n+struct Test6<'a, 'b> { //~ ERROR regions=[[-, o];[];[];[]]\n     x: &'a mut extern \"Rust\" fn(&'b int),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[[*];[];[]]\n+struct Test7<'a> { //~ ERROR regions=[[*];[];[];[]]\n     x: int\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),"}, {"sha": "0e8e52df456afc4142e5914821f5264bfae23565", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -13,29 +13,29 @@\n // Try enums too.\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[]]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[[+, -, o, *];[];[];[]]\n     Test8A(extern \"Rust\" fn(&'a int)),\n     Test8B(&'b [int]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[]]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[[*, o, -, +];[];[];[]]\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[]]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[[o, o, *];[];[];[]]\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[]]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[[o, -, *];[];[];[]]\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[]]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[[+, -, o];[];[];[]]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "c576c5e2edd6465e95111eef0b30c5422e32100c", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f8074eac9413d70610809ff62ea8b1ff82dc93/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=d2f8074eac9413d70610809ff62ea8b1ff82dc93", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n trait T { fn foo(); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[[-];[];[]]\n+struct TOption<'a> { //~ ERROR regions=[[-];[];[];[]]\n     v: Option<Box<T + 'a>>,\n }\n "}]}