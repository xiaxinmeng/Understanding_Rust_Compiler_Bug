{"sha": "0f83c68698db709dfcc64bd9eef22feabde945c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmODNjNjg2OThkYjcwOWRmY2M2NGJkOWVlZjIyZmVhYmRlOTQ1Yzk=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-06-19T05:37:09Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-06-19T05:37:09Z"}, "message": "Replace `Constant::partial_cmp`", "tree": {"sha": "bdbed939cfe383cc5a9c30e9081e1134c33ea71b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdbed939cfe383cc5a9c30e9081e1134c33ea71b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f83c68698db709dfcc64bd9eef22feabde945c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f83c68698db709dfcc64bd9eef22feabde945c9", "html_url": "https://github.com/rust-lang/rust/commit/0f83c68698db709dfcc64bd9eef22feabde945c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f83c68698db709dfcc64bd9eef22feabde945c9/comments", "author": null, "committer": null, "parents": [{"sha": "7a32c289319bb376d47e7a9f83057f82e1d4fda0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a32c289319bb376d47e7a9f83057f82e1d4fda0", "html_url": "https://github.com/rust-lang/rust/commit/7a32c289319bb376d47e7a9f83057f82e1d4fda0"}], "stats": {"total": 52, "additions": 24, "deletions": 28}, "files": [{"sha": "36417cd0877788ac9a3a8dd02fdfc57ee3ec6e46", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0f83c68698db709dfcc64bd9eef22feabde945c9/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f83c68698db709dfcc64bd9eef22feabde945c9/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=0f83c68698db709dfcc64bd9eef22feabde945c9", "patch": "@@ -122,21 +122,32 @@ impl Hash for Constant {\n     }\n }\n \n-impl PartialOrd for Constant {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        match (self, other) {\n+impl Constant {\n+    pub fn partial_cmp(tcx: TyCtxt, cmp_type: &ty::TypeVariants, left: &Self, right: &Self) -> Option<Ordering> {\n+        match (left, right) {\n             (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Int(l), &Constant::Int(r)) => Some(l.cmp(&r)),\n+            (&Constant::Int(l), &Constant::Int(r)) => {\n+                if let ty::TyInt(int_ty) = *cmp_type {\n+                    Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n+                } else {\n+                    Some(l.cmp(&r))\n+                }\n+            },\n             (&Constant::F64(l), &Constant::F64(r)) => l.partial_cmp(&r),\n             (&Constant::F32(l), &Constant::F32(r)) => l.partial_cmp(&r),\n             (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) | (&Constant::Vec(ref l), &Constant::Vec(ref r)) => {\n-                l.partial_cmp(r)\n-            },\n-            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => match lv.partial_cmp(rv) {\n-                Some(Equal) => Some(ls.cmp(rs)),\n-                x => x,\n+            (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) | (&Constant::Vec(ref l), &Constant::Vec(ref r)) => l\n+                .iter()\n+                .zip(r.iter())\n+                .map(|(li, ri)| Constant::partial_cmp(tcx, cmp_type, li, ri))\n+                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+            (&Constant::Repeat(ref lv, ref ls), &Constant::Repeat(ref rv, ref rs)) => {\n+                match Constant::partial_cmp(tcx, cmp_type, lv, rv) {\n+                    Some(Equal) => Some(ls.cmp(rs)),\n+                    x => x,\n+                }\n             },\n             _ => None, // TODO: Are there any useful inter-type orderings?\n         }"}, {"sha": "4be2b9f522711a11f53c8dcb5e855d1e4979dc83", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f83c68698db709dfcc64bd9eef22feabde945c9/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f83c68698db709dfcc64bd9eef22feabde945c9/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=0f83c68698db709dfcc64bd9eef22feabde945c9", "patch": "@@ -1,9 +1,8 @@\n use crate::consts::{constant_simple, Constant};\n-use crate::utils::{match_def_path, opt_def_id, paths, sext, span_lint};\n+use crate::utils::{match_def_path, opt_def_id, paths, span_lint};\n use rustc::hir::*;\n use rustc::lint::*;\n-use rustc::ty::{self, TyCtxt};\n-use std::cmp::{Ordering, PartialOrd};\n+use std::cmp::Ordering;\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n /// used to clamp values, but switched so that the result is constant.\n@@ -43,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n                 }\n                 match (\n                     outer_max,\n-                    const_partial_cmp(cx.tcx, &outer_c, &inner_c, &cx.tables.expr_ty(ie).sty),\n+                    Constant::partial_cmp(cx.tcx, &cx.tables.expr_ty(ie).sty, &outer_c, &inner_c),\n                 ) {\n                     (_, None) | (MinMax::Max, Some(Ordering::Less)) | (MinMax::Min, Some(Ordering::Greater)) => (),\n                     _ => {\n@@ -60,20 +59,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n     }\n }\n \n-// Constant::partial_cmp incorrectly orders signed integers\n-fn const_partial_cmp(tcx: TyCtxt, a: &Constant, b: &Constant, expr_ty: &ty::TypeVariants) -> Option<Ordering> {\n-    match *expr_ty {\n-        ty::TyInt(int_ty) => {\n-            if let (&Constant::Int(a), &Constant::Int(b)) = (a, b) {\n-                Some(sext(tcx, a, int_ty).cmp(&sext(tcx, b, int_ty)))\n-            } else {\n-                None\n-            }\n-        },\n-        _ => a.partial_cmp(&b),\n-    }\n-}\n-\n #[derive(PartialEq, Eq, Debug)]\n enum MinMax {\n     Min,"}]}