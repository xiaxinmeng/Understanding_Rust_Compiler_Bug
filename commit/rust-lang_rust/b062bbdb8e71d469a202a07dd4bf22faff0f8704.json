{"sha": "b062bbdb8e71d469a202a07dd4bf22faff0f8704", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNjJiYmRiOGU3MWQ0NjlhMjAyYTA3ZGQ0YmYyMmZhZmYwZjg3MDQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-12T21:20:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-12T21:28:11Z"}, "message": "stdlib: Switch lib::deque over to interior vectors", "tree": {"sha": "ae8c4b67d9aa7348ded059f1494b9dc051cd443d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae8c4b67d9aa7348ded059f1494b9dc051cd443d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b062bbdb8e71d469a202a07dd4bf22faff0f8704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b062bbdb8e71d469a202a07dd4bf22faff0f8704", "html_url": "https://github.com/rust-lang/rust/commit/b062bbdb8e71d469a202a07dd4bf22faff0f8704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b062bbdb8e71d469a202a07dd4bf22faff0f8704/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf", "html_url": "https://github.com/rust-lang/rust/commit/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf"}], "stats": {"total": 52, "additions": 28, "deletions": 24}, "files": [{"sha": "102c066b3d5cc2d81086360f845d8f5d8baf6a88", "filename": "src/lib/deque.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b062bbdb8e71d469a202a07dd4bf22faff0f8704/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b062bbdb8e71d469a202a07dd4bf22faff0f8704/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=b062bbdb8e71d469a202a07dd4bf22faff0f8704", "patch": "@@ -25,23 +25,25 @@ fn create[T]() -> t[T] {\n       * elsewhere.\n       */\n \n-    fn grow[T](uint nelts, uint lo, vec[mutable cell[T]] elts) ->\n-       vec[mutable cell[T]] {\n-        assert (nelts == vec::len(elts));\n-        // FIXME: Making the vector argument an alias is a workaround for\n-        // issue #375\n+    fn grow[T](uint nelts, uint lo, &(cell[T])[mutable] elts)\n+            -> (cell[T])[mutable] {\n+        assert (nelts == ivec::len(elts));\n+        auto rv = ~[mutable];\n \n-        fn fill[T](uint i, uint nelts, uint lo, &vec[mutable cell[T]] old) ->\n-           cell[T] {\n-            ret if (i < nelts) {\n-                    old.((lo + i) % nelts)\n-                } else { option::none };\n+        auto i = 0u;\n+        auto nalloc = uint::next_power_of_two(nelts + 1u);\n+        while (i < nalloc) {\n+            if (i < nelts) {\n+                rv += ~[mutable elts.((lo + i) % nelts)];\n+            } else {\n+                rv += ~[mutable option::none];\n+            }\n+            i += 1u;\n         }\n-        let uint nalloc = uint::next_power_of_two(nelts + 1u);\n-        let vec::init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n-        ret vec::init_fn_mut[cell[T]](copy_op, nalloc);\n+\n+        ret rv;\n     }\n-    fn get[T](vec[mutable cell[T]] elts, uint i) -> T {\n+    fn get[T](&(cell[T])[mutable] elts, uint i) -> T {\n         ret alt (elts.(i)) {\n                 case (option::some(?t)) { t }\n                 case (_) { fail }\n@@ -50,16 +52,16 @@ fn create[T]() -> t[T] {\n     obj deque[T](mutable uint nelts,\n                  mutable uint lo,\n                  mutable uint hi,\n-                 mutable vec[mutable cell[T]] elts) {\n+                 mutable (cell[T])[mutable] elts) {\n         fn size() -> uint { ret nelts; }\n         fn add_front(&T t) {\n             let uint oldlo = lo;\n             if (lo == 0u) {\n-                lo = vec::len[cell[T]](elts) - 1u;\n+                lo = ivec::len[cell[T]](elts) - 1u;\n             } else { lo -= 1u; }\n             if (lo == hi) {\n                 elts = grow[T](nelts, oldlo, elts);\n-                lo = vec::len[cell[T]](elts) - 1u;\n+                lo = ivec::len[cell[T]](elts) - 1u;\n                 hi = nelts;\n             }\n             elts.(lo) = option::some[T](t);\n@@ -72,7 +74,7 @@ fn create[T]() -> t[T] {\n                 hi = nelts;\n             }\n             elts.(hi) = option::some[T](t);\n-            hi = (hi + 1u) % vec::len[cell[T]](elts);\n+            hi = (hi + 1u) % ivec::len[cell[T]](elts);\n             nelts += 1u;\n         }\n \n@@ -83,14 +85,16 @@ fn create[T]() -> t[T] {\n         fn pop_front() -> T {\n             let T t = get[T](elts, lo);\n             elts.(lo) = option::none[T];\n-            lo = (lo + 1u) % vec::len[cell[T]](elts);\n+            lo = (lo + 1u) % ivec::len[cell[T]](elts);\n             nelts -= 1u;\n             ret t;\n         }\n         fn pop_back() -> T {\n             if (hi == 0u) {\n-                hi = vec::len[cell[T]](elts) - 1u;\n-            } else { hi -= 1u; }\n+                hi = ivec::len[cell[T]](elts) - 1u;\n+            } else {\n+                hi -= 1u;\n+            }\n             let T t = get[T](elts, hi);\n             elts.(hi) = option::none[T];\n             nelts -= 1u;\n@@ -99,12 +103,12 @@ fn create[T]() -> t[T] {\n         fn peek_front() -> T { ret get[T](elts, lo); }\n         fn peek_back() -> T { ret get[T](elts, hi - 1u); }\n         fn get(int i) -> T {\n-            let uint idx = (lo + (i as uint)) % vec::len[cell[T]](elts);\n+            let uint idx = (lo + (i as uint)) % ivec::len[cell[T]](elts);\n             ret get[T](elts, idx);\n         }\n     }\n-    let vec[mutable cell[T]] v =\n-        vec::init_elt_mut(option::none, initial_capacity);\n+    let (cell[T])[mutable] v =\n+        ivec::init_elt_mut(option::none, initial_capacity);\n     ret deque[T](0u, 0u, 0u, v);\n }\n // Local Variables:"}]}