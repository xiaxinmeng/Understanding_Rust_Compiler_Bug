{"sha": "780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MGY4Mjc3ZjQ0YmIyZWRkYWY2YzUxNmQ2MGIwYTZiOWI1NTdhNWI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-23T15:59:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-23T16:00:19Z"}, "message": "Finish cleanup of core::str\n\nCloses #1849", "tree": {"sha": "f8b30650ab8b26c27f384e422bcff3cd8cbcab79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8b30650ab8b26c27f384e422bcff3cd8cbcab79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "html_url": "https://github.com/rust-lang/rust/commit/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d2b4b97edd7c4038f96c81d8945e294442092a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2b4b97edd7c4038f96c81d8945e294442092a2", "html_url": "https://github.com/rust-lang/rust/commit/1d2b4b97edd7c4038f96c81d8945e294442092a2"}], "stats": {"total": 847, "additions": 353, "deletions": 494}, "files": [{"sha": "c2cc106b3e258b68f3fc0ec91166e5be70e5dec2", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -109,13 +109,10 @@ mod write {\n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n     fn mk_intermediate_name(output_path: str, extension: str) -> str unsafe {\n-        let stem = alt str::index(output_path, '.') {\n-                       option::some(dot_pos) {\n-                           str::slice(output_path, 0u, dot_pos)\n-                       }\n-                       option::none { output_path }\n-                   };\n-\n+        let stem = alt str::find_char(output_path, '.') {\n+          some(dot_pos) { str::slice(output_path, 0u, dot_pos) }\n+          none { output_path }\n+        };\n         ret stem + \".\" + extension;\n     }\n \n@@ -566,7 +563,7 @@ fn link_binary(sess: session,\n     // Converts a library file name into a cc -l argument\n     fn unlib(config: @session::config, filename: str) -> str unsafe {\n         let rmlib = fn@(filename: str) -> str {\n-            let found = str::find(filename, \"lib\");\n+            let found = str::find_str(filename, \"lib\");\n             if config.os == session::os_macos ||\n                 (config.os == session::os_linux ||\n                  config.os == session::os_freebsd) &&"}, {"sha": "a7dbe574717b3557d08855ff3f004d8c9990d514", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -157,22 +157,20 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n \n fn get_line(fm: filemap, line: int) -> str unsafe {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n-    let end = alt str::index_from(*fm.src, '\\n', begin, str::len(*fm.src)) {\n+    let end = alt str::find_char_from(*fm.src, '\\n', begin) {\n       some(e) { e }\n       none { str::len(*fm.src) }\n     };\n     str::slice(*fm.src, begin, end)\n }\n \n fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n-    -> {fm: filemap, pos: uint}\n-{\n-    fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n-    let {fm,line} = lookup_line(cm,chpos,lookup);\n+    -> {fm: filemap, pos: uint} {\n+    let {fm, line} = lookup_line(cm, chpos, {|pos| pos.ch});\n     let line_offset = fm.lines[line].byte - fm.start_pos.byte;\n     let col = chpos - fm.lines[line].ch;\n-    let col_offset = str::substr_len(*fm.src, line_offset, col);\n-    ret {fm: fm, pos: line_offset + col_offset};\n+    let col_offset = str::count_bytes(*fm.src, line_offset, col);\n+    {fm: fm, pos: line_offset + col_offset}\n }\n \n fn span_to_snippet(sp: span, cm: codemap::codemap) -> str {"}, {"sha": "7f7d5a387f02c4d065ca47c1ab99d9aa020dd4bf", "filename": "src/comp/syntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -214,7 +214,7 @@ fn finish<T: qq_helper>\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n             let repl = #fmt(\"$%u \", j);\n-            state = skip(str::len_chars(repl));\n+            state = skip(str::char_len(repl));\n             str2 += repl;\n         }\n         alt state {"}, {"sha": "1fedd785750e1a89969c4ad9eef091407dea2c20", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -25,7 +25,7 @@ fn load_errors(testfile: str) -> [expected_error] {\n fn parse_expected(line_num: uint, line: str) -> [expected_error] unsafe {\n     let error_tag = \"//!\";\n     let idx;\n-    alt str::find(line, error_tag) {\n+    alt str::find_str(line, error_tag) {\n          option::none { ret []; }\n          option::some(nn) { idx = (nn as uint) + str::len(error_tag); }\n     }"}, {"sha": "636cf0746a695e04da0364652b395f4e4fe915a3", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -106,7 +106,7 @@ fn parse_name_directive(line: str, directive: str) -> bool {\n fn parse_name_value_directive(line: str,\n                               directive: str) -> option<str> unsafe {\n     let keycolon = directive + \":\";\n-    alt str::find(line, keycolon) {\n+    alt str::find_str(line, keycolon) {\n         option::some(colon) {\n             let value = str::slice(line, colon + str::len(keycolon),\n                                    str::len(line));"}, {"sha": "74fcbf841f4d3cc375054079f260b3a1380ef89f", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -198,7 +198,7 @@ fn check_error_patterns(props: test_props,\n \n     let next_err_idx = 0u;\n     let next_err_pat = props.error_patterns[next_err_idx];\n-    for line: str in str::split_byte(procres.stderr, '\\n' as u8) {\n+    for line: str in str::split_char(procres.stderr, '\\n') {\n         if str::contains(line, next_err_pat) {\n             #debug(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n@@ -245,7 +245,7 @@ fn check_expected_errors(expected_errors: [errors::expected_error],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for line: str in str::split_byte(procres.stderr, '\\n' as u8) {\n+    for line: str in str::split_char(procres.stderr, '\\n') {\n         let was_expected = false;\n         vec::iteri(expected_errors) {|i, ee|\n             if !found_flags[i] {\n@@ -350,7 +350,7 @@ fn split_maybe_args(argstr: option<str>) -> [str] {\n     }\n \n     alt argstr {\n-      option::some(s) { rm_whitespace(str::split_byte(s, ' ' as u8)) }\n+      option::some(s) { rm_whitespace(str::split_char(s, ' ')) }\n       option::none { [] }\n     }\n }\n@@ -410,12 +410,10 @@ fn make_out_name(config: config, testfile: str, extension: str) -> str {\n \n fn output_base_name(config: config, testfile: str) -> str {\n     let base = config.build_base;\n-    let filename =\n-        {\n-            let parts = str::split_byte(fs::basename(testfile), '.' as u8);\n-            parts = vec::slice(parts, 0u, vec::len(parts) - 1u);\n-            str::connect(parts, \".\")\n-        };\n+    let filename = {\n+        let parts = str::split_char(fs::basename(testfile), '.');\n+        str::connect(vec::slice(parts, 0u, vec::len(parts) - 1u), \".\")\n+    };\n     #fmt[\"%s%s.%s\", base, filename, config.stage_id]\n }\n "}, {"sha": "288ae779a2ae0f053252501700c2c03aa1394e87", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -320,16 +320,14 @@ mod rt {\n     fn conv_str(cv: conv, s: str) -> str unsafe {\n         // For strings, precision is the maximum characters\n         // displayed\n-\n-        let unpadded =\n-            alt cv.precision {\n-              count_implied { s }\n-              count_is(max) {\n-                if max as uint < str::len_chars(s) {\n-                    str::substr(s, 0u, max as uint)\n-                } else { s }\n-              }\n-            };\n+        let unpadded = alt cv.precision {\n+          count_implied { s }\n+          count_is(max) {\n+            if max as uint < str::char_len(s) {\n+                str::substr(s, 0u, max as uint)\n+            } else { s }\n+          }\n+        };\n         ret pad(cv, unpadded, pad_nozero);\n     }\n     fn conv_float(cv: conv, f: float) -> str {\n@@ -368,7 +366,7 @@ mod rt {\n                 \"\"\n             } else {\n                 let s = uint::to_str(num, radix);\n-                let len = str::len_chars(s);\n+                let len = str::char_len(s);\n                 if len < prec {\n                     let diff = prec - len;\n                     let pad = str_init_elt(diff, '0');\n@@ -400,7 +398,7 @@ mod rt {\n             uwidth = width as uint;\n           }\n         }\n-        let strlen = str::len_chars(s);\n+        let strlen = str::char_len(s);\n         if uwidth <= strlen { ret s; }\n         let padchar = ' ';\n         let diff = uwidth - strlen;"}, {"sha": "915329292a6f5a7b13792728e303e8b521854ecc", "filename": "src/libcore/str.rs", "status": "modified", "additions": 278, "deletions": 410, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -44,16 +44,15 @@ export\n    to_lower,\n    to_upper,\n    replace,\n-   escape,\n \n    // Comparing strings\n    eq,\n    le,\n    hash,\n \n    // Iterating through strings\n-   all,\n-   any,\n+   all, any,\n+   all_between, any_between,\n    map,\n    bytes_iter,\n    chars_iter,\n@@ -63,14 +62,11 @@ export\n    lines_iter,\n \n    // Searching\n-   //index_chars,\n-   index,\n-   index_from,\n-   rindex,\n-   //rindex_chars,\n-   find,\n-   find_from,\n-   find_chars,\n+   find, find_from, find_between,\n+   rfind, rfind_from, rfind_between,\n+   find_char, find_char_from, find_char_between,\n+   rfind_char, rfind_char_from, rfind_char_between,\n+   find_str, find_str_from, find_str_between,\n    contains,\n    starts_with,\n    ends_with,\n@@ -81,29 +77,23 @@ export\n    is_not_empty,\n    is_whitespace,\n    len,\n-   len_chars,\n+   char_len,\n \n    // Misc\n-   // FIXME: perhaps some more of this section shouldn't be exported?\n    is_utf8,\n-   substr_len,\n-   substr_len_chars,\n+   count_chars, count_bytes,\n    utf8_char_width,\n    char_range_at,\n    is_char_boundary,\n    char_at,\n-   substr_all,\n-   escape_char,\n    as_bytes,\n    as_buf,\n-   //buf,\n    sbuf,\n    reserve,\n \n    unsafe;\n \n \n-\n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn rust_str_push(&s: str, ch: u8);\n@@ -303,46 +293,38 @@ Function: trim_left\n \n Returns a string with leading whitespace removed.\n */\n-fn trim_left(s: str) -> str {\n-    fn count_whities(s: [char]) -> uint {\n-        let i = 0u;\n-        while i < vec::len(s) {\n-            if !char::is_whitespace(s[i]) { break; }\n-            i += 1u;\n-        }\n-        ret i;\n+fn trim_left(+s: str) -> str {\n+    alt find(s, {|c| !char::is_whitespace(c)}) {\n+      none { \"\" }\n+      some(first) {\n+        if first == 0u { s }\n+        else unsafe { unsafe::slice_bytes(s, first, len(s)) }\n+      }\n     }\n-    let chars = chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n }\n \n /*\n Function: trim_right\n \n Returns a string with trailing whitespace removed.\n */\n-fn trim_right(s: str) -> str {\n-    fn count_whities(s: [char]) -> uint {\n-        let i = vec::len(s);\n-        while 0u < i {\n-            if !char::is_whitespace(s[i - 1u]) { break; }\n-            i -= 1u;\n-        }\n-        ret i;\n+fn trim_right(+s: str) -> str {\n+    alt rfind(s, {|c| !char::is_whitespace(c)}) {\n+      none { \"\" }\n+      some(last) {\n+        let {next, _} = char_range_at(s, last);\n+        if next == len(s) { s }\n+        else unsafe { unsafe::slice_bytes(s, 0u, next) }\n+      }\n     }\n-    let chars = chars(s);\n-    let whities = count_whities(chars);\n-    ret from_chars(vec::slice(chars, 0u, whities));\n }\n \n /*\n Function: trim\n \n Returns a string with leading and trailing whitespace removed\n */\n-fn trim(s: str) -> str { trim_left(trim_right(s)) }\n-\n+fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -376,15 +358,11 @@ fn chars(s: str) -> [char] {\n /*\n Function: substr\n \n-Take a substring of another. Returns a string containing `len` bytes\n-starting at char offset `begin`.\n-\n-Failure:\n-\n-If `begin` + `len` is is greater than the char length of the string\n+Take a substring of another. Returns a string containing `n`\n+characters starting at byte offset `begin`.\n */\n-fn substr(s: str, begin: uint, len: uint) -> str {\n-    ret slice(s, begin, begin + len);\n+fn substr(s: str, begin: uint, n: uint) -> str {\n+    slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n // Function: slice\n@@ -633,17 +611,6 @@ fn replace(s: str, from: str, to: str) -> str unsafe {\n     result\n }\n \n-/*\n-Function: escape\n-\n-Escapes special characters inside the string, making it safe for transfer.\n-*/\n-fn escape(s: str) -> str {\n-    let r = \"\";\n-    chars_iter(s) { |c| r += escape_char(c) };\n-    r\n-}\n-\n /*\n Section: Comparing strings\n */\n@@ -670,7 +637,6 @@ String hash function\n fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur.\n-\n     let u: uint = 5381u;\n     for c: u8 in s { u *= 33u; u += c as uint; }\n     ret u;\n@@ -686,8 +652,8 @@ Function: all\n Return true if a predicate matches all characters or\n if the string contains no characters\n */\n-fn all(s: str, it: fn(char) -> bool) -> bool{\n-    ret substr_all(s, 0u, len(s), it);\n+fn all(s: str, it: fn(char) -> bool) -> bool {\n+    all_between(s, 0u, len(s), it)\n }\n \n /*\n@@ -697,7 +663,7 @@ Return true if a predicate matches any character\n (and false if it matches none or there are no characters)\n */\n fn any(ss: str, pred: fn(char) -> bool) -> bool {\n-   !all(ss, {|cc| !pred(cc)})\n+    !all(ss, {|cc| !pred(cc)})\n }\n \n /*\n@@ -708,12 +674,8 @@ Apply a function to each character\n fn map(ss: str, ff: fn(char) -> char) -> str {\n     let result = \"\";\n     reserve(result, len(ss));\n-\n-    chars_iter(ss, {|cc|\n-        str::push_char(result, ff(cc));\n-    });\n-\n-    ret result;\n+    chars_iter(ss) {|cc| str::push_char(result, ff(cc));}\n+    result\n }\n \n /*\n@@ -787,172 +749,192 @@ fn lines_iter(ss: str, ff: fn(&&str)) {\n Section: Searching\n */\n \n-// Function: index\n+// Function: find_char\n //\n // Returns the byte index of the first matching char\n // (as option some/none)\n-fn index(ss: str, cc: char) -> option<uint> {\n-    index_from(ss, cc, 0u, len(ss))\n+fn find_char(s: str, c: char) -> option<uint> {\n+    find_char_between(s, c, 0u, len(s))\n }\n \n-// Function: index_from\n+// Function: find_char_from\n //\n // Returns the byte index of the first matching char\n-// (as option some/none), starting at `nn`\n-fn index_from(ss: str, cc: char, start: uint, end: uint) -> option<uint> {\n-    let bii = start;\n-    while bii < end {\n-        let {ch, next} = char_range_at(ss, bii);\n-\n-        // found here?\n-        if ch == cc {\n-            ret some(bii);\n-        }\n+// (as option some/none), starting from `start`\n+fn find_char_from(s: str, c: char, from: uint) -> option<uint> {\n+    find_char_between(s, c, from, len(s))\n+}\n \n-        bii = next;\n+// Function: find_char_between\n+//\n+// Returns the byte index of the first matching char\n+// (as option some/none), between `start` and `end`\n+fn find_char_between(s: str, c: char, start: uint, end: uint)\n+    -> option<uint> {\n+    if c < 128u as char {\n+        assert start <= end;\n+        assert end <= len(s);\n+        let i = start, b = c as u8;\n+        while i < end {\n+            if s[i] == b { ret some(i); }\n+            i += 1u;\n+        }\n+        ret none;\n+    } else {\n+        find_between(s, start, end, {|x| x == c})\n     }\n-\n-    // wasn't found\n-    ret none;\n }\n \n-// Function: index_chars\n+// Function: rfind_char\n //\n-// Returns the char index of the first matching char\n+// Returns the byte index of the last matching char\n // (as option some/none)\n-// FIXME: delete?\n-fn index_chars(ss: str, cc: char) -> option<uint> {\n-    let bii = 0u;\n-    let cii = 0u;\n-    let len = len(ss);\n-    while bii < len {\n-        let {ch, next} = char_range_at(ss, bii);\n+fn rfind_char(s: str, c: char) -> option<uint> {\n+    rfind_char_between(s, c, len(s), 0u)\n+}\n \n-        // found here?\n-        if ch == cc {\n-            ret some(cii);\n-        }\n+// Function: rfind_char_from\n+//\n+// Returns the byte index of the last matching char\n+// (as option some/none), starting from `start`\n+fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n+    rfind_char_between(s, c, start, 0u)\n+}\n \n-        cii += 1u;\n-        bii = next;\n+// Function: rfind_char_between\n+//\n+// Returns the byte index of the last matching char (as option\n+// some/none), between from `start` and `end` (start must be greater\n+// than or equal to end)\n+fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n+    -> option<uint> {\n+    if c < 128u as char {\n+        assert start >= end;\n+        assert start <= len(s);\n+        let i = start, b = c as u8;\n+        while i > end {\n+            i -= 1u;\n+            if s[i] == b { ret some(i); }\n+        }\n+        ret none;\n+    } else {\n+        rfind_between(s, start, end, {|x| x == c})\n     }\n+}\n \n-    // wasn't found\n-    ret none;\n+// Function: find\n+//\n+// Returns, as an option, the first character that passes the given\n+// predicate\n+fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n+    find_between(s, 0u, len(s), f)\n }\n \n-// Function: rindex\n+// Function: find_from\n //\n-// Returns the byte index of the first matching char\n-// (as option some/none)\n-fn rindex(ss: str, cc: char) -> option<uint> {\n-    let bii = len(ss);\n-    while bii > 0u {\n-        let {ch, prev} = char_range_at_reverse(ss, bii);\n-        bii = prev;\n-\n-        // found here?\n-        if ch == cc {\n-            ret some(bii);\n-        }\n-    }\n+// Returns, as an option, the first character that passes the given\n+// predicate, starting at byte offset `start`\n+fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+    find_between(s, start, len(s), f)\n+}\n \n-    // wasn't found\n+// Function: find_between\n+//\n+// Returns, as an option, the first character that passes the given\n+// predicate, between byte offsets `start` and `end`\n+fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+    -> option<uint> {\n+    assert start <= end;\n+    assert end <= len(s);\n+    assert is_char_boundary(s, start);\n+    let i = start;\n+    while i < end {\n+        let {ch, next} = char_range_at(s, i);\n+        if f(ch) { ret some(i); }\n+        i = next;\n+    }\n     ret none;\n }\n \n-// Function: rindex_chars\n+// Function: rfind\n //\n-// Returns the char index of the first matching char\n-// (as option some/none)\n-// FIXME: delete?\n-fn rindex_chars(ss: str, cc: char) -> option<uint> {\n-    let bii = len(ss);\n-    let cii = len_chars(ss);\n-    while bii > 0u {\n-        let {ch, prev} = char_range_at_reverse(ss, bii);\n-        cii -= 1u;\n-        bii = prev;\n-\n-        // found here?\n-        if ch == cc {\n-            ret some(cii);\n-        }\n-    }\n+// Returns, as an option, the last character in the string that passes\n+// the given predicate\n+fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n+    rfind_between(s, len(s), 0u, f)\n+}\n \n-    // wasn't found\n+// Function: rfind_from\n+//\n+// Returns, as an option, the last character that passes the given\n+// predicate, up until byte offset `start`\n+fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+    rfind_between(s, start, 0u, f)\n+}\n+\n+// Function: rfind_between\n+//\n+// Returns, as an option, the last character that passes the given\n+// predicate, between byte offsets `start` and `end` (`start` must be\n+// greater than or equal to `end`)\n+fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+    -> option<uint> {\n+    assert start >= end;\n+    assert start <= len(s);\n+    assert is_char_boundary(s, start);\n+    let i = start;\n+    while i > end {\n+        let {ch, prev} = char_range_at_reverse(s, i);\n+        if f(ch) { ret some(prev); }\n+        i = prev;\n+    }\n     ret none;\n }\n \n-//Function: find\n+// Utility used by various searching functions\n+fn match_at(haystack: str, needle: str, at: uint) -> bool {\n+    let i = at;\n+    for c in needle { if haystack[i] != c { ret false; } i += 1u; }\n+    ret true;\n+}\n+\n+//Function: find_str\n //\n // Find the byte position of the first instance of one string\n // within another, or return option::none\n-fn find(haystack: str, needle: str) -> option<uint> {\n-    find_from(haystack, needle, 0u, len(haystack))\n+fn find_str(haystack: str, needle: str) -> option<uint> {\n+    find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n-//Function: find_from\n+//Function: find_str_from\n //\n // Find the byte position of the first instance of one string\n // within another, or return option::none\n+fn find_str_from(haystack: str, needle: str, start: uint)\n+  -> option<uint> {\n+    find_str_between(haystack, needle, start, len(haystack))\n+}\n+\n+//Function: find_str_between\n //\n-// FIXME: Boyer-Moore should be significantly faster\n-fn find_from(haystack: str, needle: str, start: uint, end:uint)\n+// Find the byte position of the first instance of one string\n+// within another, or return option::none\n+fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n   -> option<uint> {\n+    // FIXME: Boyer-Moore should be significantly faster\n     assert end <= len(haystack);\n-\n     let needle_len = len(needle);\n-\n     if needle_len == 0u { ret some(start); }\n     if needle_len > end { ret none; }\n \n-    fn match_at(haystack: str, needle: str, ii: uint) -> bool {\n-        let jj = ii;\n-        for c: u8 in needle { if haystack[jj] != c { ret false; } jj += 1u; }\n-        ret true;\n-    }\n-\n-    let ii = start;\n-    while ii <= end - needle_len {\n-        if match_at(haystack, needle, ii) { ret some(ii); }\n-        ii += 1u;\n+    let i = start, e = end - needle_len;\n+    while i <= e {\n+        if match_at(haystack, needle, i) { ret some(i); }\n+        i += 1u;\n     }\n-\n     ret none;\n }\n \n-// Function: find_chars\n-//\n-// Find the char position of the first instance of one string\n-// within another, or return option::none\n-// FIXME: delete?\n-fn find_chars(haystack: str, needle: str) -> option<uint> {\n-   alt find(haystack, needle) {\n-      none { ret none; }\n-      some(nn) { ret some(b2c_pos(haystack, nn)); }\n-   }\n-}\n-\n-// Function: b2c_pos\n-//\n-// Convert a byte position into a char position\n-// within a given string\n-fn b2c_pos(ss: str, bpos: uint) -> uint {\n-   assert bpos == 0u || bpos < len(ss);\n-\n-   let ii = 0u;\n-   let cpos = 0u;\n-\n-   while ii < bpos {\n-      let sz = utf8_char_width(ss[ii]);\n-      ii += sz;\n-      cpos += 1u;\n-   }\n-\n-   ret cpos;\n-}\n-\n /*\n Function: contains\n \n@@ -964,7 +946,7 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn contains(haystack: str, needle: str) -> bool {\n-    option::is_some(find(haystack, needle))\n+    option::is_some(find_str(haystack, needle))\n }\n \n /*\n@@ -978,11 +960,10 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn starts_with(haystack: str, needle: str) -> bool unsafe {\n-    let haystack_len: uint = len(haystack);\n-    let needle_len: uint = len(needle);\n-    if needle_len == 0u { ret true; }\n-    if needle_len > haystack_len { ret false; }\n-    ret eq(unsafe::slice_bytes(haystack, 0u, needle_len), needle);\n+    let haystack_len = len(haystack), needle_len = len(needle);\n+    if needle_len == 0u { true }\n+    else if needle_len > haystack_len { false }\n+    else { match_at(haystack, needle, 0u) }\n }\n \n /*\n@@ -994,16 +975,10 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn ends_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = len(haystack);\n-    let needle_len: uint = len(needle);\n-    ret if needle_len == 0u {\n-            true\n-        } else if needle_len > haystack_len {\n-            false\n-        } else {\n-            eq(substr(haystack, haystack_len - needle_len, needle_len),\n-               needle)\n-        };\n+    let haystack_len = len(haystack), needle_len = len(needle);\n+    if needle_len == 0u { true }\n+    else if needle_len > haystack_len { false }\n+    else { match_at(haystack, needle, haystack_len - needle_len) }\n }\n \n /*\n@@ -1054,10 +1029,10 @@ pure fn len(s: str) -> uint unsafe {\n     (*repr).fill - 1u\n }\n \n-// FIXME: delete?\n-fn len_chars(s: str) -> uint {\n-    substr_len_chars(s, 0u, len(s))\n-}\n+// Function: char_len\n+//\n+// Returns the number of characters that a string holds\n+fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n@@ -1086,68 +1061,44 @@ fn is_utf8(v: [u8]) -> bool {\n }\n \n /*\n-Function: substr_len_chars\n+Function: count_chars\n \n As char_len but for a slice of a string\n \n Parameters:\n  s           - A valid string\n- byte_start  - The position inside `s` where to start counting in bytes.\n- byte_len    - The number of bytes of `s` to take into account.\n+ start       - The position inside `s` where to start counting in bytes.\n+ end         - The position where to stop counting\n \n Returns:\n- The number of Unicode characters in `s` in\n-segment [byte_start, byte_start+len( .\n-\n-Safety note:\n-- This function does not check whether the substring is valid.\n-- This function fails if `byte_offset` or `byte_len` do not\n- represent valid positions inside `s`\n-\n-FIXME: delete?\n+ The number of Unicode characters in `s` between the given indices.\n */\n-fn substr_len_chars(s: str, byte_start: uint, byte_len: uint) -> uint {\n-    let i         = byte_start;\n-    let byte_stop = i + byte_len;\n-    let len   = 0u;\n-    while i < byte_stop {\n-        let chsize = utf8_char_width(s[i]);\n-        assert (chsize > 0u);\n+fn count_chars(s: str, start: uint, end: uint) -> uint {\n+    assert is_char_boundary(s, start);\n+    assert is_char_boundary(s, end);\n+    let i = start, len = 0u;\n+    while i < end {\n+        let {next, _} = char_range_at(s, i);\n         len += 1u;\n-        i += chsize;\n+        i = next;\n     }\n     ret len;\n }\n \n-/*\n-Function: substr_len\n-\n-As byte_len but for a substring\n-\n-Parameters:\n-s - A string\n-byte_offset - The byte offset at which to start in the string\n-char_len    - The number of chars (not bytes!) in the range\n-\n-Returns:\n-The number of bytes in the substring starting at `byte_offset` and\n-containing `char_len` chars.\n-\n-Safety note:\n-\n-This function fails if `byte_offset` or `char_len` do not represent\n-valid positions in `s`\n-*/\n-fn substr_len(s: str, byte_offset: uint, char_len: uint) -> uint {\n-    let i = byte_offset;\n-    let chars = 0u;\n-    while chars < char_len {\n-        let chsize = utf8_char_width(s[i]);\n-        assert (chsize > 0u);\n-        i += chsize;\n-        chars += 1u;\n+// Function count_bytes\n+//\n+// Counts the number of bytes taken by the `n` in `s` starting from\n+// `start`.\n+fn count_bytes(s: str, start: uint, n: uint) -> uint {\n+    assert is_char_boundary(s, start);\n+    let end = start, cnt = n, l = len(s);\n+    while cnt > 0u {\n+        assert end < l;\n+        let {next, _} = char_range_at(s, end);\n+        cnt -= 1u;\n+        end = next;\n     }\n-    ret i - byte_offset;\n+    end - start\n }\n \n /*\n@@ -1159,17 +1110,27 @@ Given a first byte, determine how many bytes are in this UTF-8 character\n pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { ret 1u; }\n-    if byte < 192u {\n-        ret 0u; // Not a valid start byte\n-\n-    }\n+    // Not a valid start byte\n+    if byte < 192u { ret 0u; }\n     if byte < 224u { ret 2u; }\n     if byte < 240u { ret 3u; }\n     if byte < 248u { ret 4u; }\n     if byte < 252u { ret 5u; }\n     ret 6u;\n }\n \n+/*\n+Function is_char_boundary\n+\n+Returns false if the index points into the middle of a multi-byte\n+character sequence.\n+*/\n+pure fn is_char_boundary(s: str, index: uint) -> bool {\n+    if index == len(s) { ret true; }\n+    let b = s[index];\n+    ret b < 128u8 || b >= 192u8;\n+}\n+\n /*\n Function: char_range_at\n \n@@ -1235,18 +1196,6 @@ fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     ret {ch: val as char, next: i};\n }\n \n-/*\n-Function is_char_boundary\n-\n-Returns false if the index points into the middle of a multi-byte\n-character sequence.\n-*/\n-pure fn is_char_boundary(s: str, index: uint) -> bool {\n-    if index == len(s) { ret true; }\n-    let b = s[index];\n-    ret b < 128u8 || b >= 192u8;\n-}\n-\n /*\n Function: char_at\n \n@@ -1274,14 +1223,14 @@ fn char_range_at_reverse(ss: str, start: uint) -> {ch: char, prev: uint} {\n }\n \n /*\n-Function: substr_all\n+Function: all_between\n \n Loop through a substring, char by char\n \n Parameters:\n s           - A string to traverse. It may be empty.\n-byte_offset - The byte offset at which to start in the string.\n-byte_len    - The number of bytes to traverse in the string\n+start       - The byte offset at which to start in the string.\n+end         - The end of the range to traverse\n it          - A block to execute with each consecutive character of `s`.\n Return `true` to continue, `false` to stop.\n \n@@ -1295,34 +1244,19 @@ Safety note:\n - This function fails if `byte_offset` or `byte_len` do not\n  represent valid positions inside `s`\n  */\n-fn substr_all(s: str, byte_offset: uint, byte_len: uint,\n-              it: fn(char) -> bool) -> bool {\n-   let i = byte_offset;\n-   let result = true;\n-   while i < byte_len {\n-      let {ch, next} = char_range_at(s, i);\n-      if !it(ch) {result = false; break;}\n-      i = next;\n-   }\n-   ret result;\n+fn all_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n+    assert is_char_boundary(s, start);\n+    let i = start;\n+    while i < end {\n+        let {ch, next} = char_range_at(s, i);\n+        if !it(ch) { ret false; }\n+        i = next;\n+    }\n+    ret true;\n }\n \n-\n-/*\n-Function: escape_char\n-\n-Escapes a single character.\n-*/\n-fn escape_char(c: char) -> str {\n-    alt c {\n-      '\"' { \"\\\\\\\"\" }\n-      '\\\\' { \"\\\\\\\\\" }\n-      '\\n' { \"\\\\n\" }\n-      '\\t' { \"\\\\t\" }\n-      '\\r' { \"\\\\r\" }\n-      '\\x00' to '\\x1f' { #fmt[\"\\\\x%02x\", c as uint] }\n-      v { from_char(c) }\n-    }\n+fn any_between(s: str, start: uint, end: uint, it: fn(char) -> bool) -> bool {\n+    !all_between(s, start, end, {|c| !it(c)})\n }\n \n // UTF-8 tags and ranges\n@@ -1395,7 +1329,6 @@ mod unsafe {\n       from_bytes,\n       from_byte,\n       slice_bytes,\n-      slice_bytes_safe_range,\n       push_byte,\n       push_bytes,\n       pop_byte,\n@@ -1441,18 +1374,6 @@ mod unsafe {\n        ret s;\n    }\n \n-   /*\n-   Function: slice_bytes_safe_range\n-\n-   Like slice_bytes, with a precondition\n-   */\n-   unsafe fn slice_bytes_safe_range(s: str, begin: uint, end: uint)\n-       : uint::le(begin, end) -> str {\n-       // would need some magic to make this a precondition\n-       assert (end <= len(s));\n-       ret slice_bytes(s, begin, end);\n-   }\n-\n    // Function: push_byte\n    //\n    // Appends a byte to a string. (Not UTF-8 safe).\n@@ -1488,7 +1409,7 @@ mod unsafe {\n        s = unsafe::slice_bytes(s, 1u, len);\n        ret b;\n    }\n-    \n+\n     unsafe fn set_len(&v: str, new_len: uint) {\n         let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(v);\n         (*repr).fill = new_len + 1u;\n@@ -1526,39 +1447,23 @@ mod tests {\n         assert (len(\"\\u2620\") == 3u);\n         assert (len(\"\\U0001d11e\") == 4u);\n \n-        assert (len_chars(\"\") == 0u);\n-        assert (len_chars(\"hello world\") == 11u);\n-        assert (len_chars(\"\\x63\") == 1u);\n-        assert (len_chars(\"\\xa2\") == 1u);\n-        assert (len_chars(\"\\u03c0\") == 1u);\n-        assert (len_chars(\"\\u2620\") == 1u);\n-        assert (len_chars(\"\\U0001d11e\") == 1u);\n-        assert (len_chars(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u);\n+        assert (char_len(\"\") == 0u);\n+        assert (char_len(\"hello world\") == 11u);\n+        assert (char_len(\"\\x63\") == 1u);\n+        assert (char_len(\"\\xa2\") == 1u);\n+        assert (char_len(\"\\u03c0\") == 1u);\n+        assert (char_len(\"\\u2620\") == 1u);\n+        assert (char_len(\"\\U0001d11e\") == 1u);\n+        assert (char_len(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\") == 19u);\n     }\n \n     #[test]\n-    fn test_index_chars() {\n-        assert ( index_chars(\"hello\", 'h') == some(0u));\n-        assert ( index_chars(\"hello\", 'e') == some(1u));\n-        assert ( index_chars(\"hello\", 'o') == some(4u));\n-        assert ( index_chars(\"hello\", 'z') == none);\n-    }\n-\n-    #[test]\n-    fn test_rindex() {\n-        assert rindex(\"hello\", 'l') == some(3u);\n-        assert rindex(\"hello\", 'o') == some(4u);\n-        assert rindex(\"hello\", 'h') == some(0u);\n-        assert rindex(\"hello\", 'z') == none;\n-        assert rindex(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == some(30u);\n-    }\n-\n-    #[test]\n-    fn test_rindex_chars() {\n-        assert (rindex_chars(\"hello\", 'l') == some(3u));\n-        assert (rindex_chars(\"hello\", 'o') == some(4u));\n-        assert (rindex_chars(\"hello\", 'h') == some(0u));\n-        assert (rindex_chars(\"hello\", 'z') == none);\n+    fn test_rfind_char() {\n+        assert rfind_char(\"hello\", 'l') == some(3u);\n+        assert rfind_char(\"hello\", 'o') == some(4u);\n+        assert rfind_char(\"hello\", 'h') == some(0u);\n+        assert rfind_char(\"hello\", 'z') == none;\n+        assert rfind_char(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e') == some(30u);\n     }\n \n     #[test]\n@@ -1752,67 +1657,45 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_find() {\n+    fn test_find_str() {\n         // byte positions\n-        assert (find(\"banana\", \"apple pie\") == none);\n-        assert (find(\"\", \"\") == some(0u));\n+        assert find_str(\"banana\", \"apple pie\") == none;\n+        assert find_str(\"\", \"\") == some(0u);\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert (find(data, \"\")     == some(0u));\n-        assert (find(data, \"\u0e1b\u0e23\u0e30\u0e40\") == some( 0u));\n-        assert (find(data, \"\u0e30\u0e40\")   == some( 6u));\n-        assert (find(data, \"\u4e2d\u534e\") == some(27u));\n-        assert (find(data, \"\u0e44\u0e17\u534e\") == none);\n+        assert find_str(data, \"\")     == some(0u);\n+        assert find_str(data, \"\u0e1b\u0e23\u0e30\u0e40\") == some( 0u);\n+        assert find_str(data, \"\u0e30\u0e40\")   == some( 6u);\n+        assert find_str(data, \"\u4e2d\u534e\") == some(27u);\n+        assert find_str(data, \"\u0e44\u0e17\u534e\") == none;\n     }\n \n     #[test]\n-    fn test_find_from() {\n+    fn test_find_str_between() {\n         // byte positions\n-        assert (find_from(\"\", \"\", 0u, 0u) == some(0u));\n+        assert find_str_between(\"\", \"\", 0u, 0u) == some(0u);\n \n         let data = \"abcabc\";\n-        assert find_from(data, \"ab\", 0u, 6u) == some(0u);\n-        assert find_from(data, \"ab\", 2u, 6u) == some(3u);\n-        assert find_from(data, \"ab\", 2u, 4u) == none;\n+        assert find_str_between(data, \"ab\", 0u, 6u) == some(0u);\n+        assert find_str_between(data, \"ab\", 2u, 6u) == some(3u);\n+        assert find_str_between(data, \"ab\", 2u, 4u) == none;\n \n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         data += data;\n-        assert find_from(data, \"\", 0u, 43u) == some(0u);\n-        assert find_from(data, \"\", 6u, 43u) == some(6u);\n+        assert find_str_between(data, \"\", 0u, 43u) == some(0u);\n+        assert find_str_between(data, \"\", 6u, 43u) == some(6u);\n \n-        assert find_from(data, \"\u0e1b\u0e23\u0e30\", 0u, 43u) == some( 0u);\n-        assert find_from(data, \"\u0e17\u0e28\u0e44\", 0u, 43u) == some(12u);\n-        assert find_from(data, \"\u0e22\u4e2d\", 0u, 43u) == some(24u);\n-        assert find_from(data, \"i\u1ec7t\", 0u, 43u) == some(34u);\n-        assert find_from(data, \"Nam\", 0u, 43u) == some(40u);\n+        assert find_str_between(data, \"\u0e1b\u0e23\u0e30\", 0u, 43u) == some( 0u);\n+        assert find_str_between(data, \"\u0e17\u0e28\u0e44\", 0u, 43u) == some(12u);\n+        assert find_str_between(data, \"\u0e22\u4e2d\", 0u, 43u) == some(24u);\n+        assert find_str_between(data, \"i\u1ec7t\", 0u, 43u) == some(34u);\n+        assert find_str_between(data, \"Nam\", 0u, 43u) == some(40u);\n \n-        assert find_from(data, \"\u0e1b\u0e23\u0e30\", 43u, 86u) == some(43u);\n-        assert find_from(data, \"\u0e17\u0e28\u0e44\", 43u, 86u) == some(55u);\n-        assert find_from(data, \"\u0e22\u4e2d\", 43u, 86u) == some(67u);\n-        assert find_from(data, \"i\u1ec7t\", 43u, 86u) == some(77u);\n-        assert find_from(data, \"Nam\", 43u, 86u) == some(83u);\n-    }\n-\n-    #[test]\n-    fn test_find_chars() {\n-        // char positions\n-        assert (find_chars(\"banana\", \"apple pie\") == none);\n-        assert (find_chars(\"\", \"\") == some(0u));\n-\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert (find_chars(data, \"\")     == some(0u));\n-        assert (find_chars(data, \"\u0e1b\u0e23\u0e30\u0e40\") == some(0u));\n-        assert (find_chars(data, \"\u0e30\u0e40\")   == some(2u));\n-        assert (find_chars(data, \"\u4e2d\u534e\") == some(9u));\n-        assert (find_chars(data, \"\u0e44\u0e17\u534e\") == none);\n-    }\n-\n-    #[test]\n-    fn test_b2c_pos() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert 0u == b2c_pos(data, 0u);\n-        assert 2u == b2c_pos(data, 6u);\n-        assert 9u == b2c_pos(data, 27u);\n+        assert find_str_between(data, \"\u0e1b\u0e23\u0e30\", 43u, 86u) == some(43u);\n+        assert find_str_between(data, \"\u0e17\u0e28\u0e44\", 43u, 86u) == some(55u);\n+        assert find_str_between(data, \"\u0e22\u4e2d\", 43u, 86u) == some(67u);\n+        assert find_str_between(data, \"i\u1ec7t\", 43u, 86u) == some(77u);\n+        assert find_str_between(data, \"Nam\", 43u, 86u) == some(83u);\n     }\n \n     #[test]\n@@ -1822,9 +1705,7 @@ mod tests {\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n-\n-        assert \"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\"\n-            == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 18u);\n+        assert \"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\" == substr(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", 6u, 6u);\n     }\n \n     #[test]\n@@ -2312,19 +2193,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn test_escape() {\n-        assert(escape(\"abcdef\") == \"abcdef\");\n-        assert(escape(\"abc\\\\def\") == \"abc\\\\\\\\def\");\n-        assert(escape(\"abc\\ndef\") == \"abc\\\\ndef\");\n-        assert(escape(\"abc\\\"def\") == \"abc\\\\\\\"def\");\n-    }\n-\n-    #[test]\n-    fn test_escape_char() {\n-        assert escape_char('\\x1f') == \"\\\\x1f\";\n-    }\n-\n     #[test]\n     fn test_map() {\n         assert \"\" == map(\"\", char::to_upper);"}, {"sha": "dab88080e5560cff96ce8fd525bf449d22a523e0", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -33,19 +33,15 @@ A path or fragment of a filesystem path\n type path = str;\n \n fn splitDirnameBasename (pp: path) -> {dirname: str, basename: str} {\n-    let ii;\n-    alt str::rindex(pp, os_fs::path_sep) {\n-        option::some(xx) { ii = xx; }\n-        option::none {\n-            alt str::rindex(pp, os_fs::alt_path_sep) {\n-                option::some(xx) { ii = xx; }\n-                option::none { ret {dirname: \".\", basename: pp}; }\n-            }\n-        }\n+    alt str::rfind(pp, {|ch|\n+        ch == os_fs::path_sep || ch == os_fs::alt_path_sep\n+    }) {\n+      some(i) {\n+        {dirname: str::slice(pp, 0u, i),\n+         basename: str::slice(pp, i + 1u, str::len(pp))}\n+      }\n+      none { {dirname: \".\", basename: pp} }\n     }\n-\n-    ret {dirname: str::slice(pp, 0u, ii),\n-         basename: str::slice(pp, ii + 1u, str::len(pp))};\n }\n \n /*"}, {"sha": "8de15a60c8744ec3e5f615ab7078af6118d49ff7", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -3,10 +3,6 @@\n \n import float;\n import map;\n-import core::option;\n-import option::{some, none};\n-import str;\n-import vec;\n \n export json;\n export to_str;"}, {"sha": "6b9f7a17f74cc75dfc59c06218d8dde0c49c7040", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -743,7 +743,7 @@ mod node {\n      */\n     fn of_substr(str: @str, byte_start: uint, byte_len: uint) -> @node {\n         ret of_substr_unsafer(str, byte_start, byte_len,\n-                  str::substr_len_chars(*str, byte_start, byte_len));\n+                              str::count_chars(*str, byte_start, byte_len));\n     }\n \n     /*\n@@ -795,7 +795,7 @@ mod node {\n                     if i == 0u  { first_leaf_char_len }\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n-                    str::substr_len(*str, offset, chunk_char_len);\n+                    str::count_bytes(*str, offset, chunk_char_len);\n                 nodes[i] = @leaf({\n                     byte_offset: offset,\n                     byte_len:    chunk_byte_len,\n@@ -998,7 +998,7 @@ mod node {\n             alt(*node) {\n               node::leaf(x) {\n                 let char_len =\n-                    str::substr_len_chars(*x.content, byte_offset, byte_len);\n+                    str::count_chars(*x.content, byte_offset, byte_len);\n                 ret @leaf({byte_offset: byte_offset,\n                                 byte_len:    byte_len,\n                                 char_len:    char_len,\n@@ -1059,9 +1059,9 @@ mod node {\n                     ret node;\n                 }\n                 let byte_offset =\n-                    str::substr_len(*x.content, 0u, char_offset);\n+                    str::count_bytes(*x.content, 0u, char_offset);\n                 let byte_len    =\n-                    str::substr_len(*x.content, byte_offset, char_len);\n+                    str::count_bytes(*x.content, byte_offset, char_len);\n                 ret @leaf({byte_offset: byte_offset,\n                            byte_len:    byte_len,\n                            char_len:    char_len,\n@@ -1138,9 +1138,9 @@ mod node {\n \n     fn loop_chars(node: @node, it: fn(char) -> bool) -> bool {\n         ret loop_leaves(node, {|leaf|\n-            ret str::substr_all(*leaf.content,\n-                                    leaf.byte_offset,\n-                                    leaf.byte_len, it)\n+            ret str::all_between(*leaf.content,\n+                                 leaf.byte_offset,\n+                                 leaf.byte_len, it)\n         })\n     }\n \n@@ -1373,7 +1373,7 @@ mod tests {\n         let sample = @\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert char_len(r) == str::len_chars(*sample);\n+        assert char_len(r) == str::char_len(*sample);\n         assert rope_to_string(r) == *sample;\n     }\n \n@@ -1384,7 +1384,7 @@ mod tests {\n         while i < 10 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;\n         let r      = of_str(sample);\n-        assert char_len(r) == str::len_chars(*sample);\n+        assert char_len(r) == str::char_len(*sample);\n         assert rope_to_string(r) == *sample;\n \n         let string_iter = 0u;\n@@ -1427,7 +1427,7 @@ mod tests {\n             }\n         }\n \n-        assert len == str::len_chars(*sample);\n+        assert len == str::char_len(*sample);\n     }\n \n     #[test]"}, {"sha": "f5c8d95c65a6b6a336ebaaa4b3c84135b93219d5", "filename": "src/rustdoc/desc_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Frustdoc%2Fdesc_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Frustdoc%2Fdesc_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_pass.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -282,7 +282,7 @@ mod test {\n         astsrv::from_str(source) {|srv|\n             let doc = extract::from_srv(srv, \"\");\n             let doc = attr_pass::mk_pass()(srv, doc);\n-            mk_pass(str::trim)(srv, doc)\n+            mk_pass({|s| str::trim(s)})(srv, doc)\n         }\n     }\n }\n\\ No newline at end of file"}, {"sha": "c81bba6fda50140c886601002e5838531f6f2be0", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -56,10 +56,10 @@ fn should_write_modules_last() {\n          fn d() { }\"\n     );\n \n-    let idx_a = option::get(str::find(markdown, \"# Module `a`\"));\n-    let idx_b = option::get(str::find(markdown, \"## Function `b`\"));\n-    let idx_c = option::get(str::find(markdown, \"# Module `c`\"));\n-    let idx_d = option::get(str::find(markdown, \"## Function `d`\"));\n+    let idx_a = option::get(str::find_str(markdown, \"# Module `a`\"));\n+    let idx_b = option::get(str::find_str(markdown, \"## Function `b`\"));\n+    let idx_c = option::get(str::find_str(markdown, \"# Module `c`\"));\n+    let idx_d = option::get(str::find_str(markdown, \"## Function `d`\"));\n \n     assert idx_b < idx_d;\n     assert idx_d < idx_a;"}, {"sha": "aabb60c396e2d2e19e6a514323d1c52224a3ff68", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -10,7 +10,7 @@ is interpreted as the brief description.\n export mk_pass;\n \n fn mk_pass() -> pass {\n-    desc_pass::mk_pass(str::trim)\n+    desc_pass::mk_pass({|s| str::trim(s)})\n }\n \n #[test]"}, {"sha": "7cf23192dee41f723de8e2dfe8b032a1b2056835", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -33,7 +33,7 @@ fn read_grid(f: io::reader) -> grid_t {\n \n     let g = vec::init_fn(10u, {|_i| vec::init_elt_mut(10u, 0 as u8) });\n     while !f.eof() {\n-        let comps = str::split_byte(str::trim(f.read_line()), ',' as u8);\n+        let comps = str::split_char(str::trim(f.read_line()), ',');\n         if vec::len(comps) >= 3u {\n             let row     = option::get(uint::from_str(comps[0])) as u8;\n             let col     = option::get(uint::from_str(comps[1])) as u8;"}, {"sha": "2843ef93ea6c0121cdd9fc5c6aa76108e1270466", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -3,7 +3,8 @@ use std;\n import str::*;\n \n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 4u;\n     let b: uint = 1u;\n-    log(error, str::unsafe::slice_bytes_safe_range(\"kitties\", a, b));\n+    log(error, foo(a, b));\n }"}, {"sha": "27bccac911ef1324e1c0c3dc44f2e41f2d4141b2", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -1,6 +1,7 @@\n // error-pattern:Unsatisfied precondition constraint (for example, uint::le\n \n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 1u;\n     let b: uint = 4u;\n     let c: uint = 5u;\n@@ -13,5 +14,5 @@ fn main() unsafe {\n     // the next statement, since it's not true in the\n     // prestate.\n     let d <- a;\n-    log(debug, str::unsafe::slice_bytes_safe_range(\"kitties\", b, d));\n+    log(debug, foo(b, d));\n }"}, {"sha": "f24d96e13cc96c696fa405d16e0130bc928ae418", "filename": "src/test/run-fail/fn-constraint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -1,8 +1,9 @@\n // error-pattern:Predicate uint::le(a, b) failed\n \n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 4u;\n     let b: uint = 1u;\n     check (uint::le(a, b));\n-    log(error, str::unsafe::slice_bytes_safe_range(\"kitties\", a, b));\n+    log(error, foo(a, b));\n }"}, {"sha": "c737628b0c4b528f1a9c0809da677edc1d43ca1a", "filename": "src/test/run-pass/constraint-prop-expr-move.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -1,9 +1,10 @@\n \n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 1u;\n     let b: uint = 4u;\n     let c: uint = 17u;\n     check (uint::le(a, b));\n     c <- a;\n-    log(debug, str::unsafe::slice_bytes_safe_range(\"kitties\", c, b));\n+    log(debug, foo(c, b));\n }"}, {"sha": "a07b60799e887250af896beb8d4a824c70860b89", "filename": "src/test/run-pass/constraint-prop-move.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -1,7 +1,8 @@\n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 1u;\n     let b: uint = 4u;\n     check (uint::le(a, b));\n     let c <- a;\n-    log(debug, str::unsafe::slice_bytes_safe_range(\"kitties\", c, b));\n+    log(debug, foo(c, b));\n }"}, {"sha": "59202911a9a6550aab92736126a854c59b876c55", "filename": "src/test/run-pass/constraint-prop-swap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -1,7 +1,8 @@\n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 4u;\n     let b: uint = 1u;\n     check (uint::le(b, a));\n     b <-> a;\n-    log(debug, str::unsafe::slice_bytes_safe_range(\"kitties\", a, b));\n+    log(debug, foo(a, b));\n }"}, {"sha": "6d5808be3d1750c2fd89812f31e50d86c83bc995", "filename": "src/test/run-pass/constraint-prop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -1,7 +1,8 @@\n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 1u;\n     let b: uint = 4u;\n-    check (uint::le(a, b));\n+    check uint::le(a, b);\n     let c = b;\n-    log(debug, str::unsafe::slice_bytes_safe_range(\"kitties\", a, c));\n+    log(debug, foo(a, c));\n }"}, {"sha": "476a6b74a3d83853ccc362912c2d5bad13108eb4", "filename": "src/test/run-pass/fn-constraint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -1,6 +1,7 @@\n fn main() unsafe {\n+    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n     let a: uint = 1u;\n     let b: uint = 4u;\n     check (uint::le(a, b));\n-    log(debug, str::unsafe::slice_bytes_safe_range(\"kitties\", a, b));\n+    log(debug, foo(a, b));\n }"}, {"sha": "ed3da9bf53b633d5f0b37033bdbf6052196d1c72", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780f8277f44bb2eddaf6c516d60b0a6b9b557a5b/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=780f8277f44bb2eddaf6c516d60b0a6b9b557a5b", "patch": "@@ -8,8 +8,8 @@ fn main() {\n     let s: str = str::from_chars(chs);\n \n     assert (str::len(s) == 10u);\n-    assert (str::len_chars(s) == 4u);\n-    assert (vec::len::<char>(str::chars(s)) == 4u);\n+    assert (str::char_len(s) == 4u);\n+    assert (vec::len(str::chars(s)) == 4u);\n     assert (str::eq(str::from_chars(str::chars(s)), s));\n     assert (str::char_at(s, 0u) == 'e');\n     assert (str::char_at(s, 1u) == '\u00e9');"}]}