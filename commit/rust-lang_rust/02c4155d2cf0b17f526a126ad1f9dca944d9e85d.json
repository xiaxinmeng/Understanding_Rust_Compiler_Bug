{"sha": "02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYzQxNTVkMmNmMGIxN2Y1MjZhMTI2YWQxZjlkY2E5NDRkOWU4NWQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-01T07:21:12Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:00Z"}, "message": "rustc: remove hir::fold.", "tree": {"sha": "f8585ad384145a44a05da1139eb15e9d9e2d7cea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8585ad384145a44a05da1139eb15e9d9e2d7cea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "html_url": "https://github.com/rust-lang/rust/commit/02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "html_url": "https://github.com/rust-lang/rust/commit/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b"}], "stats": {"total": 1402, "additions": 142, "deletions": 1260}, "files": [{"sha": "57b5599bd1d7ffd59065f0d20c3077cbc0437f2b", "filename": "src/librustc/hir/fold.rs", "status": "removed", "additions": 0, "deletions": 1131, "changes": 1131, "blob_url": "https://github.com/rust-lang/rust/blob/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed593bed882e1ad6bc7ff6a3b3b6730176b5536b/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=ed593bed882e1ad6bc7ff6a3b3b6730176b5536b", "patch": "@@ -1,1131 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A Folder represents an HIR->HIR fold; it accepts a HIR piece,\n-//! and returns a piece of the same type.\n-\n-use hir::*;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_};\n-use syntax::ast::{NestedMetaItem, NestedMetaItemKind, MetaItem, MetaItemKind};\n-use hir;\n-use syntax_pos::Span;\n-use syntax::codemap::{respan, Spanned};\n-use syntax::ptr::P;\n-use syntax::parse::token::keywords;\n-use syntax::util::move_map::MoveMap;\n-\n-pub trait Folder : Sized {\n-    // Any additions to this trait should happen in form\n-    // of a call to a public `noop_*` function that only calls\n-    // out to the folder again, not other `noop_*` functions.\n-    //\n-    // This is a necessary API workaround to the problem of not\n-    // being able to call out to the super default method\n-    // in an overridden default method.\n-\n-    fn fold_crate(&mut self, c: Crate) -> Crate {\n-        noop_fold_crate(c, self)\n-    }\n-\n-    fn fold_meta_items(&mut self, meta_items: HirVec<P<MetaItem>>) -> HirVec<P<MetaItem>> {\n-        noop_fold_meta_items(meta_items, self)\n-    }\n-\n-    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n-        noop_fold_meta_list_item(list_item, self)\n-    }\n-\n-    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n-        noop_fold_meta_item(meta_item, self)\n-    }\n-\n-    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n-        noop_fold_view_path(view_path, self)\n-    }\n-\n-    fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem {\n-        noop_fold_foreign_item(ni, self)\n-    }\n-\n-    fn fold_item(&mut self, i: Item) -> Item {\n-        noop_fold_item(i, self)\n-    }\n-\n-    fn fold_item_id(&mut self, i: ItemId) -> ItemId {\n-        noop_fold_item_id(i, self)\n-    }\n-\n-    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n-        noop_fold_struct_field(sf, self)\n-    }\n-\n-    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n-        noop_fold_item_underscore(i, self)\n-    }\n-\n-    fn fold_trait_item(&mut self, i: TraitItem) -> TraitItem {\n-        noop_fold_trait_item(i, self)\n-    }\n-\n-    fn fold_impl_item(&mut self, i: ImplItem) -> ImplItem {\n-        noop_fold_impl_item(i, self)\n-    }\n-\n-    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n-        noop_fold_fn_decl(d, self)\n-    }\n-\n-    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n-        noop_fold_block(b, self)\n-    }\n-\n-    fn fold_stmt(&mut self, s: Stmt) -> Stmt {\n-        noop_fold_stmt(s, self)\n-    }\n-\n-    fn fold_arm(&mut self, a: Arm) -> Arm {\n-        noop_fold_arm(a, self)\n-    }\n-\n-    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n-        noop_fold_pat(p, self)\n-    }\n-\n-    fn fold_decl(&mut self, d: P<Decl>) -> P<Decl> {\n-        noop_fold_decl(d, self)\n-    }\n-\n-    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n-        e.map(|e| noop_fold_expr(e, self))\n-    }\n-\n-    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n-        noop_fold_ty(t, self)\n-    }\n-\n-    fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding {\n-        noop_fold_ty_binding(t, self)\n-    }\n-\n-    fn fold_mod(&mut self, m: Mod) -> Mod {\n-        noop_fold_mod(m, self)\n-    }\n-\n-    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n-        noop_fold_foreign_mod(nm, self)\n-    }\n-\n-    fn fold_variant(&mut self, v: Variant) -> Variant {\n-        noop_fold_variant(v, self)\n-    }\n-\n-    fn fold_name(&mut self, n: Name) -> Name {\n-        noop_fold_name(n, self)\n-    }\n-\n-    fn fold_usize(&mut self, i: usize) -> usize {\n-        noop_fold_usize(i, self)\n-    }\n-\n-    fn fold_path(&mut self, p: Path) -> Path {\n-        noop_fold_path(p, self)\n-    }\n-\n-    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n-        noop_fold_path_parameters(p, self)\n-    }\n-\n-    fn fold_angle_bracketed_parameter_data(&mut self,\n-                                           p: AngleBracketedParameterData)\n-                                           -> AngleBracketedParameterData {\n-        noop_fold_angle_bracketed_parameter_data(p, self)\n-    }\n-\n-    fn fold_parenthesized_parameter_data(&mut self,\n-                                         p: ParenthesizedParameterData)\n-                                         -> ParenthesizedParameterData {\n-        noop_fold_parenthesized_parameter_data(p, self)\n-    }\n-\n-    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n-        noop_fold_local(l, self)\n-    }\n-\n-    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n-        noop_fold_lifetime(l, self)\n-    }\n-\n-    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef {\n-        noop_fold_lifetime_def(l, self)\n-    }\n-\n-    fn fold_attribute(&mut self, at: Attribute) -> Option<Attribute> {\n-        noop_fold_attribute(at, self)\n-    }\n-\n-    fn fold_arg(&mut self, a: Arg) -> Arg {\n-        noop_fold_arg(a, self)\n-    }\n-\n-    fn fold_generics(&mut self, generics: Generics) -> Generics {\n-        noop_fold_generics(generics, self)\n-    }\n-\n-    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n-        noop_fold_trait_ref(p, self)\n-    }\n-\n-    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n-        noop_fold_poly_trait_ref(p, self)\n-    }\n-\n-    fn fold_variant_data(&mut self, vdata: VariantData) -> VariantData {\n-        noop_fold_variant_data(vdata, self)\n-    }\n-\n-    fn fold_lifetimes(&mut self, lts: HirVec<Lifetime>) -> HirVec<Lifetime> {\n-        noop_fold_lifetimes(lts, self)\n-    }\n-\n-    fn fold_lifetime_defs(&mut self, lts: HirVec<LifetimeDef>) -> HirVec<LifetimeDef> {\n-        noop_fold_lifetime_defs(lts, self)\n-    }\n-\n-    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n-        noop_fold_ty_param(tp, self)\n-    }\n-\n-    fn fold_ty_params(&mut self, tps: HirVec<TyParam>) -> HirVec<TyParam> {\n-        noop_fold_ty_params(tps, self)\n-    }\n-\n-    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> {\n-        noop_fold_opt_lifetime(o_lt, self)\n-    }\n-\n-    fn fold_opt_bounds(&mut self,\n-                       b: Option<TyParamBounds>)\n-                       -> Option<TyParamBounds> {\n-        noop_fold_opt_bounds(b, self)\n-    }\n-\n-    fn fold_bounds(&mut self, b: TyParamBounds) -> TyParamBounds {\n-        noop_fold_bounds(b, self)\n-    }\n-\n-    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n-        noop_fold_ty_param_bound(tpb, self)\n-    }\n-\n-    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n-        noop_fold_mt(mt, self)\n-    }\n-\n-    fn fold_field(&mut self, field: Field) -> Field {\n-        noop_fold_field(field, self)\n-    }\n-\n-    fn fold_where_clause(&mut self, where_clause: WhereClause) -> WhereClause {\n-        noop_fold_where_clause(where_clause, self)\n-    }\n-\n-    fn fold_where_predicate(&mut self, where_predicate: WherePredicate) -> WherePredicate {\n-        noop_fold_where_predicate(where_predicate, self)\n-    }\n-\n-    /// called for the `id` on each declaration\n-    fn new_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    /// called for ids that are references (e.g., ItemDef)\n-    fn map_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    fn new_span(&mut self, sp: Span) -> Span {\n-        sp\n-    }\n-}\n-\n-pub fn noop_fold_meta_items<T: Folder>(meta_items: HirVec<P<MetaItem>>,\n-                                       fld: &mut T)\n-                                       -> HirVec<P<MetaItem>> {\n-    meta_items.move_map(|x| fld.fold_meta_item(x))\n-}\n-\n-pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n-    view_path.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                ViewPathSimple(name, path) => {\n-                    ViewPathSimple(name, fld.fold_path(path))\n-                }\n-                ViewPathGlob(path) => {\n-                    ViewPathGlob(fld.fold_path(path))\n-                }\n-                ViewPathList(path, path_list_idents) => {\n-                    ViewPathList(fld.fold_path(path),\n-                                 path_list_idents.move_map(|path_list_ident| {\n-                                     Spanned {\n-                                         node: PathListItem_ {\n-                                             id: fld.new_id(path_list_ident.node.id),\n-                                             name: path_list_ident.node.name,\n-                                             rename: path_list_ident.node.rename,\n-                                         },\n-                                         span: fld.new_span(path_list_ident.span),\n-                                     }\n-                                 }))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn fold_attrs<T, F>(attrs: T, fld: &mut F) -> T\n-    where T: Into<Vec<Attribute>> + From<Vec<Attribute>>,\n-          F: Folder,\n-{\n-    attrs.into().move_flat_map(|x| fld.fold_attribute(x)).into()\n-}\n-\n-pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n-    Arm {\n-        attrs: fold_attrs(attrs, fld),\n-        pats: pats.move_map(|x| fld.fold_pat(x)),\n-        guard: guard.map(|x| fld.fold_expr(x)),\n-        body: fld.fold_expr(body),\n-    }\n-}\n-\n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> P<Decl> {\n-    d.map(|Spanned { node, span }| {\n-        match node {\n-            DeclLocal(l) => Spanned {\n-                node: DeclLocal(fld.fold_local(l)),\n-                span: fld.new_span(span),\n-            },\n-            DeclItem(it) => Spanned {\n-                node: DeclItem(fld.fold_item_id(it)),\n-                span: fld.new_span(span),\n-            },\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n-    TypeBinding {\n-        id: fld.new_id(b.id),\n-        name: b.name,\n-        ty: fld.fold_ty(b.ty),\n-        span: fld.new_span(b.span),\n-    }\n-}\n-\n-pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    t.map(|Ty { id, node, span }| {\n-        Ty {\n-            id: fld.new_id(id),\n-            node: match node {\n-                TyInfer => node,\n-                TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-                TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n-                TyRptr(region, mt) => {\n-                    TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n-                }\n-                TyBareFn(f) => {\n-                    TyBareFn(f.map(|BareFnTy { lifetimes, unsafety, abi, decl }| {\n-                        BareFnTy {\n-                            lifetimes: fld.fold_lifetime_defs(lifetimes),\n-                            unsafety: unsafety,\n-                            abi: abi,\n-                            decl: fld.fold_fn_decl(decl),\n-                        }\n-                    }))\n-                }\n-                TyNever => node,\n-                TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n-                TyPath(qself, path) => {\n-                    let qself = qself.map(|QSelf { ty, position }| {\n-                        QSelf {\n-                            ty: fld.fold_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    TyPath(qself, fld.fold_path(path))\n-                }\n-                TyObjectSum(ty, bounds) => {\n-                    TyObjectSum(fld.fold_ty(ty), fld.fold_bounds(bounds))\n-                }\n-                TyFixedLengthVec(ty, e) => {\n-                    TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n-                }\n-                TyTypeof(expr) => {\n-                    TyTypeof(fld.fold_expr(expr))\n-                }\n-                TyPolyTraitRef(bounds) => {\n-                    TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-                TyImplTrait(bounds) => {\n-                    TyImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod { abi, items }: ForeignMod,\n-                                        fld: &mut T)\n-                                        -> ForeignMod {\n-    ForeignMod {\n-        abi: abi,\n-        items: items.move_map(|x| fld.fold_foreign_item(x)),\n-    }\n-}\n-\n-pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n-    Spanned {\n-        node: Variant_ {\n-            name: v.node.name,\n-            attrs: fold_attrs(v.node.attrs, fld),\n-            data: fld.fold_variant_data(v.node.data),\n-            disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n-        },\n-        span: fld.new_span(v.span),\n-    }\n-}\n-\n-pub fn noop_fold_name<T: Folder>(n: Name, _: &mut T) -> Name {\n-    n\n-}\n-\n-pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n-    i\n-}\n-\n-pub fn noop_fold_path<T: Folder>(Path { global, segments, span }: Path, fld: &mut T) -> Path {\n-    Path {\n-        global: global,\n-        segments: segments.move_map(|PathSegment { name, parameters }| {\n-            PathSegment {\n-                name: fld.fold_name(name),\n-                parameters: fld.fold_path_parameters(parameters),\n-            }\n-        }),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters,\n-                                            fld: &mut T)\n-                                            -> PathParameters {\n-    match path_parameters {\n-        AngleBracketedParameters(data) =>\n-            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n-        ParenthesizedParameters(data) =>\n-            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n-    }\n-}\n-\n-pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n-                                                           fld: &mut T)\n-                                                           -> AngleBracketedParameterData {\n-    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n-    AngleBracketedParameterData {\n-        lifetimes: fld.fold_lifetimes(lifetimes),\n-        types: types.move_map(|ty| fld.fold_ty(ty)),\n-        bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n-    }\n-}\n-\n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n-                                                         fld: &mut T)\n-                                                         -> ParenthesizedParameterData {\n-    let ParenthesizedParameterData { inputs, output, span } = data;\n-    ParenthesizedParameterData {\n-        inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-        output: output.map(|ty| fld.fold_ty(ty)),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local { id, pat, ty, init, span, attrs }| {\n-        Local {\n-            id: fld.new_id(id),\n-            ty: ty.map(|t| fld.fold_ty(t)),\n-            pat: fld.fold_pat(pat),\n-            init: init.map(|e| fld.fold_expr(e)),\n-            span: fld.new_span(span),\n-            attrs: fold_attrs(attrs, fld),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n-    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Some(Spanned {\n-        node: Attribute_ {\n-            id: id,\n-            style: style,\n-            value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc,\n-        },\n-        span: fld.new_span(span),\n-    })\n-}\n-\n-pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n-    -> NestedMetaItem {\n-    Spanned {\n-        node: match li.node {\n-            NestedMetaItemKind::MetaItem(mi) =>  {\n-                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n-            },\n-            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n-        },\n-        span: fld.new_span(li.span)\n-    }\n-}\n-\n-pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n-    mi.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                MetaItemKind::Word(id) => MetaItemKind::Word(id),\n-                MetaItemKind::List(id, mis) => {\n-                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n-                }\n-                MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s),\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_arg<T: Folder>(Arg { id, pat, ty }: Arg, fld: &mut T) -> Arg {\n-    Arg {\n-        id: fld.new_id(id),\n-        pat: fld.fold_pat(pat),\n-        ty: fld.fold_ty(ty),\n-    }\n-}\n-\n-pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl { inputs, output, variadic }| {\n-        FnDecl {\n-            inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-            output: match output {\n-                Return(ty) => Return(fld.fold_ty(ty)),\n-                DefaultReturn(span) => DefaultReturn(span),\n-            },\n-            variadic: variadic,\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T) -> TyParamBound\n-    where T: Folder\n-{\n-    match tpb {\n-        TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n-        RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-    }\n-}\n-\n-pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {id, name, bounds, default, span} = tp;\n-    TyParam {\n-        id: fld.new_id(id),\n-        name: name,\n-        bounds: fld.fold_bounds(bounds),\n-        default: default.map(|x| fld.fold_ty(x)),\n-        span: span,\n-    }\n-}\n-\n-pub fn noop_fold_ty_params<T: Folder>(tps: HirVec<TyParam>,\n-                                      fld: &mut T)\n-                                      -> HirVec<TyParam> {\n-    tps.move_map(|tp| fld.fold_ty_param(tp))\n-}\n-\n-pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n-    Lifetime {\n-        id: fld.new_id(l.id),\n-        name: l.name,\n-        span: fld.new_span(l.span),\n-    }\n-}\n-\n-pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> LifetimeDef {\n-    LifetimeDef {\n-        lifetime: fld.fold_lifetime(l.lifetime),\n-        bounds: fld.fold_lifetimes(l.bounds),\n-    }\n-}\n-\n-pub fn noop_fold_lifetimes<T: Folder>(lts: HirVec<Lifetime>, fld: &mut T) -> HirVec<Lifetime> {\n-    lts.move_map(|l| fld.fold_lifetime(l))\n-}\n-\n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: HirVec<LifetimeDef>,\n-                                          fld: &mut T)\n-                                          -> HirVec<LifetimeDef> {\n-    lts.move_map(|l| fld.fold_lifetime_def(l))\n-}\n-\n-pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T) -> Option<Lifetime> {\n-    o_lt.map(|lt| fld.fold_lifetime(lt))\n-}\n-\n-pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,\n-                                     fld: &mut T)\n-                                     -> Generics {\n-    Generics {\n-        ty_params: fld.fold_ty_params(ty_params),\n-        lifetimes: fld.fold_lifetime_defs(lifetimes),\n-        where_clause: fld.fold_where_clause(where_clause),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_where_clause<T: Folder>(WhereClause { id, predicates }: WhereClause,\n-                                         fld: &mut T)\n-                                         -> WhereClause {\n-    WhereClause {\n-        id: fld.new_id(id),\n-        predicates: predicates.move_map(|predicate| fld.fold_where_predicate(predicate)),\n-    }\n-}\n-\n-pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -> WherePredicate {\n-    match pred {\n-        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{bound_lifetimes,\n-                                                                     bounded_ty,\n-                                                                     bounds,\n-                                                                     span}) => {\n-            hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n-                bounded_ty: fld.fold_ty(bounded_ty),\n-                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n-                span: fld.new_span(span),\n-            })\n-        }\n-        hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{lifetime,\n-                                                                       bounds,\n-                                                                       span}) => {\n-            hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: fld.new_span(span),\n-                lifetime: fld.fold_lifetime(lifetime),\n-                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound)),\n-            })\n-        }\n-        hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n-                                                               path,\n-                                                               ty,\n-                                                               span}) => {\n-            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                id: fld.new_id(id),\n-                path: fld.fold_path(path),\n-                ty: fld.fold_ty(ty),\n-                span: fld.new_span(span),\n-            })\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData {\n-    match vdata {\n-        VariantData::Struct(fields, id) => {\n-            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)),\n-                                fld.new_id(id))\n-        }\n-        VariantData::Tuple(fields, id) => {\n-            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)),\n-                               fld.new_id(id))\n-        }\n-        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id)),\n-    }\n-}\n-\n-pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n-    let id = fld.new_id(p.ref_id);\n-    let TraitRef {\n-        path,\n-        ref_id: _,\n-    } = p;\n-    hir::TraitRef {\n-        path: fld.fold_path(path),\n-        ref_id: id,\n-    }\n-}\n-\n-pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n-    hir::PolyTraitRef {\n-        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n-        trait_ref: fld.fold_trait_ref(p.trait_ref),\n-        span: fld.new_span(p.span),\n-    }\n-}\n-\n-pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n-    StructField {\n-        span: fld.new_span(f.span),\n-        id: fld.new_id(f.id),\n-        name: f.name,\n-        vis: f.vis,\n-        ty: fld.fold_ty(f.ty),\n-        attrs: fold_attrs(f.attrs, fld),\n-    }\n-}\n-\n-pub fn noop_fold_field<T: Folder>(Field { name, expr, span }: Field, folder: &mut T) -> Field {\n-    Field {\n-        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-        expr: folder.fold_expr(expr),\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_mt<T: Folder>(MutTy { ty, mutbl }: MutTy, folder: &mut T) -> MutTy {\n-    MutTy {\n-        ty: folder.fold_ty(ty),\n-        mutbl: mutbl,\n-    }\n-}\n-\n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>,\n-                                       folder: &mut T)\n-                                       -> Option<TyParamBounds> {\n-    b.map(|bounds| folder.fold_bounds(bounds))\n-}\n-\n-fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T) -> TyParamBounds {\n-    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n-}\n-\n-pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block { id, stmts, expr, rules, span }| {\n-        Block {\n-            id: folder.new_id(id),\n-            stmts: stmts.move_map(|s| folder.fold_stmt(s)),\n-            expr: expr.map(|x| folder.fold_expr(x)),\n-            rules: rules,\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n-    match i {\n-        ItemExternCrate(string) => ItemExternCrate(string),\n-        ItemUse(view_path) => {\n-            ItemUse(folder.fold_view_path(view_path))\n-        }\n-        ItemStatic(t, m, e) => {\n-            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n-        }\n-        ItemConst(t, e) => {\n-            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n-        }\n-        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemFn(folder.fold_fn_decl(decl),\n-                   unsafety,\n-                   constness,\n-                   abi,\n-                   folder.fold_generics(generics),\n-                   folder.fold_block(body))\n-        }\n-        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, generics) => {\n-            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n-        }\n-        ItemEnum(enum_definition, generics) => {\n-            ItemEnum(hir::EnumDef {\n-                         variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n-                     },\n-                     folder.fold_generics(generics))\n-        }\n-        ItemStruct(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemStruct(struct_def, folder.fold_generics(generics))\n-        }\n-        ItemUnion(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemUnion(struct_def, folder.fold_generics(generics))\n-        }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n-        }\n-        ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items\n-                .move_map(|item| folder.fold_impl_item(item));\n-            let ifce = match ifce {\n-                None => None,\n-                Some(ref trait_ref) => {\n-                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n-                }\n-            };\n-            ItemImpl(unsafety,\n-                     polarity,\n-                     folder.fold_generics(generics),\n-                     ifce,\n-                     folder.fold_ty(ty),\n-                     new_impl_items)\n-        }\n-        ItemTrait(unsafety, generics, bounds, items) => {\n-            let bounds = folder.fold_bounds(bounds);\n-            let items = items.move_map(|item| folder.fold_trait_item(item));\n-            ItemTrait(unsafety, folder.fold_generics(generics), bounds, items)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_trait_item<T: Folder>(i: TraitItem,\n-                                       folder: &mut T)\n-                                       -> TraitItem {\n-    TraitItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        node: match i.node {\n-            ConstTraitItem(ty, default) => {\n-                ConstTraitItem(folder.fold_ty(ty), default.map(|x| folder.fold_expr(x)))\n-            }\n-            MethodTraitItem(sig, body) => {\n-                MethodTraitItem(noop_fold_method_sig(sig, folder),\n-                                body.map(|x| folder.fold_block(x)))\n-            }\n-            TypeTraitItem(bounds, default) => {\n-                TypeTraitItem(folder.fold_bounds(bounds),\n-                              default.map(|x| folder.fold_ty(x)))\n-            }\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> ImplItem {\n-    ImplItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        vis: i.vis,\n-        defaultness: i.defaultness,\n-        node: match i.node {\n-            ImplItemKind::Const(ty, expr) => {\n-                ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n-            }\n-            ImplItemKind::Method(sig, body) => {\n-                ImplItemKind::Method(noop_fold_method_sig(sig, folder), folder.fold_block(body))\n-            }\n-            ImplItemKind::Type(ty) => ImplItemKind::Type(folder.fold_ty(ty)),\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n-    Mod {\n-        inner: folder.new_span(inner),\n-        item_ids: item_ids.move_map(|x| folder.fold_item_id(x)),\n-    }\n-}\n-\n-pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n-                                          exported_macros, items }: Crate,\n-                                  folder: &mut T)\n-                                  -> Crate {\n-    let config = folder.fold_meta_items(config);\n-\n-    let crate_mod = folder.fold_item(hir::Item {\n-        name: keywords::Invalid.name(),\n-        attrs: attrs,\n-        id: DUMMY_NODE_ID,\n-        vis: hir::Public,\n-        span: span,\n-        node: hir::ItemMod(module),\n-    });\n-\n-    let (module, attrs, span) = match crate_mod {\n-        hir::Item { attrs, span, node, .. } => {\n-            match node {\n-                hir::ItemMod(m) => (m, attrs, span),\n-                _ => panic!(\"fold converted a module to not a module\"),\n-            }\n-        }\n-    };\n-\n-    let items = items.into_iter()\n-                     .map(|(id, item)| (id, folder.fold_item(item)))\n-                     .collect();\n-\n-    Crate {\n-        module: module,\n-        attrs: attrs,\n-        config: config,\n-        span: span,\n-        exported_macros: exported_macros,\n-        items: items,\n-    }\n-}\n-\n-pub fn noop_fold_item_id<T: Folder>(i: ItemId, folder: &mut T) -> ItemId {\n-    let id = folder.map_id(i.id);\n-    ItemId { id: id }\n-}\n-\n-// fold one item into one item\n-pub fn noop_fold_item<T: Folder>(item: Item, folder: &mut T) -> Item {\n-    let Item { id, name, attrs, node, vis, span } = item;\n-    let id = folder.new_id(id);\n-    let node = folder.fold_item_underscore(node);\n-\n-    Item {\n-        id: id,\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        node: node,\n-        vis: vis,\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n-    ForeignItem {\n-        id: folder.new_id(ni.id),\n-        name: folder.fold_name(ni.name),\n-        attrs: fold_attrs(ni.attrs, folder),\n-        node: match ni.node {\n-            ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n-            }\n-            ForeignItemStatic(t, m) => {\n-                ForeignItemStatic(folder.fold_ty(t), m)\n-            }\n-        },\n-        vis: ni.vis,\n-        span: folder.new_span(ni.span),\n-    }\n-}\n-\n-pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n-    MethodSig {\n-        generics: folder.fold_generics(sig.generics),\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n-        decl: folder.fold_fn_decl(sig.decl),\n-    }\n-}\n-\n-pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n-    p.map(|Pat { id, node, span }| {\n-        Pat {\n-            id: folder.new_id(id),\n-            node: match node {\n-                PatKind::Wild => PatKind::Wild,\n-                PatKind::Binding(binding_mode, pth1, sub) => {\n-                    PatKind::Binding(binding_mode,\n-                             Spanned {\n-                                 span: folder.new_span(pth1.span),\n-                                 node: folder.fold_name(pth1.node),\n-                             },\n-                             sub.map(|x| folder.fold_pat(x)))\n-                }\n-                PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-                PatKind::TupleStruct(pth, pats, ddpos) => {\n-                    PatKind::TupleStruct(folder.fold_path(pth),\n-                            pats.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Path(opt_qself, pth) => {\n-                    let opt_qself = opt_qself.map(|qself| {\n-                        QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n-                    });\n-                    PatKind::Path(opt_qself, folder.fold_path(pth))\n-                }\n-                PatKind::Struct(pth, fields, etc) => {\n-                    let pth = folder.fold_path(pth);\n-                    let fs = fields.move_map(|f| {\n-                        Spanned {\n-                            span: folder.new_span(f.span),\n-                            node: hir::FieldPat {\n-                                name: f.node.name,\n-                                pat: folder.fold_pat(f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n-                    });\n-                    PatKind::Struct(pth, fs, etc)\n-                }\n-                PatKind::Tuple(elts, ddpos) => {\n-                    PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n-                PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n-                PatKind::Range(e1, e2) => {\n-                    PatKind::Range(folder.fold_expr(e1), folder.fold_expr(e2))\n-                }\n-                PatKind::Vec(before, slice, after) => {\n-                    PatKind::Vec(before.move_map(|x| folder.fold_pat(x)),\n-                           slice.map(|x| folder.fold_pat(x)),\n-                           after.move_map(|x| folder.fold_pat(x)))\n-                }\n-            },\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &mut T) -> Expr {\n-    Expr {\n-        id: folder.new_id(id),\n-        node: match node {\n-            ExprBox(e) => {\n-                ExprBox(folder.fold_expr(e))\n-            }\n-            ExprVec(exprs) => {\n-                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprRepeat(expr, count) => {\n-                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n-            }\n-            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n-            ExprCall(f, args) => {\n-                ExprCall(folder.fold_expr(f), args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprMethodCall(name, tps, args) => {\n-                ExprMethodCall(respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-                               tps.move_map(|x| folder.fold_ty(x)),\n-                               args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprBinary(binop, lhs, rhs) => {\n-                ExprBinary(binop, folder.fold_expr(lhs), folder.fold_expr(rhs))\n-            }\n-            ExprUnary(binop, ohs) => {\n-                ExprUnary(binop, folder.fold_expr(ohs))\n-            }\n-            ExprLit(l) => ExprLit(l),\n-            ExprCast(expr, ty) => {\n-                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprType(expr, ty) => {\n-                ExprType(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-            ExprIf(cond, tr, fl) => {\n-                ExprIf(folder.fold_expr(cond),\n-                       folder.fold_block(tr),\n-                       fl.map(|x| folder.fold_expr(x)))\n-            }\n-            ExprWhile(cond, body, opt_name) => {\n-                ExprWhile(folder.fold_expr(cond),\n-                          folder.fold_block(body),\n-                          opt_name.map(|label| {\n-                              respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                          }))\n-            }\n-            ExprLoop(body, opt_name) => {\n-                ExprLoop(folder.fold_block(body),\n-                         opt_name.map(|label| {\n-                             respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                         }))\n-            }\n-            ExprMatch(expr, arms, source) => {\n-                ExprMatch(folder.fold_expr(expr),\n-                          arms.move_map(|x| folder.fold_arm(x)),\n-                          source)\n-            }\n-            ExprClosure(capture_clause, decl, body, fn_decl_span) => {\n-                ExprClosure(capture_clause,\n-                            folder.fold_fn_decl(decl),\n-                            folder.fold_block(body),\n-                            folder.new_span(fn_decl_span))\n-            }\n-            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n-            ExprAssign(el, er) => {\n-                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprAssignOp(op, el, er) => {\n-                ExprAssignOp(op, folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprField(el, name) => {\n-                ExprField(folder.fold_expr(el),\n-                          respan(folder.new_span(name.span), folder.fold_name(name.node)))\n-            }\n-            ExprTupField(el, index) => {\n-                ExprTupField(folder.fold_expr(el),\n-                             respan(folder.new_span(index.span), folder.fold_usize(index.node)))\n-            }\n-            ExprIndex(el, er) => {\n-                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprPath(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n-                    QSelf {\n-                        ty: folder.fold_ty(ty),\n-                        position: position,\n-                    }\n-                });\n-                ExprPath(qself, folder.fold_path(path))\n-            }\n-            ExprBreak(opt_name) => ExprBreak(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprAgain(opt_name) => ExprAgain(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n-            ExprInlineAsm(asm, outputs, inputs) => {\n-                ExprInlineAsm(asm,\n-                              outputs.move_map(|x| folder.fold_expr(x)),\n-                              inputs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprStruct(path, fields, maybe_expr) => {\n-                ExprStruct(folder.fold_path(path),\n-                           fields.move_map(|x| folder.fold_field(x)),\n-                           maybe_expr.map(|x| folder.fold_expr(x)))\n-            }\n-        },\n-        span: folder.new_span(span),\n-        attrs: fold_attrs(attrs, folder),\n-    }\n-}\n-\n-pub fn noop_fold_stmt<T: Folder>(stmt: Stmt, folder: &mut T) -> Stmt {\n-    let span = folder.new_span(stmt.span);\n-    match stmt.node {\n-        StmtDecl(d, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtDecl(folder.fold_decl(d), id),\n-                span: span\n-            }\n-        }\n-        StmtExpr(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtExpr(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-        StmtSemi(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtSemi(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-    }\n-}"}, {"sha": "0cfdbae1a50b0a53d7bd1f9e1392620dc45eb391", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "patch": "@@ -67,7 +67,6 @@ macro_rules! hir_vec {\n pub mod check_attr;\n pub mod def;\n pub mod def_id;\n-pub mod fold;\n pub mod intravisit;\n pub mod lowering;\n pub mod map;"}, {"sha": "dda72ce57b4fa0a0a2b6cb390f56908037b2eb35", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "patch": "@@ -40,11 +40,10 @@ use rustc_back::slice;\n use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n use syntax::codemap::Spanned;\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n+use syntax::util::move_map::MoveMap;\n use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n     id: DUMMY_NODE_ID,\n@@ -182,7 +181,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 }\n             }\n \n-            let mut static_inliner = StaticInliner::new(cx.tcx, None);\n+            let mut static_inliner = StaticInliner::new(cx.tcx);\n             let inlined_arms = arms.iter().map(|arm| {\n                 (arm.pats.iter().map(|pat| {\n                     static_inliner.fold_pat((*pat).clone())\n@@ -467,87 +466,93 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     })\n }\n \n-pub struct StaticInliner<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub failed: bool,\n-    pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n+struct StaticInliner<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    failed: bool\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                   renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n-                   -> StaticInliner<'b, 'tcx> {\n+    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>) -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n             tcx: tcx,\n-            failed: false,\n-            renaming_map: renaming_map\n+            failed: false\n         }\n     }\n }\n \n-struct RenamingRecorder<'map> {\n-    substituted_node_id: NodeId,\n-    origin_span: Span,\n-    renaming_map: &'map mut FnvHashMap<(NodeId, Span), NodeId>\n-}\n-\n-impl<'v, 'map> Visitor<'v> for RenamingRecorder<'map> {\n-    fn visit_id(&mut self, node_id: NodeId) {\n-        let key = (node_id, self.origin_span);\n-        self.renaming_map.insert(key, self.substituted_node_id);\n-    }\n-}\n-\n-impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n+impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n-        return match pat.node {\n+        match pat.node {\n             PatKind::Path(..) => {\n                 match self.tcx.expect_def(pat.id) {\n                     Def::AssociatedConst(did) | Def::Const(did) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n-                                Ok(new_pat) => {\n-                                    if let Some(ref mut map) = self.renaming_map {\n-                                        // Record any renamings we do here\n-                                        record_renamings(const_expr, &pat, map);\n-                                    }\n-                                    new_pat\n-                                }\n+                                Ok(new_pat) => return new_pat,\n                                 Err(def_id) => {\n                                     self.failed = true;\n                                     self.tcx.sess.span_err(\n                                         pat.span,\n                                         &format!(\"constants of the type `{}` \\\n                                                   cannot be used in patterns\",\n                                                  self.tcx.item_path_str(def_id)));\n-                                    pat\n                                 }\n                             }\n                         } else {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n                                 \"statics cannot be referenced in patterns\");\n-                            pat\n                         }\n                     }\n-                    _ => noop_fold_pat(pat, self)\n+                    _ => {}\n                 }\n             }\n-            _ => noop_fold_pat(pat, self)\n-        };\n+            _ => {}\n+        }\n \n-        fn record_renamings(const_expr: &hir::Expr,\n-                            substituted_pat: &hir::Pat,\n-                            renaming_map: &mut FnvHashMap<(NodeId, Span), NodeId>) {\n-            let mut renaming_recorder = RenamingRecorder {\n-                substituted_node_id: substituted_pat.id,\n-                origin_span: substituted_pat.span,\n-                renaming_map: renaming_map,\n+        pat.map(|Pat { id, node, span }| {\n+            let node = match node {\n+                PatKind::Binding(binding_mode, pth1, sub) => {\n+                    PatKind::Binding(binding_mode, pth1, sub.map(|x| self.fold_pat(x)))\n+                }\n+                PatKind::TupleStruct(pth, pats, ddpos) => {\n+                    PatKind::TupleStruct(pth, pats.move_map(|x| self.fold_pat(x)), ddpos)\n+                }\n+                PatKind::Struct(pth, fields, etc) => {\n+                    let fs = fields.move_map(|f| {\n+                        Spanned {\n+                            span: f.span,\n+                            node: hir::FieldPat {\n+                                name: f.node.name,\n+                                pat: self.fold_pat(f.node.pat),\n+                                is_shorthand: f.node.is_shorthand,\n+                            },\n+                        }\n+                    });\n+                    PatKind::Struct(pth, fs, etc)\n+                }\n+                PatKind::Tuple(elts, ddpos) => {\n+                    PatKind::Tuple(elts.move_map(|x| self.fold_pat(x)), ddpos)\n+                }\n+                PatKind::Box(inner) => PatKind::Box(self.fold_pat(inner)),\n+                PatKind::Ref(inner, mutbl) => PatKind::Ref(self.fold_pat(inner), mutbl),\n+                PatKind::Vec(before, slice, after) => {\n+                    PatKind::Vec(before.move_map(|x| self.fold_pat(x)),\n+                                 slice.map(|x| self.fold_pat(x)),\n+                                 after.move_map(|x| self.fold_pat(x)))\n+                }\n+                PatKind::Wild |\n+                PatKind::Lit(_) |\n+                PatKind::Range(..) |\n+                PatKind::Path(..) => node\n             };\n-\n-            renaming_recorder.visit_expr(const_expr);\n-        }\n+            Pat {\n+                id: id,\n+                node: node,\n+                span: span\n+            }\n+        })\n     }\n }\n \n@@ -1047,7 +1052,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n     intravisit::walk_local(cx, loc);\n \n-    let pat = StaticInliner::new(cx.tcx, None).fold_pat(loc.pat.clone());\n+    let pat = StaticInliner::new(cx.tcx).fold_pat(loc.pat.clone());\n     check_irrefutable(cx, &pat, false);\n \n     // Check legality of move bindings and `@` patterns."}, {"sha": "7eb7b24015e101063f09c6dd63b39f719eb059bf", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 50, "deletions": 70, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "patch": "@@ -38,7 +38,6 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{self, DefId, DefIndex, CRATE_DEF_INDEX};\n-use rustc::hir::fold::Folder;\n use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n@@ -774,7 +773,20 @@ impl Lifetime {\n }\n \n impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, _: &DocContext) -> Lifetime {\n+    fn clean(&self, cx: &DocContext) -> Lifetime {\n+        if let Some(tcx) = cx.tcx_opt() {\n+            let def = tcx.named_region_map.defs.get(&self.id).cloned();\n+            match def {\n+                Some(DefEarlyBoundRegion(_, node_id)) |\n+                Some(DefLateBoundRegion(_, node_id)) |\n+                Some(DefFreeRegion(_, node_id)) => {\n+                    if let Some(lt) = cx.lt_substs.borrow().get(&node_id).cloned() {\n+                        return lt;\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n         Lifetime(self.name.to_string())\n     }\n }\n@@ -1629,42 +1641,6 @@ impl From<ast::FloatTy> for PrimitiveType {\n     }\n }\n \n-// Poor man's type parameter substitution at HIR level.\n-// Used to replace private type aliases in public signatures with their aliased types.\n-struct SubstAlias<'a, 'tcx: 'a> {\n-    tcx: &'a ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    // Table type parameter definition -> substituted type\n-    ty_substs: FnvHashMap<Def, hir::Ty>,\n-    // Table node id of lifetime parameter definition -> substituted lifetime\n-    lt_substs: FnvHashMap<ast::NodeId, hir::Lifetime>,\n-}\n-\n-impl<'a, 'tcx: 'a, 'b: 'tcx> Folder for SubstAlias<'a, 'tcx> {\n-    fn fold_ty(&mut self, ty: P<hir::Ty>) -> P<hir::Ty> {\n-        if let hir::TyPath(..) = ty.node {\n-            let def = self.tcx.expect_def(ty.id);\n-            if let Some(new_ty) = self.ty_substs.get(&def).cloned() {\n-                return P(new_ty);\n-            }\n-        }\n-        hir::fold::noop_fold_ty(ty, self)\n-    }\n-    fn fold_lifetime(&mut self, lt: hir::Lifetime) -> hir::Lifetime {\n-        let def = self.tcx.named_region_map.defs.get(&lt.id).cloned();\n-        match def {\n-            Some(DefEarlyBoundRegion(_, node_id)) |\n-            Some(DefLateBoundRegion(_, node_id)) |\n-            Some(DefFreeRegion(_, node_id)) => {\n-                if let Some(lt) = self.lt_substs.get(&node_id).cloned() {\n-                    return lt;\n-                }\n-            }\n-            _ => {}\n-        }\n-        hir::fold::noop_fold_lifetime(lt, self)\n-    }\n-}\n-\n impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n@@ -1696,43 +1672,47 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(None, ref path) => {\n-                if let Some(tcx) = cx.tcx_opt() {\n-                    // Substitute private type aliases\n-                    let def = tcx.expect_def(self.id);\n+                let tcx_and_def = cx.tcx_opt().map(|tcx| (tcx, tcx.expect_def(self.id)));\n+                if let Some((_, def)) = tcx_and_def {\n+                    if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n+                        return new_ty;\n+                    }\n+                }\n+\n+                let tcx_and_alias = tcx_and_def.and_then(|(tcx, def)| {\n                     if let Def::TyAlias(def_id) = def {\n-                        if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+                        // Substitute private type aliases\n+                        tcx.map.as_local_node_id(def_id).and_then(|node_id| {\n                             if !cx.access_levels.borrow().is_exported(def_id) {\n-                                let item = tcx.map.expect_item(node_id);\n-                                if let hir::ItemTy(ref ty, ref generics) = item.node {\n-                                    let provided_params = &path.segments.last().unwrap().parameters;\n-                                    let mut ty_substs = FnvHashMap();\n-                                    let mut lt_substs = FnvHashMap();\n-                                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                                        let ty_param_def = tcx.expect_def(ty_param.id);\n-                                        if let Some(ty) = provided_params.types().get(i).cloned()\n-                                                                                        .cloned() {\n-                                            ty_substs.insert(ty_param_def, ty.unwrap());\n-                                        } else if let Some(default) = ty_param.default.clone() {\n-                                            ty_substs.insert(ty_param_def, default.unwrap());\n-                                        }\n-                                    }\n-                                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n-                                        if let Some(lt) = provided_params.lifetimes().get(i)\n-                                                                                     .cloned()\n-                                                                                     .cloned() {\n-                                            lt_substs.insert(lt_param.lifetime.id, lt);\n-                                        }\n-                                    }\n-                                    let mut subst_alias = SubstAlias {\n-                                        tcx: &tcx,\n-                                        ty_substs: ty_substs,\n-                                        lt_substs: lt_substs\n-                                    };\n-                                    return subst_alias.fold_ty(ty.clone()).clean(cx);\n-                                }\n+                                Some((tcx, &tcx.map.expect_item(node_id).node))\n+                            } else {\n+                                None\n                             }\n+                        })\n+                    } else {\n+                        None\n+                    }\n+                });\n+                if let Some((tcx, &hir::ItemTy(ref ty, ref generics))) = tcx_and_alias {\n+                    let provided_params = &path.segments.last().unwrap().parameters;\n+                    let mut ty_substs = FnvHashMap();\n+                    let mut lt_substs = FnvHashMap();\n+                    for (i, ty_param) in generics.ty_params.iter().enumerate() {\n+                        let ty_param_def = tcx.expect_def(ty_param.id);\n+                        if let Some(ty) = provided_params.types().get(i).cloned()\n+                                                                        .cloned() {\n+                            ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n+                        } else if let Some(default) = ty_param.default.clone() {\n+                            ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n+                        }\n+                    }\n+                    for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n+                        if let Some(lt) = provided_params.lifetimes().get(i).cloned()\n+                                                                            .cloned() {\n+                            lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n                         }\n                     }\n+                    return cx.enter_alias(ty_substs, lt_substs, || ty.clean(cx));\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n             }"}, {"sha": "399702003ea4fc59643a8c0333181c46d280f128", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "patch": "@@ -14,6 +14,7 @@ use rustc_driver::{driver, target_features, abort_on_err};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::hir::def_id::{CrateNum, DefId};\n+use rustc::hir::def::Def;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir::map as hir_map;\n@@ -23,12 +24,13 @@ use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::codemap;\n+use syntax::{ast, codemap};\n use syntax::feature_gate::UnstableFeatures;\n use errors;\n use errors::emitter::ColorConfig;\n \n use std::cell::{RefCell, Cell};\n+use std::mem;\n use std::rc::Rc;\n \n use visit_ast::RustdocVisitor;\n@@ -63,6 +65,14 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n     pub external_traits: RefCell<FnvHashMap<DefId, clean::Trait>>,\n+\n+    // The current set of type and lifetime substitutions,\n+    // for expanding type aliases at the HIR level:\n+\n+    /// Table type parameter definition -> substituted type\n+    pub ty_substs: RefCell<FnvHashMap<Def, clean::Type>>,\n+    /// Table node id of lifetime parameter definition -> substituted lifetime\n+    pub lt_substs: RefCell<FnvHashMap<ast::NodeId, clean::Lifetime>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -84,6 +94,22 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n         let tcx_opt = self.tcx_opt();\n         tcx_opt.expect(\"tcx not present\")\n     }\n+\n+    /// Call the closure with the given parameters set as\n+    /// the substitutions for a type alias' RHS.\n+    pub fn enter_alias<F, R>(&self,\n+                             ty_substs: FnvHashMap<Def, clean::Type>,\n+                             lt_substs: FnvHashMap<ast::NodeId, clean::Lifetime>,\n+                             f: F) -> R\n+    where F: FnOnce() -> R {\n+        let (old_tys, old_lts) =\n+            (mem::replace(&mut *self.ty_substs.borrow_mut(), ty_substs),\n+             mem::replace(&mut *self.lt_substs.borrow_mut(), lt_substs));\n+        let r = f();\n+        *self.ty_substs.borrow_mut() = old_tys;\n+        *self.lt_substs.borrow_mut() = old_lts;\n+        r\n+    }\n }\n \n pub trait DocAccessLevels {\n@@ -179,12 +205,14 @@ pub fn run_core(search_paths: SearchPaths,\n             map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n-            populated_crate_impls: RefCell::new(FnvHashSet()),\n+            populated_crate_impls: Default::default(),\n             deref_trait_did: Cell::new(None),\n             deref_mut_trait_did: Cell::new(None),\n             access_levels: RefCell::new(access_levels),\n-            external_traits: RefCell::new(FnvHashMap()),\n-            renderinfo: RefCell::new(Default::default()),\n+            external_traits: Default::default(),\n+            renderinfo: Default::default(),\n+            ty_substs: Default::default(),\n+            lt_substs: Default::default(),\n         };\n         debug!(\"crate: {:?}\", ctxt.map.krate());\n "}, {"sha": "3d2caeda1468d7b38a02502fbf09d64c8514cfa3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c4155d2cf0b17f526a126ad1f9dca944d9e85d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::{RefCell, Cell};\n+use std::cell::Cell;\n use std::env;\n use std::ffi::OsString;\n use std::io::prelude::*;\n@@ -28,7 +28,6 @@ use rustc::session::{self, config};\n use rustc::session::config::{get_unstable_features_setting, OutputType,\n                              OutputTypes, Externs};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n-use rustc::util::nodemap::{FnvHashMap, FnvHashSet};\n use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n@@ -107,12 +106,14 @@ pub fn run(input: &str,\n         map: &map,\n         maybe_typed: core::NotTyped(&sess),\n         input: input,\n-        external_traits: RefCell::new(FnvHashMap()),\n-        populated_crate_impls: RefCell::new(FnvHashSet()),\n+        external_traits: Default::default(),\n+        populated_crate_impls: Default::default(),\n         deref_trait_did: Cell::new(None),\n         deref_mut_trait_did: Cell::new(None),\n         access_levels: Default::default(),\n         renderinfo: Default::default(),\n+        ty_substs: Default::default(),\n+        lt_substs: Default::default(),\n     };\n \n     let mut v = RustdocVisitor::new(&ctx);"}]}