{"sha": "59d41534573fceea2df0b5f5b16ce4ffbe345d18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZDQxNTM0NTczZmNlZWEyZGYwYjVmNWIxNmNlNGZmYmUzNDVkMTg=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-12-16T23:37:55Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-12-16T23:37:55Z"}, "message": "Implement remove for RingBuf", "tree": {"sha": "86942b1dd82c4962f8f7a51f1e0667bd56999e52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86942b1dd82c4962f8f7a51f1e0667bd56999e52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59d41534573fceea2df0b5f5b16ce4ffbe345d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59d41534573fceea2df0b5f5b16ce4ffbe345d18", "html_url": "https://github.com/rust-lang/rust/commit/59d41534573fceea2df0b5f5b16ce4ffbe345d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59d41534573fceea2df0b5f5b16ce4ffbe345d18/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93c061009675b8b54edee03b7603bc2cf9ed79fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c061009675b8b54edee03b7603bc2cf9ed79fa", "html_url": "https://github.com/rust-lang/rust/commit/93c061009675b8b54edee03b7603bc2cf9ed79fa"}], "stats": {"total": 300, "additions": 250, "deletions": 50}, "files": [{"sha": "7413978f087746585080a904fbedb5f802b0ade9", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 250, "deletions": 50, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/59d41534573fceea2df0b5f5b16ce4ffbe345d18/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59d41534573fceea2df0b5f5b16ce4ffbe345d18/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=59d41534573fceea2df0b5f5b16ce4ffbe345d18", "patch": "@@ -102,17 +102,15 @@ impl<T> RingBuf<T> {\n \n     /// Copies a contiguous block of memory len long from src to dst\n     #[inline]\n-    fn copy(&self, dst: uint, src: uint, len: uint) {\n-        unsafe {\n-            debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                          self.cap);\n-            debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n-                          self.cap);\n-            ptr::copy_memory(\n-                self.ptr.offset(dst as int),\n-                self.ptr.offset(src as int) as *const T,\n-                len);\n-        }\n+    unsafe fn copy(&self, dst: uint, src: uint, len: uint) {\n+        debug_assert!(dst + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n+                      self.cap);\n+        ptr::copy_memory(\n+            self.ptr.offset(dst as int),\n+            self.ptr.offset(src as int) as *const T,\n+            len);\n     }\n }\n \n@@ -732,7 +730,7 @@ impl<T> RingBuf<T> {\n \n                 self.tail = self.wrap_index(self.tail - 1);\n             },\n-            (true, true, _) => {\n+            (true, true, _) => unsafe {\n                 // contiguous, insert closer to tail:\n                 //\n                 //             T   I         H\n@@ -752,13 +750,15 @@ impl<T> RingBuf<T> {\n                 //      [o I A o o o o o . . . . . . . o]\n                 //       M                             M\n \n-                let old_tail = self.tail;\n-                self.tail = self.wrap_index(self.tail - 1);\n+                let new_tail = self.wrap_index(self.tail - 1);\n+\n+                self.copy(new_tail, self.tail, 1);\n+                // Already moved the tail, so we only copy `i - 1` elements.\n+                self.copy(self.tail, self.tail + 1, i - 1);\n \n-                self.copy(self.tail, old_tail, 1);\n-                self.copy(old_tail, old_tail + 1, i);\n+                self.tail = new_tail;\n             },\n-            (true, false, _) => {\n+            (true, false, _) => unsafe {\n                 //  contiguous, insert closer to head:\n                 //\n                 //             T       I     H\n@@ -768,12 +768,11 @@ impl<T> RingBuf<T> {\n                 //      [. . . o o o o I A o o . . . . .]\n                 //                       M M M\n \n-                let old_head = self.head;\n+                self.copy(idx + 1, idx, self.head - idx);\n                 self.head = self.wrap_index(self.head + 1);\n-                self.copy(idx + 1, idx, old_head - idx);\n             },\n-            (false, true, true) => {\n-                // discontiguous, tail section, insert closer to tail:\n+            (false, true, true) => unsafe {\n+                // discontiguous, insert closer to tail, tail section:\n                 //\n                 //                   H         T   I\n                 //      [o o o o o o . . . . . o o A o o]\n@@ -782,12 +781,11 @@ impl<T> RingBuf<T> {\n                 //      [o o o o o o . . . . o o I A o o]\n                 //                           M M\n \n-                let old_tail = self.tail;\n-                self.tail = self.tail - 1;\n-                self.copy(self.tail, old_tail, i);\n+                self.copy(self.tail - 1, self.tail, i);\n+                self.tail -= 1;\n             },\n-            (false, false, true) => {\n-                // discontiguous, tail section, insert closer to head:\n+            (false, false, true) => unsafe {\n+                // discontiguous, insert closer to head, tail section:\n                 //\n                 //           H             T         I\n                 //      [o o . . . . . . . o o o o o A o]\n@@ -796,20 +794,19 @@ impl<T> RingBuf<T> {\n                 //      [o o o . . . . . . o o o o o I A]\n                 //       M M M                         M\n \n-                let old_head = self.head;\n-                self.head = self.head + 1;\n-\n                 // copy elements up to new head\n-                self.copy(1, 0, old_head);\n+                self.copy(1, 0, self.head);\n \n                 // copy last element into empty spot at bottom of buffer\n                 self.copy(0, self.cap - 1, 1);\n \n                 // move elements from idx to end forward not including ^ element\n                 self.copy(idx + 1, idx, self.cap - 1 - idx);\n+\n+                self.head += 1;\n             },\n-            (false, true, false) if idx == 0 => {\n-                // discontiguous, head section, insert is closer to tail,\n+            (false, true, false) if idx == 0 => unsafe {\n+                // discontiguous, insert is closer to tail, head section,\n                 // and is at index zero in the internal buffer:\n                 //\n                 //       I                   H     T\n@@ -819,16 +816,16 @@ impl<T> RingBuf<T> {\n                 //      [A o o o o o o o o o . . o o o I]\n                 //                               M M M\n \n-                let old_tail = self.tail;\n-                self.tail = self.tail - 1;\n                 // copy elements up to new tail\n-                self.copy(old_tail - 1, old_tail, i);\n+                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n \n                 // copy last element into empty spot at bottom of buffer\n                 self.copy(self.cap - 1, 0, 1);\n+\n+                self.tail -= 1;\n             },\n-            (false, true, false) => {\n-                // discontiguous, head section, insert closer to tail:\n+            (false, true, false) => unsafe {\n+                // discontiguous, insert closer to tail, head section:\n                 //\n                 //             I             H     T\n                 //      [o o o A o o o o o o . . . o o o]\n@@ -837,19 +834,19 @@ impl<T> RingBuf<T> {\n                 //      [o o I A o o o o o o . . o o o o]\n                 //       M M                     M M M M\n \n-                let old_tail = self.tail;\n-                self.tail = self.tail - 1;\n                 // copy elements up to new tail\n-                self.copy(old_tail - 1, old_tail, i);\n+                self.copy(self.tail - 1, self.tail, self.cap - self.tail);\n \n                 // copy last element into empty spot at bottom of buffer\n                 self.copy(self.cap - 1, 0, 1);\n \n                 // move elements from idx-1 to end forward not including ^ element\n                 self.copy(0, 1, idx - 1);\n-            }\n-            (false, false, false) => {\n-                // discontiguous, head section, insert closer to head:\n+\n+                self.tail -= 1;\n+            },\n+            (false, false, false) => unsafe {\n+                // discontiguous, insert closer to head, head section:\n                 //\n                 //               I     H           T\n                 //      [o o o o A o o . . . . . . o o o]\n@@ -858,9 +855,8 @@ impl<T> RingBuf<T> {\n                 //      [o o o o I A o o . . . . . o o o]\n                 //                 M M M\n \n-                let old_head = self.head;\n-                self.head = self.head + 1;\n-                self.copy(idx + 1, idx, old_head - idx);\n+                self.copy(idx + 1, idx, self.head - idx);\n+                self.head += 1;\n             }\n         }\n \n@@ -870,6 +866,170 @@ impl<T> RingBuf<T> {\n             self.buffer_write(new_idx, t);\n         }\n     }\n+\n+    /// Removes and returns the element at position `i` from the ringbuf.\n+    /// Whichever end is closer to the removal point will be moved to make\n+    /// room, and all the affected elements will be moved to new positions.\n+    /// Returns `None` if `i` is out of bounds.\n+    ///\n+    /// # Example\n+    /// ```rust\n+    /// use std::collections::RingBuf;\n+    ///\n+    /// let mut buf = RingBuf::new();\n+    /// buf.push_back(5i);\n+    /// buf.push_back(10i);\n+    /// buf.push_back(12i);\n+    /// buf.push_back(15);\n+    /// buf.remove(2);\n+    /// assert_eq!(Some(&15), buf.get(2));\n+    /// ```\n+    #[unstable = \"matches collection reform specification; waiting on panic semantics\"]\n+    pub fn remove(&mut self, i: uint) -> Option<T> {\n+        if self.is_empty() || self.len() <= i {\n+            return None;\n+        }\n+\n+        // There are three main cases:\n+        //  Elements are contiguous\n+        //  Elements are discontiguous and the removal is in the tail section\n+        //  Elements are discontiguous and the removal is in the head section\n+        //      - special case when elements are technically contiguous,\n+        //        but self.head = 0\n+        //\n+        // For each of those there are two more cases:\n+        //  Insert is closer to tail\n+        //  Insert is closer to head\n+        //\n+        // Key: H - self.head\n+        //      T - self.tail\n+        //      o - Valid element\n+        //      x - Element marked for removal\n+        //      R - Indicates element that is being removed\n+        //      M - Indicates element was moved\n+\n+        let idx = self.wrap_index(self.tail + i);\n+\n+        let elem = unsafe {\n+            Some(self.buffer_read(idx))\n+        };\n+\n+        let distance_to_tail = i;\n+        let distance_to_head = self.len() - i;\n+\n+        let contiguous = self.tail <= self.head;\n+\n+        match (contiguous, distance_to_tail <= distance_to_head, idx >= self.tail) {\n+            (true, true, _) => unsafe {\n+                // contiguous, remove closer to tail:\n+                //\n+                //             T   R         H\n+                //      [. . . o o x o o o o . . . . . .]\n+                //\n+                //               T           H\n+                //      [. . . . o o o o o o . . . . . .]\n+                //               M M\n+\n+                self.copy(self.tail + 1, self.tail, i);\n+                self.tail += 1;\n+            },\n+            (true, false, _) => unsafe {\n+                // contiguous, remove closer to head:\n+                //\n+                //             T       R     H\n+                //      [. . . o o o o x o o . . . . . .]\n+                //\n+                //             T           H\n+                //      [. . . o o o o o o . . . . . . .]\n+                //                     M M\n+\n+                self.copy(idx, idx + 1, self.head - idx - 1);\n+                self.head -= 1;\n+            },\n+            (false, true, true) => unsafe {\n+                // discontiguous, remove closer to tail, tail section:\n+                //\n+                //                   H         T   R\n+                //      [o o o o o o . . . . . o o x o o]\n+                //\n+                //                   H           T\n+                //      [o o o o o o . . . . . . o o o o]\n+                //                               M M\n+\n+                self.copy(self.tail + 1, self.tail, i);\n+                self.tail = self.wrap_index(self.tail + 1);\n+            },\n+            (false, false, false) => unsafe {\n+                // discontiguous, remove closer to head, head section:\n+                //\n+                //               R     H           T\n+                //      [o o o o x o o . . . . . . o o o]\n+                //\n+                //                   H             T\n+                //      [o o o o o o . . . . . . . o o o]\n+                //               M M\n+\n+                self.copy(idx, idx + 1, self.head - idx - 1);\n+                self.head -= 1;\n+            },\n+            (false, false, true) => unsafe {\n+                // discontiguous, remove closer to head, tail section:\n+                //\n+                //             H           T         R\n+                //      [o o o . . . . . . o o o o o x o]\n+                //\n+                //           H             T\n+                //      [o o . . . . . . . o o o o o o o]\n+                //       M M                         M M\n+                //\n+                // or quasi-discontiguous, remove next to head, tail section:\n+                //\n+                //       H                 T         R\n+                //      [. . . . . . . . . o o o o o x o]\n+                //\n+                //                         T           H\n+                //      [. . . . . . . . . o o o o o o .]\n+                //                                   M\n+\n+                // draw in elements in the tail section\n+                self.copy(idx, idx + 1, self.cap - idx - 1);\n+\n+                // Prevents underflow.\n+                if self.head != 0 {\n+                    // copy first element into empty spot\n+                    self.copy(self.cap - 1, 0, 1);\n+\n+                    // move elements in the head section backwards\n+                    self.copy(0, 1, self.head - 1);\n+                }\n+\n+                self.head = self.wrap_index(self.head - 1);\n+            },\n+            (false, true, false) => unsafe {\n+                // discontiguous, remove closer to tail, head section:\n+                //\n+                //           R               H     T\n+                //      [o o x o o o o o o o . . . o o o]\n+                //\n+                //                           H       T\n+                //      [o o o o o o o o o o . . . . o o]\n+                //       M M M                       M M\n+\n+                // draw in elements up to idx\n+                self.copy(1, 0, idx);\n+\n+                // copy last element into empty spot\n+                self.copy(0, self.cap - 1, 1);\n+\n+                // move elements from tail to end forward, excluding the last one\n+                self.copy(self.tail + 1, self.tail, self.cap - self.tail - 1);\n+\n+                self.tail = self.wrap_index(self.tail + 1);\n+            }\n+        }\n+\n+        return elem;\n+    }\n }\n \n /// Returns the index in the underlying buffer for a given logical element index.\n@@ -1103,6 +1263,7 @@ mod tests {\n     use core::iter;\n     use self::Taggy::*;\n     use self::Taggypar::*;\n+    use std::cmp;\n     use std::fmt::Show;\n     use std::prelude::*;\n     use std::hash;\n@@ -1892,11 +2053,11 @@ mod tests {\n     #[test]\n     fn test_insert() {\n         // This test checks that every single combination of tail position, length, and\n-        // insertion position is tested. Capacity 7 should be large enough to cover every case.\n+        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n \n-        let mut tester = RingBuf::with_capacity(7);\n-        // can't guarantee we got 7, so have to get what we got.\n-        // 7 would be great, but we will definitely get 2^k - 1, for k >= 3, or else\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n         // this test isn't covering what it wants to\n         let cap = tester.capacity();\n \n@@ -1915,6 +2076,45 @@ mod tests {\n                         }\n                     }\n                     tester.insert(to_insert, to_insert);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n+                    assert_eq!(tester, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove() {\n+        // This test checks that every single combination of tail position, length, and\n+        // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+        let mut tester = RingBuf::with_capacity(15);\n+        // can't guarantee we got 15, so have to get what we got.\n+        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+        // this test isn't covering what it wants to\n+        let cap = tester.capacity();\n+\n+        // len is the length *after* removal\n+        for len in range(0, cap - 1) {\n+            // 0, 1, 2, .., len - 1\n+            let expected = iter::count(0, 1).take(len).collect();\n+            for tail_pos in range(0, cap) {\n+                for to_remove in range(0, len + 1) {\n+                    tester.tail = tail_pos;\n+                    tester.head = tail_pos;\n+                    for i in range(0, len) {\n+                        if i == to_remove {\n+                            tester.push_back(1234);\n+                        }\n+                        tester.push_back(i);\n+                    }\n+                    if to_remove == len {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.remove(to_remove);\n+                    assert!(tester.tail < tester.cap);\n+                    assert!(tester.head < tester.cap);\n                     assert_eq!(tester, expected);\n                 }\n             }"}]}