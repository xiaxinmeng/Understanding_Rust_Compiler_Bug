{"sha": "228d6f45d8fbf289e6505d12379a41e13a0872a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyOGQ2ZjQ1ZDhmYmYyODllNjUwNWQxMjM3OWE0MWUxM2EwODcyYTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-09T20:42:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: remove unnecessary extern_prelude logic from ty::item_path.", "tree": {"sha": "2e8591a073e3966eafb4bb718bbb5e2ced23c65f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e8591a073e3966eafb4bb718bbb5e2ced23c65f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/228d6f45d8fbf289e6505d12379a41e13a0872a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/228d6f45d8fbf289e6505d12379a41e13a0872a1", "html_url": "https://github.com/rust-lang/rust/commit/228d6f45d8fbf289e6505d12379a41e13a0872a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/228d6f45d8fbf289e6505d12379a41e13a0872a1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc44841ad2a2ad5f6c5e67b9e35ed8e7e71d4dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc44841ad2a2ad5f6c5e67b9e35ed8e7e71d4dc7", "html_url": "https://github.com/rust-lang/rust/commit/bc44841ad2a2ad5f6c5e67b9e35ed8e7e71d4dc7"}], "stats": {"total": 111, "additions": 47, "deletions": 64}, "files": [{"sha": "6734e264305a74bd81fa034d686bd45072e122b7", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 45, "deletions": 62, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/228d6f45d8fbf289e6505d12379a41e13a0872a1/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228d6f45d8fbf289e6505d12379a41e13a0872a1/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=228d6f45d8fbf289e6505d12379a41e13a0872a1", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         });\n         let mut buffer = LocalPathBuffer::new(mode);\n         debug!(\"item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id, false);\n+        self.push_item_path(&mut buffer, def_id);\n         buffer.into_string()\n     }\n \n@@ -81,19 +81,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n         let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n         debug!(\"absolute_item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id, false);\n+        self.push_item_path(&mut buffer, def_id);\n         buffer.into_string()\n     }\n \n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    ///\n-    /// `pushed_prelude_crate` argument should be `true` when the buffer\n-    /// has had a prelude crate pushed to it. If this is the case, then\n-    /// we do not want to prepend `crate::` (as that would not be a valid\n-    /// path).\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum, pushed_prelude_crate: bool)\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum)\n         where T: ItemPathBuffer + Debug\n     {\n         debug!(\n@@ -115,28 +110,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // Returns `None` for the local crate.\n                 if cnum != LOCAL_CRATE {\n-                    let opt_extern_crate = self.extern_crate(cnum.as_def_id());\n-                    if let Some(ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n-                        direct: true,\n-                        ..\n-                    }) = *opt_extern_crate\n-                    {\n-                        debug!(\"push_krate_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n-                    } else {\n-                        let name = self.crate_name(cnum).as_str();\n-                        debug!(\"push_krate_path: name={:?}\", name);\n-                        buffer.push(&name);\n-                    }\n-                } else if self.sess.rust_2018() && !pushed_prelude_crate {\n-                    SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-                        // We only add the `crate::` keyword where appropriate. In particular,\n-                        // when we've not previously pushed a prelude crate to this path.\n-                        if flag.get() {\n-                            buffer.push(&keywords::Crate.name().as_str())\n+                    match *self.extern_crate(cnum.as_def_id()) {\n+                        Some(ExternCrate {\n+                            src: ExternCrateSource::Extern(def_id),\n+                            direct: true,\n+                            span,\n+                            ..\n+                        }) if !span.is_dummy() => {\n+                            debug!(\"push_krate_path: def_id={:?}\", def_id);\n+                            self.push_item_path(buffer, def_id);\n                         }\n-                    })\n+                        _ => {\n+                            let name = self.crate_name(cnum).as_str();\n+                            debug!(\"push_krate_path: name={:?}\", name);\n+                            buffer.push(&name);\n+                        }\n+                    }\n+                } else if self.sess.rust_2018() {\n+                    // We add the `crate::` keyword on Rust 2018, only when desired.\n+                    if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n+                        buffer.push(&keywords::Crate.name().as_str())\n+                    }\n                 }\n             }\n             RootMode::Absolute => {\n@@ -156,7 +150,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         buffer: &mut T,\n         external_def_id: DefId,\n-        pushed_prelude_crate: bool,\n     ) -> bool\n         where T: ItemPathBuffer + Debug\n     {\n@@ -179,10 +172,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     Some(ExternCrate {\n                         src: ExternCrateSource::Extern(def_id),\n                         direct: true,\n+                        span,\n                         ..\n                     }) => {\n                         debug!(\"try_push_visible_item_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n+                        if !span.is_dummy() {\n+                            self.push_item_path(buffer, def_id);\n+                        } else {\n+                            buffer.push(&self.crate_name(cur_def.krate).as_str());\n+                        }\n                         cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n                         return true;\n                     }\n@@ -280,16 +278,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId, pushed_prelude_crate: bool)\n+    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId)\n         where T: ItemPathBuffer + Debug\n     {\n         debug!(\n-            \"push_item_path: buffer={:?} def_id={:?} pushed_prelude_crate={:?}\",\n-            buffer, def_id, pushed_prelude_crate\n+            \"push_item_path: buffer={:?} def_id={:?}\",\n+            buffer, def_id\n         );\n         match *buffer.root_mode() {\n             RootMode::Local if !def_id.is_local() =>\n-                if self.try_push_visible_item_path(buffer, def_id, pushed_prelude_crate) { return },\n+                if self.try_push_visible_item_path(buffer, def_id) { return },\n             _ => {}\n         }\n \n@@ -298,11 +296,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n                 assert!(key.parent.is_none());\n-                self.push_krate_path(buffer, def_id.krate, pushed_prelude_crate);\n+                self.push_krate_path(buffer, def_id.krate);\n             }\n \n             DefPathData::Impl => {\n-                self.push_impl_path(buffer, def_id, pushed_prelude_crate);\n+                self.push_impl_path(buffer, def_id);\n             }\n \n             // Unclear if there is any value in distinguishing these.\n@@ -327,36 +325,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_did = self.parent_def_id(def_id).unwrap();\n-\n-                // Keep track of whether we are one recursion away from the `CrateRoot` and\n-                // pushing the name of a prelude crate. If we are, we'll want to know this when\n-                // printing the `CrateRoot` so we don't prepend a `crate::` to paths.\n-                let mut is_prelude_crate = false;\n-                if let DefPathData::CrateRoot = self.def_key(parent_did).disambiguated_data.data {\n-                    if self.extern_prelude.contains_key(&data.as_interned_str().as_symbol()) {\n-                        is_prelude_crate = true;\n-                    }\n-                }\n-\n-                self.push_item_path(\n-                    buffer, parent_did, pushed_prelude_crate || is_prelude_crate\n-                );\n+                let parent_def_id = self.parent_def_id(def_id).unwrap();\n+                self.push_item_path(buffer, parent_def_id);\n                 buffer.push(&data.as_interned_str().as_symbol().as_str());\n             },\n \n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n+                self.push_item_path(buffer, parent_def_id);\n             }\n         }\n     }\n \n     fn push_impl_path<T>(\n         self,\n-         buffer: &mut T,\n-         impl_def_id: DefId,\n-         pushed_prelude_crate: bool,\n+        buffer: &mut T,\n+        impl_def_id: DefId,\n     )\n         where T: ItemPathBuffer + Debug\n     {\n@@ -372,7 +356,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if !use_types {\n-            return self.push_impl_path_fallback(buffer, impl_def_id, pushed_prelude_crate);\n+            return self.push_impl_path_fallback(buffer, impl_def_id);\n         }\n \n         // Decide whether to print the parent path for the impl.\n@@ -396,7 +380,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n+            self.push_item_path(buffer, parent_def_id);\n             if let Some(trait_ref) = impl_trait_ref {\n                 buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n@@ -420,13 +404,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::Adt(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n-                    self.push_item_path(buffer, adt_def.did, pushed_prelude_crate);\n+                    self.push_item_path(buffer, adt_def.did);\n                 } else {\n                     buffer.push(&format!(\"<{}>\", self_ty));\n                 }\n             }\n \n-            ty::Foreign(did) => self.push_item_path(buffer, did, pushed_prelude_crate),\n+            ty::Foreign(did) => self.push_item_path(buffer, did),\n \n             ty::Bool |\n             ty::Char |\n@@ -447,15 +431,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         buffer: &mut T,\n         impl_def_id: DefId,\n-        pushed_prelude_crate: bool,\n     )\n         where T: ItemPathBuffer + Debug\n     {\n         // If no type info is available, fall back to\n         // pretty printing some span information. This should\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-        self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n+        self.push_item_path(buffer, parent_def_id);\n         let hir_id = self.hir().as_local_hir_id(impl_def_id).unwrap();\n         let item = self.hir().expect_item_by_hir_id(hir_id);\n         let span_str = self.sess.source_map().span_to_string(item.span);"}, {"sha": "91301158abdb09d38b39d7c0bea7e0767ff35636", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/228d6f45d8fbf289e6505d12379a41e13a0872a1/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228d6f45d8fbf289e6505d12379a41e13a0872a1/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=228d6f45d8fbf289e6505d12379a41e13a0872a1", "patch": "@@ -225,7 +225,7 @@ fn get_symbol_hash<'a, 'tcx>(\n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     let mut buffer = SymbolPathBuffer::new(tcx);\n     item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id, false);\n+        tcx.push_item_path(&mut buffer, def_id);\n     });\n     buffer.into_interned()\n }"}, {"sha": "af40e417d6108fb1872e6975d1d1f83ff9ecad74", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/228d6f45d8fbf289e6505d12379a41e13a0872a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/228d6f45d8fbf289e6505d12379a41e13a0872a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=228d6f45d8fbf289e6505d12379a41e13a0872a1", "patch": "@@ -4243,7 +4243,7 @@ where F: Fn(DefId) -> Def {\n \n     let mut apb = AbsolutePathBuffer { names: vec![] };\n \n-    tcx.push_item_path(&mut apb, def_id, false);\n+    tcx.push_item_path(&mut apb, def_id);\n \n     hir::Path {\n         span: DUMMY_SP,"}]}