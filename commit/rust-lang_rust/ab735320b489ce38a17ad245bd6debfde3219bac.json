{"sha": "ab735320b489ce38a17ad245bd6debfde3219bac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiNzM1MzIwYjQ4OWNlMzhhMTdhZDI0NWJkNmRlYmZkZTMyMTliYWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T02:04:33Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-16T02:05:03Z"}, "message": "move regionck into typeck, in the process fixing a bug or two", "tree": {"sha": "4fb5fab0fb9986e9e2f50aaf0d73845fa15cf666", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fb5fab0fb9986e9e2f50aaf0d73845fa15cf666"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab735320b489ce38a17ad245bd6debfde3219bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab735320b489ce38a17ad245bd6debfde3219bac", "html_url": "https://github.com/rust-lang/rust/commit/ab735320b489ce38a17ad245bd6debfde3219bac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab735320b489ce38a17ad245bd6debfde3219bac/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa5cc5bcd0e370a677de141d46455d4ee518dcfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5cc5bcd0e370a677de141d46455d4ee518dcfc", "html_url": "https://github.com/rust-lang/rust/commit/fa5cc5bcd0e370a677de141d46455d4ee518dcfc"}], "stats": {"total": 367, "additions": 229, "deletions": 138}, "files": [{"sha": "6b76edbb5c78973628fb316de5a62dae4133b744", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -193,8 +193,6 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let (root_map, mutbl_map) = time(\n         time_passes, \"borrow checking\",\n         bind middle::borrowck::check_crate(ty_cx, method_map, crate));\n-    time(time_passes, \"region checking\",\n-         bind middle::regionck::check_crate(ty_cx, crate));\n     let (copy_map, ref_map) =\n         time(time_passes, \"alias checking\",\n              bind middle::alias::check_crate(ty_cx, crate));"}, {"sha": "f8fcfb481e1531cfac1b7d10d41d31f34a8446b0", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -364,8 +364,7 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let new_cx: ctxt = {closure_parent: some(item.id),\n-                        parent: some(item.id) with cx};\n+    let new_cx: ctxt = {closure_parent: none, parent: none with cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n "}, {"sha": "58c165717c7d39639007f710ac8faa873cb3f73e", "filename": "src/rustc/middle/regionck.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fa5cc5bcd0e370a677de141d46455d4ee518dcfc/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5cc5bcd0e370a677de141d46455d4ee518dcfc/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=fa5cc5bcd0e370a677de141d46455d4ee518dcfc", "patch": "@@ -1,49 +0,0 @@\n-/*\n- * The region checking pass. Ensures that region-annotated pointers never\n- * outlive their referents.\n- */\n-\n-import driver::session::session;\n-import middle::ty;\n-import std::map::hashmap;\n-import syntax::{ast, visit};\n-import util::ppaux;\n-\n-fn check_expr(expr: @ast::expr,\n-              &&tcx: ty::ctxt,\n-              visitor: visit::vt<ty::ctxt>) {\n-    visit::visit_expr(expr, tcx, visitor);\n-\n-    let t = ty::expr_ty(tcx, expr);\n-    if !ty::type_has_regions(t) { ret; }\n-    ty::walk_ty(t) { |t|\n-        alt ty::get(t).struct {\n-          ty::ty_rptr(region, _) {\n-            alt region {\n-              ty::re_bound(_) | ty::re_free(_, _) | ty::re_static |\n-              ty::re_var(_) {\n-                /* ok */\n-              }\n-              ty::re_scope(id) {\n-                if !region::scope_contains(tcx.region_map, id, expr.id) {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        #fmt[\"reference is not valid outside of %s\",\n-                             ppaux::re_scope_id_to_str(tcx, id)]);\n-                }\n-              }\n-            }\n-          }\n-          _ { /* no-op */ }\n-        }\n-    }\n-}\n-\n-fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n-    let visitor = visit::mk_vt(@{\n-        visit_expr: check_expr\n-        with *visit::default_visitor()\n-    });\n-    visit::visit_crate(*crate, tcx, visitor);\n-}\n-"}, {"sha": "ba30e13aab8ad86698f833ec3529d1ad20df826d", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -101,7 +101,7 @@ export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_var, mk_var, type_is_var;\n export ty_self, mk_self, type_has_self;\n-export region, bound_region;\n+export region, bound_region, encl_region;\n export get, type_has_params, type_needs_infer, type_has_regions;\n export type_has_resources, type_id;\n export tbox_has_flag;\n@@ -685,6 +685,15 @@ fn default_arg_mode_for_ty(ty: ty::t) -> ast::rmode {\n     else { ast::by_ref }\n }\n \n+// Returns the narrowest lifetime enclosing the evaluation of the expression\n+// with id `id`.\n+fn encl_region(cx: ctxt, id: ast::node_id) -> ty::region {\n+    alt cx.region_map.parents.find(id) {\n+      some(encl_scope) {ty::re_scope(encl_scope)}\n+      none {ty::re_static}\n+    }\n+}\n+\n fn walk_ty(ty: t, f: fn(t)) {\n     maybe_walk_ty(ty, {|t| f(t); true});\n }"}, {"sha": "59a10be49efeb1604e412e85c79bb039b06a9cc6", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -630,6 +630,7 @@ impl methods for @fn_ctxt {\n     fn next_region_var() -> ty::region {\n         ret ty::re_var(self.next_region_var_id());\n     }\n+\n     fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n                                err: ty::type_err) {\n         self.ccx.tcx.sess.span_err(\n@@ -648,6 +649,10 @@ impl methods for @fn_ctxt {\n         infer::mk_eqty(self.infcx, sub, sup)\n     }\n \n+    fn mk_subr(sub: ty::region, sup: ty::region) -> result<(), ty::type_err> {\n+        infer::mk_subr(self.infcx, sub, sup)\n+    }\n+\n     fn require_unsafe(sp: span, op: str) {\n         alt self.purity {\n           ast::unsafe_fn {/*ok*/}\n@@ -796,47 +801,6 @@ fn require_same_types(\n     }\n }\n \n-mod demand {\n-    // Requires that the two types unify, and prints an error message if they\n-    // don't.\n-    fn suptype(fcx: @fn_ctxt, sp: span,\n-              expected: ty::t, actual: ty::t) {\n-\n-        // n.b.: order of actual, expected is reversed\n-        alt infer::mk_subty(fcx.infcx, actual, expected) {\n-          result::ok(()) { /* ok */ }\n-          result::err(err) {\n-            fcx.report_mismatched_types(sp, expected, actual, err);\n-          }\n-        }\n-    }\n-\n-    fn eqtype(fcx: @fn_ctxt, sp: span,\n-              expected: ty::t, actual: ty::t) {\n-\n-        alt infer::mk_eqty(fcx.infcx, actual, expected) {\n-          result::ok(()) { /* ok */ }\n-          result::err(err) {\n-            fcx.report_mismatched_types(sp, expected, actual, err);\n-          }\n-        }\n-    }\n-\n-    // Checks that the type `actual` can be assigned to `expected`.\n-    fn assign(fcx: @fn_ctxt, sp: span, borrow_scope: ast::node_id,\n-              expected: ty::t, expr: @ast::expr) {\n-        let expr_ty = fcx.expr_ty(expr);\n-        let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n-        alt infer::mk_assignty(fcx.infcx, anmnt, expr_ty, expected) {\n-          result::ok(()) { /* ok */ }\n-          result::err(err) {\n-            fcx.report_mismatched_types(sp, expected, expr_ty, err);\n-          }\n-        }\n-    }\n-}\n-\n-\n // Returns true if the two types unify and false if they don't.\n fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n     alt fcx.mk_eqty(expected, actual) {\n@@ -1594,8 +1558,7 @@ fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n  */\n fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n     fn borrow(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n-        let parent_id = fcx.ccx.tcx.region_map.parents.get(expr.id);\n-        ret ty::re_scope(parent_id);\n+        ty::encl_region(fcx.ccx.tcx, expr.id)\n     }\n \n     fn deref(fcx: @fn_ctxt, base: @ast::expr) -> ty::region {\n@@ -1970,7 +1933,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let ret_ty = ty::ty_fn_ret(fty);\n         let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n \n-        check_fn(fcx.ccx, proto, decl, body, expr.id,\n+        check_fn(fcx.ccx, proto, decl, body,\n                  ret_ty, arg_tys, is_loop_body, some(fcx),\n                  fcx.self_ty);\n     }\n@@ -2780,6 +2743,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     let cty = fcx.expr_ty(e);\n     let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n     demand::suptype(fcx, e.span, declty, cty);\n+    regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n \n@@ -2984,15 +2948,14 @@ fn check_bare_fn(ccx: @crate_ctxt,\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     let ret_ty = ty::ty_fn_ret(fty);\n     let arg_tys = vec::map(ty::ty_fn_args(fty)) {|a| a.ty };\n-    check_fn(ccx, ast::proto_bare, decl, body, id,\n+    check_fn(ccx, ast::proto_bare, decl, body,\n              ret_ty, arg_tys, false, none, self_ty);\n }\n \n fn check_fn(ccx: @crate_ctxt,\n             proto: ast::proto,\n             decl: ast::fn_decl,\n             body: ast::blk,\n-            fid: ast::node_id,\n             ret_ty: ty::t,\n             arg_tys: [ty::t],\n             indirect_ret: bool,\n@@ -3012,7 +2975,7 @@ fn check_fn(ccx: @crate_ctxt,\n         let old_isr = option::map_default(old_fcx, @nil) {\n             |fcx| fcx.in_scope_regions };\n         collect_bound_regions_in_tys(tcx, old_isr, all_tys) {\n-            |br| ty::re_free(fid, br) }\n+            |br| ty::re_free(body.node.id, br) }\n     };\n \n     // Replace the bound regions that appear in the arg tys, ret ty, etc with\n@@ -3108,6 +3071,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // resolved when the enclosing scope finishes up.\n     if option::is_none(old_fcx) {\n         vtable::resolve_in_block(fcx, body);\n+        regionck::regionck_fn(fcx, decl, body);\n         writeback::resolve_type_vars_in_fn(fcx, decl, body);\n     }\n "}, {"sha": "db9d4a14ff568ece417994022c164a6175eafd4b", "filename": "src/rustc/middle/typeck/demand.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fdemand.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -0,0 +1,39 @@\n+// Requires that the two types unify, and prints an error message if they\n+// don't.\n+fn suptype(fcx: @fn_ctxt, sp: span,\n+           expected: ty::t, actual: ty::t) {\n+\n+    // n.b.: order of actual, expected is reversed\n+    alt infer::mk_subty(fcx.infcx, actual, expected) {\n+      result::ok(()) { /* ok */ }\n+      result::err(err) {\n+        fcx.report_mismatched_types(sp, expected, actual, err);\n+      }\n+    }\n+}\n+\n+fn eqtype(fcx: @fn_ctxt, sp: span,\n+          expected: ty::t, actual: ty::t) {\n+\n+    alt infer::mk_eqty(fcx.infcx, actual, expected) {\n+      result::ok(()) { /* ok */ }\n+      result::err(err) {\n+        fcx.report_mismatched_types(sp, expected, actual, err);\n+      }\n+    }\n+}\n+\n+// Checks that the type `actual` can be assigned to `expected`.\n+fn assign(fcx: @fn_ctxt, sp: span, borrow_scope: ast::node_id,\n+          expected: ty::t, expr: @ast::expr) {\n+    let expr_ty = fcx.expr_ty(expr);\n+    let anmnt = {expr_id: expr.id, borrow_scope: borrow_scope};\n+    alt infer::mk_assignty(fcx.infcx, anmnt, expr_ty, expected) {\n+      result::ok(()) { /* ok */ }\n+      result::err(err) {\n+        fcx.report_mismatched_types(sp, expected, expr_ty, err);\n+      }\n+    }\n+}\n+\n+"}, {"sha": "1f1698751c4c983b65809cf18c7fb568a127d231", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -1512,20 +1512,18 @@ impl of combine for lub {\n \n               (f @ ty::re_free(f_id, _), ty::re_scope(s_id)) |\n               (ty::re_scope(s_id), f @ ty::re_free(f_id, _)) {\n-                // For LUB, generally the scope is within the fn and\n-                // the free region is a parameter to the fn.  In that case,\n-                // the free region will always live as long as the fn,\n-                // which is longer than the scope.\n-                //\n-                // However, with nested fns, it can happen that the\n-                // scope surrounds the fn itself.  In that case, we do\n-                // not know which will live longer---it depends on the\n-                // value provided for the free region in any given\n-                // call.  And so we must just back off to re_static as\n-                // the LUB.\n+                // A \"free\" region can be interpreted as \"some region\n+                // at least as big as the block f_id\".  So, we can\n+                // reasonably compare free regions and scopes:\n                 let rm = self.infcx().tcx.region_map;\n                 alt region::nearest_common_ancestor(rm, f_id, s_id) {\n+                  // if the free region's scope `f_id` is bigger than\n+                  // the scope region `s_id`, then the LUB is the free\n+                  // region itself:\n                   some(r_id) if r_id == f_id { ok(f) }\n+\n+                  // otherwise, we don't know what the free region is,\n+                  // so we must conservatively say the LUB is static:\n                   _ { ok(ty::re_static) }\n                 }\n               }\n@@ -1703,15 +1701,11 @@ impl of combine for glb {\n \n               (ty::re_free(f_id, _), s @ ty::re_scope(s_id)) |\n               (s @ ty::re_scope(s_id), ty::re_free(f_id, _)) {\n-                // For GLB, generally the scope is within the fn and\n-                // the free region is a parameter to the fn.  In that case,\n-                // the scope is always shorter than the free region.\n-                //\n-                // However, with nested fns, it can happen that the\n-                // scope surrounds the fn itself.  In that case, we do\n-                // not know which will live longer---it depends on the\n-                // value provided for the free region in any given\n-                // call.  And so we cannot give a GLB.\n+                // Free region is something \"at least as big as\n+                // `f_id`.\"  If we find that the scope `f_id` is bigger\n+                // than the scope `s_id`, then we can say that the GLB\n+                // is the scope `s_id`.  Otherwise, as we do not know\n+                // big the free region is precisely, the GLB is undefined.\n                 let rm = self.infcx().tcx.region_map;\n                 alt region::nearest_common_ancestor(rm, f_id, s_id) {\n                   some(r_id) if r_id == f_id { ok(s) }"}, {"sha": "2fda17235f25267b3c7530335b7897ae83ecdce8", "filename": "src/rustc/middle/typeck/regionck.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fregionck.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -0,0 +1,132 @@\n+/*\n+\n+The region check is a final pass that runs over the AST after we have\n+inferred the type constraints but before we have actually finalized\n+the types.  It's purpose is to embed some final region constraints.\n+The reason that this is not done earlier is that sometimes we don't\n+know whether a given type will be a region pointer or not until this\n+phase.\n+\n+In particular, we ensure that, if the type of an expression or\n+variable is `&r.T`, then the expression or variable must occur within\n+the region scope `r`.\n+\n+*/\n+\n+import util::ppaux;\n+import syntax::print::pprust;\n+\n+fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n+    let v = regionck_visitor(fcx);\n+    v.visit_expr(e, fcx, v);\n+}\n+\n+fn regionck_fn(fcx: @fn_ctxt,\n+               _decl: ast::fn_decl,\n+               blk: ast::blk) {\n+    let v = regionck_visitor(fcx);\n+    v.visit_block(blk, fcx, v);\n+}\n+\n+type rvt = visit::vt<@fn_ctxt>;\n+\n+fn regionck_visitor(_fcx: @fn_ctxt) -> rvt {\n+    visit::mk_vt(@{visit_item: visit_item,\n+                   visit_stmt: visit_stmt,\n+                   visit_expr: visit_expr,\n+                   visit_block: visit_block,\n+                   visit_pat: visit_pat,\n+                   visit_local: visit_local\n+                   with *visit::default_visitor()})\n+}\n+\n+fn visit_item(_item: @ast::item, &&_fcx: @fn_ctxt, _v: rvt) {\n+    // Ignore items\n+}\n+\n+fn visit_local(l: @ast::local, &&fcx: @fn_ctxt, v: rvt) {\n+    visit::visit_local(l, fcx, v);\n+}\n+\n+fn visit_pat(p: @ast::pat, &&fcx: @fn_ctxt, v: rvt) {\n+    visit::visit_pat(p, fcx, v);\n+}\n+\n+fn visit_block(b: ast::blk, &&fcx: @fn_ctxt, v: rvt) {\n+    visit::visit_block(b, fcx, v);\n+}\n+\n+fn visit_expr(e: @ast::expr, &&fcx: @fn_ctxt, v: rvt) {\n+    #debug[\"visit_expr(e=%s)\", pprust::expr_to_str(e)];\n+\n+    visit_ty(fcx.expr_ty(e), e.id, e.span, fcx);\n+    visit::visit_expr(e, fcx, v);\n+}\n+\n+fn visit_stmt(s: @ast::stmt, &&fcx: @fn_ctxt, v: rvt) {\n+    visit::visit_stmt(s, fcx, v);\n+}\n+\n+fn visit_ty(ty: ty::t,\n+            id: ast::node_id,\n+            span: span,\n+            fcx: @fn_ctxt) {\n+\n+    // Try to resolve the type.  If we encounter an error, then typeck\n+    // is going to fail anyway, so just stop here and let typeck\n+    // report errors later on in the writeback phase.\n+    let ty = alt infer::resolve_deep(fcx.infcx, ty, false) {\n+      result::err(_) { ret; }\n+      result::ok(ty) { ty }\n+    };\n+\n+    // find the region where this expr evaluation is taking place\n+    let tcx = fcx.ccx.tcx;\n+    let encl_region = ty::encl_region(tcx, id);\n+\n+    #debug[\"visit_ty(ty=%s, id=%d, encl_region=%s)\",\n+           ppaux::ty_to_str(tcx, ty),\n+           id,\n+           ppaux::region_to_str(tcx, encl_region)];\n+\n+    // Otherwise, look at the type and see if it is a region pointer.\n+    if !ty::type_has_regions(ty) { ret; }\n+    ty::walk_regions_and_ty(\n+        tcx, ty,\n+        { |r| constrain_region(fcx, encl_region, span, r); },\n+        { |t| ty::type_has_regions(t) });\n+\n+    fn constrain_region(fcx: @fn_ctxt,\n+                        encl_region: ty::region,\n+                        span: span,\n+                        region: ty::region) {\n+        let tcx = fcx.ccx.tcx;\n+\n+        #debug[\"constrain_region(encl_region=%s, region=%s)\",\n+               ppaux::region_to_str(tcx, encl_region),\n+               ppaux::region_to_str(tcx, region)];\n+\n+        alt region {\n+          ty::re_bound(_) {\n+            // a bound region is one which appears inside an fn type.\n+            // (e.g., the `&` in `fn(&T)`).  Such regions need not be\n+            // constrained by `encl_region` as they are placeholders\n+            // for regions that are as-yet-unknown.\n+            ret;\n+          }\n+          _ {}\n+        }\n+\n+        alt fcx.mk_subr(encl_region, region) {\n+          result::err(_) {\n+            tcx.sess.span_err(\n+                span,\n+                #fmt[\"reference is not valid outside \\\n+                      of its lifetime, %s\",\n+                     ppaux::region_to_str(tcx, region)]);\n+          }\n+          result::ok(()) {\n+          }\n+        }\n+    }\n+}"}, {"sha": "d8569e46af186782e8f18b8d37f08e1586e995ec", "filename": "src/rustc/middle/typeck/writeback.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fwriteback.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -150,16 +150,19 @@ fn visit_item(_item: @ast::item, _wbcx: wb_ctxt, _v: wb_vt) {\n     // Ignore items\n }\n \n+fn mk_visitor() -> visit::vt<wb_ctxt> {\n+    visit::mk_vt(@{visit_item: visit_item,\n+                   visit_stmt: visit_stmt,\n+                   visit_expr: visit_expr,\n+                   visit_block: visit_block,\n+                   visit_pat: visit_pat,\n+                   visit_local: visit_local\n+                   with *visit::default_visitor()})\n+}\n+\n fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n-    let visit =\n-        visit::mk_vt(@{visit_item: visit_item,\n-                       visit_stmt: visit_stmt,\n-                       visit_expr: visit_expr,\n-                       visit_block: visit_block,\n-                       visit_pat: visit_pat,\n-                       visit_local: visit_local\n-                       with *visit::default_visitor()});\n+    let visit = mk_visitor();\n     visit.visit_expr(e, wbcx, visit);\n     ret wbcx.success;\n }\n@@ -168,14 +171,7 @@ fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n                            decl: ast::fn_decl,\n                            blk: ast::blk) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};\n-    let visit =\n-        visit::mk_vt(@{visit_item: visit_item,\n-                       visit_stmt: visit_stmt,\n-                       visit_expr: visit_expr,\n-                       visit_block: visit_block,\n-                       visit_pat: visit_pat,\n-                       visit_local: visit_local\n-                       with *visit::default_visitor()});\n+    let visit = mk_visitor();\n     visit.visit_block(blk, wbcx, visit);\n     for decl.inputs.each {|arg|\n         resolve_type_vars_for_node(wbcx, arg.ty.span, arg.id);"}, {"sha": "67e583eb5f9dac2f5f0d1ebeb4da64445d6ceea9", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -52,6 +52,8 @@ mod middle {\n     mod ast_map;\n     mod resolve;\n     mod typeck {\n+        mod regionck;\n+        mod demand;\n         mod infer;\n         mod astconv;\n         mod collect;\n@@ -72,7 +74,6 @@ mod middle {\n     mod capture;\n     mod pat_util;\n     mod region;\n-    mod regionck;\n     mod const_eval;\n     mod astencode;\n "}, {"sha": "d2fcac56bedbf6d045a46a06489f905aba2ec416", "filename": "src/test/compile-fail/regions-borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-borrow.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -3,6 +3,7 @@ fn foo(x: &uint) -> &uint { x }\n fn main() {\n     let p = @3u;\n     let r = foo(p);\n+    //!^ ERROR reference is not valid\n     assert *p == *r;\n     //!^ ERROR reference is not valid\n }"}, {"sha": "fc3247de05554a028200c18584549448f0f46498", "filename": "src/test/compile-fail/regions-escape-into-other-fn.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Ftest%2Fcompile-fail%2Fregions-escape-into-other-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab735320b489ce38a17ad245bd6debfde3219bac/src%2Ftest%2Fcompile-fail%2Fregions-escape-into-other-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-into-other-fn.rs?ref=ab735320b489ce38a17ad245bd6debfde3219bac", "patch": "@@ -0,0 +1,7 @@\n+fn foo(x: &uint) -> &uint { x }\n+fn bar(x: &uint) -> uint { *x }\n+\n+fn main() {\n+    let p = @3u;\n+    bar(foo(p)); //! ERROR reference is not valid\n+}"}]}