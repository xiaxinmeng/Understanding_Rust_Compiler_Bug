{"sha": "341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MWEwN2M0YzNhZGJjOTZiNGE3ZmQ2NTMyZWQzNGJmZWIyMmQ1NTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-02T11:14:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-02T19:02:59Z"}, "message": "compute union-find of locals flowing into the output of statics\n\nCo-authored-by: lqd <remy.rakic+github@gmail.com>\nCo-authored-by: nikomatsakis <niko@alum.mit.edu>", "tree": {"sha": "908283c7357aadfee92278b201874b483ce90cd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/908283c7357aadfee92278b201874b483ce90cd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "html_url": "https://github.com/rust-lang/rust/commit/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db5476571d9b27c862b95c1e64764b0ac8980e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5476571d9b27c862b95c1e64764b0ac8980e23", "html_url": "https://github.com/rust-lang/rust/commit/db5476571d9b27c862b95c1e64764b0ac8980e23"}], "stats": {"total": 227, "additions": 203, "deletions": 24}, "files": [{"sha": "da9cc10853e9dd8b99c4d8a7635ae0f60d5ee5d0", "filename": "src/librustc_mir/borrow_check/nll/escaping_locals.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fescaping_locals.rs?ref=341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A MIR walk gathering a union-crfind of assigned locals, for the purpose of locating the ones\n+//! escaping into the output.\n+\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::*;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::unify as ut;\n+\n+crate struct EscapingLocals {\n+    unification_table: ut::UnificationTable<ut::InPlace<AssignedLocal>>,\n+}\n+\n+impl EscapingLocals {\n+    crate fn compute(mir: &Mir<'_>) -> Self {\n+        let mut visitor = GatherAssignedLocalsVisitor::new();\n+        visitor.visit_mir(mir);\n+\n+        EscapingLocals { unification_table: visitor.unification_table }\n+    }\n+\n+    /// True if `local` is known to escape into static\n+    /// memory.\n+    crate fn escapes_into_return(&mut self, local: Local) -> bool {\n+        let return_place = AssignedLocal::from(RETURN_PLACE);\n+        let other_place = AssignedLocal::from(local);\n+        self.unification_table.unioned(return_place, other_place)\n+    }\n+}\n+\n+/// The MIR visitor gathering the union-find of the locals used in\n+/// assignments.\n+struct GatherAssignedLocalsVisitor {\n+    unification_table: ut::UnificationTable<ut::InPlace<AssignedLocal>>,\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+struct AssignedLocal(u32);\n+\n+impl ut::UnifyKey for AssignedLocal {\n+    type Value = ();\n+\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_index(i: u32) -> AssignedLocal {\n+        AssignedLocal(i)\n+    }\n+\n+    fn tag() -> &'static str {\n+        \"AssignedLocal\"\n+    }\n+}\n+\n+impl From<Local> for AssignedLocal {\n+    fn from(item: Local) -> Self {\n+        // newtype_indexes use usize but are u32s.\n+        assert!(item.index() < ::std::u32::MAX as usize);\n+        AssignedLocal(item.index() as u32)\n+    }\n+}\n+\n+impl GatherAssignedLocalsVisitor {\n+    fn new() -> Self {\n+        Self {\n+            unification_table: ut::UnificationTable::new(),\n+        }\n+    }\n+\n+    fn union_locals_if_needed(&mut self, lvalue: Option<Local>, rvalue: Option<Local>) {\n+        if let Some(lvalue) = lvalue {\n+            if let Some(rvalue) = rvalue {\n+                if lvalue != rvalue {\n+                    self.unification_table\n+                        .union(AssignedLocal::from(lvalue), AssignedLocal::from(rvalue));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Returns the potential `Local` associated to this `Place` or `PlaceProjection`\n+fn find_local_in_place(place: &Place) -> Option<Local> {\n+    match place {\n+        Place::Local(local) => Some(*local),\n+\n+        // If you do e.g. `x = a.f` then only *part* of the type of\n+        // `a` escapes into `x` (the part contained in `f`); if `a`'s\n+        // type has regions that don't appear in `f`, those might not\n+        // escape.\n+        Place::Projection(..) => None,\n+\n+        Place::Static { .. } | Place::Promoted { .. } => None,\n+    }\n+}\n+\n+// Returns the potential `Local` in this `Operand`.\n+fn find_local_in_operand(op: &Operand) -> Option<Local> {\n+    // Conservatively check a subset of `Operand`s we know our\n+    // benchmarks track, for example `html5ever`.\n+    match op {\n+        Operand::Copy(place) | Operand::Move(place) => find_local_in_place(place),\n+        Operand::Constant(_) => None,\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for GatherAssignedLocalsVisitor {\n+    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n+        // We need as many union-find keys as there are locals\n+        for _ in 0..mir.local_decls.len() {\n+            self.unification_table.new_key(());\n+        }\n+\n+        self.super_mir(mir);\n+    }\n+\n+    fn visit_assign(\n+        &mut self,\n+        block: BasicBlock,\n+        place: &Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        let local = find_local_in_place(place);\n+\n+        // Conservatively check a subset of `Rvalue`s we know our\n+        // benchmarks track, for example `html5ever`.\n+        match rvalue {\n+            Rvalue::Use(op) => self.union_locals_if_needed(local, find_local_in_operand(op)),\n+            Rvalue::Ref(_, _, place) => {\n+                self.union_locals_if_needed(local, find_local_in_place(place))\n+            }\n+\n+            Rvalue::Cast(kind, op, _) => match kind {\n+                CastKind::Unsize => self.union_locals_if_needed(local, find_local_in_operand(op)),\n+                _ => (),\n+            },\n+\n+            Rvalue::Aggregate(_, ops) => {\n+                for rvalue in ops.iter().map(find_local_in_operand) {\n+                    self.union_locals_if_needed(local, rvalue);\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        self.super_assign(block, place, rvalue, location);\n+    }\n+}"}, {"sha": "be29744ab136ffdcb5515df4e1b092b5f56fa9d1", "filename": "src/librustc_mir/borrow_check/nll/liveness_map.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fliveness_map.rs?ref=341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "patch": "@@ -16,9 +16,10 @@\n //! liveness code so that it only operates over variables with regions in their\n //! types, instead of all variables.\n \n+use borrow_check::nll::escaping_locals::EscapingLocals;\n+use rustc::mir::{Local, Mir};\n use rustc::ty::TypeFoldable;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::mir::{Mir, Local};\n use util::liveness::LiveVariableMap;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -29,14 +30,13 @@ use rustc_data_structures::indexed_vec::Idx;\n crate struct NllLivenessMap {\n     /// For each local variable, contains either None (if the type has no regions)\n     /// or Some(i) with a suitable index.\n-    pub from_local: IndexVec<Local, Option<LocalWithRegion>>,\n-    /// For each LocalWithRegion, maps back to the original Local index.\n-    pub to_local: IndexVec<LocalWithRegion, Local>,\n+    from_local: IndexVec<Local, Option<LocalWithRegion>>,\n \n+    /// For each LocalWithRegion, maps back to the original Local index.\n+    to_local: IndexVec<LocalWithRegion, Local>,\n }\n \n impl LiveVariableMap for NllLivenessMap {\n-\n     fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n         self.from_local[local]\n     }\n@@ -55,21 +55,33 @@ impl LiveVariableMap for NllLivenessMap {\n impl NllLivenessMap {\n     /// Iterates over the variables in Mir and assigns each Local whose type contains\n     /// regions a LocalWithRegion index. Returns a map for converting back and forth.\n-    pub fn compute(mir: &Mir) -> Self {\n+    crate fn compute(mir: &Mir<'_>) -> Self {\n+        let mut escaping_locals = EscapingLocals::compute(mir);\n+\n         let mut to_local = IndexVec::default();\n-        let from_local: IndexVec<Local,Option<_>> = mir\n+        let from_local: IndexVec<Local, Option<_>> = mir\n             .local_decls\n             .iter_enumerated()\n             .map(|(local, local_decl)| {\n-                if local_decl.ty.has_free_regions() {\n+                if escaping_locals.escapes_into_return(local) {\n+                    // If the local escapes into the return value,\n+                    // then the return value will force all of the\n+                    // regions in its type to outlive free regions\n+                    // (e.g., `'static`) and hence liveness is not\n+                    // needed. This is particularly important for big\n+                    // statics.\n+                    None\n+                } else if local_decl.ty.has_free_regions() {\n                     Some(to_local.push(local))\n+                } else {\n+                    None\n                 }\n-                    else {\n-                        None\n-                    }\n             }).collect();\n \n-        Self { from_local, to_local }\n+        Self {\n+            from_local,\n+            to_local,\n+        }\n     }\n }\n "}, {"sha": "d991908b69984a155a51fa2b1322f44fc01672bd", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "patch": "@@ -39,7 +39,9 @@ use polonius_engine::{Algorithm, Output};\n use util as mir_util;\n use util::pretty::{self, ALIGN};\n \n+mod constraints;\n mod constraint_generation;\n+mod escaping_locals;\n pub mod explain_borrow;\n mod facts;\n mod invalidation;\n@@ -49,8 +51,6 @@ crate mod type_check;\n mod universal_regions;\n crate mod liveness_map;\n \n-mod constraints;\n-\n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n@@ -120,6 +120,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         location_table,\n         borrow_set,\n         &liveness,\n+        &liveness_map,\n         &mut all_facts,\n         flow_inits,\n         move_data,"}, {"sha": "d02f54dc4b87df4feb35bac7279b1c82526c4cad", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "patch": "@@ -37,17 +37,18 @@ pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n+    liveness_map: &NllLivenessMap,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n     let mut generator = TypeLivenessGenerator {\n         cx,\n         mir,\n         liveness,\n+        liveness_map,\n         flow_inits,\n         move_data,\n         drop_data: FxHashMap(),\n-        map: &NllLivenessMap::compute(mir),\n     };\n \n     for bb in mir.basic_blocks().indices() {\n@@ -65,10 +66,10 @@ where\n     cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults<LocalWithRegion>,\n+    liveness_map: &'gen NllLivenessMap,\n     flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n     drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n-    map: &'gen NllLivenessMap,\n }\n \n struct DropData<'tcx> {\n@@ -86,9 +87,9 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n \n         self.liveness\n             .regular\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.liveness_map, |location, live_locals| {\n                 for live_local in live_locals.iter() {\n-                    let local = self.map.from_live_var(live_local);\n+                    let local = self.liveness_map.from_live_var(live_local);\n                     let live_local_ty = self.mir.local_decls[local].ty;\n                     Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n                 }\n@@ -97,7 +98,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         let mut all_live_locals: Vec<(Location, Vec<LocalWithRegion>)> = vec![];\n         self.liveness\n             .drop\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n+            .simulate_block(self.mir, bb, self.liveness_map, |location, live_locals| {\n                 all_live_locals.push((location, live_locals.iter().collect()));\n             });\n         debug!(\n@@ -124,7 +125,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                     });\n                 }\n \n-                let local = self.map.from_live_var(live_local);\n+                let local = self.liveness_map.from_live_var(live_local);\n                 let mpi = self.move_data.rev_lookup.find_local(local);\n                 if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n                     debug!(\n@@ -133,7 +134,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n                         self.move_data.move_paths[initialized_child]\n                     );\n \n-                    let local = self.map.from_live_var(live_local);\n+                    let local = self.liveness_map.from_live_var(live_local);\n                     let live_local_ty = self.mir.local_decls[local].ty;\n                     self.add_drop_live_constraint(live_local, live_local_ty, location);\n                 }"}, {"sha": "15afc6c52bf2b34eec323282f19e110bad45aec2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341a07c4c3adbc96b4a7fd6532ed34bfeb22d553/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=341a07c4c3adbc96b4a7fd6532ed34bfeb22d553", "patch": "@@ -15,9 +15,12 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n+use borrow_check::nll::liveness_map::NllLivenessMap;\n+use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n+use borrow_check::nll::type_check::free_region_relations::{\n+    CreateResult, UniversalRegionRelations,\n+};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::LocalWithRegion;\n use borrow_check::nll::ToRegionVid;\n@@ -116,6 +119,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n+    liveness_map: &NllLivenessMap,\n     all_facts: &mut Option<AllFacts>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -166,7 +170,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             Some(&mut borrowck_context),\n             Some(errors_buffer),\n             |cx| {\n-                liveness::generate(cx, mir, liveness, flow_inits, move_data);\n+                liveness::generate(cx, mir, liveness, liveness_map, flow_inits, move_data);\n                 cx.equate_inputs_and_outputs(\n                     mir,\n                     mir_def_id,"}]}