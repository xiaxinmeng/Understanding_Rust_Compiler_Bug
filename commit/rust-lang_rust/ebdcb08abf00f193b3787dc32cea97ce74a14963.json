{"sha": "ebdcb08abf00f193b3787dc32cea97ce74a14963", "node_id": "C_kwDOAAsO6NoAKGViZGNiMDhhYmYwMGYxOTNiMzc4N2RjMzJjZWE5N2NlNzRhMTQ5NjM", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-05-06T06:18:11Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-05-06T07:14:44Z"}, "message": "For now, don't change the details of hashing a `str`\n\nWe might want to change the default before stabilizing (or maybe even after), but for getting in the new unstable methods, leave it as-is for now.  That way it won't break cargo and such.", "tree": {"sha": "430900e4930e68679d0a4a16d2b89e42e13a44b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/430900e4930e68679d0a4a16d2b89e42e13a44b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebdcb08abf00f193b3787dc32cea97ce74a14963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebdcb08abf00f193b3787dc32cea97ce74a14963", "html_url": "https://github.com/rust-lang/rust/commit/ebdcb08abf00f193b3787dc32cea97ce74a14963", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebdcb08abf00f193b3787dc32cea97ce74a14963/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98054377ee13956e6134b13aa31be01d9cd5a6af", "url": "https://api.github.com/repos/rust-lang/rust/commits/98054377ee13956e6134b13aa31be01d9cd5a6af", "html_url": "https://github.com/rust-lang/rust/commit/98054377ee13956e6134b13aa31be01d9cd5a6af"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "9d64c786d67b5111167a92e3b92d81c4733690fc", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ebdcb08abf00f193b3787dc32cea97ce74a14963/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebdcb08abf00f193b3787dc32cea97ce74a14963/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=ebdcb08abf00f193b3787dc32cea97ce74a14963", "patch": "@@ -479,31 +479,62 @@ pub trait Hasher {\n     ///\n     /// # Note to Implementers\n     ///\n-    /// The default implementation of this method includes a call to\n-    /// [`Self::write_length_prefix`], so if your implementation of `Hasher`\n-    /// doesn't care about prefix-freedom and you've thus overridden\n-    /// that method to do nothing, there's no need to override this one.\n-    ///\n-    /// This method is available to be overridden separately from the others\n-    /// as `str` being UTF-8 means that it never contains `0xFF` bytes, which\n-    /// can be used to provide prefix-freedom cheaper than hashing a length.\n-    ///\n-    /// For example, if your `Hasher` works byte-by-byte (perhaps by accumulating\n-    /// them into a buffer), then you can hash the bytes of the `str` followed\n-    /// by a single `0xFF` byte.\n-    ///\n-    /// If your `Hasher` works in chunks, you can also do this by being careful\n-    /// about how you pad partial chunks.  If the chunks are padded with `0x00`\n-    /// bytes then just hashing an extra `0xFF` byte doesn't necessarily\n-    /// provide prefix-freedom, as `\"ab\"` and `\"ab\\u{0}\"` would likely hash\n-    /// the same sequence of chunks.  But if you pad with `0xFF` bytes instead,\n-    /// ensuring at least one padding byte, then it can often provide\n-    /// prefix-freedom cheaper than hashing the length would.\n+    /// There are at least two reasonable default ways to implement this.\n+    /// Which one will be the default is not yet decided, so for now\n+    /// you probably want to override it specifically.\n+    ///\n+    /// ## The general answer\n+    ///\n+    /// It's always correct to implement this with a length prefix:\n+    ///\n+    /// ```\n+    /// # #![feature(hasher_prefixfree_extras)]\n+    /// # struct Foo;\n+    /// # impl std::hash::Hasher for Foo {\n+    /// # fn finish(&self) -> u64 { unimplemented!() }\n+    /// # fn write(&mut self, _bytes: &[u8]) { unimplemented!() }\n+    /// fn write_str(&mut self, s: &str) {\n+    ///     self.write_length_prefix(s.len());\n+    ///     self.write(s.as_bytes());\n+    /// }\n+    /// # }\n+    /// ```\n+    ///\n+    /// And, if your `Hasher` works in `usize` chunks, this is likely a very\n+    /// efficient way to do it, as anything more complicated may well end up\n+    /// slower than just running the round with the length.\n+    ///\n+    /// ## If your `Hasher` works byte-wise\n+    ///\n+    /// One nice thing about `str` being UTF-8 is that the `b'\\xFF'` byte\n+    /// never happens.  That means that you can append that to the byte stream\n+    /// being hashed and maintain prefix-freedom:\n+    ///\n+    /// ```\n+    /// # #![feature(hasher_prefixfree_extras)]\n+    /// # struct Foo;\n+    /// # impl std::hash::Hasher for Foo {\n+    /// # fn finish(&self) -> u64 { unimplemented!() }\n+    /// # fn write(&mut self, _bytes: &[u8]) { unimplemented!() }\n+    /// fn write_str(&mut self, s: &str) {\n+    ///     self.write(s.as_bytes());\n+    ///     self.write_u8(0xff);\n+    /// }\n+    /// # }\n+    /// ```\n+    ///\n+    /// This does require that your implementation not add extra padding, and\n+    /// thus generally requires that you maintain a buffer, running a round\n+    /// only once that buffer is full (or `finish` is called).\n+    ///\n+    /// That's because if `write` pads data out to a fixed chunk size, it's\n+    /// likely that it does it in such a way that `\"a\"` and `\"a\\x00\"` would\n+    /// end up hashing the same sequence of things, introducing conflicts.\n     #[inline]\n     #[unstable(feature = \"hasher_prefixfree_extras\", issue = \"96762\")]\n     fn write_str(&mut self, s: &str) {\n-        self.write_length_prefix(s.len());\n         self.write(s.as_bytes());\n+        self.write_u8(0xff);\n     }\n }\n "}]}