{"sha": "2526accdd35c564eee80b6453a0b4965e6a76afd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MjZhY2NkZDM1YzU2NGVlZTgwYjY0NTNhMGI0OTY1ZTZhNzZhZmQ=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-26T16:11:47Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-26T16:11:47Z"}, "message": "Fix issues from review and unsoundness of `RawVec::into_box`", "tree": {"sha": "76705d1a424dc9682b2e1c2599db6a0985d25335", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76705d1a424dc9682b2e1c2599db6a0985d25335"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2526accdd35c564eee80b6453a0b4965e6a76afd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2526accdd35c564eee80b6453a0b4965e6a76afd", "html_url": "https://github.com/rust-lang/rust/commit/2526accdd35c564eee80b6453a0b4965e6a76afd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2526accdd35c564eee80b6453a0b4965e6a76afd/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56cbf2f22aeb6448acd7eb49e9b2554c80bdbf79", "url": "https://api.github.com/repos/rust-lang/rust/commits/56cbf2f22aeb6448acd7eb49e9b2554c80bdbf79", "html_url": "https://github.com/rust-lang/rust/commit/56cbf2f22aeb6448acd7eb49e9b2554c80bdbf79"}], "stats": {"total": 898, "additions": 430, "deletions": 468}, "files": [{"sha": "7eb9e0d5ea3e11681de5101f6d2c0a78d5c59191", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 45, "deletions": 51, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -4,7 +4,7 @@\n \n use core::intrinsics::{self, min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n-use core::usize;\n+use core::{mem, usize};\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n@@ -165,102 +165,96 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let new_size = layout.size();\n-        if new_size == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe {\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        unsafe {\n+            if layout.size() == 0 {\n+                Ok(MemoryBlock::new(layout.dangling(), layout))\n+            } else {\n                 let raw_ptr = match init {\n                     AllocInit::Uninitialized => alloc(layout),\n                     AllocInit::Zeroed => alloc_zeroed(layout),\n                 };\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok((ptr, new_size))\n+                Ok(MemoryBlock::new(ptr, layout))\n             }\n         }\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        if layout.size() != 0 {\n-            dealloc(ptr.as_ptr(), layout)\n+    unsafe fn dealloc(&mut self, memory: MemoryBlock) {\n+        if memory.size() != 0 {\n+            dealloc(memory.ptr().as_ptr(), memory.layout())\n         }\n     }\n \n     #[inline]\n     unsafe fn grow(\n         &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n+        memory: &mut MemoryBlock,\n         new_size: usize,\n         placement: ReallocPlacement,\n         init: AllocInit,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n+    ) -> Result<(), AllocErr> {\n+        let old_size = memory.size();\n         debug_assert!(\n             new_size >= old_size,\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n+            \"`new_size` must be greater than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok((ptr, new_size));\n+            return Ok(());\n         }\n \n+        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n+            ReallocPlacement::InPlace => return Err(AllocErr),\n+            ReallocPlacement::MayMove if memory.size() == 0 => {\n+                *memory = self.alloc(new_layout, init)?\n+            }\n             ReallocPlacement::MayMove => {\n-                if old_size == 0 {\n-                    self.alloc(Layout::from_size_align_unchecked(new_size, layout.align()), init)\n-                } else {\n-                    // `realloc` probably checks for `new_size > old_size` or something similar.\n-                    // `new_size` must be greater than or equal to `old_size` due to the safety constraint,\n-                    // and `new_size` == `old_size` was caught before\n-                    intrinsics::assume(new_size > old_size);\n-                    let ptr =\n-                        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)?;\n-                    let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-                    init.initialize_offset(ptr, new_layout, old_size);\n-                    Ok((ptr, new_size))\n-                }\n+                // `realloc` probably checks for `new_size > old_size` or something similar.\n+                intrinsics::assume(new_size > old_size);\n+                let ptr = realloc(memory.ptr().as_ptr(), memory.layout(), new_size);\n+                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n+                memory.init_offset(init, old_size);\n             }\n-            ReallocPlacement::InPlace => Err(AllocErr),\n         }\n+        Ok(())\n     }\n \n     #[inline]\n     unsafe fn shrink(\n         &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n+        memory: &mut MemoryBlock,\n         new_size: usize,\n         placement: ReallocPlacement,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n+    ) -> Result<(), AllocErr> {\n+        let old_size = memory.size();\n         debug_assert!(\n             new_size <= old_size,\n-            \"`new_size` must be smaller than or equal to `layout.size()`\"\n+            \"`new_size` must be smaller than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok((ptr, new_size));\n+            return Ok(());\n         }\n \n+        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n+            ReallocPlacement::InPlace => return Err(AllocErr),\n+            ReallocPlacement::MayMove if new_size == 0 => {\n+                let new_memory = MemoryBlock::new(new_layout.dangling(), new_layout);\n+                let old_memory = mem::replace(memory, new_memory);\n+                self.dealloc(old_memory)\n+            }\n             ReallocPlacement::MayMove => {\n-                let ptr = if new_size == 0 {\n-                    self.dealloc(ptr, layout);\n-                    layout.dangling()\n-                } else {\n-                    // `realloc` probably checks for `new_size > old_size` or something similar.\n-                    // `new_size` must be smaller than or equal to `old_size` due to the safety constraint,\n-                    // and `new_size` == `old_size` was caught before\n-                    intrinsics::assume(new_size < old_size);\n-                    NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)?\n-                };\n-                Ok((ptr, new_size))\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n+                let ptr = realloc(memory.ptr().as_ptr(), memory.layout(), new_size);\n+                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n             }\n-            ReallocPlacement::InPlace => Err(AllocErr),\n         }\n+        Ok(())\n     }\n }\n \n@@ -272,7 +266,7 @@ unsafe impl AllocRef for Global {\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     let layout = Layout::from_size_align_unchecked(size, align);\n     match Global.alloc(layout, AllocInit::Uninitialized) {\n-        Ok((ptr, _)) => ptr.as_ptr(),\n+        Ok(memory) => memory.ptr().as_ptr(),\n         Err(_) => handle_alloc_error(layout),\n     }\n }\n@@ -288,7 +282,7 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     let size = size_of_val(ptr.as_ref());\n     let align = min_align_of_val(ptr.as_ref());\n     let layout = Layout::from_size_align_unchecked(size, align);\n-    Global.dealloc(ptr.cast().into(), layout)\n+    Global.dealloc(MemoryBlock::new(ptr.cast().into(), layout))\n }\n \n /// Abort on memory allocation error or failure."}, {"sha": "34380ba41b4fd52e94b03c51741398e7fa0a65e5", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -8,17 +8,17 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let (ptr, _) = Global\n+        let memory = Global\n             .alloc(layout.clone(), AllocInit::Zeroed)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n-        let mut i = ptr.cast::<u8>().as_ptr();\n+        let mut i = memory.ptr().cast::<u8>().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(ptr, layout);\n+        Global.dealloc(memory);\n     }\n }\n "}, {"sha": "03d759e4a9ae428da7cd63163bd3feb638d2f0c4", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -143,7 +143,6 @@ use core::ops::{\n };\n use core::pin::Pin;\n use core::ptr::{self, NonNull, Unique};\n-use core::slice;\n use core::task::{Context, Poll};\n \n use crate::alloc::{self, AllocInit, AllocRef, Global};\n@@ -199,7 +198,7 @@ impl<T> Box<T> {\n         let ptr = Global\n             .alloc(layout, AllocInit::Uninitialized)\n             .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .0\n+            .ptr()\n             .cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n@@ -228,7 +227,7 @@ impl<T> Box<T> {\n         let ptr = Global\n             .alloc(layout, AllocInit::Zeroed)\n             .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .0\n+            .ptr()\n             .cast();\n         unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n@@ -265,13 +264,7 @@ impl<T> Box<[T]> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n-        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        let ptr = Global\n-            .alloc(layout, AllocInit::Uninitialized)\n-            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n-            .0\n-            .cast();\n-        unsafe { Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len)) }\n+        unsafe { RawVec::with_capacity(len).into_box(len) }\n     }\n }\n \n@@ -776,7 +769,7 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n         let buf = RawVec::with_capacity(len);\n         unsafe {\n             ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n-            buf.into_box().assume_init()\n+            buf.into_box(slice.len()).assume_init()\n         }\n     }\n }"}, {"sha": "8b4daa28ee8bc82a002b6db813ed7814e21d67b0", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -31,6 +31,7 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n+use core::alloc::MemoryBlock;\n use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n@@ -227,7 +228,10 @@ impl<K, V> Root<K, V> {\n         }\n \n         unsafe {\n-            Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(MemoryBlock::new(\n+                NonNull::from(top).cast(),\n+                Layout::new::<InternalNode<K, V>>(),\n+            ));\n         }\n     }\n }\n@@ -392,14 +396,14 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(\n+        Global.dealloc(MemoryBlock::new(\n             node.cast(),\n             if height > 0 {\n                 Layout::new::<InternalNode<K, V>>()\n             } else {\n                 Layout::new::<LeafNode<K, V>>()\n             },\n-        );\n+        ));\n         ret\n     }\n }\n@@ -1142,7 +1146,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n-            if self.node.height > 1 {\n+            let layout = if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n                     right_node.cast_unchecked().as_internal().edges.as_ptr(),\n                     left_node\n@@ -1159,10 +1163,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                         .correct_parent_link();\n                 }\n \n-                Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n+                Layout::new::<InternalNode<K, V>>()\n             } else {\n-                Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n-            }\n+                Layout::new::<LeafNode<K, V>>()\n+            };\n+            Global.dealloc(MemoryBlock::new(right_node.node.cast(), layout));\n \n             Handle::new_edge(self.node, self.idx)\n         }"}, {"sha": "121c1cde548cbb3746ddeab2061eea6bccd9ace5", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -100,6 +100,7 @@\n #![feature(lang_items)]\n #![feature(libc)]\n #![cfg_attr(not(bootstrap), feature(negative_impls))]\n+#![feature(new_uninit)]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]"}, {"sha": "aee2367bd951b16cb872343cf5e0e5cfe269b161", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -1,6 +1,7 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n+use core::alloc::MemoryBlock;\n use core::cmp;\n use core::mem::{self, MaybeUninit};\n use core::ops::Drop;\n@@ -24,6 +25,9 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n+/// * Produces `Unique::empty()` on zero-sized types.\n+/// * Produces `Unique::empty()` on zero-length allocations.\n+/// * Avoids freeing `Unique::empty()`.\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n /// * Guards against overflowing your length.\n@@ -44,38 +48,7 @@ mod tests;\n pub struct RawVec<T, A: AllocRef = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n-    a: A,\n-}\n-\n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Like `new`, but parameterized over the choice of allocator for\n-    /// the returned `RawVec`.\n-    pub const fn new_in(a: A) -> Self {\n-        // `cap: 0` means \"unallocated\". zero-sized allocations are handled by `AllocRef`\n-        Self { ptr: Unique::empty(), cap: 0, a }\n-    }\n-\n-    /// Like `with_capacity`, but parameterized over the choice of\n-    /// allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n-        Self::allocate_in(capacity, Uninitialized, a)\n-    }\n-\n-    /// Like `with_capacity_zeroed`, but parameterized over the choice\n-    /// of allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n-        Self::allocate_in(capacity, Zeroed, a)\n-    }\n-\n-    fn allocate_in(capacity: usize, init: AllocInit, mut a: A) -> Self {\n-        let layout = Layout::array::<T>(capacity).unwrap_or_else(|_| capacity_overflow());\n-        alloc_guard(layout.size()).unwrap_or_else(|_| capacity_overflow());\n-\n-        let (ptr, excess) = a.alloc(layout, init).unwrap_or_else(|_| handle_alloc_error(layout));\n-        Self { ptr: ptr.cast().into(), cap: Self::capacity_from_bytes(excess), a }\n-    }\n+    alloc: A,\n }\n \n impl<T> RawVec<T, Global> {\n@@ -126,23 +99,7 @@ impl<T> RawVec<T, Global> {\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n         Self::with_capacity_zeroed_in(capacity, Global)\n     }\n-}\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n-    ///\n-    /// # Undefined Behavior\n-    ///\n-    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n-    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n-    #[inline]\n-    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n-        Self { ptr: Unique::new_unchecked(ptr), cap: capacity, a }\n-    }\n-}\n-\n-impl<T> RawVec<T, Global> {\n     /// Reconstitutes a `RawVec` from a pointer and capacity.\n     ///\n     /// # Undefined Behavior\n@@ -166,6 +123,55 @@ impl<T> RawVec<T, Global> {\n }\n \n impl<T, A: AllocRef> RawVec<T, A> {\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n+    pub const fn new_in(alloc: A) -> Self {\n+        // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n+        Self { ptr: Unique::empty(), cap: 0, alloc }\n+    }\n+\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, Uninitialized, alloc)\n+    }\n+\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, Zeroed, alloc)\n+    }\n+\n+    fn allocate_in(capacity: usize, init: AllocInit, mut alloc: A) -> Self {\n+        if mem::size_of::<T>() == 0 {\n+            Self::new_in(alloc)\n+        } else {\n+            let layout = Layout::array::<T>(capacity).unwrap_or_else(|_| capacity_overflow());\n+            alloc_guard(layout.size()).unwrap_or_else(|_| capacity_overflow());\n+\n+            let memory = alloc.alloc(layout, init).unwrap_or_else(|_| handle_alloc_error(layout));\n+            Self {\n+                ptr: memory.ptr().cast().into(),\n+                cap: Self::capacity_from_bytes(memory.size()),\n+                alloc,\n+            }\n+        }\n+    }\n+\n+    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n+    ///\n+    /// # Undefined Behavior\n+    ///\n+    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n+    #[inline]\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n+        Self { ptr: Unique::new_unchecked(ptr), cap: capacity, alloc: a }\n+    }\n+\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n     /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n@@ -183,24 +189,25 @@ impl<T, A: AllocRef> RawVec<T, A> {\n \n     /// Returns a shared reference to the allocator backing this `RawVec`.\n     pub fn alloc(&self) -> &A {\n-        &self.a\n+        &self.alloc\n     }\n \n     /// Returns a mutable reference to the allocator backing this `RawVec`.\n     pub fn alloc_mut(&mut self) -> &mut A {\n-        &mut self.a\n+        &mut self.alloc\n     }\n \n-    fn current_layout(&self) -> Option<Layout> {\n-        if self.cap == 0 {\n+    fn current_memory(&self) -> Option<MemoryBlock> {\n+        if mem::size_of::<T>() == 0 || self.cap == 0 {\n             None\n         } else {\n             // We have an allocated chunk of memory, so we can bypass runtime\n             // checks to get our current layout.\n             unsafe {\n                 let align = mem::align_of::<T>();\n                 let size = mem::size_of::<T>() * self.cap;\n-                Some(Layout::from_size_align_unchecked(size, align))\n+                let layout = Layout::from_size_align_unchecked(size, align);\n+                Some(MemoryBlock::new(self.ptr.cast().into(), layout))\n             }\n         }\n     }\n@@ -454,14 +461,19 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n     /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n     fn needs_to_grow(&self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n-        needed_extra_capacity > self.capacity().wrapping_sub(used_capacity)\n+        mem::size_of::<T>() != 0\n+            && needed_extra_capacity > self.capacity().wrapping_sub(used_capacity)\n     }\n \n     fn capacity_from_bytes(excess: usize) -> usize {\n-        match mem::size_of::<T>() {\n-            0 => usize::MAX,\n-            elem_size => excess / elem_size,\n-        }\n+        debug_assert_ne!(mem::size_of::<T>(), 0);\n+        excess / mem::size_of::<T>()\n+    }\n+\n+    fn set_memory(&mut self, memory: MemoryBlock) {\n+        self.ptr = memory.ptr().cast().into();\n+        self.cap = Self::capacity_from_bytes(memory.size());\n+        drop(memory);\n     }\n \n     /// Single method to handle all possibilities of growing the buffer.\n@@ -471,9 +483,9 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         placement: ReallocPlacement,\n         init: AllocInit,\n     ) -> Result<(), TryReserveError> {\n-        let elem_size = mem::size_of::<T>();\n-        let new_layout = match strategy {\n+        let layout = match strategy {\n             Double => unsafe {\n+                let elem_size = mem::size_of::<T>();\n                 if elem_size == 0 {\n                     // Since we return a capacity of `usize::MAX` when `elem_size` is\n                     // 0, getting to here necessarily means the `RawVec` is overfull.\n@@ -511,24 +523,24 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             }\n         };\n \n-        let allocation = if let Some(old_layout) = self.current_layout() {\n-            debug_assert!(old_layout.align() == new_layout.align());\n+        let memory = if let Some(mut memory) = self.current_memory() {\n+            debug_assert_eq!(memory.align(), layout.align());\n             unsafe {\n-                self.a.grow(self.ptr.cast().into(), old_layout, new_layout.size(), placement, init)\n-            }\n+                self.alloc\n+                    .grow(&mut memory, layout.size(), placement, init)\n+                    .map_err(|_| AllocError { layout, non_exhaustive: () })?\n+            };\n+            memory\n         } else {\n             match placement {\n-                MayMove => self.a.alloc(new_layout, init),\n+                MayMove => self.alloc.alloc(layout, init),\n                 InPlace => Err(AllocErr),\n             }\n+            .map_err(|_| AllocError { layout, non_exhaustive: () })?\n         };\n \n-        allocation\n-            .map(|(ptr, excess)| {\n-                self.ptr = ptr.cast().into();\n-                self.cap = Self::capacity_from_bytes(excess);\n-            })\n-            .map_err(|_| TryReserveError::AllocError { layout: new_layout, non_exhaustive: () })\n+        self.set_memory(memory);\n+        Ok(())\n     }\n \n     fn shrink(\n@@ -538,64 +550,52 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ) -> Result<(), TryReserveError> {\n         assert!(amount <= self.cap, \"Tried to shrink to a larger capacity\");\n \n-        let elem_size = mem::size_of::<T>();\n-        let old_layout =\n-            if let Some(layout) = self.current_layout() { layout } else { return Ok(()) };\n-        let old_ptr = self.ptr.cast().into();\n-        let new_size = amount * elem_size;\n-\n-        let allocation = unsafe {\n-            if amount == 0 && placement == MayMove {\n-                self.dealloc_buffer();\n-                Ok((old_layout.dangling(), 0))\n-            } else {\n-                self.a.shrink(old_ptr, old_layout, new_size, placement)\n-            }\n-        };\n+        let mut memory = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n+        let new_size = amount * mem::size_of::<T>();\n \n-        allocation\n-            .map(|(ptr, excess)| {\n-                self.ptr = ptr.cast().into();\n-                self.cap = Self::capacity_from_bytes(excess);\n-            })\n-            .map_err(|_| TryReserveError::AllocError {\n-                layout: unsafe { Layout::from_size_align_unchecked(new_size, old_layout.align()) },\n-                non_exhaustive: (),\n-            })\n+        unsafe {\n+            self.alloc.shrink(&mut memory, new_size, placement).map_err(|_| {\n+                TryReserveError::AllocError {\n+                    layout: Layout::from_size_align_unchecked(new_size, memory.align()),\n+                    non_exhaustive: (),\n+                }\n+            })?;\n+        }\n+\n+        self.set_memory(memory);\n+        Ok(())\n     }\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Converts the entire buffer into `Box<[T]>`.\n+    /// Converts the entire buffer into `Box<[T]>` with the specified `len`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n     /// that may have been performed. (See description of type for details.)\n-    pub fn into_box(self) -> Box<[MaybeUninit<T>]> {\n-        unsafe {\n-            // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n-            let slice = slice::from_raw_parts_mut(self.ptr() as *mut MaybeUninit<T>, self.cap);\n-            let output = Box::from_raw(slice);\n-            mem::forget(self);\n-            output\n-        }\n-    }\n-}\n+    ///\n+    /// # Safety\n+    ///\n+    /// * `len` must be smaller than or equal to `self.capacity()`\n+    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+        debug_assert!(\n+            len <= self.capacity(),\n+            \"`len` must be smaller than or equal to `self.capacity()`\"\n+        );\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n-    pub unsafe fn dealloc_buffer(&mut self) {\n-        if let Some(layout) = self.current_layout() {\n-            self.a.dealloc(self.ptr.cast().into(), layout);\n-            self.ptr = Unique::empty();\n-            self.cap = 0;\n-        }\n+        // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n+        let slice = slice::from_raw_parts_mut(self.ptr() as *mut MaybeUninit<T>, len);\n+        let output = Box::from_raw(slice);\n+        mem::forget(self);\n+        output\n     }\n }\n \n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n-        unsafe { self.dealloc_buffer() }\n+        if let Some(memory) = self.current_memory() {\n+            unsafe { self.alloc.dealloc(memory) }\n+        }\n     }\n }\n "}, {"sha": "4bdd36ed63a111aed1e911b5e336cf9903d02753", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -1,5 +1,4 @@\n use super::*;\n-use core::ptr::NonNull;\n \n #[test]\n fn allocator_param() {\n@@ -13,6 +12,7 @@ fn allocator_param() {\n     //\n     // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n+\n     // storage.\n \n     // A dumb allocator that consumes a fixed amount of fuel\n@@ -21,11 +21,7 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(\n-            &mut self,\n-            layout: Layout,\n-            init: AllocInit,\n-        ) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n@@ -38,16 +34,16 @@ fn allocator_param() {\n                 err @ Err(_) => err,\n             }\n         }\n-        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-            Global.dealloc(ptr, layout)\n+        unsafe fn dealloc(&mut self, memory: MemoryBlock) {\n+            Global.dealloc(memory)\n         }\n     }\n \n     let a = BoundedAlloc { fuel: 500 };\n     let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-    assert_eq!(v.a.fuel, 450);\n+    assert_eq!(v.alloc.fuel, 450);\n     v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-    assert_eq!(v.a.fuel, 250);\n+    assert_eq!(v.alloc.fuel, 250);\n }\n \n #[test]"}, {"sha": "3625caf5f237a61bdd3b560c3ebda05bbe1789c5", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -234,6 +234,7 @@ use crate::boxed::Box;\n #[cfg(test)]\n use std::boxed::Box;\n \n+use core::alloc::MemoryBlock;\n use core::any::Any;\n use core::array::LengthAtMost32;\n use core::borrow;\n@@ -936,12 +937,12 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let (mem, _) = Global\n+        let mem = Global\n             .alloc(layout, AllocInit::Uninitialized)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = mem_to_rcbox(mem.as_ptr());\n+        let inner = mem_to_rcbox(mem.ptr().as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n@@ -1031,7 +1032,7 @@ impl<T> Rc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem, self.layout);\n+                    Global.dealloc(MemoryBlock::new(self.mem, self.layout));\n                 }\n             }\n         }\n@@ -1131,7 +1132,10 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                    Global.dealloc(MemoryBlock::new(\n+                        self.ptr.cast(),\n+                        Layout::for_value(self.ptr.as_ref()),\n+                    ));\n                 }\n             }\n         }\n@@ -1939,7 +1943,10 @@ impl<T: ?Sized> Drop for Weak<T> {\n             // the strong pointers have disappeared.\n             if inner.weak() == 0 {\n                 unsafe {\n-                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                    Global.dealloc(MemoryBlock::new(\n+                        self.ptr.cast(),\n+                        Layout::for_value(self.ptr.as_ref()),\n+                    ));\n                 }\n             }\n         }"}, {"sha": "b5e6d669f80ed80bfb348c651f146fcd7b158a2d", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -6,6 +6,7 @@\n //!\n //! [arc]: struct.Arc.html\n \n+use core::alloc::MemoryBlock;\n use core::any::Any;\n use core::array::LengthAtMost32;\n use core::borrow;\n@@ -770,7 +771,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             acquire!(self.inner().weak);\n-            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n+            Global.dealloc(MemoryBlock::new(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())))\n         }\n     }\n \n@@ -814,12 +815,12 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let (mem, _) = Global\n+        let mem = Global\n             .alloc(layout, AllocInit::Uninitialized)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = mem_to_arcinner(mem.as_ptr());\n+        let inner = mem_to_arcinner(mem.ptr().as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n@@ -909,7 +910,7 @@ impl<T> Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem.cast(), self.layout);\n+                    Global.dealloc(MemoryBlock::new(self.mem.cast(), self.layout));\n                 }\n             }\n         }\n@@ -1734,7 +1735,12 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n         if inner.weak.fetch_sub(1, Release) == 1 {\n             acquire!(inner.weak);\n-            unsafe { Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())) }\n+            unsafe {\n+                Global.dealloc(MemoryBlock::new(\n+                    self.ptr.cast(),\n+                    Layout::for_value(self.ptr.as_ref()),\n+                ))\n+            }\n         }\n     }\n }"}, {"sha": "4b0d7bc1f449eb89d037b7705b3e51e068a7a428", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n+use std::alloc::{AllocInit, AllocRef, Global, Layout, MemoryBlock, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -26,7 +26,7 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n                                 AllocInit::Uninitialized,\n                             )\n                             .unwrap()\n-                            .0\n+                            .ptr()\n                     })\n                     .collect();\n                 for &ptr in &pointers {\n@@ -39,7 +39,10 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n \n                 // Clean up\n                 for &ptr in &pointers {\n-                    allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+                    allocator.dealloc(MemoryBlock::new(\n+                        ptr,\n+                        Layout::from_size_align(size, align).unwrap(),\n+                    ))\n                 }\n             }\n         }"}, {"sha": "ba49f043d46a7b06450572e2f02e0d0d50f5021c", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -678,8 +678,9 @@ impl<T> Vec<T> {\n         unsafe {\n             self.shrink_to_fit();\n             let buf = ptr::read(&self.buf);\n+            let len = self.len();\n             mem::forget(self);\n-            buf.into_box().assume_init()\n+            buf.into_box(len).assume_init()\n         }\n     }\n "}, {"sha": "e693f50846bdbb2b27c8d43bf4c0a93be266fb33", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 137, "deletions": 180, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -11,7 +11,8 @@ pub use self::global::GlobalAlloc;\n pub use self::layout::{Layout, LayoutErr};\n \n use crate::fmt;\n-use crate::ptr::{self, NonNull};\n+use crate::mem;\n+use crate::ptr::{self, NonNull, Unique};\n \n /// The `AllocErr` error indicates an allocation failure\n /// that may be due to resource exhaustion or to\n@@ -41,49 +42,91 @@ pub enum AllocInit {\n     Zeroed,\n }\n \n-impl AllocInit {\n-    /// Initialize the memory block referenced by `ptr` and specified by `Layout`.\n+/// Represents a block of allocated memory returned by an allocator.\n+#[derive(Debug)]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[must_use = \"`MemoryBlock` should be passed to `AllocRef::dealloc`\"]\n+pub struct MemoryBlock {\n+    ptr: Unique<u8>,\n+    layout: Layout,\n+}\n+\n+impl MemoryBlock {\n+    /// Creates a new `MemoryBlock`.\n     ///\n-    /// This behaves like calling [`AllocInit::initialize_offset(ptr, layout, 0)`][off].\n+    /// # Safety\n     ///\n-    /// [off]: AllocInit::initialize_offset\n+    /// * The block must be allocated with the same alignment as [`layout.align()`], and\n+    /// * The provided [`layout.size()`] must fall in the range `min ..= max`, where:\n+    ///   - `min` is the size requested size when allocating the block, and\n+    ///   - `max` is the size of the memory block.\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub const unsafe fn new(ptr: NonNull<u8>, layout: Layout) -> Self {\n+        Self { ptr: Unique::new_unchecked(ptr.as_ptr()), layout }\n+    }\n+\n+    /// Acquires the underlying `NonNull<u8>` pointer.\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub const fn ptr(&self) -> NonNull<u8> {\n+        // SAFETY: Unique<T> is always non-null\n+        unsafe { NonNull::new_unchecked(self.ptr.as_ptr()) }\n+    }\n+\n+    /// Returns the layout describing the memory block.\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub const fn layout(&self) -> Layout {\n+        self.layout\n+    }\n+\n+    /// Returns the size of the memory block.\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub const fn size(&self) -> usize {\n+        self.layout().size()\n+    }\n+\n+    /// Returns the minimum alignment of the memory block.\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub const fn align(&self) -> usize {\n+        self.layout().align()\n+    }\n+\n+    /// Initialize the memory block like specified by `init`.\n     ///\n-    /// # Safety\n+    /// This behaves like calling [`MemoryBlock::initialize_offset(ptr, layout, 0)`][off].\n     ///\n-    /// * `layout` must [*fit*] the block of memory referenced by `ptr`\n+    /// [off]: MemoryBlock::init_offset\n     ///\n     /// [*fit*]: trait.AllocRef.html#memory-fitting\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub unsafe fn initialize(self, ptr: NonNull<u8>, layout: Layout) {\n-        self.initialize_offset(ptr, layout, 0)\n+    pub fn init(&mut self, init: AllocInit) {\n+        // SAFETY: 0 is always smaller or equal to the size\n+        unsafe { self.init_offset(init, 0) }\n     }\n \n-    /// Initialize the memory block referenced by `ptr` and specified by `Layout` at the specified\n-    /// `offset`.\n+    /// Initialize the memory block like specified by `init` at the specified `offset`.\n     ///\n     /// This is a no-op for [`AllocInit::Uninitialized`] and writes zeroes for [`AllocInit::Zeroed`]\n     /// at `ptr + offset` until `ptr + layout.size()`.\n     ///\n     /// # Safety\n     ///\n-    /// * `layout` must [*fit*] the block of memory referenced by `ptr`\n-    ///\n-    /// * `offset` must be smaller than or equal to `layout.size()`\n+    /// * `offset` must be smaller than or equal to `size()`\n     ///\n     /// [*fit*]: trait.AllocRef.html#memory-fitting\n+    #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub unsafe fn initialize_offset(self, ptr: NonNull<u8>, layout: Layout, offset: usize) {\n-        debug_assert!(\n-            offset <= layout.size(),\n-            \"`offset` must be smaller than or equal to `layout.size()`\"\n-        );\n-        match self {\n+    pub unsafe fn init_offset(&mut self, init: AllocInit, offset: usize) {\n+        debug_assert!(offset <= self.size(), \"`offset` must be smaller than or equal to `size()`\");\n+        match init {\n             AllocInit::Uninitialized => (),\n             AllocInit::Zeroed => {\n-                let new_ptr = ptr.as_ptr().add(offset);\n-                let size = layout.size() - offset;\n-                ptr::write_bytes(new_ptr, 0, size);\n+                self.ptr().as_ptr().add(offset).write_bytes(0, self.size() - offset)\n             }\n         }\n     }\n@@ -116,70 +159,23 @@ pub enum ReallocPlacement {\n ///\n /// Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `AllocRef`. If an underlying\n /// allocator does not support this (like jemalloc) or return a null pointer (such as\n-/// `libc::malloc`), this case must be caught. [`Layout::dangling()`][] then can be used to create\n-/// an aligned `NonNull<u8>`.\n-///\n-/// ### Currently allocated memory\n-///\n-/// Some of the methods require that a memory block be *currently allocated* via an allocator. This\n-/// means that:\n-///\n-/// * the starting address for that memory block was previously returned by [`alloc`], [`grow`], or\n-///   [`shrink`], and\n-///\n-/// * the memory block has not been subsequently deallocated, where blocks are either deallocated\n-///   directly by being passed to [`dealloc`] or were changed by being passed to [`grow`] or\n-///   [`shrink`] that returns `Ok`. If `grow` or `shrink` have returned `Err`, the passed pointer\n-///   remains valid.\n-///\n-/// [`alloc`]: AllocRef::alloc\n-/// [`grow`]: AllocRef::grow\n-/// [`shrink`]: AllocRef::shrink\n-/// [`dealloc`]: AllocRef::dealloc\n-///\n-/// ### Memory fitting\n-///\n-/// Some of the methods require that a layout *fit* a memory block. What it means for a layout to\n-/// \"fit\" a memory block means (or equivalently, for a memory block to \"fit\" a layout) is that the\n-/// following conditions must hold:\n-///\n-/// * The block must be allocated with the same alignment as [`layout.align()`], and\n-///\n-/// * The provided [`layout.size()`] must fall in the range `min ..= max`, where:\n-///   - `min` is the size of the layout most recently used to allocate the block, and\n-///   - `max` is the latest actual size returned from [`alloc`], [`grow`], or [`shrink`].\n-///\n-/// [`layout.align()`]: Layout::align\n-/// [`layout.size()`]: Layout::size\n-///\n-/// ### Notes\n-///\n-///  * if a layout `k` fits a memory block (denoted by `ptr`) currently allocated via an allocator\n-///    `a`, then it is legal to use that layout to deallocate it, i.e.,\n-///    [`a.dealloc(ptr, k);`][`dealloc`], and\n-///\n-///  * if an allocator does not support overallocating, it is fine to simply return\n-///    [`layout.size()`] as the actual size.\n+/// `libc::malloc`), this case must be caught.\n ///\n /// # Safety\n ///\n-/// * Pointers returned from an allocator must point to valid memory and retain their validity until\n-///   the instance and all of its clones are dropped,\n-///\n-/// * cloning or moving the allocator must not invalidate pointers returned from this allocator.\n-///   A cloned allocator must behave like the same allocator, and\n+/// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n+///   until the instance and all of its clones are dropped, and\n ///\n-/// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n-///   method of the allocator.\n+/// * cloning or moving the allocator must not invalidate memory blocks returned from this\n+///   allocator. A cloned allocator must behave like the same allocator.\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n-    /// On success, returns a pointer meeting the size and alignment guarantees of `layout` and the\n-    /// actual size of the allocated block, which is greater than or equal to `layout.size()`.\n+    /// On success, returns a memory block meeting the size and alignment guarantees of `layout`.\n     ///\n-    /// The returned block of storage is initialized as specified by [`init`], all the way up to\n-    /// the returned `actual_size`.\n+    /// The returned block may have a larger size than specified by `layout.size()` and is\n+    /// initialized as specified by [`init`], all the way up to the returned size of the block.\n     ///\n     /// [`init`]: AllocInit\n     ///\n@@ -196,58 +192,32 @@ pub unsafe trait AllocRef {\n     /// call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n     ///\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<(NonNull<u8>, usize), AllocErr>;\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr>;\n \n-    /// Deallocates the memory referenced by `ptr`.\n+    /// Deallocates the memory denoted by `memory`.\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n-    ///\n-    /// * `layout` must [*fit*] that block of memory, and\n-    ///\n-    /// * the alignment of the `layout` must match the alignment used to allocate that block of\n-    ///   memory.\n-    ///\n-    /// [*currently allocated*]: #currently-allocated-memory\n-    /// [*fit*]: #memory-fitting\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n+    /// `memory` must be a memory block returned by this allocator.\n+    unsafe fn dealloc(&mut self, memory: MemoryBlock);\n \n-    /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n-    ///\n-    /// Returns a pointer and the actual size of the allocated block. The pointer is suitable for\n-    /// holding data described by a new layout with `layout`\u2019s alignment and a size given by\n-    /// `new_size`. To accomplish this, the allocator may extend the allocation referenced by `ptr`\n-    /// to fit the new layout.\n-    ///\n-    /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n-    /// transferred to this allocator. The memory may or may not have been freed, and should be\n-    /// considered unusable (unless of course it was transferred back to the caller again via the\n-    /// return value of this method).\n-    ///\n-    /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n-    /// this allocator, and the contents of the memory block are unaltered.\n+    /// Attempts to extend the memory block.\n     ///\n     /// The behavior of how the allocator tries to grow the memory is specified by [`placement`].\n-    /// The first `layout.size()` bytes of memory are preserved or copied as appropriate from `ptr`,\n-    /// and the remaining bytes, from `layout.size()` to the returned actual size, are initialized\n-    /// according to [`init`].\n+    /// The first `memory.size()` bytes are preserved or copied as appropriate from `ptr`, and the\n+    /// remaining bytes up to the new `memory.size()` are initialized according to [`init`].\n     ///\n     /// [`placement`]: ReallocPlacement\n     /// [`init`]: AllocInit\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    ///\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n-    ///\n-    // We can't require that `new_size` is strictly greater than `layout.size()` because of ZSTs.\n+    /// * `memory` must be a memory block returned by this allocator.\n+    // We can't require that `new_size` is strictly greater than `memory.size()` because of ZSTs.\n     // An alternative would be\n-    // * `new_size must be strictly greater than `layout.size()` or both are zero\n-    /// * `new_size` must be greater than or equal to `layout.size()`\n-    ///\n-    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n+    // * `new_size must be strictly greater than `memory.size()` or both are zero\n+    /// * `new_size` must be greater than or equal to `memory.size()`\n+    /// * `new_size`, when rounded up to the nearest multiple of `memory.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n@@ -268,72 +238,58 @@ pub unsafe trait AllocRef {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn grow(\n         &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n+        memory: &mut MemoryBlock,\n         new_size: usize,\n         placement: ReallocPlacement,\n         init: AllocInit,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n-        debug_assert!(\n-            new_size >= old_size,\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n-        );\n-\n-        if new_size == old_size {\n-            return Ok((ptr, new_size));\n-        }\n-\n+    ) -> Result<(), AllocErr> {\n         match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove => {\n-                let (new_ptr, alloc_size) =\n-                    self.alloc(Layout::from_size_align_unchecked(new_size, layout.align()), init)?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), old_size);\n-                self.dealloc(ptr, layout);\n-                Ok((new_ptr, alloc_size))\n+                let old_size = memory.size();\n+                debug_assert!(\n+                    new_size >= old_size,\n+                    \"`new_size` must be greater than or equal to `memory.size()`\"\n+                );\n+\n+                if new_size == old_size {\n+                    return Ok(());\n+                }\n+\n+                let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n+                let new_memory = self.alloc(new_layout, init)?;\n+                ptr::copy_nonoverlapping(\n+                    memory.ptr().as_ptr(),\n+                    new_memory.ptr().as_ptr(),\n+                    old_size,\n+                );\n+                self.dealloc(mem::replace(memory, new_memory));\n+                Ok(())\n             }\n-            ReallocPlacement::InPlace => Err(AllocErr),\n         }\n     }\n \n-    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n+    /// Attempts to shrink the memory block.\n     ///\n-    /// Returns a pointer and the actual size of the allocated block. The pointer is suitable for\n-    /// holding data described by a new layout with `layout`\u2019s alignment and a size given by\n-    /// `new_size`. To accomplish this, the allocator may shrink the allocation referenced by `ptr`\n-    /// to fit the new layout.\n-    ///\n-    /// The behavior on how the allocator tries to shrink the memory can be specified by\n-    /// [`placement`].\n-    ///\n-    /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n-    /// transferred to this allocator. The memory may or may not have been freed, and should be\n-    /// considered unusable unless it was transferred back to the caller again via the\n-    /// return value of this method.\n-    ///\n-    /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n-    /// this allocator, and the contents of the memory block are unaltered.\n+    /// The behavior of how the allocator tries to shrink the memory is specified by [`placement`].\n     ///\n     /// [`placement`]: ReallocPlacement\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    ///\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n-    ///\n-    // We can't require that `new_size` is strictly smaller than `layout.size()` because of ZSTs.\n+    /// * `memory` must be a memory block returned by this allocator.\n+    // We can't require that `new_size` is strictly smaller than `memory.size()` because of ZSTs.\n     // An alternative would be\n-    // * `new_size must be strictly smaller than `layout.size()` or both are zero\n-    /// * `new_size` must be smaller than or equal to `layout.size()`\n+    // * `new_size must be strictly smaller than `memory.size()` or both are zero\n+    /// * `new_size` must be smaller than or equal to `memory.size()`\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     ///\n     /// # Errors\n     ///\n     /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n-    /// constraints of the allocator, or if shrinking otherwise fails.\n+    /// constraints of the allocator, or if growing otherwise fails.\n     ///\n     /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n     /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n@@ -345,32 +301,33 @@ pub unsafe trait AllocRef {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn shrink(\n         &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n+        memory: &mut MemoryBlock,\n         new_size: usize,\n         placement: ReallocPlacement,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n-        debug_assert!(\n-            new_size <= old_size,\n-            \"`new_size` must be smaller than or equal to `layout.size()`\"\n-        );\n-\n-        if new_size == old_size {\n-            return Ok((ptr, new_size));\n-        }\n-\n+    ) -> Result<(), AllocErr> {\n         match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove => {\n-                let (new_ptr, alloc_size) = self.alloc(\n-                    Layout::from_size_align_unchecked(new_size, layout.align()),\n-                    AllocInit::Uninitialized,\n-                )?;\n-                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), new_size);\n-                self.dealloc(ptr, layout);\n-                Ok((new_ptr, alloc_size))\n+                let old_size = memory.size();\n+                debug_assert!(\n+                    new_size <= old_size,\n+                    \"`new_size` must be smaller than or equal to `layout.size()`\"\n+                );\n+\n+                if new_size == old_size {\n+                    return Ok(());\n+                }\n+\n+                let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n+                let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n+                ptr::copy_nonoverlapping(\n+                    memory.ptr().as_ptr(),\n+                    new_memory.ptr().as_ptr(),\n+                    new_size,\n+                );\n+                self.dealloc(mem::replace(memory, new_memory));\n+                Ok(())\n             }\n-            ReallocPlacement::InPlace => Err(AllocErr),\n         }\n     }\n }"}, {"sha": "f295565bec3481279d032febbd489cad5139e560", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -137,104 +137,98 @@ pub struct System;\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for System {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let new_size = layout.size();\n-        if new_size == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe {\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        unsafe {\n+            if layout.size() == 0 {\n+                Ok(MemoryBlock::new(layout.dangling(), layout))\n+            } else {\n                 let raw_ptr = match init {\n                     AllocInit::Uninitialized => GlobalAlloc::alloc(self, layout),\n                     AllocInit::Zeroed => GlobalAlloc::alloc_zeroed(self, layout),\n                 };\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok((ptr, new_size))\n+                Ok(MemoryBlock::new(ptr, layout))\n             }\n         }\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-        if layout.size() != 0 {\n-            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+    unsafe fn dealloc(&mut self, memory: MemoryBlock) {\n+        if memory.size() != 0 {\n+            GlobalAlloc::dealloc(self, memory.ptr().as_ptr(), memory.layout())\n         }\n     }\n \n     #[inline]\n     unsafe fn grow(\n         &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n+        memory: &mut MemoryBlock,\n         new_size: usize,\n         placement: ReallocPlacement,\n         init: AllocInit,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n+    ) -> Result<(), AllocErr> {\n+        let old_size = memory.size();\n         debug_assert!(\n             new_size >= old_size,\n-            \"`new_size` must be greater than or equal to `layout.size()`\"\n+            \"`new_size` must be greater than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok((ptr, new_size));\n+            return Ok(());\n         }\n \n+        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n+            ReallocPlacement::InPlace => return Err(AllocErr),\n+            ReallocPlacement::MayMove if memory.size() == 0 => {\n+                *memory = self.alloc(new_layout, init)?\n+            }\n             ReallocPlacement::MayMove => {\n-                if old_size == 0 {\n-                    self.alloc(Layout::from_size_align_unchecked(new_size, layout.align()), init)\n-                } else {\n-                    // `realloc` probably checks for `new_size > old_size` or something similar.\n-                    // `new_size` must be greater than or equal to `old_size` due to the safety constraint,\n-                    // and `new_size` == `old_size` was caught before\n-                    intrinsics::assume(new_size > old_size);\n-                    let ptr =\n-                        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n-                            .ok_or(AllocErr)?;\n-                    let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-                    init.initialize_offset(ptr, new_layout, old_size);\n-                    Ok((ptr, new_size))\n-                }\n+                // `realloc` probably checks for `new_size > old_size` or something similar.\n+                intrinsics::assume(new_size > old_size);\n+                let ptr =\n+                    GlobalAlloc::realloc(self, memory.ptr().as_ptr(), memory.layout(), new_size);\n+                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n+                memory.init_offset(init, old_size);\n             }\n-            ReallocPlacement::InPlace => Err(AllocErr),\n         }\n+        Ok(())\n     }\n \n     #[inline]\n     unsafe fn shrink(\n         &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n+        memory: &mut MemoryBlock,\n         new_size: usize,\n         placement: ReallocPlacement,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n+    ) -> Result<(), AllocErr> {\n+        let old_size = memory.size();\n         debug_assert!(\n             new_size <= old_size,\n-            \"`new_size` must be smaller than or equal to `layout.size()`\"\n+            \"`new_size` must be smaller than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok((ptr, new_size));\n+            return Ok(());\n         }\n \n+        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n+            ReallocPlacement::InPlace => return Err(AllocErr),\n+            ReallocPlacement::MayMove if new_size == 0 => {\n+                let new_memory = MemoryBlock::new(new_layout.dangling(), new_layout);\n+                let old_memory = mem::replace(memory, new_memory);\n+                self.dealloc(old_memory)\n+            }\n             ReallocPlacement::MayMove => {\n-                let ptr = if new_size == 0 {\n-                    self.dealloc(ptr, layout);\n-                    layout.dangling()\n-                } else {\n-                    // `realloc` probably checks for `new_size > old_size` or something similar.\n-                    // `new_size` must be smaller than or equal to `old_size` due to the safety constraint,\n-                    // and `new_size` == `old_size` was caught before\n-                    intrinsics::assume(new_size < old_size);\n-                    NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size))\n-                        .ok_or(AllocErr)?\n-                };\n-                Ok((ptr, new_size))\n+                // `realloc` probably checks for `new_size < old_size` or something similar.\n+                intrinsics::assume(new_size < old_size);\n+                let ptr =\n+                    GlobalAlloc::realloc(self, memory.ptr().as_ptr(), memory.layout(), new_size);\n+                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n             }\n-            ReallocPlacement::InPlace => Err(AllocErr),\n         }\n+        Ok(())\n     }\n }\n "}, {"sha": "63b1b2fbb8bef9821d567cce86176f709a0c60b5", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -37,10 +37,10 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let (ptr, _) = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n-        helper::work_with(&ptr);\n+        let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        helper::work_with(&memory.ptr());\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(ptr, layout.clone());\n+        Global.dealloc(memory);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);\n@@ -49,10 +49,10 @@ fn main() {\n         drop(s);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n \n-        let (ptr, _) = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n-        helper::work_with(&ptr);\n-        System.dealloc(ptr, layout);\n+        helper::work_with(&memory.ptr());\n+        System.dealloc(memory);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n     }\n }"}, {"sha": "d4f8b4247b1e515ff5df08559003371d23cace33", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -20,16 +20,16 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let (ptr, _) = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n-        helper::work_with(&ptr);\n+        let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        helper::work_with(&memory.ptr());\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(ptr, layout.clone());\n+        Global.dealloc(memory);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n-        let (ptr, _) = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n+        let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n-        helper::work_with(&ptr);\n-        System.dealloc(ptr, layout);\n+        helper::work_with(&memory.ptr());\n+        System.dealloc(memory);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n     }\n }"}, {"sha": "3fe8ed224c270cc0a3e41daa200b27cb4beadc95", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -6,7 +6,9 @@\n \n #![feature(allocator_api)]\n \n-use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout, ReallocPlacement};\n+use std::alloc::{\n+    handle_alloc_error, AllocInit, AllocRef, Global, Layout, MemoryBlock, ReallocPlacement,\n+};\n use std::ptr::{self, NonNull};\n \n fn main() {\n@@ -41,52 +43,52 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let (ptr, _) = Global\n+        let memory = Global\n             .alloc(layout, AllocInit::Uninitialized)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         if PRINT {\n-            println!(\"allocate({:?}) = {:?}\", layout, ptr);\n+            println!(\"allocate({:?}) = {:?}\", layout, memory.ptr());\n         }\n \n-        ptr.cast().as_ptr()\n+        memory.ptr().cast().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n         if PRINT {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Global.dealloc(NonNull::new_unchecked(ptr), layout);\n+        Global.dealloc(MemoryBlock::new(NonNull::new_unchecked(ptr), layout));\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let allocation = if new.size() > old.size() {\n+        let mut memory = MemoryBlock::new(NonNull::new_unchecked(ptr), old);\n+        let result = if new.size() > old.size() {\n             Global.grow(\n-                NonNull::new_unchecked(ptr),\n-                old,\n+                &mut memory,\n                 new.size(),\n                 ReallocPlacement::MayMove,\n                 AllocInit::Uninitialized,\n             )\n         } else if new.size() < old.size() {\n-            Global.shrink(NonNull::new_unchecked(ptr), old, new.size(), ReallocPlacement::MayMove)\n+            Global.shrink(&mut memory, new.size(), ReallocPlacement::MayMove)\n         } else {\n             return ptr;\n         };\n \n-        let (ptr, _) = allocation.unwrap_or_else(|_| {\n+        result.unwrap_or_else(|_| {\n             handle_alloc_error(Layout::from_size_align_unchecked(new.size(), old.align()))\n         });\n \n         if PRINT {\n-            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, ptr);\n+            println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\", ptr, old, new, memory.ptr());\n         }\n-        ptr.cast().as_ptr()\n+        memory.ptr().cast().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize {"}, {"sha": "b9bd2988b6ee7c2554a0b58ec468fe7ef10ce5e3", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2526accdd35c564eee80b6453a0b4965e6a76afd/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=2526accdd35c564eee80b6453a0b4965e6a76afd", "patch": "@@ -4,7 +4,7 @@\n // pretty-expanded FIXME #23616\n #![feature(allocator_api)]\n \n-use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout, MemoryBlock};\n use std::ptr::NonNull;\n \n struct arena(());\n@@ -25,10 +25,10 @@ struct Ccx {\n fn alloc(_bcx: &arena) -> &Bcx<'_> {\n     unsafe {\n         let layout = Layout::new::<Bcx>();\n-        let (ptr, _) = Global\n+        let memory = Global\n             .alloc(layout, AllocInit::Uninitialized)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n-        &*(ptr.as_ptr() as *const _)\n+        &*(memory.ptr().as_ptr() as *const _)\n     }\n }\n \n@@ -40,7 +40,10 @@ fn g(fcx: &Fcx) {\n     let bcx = Bcx { fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        Global.dealloc(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n+        Global.dealloc(MemoryBlock::new(\n+            NonNull::new_unchecked(bcx2 as *const _ as *mut _),\n+            Layout::new::<Bcx>(),\n+        ));\n     }\n }\n "}]}