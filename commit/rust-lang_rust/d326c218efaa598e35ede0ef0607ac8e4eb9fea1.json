{"sha": "d326c218efaa598e35ede0ef0607ac8e4eb9fea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMjZjMjE4ZWZhYTU5OGUzNWVkZTBlZjA2MDdhYzhlNGViOWZlYTE=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-03-30T17:01:22Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-04-07T02:55:44Z"}, "message": "Suggest Pin/Box/Arc for more cases", "tree": {"sha": "900ea9c3d5e7f6461bdc4ced3782fd37bbdd3aa3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/900ea9c3d5e7f6461bdc4ced3782fd37bbdd3aa3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d326c218efaa598e35ede0ef0607ac8e4eb9fea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d326c218efaa598e35ede0ef0607ac8e4eb9fea1", "html_url": "https://github.com/rust-lang/rust/commit/d326c218efaa598e35ede0ef0607ac8e4eb9fea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d326c218efaa598e35ede0ef0607ac8e4eb9fea1/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16143d10679537d3fde4247e15334e78ad9d55b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/16143d10679537d3fde4247e15334e78ad9d55b9", "html_url": "https://github.com/rust-lang/rust/commit/16143d10679537d3fde4247e15334e78ad9d55b9"}], "stats": {"total": 105, "additions": 53, "deletions": 52}, "files": [{"sha": "02fe8312c4c1fed6a777d771762a01c7af3450a6", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/d326c218efaa598e35ede0ef0607ac8e4eb9fea1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d326c218efaa598e35ede0ef0607ac8e4eb9fea1/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d326c218efaa598e35ede0ef0607ac8e4eb9fea1", "patch": "@@ -987,59 +987,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let mut alt_rcvr_sugg = false;\n         if let SelfSource::MethodCall(rcvr) = source {\n-            info!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n-            if let ty::Adt(..) = rcvr_ty.kind() {\n-                // Try alternative arbitrary self types that could fulfill this call.\n-                // FIXME: probe for all types that *could* be arbitrary self-types, not\n-                // just this list.\n-                for (rcvr_ty, post) in &[\n-                    (rcvr_ty, \"\"),\n-                    (self.tcx.mk_mut_ref(&ty::ReErased, rcvr_ty), \"&mut \"),\n-                    (self.tcx.mk_imm_ref(&ty::ReErased, rcvr_ty), \"&\"),\n+            debug!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n+            // Try alternative arbitrary self types that could fulfill this call.\n+            // FIXME: probe for all types that *could* be arbitrary self-types, not\n+            // just this list.\n+            for (rcvr_ty, post) in &[\n+                (rcvr_ty, \"\"),\n+                (self.tcx.mk_mut_ref(&ty::ReErased, rcvr_ty), \"&mut \"),\n+                (self.tcx.mk_imm_ref(&ty::ReErased, rcvr_ty), \"&\"),\n+            ] {\n+                for (rcvr_ty, pre) in &[\n+                    (self.tcx.mk_lang_item(rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n+                    (self.tcx.mk_lang_item(rcvr_ty, LangItem::Pin), \"Pin::new\"),\n+                    (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Arc), \"Arc::new\"),\n+                    (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n-                    for (rcvr_ty, pre) in &[\n-                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::OwnedBox), \"Box::new\"),\n-                        (self.tcx.mk_lang_item(rcvr_ty, LangItem::Pin), \"Pin::new\"),\n-                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Arc), \"Arc::new\"),\n-                        (self.tcx.mk_diagnostic_item(rcvr_ty, sym::Rc), \"Rc::new\"),\n-                    ] {\n-                        if let Some(new_rcvr_t) = *rcvr_ty {\n-                            if let Ok(pick) = self.lookup_probe(\n-                                span,\n-                                item_name,\n-                                new_rcvr_t,\n-                                rcvr,\n-                                crate::check::method::probe::ProbeScope::AllTraits,\n-                            ) {\n-                                debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n-                                // Make sure the method is defined for the *actual* receiver:\n-                                // we don't want to treat `Box<Self>` as a receiver if\n-                                // it only works because of an autoderef to `&self`\n-                                if pick.autoderefs == 0\n-                                    // We don't want to suggest a container type when the missing method is\n-                                    // `.clone()`, otherwise we'd suggest `Arc::new(foo).clone()`, which is\n-                                    // far from what the user really wants.\n-                                    && Some(pick.item.container.id()) != self.tcx.lang_items().clone_trait()\n-                                {\n-                                    err.span_label(\n-                                        pick.item.ident.span,\n-                                        &format!(\n-                                            \"the method is available for `{}` here\",\n-                                            new_rcvr_t\n-                                        ),\n-                                    );\n-                                    err.multipart_suggestion(\n-                                        \"consider wrapping the receiver expression with the \\\n-                                         appropriate type\",\n-                                        vec![\n-                                            (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n-                                            (rcvr.span.shrink_to_hi(), \")\".to_string()),\n-                                        ],\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                    // We don't care about the other suggestions.\n-                                    alt_rcvr_sugg = true;\n-                                }\n+                    if let Some(new_rcvr_t) = *rcvr_ty {\n+                        if let Ok(pick) = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            new_rcvr_t,\n+                            rcvr,\n+                            crate::check::method::probe::ProbeScope::AllTraits,\n+                        ) {\n+                            debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n+                            let did = Some(pick.item.container.id());\n+                            // We don't want to suggest a container type when the missing\n+                            // method is `.clone()` or `.deref()` otherwise we'd suggest\n+                            // `Arc::new(foo).clone()`, which is far from what the user wants.\n+                            let skip = [\n+                                self.tcx.lang_items().clone_trait(),\n+                                self.tcx.lang_items().deref_trait(),\n+                                self.tcx.lang_items().deref_mut_trait(),\n+                                self.tcx.lang_items().drop_trait(),\n+                            ]\n+                            .contains(&did);\n+                            // Make sure the method is defined for the *actual* receiver: we don't\n+                            // want to treat `Box<Self>` as a receiver if it only works because of\n+                            // an autoderef to `&self`\n+                            if pick.autoderefs == 0 && !skip {\n+                                err.span_label(\n+                                    pick.item.ident.span,\n+                                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                                );\n+                                err.multipart_suggestion(\n+                                    \"consider wrapping the receiver expression with the \\\n+                                        appropriate type\",\n+                                    vec![\n+                                        (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n+                                        (rcvr.span.shrink_to_hi(), \")\".to_string()),\n+                                    ],\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                // We don't care about the other suggestions.\n+                                alt_rcvr_sugg = true;\n                             }\n                         }\n                     }"}]}