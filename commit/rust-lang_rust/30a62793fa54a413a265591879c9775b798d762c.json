{"sha": "30a62793fa54a413a265591879c9775b798d762c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYTYyNzkzZmE1NGE0MTNhMjY1NTkxODc5Yzk3NzViNzk4ZDc2MmM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-19T05:35:28Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-13T03:43:37Z"}, "message": "Make moves explicit in core tests", "tree": {"sha": "2cac5f5f52fede875ed3cf1f7f576b1ecf543482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cac5f5f52fede875ed3cf1f7f576b1ecf543482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30a62793fa54a413a265591879c9775b798d762c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30a62793fa54a413a265591879c9775b798d762c", "html_url": "https://github.com/rust-lang/rust/commit/30a62793fa54a413a265591879c9775b798d762c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30a62793fa54a413a265591879c9775b798d762c/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d7d12b902a9f6237994f74888878220cb2ffbed", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d7d12b902a9f6237994f74888878220cb2ffbed", "html_url": "https://github.com/rust-lang/rust/commit/2d7d12b902a9f6237994f74888878220cb2ffbed"}], "stats": {"total": 324, "additions": 178, "deletions": 146}, "files": [{"sha": "9aaf373869c869b67adf74d99ba16a6ee837838c", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -122,9 +122,9 @@ pub mod tests {\n     pub fn test_transmute() {\n         unsafe {\n             let x = @1;\n-            let x: *int = transmute(x);\n+            let x: *int = transmute(move x);\n             assert *x == 1;\n-            let _x: @int = transmute(x);\n+            let _x: @int = transmute(move x);\n         }\n     }\n "}, {"sha": "9a3b40757a703bf2ee4fa8bb17c1be36ba050f27", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -142,7 +142,7 @@ pub unsafe fn annihilate() {\n         assert (*box).header.prev == null();\n \n         debug!(\"freeing box: %x\", box as uint);\n-        rt_free(transmute(box));\n+        rt_free(transmute(move box));\n     }\n }\n "}, {"sha": "5acb45fdf1a55a3fe50323c87cf6f6119410cfbe", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -301,7 +301,7 @@ pub mod rt {\n                 unsafe { str::unshift_char(&mut s, ' ') };\n             }\n         }\n-        return unsafe { pad(cv, s, PadSigned) };\n+        return unsafe { pad(cv, move s, PadSigned) };\n     }\n     pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n@@ -313,7 +313,7 @@ pub mod rt {\n               TyBits => uint_to_str_prec(u, 2u, prec),\n               TyOctal => uint_to_str_prec(u, 8u, prec)\n             };\n-        return unsafe { pad(cv, rs, PadUnsigned) };\n+        return unsafe { pad(cv, move rs, PadUnsigned) };\n     }\n     pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n@@ -323,7 +323,7 @@ pub mod rt {\n     }\n     pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        return unsafe { pad(cv, s, PadNozero) };\n+        return unsafe { pad(cv, move s, PadNozero) };\n     }\n     pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n@@ -336,7 +336,7 @@ pub mod rt {\n             s.to_unique()\n           }\n         };\n-        return unsafe { pad(cv, unpadded, PadNozero) };\n+        return unsafe { pad(cv, move unpadded, PadNozero) };\n     }\n     pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n@@ -351,7 +351,7 @@ pub mod rt {\n                 s = ~\" \" + s;\n             }\n         }\n-        return unsafe { pad(cv, s, PadFloat) };\n+        return unsafe { pad(cv, move s, PadFloat) };\n     }\n     pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n@@ -411,14 +411,14 @@ pub mod rt {\n     pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return s,\n+          CountImplied => return (move s),\n           CountIs(width) => {\n               // FIXME: width should probably be uint (see Issue #1996)\n               width as uint\n           }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return s; }\n+        if uwidth <= strlen { return (move s); }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {"}, {"sha": "bc35dafde3526ec0f0eea151d2aba643c5a54453", "filename": "src/libcore/future.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -179,8 +179,8 @@ pub mod test {\n     #[test]\n     pub fn test_from_port() {\n         let (po, ch) = future_pipe::init();\n-        future_pipe::server::completed(ch, ~\"whale\");\n-        let f = from_port(po);\n+        future_pipe::server::completed(move ch, ~\"whale\");\n+        let f = from_port(move po);\n         assert get(&f) == ~\"whale\";\n     }\n \n@@ -238,7 +238,7 @@ pub mod test {\n     pub fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn |copy expected| { copy expected };\n-        do task::spawn {\n+        do task::spawn |move f, move expected| {\n             let actual = get(&f);\n             assert actual == expected;\n         }"}, {"sha": "1b4996a683d1046fb7cc5c43507268cc5df48a92", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -438,7 +438,7 @@ pub fn test_siphash() {\n         for vec::each(*r) |b| {\n             s += uint::to_str(*b as uint, 16u);\n         }\n-        return s;\n+        move s\n     }\n \n     while t < 64 {"}, {"sha": "fd0fcbbe1c1f8b74c8a17bd3cba9a8341173dbd5", "filename": "src/libcore/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -737,7 +737,7 @@ pub fn BytesWriter() -> BytesWriter {\n pub fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n-    wr.buf.check_out(|buf| buf)\n+    wr.buf.check_out(|buf| move buf)\n }\n \n pub fn with_str_writer(f: fn(Writer)) -> ~str {\n@@ -747,7 +747,7 @@ pub fn with_str_writer(f: fn(Writer)) -> ~str {\n     v.push(0);\n     assert str::is_utf8(v);\n \n-    unsafe { move ::cast::transmute(v) }\n+    unsafe { move ::cast::transmute(move v) }\n }\n \n // Utility functions"}, {"sha": "56a6df2c4ddf159510808d92fcae9e0a56d66d25", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -24,15 +24,15 @@ struct Data<T> {\n pub type Mut<T> = Data<T>;\n \n pub fn Mut<T>(t: T) -> Mut<T> {\n-    Data {value: t, mode: ReadOnly}\n+    Data {value: move t, mode: ReadOnly}\n }\n \n pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n     assert (m.mode as uint) == (ReadOnly as uint);\n     let Data {value: move value, mode: _} = move m;\n-    return value;\n+    move value\n }\n \n impl<T> Data<T> {"}, {"sha": "f8bafe29fdde2fb25b929c67a4474d15e4d478e6", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -120,7 +120,7 @@ pub pure fn chain<T, U>(opt: Option<T>,\n      */\n \n     match move opt {\n-        Some(move t) => f(t),\n+        Some(move t) => f(move t),\n         None => None\n     }\n }\n@@ -294,7 +294,7 @@ impl<T: Copy> Option<T> {\n      *\n      * Fails if the value equals `none`\n      */\n-    pure fn expect(reason: ~str) -> T { expect(&self, reason) }\n+    pure fn expect(reason: ~str) -> T { expect(&self, move reason) }\n     /// Applies a function zero or more times until the result is none.\n     pure fn while_some(blk: fn(v: T) -> Option<T>) { while_some(self, blk) }\n }\n@@ -324,8 +324,8 @@ impl<T: Eq> Option<T> : Eq {\n fn test_unwrap_ptr() {\n     let x = ~0;\n     let addr_x = ptr::addr_of(&(*x));\n-    let opt = Some(x);\n-    let y = unwrap(opt);\n+    let opt = Some(move x);\n+    let y = unwrap(move opt);\n     let addr_y = ptr::addr_of(&(*y));\n     assert addr_x == addr_y;\n }\n@@ -356,8 +356,8 @@ fn test_unwrap_resource() {\n     let i = @mut 0;\n     {\n         let x = R(i);\n-        let opt = Some(x);\n-        let _y = unwrap(opt);\n+        let opt = Some(move x);\n+        let _y = unwrap(move opt);\n     }\n     assert *i == 1;\n }"}, {"sha": "24e4d7eff41f2558114a5232238d7a7dc337ab6c", "filename": "src/libcore/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -739,7 +739,7 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     for uint::range(0, argc as uint) |i| {\n         vec::push(&mut args, str::raw::from_c_str(*argv.offset(i)));\n     }\n-    return args;\n+    move args\n }\n \n /**\n@@ -903,7 +903,7 @@ mod tests {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert getenv(n).is_none();\n-        n\n+        move n\n     }\n \n     #[test]\n@@ -937,7 +937,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, s);\n-        assert getenv(n) == option::Some(s);\n+        assert getenv(n) == option::Some(move s);\n     }\n \n     #[test]\n@@ -963,7 +963,7 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert v2.is_none() || v2 == option::Some(v);\n+            assert v2.is_none() || v2 == option::Some(move v);\n         }\n     }\n \n@@ -976,7 +976,7 @@ mod tests {\n         assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n \n         e = env();\n-        assert vec::contains(e, &(n, ~\"VALUE\"));\n+        assert vec::contains(e, &(move n, ~\"VALUE\"));\n     }\n \n     #[test]"}, {"sha": "871e803ff1a5a1a1109e8235b8fa48c99de56658", "filename": "src/libcore/path.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -96,7 +96,7 @@ impl PosixPath : GenericPath {\n         let mut components = str::split_nonempty(s, |c| c == '/');\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n-                           components: components }\n+                           components: move components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -192,7 +192,7 @@ impl PosixPath : GenericPath {\n           Some(ref f) => ~[copy *f]\n         };\n         return PosixPath { is_absolute: false,\n-                           components: cs }\n+                           components: move cs }\n     }\n \n     pure fn push_rel(other: &PosixPath) -> PosixPath {\n@@ -208,7 +208,8 @@ impl PosixPath : GenericPath {\n                 |c| windows::is_sep(c as u8));\n             unsafe { v.push_all_move(move ss); }\n         }\n-        PosixPath { components: move v, ..self }\n+        PosixPath { is_absolute: self.is_absolute,\n+                    components: move v }\n     }\n \n     pure fn push(s: &str) -> PosixPath {\n@@ -223,13 +224,18 @@ impl PosixPath : GenericPath {\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n         }\n-        return PosixPath { components: move cs, ..self }\n+        return PosixPath {\n+            is_absolute: self.is_absolute,\n+            components: move cs\n+        }\n+                          //..self }\n     }\n \n     pure fn normalize() -> PosixPath {\n         return PosixPath {\n-            components: normalize(self.components),\n-            ..self\n+            is_absolute: self.is_absolute,\n+            components: normalize(self.components)\n+          //  ..self\n         }\n     }\n }\n@@ -286,10 +292,10 @@ impl WindowsPath : GenericPath {\n         let mut components =\n             str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n         let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n-        return WindowsPath { host: host,\n-                             device: device,\n+        return WindowsPath { host: move host,\n+                             device: move device,\n                              is_absolute: is_absolute,\n-                             components: components }\n+                             components: move components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -386,7 +392,7 @@ impl WindowsPath : GenericPath {\n         return WindowsPath { host: None,\n                              device: None,\n                              is_absolute: false,\n-                             components: cs }\n+                             components: move cs }\n     }\n \n     pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n@@ -402,7 +408,13 @@ impl WindowsPath : GenericPath {\n                 |c| windows::is_sep(c as u8));\n             unsafe { v.push_all_move(move ss); }\n         }\n-        return WindowsPath { components: move v, ..self }\n+        // tedious, but as-is, we can't use ..self\n+        return WindowsPath {\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute,\n+            components: move v\n+        }\n     }\n \n     pure fn push(s: &str) -> WindowsPath {\n@@ -417,13 +429,20 @@ impl WindowsPath : GenericPath {\n         if cs.len() != 0 {\n             unsafe { cs.pop(); }\n         }\n-        return WindowsPath { components: move cs, ..self }\n+        return WindowsPath {\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute,\n+            components: move cs\n+        }\n     }\n \n     pure fn normalize() -> WindowsPath {\n         return WindowsPath {\n-            components: normalize(self.components),\n-            ..self\n+            host: copy self.host,\n+            device: copy self.device,\n+            is_absolute: self.is_absolute,\n+            components: normalize(self.components)\n         }\n     }\n }"}, {"sha": "e77cb69b05658686eed9a2416ba4d113d161ac6d", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -350,7 +350,8 @@ fn BufferResource<T: Send>(b: ~Buffer<T>) -> BufferResource<T> {\n     atomic_add_acq(&mut b.header.ref_count, 1);\n \n     BufferResource {\n-        buffer: b\n+        // tjc: ????\n+        buffer: move b\n     }\n }\n \n@@ -448,7 +449,12 @@ pub fn try_recv<T: Send, Tbuffer: Send>(p: RecvPacketBuffered<T, Tbuffer>)\n     let this = rustrt::rust_get_task();\n     rustrt::task_clear_event_reject(this);\n     rustrt::rust_task_ref(this);\n+    debug!(\"blocked = %x this = %x\", p.header.blocked_task as uint,\n+           this as uint);\n     let old_task = swap_task(&mut p.header.blocked_task, this);\n+    debug!(\"blocked = %x this = %x old_task = %x\",\n+           p.header.blocked_task as uint,\n+           this as uint, old_task as uint);\n     assert old_task.is_null();\n     let mut first = true;\n     let mut count = SPIN_COUNT;\n@@ -1212,7 +1218,7 @@ pub mod test {\n \n         c1.send(~\"abc\");\n \n-        match (p1, p2).select() {\n+        match (move p1, move p2).select() {\n           Right(_) => fail,\n           _ => ()\n         }\n@@ -1224,8 +1230,8 @@ pub mod test {\n     pub fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n-        oneshot::client::send(c, ());\n+        oneshot::client::send(move c, ());\n \n-        recv_one(p)\n+        recv_one(move p)\n     }\n }"}, {"sha": "a54db3fa759b93e4fd269f992aade5fb07a9e642", "filename": "src/libcore/private.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -374,7 +374,7 @@ pub unsafe fn unwrap_shared_mutable_state<T: Send>(rc: SharedMutableState<T>)\n             rc.data = ptr::null();\n             // Step 1 - drop our own reference.\n             let new_count = rustrt::rust_atomic_decrement(&mut ptr.count);\n-            assert new_count >= 0;\n+        //    assert new_count >= 0;\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n                 // Also we have to free the server endpoints.\n@@ -505,7 +505,7 @@ pub struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n \n pub fn exclusive<T:Send >(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), mut failed: false, mut data: user_data\n+        lock: LittleLock(), mut failed: false, mut data: move user_data\n     };\n     Exclusive { x: unsafe { shared_mutable_state(move data) } }\n }\n@@ -558,17 +558,17 @@ pub mod tests {\n     pub fn exclusive_arc() {\n         let mut futures = ~[];\n \n-        let num_tasks = 10u;\n-        let count = 10u;\n+        let num_tasks = 10;\n+        let count = 10;\n \n-        let total = exclusive(~mut 0u);\n+        let total = exclusive(~mut 0);\n \n-        for uint::range(0u, num_tasks) |_i| {\n+        for uint::range(0, num_tasks) |_i| {\n             let total = total.clone();\n-            futures.push(future::spawn(|| {\n-                for uint::range(0u, count) |_i| {\n+            futures.push(future::spawn(|move total| {\n+                for uint::range(0, count) |_i| {\n                     do total.with |count| {\n-                        **count += 1u;\n+                        **count += 1;\n                     }\n                 }\n             }));\n@@ -587,7 +587,7 @@ pub mod tests {\n         // accesses will also fail.\n         let x = exclusive(1);\n         let x2 = x.clone();\n-        do task::try {\n+        do task::try |move x2| {\n             do x2.with |one| {\n                 assert *one == 2;\n             }\n@@ -600,27 +600,28 @@ pub mod tests {\n     #[test]\n     pub fn exclusive_unwrap_basic() {\n         let x = exclusive(~~\"hello\");\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n+        assert unwrap_exclusive(move x) == ~~\"hello\";\n     }\n \n     #[test]\n     pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n-        do task::spawn {\n+        do task::spawn |move x2| {\n             let x2 = option::swap_unwrap(x2);\n             do x2.with |_hello| { }\n             task::yield();\n         }\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n+        assert unwrap_exclusive(move x) == ~~\"hello\";\n \n         // Now try the same thing, but with the child task blocking.\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn {\n+        do task::task().future_result(|+r| res = Some(move r)).spawn\n+              |move x2| {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(x2) == ~~\"hello\";\n+            assert unwrap_exclusive(move x2) == ~~\"hello\";\n         }\n         // Have to get rid of our reference before blocking.\n         { let _x = move x; } // FIXME(#3161) util::ignore doesn't work here\n@@ -633,11 +634,12 @@ pub mod tests {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn {\n+        do task::task().future_result(|+r| res = Some(move r)).spawn\n+           |move x2| {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(x2) == ~~\"hello\";\n+            assert unwrap_exclusive(move x2) == ~~\"hello\";\n         }\n-        assert unwrap_exclusive(x) == ~~\"hello\";\n+        assert unwrap_exclusive(move x) == ~~\"hello\";\n         let res = option::swap_unwrap(&mut res);\n         future::get(&res);\n     }\n@@ -656,7 +658,7 @@ pub mod tests {\n                 for 10.times { task::yield(); } // try to let the unwrapper go\n                 fail; // punt it awake from its deadlock\n             }\n-            let _z = unwrap_exclusive(x);\n+            let _z = unwrap_exclusive(move x);\n             do x2.with |_hello| { }\n         };\n         assert result.is_err();"}, {"sha": "ff29953f09a49fbe036b15fa862dce08082e0fa7", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -156,7 +156,7 @@ impl ReprVisitor {\n     fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool {\n         let mut u = ReprVisitor(ptr, self.writer);\n         let v = reflect::MovePtrAdaptor(move u);\n-        visit_tydesc(inner, v as @TyVisitor);\n+        visit_tydesc(inner, (move v) as @TyVisitor);\n         true\n     }\n \n@@ -453,7 +453,7 @@ pub fn write_repr2<T>(writer: @Writer, object: &T) {\n     let tydesc = intrinsic::get_tydesc::<T>();\n     let mut u = ReprVisitor(ptr, writer);\n     let v = reflect::MovePtrAdaptor(move u);\n-    visit_tydesc(tydesc, v as @TyVisitor)\n+    visit_tydesc(tydesc, (move v) as @TyVisitor)\n }\n \n #[test]\n@@ -992,7 +992,7 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n         let tydesc = sys::get_type_desc::<T>();\n-        let tydesc = cast::transmute(tydesc);\n+        let tydesc = cast::transmute(move tydesc);\n \n         let repr_printer = @ReprPrinter {\n             ptr: ptr,"}, {"sha": "06d8c0da0d0134ea622c51c07be5fd9d3fbb7763", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -106,7 +106,7 @@ pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n pub fn chain<T, U: Copy, V: Copy>(res: Result<T, V>, op: fn(t: T)\n     -> Result<U, V>) -> Result<U, V> {\n     match move res {\n-        Ok(move t) => op(t),\n+        Ok(move t) => op(move t),\n         Err(move e) => Err(e)\n     }\n }"}, {"sha": "06b869306305b1de7d17b32580afbc0c47bae78d", "filename": "src/libcore/run.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -226,7 +226,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n     fn ProgRes(r: ProgRepr) -> ProgRes {\n         ProgRes {\n-            r: r\n+            r: move r\n         }\n     }\n \n@@ -313,10 +313,10 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n         let stream = comm::recv(p);\n         match stream {\n             (1, copy s) => {\n-                outs = s;\n+                outs = move s;\n             }\n             (2, copy s) => {\n-                errs = s;\n+                errs = move s;\n             }\n             (n, _) => {\n                 fail(fmt!(\"program_output received an unexpected file \\"}, {"sha": "58b35b82a31fa5f6297b78248a9c1ee51ec73640", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -185,17 +185,17 @@ pub mod linear {\n                     debug!(\"insert fresh (%?->%?) at idx %?, hash %?\",\n                            k, v, idx, hash);\n                     self.buckets[idx] = Some(Bucket {hash: hash,\n-                                                     key: k,\n-                                                     value: v});\n+                                                     key: move k,\n+                                                     value: move v});\n                     self.size += 1;\n                     true\n                 }\n                 FoundEntry(idx) => {\n                     debug!(\"insert overwrite (%?->%?) at idx %?, hash %?\",\n                            k, v, idx, hash);\n                     self.buckets[idx] = Some(Bucket {hash: hash,\n-                                                     key: k,\n-                                                     value: v});\n+                                                     key: move k,\n+                                                     value: move v});\n                     false\n                 }\n             }\n@@ -230,7 +230,7 @@ pub mod linear {\n                 None => None,\n                 Some(move bucket) => {\n                     let Bucket { value: move value, _ } = move bucket;\n-                    Some(value)\n+                    Some(move value)\n                 },\n             };\n \n@@ -243,7 +243,7 @@ pub mod linear {\n             }\n             self.size -= 1;\n \n-            value\n+            move value\n \n         }\n \n@@ -297,17 +297,17 @@ pub mod linear {\n                 self.expand();\n             }\n \n-            self.insert_internal(hash, k, v);\n+            self.insert_internal(hash, move k, move v);\n \n-            old_value\n+            move old_value\n         }\n \n         fn consume(&mut self, f: fn(K, V)) {\n             let mut buckets = ~[];\n             self.buckets <-> buckets;\n             self.size = 0;\n \n-            do vec::consume(buckets) |_i, bucket| {\n+            do vec::consume(move buckets) |_i, bucket| {\n                 match move bucket {\n                     None => { },\n                     Some(move bucket) => {\n@@ -316,7 +316,7 @@ pub mod linear {\n                             value: move value,\n                             _\n                         } = move bucket;\n-                        f(key, value)\n+                        f(move key, move value)\n                     }\n                 }\n             }"}, {"sha": "677a33d56c0d32459057fb279fbb5e6b1a926dc0", "filename": "src/libcore/str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -2562,23 +2562,23 @@ mod tests {\n     #[test]\n     fn test_unsafe_slice() {\n         unsafe {\n-            assert ~\"ab\" == raw::slice_bytes(~\"abc\", 0u, 2u);\n-            assert ~\"bc\" == raw::slice_bytes(~\"abc\", 1u, 3u);\n-            assert ~\"\" == raw::slice_bytes(~\"abc\", 1u, 1u);\n+            assert ~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2);\n+            assert ~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3);\n+            assert ~\"\" == raw::slice_bytes(~\"abc\", 1, 1);\n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaaaaaaa\"); i += 1; }\n-                return rs;\n+                move rs\n             }\n             fn half_a_million_letter_a() -> ~str {\n                 let mut i = 0;\n                 let mut rs = ~\"\";\n                 while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n-                return rs;\n+                move rs\n             }\n             assert half_a_million_letter_a() ==\n-                raw::slice_bytes(a_million_letter_a(), 0u, 500000u);\n+                raw::slice_bytes(a_million_letter_a(), 0u, 500000);\n         }\n     }\n \n@@ -2664,16 +2664,16 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        assert ~\"ab\" == slice(~\"abc\", 0u, 2u);\n-        assert ~\"bc\" == slice(~\"abc\", 1u, 3u);\n-        assert ~\"\" == slice(~\"abc\", 1u, 1u);\n-        assert ~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0u, 3u);\n+        assert ~\"ab\" == slice(~\"abc\", 0, 2);\n+        assert ~\"bc\" == slice(~\"abc\", 1, 3);\n+        assert ~\"\" == slice(~\"abc\", 1, 1);\n+        assert ~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3);\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert ~\"\u0e1b\" == slice(data, 0u, 3u);\n-        assert ~\"\u0e23\" == slice(data, 3u, 6u);\n-        assert ~\"\" == slice(data, 3u, 3u);\n-        assert ~\"\u534e\" == slice(data, 30u, 33u);\n+        assert ~\"\u0e1b\" == slice(data, 0, 3);\n+        assert ~\"\u0e23\" == slice(data, 3, 6);\n+        assert ~\"\" == slice(data, 3, 3);\n+        assert ~\"\u534e\" == slice(data, 30, 33);\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n@@ -2682,13 +2682,13 @@ mod tests {\n                 push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n-            return rs;\n+            move rs\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n-            return rs;\n+            move rs\n         }\n         assert half_a_million_letter_X() ==\n             slice(a_million_letter_X(), 0u, 3u * 500000u);"}, {"sha": "32a6987a672aaad227eb02f989e518244ff8a8a7", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -153,7 +153,7 @@ pub mod tests {\n \n         assert f(20) == 30;\n \n-        let original_closure: Closure = cast::transmute(f);\n+        let original_closure: Closure = cast::transmute(move f);\n \n         let actual_function_pointer = original_closure.code;\n         let environment = original_closure.env;\n@@ -163,7 +163,7 @@ pub mod tests {\n             env: environment\n         };\n \n-        let new_f: fn(int) -> int = cast::transmute(new_closure);\n+        let new_f: fn(int) -> int = cast::transmute(move new_closure);\n         assert new_f(20) == 30;\n     }\n }"}, {"sha": "d9e213c7f55e8bc33ed9a1257b7cd8da4f75bf44", "filename": "src/libcore/task.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -424,7 +424,11 @@ impl TaskBuilder {\n                 mut notify_chan: move notify_chan,\n                 sched: self.opts.sched\n             },\n-            gen_body: |body| { wrapper(prev_gen_body(move body)) },\n+            // tjc: I think this is the line that gets miscompiled\n+            // w/ last-use off, if we leave out the move prev_gen_body?\n+            // that makes no sense, though...\n+            gen_body: |move prev_gen_body,\n+                       body| { wrapper(prev_gen_body(move body)) },\n             can_not_copy: None,\n             .. *self.consume()\n         })\n@@ -931,7 +935,7 @@ fn test_add_wrapper() {\n     let ch = comm::Chan(&po);\n     let b0 = task();\n     let b1 = do b0.add_wrapper |body| {\n-        fn~() {\n+        fn~(move body) {\n             body();\n             comm::send(ch, ());\n         }\n@@ -944,14 +948,15 @@ fn test_add_wrapper() {\n #[ignore(cfg(windows))]\n fn test_future_result() {\n     let mut result = None;\n-    do task().future_result(|+r| { result = Some(r); }).spawn { }\n-    assert future::get(&option::unwrap(result)) == Success;\n+    do task().future_result(|+r| { result = Some(move r); }).spawn { }\n+    assert future::get(&option::unwrap(move result)) == Success;\n \n     result = None;\n-    do task().future_result(|+r| { result = Some(r); }).unlinked().spawn {\n+    do task().future_result(|+r|\n+        { result = Some(move r); }).unlinked().spawn {\n         fail;\n     }\n-    assert future::get(&option::unwrap(result)) == Failure;\n+    assert future::get(&option::unwrap(move result)) == Failure;\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -981,7 +986,7 @@ fn test_spawn_conversation() {\n     let (recv_str, send_int) = do spawn_conversation |recv_int, send_str| {\n         let input = comm::recv(recv_int);\n         let output = int::str(input);\n-        comm::send(send_str, output);\n+        comm::send(send_str, move output);\n     };\n     comm::send(send_int, 1);\n     assert comm::recv(recv_str) == ~\"1\";\n@@ -1134,7 +1139,7 @@ fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n-    do spawnfn {\n+    do spawnfn |move x| {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n         comm::send(ch, x_in_child);\n     }\n@@ -1160,7 +1165,7 @@ fn test_avoid_copying_the_body_spawn_listener() {\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        do task().spawn {\n+        do task().spawn |move f| {\n             f();\n         }\n     }\n@@ -1178,7 +1183,7 @@ fn test_avoid_copying_the_body_spawn_listener_1() {\n #[test]\n fn test_avoid_copying_the_body_try() {\n     do avoid_copying_the_body |f| {\n-        do try {\n+        do try |move f| {\n             f()\n         };\n     }\n@@ -1187,7 +1192,7 @@ fn test_avoid_copying_the_body_try() {\n #[test]\n fn test_avoid_copying_the_body_unlinked() {\n     do avoid_copying_the_body |f| {\n-        do spawn_unlinked {\n+        do spawn_unlinked |move f| {\n             f();\n         }\n     }\n@@ -1212,7 +1217,7 @@ fn test_unkillable() {\n \n     // We want to do this after failing\n     do spawn_unlinked {\n-        for iter::repeat(10u) { yield() }\n+        for iter::repeat(10) { yield() }\n         ch.send(());\n     }\n \n@@ -1226,12 +1231,12 @@ fn test_unkillable() {\n     unsafe {\n         do unkillable {\n             let p = ~0;\n-            let pp: *uint = cast::transmute(p);\n+            let pp: *uint = cast::transmute(move p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(pp);\n+            let _p: ~int = cast::transmute(move pp);\n         }\n     }\n \n@@ -1246,8 +1251,8 @@ fn test_unkillable_nested() {\n     let (ch, po) = pipes::stream();\n \n     // We want to do this after failing\n-    do spawn_unlinked {\n-        for iter::repeat(10u) { yield() }\n+    do spawn_unlinked |move ch| {\n+        for iter::repeat(10) { yield() }\n         ch.send(());\n     }\n \n@@ -1262,12 +1267,12 @@ fn test_unkillable_nested() {\n         do unkillable {\n             do unkillable {} // Here's the difference from the previous test.\n             let p = ~0;\n-            let pp: *uint = cast::transmute(p);\n+            let pp: *uint = cast::transmute(move p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(pp);\n+            let _p: ~int = cast::transmute(move pp);\n         }\n     }\n \n@@ -1311,7 +1316,7 @@ fn test_child_doesnt_ref_parent() {\n fn test_sched_thread_per_core() {\n     let (chan, port) = pipes::stream();\n \n-    do spawn_sched(ThreadPerCore) {\n+    do spawn_sched(ThreadPerCore) |move chan| {\n         let cores = rt::rust_num_threads();\n         let reported_threads = rt::rust_sched_threads();\n         assert(cores as uint == reported_threads as uint);\n@@ -1325,15 +1330,15 @@ fn test_sched_thread_per_core() {\n fn test_spawn_thread_on_demand() {\n     let (chan, port) = pipes::stream();\n \n-    do spawn_sched(ManualThreads(2)) {\n+    do spawn_sched(ManualThreads(2)) |move chan| {\n         let max_threads = rt::rust_sched_threads();\n         assert(max_threads as int == 2);\n         let running_threads = rt::rust_sched_current_nonlazy_threads();\n         assert(running_threads as int == 1);\n \n         let (chan2, port2) = pipes::stream();\n \n-        do spawn() {\n+        do spawn() |move chan2| {\n             chan2.send(());\n         }\n "}, {"sha": "533e98514924ae78359342552600911935bdaaee", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -312,8 +312,8 @@ fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n \n     TCB {\n         me: me,\n-        tasks: tasks,\n-        ancestors: ancestors,\n+        tasks: move tasks,\n+        ancestors: move ancestors,\n         is_main: is_main,\n         notifier: move notifier\n     }\n@@ -330,7 +330,7 @@ struct AutoNotify {\n \n fn AutoNotify(chan: Chan<Notification>) -> AutoNotify {\n     AutoNotify {\n-        notify_chan: chan,\n+        notify_chan: move chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n@@ -652,7 +652,7 @@ fn test_spawn_raw_unsupervise() {\n         mut notify_chan: None,\n         .. default_task_opts()\n     };\n-    do spawn_raw(opts) {\n+    do spawn_raw(move opts) {\n         fail;\n     }\n }\n@@ -667,7 +667,7 @@ fn test_spawn_raw_notify_success() {\n         notify_chan: Some(move notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(opts) |move task_ch| {\n+    do spawn_raw(move opts) |move task_ch| {\n         task_ch.send(get_task());\n     }\n     let task_ = task_po.recv();\n@@ -683,10 +683,10 @@ fn test_spawn_raw_notify_failure() {\n \n     let opts = {\n         linked: false,\n-        notify_chan: Some(notify_ch),\n+        notify_chan: Some(move notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(opts) {\n+    do spawn_raw(move opts) |move task_ch| {\n         task_ch.send(get_task());\n         fail;\n     }"}, {"sha": "8380cbf6b638ed03df241bbdc44b4911bcacdb31", "filename": "src/libcore/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -100,7 +100,7 @@ mod tests {\n         let x = ~[(5, false)];\n         //FIXME #3387 assert x.eq(id(copy x));\n         let y = copy x;\n-        assert x.eq(&id(y));\n+        assert x.eq(&id(move y));\n     }\n     #[test]\n     fn test_swap() {"}, {"sha": "2e91c4b22c43f61482795e6a702f5011a17c3c22", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a62793fa54a413a265591879c9775b798d762c/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=30a62793fa54a413a265591879c9775b798d762c", "patch": "@@ -340,15 +340,15 @@ pub fn splitn<T: Copy>(v: &[T], n: uint, f: fn(t: &T) -> bool) -> ~[~[T]] {\n  */\n pub fn rsplit<T: Copy>(v: &[T], f: fn(t: &T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n-    if (ln == 0u) { return ~[] }\n+    if (ln == 0) { return ~[] }\n \n     let mut end = ln;\n     let mut result = ~[];\n-    while end > 0u {\n-        match rposition_between(v, 0u, end, f) {\n+    while end > 0 {\n+        match rposition_between(v, 0, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1u, end));\n+                result.push(slice(v, i + 1, end));\n                 end = i;\n             }\n         }\n@@ -416,7 +416,7 @@ pub fn shift<T>(v: &mut ~[T]) -> T {\n pub fn unshift<T>(v: &mut ~[T], x: T) {\n     let mut vv = ~[move x];\n     *v <-> vv;\n-    v.push_all_move(vv);\n+    v.push_all_move(move vv);\n }\n \n pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n@@ -433,7 +433,7 @@ pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) unsafe {\n }\n \n pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n-    consume(vec::from_mut(v), f)\n+    consume(vec::from_mut(move v), f)\n }\n \n /// Remove the last element from a vector and return it\n@@ -591,7 +591,7 @@ pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n \n #[inline(always)]\n pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n-    to_mut(append(from_mut(lhs), rhs))\n+    to_mut(append(from_mut(move lhs), rhs))\n }\n \n /**\n@@ -1621,7 +1621,7 @@ impl<T> ~[T]: MutableVector<T> {\n     }\n \n     fn unshift(&mut self, x: T) {\n-        unshift(self, x)\n+        unshift(self, move x)\n     }\n \n     fn swap_remove(&mut self, index: uint) -> T {\n@@ -2208,7 +2208,7 @@ mod tests {\n     #[test]\n     fn test_dedup() {\n         fn case(a: ~[uint], b: ~[uint]) {\n-            let mut v = a;\n+            let mut v = move a;\n             v.dedup();\n             assert(v == b);\n         }\n@@ -2464,13 +2464,13 @@ mod tests {\n         let v1 = ~[1, 2, 3];\n         let v2 = ~[4, 5, 6];\n \n-        let z1 = zip(v1, v2);\n+        let z1 = zip(move v1, move v2);\n \n         assert ((1, 4) == z1[0]);\n         assert ((2, 5) == z1[1]);\n         assert ((3, 6) == z1[2]);\n \n-        let (left, right) = unzip(z1);\n+        let (left, right) = unzip(move z1);\n \n         assert ((1, 4) == (left[0], right[0]));\n         assert ((2, 5) == (left[1], right[1]));\n@@ -2768,7 +2768,7 @@ mod tests {\n         unsafe {\n             let x = ~[1, 2, 3];\n             let addr = raw::to_ptr(x);\n-            let x_mut = to_mut(x);\n+            let x_mut = to_mut(move x);\n             let addr_mut = raw::to_ptr(x_mut);\n             assert addr == addr_mut;\n         }\n@@ -2779,7 +2779,7 @@ mod tests {\n         unsafe {\n             let x = ~[mut 1, 2, 3];\n             let addr = raw::to_ptr(x);\n-            let x_imm = from_mut(x);\n+            let x_imm = from_mut(move x);\n             let addr_imm = raw::to_ptr(x_imm);\n             assert addr == addr_imm;\n         }\n@@ -2977,7 +2977,7 @@ mod tests {\n     fn test_consume_fail() {\n         let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do consume(v) |_i, _elt| {\n+        do consume(move v) |_i, _elt| {\n             if i == 2 {\n                 fail\n             }\n@@ -2991,7 +2991,7 @@ mod tests {\n     fn test_consume_mut_fail() {\n         let v = ~[mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do consume_mut(v) |_i, _elt| {\n+        do consume_mut(move v) |_i, _elt| {\n             if i == 2 {\n                 fail\n             }\n@@ -3034,7 +3034,7 @@ mod tests {\n     fn test_map_consume_fail() {\n         let v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do map_consume(v) |_elt| {\n+        do map_consume(move v) |_elt| {\n             if i == 2 {\n                 fail\n             }"}]}