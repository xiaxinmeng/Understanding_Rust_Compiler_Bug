{"sha": "ce1e211eeb607fdc131cedc764ccb7d824b28b70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMWUyMTFlZWI2MDdmZGMxMzFjZWRjNzY0Y2NiN2Q4MjRiMjhiNzA=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T11:38:06Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-18T16:19:16Z"}, "message": "Adapt the getter macro to implement Clone, Eq and Ord for n-ary tuples", "tree": {"sha": "1004b1f9c74d086a2833b5f0fba1e3a6e3e908f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1004b1f9c74d086a2833b5f0fba1e3a6e3e908f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce1e211eeb607fdc131cedc764ccb7d824b28b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce1e211eeb607fdc131cedc764ccb7d824b28b70", "html_url": "https://github.com/rust-lang/rust/commit/ce1e211eeb607fdc131cedc764ccb7d824b28b70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce1e211eeb607fdc131cedc764ccb7d824b28b70/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8", "html_url": "https://github.com/rust-lang/rust/commit/3a323c1b2d755b86b1987bba3454bb2f0f92b1c8"}], "stats": {"total": 200, "additions": 55, "deletions": 145}, "files": [{"sha": "27632acf4e8f33eebe8e102267c05048885a1386", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 55, "deletions": 145, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/ce1e211eeb607fdc131cedc764ccb7d824b28b70/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce1e211eeb607fdc131cedc764ccb7d824b28b70/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=ce1e211eeb607fdc131cedc764ccb7d824b28b70", "patch": "@@ -10,13 +10,10 @@\n \n //! Operations on tuples\n \n-use clone::Clone;\n use kinds::Copy;\n use vec;\n \n-#[cfg(not(test))] use cmp::{Eq, Ord};\n-\n-pub use self::getters::*;\n+pub use self::inner::*;\n \n pub trait CopyableTuple<T, U> {\n     fn first(&self) -> T;\n@@ -46,16 +43,6 @@ impl<T:Copy,U:Copy> CopyableTuple<T, U> for (T, U) {\n         let (t, u) = *self;\n         return (u, t);\n     }\n-\n-}\n-\n-impl<T:Clone,U:Clone> Clone for (T, U) {\n-    fn clone(&self) -> (T, U) {\n-        let (a, b) = match *self {\n-            (ref a, ref b) => (a, b)\n-        };\n-        (a.clone(), b.clone())\n-    }\n }\n \n pub trait ImmutableTuple<T, U> {\n@@ -124,158 +111,81 @@ impl<A:Copy,B:Copy> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n     }\n }\n \n-#[cfg(not(test))]\n-impl<A:Eq> Eq for (A,) {\n-    #[inline(always)]\n-    fn eq(&self, other: &(A,)) -> bool {\n-        match (*self) {\n-            (ref self_a,) => match other {\n-                &(ref other_a,) => {\n-                    (*self_a).eq(other_a)\n-                }\n-            }\n+// macro for implementing n-ary tuple functions and operations\n+\n+macro_rules! tuple_impls(\n+    ($(\n+        $name:ident {\n+            $(fn $get_fn:ident -> $T:ident { $get_pattern:pat => $ret:expr })+\n         }\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &(A,)) -> bool { !(*self).eq(other) }\n-}\n+    )+) => (\n+        pub mod inner {\n+            use clone::Clone;\n+            #[cfg(not(test))] use cmp::{Eq, Ord};\n \n-#[cfg(not(test))]\n-impl<A:Ord> Ord for (A,) {\n-    #[inline(always)]\n-    fn lt(&self, other: &(A,)) -> bool {\n-        match (*self) {\n-            (ref self_a,) => {\n-                match (*other) {\n-                    (ref other_a,) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        return false;\n-                    }\n+            $(\n+                pub trait $name<$($T),+> {\n+                    $(fn $get_fn<'a>(&'a self) -> &'a $T;)+\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn le(&self, other: &(A,)) -> bool { !other.lt(&(*self)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &(A,)) -> bool { !self.lt(other) }\n-    #[inline(always)]\n-    fn gt(&self, other: &(A,)) -> bool { other.lt(&(*self))  }\n-}\n \n-#[cfg(not(test))]\n-impl<A:Eq,B:Eq> Eq for (A, B) {\n-    #[inline(always)]\n-    fn eq(&self, other: &(A, B)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b) => match other {\n-                &(ref other_a, ref other_b) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n+                impl<$($T),+> $name<$($T),+> for ($($T),+) {\n+                    $(\n+                        #[inline(always)]\n+                        fn $get_fn<'a>(&'a self) -> &'a $T {\n+                            match *self {\n+                                $get_pattern => $ret\n+                            }\n+                        }\n+                    )+\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &(A, B)) -> bool { !(*self).eq(other) }\n-}\n \n-#[cfg(not(test))]\n-impl<A:Ord,B:Ord> Ord for (A, B) {\n-    #[inline(always)]\n-    fn lt(&self, other: &(A, B)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        return false;\n+                impl<$($T:Clone),+> Clone for ($($T),+) {\n+                    fn clone(&self) -> ($($T),+) {\n+                        ($(self.$get_fn().clone()),+)\n                     }\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn le(&self, other: &(A, B)) -> bool { !(*other).lt(&(*self)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &(A, B)) -> bool { !(*self).lt(other) }\n-    #[inline(always)]\n-    fn gt(&self, other: &(A, B)) -> bool { (*other).lt(&(*self))  }\n-}\n \n-#[cfg(not(test))]\n-impl<A:Eq,B:Eq,C:Eq> Eq for (A, B, C) {\n-    #[inline(always)]\n-    fn eq(&self, other: &(A, B, C)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b, ref self_c) => match other {\n-                &(ref other_a, ref other_b, ref other_c) => {\n-                    (*self_a).eq(other_a) && (*self_b).eq(other_b)\n-                        && (*self_c).eq(other_c)\n-                }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &(A, B, C)) -> bool { !(*self).eq(other) }\n-}\n+                #[cfg(not(test))]\n+                impl<$($T:Eq),+> Eq for ($($T),+) {\n+                    #[inline(always)]\n+                    fn eq(&self, other: &($($T),+)) -> bool {\n+                        $(*self.$get_fn() == *other.$get_fn())&&+\n+                    }\n \n-#[cfg(not(test))]\n-impl<A:Ord,B:Ord,C:Ord> Ord for (A, B, C) {\n-    #[inline(always)]\n-    fn lt(&self, other: &(A, B, C)) -> bool {\n-        match (*self) {\n-            (ref self_a, ref self_b, ref self_c) => {\n-                match (*other) {\n-                    (ref other_a, ref other_b, ref other_c) => {\n-                        if (*self_a).lt(other_a) { return true; }\n-                        if (*other_a).lt(self_a) { return false; }\n-                        if (*self_b).lt(other_b) { return true; }\n-                        if (*other_b).lt(self_b) { return false; }\n-                        if (*self_c).lt(other_c) { return true; }\n-                        return false;\n+                    #[inline(always)]\n+                    fn ne(&self, other: &($($T),+)) -> bool {\n+                        !(*self == *other)\n                     }\n                 }\n-            }\n-        }\n-    }\n-    #[inline(always)]\n-    fn le(&self, other: &(A, B, C)) -> bool { !(*other).lt(&(*self)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &(A, B, C)) -> bool { !(*self).lt(other) }\n-    #[inline(always)]\n-    fn gt(&self, other: &(A, B, C)) -> bool { (*other).lt(&(*self))  }\n-}\n \n-// Tuple element getters\n+                #[cfg(not(test))]\n+                impl<$($T:Ord),+> Ord for ($($T),+) {\n+                    #[inline(always)]\n+                    fn lt(&self, other: &($($T),+)) -> bool {\n+                        $(*self.$get_fn() < *other.$get_fn())&&+\n+                    }\n \n-macro_rules! tuple_getters(\n-    ($(\n-        $name:ident {\n-            $(fn $method:ident -> $T:ident { $accessor:pat => $t:expr })+\n-        }\n-    )+) => (\n-        pub mod getters {\n-            $(pub trait $name<$($T),+> {\n-                    $(fn $method<'a>(&'a self) -> &'a $T;)+\n-            })+\n+                    #[inline(always)]\n+                    fn le(&self, other: &($($T),+)) -> bool {\n+                        $(*self.$get_fn() <= *other.$get_fn())&&+\n+                    }\n \n-            $(impl<$($T),+> $name<$($T),+> for ($($T),+) {\n-                $(\n                     #[inline(always)]\n-                    fn $method<'a>(&'a self) -> &'a $T {\n-                        match *self {\n-                            $accessor => $t\n-                        }\n+                    fn ge(&self, other: &($($T),+)) -> bool {\n+                        $(*self.$get_fn() >= *other.$get_fn())&&+\n                     }\n-                )+\n-            })+\n+\n+                    #[inline(always)]\n+                    fn gt(&self, other: &($($T),+)) -> bool {\n+                        $(*self.$get_fn() > *other.$get_fn())&&+\n+                    }\n+                }\n+            )+\n         }\n     )\n )\n \n-tuple_getters!(\n+tuple_impls!(\n     Tuple2 {\n         fn n0 -> A { (ref a,_) => a }\n         fn n1 -> B { (_,ref b) => b }"}]}