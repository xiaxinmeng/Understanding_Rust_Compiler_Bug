{"sha": "fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZjhmYTlkYWYxZTdmYjFjMTY3YjdhZTNmZjFlNDY4ZDJhNGI1YzE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-12T03:52:39Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-12T03:52:39Z"}, "message": "Merge pull request #851 from Manishearth/doc\n\nFix FP with `DOC_MARKDOWN` and reference links", "tree": {"sha": "9cd38f89976907bb4cd12a027e69b0d7036835ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cd38f89976907bb4cd12a027e69b0d7036835ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1", "html_url": "https://github.com/rust-lang/rust/commit/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b779043609cd30a031614c5f320e7ca1c3ef1a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b779043609cd30a031614c5f320e7ca1c3ef1a5", "html_url": "https://github.com/rust-lang/rust/commit/0b779043609cd30a031614c5f320e7ca1c3ef1a5"}, {"sha": "6c0a486e8b3f9801a408b89946cb6c8245a88061", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c0a486e8b3f9801a408b89946cb6c8245a88061", "html_url": "https://github.com/rust-lang/rust/commit/6c0a486e8b3f9801a408b89946cb6c8245a88061"}], "stats": {"total": 114, "additions": 94, "deletions": 20}, "files": [{"sha": "da87b1043417fc9f10cf4944f72fb35f0fdd8704", "filename": "src/doc.rs", "status": "modified", "additions": 85, "deletions": 16, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1/src%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1/src%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc.rs?ref=fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1", "patch": "@@ -84,7 +84,32 @@ fn collect_doc(attrs: &[ast::Attribute]) -> (Cow<str>, Option<Span>) {\n pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute], default_span: Span) {\n     let (doc, span) = collect_doc(attrs);\n     let span = span.unwrap_or(default_span);\n+    check_doc(cx, valid_idents, &doc, span);\n+}\n+\n+macro_rules! jump_to {\n+    // Get the next character\u2019s first byte UTF-8 friendlyly.\n+    (@next_char, $chars: expr, $len: expr) => {{\n+        if let Some(&(pos, _)) = $chars.peek() {\n+            pos\n+        } else {\n+            $len\n+        }\n+    }};\n+\n+    // Jump to the next `$c`. If no such character is found, give up.\n+    ($chars: expr, $c: expr, $len: expr) => {{\n+        if $chars.find(|&(_, c)| c == $c).is_some() {\n+            jump_to!(@next_char, $chars, $len)\n+        }\n+        else {\n+            return;\n+        }\n+    }};\n+}\n \n+#[allow(while_let_loop)] // #362\n+pub fn check_doc(cx: &EarlyContext, valid_idents: &[String], doc: &str, span: Span) {\n     // In markdown, `_` can be used to emphasize something, or, is a raw `_` depending on context.\n     // There really is no markdown specification that would disambiguate this properly. This is\n     // what GitHub and Rustdoc do:\n@@ -96,19 +121,68 @@ pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [a\n     // (_baz_)             \u2192 (<em>baz</em>)\n     // foo _ bar _ baz     \u2192 foo _ bar _ baz\n \n-    let mut in_ticks = false;\n-    for word in doc.split_whitespace() {\n-        let ticks = word.bytes().filter(|&b| b == b'`').count();\n-\n-        if ticks == 2 { // likely to be \u201c`foo`\u201d\n-            continue;\n-        } else if ticks % 2 == 1 {\n-            in_ticks = !in_ticks;\n-            continue; // let\u2019s assume no one will ever write something like \u201c`foo`_bar\u201d\n+    /// Character that can appear in a word\n+    fn is_word_char(c: char) -> bool {\n+        match c {\n+            t if t.is_alphanumeric() => true,\n+            ':' | '_' => true,\n+            _ => false,\n         }\n+    }\n \n-        if !in_ticks {\n-            check_word(cx, valid_idents, word, span);\n+    let len = doc.len();\n+    let mut chars = doc.char_indices().peekable();\n+    let mut current_word_begin = 0;\n+    loop {\n+        match chars.next() {\n+            Some((_, c)) => {\n+                match c {\n+                    c if c.is_whitespace() => {\n+                        current_word_begin = jump_to!(@next_char, chars, len);\n+                    }\n+                    '`' => {\n+                        current_word_begin = jump_to!(chars, '`', len);\n+                    },\n+                    '[' => {\n+                        let end = jump_to!(chars, ']', len);\n+                        let link_text = &doc[current_word_begin+1..end];\n+\n+                        match chars.peek() {\n+                            Some(&(_, c)) => {\n+                                // Trying to parse a link. Let\u2019s ignore the link.\n+\n+                                // FIXME: how does markdown handles such link?\n+                                // https://en.wikipedia.org/w/index.php?title=)\n+                                match c {\n+                                    '(' => { // inline link\n+                                        current_word_begin = jump_to!(chars, ')', len);\n+                                        check_doc(cx, valid_idents, link_text, span);\n+                                    }\n+                                    '[' => { // reference link\n+                                        current_word_begin = jump_to!(chars, ']', len);\n+                                        check_doc(cx, valid_idents, link_text, span);\n+                                    }\n+                                    ':' => { // reference link\n+                                        current_word_begin = jump_to!(chars, '\\n', len);\n+                                    }\n+                                    _ => continue,\n+                                }\n+                            }\n+                            None => return,\n+                        }\n+                    }\n+                    _ => {\n+                        let end = match chars.find(|&(_, c)| !is_word_char(c)) {\n+                            Some((end, _)) => end,\n+                            None => len,\n+                        };\n+\n+                        check_word(cx, valid_idents, &doc[current_word_begin..end], span);\n+                        current_word_begin = jump_to!(@next_char, chars, len);\n+                    }\n+                }\n+            }\n+            None => break,\n         }\n     }\n }\n@@ -136,11 +210,6 @@ fn check_word(cx: &EarlyContext, valid_idents: &[String], word: &str, span: Span\n         s != \"_\" && !s.contains(\"\\\\_\") && s.contains('_')\n     }\n \n-    // Something with a `/` might be a link, don\u2019t warn (see #823):\n-    if word.contains('/') {\n-        return;\n-    }\n-\n     // Trim punctuation as in `some comment (see foo::bar).`\n     //                                                   ^^\n     // Or even as in `_foo bar_` which is emphasized."}, {"sha": "45f87fba9ddaef68c562f35efdfa9e40e3974547", "filename": "src/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1", "patch": "@@ -805,7 +805,7 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     None\n }\n \n-/// This checks whether a given type is known to implement Debug.\n+/// This checks whether a given type is known to implement `Debug`.\n fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n         Some(debug) => implements_trait(cx, ty, debug, Vec::new()),"}, {"sha": "81250b5485a4551c7ca5862b56688b994679f76f", "filename": "tests/compile-fail/doc.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1/tests%2Fcompile-fail%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1/tests%2Fcompile-fail%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdoc.rs?ref=fbf8fa9daf1e7fb1c167b7ae3ff1e468d2a4b5c1", "patch": "@@ -41,14 +41,19 @@ fn test_emphasis() {\n fn test_units() {\n }\n \n-/// This test has [a link with underscores][chunked-example] inside it. See #823.\n-/// See also [the issue tracker](https://github.com/Manishearth/rust-clippy/search?q=doc_markdown&type=Issues).\n+/// This test has [a link_with_underscores][chunked-example] inside it. See #823.\n+/// See also [the issue tracker](https://github.com/Manishearth/rust-clippy/search?q=doc_markdown&type=Issues). And here is another [inline link][inline_link].\n ///\n-/// [chunked-example]: http://en.wikipedia.org/wiki/Chunked_transfer_encoding#Example\n+/// [chunked-example]: https://en.wikipedia.org/wiki/Chunked_transfer_encoding#Example\n+/// [inline_link]: https://foobar\n \n /// The `main` function is the entry point of the program. Here it only calls the `foo_bar` and\n /// `multiline_ticks` functions.\n+///\n+/// expression of the type  `_ <bit_op> m <cmp_op> c` (where `<bit_op>`\n+/// is one of {`&`, '|'} and `<cmp_op>` is one of {`!=`, `>=`, `>` ,\n fn main() {\n+//~^ ERROR: you should put `link_with_underscores` between ticks\n     foo_bar();\n     multiline_ticks();\n     test_emphasis();"}]}