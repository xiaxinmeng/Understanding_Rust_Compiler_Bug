{"sha": "027780ca2cd54dc9619058e9082c62f268f5c362", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNzc4MGNhMmNkNTRkYzk2MTkwNThlOTA4MmM2MmYyNjhmNWMzNjI=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-08-11T13:43:21Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-08-11T15:50:45Z"}, "message": "Merge commit '09bd400243ed6f7059fedc0c1623aae3792521d6' into clippyup", "tree": {"sha": "a2e1e4331906d828abd0577c61078046bc5bbfa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2e1e4331906d828abd0577c61078046bc5bbfa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/027780ca2cd54dc9619058e9082c62f268f5c362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/027780ca2cd54dc9619058e9082c62f268f5c362", "html_url": "https://github.com/rust-lang/rust/commit/027780ca2cd54dc9619058e9082c62f268f5c362", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/027780ca2cd54dc9619058e9082c62f268f5c362/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e73d3368041a74fac40328d91605364e0cedcd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e73d3368041a74fac40328d91605364e0cedcd7", "html_url": "https://github.com/rust-lang/rust/commit/9e73d3368041a74fac40328d91605364e0cedcd7"}], "stats": {"total": 3319, "additions": 2700, "deletions": 619}, "files": [{"sha": "5e9ed54c848205e499dd85cb43146d9b1d3f6f1e", "filename": "CHANGELOG.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -6,13 +6,13 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[c2c07fa...master](https://github.com/rust-lang/rust-clippy/compare/7ea7cd1...master)\n+[c2c07fa...master](https://github.com/rust-lang/rust-clippy/compare/c2c07fa...master)\n \n ## Rust 1.46\n \n Current beta, release 2020-08-27\n \n-[7ea7cd1...c2c07fa](https://github.com/rust-lang/rust-clippy/compare/7ea7cd1...master)\n+[7ea7cd1...c2c07fa](https://github.com/rust-lang/rust-clippy/compare/7ea7cd1...c2c07fa)\n \n ### New lints\n \n@@ -1454,6 +1454,7 @@ Released 2018-09-13\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n+[`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n [`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons\n@@ -1615,6 +1616,7 @@ Released 2018-09-13\n [`mutex_atomic`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutex_atomic\n [`mutex_integer`]: https://rust-lang.github.io/rust-clippy/master/index.html#mutex_integer\n [`naive_bytecount`]: https://rust-lang.github.io/rust-clippy/master/index.html#naive_bytecount\n+[`needless_arbitrary_self_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_arbitrary_self_type\n [`needless_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_bool\n [`needless_borrow`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n [`needless_borrowed_reference`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrowed_reference\n@@ -1686,6 +1688,7 @@ Released 2018-09-13\n [`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n [`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n+[`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n [`search_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#search_is_some\n [`serde_api_misuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#serde_api_misuse\n [`shadow_reuse`]: https://rust-lang.github.io/rust-clippy/master/index.html#shadow_reuse\n@@ -1701,6 +1704,7 @@ Released 2018-09-13\n [`single_match_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#single_match_else\n [`skip_while_next`]: https://rust-lang.github.io/rust-clippy/master/index.html#skip_while_next\n [`slow_vector_initialization`]: https://rust-lang.github.io/rust-clippy/master/index.html#slow_vector_initialization\n+[`stable_sort_primitive`]: https://rust-lang.github.io/rust-clippy/master/index.html#stable_sort_primitive\n [`str_to_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#str_to_string\n [`string_add`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add\n [`string_add_assign`]: https://rust-lang.github.io/rust-clippy/master/index.html#string_add_assign\n@@ -1723,6 +1727,7 @@ Released 2018-09-13\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n [`too_many_lines`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines\n [`toplevel_ref_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#toplevel_ref_arg\n+[`trait_duplication_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#trait_duplication_in_bounds\n [`transmute_bytes_to_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_bytes_to_str\n [`transmute_float_to_int`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_float_to_int\n [`transmute_int_to_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_bool"}, {"sha": "5f7b1e85ee9a1769f6de383ca49bd5c433e47293", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -28,11 +28,14 @@ All contributors are expected to follow the [Rust Code of Conduct].\n \n ## Getting started\n \n-High level approach:\n+**Note: If this is your first time contributing to Clippy, you should\n+first read the [Basics docs](doc/basics.md).**\n+\n+### High level approach\n \n 1. Find something to fix/improve\n 2. Change code (likely some file in `clippy_lints/src/`)\n-3. Follow the instructions in the [docs for writing lints](doc/adding_lints.md) such as running the `setup-toolchain.sh` script\n+3. Follow the instructions in the [Basics docs](doc/basics.md) to get set up\n 4. Run `cargo test` in the root directory and wiggle code until it passes\n 5. Open a PR (also can be done after 2. if you run into problems)\n \n@@ -95,16 +98,16 @@ quick read.\n \n ## Getting code-completion for rustc internals to work\n \n-Unfortunately, [`rust-analyzer`][ra_homepage] does not (yet?) understand how Clippy uses compiler-internals \n-using `extern crate` and it also needs to be able to read the source files of the rustc-compiler which are not \n-available via a `rustup` component at the time of writing.  \n-To work around this, you need to have a copy of the [rustc-repo][rustc_repo] available which can be obtained via  \n-`git clone https://github.com/rust-lang/rust/`.  \n-Then you can run a `cargo dev` command to automatically make Clippy use the rustc-repo via path-dependencies \n-which rust-analyzer will be able to understand.  \n-Run `cargo dev ra-setup --repo-path <repo-path>` where `<repo-path>` is an absolute path to the rustc repo \n-you just cloned.  \n-The command will add path-dependencies pointing towards rustc-crates inside the rustc repo to \n+Unfortunately, [`rust-analyzer`][ra_homepage] does not (yet?) understand how Clippy uses compiler-internals\n+using `extern crate` and it also needs to be able to read the source files of the rustc-compiler which are not\n+available via a `rustup` component at the time of writing.\n+To work around this, you need to have a copy of the [rustc-repo][rustc_repo] available which can be obtained via\n+`git clone https://github.com/rust-lang/rust/`.\n+Then you can run a `cargo dev` command to automatically make Clippy use the rustc-repo via path-dependencies\n+which rust-analyzer will be able to understand.\n+Run `cargo dev ra-setup --repo-path <repo-path>` where `<repo-path>` is an absolute path to the rustc repo\n+you just cloned.\n+The command will add path-dependencies pointing towards rustc-crates inside the rustc repo to\n Clippys `Cargo.toml`s and should allow rust-analyzer to understand most of the types that Clippy uses.\n Just make sure to remove the dependencies again before finally making a pull request!\n "}, {"sha": "f2bd651ab253c6419ce6395e22d7d5a18562dd78", "filename": "clippy_dev/src/ra_setup.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_dev%2Fsrc%2Fra_setup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_dev%2Fsrc%2Fra_setup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fra_setup.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -68,10 +68,11 @@ fn inject_deps_into_manifest(\n     });\n \n     // format a new [dependencies]-block with the new deps we need to inject\n-    let mut all_deps = String::from(\"[dependencies]\\n\");\n+    let mut all_deps = String::from(\"[target.'cfg(NOT_A_PLATFORM)'.dependencies]\\n\");\n     new_deps.for_each(|dep_line| {\n         all_deps.push_str(&dep_line);\n     });\n+    all_deps.push_str(\"\\n[dependencies]\\n\");\n \n     // replace \"[dependencies]\" with\n     // [dependencies]"}, {"sha": "376ac55f9c98ca60b1a96cf637174108a6d221c4", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,6 +1,5 @@\n //! checks for attributes\n \n-use crate::reexport::Name;\n use crate::utils::{\n     first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_help,\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n@@ -517,7 +516,7 @@ fn is_relevant_expr(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>\n     }\n }\n \n-fn check_attrs(cx: &LateContext<'_>, span: Span, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribute]) {\n     if span.from_expansion() {\n         return;\n     }\n@@ -606,7 +605,7 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::as\n                         cx,\n                         EMPTY_LINE_AFTER_OUTER_ATTR,\n                         begin_of_attr_to_item,\n-                        \"Found an empty line after an outer attribute. \\\n+                        \"found an empty line after an outer attribute. \\\n                         Perhaps you forgot to add a `!` to make it an inner attribute?\",\n                     );\n                 }"}, {"sha": "cdb49d777d8dae2aeee008054b61dee8c293f092", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -82,8 +82,8 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                             cx,\n                             NAIVE_BYTECOUNT,\n                             expr.span,\n-                            \"You appear to be counting bytes the naive way\",\n-                            \"Consider using the bytecount crate\",\n+                            \"you appear to be counting bytes the naive way\",\n+                            \"consider using the bytecount crate\",\n                             format!(\"bytecount::count({}, {})\",\n                                     snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n                                     snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),"}, {"sha": "28c1a54d2c5a6a1c1ecc2749737c668b5da8f182", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for CheckedConversions {\n                     cx,\n                     CHECKED_CONVERSIONS,\n                     item.span,\n-                    \"Checked cast can be simplified.\",\n+                    \"checked cast can be simplified\",\n                     \"try\",\n                     format!(\"{}::try_from({}).is_ok()\", to_type, snippet),\n                     applicability,"}, {"sha": "874e19d9e9fb356d96db39f9079a6e5ecec157c7", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n                                 cx,\n                                 DEFAULT_TRAIT_ACCESS,\n                                 expr.span,\n-                                &format!(\"Calling `{}` is more clear than this expression\", replacement),\n+                                &format!(\"calling `{}` is more clear than this expression\", replacement),\n                                 \"try\",\n                                 replacement,\n                                 Applicability::Unspecified, // First resolve the TODO above"}, {"sha": "80a0675898240633e73830d6dc6a649df326c7ef", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 117, "deletions": 3, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::paths;\n use crate::utils::{\n-    is_automatically_derived, is_copy, match_path, span_lint_and_help, span_lint_and_note, span_lint_and_then,\n+    get_trait_def_id, is_allowed, is_automatically_derived, is_copy, match_path, span_lint_and_help,\n+    span_lint_and_note, span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n@@ -43,6 +44,57 @@ declare_clippy_lint! {\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for deriving `Ord` but implementing `PartialOrd`\n+    /// explicitly or vice versa.\n+    ///\n+    /// **Why is this bad?** The implementation of these traits must agree (for\n+    /// example for use with `sort`) so it\u2019s probably a bad idea to use a\n+    /// default-generated `Ord` implementation with an explicitly defined\n+    /// `PartialOrd`. In particular, the following must hold for any type\n+    /// implementing `Ord`:\n+    ///\n+    /// ```text\n+    /// k1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// #[derive(Ord, PartialEq, Eq)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialOrd for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// #[derive(PartialEq, Eq)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialOrd for Foo {\n+    ///     fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n+    ///        Some(self.cmp(other))\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Ord for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    /// or, if you don't need a custom ordering:\n+    /// ```rust,ignore\n+    /// #[derive(Ord, PartialOrd, PartialEq, Eq)]\n+    /// struct Foo;\n+    /// ```\n+    pub DERIVE_ORD_XOR_PARTIAL_ORD,\n+    correctness,\n+    \"deriving `Ord` but implementing `PartialOrd` explicitly\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n     /// types.\n@@ -103,7 +155,12 @@ declare_clippy_lint! {\n     \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\"\n }\n \n-declare_lint_pass!(Derive => [EXPL_IMPL_CLONE_ON_COPY, DERIVE_HASH_XOR_EQ, UNSAFE_DERIVE_DESERIALIZE]);\n+declare_lint_pass!(Derive => [\n+    EXPL_IMPL_CLONE_ON_COPY,\n+    DERIVE_HASH_XOR_EQ,\n+    DERIVE_ORD_XOR_PARTIAL_ORD,\n+    UNSAFE_DERIVE_DESERIALIZE\n+]);\n \n impl<'tcx> LateLintPass<'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n@@ -116,6 +173,7 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n+            check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);\n \n             if is_automatically_derived {\n                 check_unsafe_derive_deserialize(cx, item, trait_ref, ty);\n@@ -180,6 +238,60 @@ fn check_hash_peq<'tcx>(\n     }\n }\n \n+/// Implementation of the `DERIVE_ORD_XOR_PARTIAL_ORD` lint.\n+fn check_ord_partial_ord<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    trait_ref: &TraitRef<'_>,\n+    ty: Ty<'tcx>,\n+    ord_is_automatically_derived: bool,\n+) {\n+    if_chain! {\n+        if let Some(ord_trait_def_id) = get_trait_def_id(cx, &paths::ORD);\n+        if let Some(partial_ord_trait_def_id) = cx.tcx.lang_items().partial_ord_trait();\n+        if let Some(def_id) = &trait_ref.trait_def_id();\n+        if *def_id == ord_trait_def_id;\n+        then {\n+            // Look for the PartialOrd implementations for `ty`\n+            cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n+                let partial_ord_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+\n+                if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n+                    return;\n+                }\n+\n+                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+\n+                // Only care about `impl PartialOrd<Foo> for Foo`\n+                // For `impl PartialOrd<B> for A, input_types is [A, B]\n+                if trait_ref.substs.type_at(1) == ty {\n+                    let mess = if partial_ord_is_automatically_derived {\n+                        \"you are implementing `Ord` explicitly but have derived `PartialOrd`\"\n+                    } else {\n+                        \"you are deriving `Ord` but have implemented `PartialOrd` explicitly\"\n+                    };\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        DERIVE_ORD_XOR_PARTIAL_ORD,\n+                        span,\n+                        mess,\n+                        |diag| {\n+                            if let Some(local_def_id) = impl_id.as_local() {\n+                                let hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+                                diag.span_note(\n+                                    cx.tcx.hir().span(hir_id),\n+                                    \"`PartialOrd` implemented here\"\n+                                );\n+                            }\n+                        }\n+                    );\n+                }\n+            });\n+        }\n+    }\n+}\n+\n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n     if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n@@ -242,7 +354,9 @@ fn check_unsafe_derive_deserialize<'tcx>(\n     if_chain! {\n         if match_path(&trait_ref.path, &paths::SERDE_DESERIALIZE);\n         if let ty::Adt(def, _) = ty.kind;\n-        if def.did.is_local();\n+        if let Some(local_def_id) = def.did.as_local();\n+        let adt_hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+        if !is_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);\n         if cx.tcx.inherent_impls(def.did)\n             .iter()\n             .map(|imp_did| item_from_def_id(cx, *imp_did))"}, {"sha": "bae7c4647d487a898c944adbaa0d62aa2c124dd3", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> DoubleComparisons {\n                     cx,\n                     DOUBLE_COMPARISONS,\n                     span,\n-                    \"This binary expression can be simplified\",\n+                    \"this binary expression can be simplified\",\n                     \"try\",\n                     sugg,\n                     applicability,"}, {"sha": "abbcaf43f4151adcdfc44c0954d6e797531667f4", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -45,41 +45,28 @@ impl EarlyLintPass for DoubleParens {\n             return;\n         }\n \n+        let msg: &str = \"consider removing unnecessary double parentheses\";\n+\n         match expr.kind {\n             ExprKind::Paren(ref in_paren) => match in_paren.kind {\n                 ExprKind::Paren(_) | ExprKind::Tup(_) => {\n-                    span_lint(\n-                        cx,\n-                        DOUBLE_PARENS,\n-                        expr.span,\n-                        \"Consider removing unnecessary double parentheses\",\n-                    );\n+                    span_lint(cx, DOUBLE_PARENS, expr.span, &msg);\n                 },\n                 _ => {},\n             },\n             ExprKind::Call(_, ref params) => {\n                 if params.len() == 1 {\n                     let param = &params[0];\n                     if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(\n-                            cx,\n-                            DOUBLE_PARENS,\n-                            param.span,\n-                            \"Consider removing unnecessary double parentheses\",\n-                        );\n+                        span_lint(cx, DOUBLE_PARENS, param.span, &msg);\n                     }\n                 }\n             },\n             ExprKind::MethodCall(_, ref params, _) => {\n                 if params.len() == 2 {\n                     let param = &params[1];\n                     if let ExprKind::Paren(_) = param.kind {\n-                        span_lint(\n-                            cx,\n-                            DOUBLE_PARENS,\n-                            param.span,\n-                            \"Consider removing unnecessary double parentheses\",\n-                        );\n+                        span_lint(cx, DOUBLE_PARENS, param.span, &msg);\n                     }\n                 }\n             },"}, {"sha": "ec3b6afa6300f13b76f17e40337b3efaeabfbeec", "filename": "clippy_lints/src/drop_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fdrop_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_bounds.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -33,11 +33,11 @@ declare_clippy_lint! {\n     /// ```\n     pub DROP_BOUNDS,\n     correctness,\n-    \"Bounds of the form `T: Drop` are useless\"\n+    \"bounds of the form `T: Drop` are useless\"\n }\n \n-const DROP_BOUNDS_SUMMARY: &str = \"Bounds of the form `T: Drop` are useless. \\\n-                                   Use `std::mem::needs_drop` to detect if a type has drop glue.\";\n+const DROP_BOUNDS_SUMMARY: &str = \"bounds of the form `T: Drop` are useless, \\\n+                                   use `std::mem::needs_drop` to detect if a type has drop glue\";\n \n declare_lint_pass!(DropBounds => [DROP_BOUNDS]);\n "}, {"sha": "ac1c7aa9bbbe998977c3484eef37d1d8893572c4", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -294,7 +294,8 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n                 let body = cx.tcx.hir().body(eid);\n                 Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n \n-                if attr.is_none() && cx.access_levels.is_exported(item.hir_id) && !is_proc_macro(cx.sess(), &item.attrs) {\n+                if attr.is_none() && cx.access_levels.is_exported(item.hir_id) && !is_proc_macro(cx.sess(), &item.attrs)\n+                {\n                     check_must_use_candidate(\n                         cx,\n                         &sig.decl,\n@@ -373,7 +374,7 @@ impl<'tcx> Functions {\n         }\n \n         if line_count > self.max_lines {\n-            span_lint(cx, TOO_MANY_LINES, span, \"This function has a large number of lines.\")\n+            span_lint(cx, TOO_MANY_LINES, span, \"this function has a large number of lines\")\n         }\n     }\n "}, {"sha": "6ad525d762058c0f5b1d2b9c9ab576d34e2375e0", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -250,6 +250,7 @@ mod mut_mut;\n mod mut_reference;\n mod mutable_debug_assertion;\n mod mutex_atomic;\n+mod needless_arbitrary_self_type;\n mod needless_bool;\n mod needless_borrow;\n mod needless_borrowed_ref;\n@@ -288,6 +289,7 @@ mod serde_api;\n mod shadow;\n mod single_component_path_imports;\n mod slow_vector_initialization;\n+mod stable_sort_primitive;\n mod strings;\n mod suspicious_trait_impl;\n mod swap;\n@@ -322,10 +324,6 @@ mod zero_div_zero;\n \n pub use crate::utils::conf::Conf;\n \n-mod reexport {\n-    pub use rustc_span::Symbol as Name;\n-}\n-\n /// Register all pre expansion lints\n ///\n /// Pre-expansion lints run before any macro expansion has happened.\n@@ -513,6 +511,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &default_trait_access::DEFAULT_TRAIT_ACCESS,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n+        &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n         &derive::EXPL_IMPL_CLONE_ON_COPY,\n         &derive::UNSAFE_DERIVE_DESERIALIZE,\n         &doc::DOC_MARKDOWN,\n@@ -610,6 +609,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::NEEDLESS_COLLECT,\n         &loops::NEEDLESS_RANGE_LOOP,\n         &loops::NEVER_LOOP,\n+        &loops::SAME_ITEM_PUSH,\n         &loops::WHILE_IMMUTABLE_CONDITION,\n         &loops::WHILE_LET_LOOP,\n         &loops::WHILE_LET_ON_ITERATOR,\n@@ -719,6 +719,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL,\n         &mutex_atomic::MUTEX_ATOMIC,\n         &mutex_atomic::MUTEX_INTEGER,\n+        &needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE,\n         &needless_bool::BOOL_COMPARISON,\n         &needless_bool::NEEDLESS_BOOL,\n         &needless_borrow::NEEDLESS_BORROW,\n@@ -776,6 +777,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &shadow::SHADOW_UNRELATED,\n         &single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS,\n         &slow_vector_initialization::SLOW_VECTOR_INITIALIZATION,\n+        &stable_sort_primitive::STABLE_SORT_PRIMITIVE,\n         &strings::STRING_ADD,\n         &strings::STRING_ADD_ASSIGN,\n         &strings::STRING_LIT_AS_BYTES,\n@@ -786,6 +788,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n         &temporary_assignment::TEMPORARY_ASSIGNMENT,\n         &to_digit_is_some::TO_DIGIT_IS_SOME,\n+        &trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n         &trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n         &transmute::CROSSPOINTER_TRANSMUTE,\n         &transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n@@ -1028,6 +1031,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box items_after_statements::ItemsAfterStatements);\n     store.register_early_pass(|| box precedence::Precedence);\n     store.register_early_pass(|| box needless_continue::NeedlessContinue);\n+    store.register_early_pass(|| box needless_arbitrary_self_type::NeedlessArbitrarySelfType);\n     store.register_early_pass(|| box redundant_static_lifetimes::RedundantStaticLifetimes);\n     store.register_late_pass(|| box cargo_common_metadata::CargoCommonMetadata);\n     store.register_late_pass(|| box multiple_crate_versions::MultipleCrateVersions);\n@@ -1079,6 +1083,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box macro_use::MacroUseImports::default());\n     store.register_late_pass(|| box map_identity::MapIdentity);\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n+    store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n@@ -1175,6 +1180,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n+        LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n         LintId::of(&trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&types::CAST_LOSSLESS),\n@@ -1231,6 +1237,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n+        LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n         LintId::of(&doc::NEEDLESS_DOCTEST_MAIN),\n         LintId::of(&double_comparison::DOUBLE_COMPARISONS),\n@@ -1293,6 +1300,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEEDLESS_COLLECT),\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::NEVER_LOOP),\n+        LintId::of(&loops::SAME_ITEM_PUSH),\n         LintId::of(&loops::WHILE_IMMUTABLE_CONDITION),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n@@ -1369,6 +1377,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&mut_key::MUTABLE_KEY_TYPE),\n         LintId::of(&mut_reference::UNNECESSARY_MUT_PASSED),\n         LintId::of(&mutex_atomic::MUTEX_ATOMIC),\n+        LintId::of(&needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n@@ -1409,6 +1418,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n         LintId::of(&single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n+        LintId::of(&stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n         LintId::of(&strings::STRING_LIT_AS_BYTES),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n         LintId::of(&suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n@@ -1495,6 +1505,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EMPTY_LOOP),\n         LintId::of(&loops::FOR_KV_MAP),\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n+        LintId::of(&loops::SAME_ITEM_PUSH),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n@@ -1600,6 +1611,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&misc::SHORT_CIRCUIT_STATEMENT),\n         LintId::of(&misc_early::UNNEEDED_WILDCARD_PATTERN),\n         LintId::of(&misc_early::ZERO_PREFIXED_LITERAL),\n+        LintId::of(&needless_arbitrary_self_type::NEEDLESS_ARBITRARY_SELF_TYPE),\n         LintId::of(&needless_bool::BOOL_COMPARISON),\n         LintId::of(&needless_bool::NEEDLESS_BOOL),\n         LintId::of(&needless_borrowed_ref::NEEDLESS_BORROWED_REFERENCE),\n@@ -1651,6 +1663,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n+        LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&drop_bounds::DROP_BOUNDS),\n         LintId::of(&drop_forget_ref::DROP_COPY),\n         LintId::of(&drop_forget_ref::DROP_REF),\n@@ -1726,6 +1739,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&mutex_atomic::MUTEX_ATOMIC),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n         LintId::of(&slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n+        LintId::of(&stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n         LintId::of(&types::BOX_VEC),\n         LintId::of(&types::REDUNDANT_ALLOCATION),\n         LintId::of(&vec::USELESS_VEC),"}, {"sha": "4df6827d77f94027551ba7663b1cace0af537c88", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -13,9 +13,8 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Symbol};\n \n-use crate::reexport::Name;\n use crate::utils::{in_macro, last_path_segment, span_lint, trait_ref_of_method};\n \n declare_clippy_lint! {\n@@ -113,7 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n enum RefLt {\n     Unnamed,\n     Static,\n-    Named(Name),\n+    Named(Symbol),\n }\n \n fn check_fn_inner<'tcx>(\n@@ -456,7 +455,7 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n }\n \n struct LifetimeChecker {\n-    map: FxHashMap<Name, Span>,\n+    map: FxHashMap<Symbol, Span>,\n }\n \n impl<'tcx> Visitor<'tcx> for LifetimeChecker {"}, {"sha": "8352a8a3d2c69573c3956bbf7bbb93f77318a4f7", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 326, "deletions": 25, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,14 +1,14 @@\n use crate::consts::constant;\n-use crate::reexport::Name;\n use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    is_integer_const, is_no_std_crate, is_refutable, last_path_segment, match_trait_method, match_type, match_var,\n-    multispan_sugg, snippet, snippet_opt, snippet_with_applicability, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n+    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n+    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_opt, snippet_with_applicability,\n+    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n+    SpanlessEq,\n };\n-use crate::utils::{is_type_diagnostic_item, qpath_res, sugg};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -17,7 +17,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     def_id, BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand,\n-    LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+    Local, LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -27,7 +27,7 @@ use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::iter::{once, Iterator};\n use std::mem;\n@@ -420,6 +420,39 @@ declare_clippy_lint! {\n     \"variables used within while expression are not mutated in the body\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks whether a for loop is being used to push a constant\n+    /// value into a Vec.\n+    ///\n+    /// **Why is this bad?** This kind of operation can be expressed more succinctly with\n+    /// `vec![item;SIZE]` or `vec.resize(NEW_SIZE, item)` and using these alternatives may also\n+    /// have better performance.\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = Vec::new();\n+    /// for _ in 0..20 {\n+    ///    vec.push(item1);\n+    /// }\n+    /// for _ in 0..30 {\n+    ///     vec.push(item2);\n+    /// }\n+    /// ```\n+    /// could be written as\n+    /// ```rust\n+    /// let item1 = 2;\n+    /// let item2 = 3;\n+    /// let mut vec: Vec<u8> = vec![item1; 20];\n+    /// vec.resize(20 + 30, item2);\n+    /// ```\n+    pub SAME_ITEM_PUSH,\n+    style,\n+    \"the same item is pushed inside of a for loop\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     NEEDLESS_RANGE_LOOP,\n@@ -436,6 +469,7 @@ declare_lint_pass!(Loops => [\n     NEVER_LOOP,\n     MUT_RANGE_BOUND,\n     WHILE_IMMUTABLE_CONDITION,\n+    SAME_ITEM_PUSH,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -741,6 +775,7 @@ fn check_for_loop<'tcx>(\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n+    detect_same_item_push(cx, pat, arg, body, expr);\n }\n \n fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n@@ -1017,6 +1052,117 @@ fn detect_manual_memcpy<'tcx>(\n     }\n }\n \n+// Scans the body of the for loop and determines whether lint should be given\n+struct SameItemPushVisitor<'a, 'tcx> {\n+    should_lint: bool,\n+    // this field holds the last vec push operation visited, which should be the only push seen\n+    vec_push: Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SameItemPushVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        match &expr.kind {\n+            // Non-determinism may occur ... don't give a lint\n+            ExprKind::Loop(_, _, _) | ExprKind::Match(_, _, _) => self.should_lint = false,\n+            ExprKind::Block(block, _) => self.visit_block(block),\n+            _ => {},\n+        }\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+        for stmt in b.stmts.iter() {\n+            self.visit_stmt(stmt);\n+        }\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx Stmt<'_>) {\n+        let vec_push_option = get_vec_push(self.cx, s);\n+        if vec_push_option.is_none() {\n+            // Current statement is not a push so visit inside\n+            match &s.kind {\n+                StmtKind::Expr(expr) | StmtKind::Semi(expr) => self.visit_expr(&expr),\n+                _ => {},\n+            }\n+        } else {\n+            // Current statement is a push ...check whether another\n+            // push had been previously done\n+            if self.vec_push.is_none() {\n+                self.vec_push = vec_push_option;\n+            } else {\n+                // There are multiple pushes ... don't lint\n+                self.should_lint = false;\n+            }\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+// Given some statement, determine if that statement is a push on a Vec. If it is, return\n+// the Vec being pushed into and the item being pushed\n+fn get_vec_push<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if_chain! {\n+            // Extract method being called\n+            if let StmtKind::Semi(semi_stmt) = &stmt.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = &semi_stmt.kind;\n+            // Figure out the parameters for the method call\n+            if let Some(self_expr) = args.get(0);\n+            if let Some(pushed_item) = args.get(1);\n+            // Check that the method being called is push() on a Vec\n+            if match_type(cx, cx.typeck_results().expr_ty(self_expr), &paths::VEC);\n+            if path.ident.name.as_str() == \"push\";\n+            then {\n+                return Some((self_expr, pushed_item))\n+            }\n+    }\n+    None\n+}\n+\n+/// Detects for loop pushing the same item into a Vec\n+fn detect_same_item_push<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    _: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    _: &'tcx Expr<'_>,\n+) {\n+    // Determine whether it is safe to lint the body\n+    let mut same_item_push_visitor = SameItemPushVisitor {\n+        should_lint: true,\n+        vec_push: None,\n+        cx,\n+    };\n+    walk_expr(&mut same_item_push_visitor, body);\n+    if same_item_push_visitor.should_lint {\n+        if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n+            // Make sure that the push does not involve possibly mutating values\n+            if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n+                if let PatKind::Wild = pat.kind {\n+                    let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n+                    let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        SAME_ITEM_PUSH,\n+                        vec.span,\n+                        \"it looks like the same item is being pushed into this Vec\",\n+                        None,\n+                        &format!(\n+                            \"try using vec![{};SIZE] or {}.resize(NEW_SIZE, {})\",\n+                            item_str, vec_str, item_str\n+                        ),\n+                    )\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Checks for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n #[allow(clippy::too_many_lines)]\n@@ -1184,7 +1330,7 @@ fn check_for_loop_range<'tcx>(\n     }\n }\n \n-fn is_len_call(expr: &Expr<'_>, var: Name) -> bool {\n+fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n         if len_args.len() == 1;\n@@ -1640,15 +1786,15 @@ struct VarVisitor<'a, 'tcx> {\n     /// var name to look for as index\n     var: HirId,\n     /// indexed variables that are used mutably\n-    indexed_mut: FxHashSet<Name>,\n+    indexed_mut: FxHashSet<Symbol>,\n     /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n-    indexed_indirectly: FxHashMap<Name, Option<region::Scope>>,\n+    indexed_indirectly: FxHashMap<Symbol, Option<region::Scope>>,\n     /// subset of `indexed` of vars that are indexed directly: `v[i]`\n     /// this will not contain cases like `v[calc_index(i)]` or `v[(i + 4) % N]`\n-    indexed_directly: FxHashMap<Name, (Option<region::Scope>, Ty<'tcx>)>,\n+    indexed_directly: FxHashMap<Symbol, (Option<region::Scope>, Ty<'tcx>)>,\n     /// Any names that are used outside an index operation.\n     /// Used to detect things like `&mut vec` used together with `vec[i]`\n-    referenced: FxHashSet<Name>,\n+    referenced: FxHashSet<Symbol>,\n     /// has the loop variable been used in expressions other than the index of\n     /// an index op?\n     nonindex: bool,\n@@ -2004,7 +2150,7 @@ struct InitializeVisitor<'a, 'tcx> {\n     end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n     var_id: HirId,\n     state: VarState,\n-    name: Option<Name>,\n+    name: Option<Symbol>,\n     depth: u32, // depth of conditional expressions\n     past_loop: bool,\n }\n@@ -2167,7 +2313,7 @@ use self::Nesting::{LookFurther, RuledOut, Unknown};\n \n struct LoopNestVisitor {\n     hir_id: HirId,\n-    iterator: Name,\n+    iterator: Symbol,\n     nesting: Nesting,\n }\n \n@@ -2218,7 +2364,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-fn path_name(e: &Expr<'_>) -> Option<Name> {\n+fn path_name(e: &Expr<'_>) -> Option<Symbol> {\n     if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n@@ -2358,6 +2504,10 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    check_needless_collect_direct_usage(expr, cx);\n+    check_needless_collect_indirect_usage(expr, cx);\n+}\n+fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n         if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n@@ -2371,7 +2521,7 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n                 match_type(cx, ty, &paths::BTREEMAP) ||\n                 is_type_diagnostic_item(cx, ty, sym!(hashmap_type)) {\n                 if method.ident.name == sym!(len) {\n-                    let span = shorten_span(expr, sym!(collect));\n+                    let span = shorten_needless_collect_span(expr);\n                     span_lint_and_sugg(\n                         cx,\n                         NEEDLESS_COLLECT,\n@@ -2383,20 +2533,20 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n                     );\n                 }\n                 if method.ident.name == sym!(is_empty) {\n-                    let span = shorten_span(expr, sym!(iter));\n+                    let span = shorten_needless_collect_span(expr);\n                     span_lint_and_sugg(\n                         cx,\n                         NEEDLESS_COLLECT,\n                         span,\n                         NEEDLESS_COLLECT_MSG,\n                         \"replace with\",\n-                        \"get(0).is_none()\".to_string(),\n+                        \"next().is_none()\".to_string(),\n                         Applicability::MachineApplicable,\n                     );\n                 }\n                 if method.ident.name == sym!(contains) {\n                     let contains_arg = snippet(cx, args[1].span, \"??\");\n-                    let span = shorten_span(expr, sym!(collect));\n+                    let span = shorten_needless_collect_span(expr);\n                     span_lint_and_then(\n                         cx,\n                         NEEDLESS_COLLECT,\n@@ -2425,13 +2575,164 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     }\n }\n \n-fn shorten_span(expr: &Expr<'_>, target_fn_name: Symbol) -> Span {\n-    let mut current_expr = expr;\n-    while let ExprKind::MethodCall(ref path, ref span, ref args, _) = current_expr.kind {\n-        if path.ident.name == target_fn_name {\n+fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n+        for ref stmt in block.stmts {\n+            if_chain! {\n+                if let StmtKind::Local(\n+                    Local { pat: Pat { kind: PatKind::Binding(_, _, ident, .. ), .. },\n+                    init: Some(ref init_expr), .. }\n+                ) = stmt.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n+                if let Some(ref generic_args) = method_name.args;\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    match_type(cx, ty, &paths::LINKED_LIST);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if iter_calls.len() == 1;\n+                then {\n+                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    let iter_call = &iter_calls[0];\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        stmt.span.until(iter_call.span),\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            diag.multipart_suggestion(\n+                                iter_call.get_suggestion_text(),\n+                                vec![\n+                                    (stmt.span, String::new()),\n+                                    (iter_call.span, iter_replacement)\n+                                ],\n+                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                            ).emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct IterFunction {\n+    func: IterFunctionKind,\n+    span: Span,\n+}\n+impl IterFunction {\n+    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => String::new(),\n+            IterFunctionKind::Len => String::from(\".count()\"),\n+            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n+            IterFunctionKind::Contains(span) => format!(\".any(|x| x == {})\", snippet(cx, *span, \"..\")),\n+        }\n+    }\n+    fn get_suggestion_text(&self) -> &'static str {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => {\n+                \"Use the original Iterator instead of collecting it and then producing a new one\"\n+            },\n+            IterFunctionKind::Len => {\n+                \"Take the original Iterator's count instead of collecting it and finding the length\"\n+            },\n+            IterFunctionKind::IsEmpty => {\n+                \"Check if the original Iterator has anything instead of collecting it and seeing if it's empty\"\n+            },\n+            IterFunctionKind::Contains(_) => {\n+                \"Check if the original Iterator contains an element instead of collecting then checking\"\n+            },\n+        }\n+    }\n+}\n+enum IterFunctionKind {\n+    IntoIter,\n+    Len,\n+    IsEmpty,\n+    Contains(Span),\n+}\n+\n+struct IterFunctionVisitor {\n+    uses: Vec<IterFunction>,\n+    seen_other: bool,\n+    target: Ident,\n+}\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        // Check function calls on our collection\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                let len = sym!(len);\n+                let is_empty = sym!(is_empty);\n+                let contains = sym!(contains);\n+                match method_name.ident.name {\n+                    sym::into_iter => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n+                    ),\n+                    name if name == len => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n+                    ),\n+                    name if name == is_empty => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n+                    ),\n+                    name if name == contains => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n+                    ),\n+                    _ => self.seen_other = true,\n+                }\n+                return\n+            }\n+        }\n+        // Check if the collection is used for anything else\n+        if_chain! {\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                self.seen_other = true;\n+            } else {\n+                walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Detect the occurences of calls to `iter` or `into_iter` for the\n+/// given identifier\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+    let mut visitor = IterFunctionVisitor {\n+        uses: Vec::new(),\n+        target: identifier,\n+        seen_other: false,\n+    };\n+    visitor.visit_block(block);\n+    if visitor.seen_other {\n+        None\n+    } else {\n+        Some(visitor.uses)\n+    }\n+}\n+\n+fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n+    if_chain! {\n+        if let ExprKind::MethodCall(.., args, _) = &expr.kind;\n+        if let ExprKind::MethodCall(_, span, ..) = &args[0].kind;\n+        then {\n             return expr.span.with_lo(span.lo());\n         }\n-        current_expr = &args[0];\n     }\n-    unreachable!()\n+    unreachable!();\n }"}, {"sha": "864d1ea87f57572d45fa9e8f7dfcc5063fd5b1d8", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -4,8 +4,8 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericBound, HirId, IsAsync,\n-    ItemKind, TraitRef, Ty, TyKind, TypeBindingKind,\n+    AsyncGeneratorKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, GeneratorKind, GenericArg, GenericBound, HirId,\n+    IsAsync, ItemKind, LifetimeName, TraitRef, Ty, TyKind, TypeBindingKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -27,8 +27,6 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// use std::future::Future;\n-    ///\n     /// async fn foo() -> i32 { 42 }\n     /// ```\n     pub MANUAL_ASYNC_FN,\n@@ -53,8 +51,9 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n             if let IsAsync::NotAsync = header.asyncness;\n             // Check that this function returns `impl Future`\n             if let FnRetTy::Return(ret_ty) = decl.output;\n-            if let Some(trait_ref) = future_trait_ref(cx, ret_ty);\n+            if let Some((trait_ref, output_lifetimes)) = future_trait_ref(cx, ret_ty);\n             if let Some(output) = future_output_ty(trait_ref);\n+            if captures_all_lifetimes(decl.inputs, &output_lifetimes);\n             // Check that the body of the function consists of one async block\n             if let ExprKind::Block(block, _) = body.value.kind;\n             if block.stmts.is_empty();\n@@ -97,16 +96,35 @@ impl<'tcx> LateLintPass<'tcx> for ManualAsyncFn {\n     }\n }\n \n-fn future_trait_ref<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n+fn future_trait_ref<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: &'tcx Ty<'tcx>,\n+) -> Option<(&'tcx TraitRef<'tcx>, Vec<LifetimeName>)> {\n     if_chain! {\n-        if let TyKind::OpaqueDef(item_id, _) = ty.kind;\n+        if let TyKind::OpaqueDef(item_id, bounds) = ty.kind;\n         let item = cx.tcx.hir().item(item_id.id);\n         if let ItemKind::OpaqueTy(opaque) = &item.kind;\n-        if opaque.bounds.len() == 1;\n-        if let GenericBound::Trait(poly, _) = &opaque.bounds[0];\n-        if poly.trait_ref.trait_def_id() == cx.tcx.lang_items().future_trait();\n+        if let Some(trait_ref) = opaque.bounds.iter().find_map(|bound| {\n+            if let GenericBound::Trait(poly, _) = bound {\n+                Some(&poly.trait_ref)\n+            } else {\n+                None\n+            }\n+        });\n+        if trait_ref.trait_def_id() == cx.tcx.lang_items().future_trait();\n         then {\n-            return Some(&poly.trait_ref);\n+            let output_lifetimes = bounds\n+                .iter()\n+                .filter_map(|bound| {\n+                    if let GenericArg::Lifetime(lt) = bound {\n+                        Some(lt.name)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect();\n+\n+            return Some((trait_ref, output_lifetimes));\n         }\n     }\n \n@@ -129,6 +147,29 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n     None\n }\n \n+fn captures_all_lifetimes(inputs: &[Ty<'_>], output_lifetimes: &[LifetimeName]) -> bool {\n+    let input_lifetimes: Vec<LifetimeName> = inputs\n+        .iter()\n+        .filter_map(|ty| {\n+            if let TyKind::Rptr(lt, _) = ty.kind {\n+                Some(lt.name)\n+            } else {\n+                None\n+            }\n+        })\n+        .collect();\n+\n+    // The lint should trigger in one of these cases:\n+    // - There are no input lifetimes\n+    // - There's only one output lifetime bound using `+ '_`\n+    // - All input lifetimes are explicitly bound to the output\n+    input_lifetimes.is_empty()\n+        || (output_lifetimes.len() == 1 && matches!(output_lifetimes[0], LifetimeName::Underscore))\n+        || input_lifetimes\n+            .iter()\n+            .all(|in_lt| output_lifetimes.iter().any(|out_lt| in_lt == out_lt))\n+}\n+\n fn desugared_async_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n     if_chain! {\n         if let Some(block_expr) = block.expr;"}, {"sha": "570ae66d595ea0348b42175bc04c097a96259c96", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1052,8 +1052,7 @@ declare_clippy_lint! {\n     ///\n     /// **Why is this bad?** Readability.\n     ///\n-    /// **Known problems:** False positive in pattern guards. Will be resolved once\n-    /// non-lexical lifetimes are stable.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -1408,7 +1407,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"nth\", \"iter_mut\"] => lint_iter_nth(cx, expr, &arg_lists, true),\n             [\"nth\", ..] => lint_iter_nth_zero(cx, expr, arg_lists[0]),\n             [\"step_by\", ..] => lint_step_by(cx, expr, arg_lists[0]),\n-            [\"next\", \"skip\"] => lint_iter_skip_next(cx, expr),\n+            [\"next\", \"skip\"] => lint_iter_skip_next(cx, expr, arg_lists[1]),\n             [\"collect\", \"cloned\"] => lint_iter_cloned_collect(cx, expr, arg_lists[1]),\n             [\"as_ref\"] => lint_asref(cx, expr, \"as_ref\", arg_lists[0]),\n             [\"as_mut\"] => lint_asref(cx, expr, \"as_mut\", arg_lists[0]),\n@@ -2433,17 +2432,21 @@ fn lint_get_unwrap<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, get_args:\n     );\n }\n \n-fn lint_iter_skip_next(cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n+fn lint_iter_skip_next(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[hir::Expr<'_>]) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        span_lint_and_help(\n-            cx,\n-            ITER_SKIP_NEXT,\n-            expr.span,\n-            \"called `skip(x).next()` on an iterator\",\n-            None,\n-            \"this is more succinctly expressed by calling `nth(x)`\",\n-        );\n+        if let [caller, n] = skip_args {\n+            let hint = format!(\".nth({})\", snippet(cx, n.span, \"..\"));\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_SKIP_NEXT,\n+                expr.span.trim_start(caller.span).unwrap(),\n+                \"called `skip(x).next()` on an iterator\",\n+                \"use `nth` instead\",\n+                hint,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n     }\n }\n \n@@ -2565,34 +2568,48 @@ fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Ex\n fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `map(..).flatten()` on an `Iterator`. \\\n-                    This is more succinctly expressed by calling `.flat_map(..)`\";\n-        let self_snippet = snippet(cx, map_args[0].span, \"..\");\n+        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n+        let is_map_to_option = match map_closure_ty.kind {\n+            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n+                let map_closure_sig = match map_closure_ty.kind {\n+                    ty::Closure(_, substs) => substs.as_closure().sig(),\n+                    _ => map_closure_ty.fn_sig(cx.tcx),\n+                };\n+                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(&map_closure_sig.output());\n+                is_type_diagnostic_item(cx, map_closure_return_ty, sym!(option_type))\n+            },\n+            _ => false,\n+        };\n+\n+        let method_to_use = if is_map_to_option {\n+            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n+            \"filter_map\"\n+        } else {\n+            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n+            \"flat_map\"\n+        };\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let hint = format!(\"{0}.flat_map({1})\", self_snippet, func_snippet);\n+        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span,\n-            msg,\n-            \"try using `flat_map` instead\",\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Iterator`\",\n+            &format!(\"try using `{}` instead\", method_to_use),\n             hint,\n             Applicability::MachineApplicable,\n         );\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n     if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n-        let msg = \"called `map(..).flatten()` on an `Option`. \\\n-                    This is more succinctly expressed by calling `.and_then(..)`\";\n-        let self_snippet = snippet(cx, map_args[0].span, \"..\");\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let hint = format!(\"{0}.and_then({1})\", self_snippet, func_snippet);\n+        let hint = format!(\".and_then({})\", func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span,\n-            msg,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Option`\",\n             \"try using `and_then` instead\",\n             hint,\n             Applicability::MachineApplicable,"}, {"sha": "004dd50a31be8716b7af5bc1727051261b2f2b84", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,5 +1,6 @@\n use crate::consts::{constant_simple, Constant};\n-use crate::utils::{match_def_path, paths, span_lint};\n+use crate::utils::{match_def_path, match_trait_method, paths, span_lint};\n+use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -18,6 +19,10 @@ declare_clippy_lint! {\n     /// ```ignore\n     /// min(0, max(100, x))\n     /// ```\n+    /// or\n+    /// ```ignore\n+    /// x.max(100).min(0)\n+    /// ```\n     /// It will always be equal to `0`. Probably the author meant to clamp the value\n     /// between 0 and 100, but has erroneously swapped `min` and `max`.\n     pub MIN_MAX,\n@@ -60,25 +65,43 @@ enum MinMax {\n }\n \n fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n-    if let ExprKind::Call(ref path, ref args) = expr.kind {\n-        if let ExprKind::Path(ref qpath) = path.kind {\n-            cx.typeck_results()\n-                .qpath_res(qpath, path.hir_id)\n-                .opt_def_id()\n-                .and_then(|def_id| {\n-                    if match_def_path(cx, def_id, &paths::CMP_MIN) {\n-                        fetch_const(cx, args, MinMax::Min)\n-                    } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n+    match expr.kind {\n+        ExprKind::Call(ref path, ref args) => {\n+            if let ExprKind::Path(ref qpath) = path.kind {\n+                cx.typeck_results()\n+                    .qpath_res(qpath, path.hir_id)\n+                    .opt_def_id()\n+                    .and_then(|def_id| {\n+                        if match_def_path(cx, def_id, &paths::CMP_MIN) {\n+                            fetch_const(cx, args, MinMax::Min)\n+                        } else if match_def_path(cx, def_id, &paths::CMP_MAX) {\n+                            fetch_const(cx, args, MinMax::Max)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+            } else {\n+                None\n+            }\n+        },\n+        ExprKind::MethodCall(ref path, _, ref args, _) => {\n+            if_chain! {\n+                if let [obj, _] = args;\n+                if cx.typeck_results().expr_ty(obj).is_floating_point() || match_trait_method(cx, expr, &paths::ORD);\n+                then {\n+                    if path.ident.as_str() == sym!(max).as_str() {\n                         fetch_const(cx, args, MinMax::Max)\n+                    } else if path.ident.as_str() == sym!(min).as_str() {\n+                        fetch_const(cx, args, MinMax::Min)\n                     } else {\n                         None\n                     }\n-                })\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        _ => None,\n     }\n }\n "}, {"sha": "02789735c17a313b1aa152aa01eadc3df3bf1692", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -271,7 +271,7 @@ impl EarlyLintPass for MiscEarlyLints {\n                         cx,\n                         BUILTIN_TYPE_SHADOW,\n                         param.ident.span,\n-                        &format!(\"This generic shadows the built-in type `{}`\", name),\n+                        &format!(\"this generic shadows the built-in type `{}`\", name),\n                     );\n                 }\n             }\n@@ -298,9 +298,9 @@ impl EarlyLintPass for MiscEarlyLints {\n                     cx,\n                     UNNEEDED_FIELD_PATTERN,\n                     pat.span,\n-                    \"All the struct fields are matched to a wildcard pattern, consider using `..`.\",\n+                    \"all the struct fields are matched to a wildcard pattern, consider using `..`\",\n                     None,\n-                    &format!(\"Try with `{} {{ .. }}` instead\", type_name),\n+                    &format!(\"try with `{} {{ .. }}` instead\", type_name),\n                 );\n                 return;\n             }\n@@ -313,7 +313,7 @@ impl EarlyLintPass for MiscEarlyLints {\n                                 cx,\n                                 UNNEEDED_FIELD_PATTERN,\n                                 field.span,\n-                                \"You matched a field with a wildcard pattern. Consider using `..` instead\",\n+                                \"you matched a field with a wildcard pattern, consider using `..` instead\",\n                             );\n                         } else {\n                             let mut normal = vec![];\n@@ -333,10 +333,10 @@ impl EarlyLintPass for MiscEarlyLints {\n                                 cx,\n                                 UNNEEDED_FIELD_PATTERN,\n                                 field.span,\n-                                \"You matched a field with a wildcard pattern. Consider using `..` \\\n+                                \"you matched a field with a wildcard pattern, consider using `..` \\\n                                  instead\",\n                                 None,\n-                                &format!(\"Try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n+                                &format!(\"try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n                             );\n                         }\n                     }"}, {"sha": "38bdd0f7ed23bdd49dda3fd8443a91be55ea81c7", "filename": "clippy_lints/src/needless_arbitrary_self_type.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_arbitrary_self_type.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,118 @@\n+use crate::utils::span_lint_and_sugg;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{BindingMode, Lifetime, Mutability, Param, PatKind, Path, TyKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::kw;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** The lint checks for `self` in fn parameters that\n+    /// specify the `Self`-type explicitly\n+    /// **Why is this bad?** Increases the amount and decreases the readability of code\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// enum ValType {\n+    ///     I32,\n+    ///     I64,\n+    ///     F32,\n+    ///     F64,\n+    /// }\n+    ///\n+    /// impl ValType {\n+    ///     pub fn bytes(self: Self) -> usize {\n+    ///         match self {\n+    ///             Self::I32 | Self::F32 => 4,\n+    ///             Self::I64 | Self::F64 => 8,\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Could be rewritten as\n+    ///\n+    /// ```rust\n+    /// enum ValType {\n+    ///     I32,\n+    ///     I64,\n+    ///     F32,\n+    ///     F64,\n+    /// }\n+    ///\n+    /// impl ValType {\n+    ///     pub fn bytes(self) -> usize {\n+    ///         match self {\n+    ///             Self::I32 | Self::F32 => 4,\n+    ///             Self::I64 | Self::F64 => 8,\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    pub NEEDLESS_ARBITRARY_SELF_TYPE,\n+    complexity,\n+    \"type of `self` parameter is already by default `Self`\"\n+}\n+\n+declare_lint_pass!(NeedlessArbitrarySelfType => [NEEDLESS_ARBITRARY_SELF_TYPE]);\n+\n+enum Mode {\n+    Ref(Option<Lifetime>),\n+    Value,\n+}\n+\n+fn check_param_inner(cx: &EarlyContext<'_>, path: &Path, span: Span, binding_mode: &Mode, mutbl: Mutability) {\n+    if_chain! {\n+        if let [segment] = &path.segments[..];\n+        if segment.ident.name == kw::SelfUpper;\n+        then {\n+            let self_param = match (binding_mode, mutbl) {\n+                (Mode::Ref(None), Mutability::Mut) => \"&mut self\".to_string(),\n+                (Mode::Ref(Some(lifetime)), Mutability::Mut) => format!(\"&{} mut self\", &lifetime.ident.name),\n+                (Mode::Ref(None), Mutability::Not) => \"&self\".to_string(),\n+                (Mode::Ref(Some(lifetime)), Mutability::Not) => format!(\"&{} self\", &lifetime.ident.name),\n+                (Mode::Value, Mutability::Mut) => \"mut self\".to_string(),\n+                (Mode::Value, Mutability::Not) => \"self\".to_string(),\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                NEEDLESS_ARBITRARY_SELF_TYPE,\n+                span,\n+                \"the type of the `self` parameter does not need to be arbitrary\",\n+                \"consider to change this parameter to\",\n+                self_param,\n+                Applicability::MachineApplicable,\n+            )\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for NeedlessArbitrarySelfType {\n+    fn check_param(&mut self, cx: &EarlyContext<'_>, p: &Param) {\n+        if !p.is_self() {\n+            return;\n+        }\n+\n+        match &p.ty.kind {\n+            TyKind::Path(None, path) => {\n+                if let PatKind::Ident(BindingMode::ByValue(mutbl), _, _) = p.pat.kind {\n+                    check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Value, mutbl)\n+                }\n+            },\n+            TyKind::Rptr(lifetime, mut_ty) => {\n+                if_chain! {\n+                if let TyKind::Path(None, path) = &mut_ty.ty.kind;\n+                if let PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, _) = p.pat.kind;\n+                    then {\n+                        check_param_inner(cx, path, p.span.to(p.ty.span), &Mode::Ref(*lifetime), mut_ty.mutbl)\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}, {"sha": "dc5aa6691396b14220376178adcac0afe5a374af", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -243,7 +243,7 @@ fn check_comparison<'a, 'tcx>(\n                         cx,\n                         BOOL_COMPARISON,\n                         e.span,\n-                        \"This comparison might be written more concisely\",\n+                        \"this comparison might be written more concisely\",\n                         \"try simplifying it as shown\",\n                         format!(\n                             \"{} != {}\","}, {"sha": "047a78b087841b7224c83536bfbb4eaa488f7908", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -40,9 +40,8 @@ declare_clippy_lint! {\n     ///     assert_eq!(v.len(), 42);\n     /// }\n     /// ```\n-    ///\n+    /// should be\n     /// ```rust\n-    /// // should be\n     /// fn foo(v: &[i32]) {\n     ///     assert_eq!(v.len(), 42);\n     /// }\n@@ -159,26 +158,19 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 }\n             }\n \n+            //\n             // * Exclude a type that is specifically bounded by `Borrow`.\n             // * Exclude a type whose reference also fulfills its bound. (e.g., `std::convert::AsRef`,\n             //   `serde::Serialize`)\n             let (implements_borrow_trait, all_borrowable_trait) = {\n-                let preds = preds\n-                    .iter()\n-                    .filter(|t| t.self_ty() == ty)\n-                    .collect::<Vec<_>>();\n+                let preds = preds.iter().filter(|t| t.self_ty() == ty).collect::<Vec<_>>();\n \n                 (\n                     preds.iter().any(|t| t.def_id() == borrow_trait),\n                     !preds.is_empty() && {\n                         let ty_empty_region = cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_root_empty, ty);\n                         preds.iter().all(|t| {\n-                            let ty_params = t\n-                                .trait_ref\n-                                .substs\n-                                .iter()\n-                                .skip(1)\n-                                .collect::<Vec<_>>();\n+                            let ty_params = t.trait_ref.substs.iter().skip(1).collect::<Vec<_>>();\n                             implements_trait(cx, ty_empty_region, t.def_id(), &ty_params)\n                         })\n                     },"}, {"sha": "4fb899125e8ad9f0612149d10b97ecf360bc778c", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -79,10 +79,10 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n                         cx,\n                         NEG_CMP_OP_ON_PARTIAL_ORD,\n                         expr.span,\n-                        \"The use of negated comparison operators on partially ordered \\\n-                        types produces code that is hard to read and refactor. Please \\\n+                        \"the use of negated comparison operators on partially ordered \\\n+                        types produces code that is hard to read and refactor, please \\\n                         consider using the `partial_cmp` method instead, to make it \\\n-                        clear that the two values could be incomparable.\"\n+                        clear that the two values could be incomparable\"\n                     )\n                 }\n             }"}, {"sha": "aa550510867f9af5df50165cdf9ef18845ca9a4f", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -47,7 +47,7 @@ fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n         if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.typeck_results().expr_ty_opt(lit));\n         if cx.typeck_results().expr_ty(exp).is_integral();\n         then {\n-            span_lint(cx, NEG_MULTIPLY, span, \"Negation by multiplying with `-1`\");\n+            span_lint(cx, NEG_MULTIPLY, span, \"negation by multiplying with `-1`\");\n         }\n     }\n }"}, {"sha": "3c041bac234a589f8034f1dd5ede89db0b6c1c8b", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -42,13 +42,13 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n                 if let BinOpKind::Lt = op.node {\n                     if let BinOpKind::Add = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                            \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                            \"you are trying to use classic C overflow conditions that will fail in Rust\");\n                     }\n                 }\n                 if let BinOpKind::Gt = op.node {\n                     if let BinOpKind::Sub = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                            \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                            \"you are trying to use classic C underflow conditions that will fail in Rust\");\n                     }\n                 }\n             }\n@@ -67,13 +67,13 @@ impl<'tcx> LateLintPass<'tcx> for OverflowCheckConditional {\n                 if let BinOpKind::Gt = op.node {\n                     if let BinOpKind::Add = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                            \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                            \"you are trying to use classic C overflow conditions that will fail in Rust\");\n                     }\n                 }\n                 if let BinOpKind::Lt = op.node {\n                     if let BinOpKind::Sub = op2.node {\n                         span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                            \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                            \"you are trying to use classic C underflow conditions that will fail in Rust\");\n                     }\n                 }\n             }"}, {"sha": "b8583402928b424013200de3d1680352c3f34b12", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> LateLintPass<'tcx> for PathBufPushOverwrite {\n                     cx,\n                     PATH_BUF_PUSH_OVERWRITE,\n                     lit.span,\n-                    \"Calling `push` with '/' or '\\\\' (file system root) will overwrite the previous path definition\",\n+                    \"calling `push` with '/' or '\\\\' (file system root) will overwrite the previous path definition\",\n                     \"try\",\n                     format!(\"\\\"{}\\\"\", pushed_path_lit.trim_start_matches(|c| c == '/' || c == '\\\\')),\n                     Applicability::MachineApplicable,"}, {"sha": "460d631fab0fdc62ac9207e3112c9bfb65383937", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -145,7 +145,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     cx,\n                     CMP_NULL,\n                     expr.span,\n-                    \"Comparing with null is better expressed by the `.is_null()` method\",\n+                    \"comparing with null is better expressed by the `.is_null()` method\",\n                 );\n             }\n         }"}, {"sha": "f88075798ca7515d61b6f478933956c8f3804add", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -160,7 +160,7 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n                          span_lint(cx,\n                                    RANGE_ZIP_WITH_LEN,\n                                    expr.span,\n-                                   &format!(\"It is more idiomatic to use `{}.iter().enumerate()`\",\n+                                   &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n                                             snippet(cx, iter_args[0].span, \"_\")));\n                     }\n                 }"}, {"sha": "7bbcc67aa2ddf13db6eb565df72047355c2f1666", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -86,13 +86,13 @@ impl EarlyLintPass for RedundantStaticLifetimes {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n         if !item.span.from_expansion() {\n             if let ItemKind::Const(_, ref var_type, _) = item.kind {\n-                self.visit_type(var_type, cx, \"Constants have by default a `'static` lifetime\");\n+                self.visit_type(var_type, cx, \"constants have by default a `'static` lifetime\");\n                 // Don't check associated consts because `'static` cannot be elided on those (issue\n                 // #2438)\n             }\n \n             if let ItemKind::Static(ref var_type, _, _) = item.kind {\n-                self.visit_type(var_type, cx, \"Statics have by default a `'static` lifetime\");\n+                self.visit_type(var_type, cx, \"statics have by default a `'static` lifetime\");\n             }\n         }\n     }"}, {"sha": "3fda00403c611890e9053cb60bb7b9cfcdcba720", "filename": "clippy_lints/src/reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freference.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -92,7 +92,7 @@ impl EarlyLintPass for RefInDeref {\n                     cx,\n                     REF_IN_DEREF,\n                     object.span,\n-                    \"Creating a reference that is immediately dereferenced.\",\n+                    \"creating a reference that is immediately dereferenced\",\n                     \"try this\",\n                     snippet_with_applicability(cx, inner.span, \"_\", &mut applicability).to_string(),\n                     applicability,"}, {"sha": "2610157763a8b97dcdb9a818c1ee1cfb7417190f", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,3 @@\n-use crate::reexport::Name;\n use crate::utils::{contains_name, higher, iter_input_pats, snippet, span_lint_and_then};\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n@@ -10,6 +9,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for bindings that shadow other bindings already in\n@@ -123,7 +123,7 @@ fn check_fn<'tcx>(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>, body: &'tcx Bo\n     check_expr(cx, &body.value, &mut bindings);\n }\n \n-fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     let len = bindings.len();\n     for stmt in block.stmts {\n         match stmt.kind {\n@@ -138,7 +138,7 @@ fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &\n     bindings.truncate(len);\n }\n \n-fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     if in_external_macro(cx.sess(), local.span) {\n         return;\n     }\n@@ -173,7 +173,7 @@ fn check_pat<'tcx>(\n     pat: &'tcx Pat<'_>,\n     init: Option<&'tcx Expr<'_>>,\n     span: Span,\n-    bindings: &mut Vec<(Name, Span)>,\n+    bindings: &mut Vec<(Symbol, Span)>,\n ) {\n     // TODO: match more stuff / destructuring\n     match pat.kind {\n@@ -254,7 +254,7 @@ fn check_pat<'tcx>(\n \n fn lint_shadow<'tcx>(\n     cx: &LateContext<'tcx>,\n-    name: Name,\n+    name: Symbol,\n     span: Span,\n     pattern_span: Span,\n     init: Option<&'tcx Expr<'_>>,\n@@ -315,7 +315,7 @@ fn lint_shadow<'tcx>(\n     }\n }\n \n-fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     if in_external_macro(cx.sess(), expr.span) {\n         return;\n     }\n@@ -351,7 +351,7 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n     }\n }\n \n-fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     match ty.kind {\n         TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n         TyKind::Array(ref fty, ref anon_const) => {\n@@ -371,7 +371,7 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(\n     }\n }\n \n-fn is_self_shadow(name: Name, expr: &Expr<'_>) -> bool {\n+fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Box(ref inner) | ExprKind::AddrOf(_, _, ref inner) => is_self_shadow(name, inner),\n         ExprKind::Block(ref block, _) => {\n@@ -383,6 +383,6 @@ fn is_self_shadow(name: Name, expr: &Expr<'_>) -> bool {\n     }\n }\n \n-fn path_eq_name(name: Name, path: &Path<'_>) -> bool {\n+fn path_eq_name(name: Symbol, path: &Path<'_>) -> bool {\n     !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.as_str() == name.as_str()\n }"}, {"sha": "cd7056620a2e02c19744a17b42e0b129bb9bbc8a", "filename": "clippy_lints/src/stable_sort_primitive.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,130 @@\n+use crate::utils::{is_slice_of_primitives, span_lint_and_sugg, sugg::Sugg};\n+\n+use if_chain::if_chain;\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// When sorting primitive values (integers, bools, chars, as well\n+    /// as arrays, slices, and tuples of such items), it is better to\n+    /// use an unstable sort than a stable sort.\n+    ///\n+    /// **Why is this bad?**\n+    /// Using a stable sort consumes more memory and cpu cycles. Because\n+    /// values which compare equal are identical, preserving their\n+    /// relative order (the guarantee that a stable sort provides) means\n+    /// nothing, while the extra costs still apply.\n+    ///\n+    /// **Known problems:**\n+    /// None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut vec = vec![2, 1, 3];\n+    /// vec.sort_unstable();\n+    /// ```\n+    pub STABLE_SORT_PRIMITIVE,\n+    perf,\n+    \"use of sort() when sort_unstable() is equivalent\"\n+}\n+\n+declare_lint_pass!(StableSortPrimitive => [STABLE_SORT_PRIMITIVE]);\n+\n+/// The three \"kinds\" of sorts\n+enum SortingKind {\n+    Vanilla,\n+    /* The other kinds of lint are currently commented out because they\n+     * can map distinct values to equal ones. If the key function is\n+     * provably one-to-one, or if the Cmp function conserves equality,\n+     * then they could be linted on, but I don't know if we can check\n+     * for that. */\n+\n+    /* ByKey,\n+     * ByCmp, */\n+}\n+impl SortingKind {\n+    /// The name of the stable version of this kind of sort\n+    fn stable_name(&self) -> &str {\n+        match self {\n+            SortingKind::Vanilla => \"sort\",\n+            /* SortingKind::ByKey => \"sort_by_key\",\n+             * SortingKind::ByCmp => \"sort_by\", */\n+        }\n+    }\n+    /// The name of the unstable version of this kind of sort\n+    fn unstable_name(&self) -> &str {\n+        match self {\n+            SortingKind::Vanilla => \"sort_unstable\",\n+            /* SortingKind::ByKey => \"sort_unstable_by_key\",\n+             * SortingKind::ByCmp => \"sort_unstable_by\", */\n+        }\n+    }\n+    /// Takes the name of a function call and returns the kind of sort\n+    /// that corresponds to that function name (or None if it isn't)\n+    fn from_stable_name(name: &str) -> Option<SortingKind> {\n+        match name {\n+            \"sort\" => Some(SortingKind::Vanilla),\n+            // \"sort_by\" => Some(SortingKind::ByCmp),\n+            // \"sort_by_key\" => Some(SortingKind::ByKey),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+/// A detected instance of this lint\n+struct LintDetection {\n+    slice_name: String,\n+    method: SortingKind,\n+    method_args: String,\n+}\n+\n+fn detect_stable_sort_primitive(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintDetection> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n+        if let Some(slice) = &args.get(0);\n+        if let Some(method) = SortingKind::from_stable_name(&method_name.ident.name.as_str());\n+        if is_slice_of_primitives(cx, slice);\n+        then {\n+            let args_str = args.iter().skip(1).map(|arg| Sugg::hir(cx, arg, \"..\").to_string()).collect::<Vec<String>>().join(\", \");\n+            Some(LintDetection { slice_name: Sugg::hir(cx, slice, \"..\").to_string(), method, method_args: args_str })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl LateLintPass<'_> for StableSortPrimitive {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if let Some(detection) = detect_stable_sort_primitive(cx, expr) {\n+            span_lint_and_sugg(\n+                cx,\n+                STABLE_SORT_PRIMITIVE,\n+                expr.span,\n+                format!(\n+                    \"Use {} instead of {}\",\n+                    detection.method.unstable_name(),\n+                    detection.method.stable_name()\n+                )\n+                .as_str(),\n+                \"try\",\n+                format!(\n+                    \"{}.{}({})\",\n+                    detection.slice_name,\n+                    detection.method.unstable_name(),\n+                    detection.method_args\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "4e335a0222f2067c3fd33e05f9bed56c5fa91bff", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -64,26 +64,22 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n                 | hir::BinOpKind::Gt => return,\n                 _ => {},\n             }\n-            // Check if the binary expression is part of another bi/unary expression\n-            // or operator assignment as a child node\n-            let mut parent_expr = cx.tcx.hir().get_parent_node(expr.hir_id);\n-            while parent_expr != hir::CRATE_HIR_ID {\n-                if let hir::Node::Expr(e) = cx.tcx.hir().get(parent_expr) {\n-                    match e.kind {\n-                        hir::ExprKind::Binary(..)\n-                        | hir::ExprKind::Unary(hir::UnOp::UnNot | hir::UnOp::UnNeg, _)\n-                        | hir::ExprKind::AssignOp(..) => return,\n-                        _ => {},\n+\n+            // Check for more than one binary operation in the implemented function\n+            // Linting when multiple operations are involved can result in false positives\n+            if_chain! {\n+                let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n+                if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get(parent_fn);\n+                if let hir::ImplItemKind::Fn(_, body_id) = impl_item.kind;\n+                let body = cx.tcx.hir().body(body_id);\n+                let mut visitor = BinaryExprVisitor { nb_binops: 0 };\n+\n+                then {\n+                    walk_expr(&mut visitor, &body.value);\n+                    if visitor.nb_binops > 1 {\n+                        return;\n                     }\n                 }\n-                parent_expr = cx.tcx.hir().get_parent_node(parent_expr);\n-            }\n-            // as a parent node\n-            let mut visitor = BinaryExprVisitor { in_binary_expr: false };\n-            walk_expr(&mut visitor, expr);\n-\n-            if visitor.in_binary_expr {\n-                return;\n             }\n \n             if let Some(impl_trait) = check_binop(\n@@ -102,7 +98,7 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n                     cx,\n                     SUSPICIOUS_ARITHMETIC_IMPL,\n                     binop.span,\n-                    &format!(r#\"Suspicious use of binary operator in `{}` impl\"#, impl_trait),\n+                    &format!(\"suspicious use of binary operator in `{}` impl\", impl_trait),\n                 );\n             }\n \n@@ -139,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n                     cx,\n                     SUSPICIOUS_OP_ASSIGN_IMPL,\n                     binop.span,\n-                    &format!(r#\"Suspicious use of binary operator in `{}` impl\"#, impl_trait),\n+                    &format!(\"suspicious use of binary operator in `{}` impl\", impl_trait),\n                 );\n             }\n         }\n@@ -181,7 +177,7 @@ fn check_binop(\n }\n \n struct BinaryExprVisitor {\n-    in_binary_expr: bool,\n+    nb_binops: u32,\n }\n \n impl<'tcx> Visitor<'tcx> for BinaryExprVisitor {\n@@ -191,12 +187,13 @@ impl<'tcx> Visitor<'tcx> for BinaryExprVisitor {\n         match expr.kind {\n             hir::ExprKind::Binary(..)\n             | hir::ExprKind::Unary(hir::UnOp::UnNot | hir::UnOp::UnNeg, _)\n-            | hir::ExprKind::AssignOp(..) => self.in_binary_expr = true,\n+            | hir::ExprKind::AssignOp(..) => self.nb_binops += 1,\n             _ => {},\n         }\n \n         walk_expr(self, expr);\n     }\n+\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n     }"}, {"sha": "d4acf8df46d8a5323d64613c38de7ef7abbb8dd1", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -2,9 +2,10 @@ use crate::utils::{in_macro, snippet, snippet_with_applicability, span_lint_and_\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{GenericBound, Generics, WherePredicate};\n+use rustc_hir::{def::Res, GenericBound, Generics, ParamName, Path, QPath, TyKind, WherePredicate};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns about unnecessary type repetitions in trait bounds\n@@ -29,6 +30,35 @@ declare_clippy_lint! {\n     \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for cases where generics are being used and multiple\n+    /// syntax specifications for trait bounds are used simultaneously.\n+    ///\n+    /// **Why is this bad?** Duplicate bounds makes the code\n+    /// less readable than specifing them only once.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn func<T: Clone + Default>(arg: T) where T: Clone + Default {}\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// fn func<T: Clone + Default>(arg: T) {}\n+    /// ```\n+    /// or\n+    ///\n+    /// ```rust\n+    /// fn func<T>(arg: T) where T: Clone + Default {}\n+    /// ```\n+    pub TRAIT_DUPLICATION_IN_BOUNDS,\n+    pedantic,\n+    \"Check if the same trait bounds are specified twice during a function declaration\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TraitBounds {\n     max_trait_bounds: u64,\n@@ -41,10 +71,25 @@ impl TraitBounds {\n     }\n }\n \n-impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS]);\n+impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS, TRAIT_DUPLICATION_IN_BOUNDS]);\n \n impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     fn check_generics(&mut self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n+        self.check_type_repetition(cx, gen);\n+        check_trait_bound_duplication(cx, gen);\n+    }\n+}\n+\n+fn get_trait_res_span_from_bound(bound: &GenericBound<'_>) -> Option<(Res, Span)> {\n+    if let GenericBound::Trait(t, _) = bound {\n+        Some((t.trait_ref.path.res, t.span))\n+    } else {\n+        None\n+    }\n+}\n+\n+impl TraitBounds {\n+    fn check_type_repetition(self, cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         if in_macro(gen.span) {\n             return;\n         }\n@@ -101,3 +146,48 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n         }\n     }\n }\n+\n+fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n+    if in_macro(gen.span) || gen.params.is_empty() || gen.where_clause.predicates.is_empty() {\n+        return;\n+    }\n+\n+    let mut map = FxHashMap::default();\n+    for param in gen.params {\n+        if let ParamName::Plain(ref ident) = param.name {\n+            let res = param\n+                .bounds\n+                .iter()\n+                .filter_map(get_trait_res_span_from_bound)\n+                .collect::<Vec<_>>();\n+            map.insert(*ident, res);\n+        }\n+    }\n+\n+    for predicate in gen.where_clause.predicates {\n+        if_chain! {\n+            if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n+            if !in_macro(bound_predicate.span);\n+            if let TyKind::Path(ref path) = bound_predicate.bounded_ty.kind;\n+            if let QPath::Resolved(_, Path { ref segments, .. }) = path;\n+            if let Some(segment) = segments.first();\n+            if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n+            then {\n+                for (res_where, _) in bound_predicate.bounds.iter().filter_map(get_trait_res_span_from_bound) {\n+                    if let Some((_, span_direct)) = trait_resolutions_direct\n+                                                .iter()\n+                                                .find(|(res_direct, _)| *res_direct == res_where) {\n+                        span_lint_and_help(\n+                            cx,\n+                            TRAIT_DUPLICATION_IN_BOUNDS,\n+                            *span_direct,\n+                            \"this trait bound is already specified in the where clause\",\n+                            None,\n+                            \"consider removing this trait bound\",\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "7b5e92eb5ee1b896882bdf6b6195e0dbc1636113", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -61,12 +61,14 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     ///\n-    /// ```rust,ignore\n-    /// core::intrinsics::transmute::<*const [i32], *const [u16]>(p)\n+    /// ```rust\n+    /// # let p: *const [i32] = &[];\n+    /// unsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// p as *const [u16]\n+    /// # let p: *const [i32] = &[];\n+    /// p as *const [u16];\n     /// ```\n     pub TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n     complexity,\n@@ -704,14 +706,14 @@ fn can_be_expressed_as_pointer_cast<'tcx>(\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) -> bool {\n-    use CastKind::*;\n+    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n     matches!(\n         check_cast(cx, e, from_ty, to_ty),\n         Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n     )\n }\n \n-/// If a cast from from_ty to to_ty is valid, returns an Ok containing the kind of\n+/// If a cast from `from_ty` to `to_ty` is valid, returns an Ok containing the kind of\n /// the cast. In certain cases, including some invalid casts from array references\n /// to pointers, this may cause additional errors to be emitted and/or ICE error\n /// messages. This function will panic if that occurs."}, {"sha": "3bd73d9f21a98f98deea34846f8a18e1a10a92d9", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 88, "deletions": 24, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,10 +1,13 @@\n-use crate::utils::{match_qpath, paths, snippet, snippet_with_macro_callsite, span_lint_and_sugg};\n+use crate::utils::{\n+    is_type_diagnostic_item, match_def_path, match_qpath, paths, snippet, snippet_with_macro_callsite,\n+    span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -65,19 +68,39 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n             if let Some(ref err_arg) = err_args.get(0);\n             if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n             if match_qpath(err_fun_path, &paths::RESULT_ERR);\n-            if let Some(return_type) = find_err_return_type(cx, &expr.kind);\n-\n+            if let Some(return_ty) = find_return_type(cx, &expr.kind);\n             then {\n-                let err_type = cx.typeck_results().expr_ty(err_arg);\n+                let prefix;\n+                let suffix;\n+                let err_ty;\n+\n+                if let Some(ty) = result_error_type(cx, return_ty) {\n+                    prefix = \"Err(\";\n+                    suffix = \")\";\n+                    err_ty = ty;\n+                } else if let Some(ty) = poll_result_error_type(cx, return_ty) {\n+                    prefix = \"Poll::Ready(Err(\";\n+                    suffix = \"))\";\n+                    err_ty = ty;\n+                } else if let Some(ty) = poll_option_result_error_type(cx, return_ty) {\n+                    prefix = \"Poll::Ready(Some(Err(\";\n+                    suffix = \")))\";\n+                    err_ty = ty;\n+                } else {\n+                    return;\n+                };\n+\n+                let expr_err_ty = cx.typeck_results().expr_ty(err_arg);\n+\n                 let origin_snippet = if err_arg.span.from_expansion() {\n                     snippet_with_macro_callsite(cx, err_arg.span, \"_\")\n                 } else {\n                     snippet(cx, err_arg.span, \"_\")\n                 };\n-                let suggestion = if err_type == return_type {\n-                    format!(\"return Err({})\", origin_snippet)\n+                let suggestion = if err_ty == expr_err_ty {\n+                    format!(\"return {}{}{}\", prefix, origin_snippet, suffix)\n                 } else {\n-                    format!(\"return Err({}.into())\", origin_snippet)\n+                    format!(\"return {}{}.into(){}\", prefix, origin_snippet, suffix)\n                 };\n \n                 span_lint_and_sugg(\n@@ -94,27 +117,68 @@ impl<'tcx> LateLintPass<'tcx> for TryErr {\n     }\n }\n \n-// In order to determine whether to suggest `.into()` or not, we need to find the error type the\n-// function returns. To do that, we look for the From::from call (see tree above), and capture\n-// its output type.\n-fn find_err_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n+/// Finds function return type by examining return expressions in match arms.\n+fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n     if let ExprKind::Match(_, ref arms, MatchSource::TryDesugar) = expr {\n-        arms.iter().find_map(|ty| find_err_return_type_arm(cx, ty))\n-    } else {\n-        None\n+        for arm in arms.iter() {\n+            if let ExprKind::Ret(Some(ref ret)) = arm.body.kind {\n+                return Some(cx.typeck_results().expr_ty(ret));\n+            }\n+        }\n     }\n+    None\n }\n \n-// Check for From::from in one of the match arms.\n-fn find_err_return_type_arm<'tcx>(cx: &LateContext<'tcx>, arm: &'tcx Arm<'_>) -> Option<Ty<'tcx>> {\n+/// Extracts the error type from Result<T, E>.\n+fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ExprKind::Ret(Some(ref err_ret)) = arm.body.kind;\n-        if let ExprKind::Call(ref from_error_path, ref from_error_args) = err_ret.kind;\n-        if let ExprKind::Path(ref from_error_fn) = from_error_path.kind;\n-        if match_qpath(from_error_fn, &paths::TRY_FROM_ERROR);\n-        if let Some(from_error_arg) = from_error_args.get(0);\n+        if let ty::Adt(_, subst) = ty.kind;\n+        if is_type_diagnostic_item(cx, ty, sym!(result_type));\n+        let err_ty = subst.type_at(1);\n+        then {\n+            Some(err_ty)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extracts the error type from Poll<Result<T, E>>.\n+fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(def, subst) = ty.kind;\n+        if match_def_path(cx, def.did, &paths::POLL);\n+        let ready_ty = subst.type_at(0);\n+\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind;\n+        if cx.tcx.is_diagnostic_item(sym!(result_type), ready_def.did);\n+        let err_ty = ready_subst.type_at(1);\n+\n+        then {\n+            Some(err_ty)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Extracts the error type from Poll<Option<Result<T, E>>>.\n+fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    if_chain! {\n+        if let ty::Adt(def, subst) = ty.kind;\n+        if match_def_path(cx, def.did, &paths::POLL);\n+        let ready_ty = subst.type_at(0);\n+\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind;\n+        if cx.tcx.is_diagnostic_item(sym!(option_type), ready_def.did);\n+        let some_ty = ready_subst.type_at(0);\n+\n+        if let ty::Adt(some_def, some_subst) = some_ty.kind;\n+        if cx.tcx.is_diagnostic_item(sym!(result_type), some_def.did);\n+        let err_ty = some_subst.type_at(1);\n+\n         then {\n-            Some(cx.typeck_results().expr_ty(from_error_arg))\n+            Some(err_ty)\n         } else {\n             None\n         }"}, {"sha": "ea4b8172c9c2e8bb6f5b61bdb7a8e407b8612cb8", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -181,8 +181,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                             self.cx,\n                             UNNECESSARY_UNWRAP,\n                             expr.span,\n-                            &format!(\"You checked before that `{}()` cannot fail. \\\n-                            Instead of checking and unwrapping, it's better to use `if let` or `match`.\",\n+                            &format!(\"you checked before that `{}()` cannot fail, \\\n+                            instead of checking and unwrapping, it's better to use `if let` or `match`\",\n                             method_name.ident.name),\n                             |diag| { diag.span_label(unwrappable.check.span, \"the check is happening here\"); },\n                         );\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                             self.cx,\n                             PANICKING_UNWRAP,\n                             expr.span,\n-                            &format!(\"This call to `{}()` will always panic.\",\n+                            &format!(\"this call to `{}()` will always panic\",\n                             method_name.ident.name),\n                             |diag| { diag.span_label(unwrappable.check.span, \"because of this check\"); },\n                         );"}, {"sha": null, "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362"}, {"sha": "a3975683cb3021395a7a9f4a29c6ef585455bb09", "filename": "clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -75,12 +75,12 @@ pub fn get_attr<'a>(\n                 })\n                 .map_or_else(\n                     || {\n-                        sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n+                        sess.span_err(attr_segments[1].ident.span, \"usage of unknown attribute\");\n                         false\n                     },\n                     |deprecation_status| {\n                         let mut diag =\n-                            sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n+                            sess.struct_span_err(attr_segments[1].ident.span, \"usage of deprecated attribute\");\n                         match *deprecation_status {\n                             DeprecationStatus::Deprecated => {\n                                 diag.emit();"}, {"sha": "223628cc610da038d91f1856ea638dc56ce892b7", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -43,6 +43,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, layout::IntegerExt, subst::GenericArg, Ty, TyCtxt, TypeFoldable};\n+use rustc_mir::const_eval;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::symbol::{self, kw, Symbol};\n@@ -52,7 +53,6 @@ use rustc_trait_selection::traits::query::normalize::AtExt;\n use smallvec::SmallVec;\n \n use crate::consts::{constant, Constant};\n-use crate::reexport::Name;\n \n /// Returns `true` if the two spans come from differing expansions (i.e., one is\n /// from a macro and one isn't).\n@@ -150,7 +150,7 @@ pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str])\n }\n \n /// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr<'_>, var: Name) -> bool {\n+pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n         if let [p] = path.segments {\n             return p.ident.name == var;\n@@ -420,7 +420,7 @@ pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n }\n \n /// Gets the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n     let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n     match cx.tcx.hir().find(parent_id) {\n         Some(\n@@ -433,7 +433,7 @@ pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Name> {\n }\n \n /// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat<'_>) -> Option<Name> {\n+pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n     match pat.kind {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n@@ -443,14 +443,14 @@ pub fn get_pat_name(pat: &Pat<'_>) -> Option<Name> {\n }\n \n struct ContainsName {\n-    name: Name,\n+    name: Symbol,\n     result: bool,\n }\n \n impl<'tcx> Visitor<'tcx> for ContainsName {\n     type Map = Map<'tcx>;\n \n-    fn visit_name(&mut self, _: Span, name: Name) {\n+    fn visit_name(&mut self, _: Span, name: Symbol) {\n         if self.name == name {\n             self.result = true;\n         }\n@@ -461,7 +461,7 @@ impl<'tcx> Visitor<'tcx> for ContainsName {\n }\n \n /// Checks if an `Expr` contains a certain name.\n-pub fn contains_name(name: Name, expr: &Expr<'_>) -> bool {\n+pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n     let mut cn = ContainsName { name, result: false };\n     cn.visit_expr(expr);\n     cn.result\n@@ -869,11 +869,19 @@ pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n \n /// Checks if an expression is constructing a tuple-like enum variant or struct\n pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    fn has_no_arguments(cx: &LateContext<'_>, def_id: DefId) -> bool {\n+        cx.tcx.fn_sig(def_id).skip_binder().inputs().is_empty()\n+    }\n+\n     if let ExprKind::Call(ref fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n             let res = cx.qpath_res(qp, fun.hir_id);\n             return match res {\n                 def::Res::Def(DefKind::Variant | DefKind::Ctor(..), ..) => true,\n+                // FIXME: check the constness of the arguments, see https://github.com/rust-lang/rust-clippy/pull/5682#issuecomment-638681210\n+                def::Res::Def(DefKind::Fn, def_id) if has_no_arguments(cx, def_id) => {\n+                    const_eval::is_const_fn(cx.tcx, def_id)\n+                },\n                 def::Res::Def(_, def_id) => cx.tcx.is_promotable_const_fn(def_id),\n                 _ => false,\n             };\n@@ -1027,7 +1035,7 @@ pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n-pub fn get_arg_name(pat: &Pat<'_>) -> Option<Name> {\n+pub fn get_arg_name(pat: &Pat<'_>) -> Option<Symbol> {\n     match pat.kind {\n         PatKind::Binding(.., ident, None) => Some(ident.name),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n@@ -1378,6 +1386,36 @@ pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bo\n     })\n }\n \n+/// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n+/// number type, a str, or an array, slice, or tuple of those types).\n+pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n+    match ty.kind {\n+        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n+        ty::Ref(_, inner, _) if inner.kind == ty::Str => true,\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true iff the given expression is a slice of primitives (as defined in the\n+/// `is_recursively_primitive_type` function).\n+pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n+    match expr_type.kind {\n+        ty::Slice(ref element_type)\n+        | ty::Ref(\n+            _,\n+            ty::TyS {\n+                kind: ty::Slice(ref element_type),\n+                ..\n+            },\n+            _,\n+        ) => is_recursively_primitive_type(element_type),\n+        _ => false,\n+    }\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{"}, {"sha": "923b319d7778e2b3f0741eff765eca54a331bbba", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -80,6 +80,7 @@ pub const PATH: [&str; 3] = [\"std\", \"path\", \"Path\"];\n pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n+pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n pub const PTR_NULL: [&str; 2] = [\"ptr\", \"null\"];\n pub const PTR_NULL_MUT: [&str; 2] = [\"ptr\", \"null_mut\"];\n@@ -129,7 +130,6 @@ pub const TO_STRING: [&str; 3] = [\"alloc\", \"string\", \"ToString\"];\n pub const TO_STRING_METHOD: [&str; 4] = [\"alloc\", \"string\", \"ToString\", \"to_string\"];\n pub const TRANSMUTE: [&str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const TRY_FROM: [&str; 4] = [\"core\", \"convert\", \"TryFrom\", \"try_from\"];\n-pub const TRY_FROM_ERROR: [&str; 4] = [\"std\", \"ops\", \"Try\", \"from_error\"];\n pub const TRY_INTO_RESULT: [&str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const TRY_INTO_TRAIT: [&str; 3] = [\"core\", \"convert\", \"TryInto\"];\n pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];"}, {"sha": "168092f7329cc0caed65ea30f0edfe20ac91644c", "filename": "doc/adding_lints.md", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -27,23 +27,22 @@ because that's clearly a non-descriptive name.\n \n ## Setup\n \n-When working on Clippy, you will need the current git master version of rustc,\n-which can change rapidly. Make sure you're working near rust-clippy's master,\n-and use the `setup-toolchain.sh` script to configure the appropriate toolchain\n-for the Clippy directory.\n+See the [Basics](basics.md#get-the-code) documentation.\n \n ## Getting Started\n \n There is a bit of boilerplate code that needs to be set up when creating a new\n lint. Fortunately, you can use the clippy dev tools to handle this for you. We\n are naming our new lint `foo_functions` (lints are generally written in snake\n case), and we don't need type information so it will have an early pass type\n-(more on this later on). To get started on this lint you can run\n-`cargo dev new_lint --name=foo_functions --pass=early --category=pedantic`\n-(category will default to nursery if not provided). This command will create\n-two files: `tests/ui/foo_functions.rs` and `clippy_lints/src/foo_functions.rs`,\n-as well as run `cargo dev update_lints` to register the new lint. For cargo lints,\n-two project hierarchies (fail/pass) will be created by default under `tests/ui-cargo`.\n+(more on this later on). If you're not sure if the name you chose fits the lint,\n+take a look at our [lint naming guidelines][lint_naming]. To get started on this\n+lint you can run `cargo dev new_lint --name=foo_functions --pass=early\n+--category=pedantic` (category will default to nursery if not provided). This\n+command will create two files: `tests/ui/foo_functions.rs` and\n+`clippy_lints/src/foo_functions.rs`, as well as run `cargo dev update_lints` to\n+register the new lint. For cargo lints, two project hierarchies (fail/pass) will\n+be created by default under `tests/ui-cargo`.\n \n Next, we'll open up these files and add our lint!\n \n@@ -113,7 +112,7 @@ For cargo lints, the process of testing differs in that we are interested in\n the `Cargo.toml` manifest file. We also need a minimal crate associated\n with that manifest.\n \n-If our new lint is named e.g. `foo_categories`, after running `cargo dev new_lint` \n+If our new lint is named e.g. `foo_categories`, after running `cargo dev new_lint`\n we will find by default two new crates, each with its manifest file:\n \n * `tests/ui-cargo/foo_categories/fail/Cargo.toml`: this file should cause the new lint to raise an error."}, {"sha": "c81e7f6e0692bd6b2378ff20eb50523b59617925", "filename": "doc/basics.md", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/doc%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/doc%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fbasics.md?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,112 @@\n+# Basics for hacking on Clippy\n+\n+This document explains the basics for hacking on Clippy. Besides others, this\n+includes how to set-up the development environment, how to build and how to test\n+Clippy. For a more in depth description on the codebase take a look at [Adding\n+Lints] or [Common Tools].\n+\n+[Adding Lints]: https://github.com/rust-lang/rust-clippy/blob/master/doc/adding_lints.md\n+[Common Tools]: https://github.com/rust-lang/rust-clippy/blob/master/doc/common_tools_writing_lints.md\n+\n+- [Basics for hacking on Clippy](#basics-for-hacking-on-clippy)\n+  - [Get the code](#get-the-code)\n+  - [Setup](#setup)\n+  - [Building and Testing](#building-and-testing)\n+  - [`cargo dev`](#cargo-dev)\n+\n+## Get the Code\n+\n+First, make sure you have checked out the latest version of Clippy. If this is\n+your first time working on Clippy, create a fork of the repository and clone it\n+afterwards with the following command:\n+\n+```bash\n+git clone git@github.com:<your-username>/rust-clippy\n+```\n+\n+If you've already cloned Clippy in the past, update it to the latest version:\n+\n+```bash\n+# upstream has to be the remote of the rust-lang/rust-clippy repo\n+git fetch upstream\n+# make sure that you are on the master branch\n+git checkout master\n+# rebase your master branch on the upstream master\n+git rebase upstream/master\n+# push to the master branch of your fork\n+git push\n+```\n+\n+## Setup\n+\n+Next we need to setup the toolchain to compile Clippy. Since Clippy heavily\n+relies on compiler internals it is build with the latest rustc master. To get\n+this toolchain, you can just use the `setup-toolchain.sh` script or use\n+`rustup-toolchain-install-master`:\n+\n+```bash\n+sh setup-toolchain.sh\n+# OR\n+cargo install rustup-toolchain-install-master\n+# For better IDE integration also add `-c rustfmt -c rust-src` (optional)\n+rustup-toolchain-install-master -f -n master -c rustc-dev -c llvm-tools\n+rustup override set master\n+```\n+\n+_Note:_ Sometimes you may get compiler errors when building Clippy, even if you\n+didn't change anything. Normally those will be fixed by a maintainer in a few hours. \n+\n+## Building and Testing\n+\n+Once the `master` toolchain is installed, you can build and test Clippy like\n+every other Rust project:\n+\n+```bash\n+cargo build  # builds Clippy\n+cargo test   # tests Clippy\n+```\n+\n+Since Clippy's test suite is pretty big, there are some commands that only run a\n+subset of Clippy's tests:\n+\n+```bash\n+# only run UI tests\n+cargo uitest\n+# only run UI tests starting with `test_`\n+TESTNAME=\"test_\" cargo uitest\n+# only run dogfood tests\n+cargo test --test dogfood\n+```\n+\n+If the output of a [UI test] differs from the expected output, you can update the\n+reference file with:\n+\n+```bash\n+sh tests/ui/update-all-references.sh\n+```\n+\n+For example, this is necessary, if you fix a typo in an error message of a lint\n+or if you modify a test file to add a test case.\n+\n+_Note:_ This command may update more files than you intended. In that case only\n+commit the files you wanted to update.\n+\n+[UI test]: https://rustc-dev-guide.rust-lang.org/tests/adding.html#guide-to-the-ui-tests\n+\n+## `cargo dev`\n+\n+Clippy has some dev tools to make working on Clippy more convenient. These tools\n+can be accessed through the `cargo dev` command. Available tools are listed\n+below. To get more information about these commands, just call them with\n+`--help`.\n+\n+```bash\n+# formats the whole Clippy codebase and all tests\n+cargo dev fmt\n+# register or update lint names/groups/...\n+cargo dev update_lints\n+# create a new lint and register it\n+cargo dev new_lint\n+# (experimental) Setup Clippy to work with rust-analyzer\n+cargo dev ra-setup\n+```"}, {"sha": "bbb300296be9720ab629d8426e03fef89e6c5379", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -360,6 +360,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"derive\",\n     },\n+    Lint {\n+        name: \"derive_ord_xor_partial_ord\",\n+        group: \"correctness\",\n+        desc: \"deriving `Ord` but implementing `PartialOrd` explicitly\",\n+        deprecation: None,\n+        module: \"derive\",\n+    },\n     Lint {\n         name: \"diverging_sub_expression\",\n         group: \"complexity\",\n@@ -405,7 +412,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     Lint {\n         name: \"drop_bounds\",\n         group: \"correctness\",\n-        desc: \"Bounds of the form `T: Drop` are useless\",\n+        desc: \"bounds of the form `T: Drop` are useless\",\n         deprecation: None,\n         module: \"drop_bounds\",\n     },\n@@ -1452,6 +1459,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"bytecount\",\n     },\n+    Lint {\n+        name: \"needless_arbitrary_self_type\",\n+        group: \"complexity\",\n+        desc: \"type of `self` parameter is already by default `Self`\",\n+        deprecation: None,\n+        module: \"needless_arbitrary_self_type\",\n+    },\n     Lint {\n         name: \"needless_bool\",\n         group: \"complexity\",\n@@ -1928,6 +1942,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"copies\",\n     },\n+    Lint {\n+        name: \"same_item_push\",\n+        group: \"style\",\n+        desc: \"the same item is pushed inside of a for loop\",\n+        deprecation: None,\n+        module: \"loops\",\n+    },\n     Lint {\n         name: \"search_is_some\",\n         group: \"complexity\",\n@@ -2026,6 +2047,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"slow_vector_initialization\",\n     },\n+    Lint {\n+        name: \"stable_sort_primitive\",\n+        group: \"perf\",\n+        desc: \"use of sort() when sort_unstable() is equivalent\",\n+        deprecation: None,\n+        module: \"stable_sort_primitive\",\n+    },\n     Lint {\n         name: \"string_add\",\n         group: \"restriction\",\n@@ -2166,6 +2194,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"misc\",\n     },\n+    Lint {\n+        name: \"trait_duplication_in_bounds\",\n+        group: \"pedantic\",\n+        desc: \"Check if the same trait bounds are specified twice during a function declaration\",\n+        deprecation: None,\n+        module: \"trait_bounds\",\n+    },\n     Lint {\n         name: \"transmute_bytes_to_str\",\n         group: \"complexity\","}, {"sha": "697823712bf05e4ef411709915b1100fea7672cc", "filename": "tests/compile-test.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -3,7 +3,7 @@\n use compiletest_rs as compiletest;\n use compiletest_rs::common::Mode as TestMode;\n \n-use std::env::{self, set_var};\n+use std::env::{self, set_var, var};\n use std::ffi::OsStr;\n use std::fs;\n use std::io;\n@@ -136,7 +136,9 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n \n     let tests = compiletest::make_tests(&config);\n \n+    let manifest_dir = var(\"CARGO_MANIFEST_DIR\").unwrap_or_default();\n     let res = run_tests(&config, tests);\n+    set_var(\"CARGO_MANIFEST_DIR\", &manifest_dir);\n     match res {\n         Ok(true) => {},\n         Ok(false) => panic!(\"Some tests failed\"),\n@@ -147,9 +149,6 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n }\n \n fn run_ui_cargo(config: &mut compiletest::Config) {\n-    if cargo::is_rustc_test_suite() {\n-        return;\n-    }\n     fn run_tests(\n         config: &compiletest::Config,\n         filter: &Option<String>,\n@@ -217,6 +216,10 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n         Ok(result)\n     }\n \n+    if cargo::is_rustc_test_suite() {\n+        return;\n+    }\n+\n     config.mode = TestMode::Ui;\n     config.src_base = Path::new(\"tests\").join(\"ui-cargo\").canonicalize().unwrap();\n "}, {"sha": "fb12257021a1e7e0f0751c65c233392c0d8572fa", "filename": "tests/ui-toml/functions_maxlines/test.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: This function has a large number of lines.\n+error: this function has a large number of lines\n   --> $DIR/test.rs:18:1\n    |\n LL | / fn too_many_lines() {\n@@ -9,7 +9,7 @@ LL | | }\n    |\n    = note: `-D clippy::too-many-lines` implied by `-D warnings`\n \n-error: This function has a large number of lines.\n+error: this function has a large number of lines\n   --> $DIR/test.rs:38:1\n    |\n LL | / fn comment_before_code() {"}, {"sha": "0458950edee1c9660d41a4e15a974038f3949eac", "filename": "tests/ui/await_holding_lock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -47,6 +47,7 @@ async fn not_good(x: &Mutex<u32>) -> u32 {\n     first + second + third\n }\n \n+#[allow(clippy::manual_async_fn)]\n fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n     async move {\n         let guard = x.lock().unwrap();"}, {"sha": "21bf49d16f04877d862ff702ef527575cd537d2f", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -46,13 +46,13 @@ LL | |     };\n    | |_____^\n \n error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n-  --> $DIR/await_holding_lock.rs:52:13\n+  --> $DIR/await_holding_lock.rs:53:13\n    |\n LL |         let guard = x.lock().unwrap();\n    |             ^^^^^\n    |\n note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:52:9\n+  --> $DIR/await_holding_lock.rs:53:9\n    |\n LL | /         let guard = x.lock().unwrap();\n LL | |         baz().await"}, {"sha": "55d94b8257dba3b96408dad7eb849811623e0114", "filename": "tests/ui/bool_comparison.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fbool_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fbool_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbool_comparison.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -84,25 +84,25 @@ error: order comparisons between booleans can be simplified\n LL |     if x > y {\n    |        ^^^^^ help: try simplifying it as shown: `x & !y`\n \n-error: This comparison might be written more concisely\n+error: this comparison might be written more concisely\n   --> $DIR/bool_comparison.rs:120:8\n    |\n LL |     if a == !b {};\n    |        ^^^^^^^ help: try simplifying it as shown: `a != b`\n \n-error: This comparison might be written more concisely\n+error: this comparison might be written more concisely\n   --> $DIR/bool_comparison.rs:121:8\n    |\n LL |     if !a == b {};\n    |        ^^^^^^^ help: try simplifying it as shown: `a != b`\n \n-error: This comparison might be written more concisely\n+error: this comparison might be written more concisely\n   --> $DIR/bool_comparison.rs:125:8\n    |\n LL |     if b == !a {};\n    |        ^^^^^^^ help: try simplifying it as shown: `b != a`\n \n-error: This comparison might be written more concisely\n+error: this comparison might be written more concisely\n   --> $DIR/bool_comparison.rs:126:8\n    |\n LL |     if !b == a {};"}, {"sha": "f42b246afd29319233c12bde09cb35726f959776", "filename": "tests/ui/builtin-type-shadow.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fbuiltin-type-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fbuiltin-type-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin-type-shadow.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: This generic shadows the built-in type `u32`\n+error: this generic shadows the built-in type `u32`\n   --> $DIR/builtin-type-shadow.rs:4:8\n    |\n LL | fn foo<u32>(a: u32) -> u32 {"}, {"sha": "1dc37fc8b259f576d046aeec7090a998465cabd0", "filename": "tests/ui/bytecount.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fbytecount.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fbytecount.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytecount.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,26 +1,26 @@\n-error: You appear to be counting bytes the naive way\n+error: you appear to be counting bytes the naive way\n   --> $DIR/bytecount.rs:5:13\n    |\n LL |     let _ = x.iter().filter(|&&a| a == 0).count(); // naive byte count\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count(x, 0)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count(x, 0)`\n    |\n note: the lint level is defined here\n   --> $DIR/bytecount.rs:1:8\n    |\n LL | #[deny(clippy::naive_bytecount)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: You appear to be counting bytes the naive way\n+error: you appear to be counting bytes the naive way\n   --> $DIR/bytecount.rs:7:13\n    |\n LL |     let _ = (&x[..]).iter().filter(|&a| *a == 0).count(); // naive byte count\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count((&x[..]), 0)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count((&x[..]), 0)`\n \n-error: You appear to be counting bytes the naive way\n+error: you appear to be counting bytes the naive way\n   --> $DIR/bytecount.rs:19:13\n    |\n LL |     let _ = x.iter().filter(|a| b + 1 == **a).count(); // naive byte count\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Consider using the bytecount crate: `bytecount::count(x, b + 1)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using the bytecount crate: `bytecount::count(x, b + 1)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "18518def0acbe42e596234de18964803d6059a18", "filename": "tests/ui/checked_conversions.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_conversions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_conversions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,96 +1,96 @@\n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:17:13\n    |\n LL |     let _ = value <= (u32::max_value() as i64) && value >= 0;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u32::try_from(value).is_ok()`\n    |\n    = note: `-D clippy::checked-conversions` implied by `-D warnings`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:18:13\n    |\n LL |     let _ = value <= (u32::MAX as i64) && value >= 0;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u32::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:22:13\n    |\n LL |     let _ = value <= i64::from(u16::max_value()) && value >= 0;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:23:13\n    |\n LL |     let _ = value <= i64::from(u16::MAX) && value >= 0;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:27:13\n    |\n LL |     let _ = value <= (u8::max_value() as isize) && value >= 0;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u8::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:28:13\n    |\n LL |     let _ = value <= (u8::MAX as isize) && value >= 0;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u8::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:34:13\n    |\n LL |     let _ = value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:35:13\n    |\n LL |     let _ = value <= (i32::MAX as i64) && value >= (i32::MIN as i64);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:39:13\n    |\n LL |     let _ = value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i16::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:40:13\n    |\n LL |     let _ = value <= i64::from(i16::MAX) && value >= i64::from(i16::MIN);\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i16::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:46:13\n    |\n LL |     let _ = value <= i32::max_value() as u32;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:47:13\n    |\n LL |     let _ = value <= i32::MAX as u32;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `i32::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:51:13\n    |\n LL |     let _ = value <= isize::max_value() as usize && value as i32 == 5;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `isize::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:52:13\n    |\n LL |     let _ = value <= isize::MAX as usize && value as i32 == 5;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `isize::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:56:13\n    |\n LL |     let _ = value <= u16::max_value() as u32 && value as i32 == 5;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `u16::try_from(value).is_ok()`\n \n-error: Checked cast can be simplified.\n+error: checked cast can be simplified\n   --> $DIR/checked_conversions.rs:57:13\n    |\n LL |     let _ = value <= u16::MAX as u32 && value as i32 == 5;"}, {"sha": "33bb5136ef8e70ff8c5a24fd0a1f90fb9b75ac27", "filename": "tests/ui/checked_unwrap/complex_conditionals.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:8:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n@@ -12,7 +12,7 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: This call to `unwrap_err()` will always panic.\n+error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:9:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n@@ -27,7 +27,7 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:10:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n@@ -36,7 +36,7 @@ LL |     if x.is_ok() && y.is_err() {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:11:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n@@ -45,7 +45,7 @@ LL |     if x.is_ok() && y.is_err() {\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:25:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n@@ -54,7 +54,7 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:26:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n@@ -63,7 +63,7 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:27:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n@@ -72,7 +72,7 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:28:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n@@ -81,15 +81,15 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:32:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |        --------- the check is happening here\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: This call to `unwrap_err()` will always panic.\n+error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:33:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n@@ -98,7 +98,7 @@ LL |         x.unwrap(); // unnecessary\n LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:34:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n@@ -107,7 +107,7 @@ LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:35:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n@@ -116,7 +116,7 @@ LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:36:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n@@ -125,7 +125,7 @@ LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n LL |         z.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: This call to `unwrap_err()` will always panic.\n+error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:37:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n@@ -134,7 +134,7 @@ LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n LL |         z.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:45:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n@@ -143,7 +143,7 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:46:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n@@ -152,7 +152,7 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:47:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n@@ -161,7 +161,7 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         y.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: This call to `unwrap_err()` will always panic.\n+error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:48:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n@@ -170,7 +170,7 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         y.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:49:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n@@ -179,7 +179,7 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         z.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals.rs:50:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {"}, {"sha": "a01f7f956f629c80ac8affb2f702a1b148b794d2", "filename": "tests/ui/checked_unwrap/complex_conditionals_nested.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/complex_conditionals_nested.rs:8:13\n    |\n LL |         if x.is_some() {\n@@ -12,7 +12,7 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals_nested.rs:10:13\n    |\n LL |         if x.is_some() {"}, {"sha": "416ec1a01ab3aa27e59b9ed44bd9d8cde45c911e", "filename": "tests/ui/checked_unwrap/simple_conditionals.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/simple_conditionals.rs:39:9\n    |\n LL |     if x.is_some() {\n@@ -12,7 +12,7 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/simple_conditionals.rs:41:9\n    |\n LL |     if x.is_some() {\n@@ -27,15 +27,15 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/simple_conditionals.rs:44:9\n    |\n LL |     if x.is_none() {\n    |        ----------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/simple_conditionals.rs:46:9\n    |\n LL |     if x.is_none() {\n@@ -44,7 +44,7 @@ LL |     if x.is_none() {\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/simple_conditionals.rs:7:13\n    |\n LL |         if $a.is_some() {\n@@ -57,15 +57,15 @@ LL |     m!(x);\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/simple_conditionals.rs:54:9\n    |\n LL |     if x.is_ok() {\n    |        --------- the check is happening here\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: This call to `unwrap_err()` will always panic.\n+error: this call to `unwrap_err()` will always panic\n   --> $DIR/simple_conditionals.rs:55:9\n    |\n LL |     if x.is_ok() {\n@@ -74,7 +74,7 @@ LL |         x.unwrap(); // unnecessary\n LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/simple_conditionals.rs:57:9\n    |\n LL |     if x.is_ok() {\n@@ -83,7 +83,7 @@ LL |     if x.is_ok() {\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/simple_conditionals.rs:58:9\n    |\n LL |     if x.is_ok() {\n@@ -92,15 +92,15 @@ LL |     if x.is_ok() {\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: This call to `unwrap()` will always panic.\n+error: this call to `unwrap()` will always panic\n   --> $DIR/simple_conditionals.rs:61:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/simple_conditionals.rs:62:9\n    |\n LL |     if x.is_err() {\n@@ -109,7 +109,7 @@ LL |         x.unwrap(); // will panic\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n   --> $DIR/simple_conditionals.rs:64:9\n    |\n LL |     if x.is_err() {\n@@ -118,7 +118,7 @@ LL |     if x.is_err() {\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: This call to `unwrap_err()` will always panic.\n+error: this call to `unwrap_err()` will always panic\n   --> $DIR/simple_conditionals.rs:65:9\n    |\n LL |     if x.is_err() {"}, {"sha": "a1f4c70fb2786ede59a99564e629a4715ab3fca7", "filename": "tests/ui/cmp_null.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fcmp_null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fcmp_null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_null.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,12 +1,12 @@\n-error: Comparing with null is better expressed by the `.is_null()` method\n+error: comparing with null is better expressed by the `.is_null()` method\n   --> $DIR/cmp_null.rs:9:8\n    |\n LL |     if p == ptr::null() {\n    |        ^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::cmp-null` implied by `-D warnings`\n \n-error: Comparing with null is better expressed by the `.is_null()` method\n+error: comparing with null is better expressed by the `.is_null()` method\n   --> $DIR/cmp_null.rs:14:8\n    |\n LL |     if m == ptr::null_mut() {"}, {"sha": "68afa8f8c3a84bfabbf06f4778fa5308d103f9f3", "filename": "tests/ui/crashes/ice-5872.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fcrashes%2Fice-5872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fcrashes%2Fice-5872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5872.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,5 @@\n+#![warn(clippy::needless_collect)]\n+\n+fn main() {\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<_>>().is_empty();\n+}"}, {"sha": "a60ca345cf78d473213dad95d29cbdae97d765ac", "filename": "tests/ui/crashes/ice-5872.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fcrashes%2Fice-5872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fcrashes%2Fice-5872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5872.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,10 @@\n+error: avoid using `collect()` when not needed\n+  --> $DIR/ice-5872.rs:4:39\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<Vec<_>>().is_empty();\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n+   |\n+   = note: `-D clippy::needless-collect` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "26b2057548bd9e46b3dc94c7a6ff6366a30b33ce", "filename": "tests/ui/default_trait_access.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdefault_trait_access.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdefault_trait_access.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_trait_access.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,48 +1,48 @@\n-error: Calling `std::string::String::default()` is more clear than this expression\n+error: calling `std::string::String::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:8:22\n    |\n LL |     let s1: String = Default::default();\n    |                      ^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n    |\n    = note: `-D clippy::default-trait-access` implied by `-D warnings`\n \n-error: Calling `std::string::String::default()` is more clear than this expression\n+error: calling `std::string::String::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:12:22\n    |\n LL |     let s3: String = D2::default();\n    |                      ^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n \n-error: Calling `std::string::String::default()` is more clear than this expression\n+error: calling `std::string::String::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:14:22\n    |\n LL |     let s4: String = std::default::Default::default();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n \n-error: Calling `std::string::String::default()` is more clear than this expression\n+error: calling `std::string::String::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:18:22\n    |\n LL |     let s6: String = default::Default::default();\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `std::string::String::default()`\n \n-error: Calling `GenericDerivedDefault<std::string::String>::default()` is more clear than this expression\n+error: calling `GenericDerivedDefault<std::string::String>::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:28:46\n    |\n LL |     let s11: GenericDerivedDefault<String> = Default::default();\n    |                                              ^^^^^^^^^^^^^^^^^^ help: try: `GenericDerivedDefault<std::string::String>::default()`\n \n-error: Calling `TupleDerivedDefault::default()` is more clear than this expression\n+error: calling `TupleDerivedDefault::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:34:36\n    |\n LL |     let s14: TupleDerivedDefault = Default::default();\n    |                                    ^^^^^^^^^^^^^^^^^^ help: try: `TupleDerivedDefault::default()`\n \n-error: Calling `ArrayDerivedDefault::default()` is more clear than this expression\n+error: calling `ArrayDerivedDefault::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:36:36\n    |\n LL |     let s15: ArrayDerivedDefault = Default::default();\n    |                                    ^^^^^^^^^^^^^^^^^^ help: try: `ArrayDerivedDefault::default()`\n \n-error: Calling `TupleStructDerivedDefault::default()` is more clear than this expression\n+error: calling `TupleStructDerivedDefault::default()` is more clear than this expression\n   --> $DIR/default_trait_access.rs:40:42\n    |\n LL |     let s17: TupleStructDerivedDefault = Default::default();"}, {"sha": "b82dc518a3ba60520d21f016e2b213ddb430bed4", "filename": "tests/ui/derive_ord_xor_partial_ord.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fderive_ord_xor_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fderive_ord_xor_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_ord_xor_partial_ord.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,68 @@\n+#![warn(clippy::derive_ord_xor_partial_ord)]\n+\n+use std::cmp::Ordering;\n+\n+#[derive(PartialOrd, Ord, PartialEq, Eq)]\n+struct DeriveBoth;\n+\n+impl PartialEq<u64> for DeriveBoth {\n+    fn eq(&self, _: &u64) -> bool {\n+        true\n+    }\n+}\n+\n+impl PartialOrd<u64> for DeriveBoth {\n+    fn partial_cmp(&self, _: &u64) -> Option<Ordering> {\n+        Some(Ordering::Equal)\n+    }\n+}\n+\n+#[derive(Ord, PartialEq, Eq)]\n+struct DeriveOrd;\n+\n+impl PartialOrd for DeriveOrd {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(other.cmp(self))\n+    }\n+}\n+\n+#[derive(Ord, PartialEq, Eq)]\n+struct DeriveOrdWithExplicitTypeVariable;\n+\n+impl PartialOrd<DeriveOrdWithExplicitTypeVariable> for DeriveOrdWithExplicitTypeVariable {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(other.cmp(self))\n+    }\n+}\n+\n+#[derive(PartialOrd, PartialEq, Eq)]\n+struct DerivePartialOrd;\n+\n+impl std::cmp::Ord for DerivePartialOrd {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        Ordering::Less\n+    }\n+}\n+\n+#[derive(PartialOrd, PartialEq, Eq)]\n+struct ImplUserOrd;\n+\n+trait Ord {}\n+\n+// We don't want to lint on user-defined traits called `Ord`\n+impl Ord for ImplUserOrd {}\n+\n+mod use_ord {\n+    use std::cmp::{Ord, Ordering};\n+\n+    #[derive(PartialOrd, PartialEq, Eq)]\n+    struct DerivePartialOrdInUseOrd;\n+\n+    impl Ord for DerivePartialOrdInUseOrd {\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            Ordering::Less\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "66bc4d42ce8c3c85e80d571bcbb658884a92cbe3", "filename": "tests/ui/derive_ord_xor_partial_ord.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,71 @@\n+error: you are deriving `Ord` but have implemented `PartialOrd` explicitly\n+  --> $DIR/derive_ord_xor_partial_ord.rs:20:10\n+   |\n+LL | #[derive(Ord, PartialEq, Eq)]\n+   |          ^^^\n+   |\n+   = note: `-D clippy::derive-ord-xor-partial-ord` implied by `-D warnings`\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:23:1\n+   |\n+LL | / impl PartialOrd for DeriveOrd {\n+LL | |     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+LL | |         Some(other.cmp(self))\n+LL | |     }\n+LL | | }\n+   | |_^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are deriving `Ord` but have implemented `PartialOrd` explicitly\n+  --> $DIR/derive_ord_xor_partial_ord.rs:29:10\n+   |\n+LL | #[derive(Ord, PartialEq, Eq)]\n+   |          ^^^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:32:1\n+   |\n+LL | / impl PartialOrd<DeriveOrdWithExplicitTypeVariable> for DeriveOrdWithExplicitTypeVariable {\n+LL | |     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+LL | |         Some(other.cmp(self))\n+LL | |     }\n+LL | | }\n+   | |_^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are implementing `Ord` explicitly but have derived `PartialOrd`\n+  --> $DIR/derive_ord_xor_partial_ord.rs:41:1\n+   |\n+LL | / impl std::cmp::Ord for DerivePartialOrd {\n+LL | |     fn cmp(&self, other: &Self) -> Ordering {\n+LL | |         Ordering::Less\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:38:10\n+   |\n+LL | #[derive(PartialOrd, PartialEq, Eq)]\n+   |          ^^^^^^^^^^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are implementing `Ord` explicitly but have derived `PartialOrd`\n+  --> $DIR/derive_ord_xor_partial_ord.rs:61:5\n+   |\n+LL | /     impl Ord for DerivePartialOrdInUseOrd {\n+LL | |         fn cmp(&self, other: &Self) -> Ordering {\n+LL | |             Ordering::Less\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:58:14\n+   |\n+LL |     #[derive(PartialOrd, PartialEq, Eq)]\n+   |              ^^^^^^^^^^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "05ef4e25f7f870b8b8c9056ff6f540de89617b1b", "filename": "tests/ui/double_comparison.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdouble_comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdouble_comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_comparison.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,48 +1,48 @@\n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:6:8\n    |\n LL |     if x == y || x < y {\n    |        ^^^^^^^^^^^^^^^ help: try: `x <= y`\n    |\n    = note: `-D clippy::double-comparisons` implied by `-D warnings`\n \n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:9:8\n    |\n LL |     if x < y || x == y {\n    |        ^^^^^^^^^^^^^^^ help: try: `x <= y`\n \n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:12:8\n    |\n LL |     if x == y || x > y {\n    |        ^^^^^^^^^^^^^^^ help: try: `x >= y`\n \n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:15:8\n    |\n LL |     if x > y || x == y {\n    |        ^^^^^^^^^^^^^^^ help: try: `x >= y`\n \n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:18:8\n    |\n LL |     if x < y || x > y {\n    |        ^^^^^^^^^^^^^^ help: try: `x != y`\n \n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:21:8\n    |\n LL |     if x > y || x < y {\n    |        ^^^^^^^^^^^^^^ help: try: `x != y`\n \n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:24:8\n    |\n LL |     if x <= y && x >= y {\n    |        ^^^^^^^^^^^^^^^^ help: try: `x == y`\n \n-error: This binary expression can be simplified\n+error: this binary expression can be simplified\n   --> $DIR/double_comparison.rs:27:8\n    |\n LL |     if x >= y && x <= y {"}, {"sha": "40fcad2ab1d4a64b5c88a7a451d08f9180379784", "filename": "tests/ui/double_parens.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdouble_parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdouble_parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdouble_parens.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,36 +1,36 @@\n-error: Consider removing unnecessary double parentheses\n+error: consider removing unnecessary double parentheses\n   --> $DIR/double_parens.rs:15:5\n    |\n LL |     ((0))\n    |     ^^^^^\n    |\n    = note: `-D clippy::double-parens` implied by `-D warnings`\n \n-error: Consider removing unnecessary double parentheses\n+error: consider removing unnecessary double parentheses\n   --> $DIR/double_parens.rs:19:14\n    |\n LL |     dummy_fn((0));\n    |              ^^^\n \n-error: Consider removing unnecessary double parentheses\n+error: consider removing unnecessary double parentheses\n   --> $DIR/double_parens.rs:23:20\n    |\n LL |     x.dummy_method((0));\n    |                    ^^^\n \n-error: Consider removing unnecessary double parentheses\n+error: consider removing unnecessary double parentheses\n   --> $DIR/double_parens.rs:27:5\n    |\n LL |     ((1, 2))\n    |     ^^^^^^^^\n \n-error: Consider removing unnecessary double parentheses\n+error: consider removing unnecessary double parentheses\n   --> $DIR/double_parens.rs:31:5\n    |\n LL |     (())\n    |     ^^^^\n \n-error: Consider removing unnecessary double parentheses\n+error: consider removing unnecessary double parentheses\n   --> $DIR/double_parens.rs:53:16\n    |\n LL |     assert_eq!(((1, 2)), (1, 2), \"Error\");"}, {"sha": "8208c0ed7e3985e6e4059d4373574622f8540fb4", "filename": "tests/ui/drop_bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdrop_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fdrop_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_bounds.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,12 +1,12 @@\n-error: Bounds of the form `T: Drop` are useless. Use `std::mem::needs_drop` to detect if a type has drop glue.\n+error: bounds of the form `T: Drop` are useless, use `std::mem::needs_drop` to detect if a type has drop glue\n   --> $DIR/drop_bounds.rs:2:11\n    |\n LL | fn foo<T: Drop>() {}\n    |           ^^^^\n    |\n    = note: `#[deny(clippy::drop_bounds)]` on by default\n \n-error: Bounds of the form `T: Drop` are useless. Use `std::mem::needs_drop` to detect if a type has drop glue.\n+error: bounds of the form `T: Drop` are useless, use `std::mem::needs_drop` to detect if a type has drop glue\n   --> $DIR/drop_bounds.rs:5:8\n    |\n LL |     T: Drop,"}, {"sha": "594fca44a321071ac46cdc9ad5bcac5676f69218", "filename": "tests/ui/empty_line_after_outer_attribute.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fempty_line_after_outer_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fempty_line_after_outer_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_line_after_outer_attribute.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n+error: found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n   --> $DIR/empty_line_after_outer_attribute.rs:11:1\n    |\n LL | / #[crate_type = \"lib\"]\n@@ -9,15 +9,15 @@ LL | | fn with_one_newline_and_comment() { assert!(true) }\n    |\n    = note: `-D clippy::empty-line-after-outer-attr` implied by `-D warnings`\n \n-error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n+error: found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n   --> $DIR/empty_line_after_outer_attribute.rs:23:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n LL | | fn with_one_newline() { assert!(true) }\n    | |_\n \n-error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n+error: found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n   --> $DIR/empty_line_after_outer_attribute.rs:28:1\n    |\n LL | / #[crate_type = \"lib\"]\n@@ -26,23 +26,23 @@ LL | |\n LL | | fn with_two_newlines() { assert!(true) }\n    | |_\n \n-error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n+error: found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n   --> $DIR/empty_line_after_outer_attribute.rs:35:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n LL | | enum Baz {\n    | |_\n \n-error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n+error: found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n   --> $DIR/empty_line_after_outer_attribute.rs:43:1\n    |\n LL | / #[crate_type = \"lib\"]\n LL | |\n LL | | struct Foo {\n    | |_\n \n-error: Found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n+error: found an empty line after an outer attribute. Perhaps you forgot to add a `!` to make it an inner attribute?\n   --> $DIR/empty_line_after_outer_attribute.rs:51:1\n    |\n LL | / #[crate_type = \"lib\"]"}, {"sha": "150acfbfee75996fd89b882784a26fcbc3a5e002", "filename": "tests/ui/extra_unused_lifetimes.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fextra_unused_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fextra_unused_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_lifetimes.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,10 @@\n-#![allow(unused, dead_code, clippy::needless_lifetimes, clippy::needless_pass_by_value)]\n+#![allow(\n+    unused,\n+    dead_code,\n+    clippy::needless_lifetimes,\n+    clippy::needless_pass_by_value,\n+    clippy::needless_arbitrary_self_type\n+)]\n #![warn(clippy::extra_unused_lifetimes)]\n \n fn empty() {}"}, {"sha": "ebdb8e749520fed2bd95045043b76e60f5829543", "filename": "tests/ui/extra_unused_lifetimes.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fextra_unused_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fextra_unused_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_lifetimes.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,25 +1,25 @@\n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:8:14\n+  --> $DIR/extra_unused_lifetimes.rs:14:14\n    |\n LL | fn unused_lt<'a>(x: u8) {}\n    |              ^^\n    |\n    = note: `-D clippy::extra-unused-lifetimes` implied by `-D warnings`\n \n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:10:25\n+  --> $DIR/extra_unused_lifetimes.rs:16:25\n    |\n LL | fn unused_lt_transitive<'a, 'b: 'a>(x: &'b u8) {\n    |                         ^^\n \n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:35:10\n+  --> $DIR/extra_unused_lifetimes.rs:41:10\n    |\n LL |     fn x<'a>(&self) {}\n    |          ^^\n \n error: this lifetime isn't used in the function definition\n-  --> $DIR/extra_unused_lifetimes.rs:61:22\n+  --> $DIR/extra_unused_lifetimes.rs:67:22\n    |\n LL |         fn unused_lt<'a>(x: u8) {}\n    |                      ^^"}, {"sha": "c640c82d6d7c991e9df76d297118ea3de576a4cf", "filename": "tests/ui/functions_maxlines.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ffunctions_maxlines.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ffunctions_maxlines.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffunctions_maxlines.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: This function has a large number of lines.\n+error: this function has a large number of lines\n   --> $DIR/functions_maxlines.rs:58:1\n    |\n LL | / fn bad_lines() {"}, {"sha": "928b6acb95101648f9f4465e5a8495cbb79fa06c", "filename": "tests/ui/iter_skip_next.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fiter_skip_next.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fiter_skip_next.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_skip_next.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+// aux-build:option_helpers.rs\n+\n+#![warn(clippy::iter_skip_next)]\n+#![allow(clippy::blacklisted_name)]\n+#![allow(clippy::iter_nth)]\n+\n+extern crate option_helpers;\n+\n+use option_helpers::IteratorFalsePositives;\n+\n+/// Checks implementation of `ITER_SKIP_NEXT` lint\n+fn main() {\n+    let some_vec = vec![0, 1, 2, 3];\n+    let _ = some_vec.iter().nth(42);\n+    let _ = some_vec.iter().cycle().nth(42);\n+    let _ = (1..10).nth(10);\n+    let _ = &some_vec[..].iter().nth(3);\n+    let foo = IteratorFalsePositives { foo: 0 };\n+    let _ = foo.skip(42).next();\n+    let _ = foo.filter().skip(42).next();\n+}"}, {"sha": "7075e2598ebee2903cdb6d70ab922190ccc2ec62", "filename": "tests/ui/iter_skip_next.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_skip_next.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,15 +1,17 @@\n+// run-rustfix\n // aux-build:option_helpers.rs\n \n #![warn(clippy::iter_skip_next)]\n #![allow(clippy::blacklisted_name)]\n+#![allow(clippy::iter_nth)]\n \n extern crate option_helpers;\n \n use option_helpers::IteratorFalsePositives;\n \n /// Checks implementation of `ITER_SKIP_NEXT` lint\n-fn iter_skip_next() {\n-    let mut some_vec = vec![0, 1, 2, 3];\n+fn main() {\n+    let some_vec = vec![0, 1, 2, 3];\n     let _ = some_vec.iter().skip(42).next();\n     let _ = some_vec.iter().cycle().skip(42).next();\n     let _ = (1..10).skip(10).next();\n@@ -18,5 +20,3 @@ fn iter_skip_next() {\n     let _ = foo.skip(42).next();\n     let _ = foo.filter().skip(42).next();\n }\n-\n-fn main() {}"}, {"sha": "feedc2f288a2bf81855ae6a2b49507c0fcac44fa", "filename": "tests/ui/iter_skip_next.stderr", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fiter_skip_next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fiter_skip_next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_skip_next.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,35 +1,28 @@\n error: called `skip(x).next()` on an iterator\n-  --> $DIR/iter_skip_next.rs:13:13\n+  --> $DIR/iter_skip_next.rs:15:28\n    |\n LL |     let _ = some_vec.iter().skip(42).next();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(42)`\n    |\n    = note: `-D clippy::iter-skip-next` implied by `-D warnings`\n-   = help: this is more succinctly expressed by calling `nth(x)`\n \n error: called `skip(x).next()` on an iterator\n-  --> $DIR/iter_skip_next.rs:14:13\n+  --> $DIR/iter_skip_next.rs:16:36\n    |\n LL |     let _ = some_vec.iter().cycle().skip(42).next();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: this is more succinctly expressed by calling `nth(x)`\n+   |                                    ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(42)`\n \n error: called `skip(x).next()` on an iterator\n-  --> $DIR/iter_skip_next.rs:15:13\n+  --> $DIR/iter_skip_next.rs:17:20\n    |\n LL |     let _ = (1..10).skip(10).next();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: this is more succinctly expressed by calling `nth(x)`\n+   |                    ^^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(10)`\n \n error: called `skip(x).next()` on an iterator\n-  --> $DIR/iter_skip_next.rs:16:14\n+  --> $DIR/iter_skip_next.rs:18:33\n    |\n LL |     let _ = &some_vec[..].iter().skip(3).next();\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: this is more succinctly expressed by calling `nth(x)`\n+   |                                 ^^^^^^^^^^^^^^^ help: use `nth` instead: `.nth(3)`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "b5211318a15047e4e9c6f9f079cd2835d34fa01e", "filename": "tests/ui/len_without_is_empty.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_without_is_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_without_is_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -4,14 +4,14 @@\n pub struct PubOne;\n \n impl PubOne {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n }\n \n impl PubOne {\n     // A second impl for this struct -- the error span shouldn't mention this.\n-    pub fn irrelevant(self: &Self) -> bool {\n+    pub fn irrelevant(&self) -> bool {\n         false\n     }\n }\n@@ -21,57 +21,57 @@ pub struct PubAllowed;\n \n #[allow(clippy::len_without_is_empty)]\n impl PubAllowed {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n }\n \n // No `allow` attribute on this impl block, but that doesn't matter -- we only require one on the\n // impl containing `len`.\n impl PubAllowed {\n-    pub fn irrelevant(self: &Self) -> bool {\n+    pub fn irrelevant(&self) -> bool {\n         false\n     }\n }\n \n pub trait PubTraitsToo {\n-    fn len(self: &Self) -> isize;\n+    fn len(&self) -> isize;\n }\n \n impl PubTraitsToo for One {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         0\n     }\n }\n \n pub struct HasIsEmpty;\n \n impl HasIsEmpty {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n \n-    fn is_empty(self: &Self) -> bool {\n+    fn is_empty(&self) -> bool {\n         false\n     }\n }\n \n pub struct HasWrongIsEmpty;\n \n impl HasWrongIsEmpty {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n \n-    pub fn is_empty(self: &Self, x: u32) -> bool {\n+    pub fn is_empty(&self, x: u32) -> bool {\n         false\n     }\n }\n \n struct NotPubOne;\n \n impl NotPubOne {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         // No error; `len` is pub but `NotPubOne` is not exported anyway.\n         1\n     }\n@@ -80,48 +80,48 @@ impl NotPubOne {\n struct One;\n \n impl One {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         // No error; `len` is private; see issue #1085.\n         1\n     }\n }\n \n trait TraitsToo {\n-    fn len(self: &Self) -> isize;\n+    fn len(&self) -> isize;\n     // No error; `len` is private; see issue #1085.\n }\n \n impl TraitsToo for One {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         0\n     }\n }\n \n struct HasPrivateIsEmpty;\n \n impl HasPrivateIsEmpty {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n \n-    fn is_empty(self: &Self) -> bool {\n+    fn is_empty(&self) -> bool {\n         false\n     }\n }\n \n struct Wither;\n \n pub trait WithIsEmpty {\n-    fn len(self: &Self) -> isize;\n-    fn is_empty(self: &Self) -> bool;\n+    fn len(&self) -> isize;\n+    fn is_empty(&self) -> bool;\n }\n \n impl WithIsEmpty for Wither {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         1\n     }\n \n-    fn is_empty(self: &Self) -> bool {\n+    fn is_empty(&self) -> bool {\n         false\n     }\n }"}, {"sha": "d79c300c07445054ec7ca5da083bb4aaf8202f1d", "filename": "tests/ui/len_without_is_empty.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_without_is_empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_without_is_empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_without_is_empty.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -2,7 +2,7 @@ error: item `PubOne` has a public `len` method but no corresponding `is_empty` m\n   --> $DIR/len_without_is_empty.rs:6:1\n    |\n LL | / impl PubOne {\n-LL | |     pub fn len(self: &Self) -> isize {\n+LL | |     pub fn len(&self) -> isize {\n LL | |         1\n LL | |     }\n LL | | }\n@@ -14,15 +14,15 @@ error: trait `PubTraitsToo` has a `len` method but no (possibly inherited) `is_e\n   --> $DIR/len_without_is_empty.rs:37:1\n    |\n LL | / pub trait PubTraitsToo {\n-LL | |     fn len(self: &Self) -> isize;\n+LL | |     fn len(&self) -> isize;\n LL | | }\n    | |_^\n \n error: item `HasIsEmpty` has a public `len` method but a private `is_empty` method\n   --> $DIR/len_without_is_empty.rs:49:1\n    |\n LL | / impl HasIsEmpty {\n-LL | |     pub fn len(self: &Self) -> isize {\n+LL | |     pub fn len(&self) -> isize {\n LL | |         1\n LL | |     }\n ...  |\n@@ -34,7 +34,7 @@ error: item `HasWrongIsEmpty` has a public `len` method but no corresponding `is\n   --> $DIR/len_without_is_empty.rs:61:1\n    |\n LL | / impl HasWrongIsEmpty {\n-LL | |     pub fn len(self: &Self) -> isize {\n+LL | |     pub fn len(&self) -> isize {\n LL | |         1\n LL | |     }\n ...  |"}, {"sha": "d81676a3d9f4801d06f1884e1473c8730bd7597f", "filename": "tests/ui/len_zero.fixed", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_zero.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_zero.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -7,51 +7,51 @@ pub struct One;\n struct Wither;\n \n trait TraitsToo {\n-    fn len(self: &Self) -> isize;\n+    fn len(&self) -> isize;\n     // No error; `len` is private; see issue #1085.\n }\n \n impl TraitsToo for One {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         0\n     }\n }\n \n pub struct HasIsEmpty;\n \n impl HasIsEmpty {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n \n-    fn is_empty(self: &Self) -> bool {\n+    fn is_empty(&self) -> bool {\n         false\n     }\n }\n \n pub struct HasWrongIsEmpty;\n \n impl HasWrongIsEmpty {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n \n-    pub fn is_empty(self: &Self, x: u32) -> bool {\n+    pub fn is_empty(&self, x: u32) -> bool {\n         false\n     }\n }\n \n pub trait WithIsEmpty {\n-    fn len(self: &Self) -> isize;\n-    fn is_empty(self: &Self) -> bool;\n+    fn len(&self) -> isize;\n+    fn is_empty(&self) -> bool;\n }\n \n impl WithIsEmpty for Wither {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         1\n     }\n \n-    fn is_empty(self: &Self) -> bool {\n+    fn is_empty(&self) -> bool {\n         false\n     }\n }"}, {"sha": "ecdba921a5d0fde97fa67b5a3a455d953d3cdd38", "filename": "tests/ui/len_zero.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flen_zero.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -7,51 +7,51 @@ pub struct One;\n struct Wither;\n \n trait TraitsToo {\n-    fn len(self: &Self) -> isize;\n+    fn len(&self) -> isize;\n     // No error; `len` is private; see issue #1085.\n }\n \n impl TraitsToo for One {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         0\n     }\n }\n \n pub struct HasIsEmpty;\n \n impl HasIsEmpty {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n \n-    fn is_empty(self: &Self) -> bool {\n+    fn is_empty(&self) -> bool {\n         false\n     }\n }\n \n pub struct HasWrongIsEmpty;\n \n impl HasWrongIsEmpty {\n-    pub fn len(self: &Self) -> isize {\n+    pub fn len(&self) -> isize {\n         1\n     }\n \n-    pub fn is_empty(self: &Self, x: u32) -> bool {\n+    pub fn is_empty(&self, x: u32) -> bool {\n         false\n     }\n }\n \n pub trait WithIsEmpty {\n-    fn len(self: &Self) -> isize;\n-    fn is_empty(self: &Self) -> bool;\n+    fn len(&self) -> isize;\n+    fn is_empty(&self) -> bool;\n }\n \n impl WithIsEmpty for Wither {\n-    fn len(self: &Self) -> isize {\n+    fn len(&self) -> isize {\n         1\n     }\n \n-    fn is_empty(self: &Self) -> bool {\n+    fn is_empty(&self) -> bool {\n         false\n     }\n }"}, {"sha": "4f551690c4370ab3b7f2428237f3a0d5e3548180", "filename": "tests/ui/manual_async_fn.fixed", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmanual_async_fn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmanual_async_fn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -43,10 +43,6 @@ impl S {\n         42\n     }\n \n-    async fn meth_fut(&self) -> i32 { 42 }\n-\n-    async fn empty_fut(&self)  {}\n-\n     // should be ignored\n     fn not_fut(&self) -> i32 {\n         42\n@@ -64,4 +60,40 @@ impl S {\n     }\n }\n \n+// Tests related to lifetime capture\n+\n+async fn elided(_: &i32) -> i32 { 42 }\n+\n+// should be ignored\n+fn elided_not_bound(_: &i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+async fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> i32 { 42 }\n+\n+// should be ignored\n+#[allow(clippy::needless_lifetimes)]\n+fn explicit_not_bound<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+mod issue_5765 {\n+    use std::future::Future;\n+\n+    struct A;\n+    impl A {\n+        fn f(&self) -> impl Future<Output = ()> {\n+            async {}\n+        }\n+    }\n+\n+    fn test() {\n+        let _future = {\n+            let a = A;\n+            a.f()\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "6ed60309947a81b27f5e2a2b7a559cdbbacf9b7e", "filename": "tests/ui/manual_async_fn.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -51,14 +51,6 @@ impl S {\n         }\n     }\n \n-    fn meth_fut(&self) -> impl Future<Output = i32> {\n-        async { 42 }\n-    }\n-\n-    fn empty_fut(&self) -> impl Future<Output = ()> {\n-        async {}\n-    }\n-\n     // should be ignored\n     fn not_fut(&self) -> i32 {\n         42\n@@ -76,4 +68,44 @@ impl S {\n     }\n }\n \n+// Tests related to lifetime capture\n+\n+fn elided(_: &i32) -> impl Future<Output = i32> + '_ {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+fn elided_not_bound(_: &i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+#[allow(clippy::needless_lifetimes)]\n+fn explicit_not_bound<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> {\n+    async { 42 }\n+}\n+\n+// should be ignored\n+mod issue_5765 {\n+    use std::future::Future;\n+\n+    struct A;\n+    impl A {\n+        fn f(&self) -> impl Future<Output = ()> {\n+            async {}\n+        }\n+    }\n+\n+    fn test() {\n+        let _future = {\n+            let a = A;\n+            a.f()\n+        };\n+    }\n+}\n+\n fn main() {}"}, {"sha": "ccd828674276ba48cf9c6ba2a0f357edaecc5331", "filename": "tests/ui/manual_async_fn.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmanual_async_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmanual_async_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_async_fn.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -65,34 +65,34 @@ LL |             let c = 21;\n  ...\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:54:5\n+  --> $DIR/manual_async_fn.rs:73:1\n    |\n-LL |     fn meth_fut(&self) -> impl Future<Output = i32> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn elided(_: &i32) -> impl Future<Output = i32> + '_ {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: make the function `async` and return the output of the future directly\n    |\n-LL |     async fn meth_fut(&self) -> i32 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | async fn elided(_: &i32) -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: move the body of the async block to the enclosing function\n    |\n-LL |     fn meth_fut(&self) -> impl Future<Output = i32> { 42 }\n-   |                                                     ^^^^^^\n+LL | fn elided(_: &i32) -> impl Future<Output = i32> + '_ { 42 }\n+   |                                                      ^^^^^^\n \n error: this function can be simplified using the `async fn` syntax\n-  --> $DIR/manual_async_fn.rs:58:5\n+  --> $DIR/manual_async_fn.rs:82:1\n    |\n-LL |     fn empty_fut(&self) -> impl Future<Output = ()> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: make the function `async` and remove the return type\n+help: make the function `async` and return the output of the future directly\n    |\n-LL |     async fn empty_fut(&self)  {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | async fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> i32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: move the body of the async block to the enclosing function\n    |\n-LL |     fn empty_fut(&self) -> impl Future<Output = ()> {}\n-   |                                                     ^^\n+LL | fn explicit<'a, 'b>(_: &'a i32, _: &'b i32) -> impl Future<Output = i32> + 'a + 'b { 42 }\n+   |                                                                                    ^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "a5fdf7df613d325d6b5bf80ed09647806581adb0", "filename": "tests/ui/map_flatten.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -5,6 +5,20 @@\n #![allow(clippy::map_identity)]\n \n fn main() {\n+    // mapping to Option on Iterator\n+    fn option_id(x: i8) -> Option<i8> {\n+        Some(x)\n+    }\n+    let option_id_ref: fn(i8) -> Option<i8> = option_id;\n+    let option_id_closure = |x| Some(x);\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id).collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_ref).collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_closure).collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(|x| x.checked_add(1)).collect();\n+\n+    // mapping to Iterator on Iterator\n     let _: Vec<_> = vec![5_i8; 6].into_iter().flat_map(|x| 0..x).collect();\n+\n+    // mapping to Option on Option\n     let _: Option<_> = (Some(Some(1))).and_then(|x| x);\n }"}, {"sha": "abbc4e16e567951af8a952810e2a7bce9724d832", "filename": "tests/ui/map_flatten.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -5,6 +5,20 @@\n #![allow(clippy::map_identity)]\n \n fn main() {\n+    // mapping to Option on Iterator\n+    fn option_id(x: i8) -> Option<i8> {\n+        Some(x)\n+    }\n+    let option_id_ref: fn(i8) -> Option<i8> = option_id;\n+    let option_id_closure = |x| Some(x);\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n+\n+    // mapping to Iterator on Iterator\n     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n+\n+    // mapping to Option on Option\n     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n }"}, {"sha": "b6479cd69eac4f49f6a0abf08c55dc3ba7f0224d", "filename": "tests/ui/map_flatten.stderr", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,16 +1,40 @@\n-error: called `map(..).flatten()` on an `Iterator`. This is more succinctly expressed by calling `.flat_map(..)`\n-  --> $DIR/map_flatten.rs:8:21\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:14:46\n    |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `vec![5_i8; 6].into_iter().flat_map(|x| 0..x)`\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n-error: called `map(..).flatten()` on an `Option`. This is more succinctly expressed by calling `.and_then(..)`\n-  --> $DIR/map_flatten.rs:9:24\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:15:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n+\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:16:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n+\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:17:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n+\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:20:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n+\n+error: called `map(..).flatten()` on an `Option`\n+  --> $DIR/map_flatten.rs:23:39\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `(Some(Some(1))).and_then(|x| x)`\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "f7ed72a11cf684b64f8d584cbaa990ae4aa0fa39", "filename": "tests/ui/min_max.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmin_max.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmin_max.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_max.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -6,6 +6,18 @@ use std::cmp::{max, min};\n \n const LARGE: usize = 3;\n \n+struct NotOrd(u64);\n+\n+impl NotOrd {\n+    fn min(self, x: u64) -> NotOrd {\n+        NotOrd(x)\n+    }\n+\n+    fn max(self, x: u64) -> NotOrd {\n+        NotOrd(x)\n+    }\n+}\n+\n fn main() {\n     let x;\n     x = 2usize;\n@@ -30,4 +42,24 @@ fn main() {\n     max(min(s, \"Apple\"), \"Zoo\");\n \n     max(\"Apple\", min(s, \"Zoo\")); // ok\n+\n+    let f = 3f32;\n+    x.min(1).max(3);\n+    x.max(3).min(1);\n+    f.max(3f32).min(1f32);\n+\n+    x.max(1).min(3); // ok\n+    x.min(3).max(1); // ok\n+    f.min(3f32).max(1f32); // ok\n+\n+    max(x.min(1), 3);\n+    min(x.max(1), 3); // ok\n+\n+    s.max(\"Zoo\").min(\"Apple\");\n+    s.min(\"Apple\").max(\"Zoo\");\n+\n+    s.min(\"Zoo\").max(\"Apple\"); // ok\n+\n+    let not_ord = NotOrd(1);\n+    not_ord.min(1).max(3); // ok\n }"}, {"sha": "9f8e26fa406f0e59c7458ec5b54ca234386abf6d", "filename": "tests/ui/min_max.stderr", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmin_max.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fmin_max.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmin_max.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,46 +1,82 @@\n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:12:5\n+  --> $DIR/min_max.rs:24:5\n    |\n LL |     min(1, max(3, x));\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::min-max` implied by `-D warnings`\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:13:5\n+  --> $DIR/min_max.rs:25:5\n    |\n LL |     min(max(3, x), 1);\n    |     ^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:14:5\n+  --> $DIR/min_max.rs:26:5\n    |\n LL |     max(min(x, 1), 3);\n    |     ^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:15:5\n+  --> $DIR/min_max.rs:27:5\n    |\n LL |     max(3, min(x, 1));\n    |     ^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:17:5\n+  --> $DIR/min_max.rs:29:5\n    |\n LL |     my_max(3, my_min(x, 1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:29:5\n+  --> $DIR/min_max.rs:41:5\n    |\n LL |     min(\"Apple\", max(\"Zoo\", s));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this `min`/`max` combination leads to constant result\n-  --> $DIR/min_max.rs:30:5\n+  --> $DIR/min_max.rs:42:5\n    |\n LL |     max(min(s, \"Apple\"), \"Zoo\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 7 previous errors\n+error: this `min`/`max` combination leads to constant result\n+  --> $DIR/min_max.rs:47:5\n+   |\n+LL |     x.min(1).max(3);\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: this `min`/`max` combination leads to constant result\n+  --> $DIR/min_max.rs:48:5\n+   |\n+LL |     x.max(3).min(1);\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: this `min`/`max` combination leads to constant result\n+  --> $DIR/min_max.rs:49:5\n+   |\n+LL |     f.max(3f32).min(1f32);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this `min`/`max` combination leads to constant result\n+  --> $DIR/min_max.rs:55:5\n+   |\n+LL |     max(x.min(1), 3);\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: this `min`/`max` combination leads to constant result\n+  --> $DIR/min_max.rs:58:5\n+   |\n+LL |     s.max(\"Zoo\").min(\"Apple\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this `min`/`max` combination leads to constant result\n+  --> $DIR/min_max.rs:59:5\n+   |\n+LL |     s.min(\"Apple\").max(\"Zoo\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "9da21eb6b29b82ff9ce6283373d2f1819c8f0ebb", "filename": "tests/ui/needless_arbitrary_self_type.fixed", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_arbitrary_self_type.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_arbitrary_self_type.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_arbitrary_self_type.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,69 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_arbitrary_self_type)]\n+#![allow(unused_mut, clippy::needless_lifetimes)]\n+\n+pub enum ValType {\n+    A,\n+    B,\n+}\n+\n+impl ValType {\n+    pub fn bad(self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn good(self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_bad(mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_good(mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_bad(&self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_good(&self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_bad_with_lifetime<'a>(&'a self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_good_with_lifetime<'a>(&'a self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_bad(&mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_good(&mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_bad_with_lifetime<'a>(&'a mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_good_with_lifetime<'a>(&'a mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_mut_good(mut self: &mut Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_mut_ref_good(self: &&mut &mut Self) {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "17aeaaf97ac73ab792661dc03cf95f14035746f3", "filename": "tests/ui/needless_arbitrary_self_type.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_arbitrary_self_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_arbitrary_self_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_arbitrary_self_type.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,69 @@\n+// run-rustfix\n+\n+#![warn(clippy::needless_arbitrary_self_type)]\n+#![allow(unused_mut, clippy::needless_lifetimes)]\n+\n+pub enum ValType {\n+    A,\n+    B,\n+}\n+\n+impl ValType {\n+    pub fn bad(self: Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn good(self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_bad(mut self: Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_good(mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_bad(self: &Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_good(&self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_bad_with_lifetime<'a>(self: &'a Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn ref_good_with_lifetime<'a>(&'a self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_bad(self: &mut Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_good(&mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_bad_with_lifetime<'a>(self: &'a mut Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_good_with_lifetime<'a>(&'a mut self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_mut_good(mut self: &mut Self) {\n+        unimplemented!();\n+    }\n+\n+    pub fn mut_ref_mut_ref_good(self: &&mut &mut Self) {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f4c645d35c8f134a05fa4bd1d1665d65a42a4d5a", "filename": "tests/ui/needless_arbitrary_self_type.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_arbitrary_self_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_arbitrary_self_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_arbitrary_self_type.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,40 @@\n+error: the type of the `self` parameter does not need to be arbitrary\n+  --> $DIR/needless_arbitrary_self_type.rs:12:16\n+   |\n+LL |     pub fn bad(self: Self) {\n+   |                ^^^^^^^^^^ help: consider to change this parameter to: `self`\n+   |\n+   = note: `-D clippy::needless-arbitrary-self-type` implied by `-D warnings`\n+\n+error: the type of the `self` parameter does not need to be arbitrary\n+  --> $DIR/needless_arbitrary_self_type.rs:20:20\n+   |\n+LL |     pub fn mut_bad(mut self: Self) {\n+   |                    ^^^^^^^^^^^^^^ help: consider to change this parameter to: `mut self`\n+\n+error: the type of the `self` parameter does not need to be arbitrary\n+  --> $DIR/needless_arbitrary_self_type.rs:28:20\n+   |\n+LL |     pub fn ref_bad(self: &Self) {\n+   |                    ^^^^^^^^^^^ help: consider to change this parameter to: `&self`\n+\n+error: the type of the `self` parameter does not need to be arbitrary\n+  --> $DIR/needless_arbitrary_self_type.rs:36:38\n+   |\n+LL |     pub fn ref_bad_with_lifetime<'a>(self: &'a Self) {\n+   |                                      ^^^^^^^^^^^^^^ help: consider to change this parameter to: `&'a self`\n+\n+error: the type of the `self` parameter does not need to be arbitrary\n+  --> $DIR/needless_arbitrary_self_type.rs:44:24\n+   |\n+LL |     pub fn mut_ref_bad(self: &mut Self) {\n+   |                        ^^^^^^^^^^^^^^^ help: consider to change this parameter to: `&mut self`\n+\n+error: the type of the `self` parameter does not need to be arbitrary\n+  --> $DIR/needless_arbitrary_self_type.rs:52:42\n+   |\n+LL |     pub fn mut_ref_bad_with_lifetime<'a>(self: &'a mut Self) {\n+   |                                          ^^^^^^^^^^^^^^^^^^ help: consider to change this parameter to: `&'a mut self`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "7f2fcf02f6b5bfb6140c7af508af3ee4e8f62765", "filename": "tests/ui/needless_collect.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -5,11 +5,11 @@\n use std::collections::{BTreeSet, HashMap, HashSet};\n \n #[warn(clippy::needless_collect)]\n-#[allow(unused_variables, clippy::iter_cloned_collect)]\n+#[allow(unused_variables, clippy::iter_cloned_collect, clippy::iter_next_slice)]\n fn main() {\n     let sample = [1; 5];\n     let len = sample.iter().count();\n-    if sample.get(0).is_none() {\n+    if sample.iter().next().is_none() {\n         // Empty\n     }\n     sample.iter().cloned().any(|x| x == 1);"}, {"sha": "788a9eb3264ee6c6cf972eeccc45d2c45b7542e2", "filename": "tests/ui/needless_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -5,7 +5,7 @@\n use std::collections::{BTreeSet, HashMap, HashSet};\n \n #[warn(clippy::needless_collect)]\n-#[allow(unused_variables, clippy::iter_cloned_collect)]\n+#[allow(unused_variables, clippy::iter_cloned_collect, clippy::iter_next_slice)]\n fn main() {\n     let sample = [1; 5];\n     let len = sample.iter().collect::<Vec<_>>().len();"}, {"sha": "2a9539d59759d6f73798582868f6f6da667bf6b7", "filename": "tests/ui/needless_collect.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -7,10 +7,10 @@ LL |     let len = sample.iter().collect::<Vec<_>>().len();\n    = note: `-D clippy::needless-collect` implied by `-D warnings`\n \n error: avoid using `collect()` when not needed\n-  --> $DIR/needless_collect.rs:12:15\n+  --> $DIR/needless_collect.rs:12:22\n    |\n LL |     if sample.iter().collect::<Vec<_>>().is_empty() {\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `get(0).is_none()`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `next().is_none()`\n \n error: avoid using `collect()` when not needed\n   --> $DIR/needless_collect.rs:15:28"}, {"sha": "4cf03e820352356b84f873cac15c7fd094a8020b", "filename": "tests/ui/needless_collect_indirect.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,19 @@\n+use std::collections::{HashMap, VecDeque};\n+\n+fn main() {\n+    let sample = [1; 5];\n+    let indirect_iter = sample.iter().collect::<Vec<_>>();\n+    indirect_iter.into_iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+    let indirect_len = sample.iter().collect::<VecDeque<_>>();\n+    indirect_len.len();\n+    let indirect_empty = sample.iter().collect::<VecDeque<_>>();\n+    indirect_empty.is_empty();\n+    let indirect_contains = sample.iter().collect::<VecDeque<_>>();\n+    indirect_contains.contains(&&5);\n+    let indirect_negative = sample.iter().collect::<Vec<_>>();\n+    indirect_negative.len();\n+    indirect_negative\n+        .into_iter()\n+        .map(|x| (*x, *x + 1))\n+        .collect::<HashMap<_, _>>();\n+}"}, {"sha": "0c1e61d749661c5fb4a00652e75f6165407d08a8", "filename": "tests/ui/needless_collect_indirect.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,55 @@\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:5:5\n+   |\n+LL | /     let indirect_iter = sample.iter().collect::<Vec<_>>();\n+LL | |     indirect_iter.into_iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+   | |____^\n+   |\n+   = note: `-D clippy::needless-collect` implied by `-D warnings`\n+help: Use the original Iterator instead of collecting it and then producing a new one\n+   |\n+LL |     \n+LL |     sample.iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:7:5\n+   |\n+LL | /     let indirect_len = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_len.len();\n+   | |____^\n+   |\n+help: Take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL |     \n+LL |     sample.iter().count();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:9:5\n+   |\n+LL | /     let indirect_empty = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_empty.is_empty();\n+   | |____^\n+   |\n+help: Check if the original Iterator has anything instead of collecting it and seeing if it's empty\n+   |\n+LL |     \n+LL |     sample.iter().next().is_none();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:11:5\n+   |\n+LL | /     let indirect_contains = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_contains.contains(&&5);\n+   | |____^\n+   |\n+help: Check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL |     \n+LL |     sample.iter().any(|x| x == &&5);\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c78560007217df78dd4f78a65810cb4956cabfef", "filename": "tests/ui/neg_cmp_op_on_partial_ord.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneg_cmp_op_on_partial_ord.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,24 +1,24 @@\n-error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n+error: the use of negated comparison operators on partially ordered types produces code that is hard to read and refactor, please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable\n   --> $DIR/neg_cmp_op_on_partial_ord.rs:16:21\n    |\n LL |     let _not_less = !(a_value < another_value);\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::neg-cmp-op-on-partial-ord` implied by `-D warnings`\n \n-error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n+error: the use of negated comparison operators on partially ordered types produces code that is hard to read and refactor, please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable\n   --> $DIR/neg_cmp_op_on_partial_ord.rs:19:30\n    |\n LL |     let _not_less_or_equal = !(a_value <= another_value);\n    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n+error: the use of negated comparison operators on partially ordered types produces code that is hard to read and refactor, please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable\n   --> $DIR/neg_cmp_op_on_partial_ord.rs:22:24\n    |\n LL |     let _not_greater = !(a_value > another_value);\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: The use of negated comparison operators on partially ordered types produces code that is hard to read and refactor. Please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable.\n+error: the use of negated comparison operators on partially ordered types produces code that is hard to read and refactor, please consider using the `partial_cmp` method instead, to make it clear that the two values could be incomparable\n   --> $DIR/neg_cmp_op_on_partial_ord.rs:25:33\n    |\n LL |     let _not_greater_or_equal = !(a_value >= another_value);"}, {"sha": "ad677f6d6fb9bf46c897fb122dc798883cb21ac4", "filename": "tests/ui/neg_multiply.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneg_multiply.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fneg_multiply.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneg_multiply.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,12 +1,12 @@\n-error: Negation by multiplying with `-1`\n+error: negation by multiplying with `-1`\n   --> $DIR/neg_multiply.rs:27:5\n    |\n LL |     x * -1;\n    |     ^^^^^^\n    |\n    = note: `-D clippy::neg-multiply` implied by `-D warnings`\n \n-error: Negation by multiplying with `-1`\n+error: negation by multiplying with `-1`\n   --> $DIR/neg_multiply.rs:29:5\n    |\n LL |     -1 * x;"}, {"sha": "96d1c54946c0b40a7cee773d20f4bc6dfe0408ab", "filename": "tests/ui/option_map_unit_fn_fixable.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Foption_map_unit_fn_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Foption_map_unit_fn_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_unit_fn_fixable.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -22,9 +22,9 @@ struct HasOption {\n }\n \n impl HasOption {\n-    fn do_option_nothing(self: &Self, value: usize) {}\n+    fn do_option_nothing(&self, value: usize) {}\n \n-    fn do_option_plus_one(self: &Self, value: usize) -> usize {\n+    fn do_option_plus_one(&self, value: usize) -> usize {\n         value + 1\n     }\n }"}, {"sha": "931ffc18665938cd3af7a9b592ad71f67a4df96d", "filename": "tests/ui/option_map_unit_fn_fixable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Foption_map_unit_fn_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Foption_map_unit_fn_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_unit_fn_fixable.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -22,9 +22,9 @@ struct HasOption {\n }\n \n impl HasOption {\n-    fn do_option_nothing(self: &Self, value: usize) {}\n+    fn do_option_nothing(&self, value: usize) {}\n \n-    fn do_option_plus_one(self: &Self, value: usize) -> usize {\n+    fn do_option_plus_one(&self, value: usize) -> usize {\n         value + 1\n     }\n }"}, {"sha": "67faa8bd4a0aa1f8b2c5eb2a8f86f43df6fd2798", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -116,4 +116,12 @@ fn f() -> Option<()> {\n     Some(())\n }\n \n+// Issue 5886 - const fn (with no arguments)\n+pub fn skip_const_fn_with_no_args() {\n+    const fn foo() -> Option<i32> {\n+        Some(42)\n+    }\n+    let _ = None.or(foo());\n+}\n+\n fn main() {}"}, {"sha": "9867e2eedcff5253eaa86e20bbb24fabd9a046bd", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -116,4 +116,12 @@ fn f() -> Option<()> {\n     Some(())\n }\n \n+// Issue 5886 - const fn (with no arguments)\n+pub fn skip_const_fn_with_no_args() {\n+    const fn foo() -> Option<i32> {\n+        Some(42)\n+    }\n+    let _ = None.or(foo());\n+}\n+\n fn main() {}"}, {"sha": "19e843c2c0a50d5b468a9a2a4447db3bcac7f6e2", "filename": "tests/ui/overflow_check_conditional.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Foverflow_check_conditional.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Foverflow_check_conditional.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foverflow_check_conditional.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,48 +1,48 @@\n-error: You are trying to use classic C overflow conditions that will fail in Rust.\n+error: you are trying to use classic C overflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:8:8\n    |\n LL |     if a + b < a {}\n    |        ^^^^^^^^^\n    |\n    = note: `-D clippy::overflow-check-conditional` implied by `-D warnings`\n \n-error: You are trying to use classic C overflow conditions that will fail in Rust.\n+error: you are trying to use classic C overflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:9:8\n    |\n LL |     if a > a + b {}\n    |        ^^^^^^^^^\n \n-error: You are trying to use classic C overflow conditions that will fail in Rust.\n+error: you are trying to use classic C overflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:10:8\n    |\n LL |     if a + b < b {}\n    |        ^^^^^^^^^\n \n-error: You are trying to use classic C overflow conditions that will fail in Rust.\n+error: you are trying to use classic C overflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:11:8\n    |\n LL |     if b > a + b {}\n    |        ^^^^^^^^^\n \n-error: You are trying to use classic C underflow conditions that will fail in Rust.\n+error: you are trying to use classic C underflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:12:8\n    |\n LL |     if a - b > b {}\n    |        ^^^^^^^^^\n \n-error: You are trying to use classic C underflow conditions that will fail in Rust.\n+error: you are trying to use classic C underflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:13:8\n    |\n LL |     if b < a - b {}\n    |        ^^^^^^^^^\n \n-error: You are trying to use classic C underflow conditions that will fail in Rust.\n+error: you are trying to use classic C underflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:14:8\n    |\n LL |     if a - b > a {}\n    |        ^^^^^^^^^\n \n-error: You are trying to use classic C underflow conditions that will fail in Rust.\n+error: you are trying to use classic C underflow conditions that will fail in Rust\n   --> $DIR/overflow_check_conditional.rs:15:8\n    |\n LL |     if a < a - b {}"}, {"sha": "bb8dce2bbba4b3f4d560b34bd76577cdd5a6b17e", "filename": "tests/ui/path_buf_push_overwrite.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fpath_buf_push_overwrite.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fpath_buf_push_overwrite.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpath_buf_push_overwrite.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: Calling `push` with '/' or '/' (file system root) will overwrite the previous path definition\n+error: calling `push` with '/' or '/' (file system root) will overwrite the previous path definition\n   --> $DIR/path_buf_push_overwrite.rs:7:12\n    |\n LL |     x.push(\"/bar\");"}, {"sha": "dcb5061371f80e94f416288eb13e8fcd7c13d222", "filename": "tests/ui/range.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Frange.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Frange.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frange.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: It is more idiomatic to use `v1.iter().enumerate()`\n+error: it is more idiomatic to use `v1.iter().enumerate()`\n   --> $DIR/range.rs:5:14\n    |\n LL |     let _x = v1.iter().zip(0..v1.len());"}, {"sha": "649831f9c069af3d30a60cbf1d06a14f3b83ab9b", "filename": "tests/ui/redundant_static_lifetimes.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fredundant_static_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fredundant_static_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_static_lifetimes.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,96 +1,96 @@\n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:8:17\n    |\n LL | const VAR_ONE: &'static str = \"Test constant #1\"; // ERROR Consider removing 'static.\n    |                -^^^^^^^---- help: consider removing `'static`: `&str`\n    |\n    = note: `-D clippy::redundant-static-lifetimes` implied by `-D warnings`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:12:21\n    |\n LL | const VAR_THREE: &[&'static str] = &[\"one\", \"two\"]; // ERROR Consider removing 'static\n    |                    -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:14:32\n    |\n LL | const VAR_FOUR: (&str, (&str, &'static str), &'static str) = (\"on\", (\"th\", \"th\"), \"on\"); // ERROR Consider removing 'static\n    |                               -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:14:47\n    |\n LL | const VAR_FOUR: (&str, (&str, &'static str), &'static str) = (\"on\", (\"th\", \"th\"), \"on\"); // ERROR Consider removing 'static\n    |                                              -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:16:17\n    |\n LL | const VAR_SIX: &'static u8 = &5;\n    |                -^^^^^^^--- help: consider removing `'static`: `&u8`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:18:20\n    |\n LL | const VAR_HEIGHT: &'static Foo = &Foo {};\n    |                   -^^^^^^^---- help: consider removing `'static`: `&Foo`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:20:19\n    |\n LL | const VAR_SLICE: &'static [u8] = b\"Test constant #1\"; // ERROR Consider removing 'static.\n    |                  -^^^^^^^----- help: consider removing `'static`: `&[u8]`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:22:19\n    |\n LL | const VAR_TUPLE: &'static (u8, u8) = &(1, 2); // ERROR Consider removing 'static.\n    |                  -^^^^^^^--------- help: consider removing `'static`: `&(u8, u8)`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:24:19\n    |\n LL | const VAR_ARRAY: &'static [u8; 1] = b\"T\"; // ERROR Consider removing 'static.\n    |                  -^^^^^^^-------- help: consider removing `'static`: `&[u8; 1]`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:26:25\n    |\n LL | static STATIC_VAR_ONE: &'static str = \"Test static #1\"; // ERROR Consider removing 'static.\n    |                        -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:30:29\n    |\n LL | static STATIC_VAR_THREE: &[&'static str] = &[\"one\", \"two\"]; // ERROR Consider removing 'static\n    |                            -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:32:25\n    |\n LL | static STATIC_VAR_SIX: &'static u8 = &5;\n    |                        -^^^^^^^--- help: consider removing `'static`: `&u8`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:34:28\n    |\n LL | static STATIC_VAR_HEIGHT: &'static Foo = &Foo {};\n    |                           -^^^^^^^---- help: consider removing `'static`: `&Foo`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:36:27\n    |\n LL | static STATIC_VAR_SLICE: &'static [u8] = b\"Test static #3\"; // ERROR Consider removing 'static.\n    |                          -^^^^^^^----- help: consider removing `'static`: `&[u8]`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:38:27\n    |\n LL | static STATIC_VAR_TUPLE: &'static (u8, u8) = &(1, 2); // ERROR Consider removing 'static.\n    |                          -^^^^^^^--------- help: consider removing `'static`: `&(u8, u8)`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes.rs:40:27\n    |\n LL | static STATIC_VAR_ARRAY: &'static [u8; 1] = b\"T\"; // ERROR Consider removing 'static."}, {"sha": "cc7e55a757a32895778366d2974b2cef05075183", "filename": "tests/ui/redundant_static_lifetimes_multiple.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fredundant_static_lifetimes_multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fredundant_static_lifetimes_multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_static_lifetimes_multiple.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,60 +1,60 @@\n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:3:18\n    |\n LL | const VAR_FIVE: &'static [&[&'static str]] = &[&[\"test\"], &[\"other one\"]]; // ERROR Consider removing 'static\n    |                 -^^^^^^^------------------ help: consider removing `'static`: `&[&[&'static str]]`\n    |\n    = note: `-D clippy::redundant-static-lifetimes` implied by `-D warnings`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:3:30\n    |\n LL | const VAR_FIVE: &'static [&[&'static str]] = &[&[\"test\"], &[\"other one\"]]; // ERROR Consider removing 'static\n    |                             -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:5:29\n    |\n LL | const VAR_SEVEN: &[&(&str, &'static [&'static str])] = &[&(\"one\", &[\"other one\"])];\n    |                            -^^^^^^^--------------- help: consider removing `'static`: `&[&'static str]`\n \n-error: Constants have by default a `'static` lifetime\n+error: constants have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:5:39\n    |\n LL | const VAR_SEVEN: &[&(&str, &'static [&'static str])] = &[&(\"one\", &[\"other one\"])];\n    |                                      -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:7:40\n    |\n LL | static STATIC_VAR_FOUR: (&str, (&str, &'static str), &'static str) = (\"on\", (\"th\", \"th\"), \"on\"); // ERROR Consider removing 'static\n    |                                       -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:7:55\n    |\n LL | static STATIC_VAR_FOUR: (&str, (&str, &'static str), &'static str) = (\"on\", (\"th\", \"th\"), \"on\"); // ERROR Consider removing 'static\n    |                                                      -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:9:26\n    |\n LL | static STATIC_VAR_FIVE: &'static [&[&'static str]] = &[&[\"test\"], &[\"other one\"]]; // ERROR Consider removing 'static\n    |                         -^^^^^^^------------------ help: consider removing `'static`: `&[&[&'static str]]`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:9:38\n    |\n LL | static STATIC_VAR_FIVE: &'static [&[&'static str]] = &[&[\"test\"], &[\"other one\"]]; // ERROR Consider removing 'static\n    |                                     -^^^^^^^---- help: consider removing `'static`: `&str`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:11:37\n    |\n LL | static STATIC_VAR_SEVEN: &[&(&str, &'static [&'static str])] = &[&(\"one\", &[\"other one\"])];\n    |                                    -^^^^^^^--------------- help: consider removing `'static`: `&[&'static str]`\n \n-error: Statics have by default a `'static` lifetime\n+error: statics have by default a `'static` lifetime\n   --> $DIR/redundant_static_lifetimes_multiple.rs:11:47\n    |\n LL | static STATIC_VAR_SEVEN: &[&(&str, &'static [&'static str])] = &[&(\"one\", &[\"other one\"])];"}, {"sha": "88046762483567d267329223c4c81aa6fc87b8f8", "filename": "tests/ui/renamed_builtin_attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Frenamed_builtin_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Frenamed_builtin_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frenamed_builtin_attr.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: Usage of deprecated attribute\n+error: usage of deprecated attribute\n   --> $DIR/renamed_builtin_attr.rs:3:11\n    |\n LL | #[clippy::cyclomatic_complexity = \"1\"]"}, {"sha": "631042c616bc0cd261579f32aa06c43e9526b151", "filename": "tests/ui/result_map_unit_fn_fixable.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fresult_map_unit_fn_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fresult_map_unit_fn_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unit_fn_fixable.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -18,9 +18,9 @@ struct HasResult {\n }\n \n impl HasResult {\n-    fn do_result_nothing(self: &Self, value: usize) {}\n+    fn do_result_nothing(&self, value: usize) {}\n \n-    fn do_result_plus_one(self: &Self, value: usize) -> usize {\n+    fn do_result_plus_one(&self, value: usize) -> usize {\n         value + 1\n     }\n }"}, {"sha": "679eb2326268c7a62fba3a04b228d9bbf4a827ee", "filename": "tests/ui/result_map_unit_fn_fixable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fresult_map_unit_fn_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fresult_map_unit_fn_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresult_map_unit_fn_fixable.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -18,9 +18,9 @@ struct HasResult {\n }\n \n impl HasResult {\n-    fn do_result_nothing(self: &Self, value: usize) {}\n+    fn do_result_nothing(&self, value: usize) {}\n \n-    fn do_result_plus_one(self: &Self, value: usize) -> usize {\n+    fn do_result_plus_one(&self, value: usize) -> usize {\n         value + 1\n     }\n }"}, {"sha": "ff1088f86f6470cc2c41256fdd8746d3161bb23b", "filename": "tests/ui/same_item_push.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,89 @@\n+#![warn(clippy::same_item_push)]\n+\n+fn mutate_increment(x: &mut u8) -> u8 {\n+    *x += 1;\n+    *x\n+}\n+\n+fn increment(x: u8) -> u8 {\n+    x + 1\n+}\n+\n+fn main() {\n+    // Test for basic case\n+    let mut spaces = Vec::with_capacity(10);\n+    for _ in 0..10 {\n+        spaces.push(vec![b' ']);\n+    }\n+\n+    let mut vec2: Vec<u8> = Vec::new();\n+    let item = 2;\n+    for _ in 5..=20 {\n+        vec2.push(item);\n+    }\n+\n+    let mut vec3: Vec<u8> = Vec::new();\n+    for _ in 0..15 {\n+        let item = 2;\n+        vec3.push(item);\n+    }\n+\n+    let mut vec4: Vec<u8> = Vec::new();\n+    for _ in 0..15 {\n+        vec4.push(13);\n+    }\n+\n+    // Suggestion should not be given as pushed variable can mutate\n+    let mut vec5: Vec<u8> = Vec::new();\n+    let mut item: u8 = 2;\n+    for _ in 0..30 {\n+        vec5.push(mutate_increment(&mut item));\n+    }\n+\n+    let mut vec6: Vec<u8> = Vec::new();\n+    let mut item: u8 = 2;\n+    let mut item2 = &mut mutate_increment(&mut item);\n+    for _ in 0..30 {\n+        vec6.push(mutate_increment(item2));\n+    }\n+\n+    let mut vec7: Vec<usize> = Vec::new();\n+    for (a, b) in [0, 1, 4, 9, 16].iter().enumerate() {\n+        vec7.push(a);\n+    }\n+\n+    let mut vec8: Vec<u8> = Vec::new();\n+    for i in 0..30 {\n+        vec8.push(increment(i));\n+    }\n+\n+    let mut vec9: Vec<u8> = Vec::new();\n+    for i in 0..30 {\n+        vec9.push(i + i * i);\n+    }\n+\n+    // Suggestion should not be given as there are multiple pushes that are not the same\n+    let mut vec10: Vec<u8> = Vec::new();\n+    let item: u8 = 2;\n+    for _ in 0..30 {\n+        vec10.push(item);\n+        vec10.push(item * 2);\n+    }\n+\n+    // Suggestion should not be given as Vec is not involved\n+    for _ in 0..5 {\n+        println!(\"Same Item Push\");\n+    }\n+\n+    struct A {\n+        kind: u32,\n+    }\n+    let mut vec_a: Vec<A> = Vec::new();\n+    for i in 0..30 {\n+        vec_a.push(A { kind: i });\n+    }\n+    let mut vec12: Vec<u8> = Vec::new();\n+    for a in vec_a {\n+        vec12.push(2u8.pow(a.kind));\n+    }\n+}"}, {"sha": "ddc5d48cd41357471b770872e2e4d05b33af3ab6", "filename": "tests/ui/same_item_push.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsame_item_push.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsame_item_push.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_item_push.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,35 @@\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:16:9\n+   |\n+LL |         spaces.push(vec![b' ']);\n+   |         ^^^^^^\n+   |\n+   = note: `-D clippy::same-item-push` implied by `-D warnings`\n+   = help: try using vec![vec![b' '];SIZE] or spaces.resize(NEW_SIZE, vec![b' '])\n+\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:22:9\n+   |\n+LL |         vec2.push(item);\n+   |         ^^^^\n+   |\n+   = help: try using vec![item;SIZE] or vec2.resize(NEW_SIZE, item)\n+\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:28:9\n+   |\n+LL |         vec3.push(item);\n+   |         ^^^^\n+   |\n+   = help: try using vec![item;SIZE] or vec3.resize(NEW_SIZE, item)\n+\n+error: it looks like the same item is being pushed into this Vec\n+  --> $DIR/same_item_push.rs:33:9\n+   |\n+LL |         vec4.push(13);\n+   |         ^^^^\n+   |\n+   = help: try using vec![13;SIZE] or vec4.resize(NEW_SIZE, 13)\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "8f8f566593152771852c23b33f9902fdea1e31f4", "filename": "tests/ui/stable_sort_primitive.fixed", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fstable_sort_primitive.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fstable_sort_primitive.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,32 @@\n+// run-rustfix\n+#![warn(clippy::stable_sort_primitive)]\n+\n+fn main() {\n+    // positive examples\n+    let mut vec = vec![1, 3, 2];\n+    vec.sort_unstable();\n+    let mut vec = vec![false, false, true];\n+    vec.sort_unstable();\n+    let mut vec = vec!['a', 'A', 'c'];\n+    vec.sort_unstable();\n+    let mut vec = vec![\"ab\", \"cd\", \"ab\", \"bc\"];\n+    vec.sort_unstable();\n+    let mut vec = vec![(2, 1), (1, 2), (2, 5)];\n+    vec.sort_unstable();\n+    let mut vec = vec![[2, 1], [1, 2], [2, 5]];\n+    vec.sort_unstable();\n+    let mut arr = [1, 3, 2];\n+    arr.sort_unstable();\n+    // Negative examples: behavior changes if made unstable\n+    let mut vec = vec![1, 3, 2];\n+    vec.sort_by_key(|i| i / 2);\n+    vec.sort_by(|a, b| (a + b).cmp(&b));\n+    // negative examples - Not of a primitive type\n+    let mut vec_of_complex = vec![String::from(\"hello\"), String::from(\"world!\")];\n+    vec_of_complex.sort();\n+    vec_of_complex.sort_by_key(String::len);\n+    let mut vec = vec![(String::from(\"hello\"), String::from(\"world\"))];\n+    vec.sort();\n+    let mut vec = vec![[String::from(\"hello\"), String::from(\"world\")]];\n+    vec.sort();\n+}"}, {"sha": "f9bd977906718156cb1601699e158ca3686cefa9", "filename": "tests/ui/stable_sort_primitive.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,32 @@\n+// run-rustfix\n+#![warn(clippy::stable_sort_primitive)]\n+\n+fn main() {\n+    // positive examples\n+    let mut vec = vec![1, 3, 2];\n+    vec.sort();\n+    let mut vec = vec![false, false, true];\n+    vec.sort();\n+    let mut vec = vec!['a', 'A', 'c'];\n+    vec.sort();\n+    let mut vec = vec![\"ab\", \"cd\", \"ab\", \"bc\"];\n+    vec.sort();\n+    let mut vec = vec![(2, 1), (1, 2), (2, 5)];\n+    vec.sort();\n+    let mut vec = vec![[2, 1], [1, 2], [2, 5]];\n+    vec.sort();\n+    let mut arr = [1, 3, 2];\n+    arr.sort();\n+    // Negative examples: behavior changes if made unstable\n+    let mut vec = vec![1, 3, 2];\n+    vec.sort_by_key(|i| i / 2);\n+    vec.sort_by(|a, b| (a + b).cmp(&b));\n+    // negative examples - Not of a primitive type\n+    let mut vec_of_complex = vec![String::from(\"hello\"), String::from(\"world!\")];\n+    vec_of_complex.sort();\n+    vec_of_complex.sort_by_key(String::len);\n+    let mut vec = vec![(String::from(\"hello\"), String::from(\"world\"))];\n+    vec.sort();\n+    let mut vec = vec![[String::from(\"hello\"), String::from(\"world\")]];\n+    vec.sort();\n+}"}, {"sha": "b0b729ede48e5cccde3396c0920baaf2cc3d7a33", "filename": "tests/ui/stable_sort_primitive.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fstable_sort_primitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fstable_sort_primitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,46 @@\n+error: Use sort_unstable instead of sort\n+  --> $DIR/stable_sort_primitive.rs:7:5\n+   |\n+LL |     vec.sort();\n+   |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+   |\n+   = note: `-D clippy::stable-sort-primitive` implied by `-D warnings`\n+\n+error: Use sort_unstable instead of sort\n+  --> $DIR/stable_sort_primitive.rs:9:5\n+   |\n+LL |     vec.sort();\n+   |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+\n+error: Use sort_unstable instead of sort\n+  --> $DIR/stable_sort_primitive.rs:11:5\n+   |\n+LL |     vec.sort();\n+   |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+\n+error: Use sort_unstable instead of sort\n+  --> $DIR/stable_sort_primitive.rs:13:5\n+   |\n+LL |     vec.sort();\n+   |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+\n+error: Use sort_unstable instead of sort\n+  --> $DIR/stable_sort_primitive.rs:15:5\n+   |\n+LL |     vec.sort();\n+   |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+\n+error: Use sort_unstable instead of sort\n+  --> $DIR/stable_sort_primitive.rs:17:5\n+   |\n+LL |     vec.sort();\n+   |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n+\n+error: Use sort_unstable instead of sort\n+  --> $DIR/stable_sort_primitive.rs:19:5\n+   |\n+LL |     arr.sort();\n+   |     ^^^^^^^^^^ help: try: `arr.sort_unstable()`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "60c2f3ec9b652159db0b19696b1139ca9a8bff4c", "filename": "tests/ui/suspicious_arithmetic_impl.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsuspicious_arithmetic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -88,3 +88,33 @@ fn main() {}\n fn do_nothing(x: u32) -> u32 {\n     x\n }\n+\n+struct MultipleBinops(u32);\n+\n+impl Add for MultipleBinops {\n+    type Output = MultipleBinops;\n+\n+    // OK: multiple Binops in `add` impl\n+    fn add(self, other: Self) -> Self::Output {\n+        let mut result = self.0 + other.0;\n+        if result >= u32::max_value() {\n+            result -= u32::max_value();\n+        }\n+        MultipleBinops(result)\n+    }\n+}\n+\n+impl Mul for MultipleBinops {\n+    type Output = MultipleBinops;\n+\n+    // OK: multiple Binops in `mul` impl\n+    fn mul(self, other: Self) -> Self::Output {\n+        let mut result: u32 = 0;\n+        let size = std::cmp::max(self.0, other.0) as usize;\n+        let mut v = vec![0; size + 1];\n+        for i in 0..size + 1 {\n+            result *= i as u32;\n+        }\n+        MultipleBinops(result)\n+    }\n+}"}, {"sha": "23d47e3f1ff085b647451daa653918cf31093863", "filename": "tests/ui/suspicious_arithmetic_impl.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,20 +1,20 @@\n-error: Suspicious use of binary operator in `Add` impl\n+error: suspicious use of binary operator in `Add` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:11:20\n    |\n LL |         Foo(self.0 - other.0)\n    |                    ^\n    |\n    = note: `-D clippy::suspicious-arithmetic-impl` implied by `-D warnings`\n \n-error: Suspicious use of binary operator in `AddAssign` impl\n+error: suspicious use of binary operator in `AddAssign` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:17:23\n    |\n LL |         *self = *self - other;\n    |                       ^\n    |\n    = note: `#[deny(clippy::suspicious_op_assign_impl)]` on by default\n \n-error: Suspicious use of binary operator in `MulAssign` impl\n+error: suspicious use of binary operator in `MulAssign` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:30:16\n    |\n LL |         self.0 /= other.0;"}, {"sha": "cb2b0054e352b4b951dd23f0444bc0c760caf87b", "filename": "tests/ui/trait_duplication_in_bounds.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,31 @@\n+#![deny(clippy::trait_duplication_in_bounds)]\n+\n+use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+\n+fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+where\n+    T: Clone,\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_bar<T: Clone + Default>(arg: T) {\n+    unimplemented!();\n+}\n+\n+fn good_foo<T>(arg: T)\n+where\n+    T: Clone + Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_foobar<T: Default>(arg: T)\n+where\n+    T: Clone,\n+{\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "027e1c752041214d756a812f2308e335d1ff6154", "filename": "tests/ui/trait_duplication_in_bounds.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -0,0 +1,23 @@\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:5:15\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |               ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/trait_duplication_in_bounds.rs:1:9\n+   |\n+LL | #![deny(clippy::trait_duplication_in_bounds)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:5:23\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |                       ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b6f1e83181ccb4cb2bce5d89d5ec24df478fcdc5", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.fixed", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -9,60 +9,48 @@\n \n use std::mem::{size_of, transmute};\n \n-// rustc_typeck::check::cast contains documentation about when a cast `e as U` is \n+// rustc_typeck::check::cast contains documentation about when a cast `e as U` is\n // valid, which we quote from below.\n fn main() {\n     // We should see an error message for each transmute, and no error messages for\n     // the casts, since the casts are the recommended fixes.\n \n     // e is an integer and U is *U_0, while U_0: Sized; addr-ptr-cast\n-    let _ptr_i32_transmute = unsafe {\n-        usize::MAX as *const i32\n-    };\n+    let _ptr_i32_transmute = unsafe { usize::MAX as *const i32 };\n     let ptr_i32 = usize::MAX as *const i32;\n \n     // e has type *T, U is *U_0, and either U_0: Sized ...\n-    let _ptr_i8_transmute = unsafe {\n-        ptr_i32 as *const i8\n-    };\n+    let _ptr_i8_transmute = unsafe { ptr_i32 as *const i8 };\n     let _ptr_i8 = ptr_i32 as *const i8;\n \n-    let slice_ptr = &[0,1,2,3] as *const [i32];\n+    let slice_ptr = &[0, 1, 2, 3] as *const [i32];\n \n     // ... or pointer_kind(T) = pointer_kind(U_0); ptr-ptr-cast\n-    let _ptr_to_unsized_transmute = unsafe {\n-        slice_ptr as *const [u16]\n-    };\n+    let _ptr_to_unsized_transmute = unsafe { slice_ptr as *const [u16] };\n     let _ptr_to_unsized = slice_ptr as *const [u16];\n     // TODO: We could try testing vtable casts here too, but maybe\n     // we should wait until std::raw::TraitObject is stabilized?\n \n     // e has type *T and U is a numeric type, while T: Sized; ptr-addr-cast\n-    let _usize_from_int_ptr_transmute = unsafe {\n-        ptr_i32 as usize\n-    };\n+    let _usize_from_int_ptr_transmute = unsafe { ptr_i32 as usize };\n     let _usize_from_int_ptr = ptr_i32 as usize;\n \n-    let array_ref: &[i32; 4] = &[1,2,3,4];\n+    let array_ref: &[i32; 4] = &[1, 2, 3, 4];\n \n     // e has type &[T; n] and U is *const T; array-ptr-cast\n-    let _array_ptr_transmute = unsafe {\n-        array_ref as *const [i32; 4]\n-    };\n+    let _array_ptr_transmute = unsafe { array_ref as *const [i32; 4] };\n     let _array_ptr = array_ref as *const [i32; 4];\n \n-    fn foo(_: usize) -> u8 { 42 }\n+    fn foo(_: usize) -> u8 {\n+        42\n+    }\n \n     // e is a function pointer type and U has type *T, while T: Sized; fptr-ptr-cast\n-    let _usize_ptr_transmute = unsafe {\n-        foo as *const usize\n-    };\n+    let _usize_ptr_transmute = unsafe { foo as *const usize };\n     let _usize_ptr_transmute = foo as *const usize;\n \n     // e is a function pointer type and U is an integer; fptr-addr-cast\n-    let _usize_from_fn_ptr_transmute = unsafe {\n-        foo as usize\n-    };\n+    let _usize_from_fn_ptr_transmute = unsafe { foo as usize };\n     let _usize_from_fn_ptr = foo as *const usize;\n }\n "}, {"sha": "0205d1ece60d58c3e3fab1c55de5638b8f8011e6", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -9,60 +9,48 @@\n \n use std::mem::{size_of, transmute};\n \n-// rustc_typeck::check::cast contains documentation about when a cast `e as U` is \n+// rustc_typeck::check::cast contains documentation about when a cast `e as U` is\n // valid, which we quote from below.\n fn main() {\n     // We should see an error message for each transmute, and no error messages for\n     // the casts, since the casts are the recommended fixes.\n \n     // e is an integer and U is *U_0, while U_0: Sized; addr-ptr-cast\n-    let _ptr_i32_transmute = unsafe {\n-        transmute::<usize, *const i32>(usize::MAX)\n-    };\n+    let _ptr_i32_transmute = unsafe { transmute::<usize, *const i32>(usize::MAX) };\n     let ptr_i32 = usize::MAX as *const i32;\n \n     // e has type *T, U is *U_0, and either U_0: Sized ...\n-    let _ptr_i8_transmute = unsafe {\n-        transmute::<*const i32, *const i8>(ptr_i32)\n-    };\n+    let _ptr_i8_transmute = unsafe { transmute::<*const i32, *const i8>(ptr_i32) };\n     let _ptr_i8 = ptr_i32 as *const i8;\n \n-    let slice_ptr = &[0,1,2,3] as *const [i32];\n+    let slice_ptr = &[0, 1, 2, 3] as *const [i32];\n \n     // ... or pointer_kind(T) = pointer_kind(U_0); ptr-ptr-cast\n-    let _ptr_to_unsized_transmute = unsafe {\n-        transmute::<*const [i32], *const [u16]>(slice_ptr)\n-    };\n+    let _ptr_to_unsized_transmute = unsafe { transmute::<*const [i32], *const [u16]>(slice_ptr) };\n     let _ptr_to_unsized = slice_ptr as *const [u16];\n     // TODO: We could try testing vtable casts here too, but maybe\n     // we should wait until std::raw::TraitObject is stabilized?\n \n     // e has type *T and U is a numeric type, while T: Sized; ptr-addr-cast\n-    let _usize_from_int_ptr_transmute = unsafe {\n-        transmute::<*const i32, usize>(ptr_i32)\n-    };\n+    let _usize_from_int_ptr_transmute = unsafe { transmute::<*const i32, usize>(ptr_i32) };\n     let _usize_from_int_ptr = ptr_i32 as usize;\n \n-    let array_ref: &[i32; 4] = &[1,2,3,4];\n+    let array_ref: &[i32; 4] = &[1, 2, 3, 4];\n \n     // e has type &[T; n] and U is *const T; array-ptr-cast\n-    let _array_ptr_transmute = unsafe {\n-        transmute::<&[i32; 4], *const [i32; 4]>(array_ref)\n-    };\n+    let _array_ptr_transmute = unsafe { transmute::<&[i32; 4], *const [i32; 4]>(array_ref) };\n     let _array_ptr = array_ref as *const [i32; 4];\n \n-    fn foo(_: usize) -> u8 { 42 }\n+    fn foo(_: usize) -> u8 {\n+        42\n+    }\n \n     // e is a function pointer type and U has type *T, while T: Sized; fptr-ptr-cast\n-    let _usize_ptr_transmute = unsafe {\n-        transmute::<fn(usize) -> u8, *const usize>(foo)\n-    };\n+    let _usize_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, *const usize>(foo) };\n     let _usize_ptr_transmute = foo as *const usize;\n \n     // e is a function pointer type and U is an integer; fptr-addr-cast\n-    let _usize_from_fn_ptr_transmute = unsafe {\n-        transmute::<fn(usize) -> u8, usize>(foo)\n-    };\n+    let _usize_from_fn_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, usize>(foo) };\n     let _usize_from_fn_ptr = foo as *const usize;\n }\n "}, {"sha": "1157b179317e20e9725fe4ef403cd7e9bd320c9e", "filename": "tests/ui/transmutes_expressible_as_ptr_casts.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,53 +1,53 @@\n error: transmute from an integer to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:20:9\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:19:39\n    |\n-LL |         transmute::<usize, *const i32>(usize::MAX)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `usize::MAX as *const i32`\n+LL |     let _ptr_i32_transmute = unsafe { transmute::<usize, *const i32>(usize::MAX) };\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `usize::MAX as *const i32`\n    |\n    = note: `-D clippy::useless-transmute` implied by `-D warnings`\n \n error: transmute from a pointer to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:26:9\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:23:38\n    |\n-LL |         transmute::<*const i32, *const i8>(ptr_i32)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as *const i8`\n+LL |     let _ptr_i8_transmute = unsafe { transmute::<*const i32, *const i8>(ptr_i32) };\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as *const i8`\n    |\n    = note: `-D clippy::transmute-ptr-to-ptr` implied by `-D warnings`\n \n error: transmute from a pointer to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:34:9\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:29:46\n    |\n-LL |         transmute::<*const [i32], *const [u16]>(slice_ptr)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `slice_ptr as *const [u16]`\n+LL |     let _ptr_to_unsized_transmute = unsafe { transmute::<*const [i32], *const [u16]>(slice_ptr) };\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `slice_ptr as *const [u16]`\n \n error: transmute from `*const i32` to `usize` which could be expressed as a pointer cast instead\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:42:9\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:35:50\n    |\n-LL |         transmute::<*const i32, usize>(ptr_i32)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as usize`\n+LL |     let _usize_from_int_ptr_transmute = unsafe { transmute::<*const i32, usize>(ptr_i32) };\n+   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as usize`\n    |\n    = note: `-D clippy::transmutes-expressible-as-ptr-casts` implied by `-D warnings`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:50:9\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:41:41\n    |\n-LL |         transmute::<&[i32; 4], *const [i32; 4]>(array_ref)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `array_ref as *const [i32; 4]`\n+LL |     let _array_ptr_transmute = unsafe { transmute::<&[i32; 4], *const [i32; 4]>(array_ref) };\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `array_ref as *const [i32; 4]`\n \n error: transmute from `fn(usize) -> u8 {main::foo}` to `*const usize` which could be expressed as a pointer cast instead\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:58:9\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:49:41\n    |\n-LL |         transmute::<fn(usize) -> u8, *const usize>(foo)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as *const usize`\n+LL |     let _usize_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, *const usize>(foo) };\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as *const usize`\n \n error: transmute from `fn(usize) -> u8 {main::foo}` to `usize` which could be expressed as a pointer cast instead\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:64:9\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:53:49\n    |\n-LL |         transmute::<fn(usize) -> u8, usize>(foo)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as usize`\n+LL |     let _usize_from_fn_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, usize>(foo) };\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as usize`\n \n error: transmute from a reference to a pointer\n-  --> $DIR/transmutes_expressible_as_ptr_casts.rs:77:14\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:65:14\n    |\n LL |     unsafe { transmute::<&[i32; 1], *const u8>(in_param) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `in_param as *const [i32; 1] as *const u8`"}, {"sha": "9e77dcd8731642567072e5ff8ac0a8a12db38cd5", "filename": "tests/ui/try_err.fixed", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftry_err.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftry_err.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -6,6 +6,9 @@\n #[macro_use]\n extern crate macro_rules;\n \n+use std::io;\n+use std::task::Poll;\n+\n // Tests that a simple case works\n // Should flag `Err(err)?`\n pub fn basic_test() -> Result<i32, i32> {\n@@ -104,3 +107,21 @@ pub fn macro_inside(fail: bool) -> Result<i32, String> {\n     }\n     Ok(0)\n }\n+\n+pub fn poll_write(n: usize) -> Poll<io::Result<usize>> {\n+    if n == 0 {\n+        return Poll::Ready(Err(io::ErrorKind::WriteZero.into()))\n+    } else if n == 1 {\n+        return Poll::Ready(Err(io::Error::new(io::ErrorKind::InvalidInput, \"error\")))\n+    };\n+\n+    Poll::Ready(Ok(n))\n+}\n+\n+pub fn poll_next(ready: bool) -> Poll<Option<io::Result<()>>> {\n+    if !ready {\n+        return Poll::Ready(Some(Err(io::ErrorKind::NotFound.into())))\n+    }\n+\n+    Poll::Ready(None)\n+}"}, {"sha": "41bcb0a189e76de98a567bcb3db02caf9bd82354", "filename": "tests/ui/try_err.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -6,6 +6,9 @@\n #[macro_use]\n extern crate macro_rules;\n \n+use std::io;\n+use std::task::Poll;\n+\n // Tests that a simple case works\n // Should flag `Err(err)?`\n pub fn basic_test() -> Result<i32, i32> {\n@@ -104,3 +107,21 @@ pub fn macro_inside(fail: bool) -> Result<i32, String> {\n     }\n     Ok(0)\n }\n+\n+pub fn poll_write(n: usize) -> Poll<io::Result<usize>> {\n+    if n == 0 {\n+        Err(io::ErrorKind::WriteZero)?\n+    } else if n == 1 {\n+        Err(io::Error::new(io::ErrorKind::InvalidInput, \"error\"))?\n+    };\n+\n+    Poll::Ready(Ok(n))\n+}\n+\n+pub fn poll_next(ready: bool) -> Poll<Option<io::Result<()>>> {\n+    if !ready {\n+        Err(io::ErrorKind::NotFound)?\n+    }\n+\n+    Poll::Ready(None)\n+}"}, {"sha": "3f1cbc17e72d08ff35e90bfc0e9333472d1473f8", "filename": "tests/ui/try_err.stderr", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftry_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Ftry_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftry_err.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,5 +1,5 @@\n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:15:9\n+  --> $DIR/try_err.rs:18:9\n    |\n LL |         Err(err)?;\n    |         ^^^^^^^^^ help: try this: `return Err(err)`\n@@ -11,28 +11,46 @@ LL | #![deny(clippy::try_err)]\n    |         ^^^^^^^^^^^^^^^\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:25:9\n+  --> $DIR/try_err.rs:28:9\n    |\n LL |         Err(err)?;\n    |         ^^^^^^^^^ help: try this: `return Err(err.into())`\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:45:17\n+  --> $DIR/try_err.rs:48:17\n    |\n LL |                 Err(err)?;\n    |                 ^^^^^^^^^ help: try this: `return Err(err)`\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:64:17\n+  --> $DIR/try_err.rs:67:17\n    |\n LL |                 Err(err)?;\n    |                 ^^^^^^^^^ help: try this: `return Err(err.into())`\n \n error: returning an `Err(_)` with the `?` operator\n-  --> $DIR/try_err.rs:103:9\n+  --> $DIR/try_err.rs:106:9\n    |\n LL |         Err(foo!())?;\n    |         ^^^^^^^^^^^^ help: try this: `return Err(foo!())`\n \n-error: aborting due to 5 previous errors\n+error: returning an `Err(_)` with the `?` operator\n+  --> $DIR/try_err.rs:113:9\n+   |\n+LL |         Err(io::ErrorKind::WriteZero)?\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `return Poll::Ready(Err(io::ErrorKind::WriteZero.into()))`\n+\n+error: returning an `Err(_)` with the `?` operator\n+  --> $DIR/try_err.rs:115:9\n+   |\n+LL |         Err(io::Error::new(io::ErrorKind::InvalidInput, \"error\"))?\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `return Poll::Ready(Err(io::Error::new(io::ErrorKind::InvalidInput, \"error\")))`\n+\n+error: returning an `Err(_)` with the `?` operator\n+  --> $DIR/try_err.rs:123:9\n+   |\n+LL |         Err(io::ErrorKind::NotFound)?\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `return Poll::Ready(Some(Err(io::ErrorKind::NotFound.into())))`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "618c5980d64e5bdc83b64b24f9405695cbf6cbef", "filename": "tests/ui/unknown_attribute.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funknown_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funknown_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funknown_attribute.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: Usage of unknown attribute\n+error: usage of unknown attribute\n   --> $DIR/unknown_attribute.rs:1:11\n    |\n LL | #[clippy::unknown]"}, {"sha": "d0a0f219097e5f20b2aa325c345fc2b71128c4d8", "filename": "tests/ui/unnecessary_ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_ref.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,4 +1,4 @@\n-error: Creating a reference that is immediately dereferenced.\n+error: creating a reference that is immediately dereferenced\n   --> $DIR/unnecessary_ref.rs:13:17\n    |\n LL |     let inner = (&outer).inner;"}, {"sha": "31c2ba0f9c5893a21dcaba76b1675b4577746173", "filename": "tests/ui/unnecessary_sort_by.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.fixed?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,5 +1,7 @@\n // run-rustfix\n \n+#![allow(clippy::stable_sort_primitive)]\n+\n use std::cmp::Reverse;\n \n fn unnecessary_sort_by() {"}, {"sha": "a3c8ae468ede73d15a42f79c61141b60aac38e46", "filename": "tests/ui/unnecessary_sort_by.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,5 +1,7 @@\n // run-rustfix\n \n+#![allow(clippy::stable_sort_primitive)]\n+\n use std::cmp::Reverse;\n \n fn unnecessary_sort_by() {"}, {"sha": "70c6cf0a3b63138b25781730faac8a13b9b62efb", "filename": "tests/ui/unnecessary_sort_by.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_sort_by.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funnecessary_sort_by.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_sort_by.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,43 +1,43 @@\n error: use Vec::sort here instead\n-  --> $DIR/unnecessary_sort_by.rs:12:5\n+  --> $DIR/unnecessary_sort_by.rs:14:5\n    |\n LL |     vec.sort_by(|a, b| a.cmp(b));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort()`\n    |\n    = note: `-D clippy::unnecessary-sort-by` implied by `-D warnings`\n \n error: use Vec::sort here instead\n-  --> $DIR/unnecessary_sort_by.rs:13:5\n+  --> $DIR/unnecessary_sort_by.rs:15:5\n    |\n LL |     vec.sort_unstable_by(|a, b| a.cmp(b));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable()`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:14:5\n+  --> $DIR/unnecessary_sort_by.rs:16:5\n    |\n LL |     vec.sort_by(|a, b| (a + 5).abs().cmp(&(b + 5).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&a| (a + 5).abs())`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:15:5\n+  --> $DIR/unnecessary_sort_by.rs:17:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-a).cmp(&id(-b)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&a| id(-a))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:17:5\n+  --> $DIR/unnecessary_sort_by.rs:19:5\n    |\n LL |     vec.sort_by(|a, b| b.cmp(a));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse(b))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:18:5\n+  --> $DIR/unnecessary_sort_by.rs:20:5\n    |\n LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a + 5).abs()));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse((b + 5).abs()))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/unnecessary_sort_by.rs:19:5\n+  --> $DIR/unnecessary_sort_by.rs:21:5\n    |\n LL |     vec.sort_unstable_by(|a, b| id(-b).cmp(&id(-a)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_unstable_by_key(|&b| Reverse(id(-b)))`"}, {"sha": "b8d3c2945322b66e6e59859595fb44a12379ebc9", "filename": "tests/ui/unneeded_field_pattern.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funneeded_field_pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funneeded_field_pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funneeded_field_pattern.stderr?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -1,19 +1,19 @@\n-error: You matched a field with a wildcard pattern. Consider using `..` instead\n+error: you matched a field with a wildcard pattern, consider using `..` instead\n   --> $DIR/unneeded_field_pattern.rs:14:15\n    |\n LL |         Foo { a: _, b: 0, .. } => {},\n    |               ^^^^\n    |\n    = note: `-D clippy::unneeded-field-pattern` implied by `-D warnings`\n-   = help: Try with `Foo { b: 0, .. }`\n+   = help: try with `Foo { b: 0, .. }`\n \n-error: All the struct fields are matched to a wildcard pattern, consider using `..`.\n+error: all the struct fields are matched to a wildcard pattern, consider using `..`\n   --> $DIR/unneeded_field_pattern.rs:16:9\n    |\n LL |         Foo { a: _, b: _, c: _ } => {},\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: Try with `Foo { .. }` instead\n+   = help: try with `Foo { .. }` instead\n \n error: aborting due to 2 previous errors\n "}, {"sha": "690d705573d3f73ae3bba84c7dfb4a97d35e87fb", "filename": "tests/ui/unsafe_derive_deserialize.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funsafe_derive_deserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/027780ca2cd54dc9619058e9082c62f268f5c362/tests%2Fui%2Funsafe_derive_deserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funsafe_derive_deserialize.rs?ref=027780ca2cd54dc9619058e9082c62f268f5c362", "patch": "@@ -57,4 +57,14 @@ impl E {\n #[derive(Deserialize)]\n pub struct F {}\n \n+// Check that we honor the `allow` attribute on the ADT\n+#[allow(clippy::unsafe_derive_deserialize)]\n+#[derive(Deserialize)]\n+pub struct G {}\n+impl G {\n+    pub fn unsafe_block(&self) {\n+        unsafe {}\n+    }\n+}\n+\n fn main() {}"}]}