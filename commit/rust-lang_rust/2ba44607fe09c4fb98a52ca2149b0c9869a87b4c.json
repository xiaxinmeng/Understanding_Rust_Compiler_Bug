{"sha": "2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYTQ0NjA3ZmUwOWM0ZmI5OGE1MmNhMjE0OWIwYzk4NjlhODdiNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-22T23:01:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-22T23:01:56Z"}, "message": "Auto merge of #28907 - SingingTree:rustfmt_libterm, r=nrc\n\nHey hey,\n\nThis is the result of running rustfmt over the libterm module. The first commit reflects the unaltered changes from rustfmt, and the commit message contains some notes on areas where I thought rustfmt had behaved strangely. The second commit attempts to fix the strange areas from the first commit.\n\nClarification edit: there are still some areas where I think rustfmt has made changes which may merit discussion (one is noted in the comments below). My second commit only undoes the changes that I figured would not warrant discussion (based on my opinion of the style, which is of course subjective).\n\nr? @nrc", "tree": {"sha": "4392289508e09c0cd620bbbd349ed6dd224f5a5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4392289508e09c0cd620bbbd349ed6dd224f5a5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "html_url": "https://github.com/rust-lang/rust/commit/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2847a9999661316140832d5a364db44dd041f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2847a9999661316140832d5a364db44dd041f74", "html_url": "https://github.com/rust-lang/rust/commit/a2847a9999661316140832d5a364db44dd041f74"}, {"sha": "7d54c32c94766890cd8ab87221edb71ae10b1e91", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d54c32c94766890cd8ab87221edb71ae10b1e91", "html_url": "https://github.com/rust-lang/rust/commit/7d54c32c94766890cd8ab87221edb71ae10b1e91"}], "stats": {"total": 897, "additions": 507, "deletions": 390}, "files": [{"sha": "f33530f93d111c05819a5d90e1a5c49e7754dcb5", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "patch": "@@ -63,8 +63,12 @@\n #![feature(str_char)]\n #![feature(vec_push_all)]\n #![cfg_attr(windows, feature(libc))]\n+// Handle rustfmt skips\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n \n-#[macro_use] extern crate log;\n+#[macro_use]\n+extern crate log;\n \n pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]\n@@ -100,53 +104,37 @@ impl Write for WriterWrapper {\n /// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stdout(),\n-    })\n+    TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stdout() })\n }\n \n #[cfg(windows)]\n /// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stdout(),\n-    });\n+    let ti = TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stdout() });\n \n     match ti {\n         Some(t) => Some(t),\n-        None => {\n-            WinConsole::new(WriterWrapper {\n-                wrapped: box std::io::stdout(),\n-            })\n-        }\n+        None => WinConsole::new(WriterWrapper { wrapped: box std::io::stdout() }),\n     }\n }\n \n #[cfg(not(windows))]\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stderr(),\n-    })\n+    TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stderr() })\n }\n \n #[cfg(windows)]\n /// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n-    let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stderr(),\n-    });\n+    let ti = TerminfoTerminal::new(WriterWrapper { wrapped: box std::io::stderr() });\n \n     match ti {\n         Some(t) => Some(t),\n-        None => {\n-            WinConsole::new(WriterWrapper {\n-                wrapped: box std::io::stderr(),\n-            })\n-        }\n+        None => WinConsole::new(WriterWrapper { wrapped: box std::io::stderr() }),\n     }\n }\n \n@@ -157,23 +145,23 @@ pub mod color {\n     /// Number for a terminal color\n     pub type Color = u16;\n \n-    pub const BLACK:   Color = 0;\n-    pub const RED:     Color = 1;\n-    pub const GREEN:   Color = 2;\n-    pub const YELLOW:  Color = 3;\n-    pub const BLUE:    Color = 4;\n+    pub const BLACK: Color = 0;\n+    pub const RED: Color = 1;\n+    pub const GREEN: Color = 2;\n+    pub const YELLOW: Color = 3;\n+    pub const BLUE: Color = 4;\n     pub const MAGENTA: Color = 5;\n-    pub const CYAN:    Color = 6;\n-    pub const WHITE:   Color = 7;\n-\n-    pub const BRIGHT_BLACK:   Color = 8;\n-    pub const BRIGHT_RED:     Color = 9;\n-    pub const BRIGHT_GREEN:   Color = 10;\n-    pub const BRIGHT_YELLOW:  Color = 11;\n-    pub const BRIGHT_BLUE:    Color = 12;\n+    pub const CYAN: Color = 6;\n+    pub const WHITE: Color = 7;\n+\n+    pub const BRIGHT_BLACK: Color = 8;\n+    pub const BRIGHT_RED: Color = 9;\n+    pub const BRIGHT_GREEN: Color = 10;\n+    pub const BRIGHT_YELLOW: Color = 11;\n+    pub const BRIGHT_BLUE: Color = 12;\n     pub const BRIGHT_MAGENTA: Color = 13;\n-    pub const BRIGHT_CYAN:    Color = 14;\n-    pub const BRIGHT_WHITE:   Color = 15;\n+    pub const BRIGHT_CYAN: Color = 14;\n+    pub const BRIGHT_WHITE: Color = 15;\n }\n \n /// Terminal attributes\n@@ -206,7 +194,7 @@ pub mod attr {\n         /// Convenience attribute to set the foreground color\n         ForegroundColor(super::color::Color),\n         /// Convenience attribute to set the background color\n-        BackgroundColor(super::color::Color)\n+        BackgroundColor(super::color::Color),\n     }\n }\n "}, {"sha": "89c22e555ca95f879e4db375d24213c6b5bfa72b", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "patch": "@@ -28,13 +28,13 @@ use self::parm::{expand, Number, Variables};\n #[derive(Debug)]\n pub struct TermInfo {\n     /// Names for the terminal\n-    pub names: Vec<String> ,\n+    pub names: Vec<String>,\n     /// Map of capability name to boolean value\n     pub bools: HashMap<String, bool>,\n     /// Map of capability name to numeric value\n     pub numbers: HashMap<String, u16>,\n     /// Map of capability name to raw (unexpanded) string\n-    pub strings: HashMap<String, Vec<u8> >\n+    pub strings: HashMap<String, Vec<u8>>,\n }\n \n pub mod searcher;\n@@ -49,19 +49,19 @@ pub mod parm;\n \n fn cap_for_attr(attr: attr::Attr) -> &'static str {\n     match attr {\n-        attr::Bold               => \"bold\",\n-        attr::Dim                => \"dim\",\n-        attr::Italic(true)       => \"sitm\",\n-        attr::Italic(false)      => \"ritm\",\n-        attr::Underline(true)    => \"smul\",\n-        attr::Underline(false)   => \"rmul\",\n-        attr::Blink              => \"blink\",\n-        attr::Standout(true)     => \"smso\",\n-        attr::Standout(false)    => \"rmso\",\n-        attr::Reverse            => \"rev\",\n-        attr::Secure             => \"invis\",\n+        attr::Bold => \"bold\",\n+        attr::Dim => \"dim\",\n+        attr::Italic(true) => \"sitm\",\n+        attr::Italic(false) => \"ritm\",\n+        attr::Underline(true) => \"smul\",\n+        attr::Underline(false) => \"rmul\",\n+        attr::Blink => \"blink\",\n+        attr::Standout(true) => \"smso\",\n+        attr::Standout(false) => \"rmso\",\n+        attr::Reverse => \"rev\",\n+        attr::Secure => \"invis\",\n         attr::ForegroundColor(_) => \"setaf\",\n-        attr::BackgroundColor(_) => \"setab\"\n+        attr::BackgroundColor(_) => \"setab\",\n     }\n }\n \n@@ -70,7 +70,7 @@ fn cap_for_attr(attr: attr::Attr) -> &'static str {\n pub struct TerminfoTerminal<T> {\n     num_colors: u16,\n     out: T,\n-    ti: Box<TermInfo>\n+    ti: Box<TermInfo>,\n }\n \n impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n@@ -80,12 +80,12 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n             let s = expand(self.ti\n                                .strings\n                                .get(\"setaf\")\n-                               .unwrap()\n-                               ,\n-                           &[Number(color as isize)], &mut Variables::new());\n+                               .unwrap(),\n+                           &[Number(color as isize)],\n+                           &mut Variables::new());\n             if s.is_ok() {\n                 try!(self.out.write_all(&s.unwrap()));\n-                return Ok(true)\n+                return Ok(true);\n             }\n         }\n         Ok(false)\n@@ -97,12 +97,12 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n             let s = expand(self.ti\n                                .strings\n                                .get(\"setab\")\n-                               .unwrap()\n-                               ,\n-                           &[Number(color as isize)], &mut Variables::new());\n+                               .unwrap(),\n+                           &[Number(color as isize)],\n+                           &mut Variables::new());\n             if s.is_ok() {\n                 try!(self.out.write_all(&s.unwrap()));\n-                return Ok(true)\n+                return Ok(true);\n             }\n         }\n         Ok(false)\n@@ -116,12 +116,10 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n                 let cap = cap_for_attr(attr);\n                 let parm = self.ti.strings.get(cap);\n                 if parm.is_some() {\n-                    let s = expand(parm.unwrap(),\n-                                   &[],\n-                                   &mut Variables::new());\n+                    let s = expand(parm.unwrap(), &[], &mut Variables::new());\n                     if s.is_ok() {\n                         try!(self.out.write_all(&s.unwrap()));\n-                        return Ok(true)\n+                        return Ok(true);\n                     }\n                 }\n                 Ok(false)\n@@ -131,9 +129,7 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n \n     fn supports_attr(&self, attr: attr::Attr) -> bool {\n         match attr {\n-            attr::ForegroundColor(_) | attr::BackgroundColor(_) => {\n-                self.num_colors > 0\n-            }\n+            attr::ForegroundColor(_) | attr::BackgroundColor(_) => self.num_colors > 0,\n             _ => {\n                 let cap = cap_for_attr(attr);\n                 self.ti.strings.get(cap).is_some()\n@@ -151,28 +147,33 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n                 cap = self.ti.strings.get(\"op\");\n             }\n         }\n-        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_owned()), |op| {\n-            expand(op, &[], &mut Variables::new())\n-        });\n+        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_owned()),\n+                           |op| expand(op, &[], &mut Variables::new()));\n         if s.is_ok() {\n-            return self.out.write_all(&s.unwrap())\n+            return self.out.write_all(&s.unwrap());\n         }\n         Ok(())\n     }\n \n-    fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n+    fn get_ref<'a>(&'a self) -> &'a T {\n+        &self.out\n+    }\n \n-    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T {\n+        &mut self.out\n+    }\n }\n \n impl<T: Write+Send+'static> UnwrappableTerminal<T> for TerminfoTerminal<T> {\n-    fn unwrap(self) -> T { self.out }\n+    fn unwrap(self) -> T {\n+        self.out\n+    }\n }\n \n impl<T: Write+Send+'static> TerminfoTerminal<T> {\n     /// Returns `None` whenever the terminal cannot be created for some\n     /// reason.\n-    pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n+    pub fn new(out: T) -> Option<Box<Terminal<T> + Send + 'static>> {\n         let term = match env::var(\"TERM\") {\n             Ok(t) => t,\n             Err(..) => {\n@@ -183,20 +184,22 @@ impl<T: Write+Send+'static> TerminfoTerminal<T> {\n \n         let mut file = match open(&term[..]) {\n             Ok(f) => f,\n-            Err(err) => return match env::var(\"MSYSCON\") {\n-                Ok(ref val) if &val[..] == \"mintty.exe\" => {\n-                    // msys terminal\n-                    Some(box TerminfoTerminal{\n-                        out: out,\n-                        ti: msys_terminfo(),\n-                        num_colors: 8,\n-                    })\n-                },\n-                _ => {\n-                    debug!(\"error finding terminfo entry: {:?}\", err);\n-                    None\n-                },\n-            },\n+            Err(err) => {\n+                return match env::var(\"MSYSCON\") {\n+                    Ok(ref val) if &val[..] == \"mintty.exe\" => {\n+                        // msys terminal\n+                        Some(box TerminfoTerminal {\n+                            out: out,\n+                            ti: msys_terminfo(),\n+                            num_colors: 8,\n+                        })\n+                    }\n+                    _ => {\n+                        debug!(\"error finding terminfo entry: {:?}\", err);\n+                        None\n+                    }\n+                };\n+            }\n         };\n \n         let ti = parse(&mut file, false);\n@@ -206,20 +209,25 @@ impl<T: Write+Send+'static> TerminfoTerminal<T> {\n         }\n \n         let inf = ti.unwrap();\n-        let nc = if inf.strings.get(\"setaf\").is_some()\n-                 && inf.strings.get(\"setab\").is_some() {\n-                     inf.numbers.get(\"colors\").map_or(0, |&n| n)\n-                 } else { 0 };\n-\n-        Some(box TerminfoTerminal {out: out,\n-                                   ti: inf,\n-                                   num_colors: nc})\n+        let nc = if inf.strings.get(\"setaf\").is_some() && inf.strings.get(\"setab\").is_some() {\n+            inf.numbers.get(\"colors\").map_or(0, |&n| n)\n+        } else {\n+            0\n+        };\n+\n+        Some(box TerminfoTerminal {\n+            out: out,\n+            ti: inf,\n+            num_colors: nc,\n+        })\n     }\n \n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n         if color >= self.num_colors && color >= 8 && color < 16 {\n-            color-8\n-        } else { color }\n+            color - 8\n+        } else {\n+            color\n+        }\n     }\n }\n "}, {"sha": "49db096ce7332c88ac782c38b7b3acb0a4f0b922", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 337, "deletions": 227, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "patch": "@@ -32,52 +32,44 @@ enum States {\n     SeekIfElse(isize),\n     SeekIfElsePercent(isize),\n     SeekIfEnd(isize),\n-    SeekIfEndPercent(isize)\n+    SeekIfEndPercent(isize),\n }\n \n #[derive(Copy, Clone, PartialEq)]\n enum FormatState {\n     FormatStateFlags,\n     FormatStateWidth,\n-    FormatStatePrecision\n+    FormatStatePrecision,\n }\n \n /// Types of parameters a capability can use\n #[allow(missing_docs)]\n #[derive(Clone)]\n pub enum Param {\n     Words(String),\n-    Number(isize)\n+    Number(isize),\n }\n \n /// Container for static and dynamic variable arrays\n pub struct Variables {\n     /// Static variables A-Z\n     sta: [Param; 26],\n     /// Dynamic variables a-z\n-    dyn: [Param; 26]\n+    dyn: [Param; 26],\n }\n \n impl Variables {\n     /// Return a new zero-initialized Variables\n     pub fn new() -> Variables {\n         Variables {\n-            sta: [\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0),\n-            ],\n-            dyn: [\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0), Number(0), Number(0), Number(0), Number(0),\n-                Number(0),\n-            ],\n+            sta: [Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                  Number(0), Number(0), Number(0), Number(0), Number(0)],\n+            dyn: [Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                  Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                  Number(0), Number(0), Number(0), Number(0), Number(0)],\n         }\n     }\n }\n@@ -91,8 +83,7 @@ impl Variables {\n ///\n /// To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n /// multiple capabilities for the same terminal.\n-pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n-    -> Result<Vec<u8> , String> {\n+pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<u8>, String> {\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n@@ -101,10 +92,8 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n     let mut stack: Vec<Param> = Vec::new();\n \n     // Copy parameters into a local vector for mutability\n-    let mut mparams = [\n-        Number(0), Number(0), Number(0), Number(0), Number(0),\n-        Number(0), Number(0), Number(0), Number(0),\n-    ];\n+    let mut mparams = [Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                       Number(0), Number(0), Number(0)];\n     for (dst, src) in mparams.iter_mut().zip(params) {\n         *dst = (*src).clone();\n     }\n@@ -119,147 +108,241 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 } else {\n                     output.push(c);\n                 }\n-            },\n+            }\n             Percent => {\n                 match cur {\n-                    '%' => { output.push(c); state = Nothing },\n-                    'c' => if !stack.is_empty() {\n-                        match stack.pop().unwrap() {\n-                            // if c is 0, use 0200 (128) for ncurses compatibility\n-                            Number(c) => {\n-                                output.push(if c == 0 {\n-                                    128\n-                                } else {\n-                                    c as u8\n-                                })\n+                    '%' => {\n+                        output.push(c);\n+                        state = Nothing\n+                    }\n+                    'c' => {\n+                        if !stack.is_empty() {\n+                            match stack.pop().unwrap() {\n+                                // if c is 0, use 0200 (128) for ncurses compatibility\n+                                Number(c) => {\n+                                    output.push(if c == 0 {\n+                                        128\n+                                    } else {\n+                                        c as u8\n+                                    })\n+                                }\n+                                _ => return Err(\"a non-char was used with %c\".to_owned()),\n                             }\n-                            _       => return Err(\"a non-char was used with %c\".to_owned())\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    }\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n-                    'l' => if !stack.is_empty() {\n-                        match stack.pop().unwrap() {\n-                            Words(s) => stack.push(Number(s.len() as isize)),\n-                            _        => return Err(\"a non-str was used with %l\".to_owned())\n+                    'l' => {\n+                        if !stack.is_empty() {\n+                            match stack.pop().unwrap() {\n+                                Words(s) => stack.push(Number(s.len() as isize)),\n+                                _ => return Err(\"a non-str was used with %l\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '+' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x + y)),\n-                            _ => return Err(\"non-numbers on stack with +\".to_owned())\n+                    }\n+                    '+' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x + y)),\n+                                _ => return Err(\"non-numbers on stack with +\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '-' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x - y)),\n-                            _ => return Err(\"non-numbers on stack with -\".to_owned())\n+                    }\n+                    '-' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x - y)),\n+                                _ => return Err(\"non-numbers on stack with -\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '*' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x * y)),\n-                            _ => return Err(\"non-numbers on stack with *\".to_owned())\n+                    }\n+                    '*' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x * y)),\n+                                _ => return Err(\"non-numbers on stack with *\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '/' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x / y)),\n-                            _ => return Err(\"non-numbers on stack with /\".to_owned())\n+                    }\n+                    '/' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x / y)),\n+                                _ => return Err(\"non-numbers on stack with /\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    'm' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x % y)),\n-                            _ => return Err(\"non-numbers on stack with %\".to_owned())\n+                    }\n+                    'm' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x % y)),\n+                                _ => return Err(\"non-numbers on stack with %\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '&' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x & y)),\n-                            _ => return Err(\"non-numbers on stack with &\".to_owned())\n+                    }\n+                    '&' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x & y)),\n+                                _ => return Err(\"non-numbers on stack with &\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '|' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x | y)),\n-                            _ => return Err(\"non-numbers on stack with |\".to_owned())\n+                    }\n+                    '|' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x | y)),\n+                                _ => return Err(\"non-numbers on stack with |\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '^' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n-                            _ => return Err(\"non-numbers on stack with ^\".to_owned())\n+                    }\n+                    '^' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n+                                _ => return Err(\"non-numbers on stack with ^\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '=' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n-                                                                        else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with =\".to_owned())\n+                    }\n+                    '=' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => {\n+                                    stack.push(Number(if x == y {\n+                                        1\n+                                    } else {\n+                                        0\n+                                    }))\n+                                }\n+                                _ => return Err(\"non-numbers on stack with =\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '>' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n-                                                                        else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with >\".to_owned())\n+                    }\n+                    '>' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => {\n+                                    stack.push(Number(if x > y {\n+                                        1\n+                                    } else {\n+                                        0\n+                                    }))\n+                                }\n+                                _ => return Err(\"non-numbers on stack with >\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '<' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n-                                                                        else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with <\".to_owned())\n+                    }\n+                    '<' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(y), Number(x)) => {\n+                                    stack.push(Number(if x < y {\n+                                        1\n+                                    } else {\n+                                        0\n+                                    }))\n+                                }\n+                                _ => return Err(\"non-numbers on stack with <\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    'A' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(0), Number(_)) => stack.push(Number(0)),\n-                            (Number(_), Number(0)) => stack.push(Number(0)),\n-                            (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical and\".to_owned())\n+                    }\n+                    'A' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(0), Number(_)) => stack.push(Number(0)),\n+                                (Number(_), Number(0)) => stack.push(Number(0)),\n+                                (Number(_), Number(_)) => stack.push(Number(1)),\n+                                _ => return Err(\"non-numbers on stack with logical and\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    'O' => if stack.len() > 1 {\n-                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n-                            (Number(0), Number(0)) => stack.push(Number(0)),\n-                            (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical or\".to_owned())\n+                    }\n+                    'O' => {\n+                        if stack.len() > 1 {\n+                            match (stack.pop().unwrap(), stack.pop().unwrap()) {\n+                                (Number(0), Number(0)) => stack.push(Number(0)),\n+                                (Number(_), Number(_)) => stack.push(Number(1)),\n+                                _ => return Err(\"non-numbers on stack with logical or\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '!' => if !stack.is_empty() {\n-                        match stack.pop().unwrap() {\n-                            Number(0) => stack.push(Number(1)),\n-                            Number(_) => stack.push(Number(0)),\n-                            _ => return Err(\"non-number on stack with logical not\".to_owned())\n+                    }\n+                    '!' => {\n+                        if !stack.is_empty() {\n+                            match stack.pop().unwrap() {\n+                                Number(0) => stack.push(Number(1)),\n+                                Number(_) => stack.push(Number(0)),\n+                                _ => return Err(\"non-number on stack with logical not\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n+                        }\n+                    }\n+                    '~' => {\n+                        if !stack.is_empty() {\n+                            match stack.pop().unwrap() {\n+                                Number(x) => stack.push(Number(!x)),\n+                                _ => return Err(\"non-number on stack with %~\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    '~' => if !stack.is_empty() {\n-                        match stack.pop().unwrap() {\n-                            Number(x) => stack.push(Number(!x)),\n-                            _         => return Err(\"non-number on stack with %~\".to_owned())\n+                    }\n+                    'i' => {\n+                        match (mparams[0].clone(), mparams[1].clone()) {\n+                            (Number(x), Number(y)) => {\n+                                mparams[0] = Number(x + 1);\n+                                mparams[1] = Number(y + 1);\n+                            }\n+                            (_, _) => return Err(\"first two params not numbers with %i\".to_owned()),\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    'i' => match (mparams[0].clone(), mparams[1].clone()) {\n-                        (Number(x), Number(y)) => {\n-                            mparams[0] = Number(x+1);\n-                            mparams[1] = Number(y+1);\n-                        },\n-                        (_, _) => return Err(\"first two params not numbers with %i\".to_owned())\n-                    },\n+                    }\n \n                     // printf-style support for %doxXs\n-                    'd'|'o'|'x'|'X'|'s' => if !stack.is_empty() {\n-                        let flags = Flags::new();\n-                        let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n-                        if res.is_err() { return res }\n-                        output.push_all(&res.unwrap())\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    ':'|'#'|' '|'.'|'0'...'9' => {\n+                    'd' | 'o' | 'x' | 'X' | 's' => {\n+                        if !stack.is_empty() {\n+                            let flags = Flags::new();\n+                            let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n+                            if res.is_err() {\n+                                return res;\n+                            }\n+                            output.push_all(&res.unwrap())\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n+                        }\n+                    }\n+                    ':' | '#' | ' ' | '.' | '0'...'9' => {\n                         let mut flags = Flags::new();\n                         let mut fstate = FormatStateFlags;\n                         match cur {\n@@ -271,51 +354,57 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                                 flags.width = cur as usize - '0' as usize;\n                                 fstate = FormatStateWidth;\n                             }\n-                            _ => unreachable!()\n+                            _ => unreachable!(),\n                         }\n                         state = FormatPattern(flags, fstate);\n                     }\n \n                     // conditionals\n                     '?' => (),\n-                    't' => if !stack.is_empty() {\n-                        match stack.pop().unwrap() {\n-                            Number(0) => state = SeekIfElse(0),\n-                            Number(_) => (),\n-                            _         => return Err(\"non-number on stack \\\n-                                                    with conditional\".to_owned())\n+                    't' => {\n+                        if !stack.is_empty() {\n+                            match stack.pop().unwrap() {\n+                                Number(0) => state = SeekIfElse(0),\n+                                Number(_) => (),\n+                                _ => return Err(\"non-number on stack with conditional\".to_owned()),\n+                            }\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    }\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n-                    _ => {\n-                        return Err(format!(\"unrecognized format option {:?}\", cur))\n-                    }\n+                    _ => return Err(format!(\"unrecognized format option {:?}\", cur)),\n                 }\n-            },\n+            }\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n-                    Some(d) => d as usize - 1,\n-                    None => return Err(\"bad param number\".to_owned())\n-                }].clone());\n-            },\n+                               Some(d) => d as usize - 1,\n+                               None => return Err(\"bad param number\".to_owned()),\n+                           }]\n+                           .clone());\n+            }\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if !stack.is_empty() {\n                         let idx = (cur as u8) - b'A';\n                         vars.sta[idx as usize] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_owned()) }\n+                    } else {\n+                        return Err(\"stack is empty\".to_owned());\n+                    }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if !stack.is_empty() {\n                         let idx = (cur as u8) - b'a';\n                         vars.dyn[idx as usize] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_owned()) }\n+                    } else {\n+                        return Err(\"stack is empty\".to_owned());\n+                    }\n                 } else {\n                     return Err(\"bad variable name in %P\".to_owned());\n                 }\n-            },\n+            }\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     let idx = (cur as u8) - b'A';\n@@ -326,74 +415,84 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 } else {\n                     return Err(\"bad variable name in %g\".to_owned());\n                 }\n-            },\n+            }\n             CharConstant => {\n                 stack.push(Number(c as isize));\n                 state = CharClose;\n-            },\n+            }\n             CharClose => {\n                 if cur != '\\'' {\n                     return Err(\"malformed character constant\".to_owned());\n                 }\n-            },\n+            }\n             IntConstant(i) => {\n                 match cur {\n                     '}' => {\n                         stack.push(Number(i));\n                         state = Nothing;\n                     }\n                     '0'...'9' => {\n-                        state = IntConstant(i*10 + (cur as isize - '0' as isize));\n+                        state = IntConstant(i * 10 + (cur as isize - '0' as isize));\n                         old_state = Nothing;\n                     }\n-                    _ => return Err(\"bad isize constant\".to_owned())\n+                    _ => return Err(\"bad isize constant\".to_owned()),\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n                 old_state = Nothing;\n                 match (*fstate, cur) {\n-                    (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if !stack.is_empty() {\n-                        let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n-                        if res.is_err() { return res }\n-                        output.push_all(&res.unwrap());\n-                        // will cause state to go to Nothing\n-                        old_state = FormatPattern(*flags, *fstate);\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n-                    (FormatStateFlags,'#') => {\n+                    (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n+                        if !stack.is_empty() {\n+                            let res = format(stack.pop().unwrap(),\n+                                             FormatOp::from_char(cur),\n+                                             *flags);\n+                            if res.is_err() {\n+                                return res;\n+                            }\n+                            output.push_all(&res.unwrap());\n+                            // will cause state to go to Nothing\n+                            old_state = FormatPattern(*flags, *fstate);\n+                        } else {\n+                            return Err(\"stack is empty\".to_owned());\n+                        }\n+                    }\n+                    (FormatStateFlags, '#') => {\n                         flags.alternate = true;\n                     }\n-                    (FormatStateFlags,'-') => {\n+                    (FormatStateFlags, '-') => {\n                         flags.left = true;\n                     }\n-                    (FormatStateFlags,'+') => {\n+                    (FormatStateFlags, '+') => {\n                         flags.sign = true;\n                     }\n-                    (FormatStateFlags,' ') => {\n+                    (FormatStateFlags, ' ') => {\n                         flags.space = true;\n                     }\n-                    (FormatStateFlags,'0'...'9') => {\n+                    (FormatStateFlags, '0'...'9') => {\n                         flags.width = cur as usize - '0' as usize;\n                         *fstate = FormatStateWidth;\n                     }\n-                    (FormatStateFlags,'.') => {\n+                    (FormatStateFlags, '.') => {\n                         *fstate = FormatStatePrecision;\n                     }\n-                    (FormatStateWidth,'0'...'9') => {\n+                    (FormatStateWidth, '0'...'9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n-                        if flags.width < old { return Err(\"format width overflow\".to_owned()) }\n+                        if flags.width < old {\n+                            return Err(\"format width overflow\".to_owned());\n+                        }\n                     }\n-                    (FormatStateWidth,'.') => {\n+                    (FormatStateWidth, '.') => {\n                         *fstate = FormatStatePrecision;\n                     }\n-                    (FormatStatePrecision,'0'...'9') => {\n+                    (FormatStatePrecision, '0'...'9') => {\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                         if flags.precision < old {\n-                            return Err(\"format precision overflow\".to_owned())\n+                            return Err(\"format precision overflow\".to_owned());\n                         }\n                     }\n-                    _ => return Err(\"invalid format specifier\".to_owned())\n+                    _ => return Err(\"invalid format specifier\".to_owned()),\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -407,12 +506,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     if level == 0 {\n                         state = Nothing;\n                     } else {\n-                        state = SeekIfElse(level-1);\n+                        state = SeekIfElse(level - 1);\n                     }\n                 } else if cur == 'e' && level == 0 {\n                     state = Nothing;\n                 } else if cur == '?' {\n-                    state = SeekIfElse(level+1);\n+                    state = SeekIfElse(level + 1);\n                 } else {\n                     state = SeekIfElse(level);\n                 }\n@@ -428,10 +527,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     if level == 0 {\n                         state = Nothing;\n                     } else {\n-                        state = SeekIfEnd(level-1);\n+                        state = SeekIfEnd(level - 1);\n                     }\n                 } else if cur == '?' {\n-                    state = SeekIfEnd(level+1);\n+                    state = SeekIfEnd(level + 1);\n                 } else {\n                     state = SeekIfEnd(level);\n                 }\n@@ -451,13 +550,19 @@ struct Flags {\n     alternate: bool,\n     left: bool,\n     sign: bool,\n-    space: bool\n+    space: bool,\n }\n \n impl Flags {\n     fn new() -> Flags {\n-        Flags{ width: 0, precision: 0, alternate: false,\n-               left: false, sign: false, space: false }\n+        Flags {\n+            width: 0,\n+            precision: 0,\n+            alternate: false,\n+            left: false,\n+            sign: false,\n+            space: false,\n+        }\n     }\n }\n \n@@ -467,7 +572,7 @@ enum FormatOp {\n     FormatOctal,\n     FormatHex,\n     FormatHEX,\n-    FormatString\n+    FormatString,\n }\n \n impl FormatOp {\n@@ -478,7 +583,7 @@ impl FormatOp {\n             'x' => FormatHex,\n             'X' => FormatHEX,\n             's' => FormatString,\n-            _ => panic!(\"bad FormatOp char\")\n+            _ => panic!(\"bad FormatOp char\"),\n         }\n     }\n     fn to_char(self) -> char {\n@@ -487,23 +592,21 @@ impl FormatOp {\n             FormatOctal => 'o',\n             FormatHex => 'x',\n             FormatHEX => 'X',\n-            FormatString => 's'\n+            FormatString => 's',\n         }\n     }\n }\n \n-fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n     let mut s = match val {\n         Number(d) => {\n             let s = match (op, flags.sign) {\n-                (FormatDigit, true)  => format!(\"{:+}\", d).into_bytes(),\n+                (FormatDigit, true) => format!(\"{:+}\", d).into_bytes(),\n                 (FormatDigit, false) => format!(\"{}\", d).into_bytes(),\n-                (FormatOctal, _)     => format!(\"{:o}\", d).into_bytes(),\n-                (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n-                (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n-                (FormatString, _)    => {\n-                    return Err(\"non-number on stack with %s\".to_owned())\n-                }\n+                (FormatOctal, _) => format!(\"{:o}\", d).into_bytes(),\n+                (FormatHex, _) => format!(\"{:x}\", d).into_bytes(),\n+                (FormatHEX, _) => format!(\"{:X}\", d).into_bytes(),\n+                (FormatString, _) => return Err(\"non-number on stack with %s\".to_owned()),\n             };\n             let mut s: Vec<u8> = s.into_iter().collect();\n             if flags.precision > s.len() {\n@@ -516,7 +619,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             assert!(!s.is_empty(), \"string conversion produced empty result\");\n             match op {\n                 FormatDigit => {\n-                    if flags.space && !(s[0] == b'-' || s[0] == b'+' ) {\n+                    if flags.space && !(s[0] == b'-' || s[0] == b'+') {\n                         s.insert(0, b' ');\n                     }\n                 }\n@@ -527,18 +630,18 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                 }\n                 FormatHex => {\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, vec!(b'0', b'x'));\n+                        let s_ = replace(&mut s, vec![b'0', b'x']);\n                         s.extend(s_);\n                     }\n                 }\n                 FormatHEX => {\n                     s = s.to_ascii_uppercase();\n                     if flags.alternate {\n-                        let s_ = replace(&mut s, vec!(b'0', b'X'));\n+                        let s_ = replace(&mut s, vec![b'0', b'X']);\n                         s.extend(s_);\n                     }\n                 }\n-                FormatString => unreachable!()\n+                FormatString => unreachable!(),\n             }\n             s\n         }\n@@ -551,10 +654,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                     }\n                     s\n                 }\n-                _ => {\n-                    return Err(format!(\"non-string on stack with %{:?}\",\n-                                       op.to_char()))\n-                }\n+                _ => return Err(format!(\"non-string on stack with %{:?}\", op.to_char())),\n             }\n         }\n     };\n@@ -574,7 +674,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n \n #[cfg(test)]\n mod tests {\n-    use super::{expand,Param,Words,Variables,Number};\n+    use super::{expand, Param, Words, Variables, Number};\n     use std::result::Result::Ok;\n \n     #[test]\n@@ -594,7 +694,8 @@ mod tests {\n     fn test_op_i() {\n         let mut vars = Variables::new();\n         assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n-                          &[Number(1),Number(2),Number(3)], &mut vars),\n+                          &[Number(1), Number(2), Number(3)],\n+                          &mut vars),\n                    Ok(\"123233\".bytes().collect::<Vec<_>>()));\n         assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n                    Ok(\"0011\".bytes().collect::<Vec<_>>()));\n@@ -604,9 +705,11 @@ mod tests {\n     fn test_param_stack_failure_conditions() {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n-        fn get_res(fmt: &str, cap: &str, params: &[Param], vars: &mut Variables) ->\n-            Result<Vec<u8>, String>\n-        {\n+        fn get_res(fmt: &str,\n+                   cap: &str,\n+                   params: &[Param],\n+                   vars: &mut Variables)\n+                   -> Result<Vec<u8>, String> {\n             let mut u8v: Vec<_> = fmt.bytes().collect();\n             u8v.extend(cap.bytes());\n             expand(&u8v, params, vars)\n@@ -616,27 +719,34 @@ mod tests {\n         for &cap in &caps {\n             let res = get_res(\"\", cap, &[], vars);\n             assert!(res.is_err(),\n-                    \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n+                    \"Op {} succeeded incorrectly with 0 stack entries\",\n+                    cap);\n             let p = if cap == \"%s\" || cap == \"%l\" {\n                 Words(\"foo\".to_string())\n             } else {\n                 Number(97)\n             };\n             let res = get_res(\"%p1\", cap, &[p], vars);\n             assert!(res.is_ok(),\n-                    \"Op {} failed with 1 stack entry: {}\", cap, res.err().unwrap());\n+                    \"Op {} failed with 1 stack entry: {}\",\n+                    cap,\n+                    res.err().unwrap());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n         for &cap in &caps {\n             let res = expand(cap.as_bytes(), &[], vars);\n             assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 0 stack entries\", cap);\n+                    \"Binop {} succeeded incorrectly with 0 stack entries\",\n+                    cap);\n             let res = get_res(\"%{1}\", cap, &[], vars);\n             assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 1 stack entry\", cap);\n+                    \"Binop {} succeeded incorrectly with 1 stack entry\",\n+                    cap);\n             let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n             assert!(res.is_ok(),\n-                    \"Binop {} failed with 2 stack entries: {:?}\", cap, res.err().unwrap());\n+                    \"Binop {} failed with 2 stack entries: {:?}\",\n+                    cap,\n+                    res.err().unwrap());\n         }\n     }\n \n@@ -670,16 +780,13 @@ mod tests {\n         let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n         let res = expand(s, &[Number(1)], &mut vars);\n         assert!(res.is_ok(), res.err().unwrap());\n-        assert_eq!(res.unwrap(),\n-                   \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n+        assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n         let res = expand(s, &[Number(8)], &mut vars);\n         assert!(res.is_ok(), res.err().unwrap());\n-        assert_eq!(res.unwrap(),\n-                   \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n+        assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n         let res = expand(s, &[Number(42)], &mut vars);\n         assert!(res.is_ok(), res.err().unwrap());\n-        assert_eq!(res.unwrap(),\n-                   \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n+        assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -690,14 +797,17 @@ mod tests {\n                           &[Words(\"foo\".to_string()),\n                             Words(\"foo\".to_string()),\n                             Words(\"f\".to_string()),\n-                            Words(\"foo\".to_string())], vars),\n+                            Words(\"foo\".to_string())],\n+                          vars),\n                    Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n         assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_owned())], vars),\n                    Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n \n         assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n                    Ok(\"1001    1+1\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", &[Number(15), Number(27)], vars),\n+        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\",\n+                          &[Number(15), Number(27)],\n+                          vars),\n                    Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>()));\n     }\n }"}, {"sha": "7c8d9983e78f534883d3042570c2c4810bd23bc1", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "patch": "@@ -19,6 +19,7 @@ use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n+#[rustfmt_skip]\n #[allow(missing_docs)]\n pub static boolfnames: &'static[&'static str] = &[\"auto_left_margin\", \"auto_right_margin\",\n     \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n@@ -32,12 +33,14 @@ pub static boolfnames: &'static[&'static str] = &[\"auto_left_margin\", \"auto_righ\n     \"no_correctly_working_cr\", \"gnu_has_meta_key\", \"linefeed_is_newline\", \"has_hardware_tabs\",\n     \"return_does_clr_eol\"];\n \n+#[rustfmt_skip]\n #[allow(missing_docs)]\n pub static boolnames: &'static[&'static str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n     \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n     \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n     \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n \n+#[rustfmt_skip]\n #[allow(missing_docs)]\n pub static numfnames: &'static[&'static str] = &[ \"columns\", \"init_tabs\", \"lines\",\n     \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n@@ -49,12 +52,14 @@ pub static numfnames: &'static[&'static str] = &[ \"columns\", \"init_tabs\", \"lines\n     \"bit_image_entwining\", \"bit_image_type\", \"magic_cookie_glitch_ul\", \"carriage_return_delay\",\n     \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n \n+#[rustfmt_skip]\n #[allow(missing_docs)]\n pub static numnames: &'static[&'static str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n     \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n     \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n     \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n \n+#[rustfmt_skip]\n #[allow(missing_docs)]\n pub static stringfnames: &'static[&'static str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n     \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n@@ -129,6 +134,7 @@ pub static stringfnames: &'static[&'static str] = &[ \"back_tab\", \"bell\", \"carria\n     \"acs_lrcorner\", \"acs_ltee\", \"acs_rtee\", \"acs_btee\", \"acs_ttee\", \"acs_hline\", \"acs_vline\",\n     \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n \n+#[rustfmt_skip]\n #[allow(missing_docs)]\n pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n     \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n@@ -165,8 +171,7 @@ pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tb\n     \"box1\"];\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(file: &mut Read, longnames: bool)\n-             -> Result<Box<TermInfo>, String> {\n+pub fn parse(file: &mut Read, longnames: bool) -> Result<Box<TermInfo>, String> {\n     macro_rules! try { ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n@@ -192,36 +197,34 @@ pub fn parse(file: &mut Read, longnames: bool)\n     let magic = try!(read_le_u16(file));\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x}, found {:x}\",\n-                           0x011A_usize, magic as usize));\n+                           0x011A_usize,\n+                           magic as usize));\n     }\n \n-    let names_bytes          = try!(read_le_u16(file)) as isize;\n-    let bools_bytes          = try!(read_le_u16(file)) as isize;\n-    let numbers_count        = try!(read_le_u16(file)) as isize;\n+    let names_bytes = try!(read_le_u16(file)) as isize;\n+    let bools_bytes = try!(read_le_u16(file)) as isize;\n+    let numbers_count = try!(read_le_u16(file)) as isize;\n     let string_offsets_count = try!(read_le_u16(file)) as isize;\n-    let string_table_bytes   = try!(read_le_u16(file)) as isize;\n+    let string_table_bytes = try!(read_le_u16(file)) as isize;\n \n-    assert!(names_bytes          > 0);\n+    assert!(names_bytes > 0);\n \n     if (bools_bytes as usize) > boolnames.len() {\n-        return Err(\"incompatible file: more booleans than \\\n-                    expected\".to_owned());\n+        return Err(\"incompatible file: more booleans than expected\".to_owned());\n     }\n \n     if (numbers_count as usize) > numnames.len() {\n-        return Err(\"incompatible file: more numbers than \\\n-                    expected\".to_owned());\n+        return Err(\"incompatible file: more numbers than expected\".to_owned());\n     }\n \n     if (string_offsets_count as usize) > stringnames.len() {\n-        return Err(\"incompatible file: more string offsets than \\\n-                    expected\".to_owned());\n+        return Err(\"incompatible file: more string offsets than expected\".to_owned());\n     }\n \n     // don't read NUL\n     let bytes = try!(read_exact(file, names_bytes as usize - 1));\n     let names_str = match String::from_utf8(bytes) {\n-        Ok(s)  => s,\n+        Ok(s) => s,\n         Err(_) => return Err(\"input not utf-8\".to_owned()),\n     };\n \n@@ -266,13 +269,13 @@ pub fn parse(file: &mut Read, longnames: bool)\n         let string_table = try!(read_exact(file, string_table_bytes as usize));\n \n         if string_table.len() != string_table_bytes as usize {\n-            return Err(\"error: hit EOF before end of string \\\n-                        table\".to_owned());\n+            return Err(\"error: hit EOF before end of string table\".to_owned());\n         }\n \n         for (i, v) in string_offsets.iter().enumerate() {\n             let offset = *v;\n-            if offset == 0xFFFF { // non-entry\n+            if offset == 0xFFFF {\n+                // non-entry\n                 continue;\n             }\n \n@@ -291,17 +294,17 @@ pub fn parse(file: &mut Read, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table[offset as usize .. string_table_bytes as usize]\n-                .iter().position(|&b| b == 0);\n+            let nulpos = string_table[offset as usize..string_table_bytes as usize]\n+                             .iter()\n+                             .position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table[offset as usize ..\n-                                                   (offset as usize + len)].to_vec())\n-                },\n+                                      string_table[offset as usize..(offset as usize + len)]\n+                                          .to_vec())\n+                }\n                 None => {\n-                    return Err(\"invalid file: missing NUL in \\\n-                                string_table\".to_owned());\n+                    return Err(\"invalid file: missing NUL in string_table\".to_owned());\n                 }\n             };\n         }\n@@ -312,7 +315,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n         names: term_names,\n         bools: bools_map,\n         numbers: numbers_map,\n-        strings: string_map\n+        strings: string_map,\n     })\n }\n \n@@ -343,10 +346,10 @@ pub fn msys_terminfo() -> Box<TermInfo> {\n     strings.insert(\"setaf\".to_owned(), b\"\\x1B[3%p1%dm\".to_vec());\n     strings.insert(\"setab\".to_owned(), b\"\\x1B[4%p1%dm\".to_vec());\n     box TermInfo {\n-        names: vec!(\"cygwin\".to_owned()), // msys is a fork of an older cygwin version\n+        names: vec![\"cygwin\".to_owned()], // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),\n-        strings: strings\n+        strings: strings,\n     }\n }\n "}, {"sha": "397e7aa22546cc6b744d8fc66389549dccbdaffb", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "patch": "@@ -38,13 +38,15 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n             match env::var(\"TERMINFO_DIRS\") {\n-                Ok(dirs) => for i in dirs.split(':') {\n-                    if i == \"\" {\n-                        dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n-                    } else {\n-                        dirs_to_search.push(PathBuf::from(i));\n+                Ok(dirs) => {\n+                    for i in dirs.split(':') {\n+                        if i == \"\" {\n+                            dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n+                        } else {\n+                            dirs_to_search.push(PathBuf::from(i));\n+                        }\n                     }\n-                },\n+                }\n                 // Found nothing in TERMINFO_DIRS, use the default paths:\n                 // According to  /etc/terminfo/README, after looking at\n                 // ~/.terminfo, ncurses will search /etc/terminfo, then\n@@ -86,9 +88,7 @@ pub fn open(term: &str) -> Result<File, String> {\n                 Err(e) => Err(format!(\"error opening file: {:?}\", e)),\n             }\n         }\n-        None => {\n-            Err(format!(\"could not find terminfo entry for {:?}\", term))\n-        }\n+        None => Err(format!(\"could not find terminfo entry for {:?}\", term)),\n     }\n }\n "}, {"sha": "fa53d783194c83f8fc5504f574c0ae6437ce4cba", "filename": "src/libterm/win.rs", "status": "modified", "additions": 33, "deletions": 25, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ba44607fe09c4fb98a52ca2149b0c9869a87b4c/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=2ba44607fe09c4fb98a52ca2149b0c9869a87b4c", "patch": "@@ -19,7 +19,7 @@ use std::io::prelude::*;\n \n use attr;\n use color;\n-use {Terminal,UnwrappableTerminal};\n+use {Terminal, UnwrappableTerminal};\n \n /// A Terminal implementation which uses the Win32 Console API.\n pub struct WinConsole<T> {\n@@ -50,23 +50,22 @@ struct CONSOLE_SCREEN_BUFFER_INFO {\n extern \"system\" {\n     fn SetConsoleTextAttribute(handle: HANDLE, attr: WORD) -> BOOL;\n     fn GetStdHandle(which: DWORD) -> HANDLE;\n-    fn GetConsoleScreenBufferInfo(handle: HANDLE,\n-                                  info: *mut CONSOLE_SCREEN_BUFFER_INFO) -> BOOL;\n+    fn GetConsoleScreenBufferInfo(handle: HANDLE, info: *mut CONSOLE_SCREEN_BUFFER_INFO) -> BOOL;\n }\n \n fn color_to_bits(color: color::Color) -> u16 {\n     // magic numbers from mingw-w64's wincon.h\n \n     let bits = match color % 8 {\n-        color::BLACK   => 0,\n-        color::BLUE    => 0x1,\n-        color::GREEN   => 0x2,\n-        color::RED     => 0x4,\n-        color::YELLOW  => 0x2 | 0x4,\n+        color::BLACK => 0,\n+        color::BLUE => 0x1,\n+        color::GREEN => 0x2,\n+        color::RED => 0x4,\n+        color::YELLOW => 0x2 | 0x4,\n         color::MAGENTA => 0x1 | 0x4,\n-        color::CYAN    => 0x1 | 0x2,\n-        color::WHITE   => 0x1 | 0x2 | 0x4,\n-        _ => unreachable!()\n+        color::CYAN => 0x1 | 0x2,\n+        color::WHITE => 0x1 | 0x2 | 0x4,\n+        _ => unreachable!(),\n     };\n \n     if color >= 8 {\n@@ -86,7 +85,7 @@ fn bits_to_color(bits: u16) -> color::Color {\n         0x5 => color::MAGENTA,\n         0x3 => color::CYAN,\n         0x7 => color::WHITE,\n-        _ => unreachable!()\n+        _ => unreachable!(),\n     };\n \n     color | (bits & 0x8) // copy the hi-intensity bit\n@@ -116,23 +115,26 @@ impl<T: Write+Send+'static> WinConsole<T> {\n \n     /// Returns `None` whenever the terminal cannot be created for some\n     /// reason.\n-    pub fn new(out: T) -> Option<Box<Terminal<T>+Send+'static>> {\n+    pub fn new(out: T) -> Option<Box<Terminal<T> + Send + 'static>> {\n         let fg;\n         let bg;\n         unsafe {\n             let mut buffer_info = ::std::mem::uninitialized();\n-            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as DWORD),\n-                                          &mut buffer_info) != 0 {\n+            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as DWORD), &mut buffer_info) != 0 {\n                 fg = bits_to_color(buffer_info.wAttributes);\n                 bg = bits_to_color(buffer_info.wAttributes >> 4);\n             } else {\n                 fg = color::WHITE;\n                 bg = color::BLACK;\n             }\n         }\n-        Some(box WinConsole { buf: out,\n-                              def_foreground: fg, def_background: bg,\n-                              foreground: fg, background: bg })\n+        Some(box WinConsole {\n+            buf: out,\n+            def_foreground: fg,\n+            def_background: bg,\n+            foreground: fg,\n+            background: bg,\n+        })\n     }\n }\n \n@@ -167,13 +169,13 @@ impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n                 self.foreground = f;\n                 self.apply();\n                 Ok(true)\n-            },\n+            }\n             attr::BackgroundColor(b) => {\n                 self.background = b;\n                 self.apply();\n                 Ok(true)\n-            },\n-            _ => Ok(false)\n+            }\n+            _ => Ok(false),\n         }\n     }\n \n@@ -182,7 +184,7 @@ impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n         // it to do anything -cmr\n         match attr {\n             attr::ForegroundColor(_) | attr::BackgroundColor(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -194,11 +196,17 @@ impl<T: Write+Send+'static> Terminal<T> for WinConsole<T> {\n         Ok(())\n     }\n \n-    fn get_ref<'a>(&'a self) -> &'a T { &self.buf }\n+    fn get_ref<'a>(&'a self) -> &'a T {\n+        &self.buf\n+    }\n \n-    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.buf }\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T {\n+        &mut self.buf\n+    }\n }\n \n impl<T: Write+Send+'static> UnwrappableTerminal<T> for WinConsole<T> {\n-    fn unwrap(self) -> T { self.buf }\n+    fn unwrap(self) -> T {\n+        self.buf\n+    }\n }"}]}