{"sha": "2195d1db6d70d64383bec82819fab02891d09744", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTVkMWRiNmQ3MGQ2NDM4M2JlYzgyODE5ZmFiMDI4OTFkMDk3NDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-13T13:38:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T09:49:07Z"}, "message": "Replace module_tree with CrateDefMap", "tree": {"sha": "40174ca7cbb3625ea62ebc10dbd9b592c83a8081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40174ca7cbb3625ea62ebc10dbd9b592c83a8081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2195d1db6d70d64383bec82819fab02891d09744", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2195d1db6d70d64383bec82819fab02891d09744", "html_url": "https://github.com/rust-lang/rust/commit/2195d1db6d70d64383bec82819fab02891d09744", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2195d1db6d70d64383bec82819fab02891d09744/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/182c05a96c25321ac3ff262cea098e0c4d7ed6f8", "html_url": "https://github.com/rust-lang/rust/commit/182c05a96c25321ac3ff262cea098e0c4d7ed6f8"}], "stats": {"total": 844, "additions": 333, "deletions": 511}, "files": [{"sha": "ef69ef96a7259c50627ef6f812f09c55a3f59893", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -9,12 +9,12 @@ use crate::{\n     HirDatabase, PersistentHirDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, lower::ImportId},\n+    nameres::crate_def_map::ModuleId,\n     expr::{Body, BodySourceMap},\n     ty::InferenceResult,\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n-    module_tree::ModuleId,\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n     impl_block::ImplBlock,\n     resolve::Resolver,"}, {"sha": "cc87c6f14027e60def963950cd6e74c244832119", "filename": "crates/ra_hir/src/code_model_impl/krate.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fkrate.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -18,9 +18,7 @@ impl Crate {\n             .collect()\n     }\n     pub(crate) fn root_module_impl(&self, db: &impl PersistentHirDatabase) -> Option<Module> {\n-        let module_tree = db.module_tree(*self);\n-        let module_id = module_tree.modules().next()?;\n-\n+        let module_id = db.crate_def_map(*self).root();\n         let module = Module { krate: *self, module_id };\n         Some(module)\n     }"}, {"sha": "5d8f738b57dc0674463615d780a2d43624eb1010", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 66, "deletions": 31, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -1,45 +1,74 @@\n-use ra_syntax::{ast, SyntaxNode, TreeArc};\n+use ra_db::FileId;\n+use ra_syntax::{ast, SyntaxNode, TreeArc, AstNode};\n \n use crate::{\n-    Module, ModuleSource, Problem,\n-    Name,\n-    module_tree::ModuleId,\n+    Module, ModuleSource, Problem, Name,\n+    nameres::crate_def_map::ModuleId,\n     nameres::lower::ImportId,\n     HirDatabase, PersistentHirDatabase,\n-    HirFileId\n+    HirFileId, SourceItemId,\n };\n \n+impl ModuleSource {\n+    pub(crate) fn new(\n+        db: &impl PersistentHirDatabase,\n+        file_id: Option<FileId>,\n+        decl_id: Option<SourceItemId>,\n+    ) -> ModuleSource {\n+        match (file_id, decl_id) {\n+            (Some(file_id), _) => {\n+                let source_file = db.parse(file_id);\n+                ModuleSource::SourceFile(source_file)\n+            }\n+            (None, Some(item_id)) => {\n+                let module = db.file_item(item_id);\n+                let module = ast::Module::cast(&*module).unwrap();\n+                assert!(module.item_list().is_some(), \"expected inline module\");\n+                ModuleSource::Module(module.to_owned())\n+            }\n+            (None, None) => panic!(),\n+        }\n+    }\n+}\n+\n impl Module {\n     fn with_module_id(&self, module_id: ModuleId) -> Module {\n         Module { module_id, krate: self.krate }\n     }\n \n     pub(crate) fn name_impl(&self, db: &impl HirDatabase) -> Option<Name> {\n-        let module_tree = db.module_tree(self.krate);\n-        let link = self.module_id.parent_link(&module_tree)?;\n-        Some(link.name(&module_tree).clone())\n+        let def_map = db.crate_def_map(self.krate);\n+        let parent = def_map[self.module_id].parent?;\n+        def_map[parent].children.iter().find_map(|(name, module_id)| {\n+            if *module_id == self.module_id {\n+                Some(name.clone())\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     pub(crate) fn definition_source_impl(\n         &self,\n         db: &impl PersistentHirDatabase,\n     ) -> (HirFileId, ModuleSource) {\n-        let module_tree = db.module_tree(self.krate);\n-        let file_id = self.module_id.file_id(&module_tree);\n-        let decl_id = self.module_id.decl_id(&module_tree);\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl_id = def_map[self.module_id].declaration;\n+        let file_id = def_map[self.module_id].definition;\n         let module_source = ModuleSource::new(db, file_id, decl_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id);\n         (file_id, module_source)\n     }\n \n     pub(crate) fn declaration_source_impl(\n         &self,\n         db: &impl HirDatabase,\n     ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n-        let module_tree = db.module_tree(self.krate);\n-        let link = self.module_id.parent_link(&module_tree)?;\n-        let file_id = link.owner(&module_tree).file_id(&module_tree);\n-        let src = link.source(&module_tree, db);\n-        Some((file_id, src))\n+        let def_map = db.crate_def_map(self.krate);\n+        let decl = def_map[self.module_id].declaration?;\n+        let syntax_node = db.file_item(decl);\n+        let ast = ast::Module::cast(&syntax_node).unwrap().to_owned();\n+        Some((decl.file_id, ast))\n     }\n \n     pub(crate) fn import_source_impl(\n@@ -53,43 +82,49 @@ impl Module {\n     }\n \n     pub(crate) fn crate_root_impl(&self, db: &impl PersistentHirDatabase) -> Module {\n-        let module_tree = db.module_tree(self.krate);\n-        let module_id = self.module_id.crate_root(&module_tree);\n-        self.with_module_id(module_id)\n+        let def_map = db.crate_def_map(self.krate);\n+        self.with_module_id(def_map.root())\n     }\n \n     /// Finds a child module with the specified name.\n     pub(crate) fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n-        let module_tree = db.module_tree(self.krate);\n-        let child_id = self.module_id.child(&module_tree, name)?;\n-        Some(self.with_module_id(child_id))\n+        let def_map = db.crate_def_map(self.krate);\n+        let child_id = def_map[self.module_id].children.get(name)?;\n+        Some(self.with_module_id(*child_id))\n     }\n \n     /// Iterates over all child modules.\n     pub(crate) fn children_impl(\n         &self,\n         db: &impl PersistentHirDatabase,\n     ) -> impl Iterator<Item = Module> {\n-        let module_tree = db.module_tree(self.krate);\n-        let children = self\n-            .module_id\n-            .children(&module_tree)\n-            .map(|(_, module_id)| self.with_module_id(module_id))\n+        let def_map = db.crate_def_map(self.krate);\n+        let children = def_map[self.module_id]\n+            .children\n+            .iter()\n+            .map(|(_, module_id)| self.with_module_id(*module_id))\n             .collect::<Vec<_>>();\n         children.into_iter()\n     }\n \n     pub(crate) fn parent_impl(&self, db: &impl PersistentHirDatabase) -> Option<Module> {\n-        let module_tree = db.module_tree(self.krate);\n-        let parent_id = self.module_id.parent(&module_tree)?;\n+        let def_map = db.crate_def_map(self.krate);\n+        let parent_id = def_map[self.module_id].parent?;\n         Some(self.with_module_id(parent_id))\n     }\n \n     pub(crate) fn problems_impl(\n         &self,\n         db: &impl HirDatabase,\n     ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        let module_tree = db.module_tree(self.krate);\n-        self.module_id.problems(&module_tree, db)\n+        let def_map = db.crate_def_map(self.krate);\n+        let (my_file_id, _) = self.definition_source(db);\n+        // FIXME: not entirely corret filterint by module\n+        def_map\n+            .problems()\n+            .iter()\n+            .filter(|(source_item_id, _problem)| my_file_id == source_item_id.file_id)\n+            .map(|(source_item_id, problem)| (db.file_item(*source_item_id), problem.clone()))\n+            .collect()\n     }\n }"}, {"sha": "423922a572e20b632d20d831b7d17eea632e4e01", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n-use ra_db::{SourceDatabase, salsa};\n+use ra_db::{SourceDatabase, salsa, FileId};\n \n use crate::{\n     MacroCallId, HirFileId,\n@@ -10,14 +10,11 @@ use crate::{\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n     macros::MacroExpansion,\n-    module_tree::ModuleTree,\n-    nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n+    nameres::{Namespace, ItemMap, lower::{LoweredModule, ImportSourceMap}, crate_def_map::{RawItems, CrateDefMap}},\n     ty::{InferenceResult, Ty, method_resolution::CrateImplBlocks, TypableDef, CallableDef, FnSig},\n     adt::{StructData, EnumData},\n     impl_block::{ModuleImplBlocks, ImplSourceMap},\n     generics::{GenericParams, GenericDef},\n-    ids::SourceFileItemId,\n-    nameres::Namespace,\n     type_ref::TypeRef,\n };\n \n@@ -41,13 +38,6 @@ pub trait PersistentHirDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::ids::SourceFileItems::file_item_query)]\n     fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n \n-    #[salsa::invoke(crate::module_tree::Submodule::submodules_query)]\n-    fn submodules(\n-        &self,\n-        file_id: HirFileId,\n-        delc_id: Option<SourceFileItemId>,\n-    ) -> Arc<Vec<crate::module_tree::Submodule>>;\n-\n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_with_source_map_query)]\n     fn lower_module_with_source_map(\n         &self,\n@@ -57,11 +47,14 @@ pub trait PersistentHirDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::nameres::lower::LoweredModule::lower_module_query)]\n     fn lower_module(&self, module: Module) -> Arc<LoweredModule>;\n \n+    #[salsa::invoke(RawItems::raw_items_query)]\n+    fn raw_items(&self, file_id: FileId) -> Arc<RawItems>;\n+\n     #[salsa::invoke(crate::nameres::ItemMap::item_map_query)]\n     fn item_map(&self, krate: Crate) -> Arc<ItemMap>;\n \n-    #[salsa::invoke(crate::module_tree::ModuleTree::module_tree_query)]\n-    fn module_tree(&self, krate: Crate) -> Arc<ModuleTree>;\n+    #[salsa::invoke(CrateDefMap::crate_def_map_query)]\n+    fn crate_def_map(&self, krate: Crate) -> Arc<CrateDefMap>;\n \n     #[salsa::invoke(crate::impl_block::impls_in_module)]\n     fn impls_in_module(&self, module: Module) -> Arc<ModuleImplBlocks>;"}, {"sha": "6ce00a3722d79588a498157f219d36fb26b71f10", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -296,6 +296,12 @@ impl AstItemDef<ast::TypeAliasDef> for TypeId {\n pub struct SourceFileItemId(RawId);\n impl_arena_id!(SourceFileItemId);\n \n+impl SourceFileItemId {\n+    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n+        SourceItemId { file_id, item_id: self }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct SourceItemId {\n     pub(crate) file_id: HirFileId,"}, {"sha": "61db4f6cc95187d6fe81a9526f55c636ae7d4029", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -26,7 +26,6 @@ pub mod source_binder;\n mod ids;\n mod macros;\n mod name;\n-mod module_tree;\n mod nameres;\n mod adt;\n mod type_alias;"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 0, "deletions": 340, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -1,340 +0,0 @@\n-use std::sync::Arc;\n-\n-use arrayvec::ArrayVec;\n-use relative_path::RelativePathBuf;\n-use ra_db::{FileId, SourceRoot};\n-use ra_syntax::{\n-    SyntaxNode, TreeArc,\n-    algo::generate,\n-    ast::{self, AstNode, NameOwner},\n-};\n-use ra_arena::{Arena, RawId, impl_arena_id};\n-use test_utils::tested_by;\n-\n-use crate::{\n-    Name, AsName, HirDatabase, SourceItemId, HirFileId, Problem, SourceFileItems, ModuleSource,\n-    PersistentHirDatabase,\n-    Crate,\n-    ids::SourceFileItemId,\n-};\n-\n-impl ModuleSource {\n-    pub(crate) fn new(\n-        db: &impl PersistentHirDatabase,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> ModuleSource {\n-        match decl_id {\n-            Some(item_id) => {\n-                let module = db.file_item(SourceItemId { file_id, item_id });\n-                let module = ast::Module::cast(&*module).unwrap();\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module.to_owned())\n-            }\n-            None => {\n-                let source_file = db.hir_parse(file_id);\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub struct Submodule {\n-    name: Name,\n-    is_declaration: bool,\n-    decl_id: SourceFileItemId,\n-}\n-\n-impl Submodule {\n-    pub(crate) fn submodules_query(\n-        db: &impl PersistentHirDatabase,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> Arc<Vec<Submodule>> {\n-        db.check_canceled();\n-        let file_items = db.file_items(file_id);\n-        let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let submodules = match module_source {\n-            ModuleSource::SourceFile(source_file) => {\n-                collect_submodules(file_id, &file_items, &*source_file)\n-            }\n-            ModuleSource::Module(module) => {\n-                collect_submodules(file_id, &file_items, module.item_list().unwrap())\n-            }\n-        };\n-\n-        return Arc::new(submodules);\n-\n-        fn collect_submodules(\n-            file_id: HirFileId,\n-            file_items: &SourceFileItems,\n-            root: &impl ast::ModuleItemOwner,\n-        ) -> Vec<Submodule> {\n-            root.items()\n-                .filter_map(|item| match item.kind() {\n-                    ast::ModuleItemKind::Module(m) => Some(m),\n-                    _ => None,\n-                })\n-                .filter_map(|module| {\n-                    let name = module.name()?.as_name();\n-                    if !module.has_semi() && module.item_list().is_none() {\n-                        tested_by!(name_res_works_for_broken_modules);\n-                        return None;\n-                    }\n-                    let sub = Submodule {\n-                        name,\n-                        is_declaration: module.has_semi(),\n-                        decl_id: file_items.id_of(file_id, module.syntax()),\n-                    };\n-                    Some(sub)\n-                })\n-                .collect()\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct ModuleId(RawId);\n-impl_arena_id!(ModuleId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct LinkId(RawId);\n-impl_arena_id!(LinkId);\n-\n-/// Physically, rust source is organized as a set of files, but logically it is\n-/// organized as a tree of modules. Usually, a single file corresponds to a\n-/// single module, but it is not neccessarily always the case.\n-///\n-/// `ModuleTree` encapsulates the logic of transitioning from the fuzzy world of files\n-/// (which can have multiple parents) to the precise world of modules (which\n-/// always have one parent).\n-#[derive(Default, Debug, PartialEq, Eq)]\n-pub struct ModuleTree {\n-    mods: Arena<ModuleId, ModuleData>,\n-    links: Arena<LinkId, LinkData>,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct ModuleData {\n-    file_id: HirFileId,\n-    /// Points to `ast::Module`, `None` for the whole file.\n-    decl_id: Option<SourceFileItemId>,\n-    parent: Option<LinkId>,\n-    children: Vec<LinkId>,\n-}\n-\n-#[derive(Hash, Debug, PartialEq, Eq)]\n-struct LinkData {\n-    source: SourceItemId,\n-    owner: ModuleId,\n-    name: Name,\n-    points_to: Vec<ModuleId>,\n-    problem: Option<Problem>,\n-}\n-\n-impl ModuleTree {\n-    pub(crate) fn module_tree_query(\n-        db: &impl PersistentHirDatabase,\n-        krate: Crate,\n-    ) -> Arc<ModuleTree> {\n-        db.check_canceled();\n-        let mut res = ModuleTree::default();\n-        res.init_crate(db, krate);\n-        Arc::new(res)\n-    }\n-\n-    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n-        self.mods.iter().map(|(id, _)| id)\n-    }\n-\n-    pub(crate) fn find_module_by_source(\n-        &self,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> Option<ModuleId> {\n-        let (res, _) =\n-            self.mods.iter().find(|(_, m)| (m.file_id, m.decl_id) == (file_id, decl_id))?;\n-        Some(res)\n-    }\n-\n-    fn init_crate(&mut self, db: &impl PersistentHirDatabase, krate: Crate) {\n-        let crate_graph = db.crate_graph();\n-        let file_id = crate_graph.crate_root(krate.crate_id);\n-        let source_root_id = db.file_source_root(file_id);\n-\n-        let source_root = db.source_root(source_root_id);\n-        self.init_subtree(db, &source_root, None, file_id.into(), None);\n-    }\n-\n-    fn init_subtree(\n-        &mut self,\n-        db: &impl PersistentHirDatabase,\n-        source_root: &SourceRoot,\n-        parent: Option<LinkId>,\n-        file_id: HirFileId,\n-        decl_id: Option<SourceFileItemId>,\n-    ) -> ModuleId {\n-        let is_root = parent.is_none();\n-        let id = self.alloc_mod(ModuleData { file_id, decl_id, parent, children: Vec::new() });\n-        for sub in db.submodules(file_id, decl_id).iter() {\n-            let link = self.alloc_link(LinkData {\n-                source: SourceItemId { file_id, item_id: sub.decl_id },\n-                name: sub.name.clone(),\n-                owner: id,\n-                points_to: Vec::new(),\n-                problem: None,\n-            });\n-\n-            let (points_to, problem) = if sub.is_declaration {\n-                let (points_to, problem) = resolve_submodule(db, file_id, &sub.name, is_root);\n-                let points_to = points_to\n-                    .into_iter()\n-                    .map(|file_id| {\n-                        self.init_subtree(db, source_root, Some(link), file_id.into(), None)\n-                    })\n-                    .collect::<Vec<_>>();\n-                (points_to, problem)\n-            } else {\n-                let points_to =\n-                    self.init_subtree(db, source_root, Some(link), file_id, Some(sub.decl_id));\n-                (vec![points_to], None)\n-            };\n-\n-            self.links[link].points_to = points_to;\n-            self.links[link].problem = problem;\n-        }\n-        id\n-    }\n-\n-    fn alloc_mod(&mut self, data: ModuleData) -> ModuleId {\n-        self.mods.alloc(data)\n-    }\n-\n-    fn alloc_link(&mut self, data: LinkData) -> LinkId {\n-        let owner = data.owner;\n-        let id = self.links.alloc(data);\n-        self.mods[owner].children.push(id);\n-        id\n-    }\n-}\n-\n-impl ModuleId {\n-    pub(crate) fn file_id(self, tree: &ModuleTree) -> HirFileId {\n-        tree.mods[self].file_id\n-    }\n-    pub(crate) fn decl_id(self, tree: &ModuleTree) -> Option<SourceFileItemId> {\n-        tree.mods[self].decl_id\n-    }\n-    pub(crate) fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n-        tree.mods[self].parent\n-    }\n-    pub(crate) fn parent(self, tree: &ModuleTree) -> Option<ModuleId> {\n-        let link = self.parent_link(tree)?;\n-        Some(tree.links[link].owner)\n-    }\n-    pub(crate) fn crate_root(self, tree: &ModuleTree) -> ModuleId {\n-        generate(Some(self), move |it| it.parent(tree)).last().unwrap()\n-    }\n-    pub(crate) fn child(self, tree: &ModuleTree, name: &Name) -> Option<ModuleId> {\n-        let link = tree.mods[self]\n-            .children\n-            .iter()\n-            .map(|&it| &tree.links[it])\n-            .find(|it| it.name == *name)?;\n-        Some(*link.points_to.first()?)\n-    }\n-    pub(crate) fn children<'a>(\n-        self,\n-        tree: &'a ModuleTree,\n-    ) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n-        tree.mods[self].children.iter().filter_map(move |&it| {\n-            let link = &tree.links[it];\n-            let module = *link.points_to.first()?;\n-            Some((link.name.clone(), module))\n-        })\n-    }\n-    pub(crate) fn problems(\n-        self,\n-        tree: &ModuleTree,\n-        db: &impl HirDatabase,\n-    ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n-        tree.mods[self]\n-            .children\n-            .iter()\n-            .filter_map(|&link| {\n-                let p = tree.links[link].problem.clone()?;\n-                let s = link.source(tree, db);\n-                let s = s.name().unwrap().syntax().to_owned();\n-                Some((s, p))\n-            })\n-            .collect()\n-    }\n-}\n-\n-impl LinkId {\n-    pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n-        tree.links[self].owner\n-    }\n-    pub(crate) fn name(self, tree: &ModuleTree) -> &Name {\n-        &tree.links[self].name\n-    }\n-    pub(crate) fn source(\n-        self,\n-        tree: &ModuleTree,\n-        db: &impl PersistentHirDatabase,\n-    ) -> TreeArc<ast::Module> {\n-        let syntax_node = db.file_item(tree.links[self].source);\n-        ast::Module::cast(&syntax_node).unwrap().to_owned()\n-    }\n-}\n-\n-pub(crate) fn resolve_module_declaration(\n-    db: &impl PersistentHirDatabase,\n-    file_id: HirFileId,\n-    name: &Name,\n-    is_root: bool,\n-) -> Option<FileId> {\n-    resolve_submodule(db, file_id, name, is_root).0.first().map(|it| *it)\n-}\n-\n-fn resolve_submodule(\n-    db: &impl PersistentHirDatabase,\n-    file_id: HirFileId,\n-    name: &Name,\n-    is_root: bool,\n-) -> (Vec<FileId>, Option<Problem>) {\n-    // FIXME: handle submodules of inline modules properly\n-    let file_id = file_id.original_file(db);\n-    let source_root_id = db.file_source_root(file_id);\n-    let path = db.file_relative_path(file_id);\n-    let root = RelativePathBuf::default();\n-    let dir_path = path.parent().unwrap_or(&root);\n-    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n-    let is_dir_owner = is_root || mod_name == \"mod\";\n-\n-    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n-    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n-    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n-    let mut candidates = ArrayVec::<[_; 2]>::new();\n-    if is_dir_owner {\n-        candidates.push(file_mod.clone());\n-        candidates.push(dir_mod);\n-    } else {\n-        candidates.push(file_dir_mod.clone());\n-    };\n-    let sr = db.source_root(source_root_id);\n-    let points_to = candidates\n-        .into_iter()\n-        .filter_map(|path| sr.files.get(&path))\n-        .map(|&it| it)\n-        .collect::<Vec<_>>();\n-    let problem = if points_to.is_empty() {\n-        Some(Problem::UnresolvedModule {\n-            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n-        })\n-    } else {\n-        None\n-    };\n-    (points_to, problem)\n-}"}, {"sha": "baffbce6f47f798d28357d52e5495d31b18978b6", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -15,7 +15,7 @@\n //! so that the results of name resolution can be preserved unless the module\n //! structure itself is modified.\n pub(crate) mod lower;\n-mod crate_def_map;\n+pub(crate) mod crate_def_map;\n \n use std::{time, sync::Arc};\n \n@@ -29,8 +29,10 @@ use crate::{\n     Module, ModuleDef,\n     Path, PathKind, PersistentHirDatabase,\n     Crate, Name,\n-    module_tree::{ModuleId, ModuleTree},\n-    nameres::lower::{ImportId, LoweredModule, ImportData},\n+    nameres::{\n+        crate_def_map::{CrateDefMap, ModuleId},\n+        lower::{ImportId, LoweredModule, ImportData}\n+    },\n };\n \n /// `ItemMap` is the result of module name resolution. It contains, for each\n@@ -160,7 +162,7 @@ struct Resolver<'a, DB> {\n     db: &'a DB,\n     input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n     krate: Crate,\n-    module_tree: Arc<ModuleTree>,\n+    def_map: Arc<CrateDefMap>,\n     processed_imports: FxHashSet<(ModuleId, ImportId)>,\n     /// If module `a` has `use b::*`, then this contains the mapping b -> a (and the import)\n     glob_imports: FxHashMap<ModuleId, Vec<(ModuleId, ImportId)>>,\n@@ -176,12 +178,11 @@ where\n         input: &'a FxHashMap<ModuleId, Arc<LoweredModule>>,\n         krate: Crate,\n     ) -> Resolver<'a, DB> {\n-        let module_tree = db.module_tree(krate);\n         Resolver {\n             db,\n             input,\n             krate,\n-            module_tree,\n+            def_map: db.crate_def_map(krate),\n             processed_imports: FxHashSet::default(),\n             glob_imports: FxHashMap::default(),\n             result: ItemMap {\n@@ -254,9 +255,9 @@ where\n         }\n \n         // Populate modules\n-        for (name, module_id) in module_id.children(&self.module_tree) {\n-            let module = Module { module_id, krate: self.krate };\n-            self.add_module_item(&mut module_items, name, PerNs::types(module.into()));\n+        for (name, module_id) in self.def_map[module_id].children.iter() {\n+            let module = Module { module_id: *module_id, krate: self.krate };\n+            self.add_module_item(&mut module_items, name.clone(), PerNs::types(module.into()));\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n@@ -479,8 +480,8 @@ enum ReachedFixedPoint {\n impl ItemMap {\n     pub(crate) fn item_map_query(db: &impl PersistentHirDatabase, krate: Crate) -> Arc<ItemMap> {\n         let start = time::Instant::now();\n-        let module_tree = db.module_tree(krate);\n-        let input = module_tree\n+        let def_map = db.crate_def_map(krate);\n+        let input = def_map\n             .modules()\n             .map(|module_id| (module_id, db.lower_module(Module { krate, module_id })))\n             .collect::<FxHashMap<_, _>>();"}, {"sha": "d7ccb65843612f127cd402f72d38b15b491b4a34", "filename": "crates/ra_hir/src/nameres/crate_def_map.rs", "status": "modified", "additions": 100, "deletions": 18, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -48,25 +48,40 @@ mod tests;\n \n use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n-use ra_arena::Arena;\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_db::FileId;\n+\n+use std::sync::Arc;\n \n use crate::{\n-    Name, Module, Path, PathKind, ModuleDef, Crate,\n+    Name, Module, Path, PathKind, ModuleDef, Crate, Problem, HirFileId,\n     PersistentHirDatabase,\n-    module_tree::ModuleId,\n     nameres::{ModuleScope, ResolveMode, ResolvePathResult, PerNs, Edition, ReachedFixedPoint},\n+    ids::{SourceItemId, SourceFileItemId},\n };\n \n-#[derive(Default, Debug)]\n-struct ModuleData {\n-    parent: Option<ModuleId>,\n-    children: FxHashMap<Name, ModuleId>,\n-    scope: ModuleScope,\n+pub(crate) use self::raw::RawItems;\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct ModuleData {\n+    pub(crate) parent: Option<ModuleId>,\n+    pub(crate) children: FxHashMap<Name, ModuleId>,\n+    pub(crate) scope: ModuleScope,\n+    /// None for root\n+    pub(crate) declaration: Option<SourceItemId>,\n+    /// None for inline modules.\n+    ///\n+    /// Note that non-inline modules, by definition, live inside non-macro file.\n+    pub(crate) definition: Option<FileId>,\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub(crate) struct ModuleId(RawId);\n+impl_arena_id!(ModuleId);\n+\n /// Contans all top-level defs from a macro-expanded crate\n-#[derive(Debug)]\n-pub(crate) struct CrateDefMap {\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct CrateDefMap {\n     krate: Crate,\n     edition: Edition,\n     /// The prelude module for this crate. This either comes from an import\n@@ -77,19 +92,85 @@ pub(crate) struct CrateDefMap {\n     root: ModuleId,\n     modules: Arena<ModuleId, ModuleData>,\n     public_macros: FxHashMap<Name, mbe::MacroRules>,\n+    problems: CrateDefMapProblems,\n+}\n+\n+#[derive(Default, Debug, PartialEq, Eq)]\n+pub(crate) struct CrateDefMapProblems {\n+    problems: Vec<(SourceItemId, Problem)>,\n+}\n+\n+impl CrateDefMapProblems {\n+    fn add(&mut self, source_item_id: SourceItemId, problem: Problem) {\n+        self.problems.push((source_item_id, problem))\n+    }\n+\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (&'a SourceItemId, &'a Problem)> + 'a {\n+        self.problems.iter().map(|(s, p)| (s, p))\n+    }\n }\n \n impl std::ops::Index<ModuleId> for CrateDefMap {\n-    type Output = ModuleScope;\n-    fn index(&self, id: ModuleId) -> &ModuleScope {\n-        &self.modules[id].scope\n+    type Output = ModuleData;\n+    fn index(&self, id: ModuleId) -> &ModuleData {\n+        &self.modules[id]\n     }\n }\n \n impl CrateDefMap {\n+    pub(crate) fn crate_def_map_query(\n+        db: &impl PersistentHirDatabase,\n+        krate: Crate,\n+    ) -> Arc<CrateDefMap> {\n+        let def_map = {\n+            let edition = krate.edition(db);\n+            let mut modules: Arena<ModuleId, ModuleData> = Arena::default();\n+            let root = modules.alloc(ModuleData::default());\n+            CrateDefMap {\n+                krate,\n+                edition,\n+                extern_prelude: FxHashMap::default(),\n+                prelude: None,\n+                root,\n+                modules,\n+                public_macros: FxHashMap::default(),\n+                problems: CrateDefMapProblems::default(),\n+            }\n+        };\n+        let def_map = collector::collect_defs(db, def_map);\n+        Arc::new(def_map)\n+    }\n+\n+    pub(crate) fn root(&self) -> ModuleId {\n+        self.root\n+    }\n+\n+    pub(crate) fn problems(&self) -> &CrateDefMapProblems {\n+        &self.problems\n+    }\n+\n+    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n+        self.modules.iter().map(|(id, _data)| id)\n+    }\n+\n+    pub(crate) fn find_module_by_source(\n+        &self,\n+        file_id: HirFileId,\n+        decl_id: Option<SourceFileItemId>,\n+    ) -> Option<ModuleId> {\n+        let decl_id = decl_id.map(|it| it.with_file_id(file_id));\n+        let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n+            if decl_id.is_some() {\n+                module_data.declaration == decl_id\n+            } else {\n+                module_data.definition.map(|it| it.into()) == Some(file_id)\n+            }\n+        })?;\n+        Some(module_id)\n+    }\n+\n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n-    #[allow(unused)]\n     fn resolve_path_fp(\n         &self,\n         db: &impl PersistentHirDatabase,\n@@ -182,7 +263,7 @@ impl CrateDefMap {\n                         );\n                     }\n \n-                    match self[module.module_id].items.get(&segment.name) {\n+                    match self[module.module_id].scope.items.get(&segment.name) {\n                         Some(res) if !res.def.is_none() => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n@@ -225,7 +306,8 @@ impl CrateDefMap {\n     }\n \n     fn resolve_name_in_crate_root_or_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n-        let from_crate_root = self[self.root].items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_crate_root =\n+            self[self.root].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n         let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n \n         from_crate_root.or(from_extern_prelude)\n@@ -241,7 +323,7 @@ impl CrateDefMap {\n         //  - current module / scope\n         //  - extern prelude\n         //  - std prelude\n-        let from_scope = self[module].items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_scope = self[module].scope.items.get(name).map_or(PerNs::none(), |it| it.def);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name);\n@@ -256,7 +338,7 @@ impl CrateDefMap {\n     fn resolve_in_prelude(&self, db: &impl PersistentHirDatabase, name: &Name) -> PerNs<ModuleDef> {\n         if let Some(prelude) = self.prelude {\n             let resolution = if prelude.krate == self.krate {\n-                self[prelude.module_id].items.get(name).cloned()\n+                self[prelude.module_id].scope.items.get(name).cloned()\n             } else {\n                 db.item_map(prelude.krate)[prelude.module_id].items.get(name).cloned()\n             };"}, {"sha": "2fbfa9e349930e710b968905c42c67402a7ed6f6", "filename": "crates/ra_hir/src/nameres/crate_def_map/collector.rs", "status": "modified", "additions": 100, "deletions": 66, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fcollector.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -1,42 +1,25 @@\n-use std::sync::Arc;\n-\n+use arrayvec::ArrayVec;\n use rustc_hash::FxHashMap;\n-use ra_arena::Arena;\n+use relative_path::RelativePathBuf;\n use test_utils::tested_by;\n+use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    Crate, PersistentHirDatabase, HirFileId, Name, Path,\n+    PersistentHirDatabase, HirFileId, Name, Path, Problem,\n     KnownName,\n     nameres::{Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode},\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId},\n-    module_tree::resolve_module_declaration,\n };\n \n use super::{CrateDefMap, ModuleId, ModuleData, raw};\n \n-#[allow(unused)]\n-pub(crate) fn crate_def_map_query(\n+pub(super) fn collect_defs(\n     db: &impl PersistentHirDatabase,\n-    krate: Crate,\n-) -> Arc<CrateDefMap> {\n-    let mut def_map = {\n-        let edition = krate.edition(db);\n-        let mut modules: Arena<ModuleId, ModuleData> = Arena::default();\n-        let root = modules.alloc(ModuleData::default());\n-        CrateDefMap {\n-            krate,\n-            edition,\n-            extern_prelude: FxHashMap::default(),\n-            prelude: None,\n-            root,\n-            modules,\n-            public_macros: FxHashMap::default(),\n-        }\n-    };\n-\n+    mut def_map: CrateDefMap,\n+) -> CrateDefMap {\n     // populate external prelude\n-    for dep in krate.dependencies(db) {\n+    for dep in def_map.krate.dependencies(db) {\n         log::debug!(\"crate dep {:?} -> {:?}\", dep.name, dep.krate);\n         if let Some(module) = dep.krate.root_module(db) {\n             def_map.extern_prelude.insert(dep.name.clone(), module.into());\n@@ -52,46 +35,36 @@ pub(crate) fn crate_def_map_query(\n \n     let mut collector = DefCollector {\n         db,\n-        krate,\n         def_map,\n         glob_imports: FxHashMap::default(),\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n         global_macro_scope: FxHashMap::default(),\n     };\n     collector.collect();\n-    let def_map = collector.finish();\n-    Arc::new(def_map)\n+    collector.finish()\n }\n \n /// Walks the tree of module recursively\n struct DefCollector<DB> {\n     db: DB,\n-    krate: Crate,\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<ModuleId, Vec<(ModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(ModuleId, raw::ImportId, raw::ImportData)>,\n     unexpanded_macros: Vec<(ModuleId, MacroCallId, Path, tt::Subtree)>,\n     global_macro_scope: FxHashMap<Name, mbe::MacroRules>,\n }\n \n-/// Walks a single module, populating defs, imports and macros\n-struct ModCollector<'a, D> {\n-    def_collector: D,\n-    module_id: ModuleId,\n-    file_id: HirFileId,\n-    raw_items: &'a raw::RawItems,\n-}\n-\n impl<'a, DB> DefCollector<&'a DB>\n where\n     DB: PersistentHirDatabase,\n {\n     fn collect(&mut self) {\n         let crate_graph = self.db.crate_graph();\n-        let file_id = crate_graph.crate_root(self.krate.crate_id());\n-        let raw_items = raw::RawItems::raw_items_query(self.db, file_id);\n+        let file_id = crate_graph.crate_root(self.def_map.krate.crate_id());\n+        let raw_items = self.db.raw_items(file_id);\n         let module_id = self.def_map.root;\n+        self.def_map.modules[module_id].definition = Some(file_id);\n         ModCollector {\n             def_collector: &mut *self,\n             module_id,\n@@ -123,10 +96,6 @@ where\n         }\n     }\n \n-    fn alloc_module(&mut self) -> ModuleId {\n-        self.def_map.modules.alloc(ModuleData::default())\n-    }\n-\n     fn resolve_imports(&mut self) -> ReachedFixedPoint {\n         let mut imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n         let mut resolved = Vec::new();\n@@ -184,7 +153,7 @@ where\n                     if import.is_prelude {\n                         tested_by!(std_prelude);\n                         self.def_map.prelude = Some(m);\n-                    } else if m.krate != self.krate {\n+                    } else if m.krate != self.def_map.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.item_map(m.krate);\n@@ -199,7 +168,7 @@ where\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n                         // additions\n-                        let scope = &self.def_map[m.module_id];\n+                        let scope = &self.def_map[m.module_id].scope;\n                         let items = scope\n                             .items\n                             .iter()\n@@ -243,11 +212,9 @@ where\n             log::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n             // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n-            if let Some(root_module) = self.krate.root_module(self.db) {\n-                if import.is_extern_crate && module_id == root_module.module_id {\n-                    if let Some(def) = def.take_types() {\n-                        self.def_map.extern_prelude.insert(name.clone(), def);\n-                    }\n+            if import.is_extern_crate && module_id == self.def_map.root {\n+                if let Some(def) = def.take_types() {\n+                    self.def_map.extern_prelude.insert(name.clone(), def);\n                 }\n             }\n             let resolution = Resolution { def, import: Some(import_id) };\n@@ -324,8 +291,7 @@ where\n                 Some(it) => it,\n                 _ => return true,\n             };\n-            // FIXME: this should be a proper query\n-            let def_map = crate_def_map_query(self.db, krate);\n+            let def_map = self.db.crate_def_map(krate);\n             let rules = def_map.public_macros.get(&path.segments[1].name).cloned();\n             resolved.push((*module_id, *call_id, rules, tt.clone()));\n             false\n@@ -367,6 +333,14 @@ where\n     }\n }\n \n+/// Walks a single module, populating defs, imports and macros\n+struct ModCollector<'a, D> {\n+    def_collector: D,\n+    module_id: ModuleId,\n+    file_id: HirFileId,\n+    raw_items: &'a raw::RawItems,\n+}\n+\n impl<DB> ModCollector<'_, &'_ mut DefCollector<&'_ DB>>\n where\n     DB: PersistentHirDatabase,\n@@ -389,8 +363,12 @@ where\n     fn collect_module(&mut self, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, items } => {\n-                let module_id = self.push_child_module(name.clone());\n+            raw::ModuleData::Definition { name, items, source_item_id } => {\n+                let module_id = self.push_child_module(\n+                    name.clone(),\n+                    source_item_id.with_file_id(self.file_id),\n+                    None,\n+                );\n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     module_id,\n@@ -400,13 +378,20 @@ where\n                 .collect(&*items);\n             }\n             // out of line module, resovle, parse and recurse\n-            raw::ModuleData::Declaration { name } => {\n-                let module_id = self.push_child_module(name.clone());\n+            raw::ModuleData::Declaration { name, source_item_id } => {\n+                let source_item_id = source_item_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n-                if let Some(file_id) =\n-                    resolve_module_declaration(self.def_collector.db, self.file_id, name, is_root)\n-                {\n-                    let raw_items = raw::RawItems::raw_items_query(self.def_collector.db, file_id);\n+                let (file_ids, problem) =\n+                    resolve_submodule(self.def_collector.db, self.file_id, name, is_root);\n+\n+                if let Some(problem) = problem {\n+                    self.def_collector.def_map.problems.add(source_item_id, problem)\n+                }\n+\n+                if let Some(&file_id) = file_ids.first() {\n+                    let module_id =\n+                        self.push_child_module(name.clone(), source_item_id, Some(file_id));\n+                    let raw_items = self.def_collector.db.raw_items(file_id);\n                     ModCollector {\n                         def_collector: &mut *self.def_collector,\n                         module_id,\n@@ -419,15 +404,23 @@ where\n         }\n     }\n \n-    fn push_child_module(&mut self, name: Name) -> ModuleId {\n-        let res = self.def_collector.alloc_module();\n-        self.def_collector.def_map.modules[res].parent = Some(self.module_id);\n-        self.def_collector.def_map.modules[self.module_id].children.insert(name, res);\n+    fn push_child_module(\n+        &mut self,\n+        name: Name,\n+        declaration: SourceItemId,\n+        definition: Option<FileId>,\n+    ) -> ModuleId {\n+        let modules = &mut self.def_collector.def_map.modules;\n+        let res = modules.alloc(ModuleData::default());\n+        modules[res].parent = Some(self.module_id);\n+        modules[res].declaration = Some(declaration);\n+        modules[res].definition = definition;\n+        modules[self.module_id].children.insert(name, res);\n         res\n     }\n \n     fn define_def(&mut self, def: &raw::DefData) {\n-        let module = Module { krate: self.def_collector.krate, module_id: self.module_id };\n+        let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id.into());\n         macro_rules! id {\n             () => {\n@@ -462,7 +455,7 @@ where\n \n         let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n         let macro_call_id = MacroCallLoc {\n-            module: Module { krate: self.def_collector.krate, module_id: self.module_id },\n+            module: Module { krate: self.def_collector.def_map.krate, module_id: self.module_id },\n             source_item_id,\n         }\n         .id(self.def_collector.db);\n@@ -491,3 +484,44 @@ where\n fn is_macro_rules(path: &Path) -> bool {\n     path.as_ident().and_then(Name::as_known_name) == Some(KnownName::MacroRules)\n }\n+\n+fn resolve_submodule(\n+    db: &impl PersistentHirDatabase,\n+    file_id: HirFileId,\n+    name: &Name,\n+    is_root: bool,\n+) -> (Vec<FileId>, Option<Problem>) {\n+    // FIXME: handle submodules of inline modules properly\n+    let file_id = file_id.original_file(db);\n+    let source_root_id = db.file_source_root(file_id);\n+    let path = db.file_relative_path(file_id);\n+    let root = RelativePathBuf::default();\n+    let dir_path = path.parent().unwrap_or(&root);\n+    let mod_name = path.file_stem().unwrap_or(\"unknown\");\n+    let is_dir_owner = is_root || mod_name == \"mod\";\n+\n+    let file_mod = dir_path.join(format!(\"{}.rs\", name));\n+    let dir_mod = dir_path.join(format!(\"{}/mod.rs\", name));\n+    let file_dir_mod = dir_path.join(format!(\"{}/{}.rs\", mod_name, name));\n+    let mut candidates = ArrayVec::<[_; 2]>::new();\n+    if is_dir_owner {\n+        candidates.push(file_mod.clone());\n+        candidates.push(dir_mod);\n+    } else {\n+        candidates.push(file_dir_mod.clone());\n+    };\n+    let sr = db.source_root(source_root_id);\n+    let points_to = candidates\n+        .into_iter()\n+        .filter_map(|path| sr.files.get(&path))\n+        .map(|&it| it)\n+        .collect::<Vec<_>>();\n+    let problem = if points_to.is_empty() {\n+        Some(Problem::UnresolvedModule {\n+            candidate: if is_dir_owner { file_mod } else { file_dir_mod },\n+        })\n+    } else {\n+        None\n+    };\n+    (points_to, problem)\n+}"}, {"sha": "f064f722cfb7f46821550620ba57327b1d7779c7", "filename": "crates/ra_hir/src/nameres/crate_def_map/raw.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Fraw.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -3,6 +3,7 @@ use std::{\n     ops::Index,\n };\n \n+use test_utils::tested_by;\n use ra_db::FileId;\n use ra_arena::{Arena, impl_arena_id, RawId};\n use ra_syntax::{\n@@ -15,8 +16,8 @@ use crate::{\n     ids::{SourceFileItemId, SourceFileItems},\n };\n \n-#[derive(Default, PartialEq, Eq)]\n-pub(crate) struct RawItems {\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct RawItems {\n     modules: Arena<Module, ModuleData>,\n     imports: Arena<ImportId, ImportData>,\n     defs: Arena<Def, DefData>,\n@@ -26,18 +27,21 @@ pub(crate) struct RawItems {\n }\n \n impl RawItems {\n-    pub(crate) fn items(&self) -> &[RawItem] {\n-        &self.items\n-    }\n-\n-    pub(crate) fn raw_items_query(db: &impl PersistentHirDatabase, file_id: FileId) -> RawItems {\n+    pub(crate) fn raw_items_query(\n+        db: &impl PersistentHirDatabase,\n+        file_id: FileId,\n+    ) -> Arc<RawItems> {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n             source_file_items: db.file_items(file_id.into()),\n         };\n         let source_file = db.parse(file_id);\n         collector.process_module(None, &*source_file);\n-        collector.raw_items\n+        Arc::new(collector.raw_items)\n+    }\n+\n+    pub(crate) fn items(&self) -> &[RawItem] {\n+        &self.items\n     }\n \n     // We can't use queries during name resolution for fear of cycles, so this\n@@ -81,32 +85,32 @@ impl Index<Macro> for RawItems {\n     }\n }\n \n-#[derive(PartialEq, Eq, Clone, Copy)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub(crate) enum RawItem {\n     Module(Module),\n     Import(ImportId),\n     Def(Def),\n     Macro(Macro),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct Module(RawId);\n impl_arena_id!(Module);\n \n-#[derive(PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(crate) enum ModuleData {\n-    Declaration { name: Name },\n-    Definition { name: Name, items: Vec<RawItem> },\n+    Declaration { name: Name, source_item_id: SourceFileItemId },\n+    Definition { name: Name, source_item_id: SourceFileItemId, items: Vec<RawItem> },\n }\n \n pub(crate) use crate::nameres::lower::ImportId;\n pub(super) use crate::nameres::lower::ImportData;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct Def(RawId);\n impl_arena_id!(Def);\n \n-#[derive(PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(crate) struct DefData {\n     pub(crate) source_item_id: SourceFileItemId,\n     pub(crate) name: Name,\n@@ -124,11 +128,11 @@ pub(crate) enum DefKind {\n     TypeAlias,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub(crate) struct Macro(RawId);\n impl_arena_id!(Macro);\n \n-#[derive(PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(crate) struct MacroData {\n     pub(crate) source_item_id: SourceFileItemId,\n     pub(crate) path: Path,\n@@ -191,18 +195,25 @@ impl RawItemsCollector {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n+        let source_item_id = self.source_file_items.id_of_unchecked(module.syntax());\n         if module.has_semi() {\n-            let item = self.raw_items.modules.alloc(ModuleData::Declaration { name });\n+            let item =\n+                self.raw_items.modules.alloc(ModuleData::Declaration { name, source_item_id });\n             self.push_item(current_module, RawItem::Module(item));\n             return;\n         }\n \n         if let Some(item_list) = module.item_list() {\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Definition { name, items: Vec::new() });\n+            let item = self.raw_items.modules.alloc(ModuleData::Definition {\n+                name,\n+                source_item_id,\n+                items: Vec::new(),\n+            });\n             self.process_module(Some(item), item_list);\n             self.push_item(current_module, RawItem::Module(item));\n+            return;\n         }\n+        tested_by!(name_res_works_for_broken_modules);\n     }\n \n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: &ast::UseItem) {"}, {"sha": "742a19e5cad61f3b96610050acb58e0f708adc13", "filename": "crates/ra_hir/src/nameres/crate_def_map/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcrate_def_map%2Ftests.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -15,7 +15,7 @@ fn compute_crate_def_map(fixture: &str, graph: Option<CrateGraphFixture>) -> Arc\n     }\n     let crate_id = db.crate_graph().iter().next().unwrap();\n     let krate = Crate { crate_id };\n-    collector::crate_def_map_query(&db, krate)\n+    db.crate_def_map(krate)\n }\n \n fn render_crate_def_map(map: &CrateDefMap) -> String {"}, {"sha": "961e442a9aad9692086849155f64a13938c5bf0d", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -7,7 +7,7 @@ use crate::{\n     ItemMap,\n     PersistentHirDatabase,\n     mock::MockDatabase,\n-    module_tree::ModuleId,\n+    nameres::crate_def_map::ModuleId,\n };\n use super::Resolution;\n \n@@ -359,6 +359,7 @@ fn std_prelude() {\n     let main_id = db.file_id_of(\"/main.rs\");\n \n     let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n+    eprintln!(\"module = {:?}\", module);\n     let krate = module.krate(&db).unwrap();\n     let item_map = db.item_map(krate);\n "}, {"sha": "62b699a64bdbe380c7e65872e7bdf6481c040cd0", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -80,8 +80,8 @@ fn module_from_source(\n     let source_root_id = db.file_source_root(file_id.as_original_file());\n     db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map(\n         |krate| {\n-            let module_tree = db.module_tree(krate);\n-            let module_id = module_tree.find_module_by_source(file_id, decl_id)?;\n+            let def_map = db.crate_def_map(krate);\n+            let module_id = def_map.find_module_by_source(file_id, decl_id)?;\n             Some(Module { krate, module_id })\n         },\n     )"}, {"sha": "7c77474b0aafc6b39f1e20baa7e44f4f9adea5bd", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -7,10 +7,12 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    HirDatabase, module_tree::ModuleId, Module, Crate, Name, Function, Trait,\n+    HirDatabase, Module, Crate, Name, Function, Trait,\n     ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n     ty::{AdtDef, Ty},\n+    nameres::crate_def_map::ModuleId,\n+\n };\n \n /// This is used as a key for indexing impls."}, {"sha": "2395930f0d765f07f90d7515511c938740238c0d", "filename": "crates/ra_ide_api/src/runnables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2195d1db6d70d64383bec82819fab02891d09744/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Frunnables.rs?ref=2195d1db6d70d64383bec82819fab02891d09744", "patch": "@@ -1,7 +1,7 @@\n use itertools::Itertools;\n use ra_syntax::{\n     TextRange, SyntaxNode,\n-    ast::{self, AstNode, NameOwner, ModuleItemOwner},\n+    ast::{self, AstNode, NameOwner, ModuleItemOwner, AttrsOwner},\n };\n use ra_db::SourceDatabase;\n "}]}