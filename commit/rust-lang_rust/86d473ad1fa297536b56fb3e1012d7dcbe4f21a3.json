{"sha": "86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZDQ3M2FkMWZhMjk3NTM2YjU2ZmIzZTEwMTJkN2RjYmU0ZjIxYTM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-30T16:28:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-30T16:28:30Z"}, "message": "Substitute type parameters more eagerly\n\nThis simplifies the typechecker a bit (no more ty_param_substs_opt_and_ty)\nand is needed for another experiment I'm playing with. I hope it also\nmakes compilation faster (the bots will tell).", "tree": {"sha": "544002c0c51d5bf4165b7b7bd50acb0d093e0b7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/544002c0c51d5bf4165b7b7bd50acb0d093e0b7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "html_url": "https://github.com/rust-lang/rust/commit/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "964bd485c6837fa08212451f45878746c9d3d308", "url": "https://api.github.com/repos/rust-lang/rust/commits/964bd485c6837fa08212451f45878746c9d3d308", "html_url": "https://github.com/rust-lang/rust/commit/964bd485c6837fa08212451f45878746c9d3d308"}], "stats": {"total": 505, "additions": 201, "deletions": 304}, "files": [{"sha": "bcd760b5c61cab219e9678a476fb827c8577bcb0", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -8,7 +8,7 @@ import syntax::ast_util::local_def;\n import common::*;\n import middle::trans::common::crate_ctxt;\n import middle::ty;\n-import middle::ty::node_id_to_monotype;\n+import middle::ty::node_id_to_type;\n import front::attr;\n \n export encode_metadata;\n@@ -243,7 +243,7 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_name(ebml_w, variant.node.name);\n         encode_enum_id(ebml_w, local_def(id));\n         encode_type(ecx, ebml_w,\n-                    node_id_to_monotype(ecx.ccx.tcx, variant.node.id));\n+                    node_id_to_type(ecx.ccx.tcx, variant.node.id));\n         if vec::len::<variant_arg>(variant.node.args) > 0u {\n             encode_symbol(ecx, ebml_w, variant.node.id);\n         }\n@@ -287,7 +287,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'c' as u8);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n       }\n@@ -301,7 +301,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         impure_fn { 'f' }\n                       } as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n       }\n@@ -320,7 +320,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'y' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         ebml::end_tag(ebml_w);\n       }\n@@ -329,7 +329,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 't' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for v: variant in variants {\n             encode_variant_id(ebml_w, local_def(v.node.id));\n@@ -338,7 +338,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_enum_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n       }\n       item_res(_, tps, _, _, ctor_id) {\n-        let fn_ty = node_id_to_monotype(tcx, ctor_id);\n+        let fn_ty = node_id_to_type(tcx, ctor_id);\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(ctor_id));\n@@ -363,7 +363,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'i' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         for m in methods {\n             ebml::start_tag(ebml_w, tag_item_method);\n@@ -389,7 +389,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             encode_family(ebml_w, 'f' as u8);\n             encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n             encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(tcx, m.id));\n+                        node_id_to_type(tcx, m.id));\n             encode_name(ebml_w, m.ident);\n             encode_symbol(ecx, ebml_w, m.id);\n             ebml::end_tag(ebml_w);\n@@ -400,7 +400,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'I' as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n         let i = 0u;\n         for mty in *ty::iface_methods(tcx, local_def(item.id)) {\n@@ -435,7 +435,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, letter);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n-        encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, nitem.id));\n+        encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n       }\n     }"}, {"sha": "d8dca5c01151a45edaffb9a7d405ec6ffefd9485", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -59,7 +59,7 @@ fn check_crate(tcx: ty::ctxt, method_map: typeck::method_map,\n // closure.\n fn with_appropriate_checker(cx: ctx, id: node_id,\n                             b: fn(fn@(ctx, ty::t, sp: span))) {\n-    let fty = ty::node_id_to_monotype(cx.tcx, id);\n+    let fty = ty::node_id_to_type(cx.tcx, id);\n     alt ty::ty_fn_proto(cx.tcx, fty) {\n       proto_uniq { b(check_send); }\n       proto_box { b(check_copy); }\n@@ -168,8 +168,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_path(_) {\n-        let substs = ty::node_id_to_ty_param_substs_opt_and_ty(cx.tcx, e.id);\n-        alt substs.substs {\n+        alt cx.tcx.node_type_substs.find(e.id) {\n           some(ts) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;"}, {"sha": "ceaff558286a5e153696ef290f8380a9da2ebca7", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -64,7 +64,7 @@ fn find_last_uses(c: @crate, def_map: resolve::def_map,\n }\n \n fn ex_is_blockish(cx: ctx, id: node_id) -> bool {\n-    alt ty::struct(cx.tcx, ty::node_id_to_monotype(cx.tcx, id)) {\n+    alt ty::struct(cx.tcx, ty::node_id_to_type(cx.tcx, id)) {\n       ty::ty_fn({proto: p, _}) if is_blockish(p) { true }\n       _ { false }\n     }"}, {"sha": "ef40d4a87b20d877b0ca7eecf8b60506a8dacf59", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -268,7 +268,7 @@ fn is_immutable_def(cx: @ctx, def: def) -> option::t<str> {\n       def_arg(_, mode_infer) { some(\"argument\") }\n       def_self(_) { some(\"self argument\") }\n       def_upvar(_, inner, node_id) {\n-        let ty = ty::node_id_to_monotype(cx.tcx, node_id);\n+        let ty = ty::node_id_to_type(cx.tcx, node_id);\n         let proto = ty::ty_fn_proto(cx.tcx, ty);\n         ret alt proto {\n           proto_any | proto_block { is_immutable_def(cx, *inner) }"}, {"sha": "366833bed05b7851ba5046f085b2a9c4ef6771c6", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -419,7 +419,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n     if vec::len(rec_fields) > 0u {\n-        let rec_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n+        let rec_ty = ty::node_id_to_type(ccx.tcx, pat_id);\n         let fields =\n             alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n         let rec_vals = [];\n@@ -437,7 +437,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     }\n \n     if any_tup_pat(m, col) {\n-        let tup_ty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n+        let tup_ty = ty::node_id_to_type(ccx.tcx, pat_id);\n         let n_tup_elts =\n             alt ty::struct(ccx.tcx, tup_ty) {\n               ty::ty_tup(elts) { vec::len(elts) }\n@@ -492,7 +492,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n           }\n           lit(l) {\n             test_val = Load(bcx, val);\n-            let pty = ty::node_id_to_monotype(ccx.tcx, pat_id);\n+            let pty = ty::node_id_to_type(ccx.tcx, pat_id);\n             kind = ty::type_is_integral(ccx.tcx, pty) ? switch : compare;\n           }\n           range(_, _) {\n@@ -709,7 +709,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n     alt normalize_pat(bcx_tcx(bcx), pat).node {\n       ast::pat_ident(_,inner) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n-            let ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n+            let ty = ty::node_id_to_type(ccx.tcx, pat.id);\n             // FIXME: Could constrain pat_bind to make this\n             // check unnecessary.\n             check (type_has_static_size(ccx, ty));\n@@ -737,7 +737,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_rec(fields, _) {\n-        let rec_ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n+        let rec_ty = ty::node_id_to_type(ccx.tcx, pat.id);\n         let rec_fields =\n             alt ty::struct(ccx.tcx, rec_ty) { ty::ty_rec(fields) { fields } };\n         for f: ast::field_pat in fields {\n@@ -749,7 +749,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_tup(elems) {\n-        let tup_ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n+        let tup_ty = ty::node_id_to_type(ccx.tcx, pat.id);\n         let i = 0u;\n         for elem in elems {\n             // how to get rid of this check?"}, {"sha": "75144c32d21bcda58075ba20fbe1e385292e4935", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -2048,7 +2048,7 @@ fn trans_lit(cx: @block_ctxt, lit: ast::lit, dest: dest) -> @block_ctxt {\n \n // Converts an annotation to a type\n fn node_id_type(cx: @crate_ctxt, id: ast::node_id) -> ty::t {\n-    ret ty::node_id_to_monotype(cx.tcx, id);\n+    ret ty::node_id_to_type(cx.tcx, id);\n }\n \n fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n@@ -2057,7 +2057,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n     alt bcx_ccx(bcx).method_map.find(un_expr.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(un_expr);\n-        let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n+        let fty = ty::node_id_to_type(bcx_tcx(bcx), callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             impl::trans_method_callee(bcx, callee_id, e, origin)\n         }, [], un_expr.id, dest);\n@@ -2195,7 +2195,7 @@ fn trans_assign_op(bcx: @block_ctxt, ex: @ast::expr, op: ast::binop,\n     alt bcx_ccx(bcx).method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n-        let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n+        let fty = ty::node_id_to_type(bcx_tcx(bcx), callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             // FIXME provide the already-computed address, not the expr\n             impl::trans_method_callee(bcx, callee_id, dst, origin)\n@@ -2317,7 +2317,7 @@ fn trans_binary(bcx: @block_ctxt, op: ast::binop, lhs: @ast::expr,\n     alt bcx_ccx(bcx).method_map.find(ex.id) {\n       some(origin) {\n         let callee_id = ast_util::op_expr_callee_id(ex);\n-        let fty = ty::node_id_to_monotype(bcx_tcx(bcx), callee_id);\n+        let fty = ty::node_id_to_type(bcx_tcx(bcx), callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             impl::trans_method_callee(bcx, callee_id, lhs, origin)\n         }, [rhs], ex.id, dest);\n@@ -2681,7 +2681,7 @@ fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n             assert (ccx.consts.contains_key(did.node));\n             ret lval_no_env(cx, ccx.consts.get(did.node), owned);\n         } else {\n-            let tp = ty::node_id_to_monotype(ccx.tcx, id);\n+            let tp = ty::node_id_to_type(ccx.tcx, id);\n             let val = trans_external_path(cx, did, {bounds: @[], ty: tp});\n             ret lval_no_env(cx, load_if_immediate(cx, val, tp), owned_imm);\n         }\n@@ -3544,7 +3544,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         // If it is here, it's not an lval, so this is a user-defined index op\n         let origin = bcx_ccx(bcx).method_map.get(e.id);\n         let callee_id = ast_util::op_expr_callee_id(e);\n-        let fty = ty::node_id_to_monotype(tcx, callee_id);\n+        let fty = ty::node_id_to_type(tcx, callee_id);\n         ret trans_call_inner(bcx, fty, {|bcx|\n             impl::trans_method_callee(bcx, callee_id, base, origin)\n         }, [idx], e.id, dest);"}, {"sha": "ed1d5e9158ab3354c6720ecc715cf072d76cbcd8", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -417,7 +417,7 @@ fn build_closure(bcx0: @block_ctxt,\n     vec::iter(cap_vars) { |cap_var|\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n-        let ty = ty::node_id_to_monotype(tcx, nid);\n+        let ty = ty::node_id_to_type(tcx, nid);\n         alt cap_var.mode {\n           capture::cap_ref {\n             assert ck == ty::ck_block;"}, {"sha": "0798e0236f58be97d6ef773208a4edbaf992b8c7", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -46,7 +46,7 @@ fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n         alt cx.ccx.item_ids.find(m.id) {\n           some(llfn) {\n             trans_fn(extend_path(sub_cx, m.ident), m.span, m.decl, m.body,\n-                     llfn, impl_self(ty::node_id_to_monotype(cx.ccx.tcx, id)),\n+                     llfn, impl_self(ty::node_id_to_type(cx.ccx.tcx, id)),\n                      tps + m.tps, m.id);\n           }\n         }"}, {"sha": "8ff292d5ffd41674c5d89f92b4853564fd7cf556", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 56, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -22,10 +22,8 @@ import util::ppaux::ty_constr_to_str;\n import util::ppaux::mode_str;\n import syntax::print::pprust::*;\n \n-export node_id_to_monotype;\n export node_id_to_type;\n export node_id_to_type_params;\n-export node_id_to_ty_param_substs_opt_and_ty;\n export arg;\n export args_eq;\n export ast_constr_to_constr;\n@@ -103,7 +101,6 @@ export new_ty_hash;\n export enum_variants;\n export iface_methods, store_iface_methods, impl_iface;\n export enum_variant_with_id;\n-export ty_param_substs_opt_and_ty;\n export ty_param_bounds_and_ty;\n export ty_bool;\n export ty_bot;\n@@ -136,7 +133,6 @@ export ty_var;\n export ty_named;\n export same_type;\n export ty_var_id;\n-export ty_param_substs_opt_and_ty_to_monotype;\n export ty_fn_args;\n export type_constr;\n export type_contains_params;\n@@ -212,6 +208,7 @@ type ctxt =\n       sess: session::session,\n       def_map: resolve::def_map,\n       node_types: node_type_table,\n+      node_type_substs: hashmap<node_id, [t]>,\n       items: ast_map::map,\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n@@ -369,12 +366,7 @@ const idx_first_others: uint = 20u;\n \n type type_store = interner::interner<@raw_t>;\n \n-// substs is a list of actuals that correspond to ty's\n-// formal parameters\n-type ty_param_substs_opt_and_ty = {substs: option::t<[ty::t]>, ty: ty::t};\n-\n-type node_type_table =\n-    @smallintmap::smallintmap<ty::ty_param_substs_opt_and_ty>;\n+type node_type_table = @smallintmap::smallintmap<t>;\n \n fn populate_type_store(cx: ctxt) {\n     intern(cx, ty_nil);\n@@ -415,8 +407,6 @@ fn new_ty_hash<V: copy>() -> map::hashmap<t, V> { map::new_uint_hash() }\n \n fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n            freevars: freevars::freevar_map) -> ctxt {\n-    let ntt: node_type_table =\n-        @smallintmap::mk::<ty::ty_param_substs_opt_and_ty>();\n     fn eq_raw_ty(&&a: @raw_t, &&b: @raw_t) -> bool {\n         ret a.hash == b.hash && a.struct == b.struct;\n     }\n@@ -425,7 +415,8 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n         @{ts: ts,\n           sess: s,\n           def_map: dm,\n-          node_types: ntt,\n+          node_types: @smallintmap::mk(),\n+          node_type_substs: map::new_int_hash(),\n           items: amap,\n           freevars: freevars,\n           tcache: new_def_hash(),\n@@ -1442,55 +1433,21 @@ fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n     ret true;\n }\n \n-// Type lookups\n-fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n-   ty_param_substs_opt_and_ty {\n-    // Pull out the node type table.\n-    alt smallintmap::find(*cx.node_types, id as uint) {\n-      none {\n-        cx.sess.bug(\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n-                        \"an untyped node (\" + int::to_str(id, 10u) +\n-                        \")\");\n-      }\n-      some(tpot) { ret tpot; }\n-    }\n-}\n-\n fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n-    ret node_id_to_ty_param_substs_opt_and_ty(cx, id).ty;\n+    smallintmap::get(*cx.node_types, id as uint)\n }\n \n fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> [t] {\n-    alt node_id_to_ty_param_substs_opt_and_ty(cx, id).substs {\n+    alt cx.node_type_substs.find(id) {\n       none { ret []; }\n-      some(tps) { ret tps; }\n+      some(ts) { ret ts; }\n     }\n }\n \n fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n-    ret vec::len(node_id_to_type_params(cx, id)) > 0u;\n-}\n-\n-\n-// Returns a type with type parameter substitutions performed if applicable\n-fn ty_param_substs_opt_and_ty_to_monotype(cx: ctxt,\n-                                          tpot: ty_param_substs_opt_and_ty) ->\n-   t {\n-    alt tpot.substs {\n-      none { ret tpot.ty; }\n-      some(tps) { ret substitute_type_params(cx, tps, tpot.ty); }\n-    }\n-}\n-\n-\n-// Returns the type of an annotation, with type parameter substitutions\n-// performed if applicable\n-fn node_id_to_monotype(cx: ctxt, id: ast::node_id) -> t {\n-    let tpot = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n-    ret ty_param_substs_opt_and_ty_to_monotype(cx, tpot);\n+    ret cx.node_type_substs.contains_key(id);\n }\n \n-\n // Returns the number of distinct type parameters in the given type.\n fn count_ty_params(cx: ctxt, ty: t) -> uint {\n     fn counter(cx: ctxt, param_indices: @mutable [uint], ty: t) {\n@@ -1587,7 +1544,7 @@ fn block_ty(cx: ctxt, b: ast::blk) -> t {\n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n-    ret node_id_to_monotype(cx, pat.id);\n+    ret node_id_to_type(cx, pat.id);\n }\n \n \n@@ -1598,7 +1555,7 @@ fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n fn expr_ty(cx: ctxt, expr: @ast::expr) -> t {\n-    ret node_id_to_monotype(cx, expr.id);\n+    ret node_id_to_type(cx, expr.id);\n }\n \n fn expr_ty_params_and_ty(cx: ctxt, expr: @ast::expr) -> {params: [t], ty: t} {\n@@ -1740,7 +1697,6 @@ mod unify {\n             }\n         );\n \n-\n         alt smallintmap::find(vb.types, root_a) {\n           none {\n             alt smallintmap::find(vb.types, root_b) {\n@@ -2534,7 +2490,6 @@ fn type_err_to_str(err: ty::type_err) -> str {\n // Replaces type parameters in the given type using the given list of\n // substitions.\n fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n-\n    if !type_contains_params(cx, typ) { ret typ; }\n     // Precondition? idx < vec::len(substs)\n     fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _did: def_id)\n@@ -2603,7 +2558,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n           ast_map::node_item(@{node: ast::item_enum(variants, _), _}) {\n             let disr_val = -1;\n             @vec::map(variants, {|variant|\n-                let ctor_ty = node_id_to_monotype(cx, variant.node.id);\n+                let ctor_ty = node_id_to_type(cx, variant.node.id);\n                 let arg_tys = if vec::len(variant.node.args) > 0u {\n                     vec::map(ty_fn_args(cx, ctor_ty), {|a| a.ty})\n                 } else { [] };"}, {"sha": "c1f197731363f3f3cca75423b9030034246365a5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 161, "deletions": 218, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86d473ad1fa297536b56fb3e1012d7dcbe4f21a3/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=86d473ad1fa297536b56fb3e1012d7dcbe4f21a3", "patch": "@@ -10,7 +10,7 @@ import pat_util::*;\n import middle::ty;\n import middle::ty::{node_id_to_type, arg, block_ty,\n                     expr_ty, field, node_type_table, mk_nil,\n-                    ty_param_substs_opt_and_ty, ty_param_bounds_and_ty};\n+                    ty_param_bounds_and_ty};\n import util::ppaux::ty_to_str;\n import middle::ty::unify::{ures_ok, ures_err, fix_ok, fix_err};\n import core::{int, vec, str, option};\n@@ -137,33 +137,35 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n-                    tpt: ty_param_bounds_and_ty, sp: span)\n-    -> ty_param_substs_opt_and_ty {\n+                    tpt: ty_param_bounds_and_ty, sp: span,\n+                    id: ast::node_id) {\n     let ty_param_count = vec::len(*tpt.bounds);\n-    let vars = vec::init_fn(ty_param_count, {|_i| next_ty_var(fcx)});\n     let ty_substs_len = vec::len(pth.node.types);\n     if ty_substs_len > 0u {\n-        let param_var_len = vec::len(vars);\n-        if param_var_len == 0u {\n+        if ty_param_count == 0u {\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"this item does not take type parameters\");\n-        } else if ty_substs_len > param_var_len {\n+        } else if ty_substs_len > ty_param_count {\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"too many type parameter provided for this item\");\n-        } else if ty_substs_len < param_var_len {\n+        } else if ty_substs_len < ty_param_count {\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, \"not enough type parameters provided for this item\");\n         }\n-        vec::iter2(pth.node.types, vars) {|sub, var|\n-            let ty_subst = ast_ty_to_ty_crate(fcx.ccx, sub);\n-            demand::simple(fcx, pth.span, var, ty_subst);\n-        }\n         if ty_param_count == 0u {\n             fcx.ccx.tcx.sess.span_fatal(\n                 sp, \"this item does not take type parameters\");\n         }\n+        let substs = vec::map(pth.node.types, {|aty|\n+            ast_ty_to_ty_crate(fcx.ccx, aty)\n+        });\n+        write_ty_substs(fcx.ccx.tcx, id, tpt.ty, substs);\n+    } else if ty_param_count > 0u {\n+        let vars = vec::init_fn(ty_param_count, {|_i| next_ty_var(fcx)});\n+        write_ty_substs(fcx.ccx.tcx, id, tpt.ty, vars);\n+    } else {\n+        write_ty(fcx.ccx.tcx, id, tpt.ty);\n     }\n-    {substs: some(vars), ty: tpt.ty}\n }\n \n // Type tests\n@@ -547,50 +549,25 @@ fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n \n \n // Functions that write types into the node type table\n-mod write {\n-    fn inner(ntt: node_type_table, node_id: ast::node_id,\n-             tpot: ty_param_substs_opt_and_ty) {\n-        smallintmap::insert(*ntt, node_id as uint, tpot);\n-    }\n-\n-    // Writes a type parameter count and type pair into the node type table.\n-    fn ty(tcx: ty::ctxt, node_id: ast::node_id,\n-          tpot: ty_param_substs_opt_and_ty) {\n-        assert (!ty::type_contains_vars(tcx, tpot.ty));\n-        inner(tcx.node_types, node_id, tpot);\n-    }\n-\n-    // Writes a type parameter count and type pair into the node type table.\n-    // This function allows for the possibility of type variables, which will\n-    // be rewritten later during the fixup mode.\n-    fn ty_fixup(fcx: @fn_ctxt, node_id: ast::node_id,\n-                tpot: ty_param_substs_opt_and_ty) {\n-        inner(fcx.ccx.tcx.node_types, node_id, tpot);\n-        if ty::type_contains_vars(fcx.ccx.tcx, tpot.ty) {\n-            fcx.fixups += [node_id];\n-        }\n-    }\n-\n-    // Writes a type with no type parameters into the node type table.\n-    fn ty_only(tcx: ty::ctxt, node_id: ast::node_id, typ: ty::t) {\n-        ty(tcx, node_id, {substs: none::<[ty::t]>, ty: typ});\n-    }\n-\n-    // Writes a type with no type parameters into the node type table. This\n-    // function allows for the possibility of type variables.\n-    fn ty_only_fixup(fcx: @fn_ctxt, node_id: ast::node_id, typ: ty::t) {\n-        ret ty_fixup(fcx, node_id, {substs: none::<[ty::t]>, ty: typ});\n-    }\n-\n-    // Writes a nil type into the node type table.\n-    fn nil_ty(tcx: ty::ctxt, node_id: ast::node_id) {\n-        ret ty(tcx, node_id, {substs: none::<[ty::t]>, ty: ty::mk_nil(tcx)});\n-    }\n-\n-    // Writes the bottom type into the node type table.\n-    fn bot_ty(tcx: ty::ctxt, node_id: ast::node_id) {\n-        ret ty(tcx, node_id, {substs: none::<[ty::t]>, ty: ty::mk_bot(tcx)});\n-    }\n+fn write_ty(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n+    smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n+}\n+fn write_substs(tcx: ty::ctxt, node_id: ast::node_id, +substs: [ty::t]) {\n+    tcx.node_type_substs.insert(node_id, substs);\n+}\n+fn write_ty_substs(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n+                   +substs: [ty::t]) {\n+    let ty = if ty::type_contains_params(tcx, ty) {\n+        ty::substitute_type_params(tcx, substs, ty)\n+    } else { ty };\n+    write_ty(tcx, node_id, ty);\n+    write_substs(tcx, node_id, substs);\n+}\n+fn write_nil(tcx: ty::ctxt, node_id: ast::node_id) {\n+    write_ty(tcx, node_id, ty::mk_nil(tcx));\n+}\n+fn write_bot(tcx: ty::ctxt, node_id: ast::node_id) {\n+    write_ty(tcx, node_id, ty::mk_bot(tcx));\n }\n \n fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n@@ -673,7 +650,7 @@ mod collect {\n             let tpt = {bounds: ty_param_bounds(cx.tcx, m_collect, ty_params),\n                        ty: result_ty};\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n-            write::ty_only(cx.tcx, variant.node.id, result_ty);\n+            write_ty(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n     fn convert(cx: @ctxt, it: @ast::item) {\n@@ -682,7 +659,7 @@ mod collect {\n           ast::item_mod(_) | ast::item_native_mod(_) {}\n           ast::item_enum(variants, ty_params) {\n             let tpt = ty_of_item(cx.tcx, m_collect, it);\n-            write::ty_only(cx.tcx, it.id, tpt.ty);\n+            write_ty(cx.tcx, it.id, tpt.ty);\n             get_enum_variant_types(cx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(tps, ifce, selfty, ms) {\n@@ -696,9 +673,9 @@ mod collect {\n                 cx.tcx.tcache.insert(local_def(m.id),\n                                      {bounds: @(*i_bounds + *bounds),\n                                       ty: fty});\n-                write::ty_only(cx.tcx, m.id, fty);\n+                write_ty(cx.tcx, m.id, fty);\n             }\n-            write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n+            write_ty(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n                                                        selfty));\n             alt ifce {\n               some(t) {\n@@ -746,15 +723,15 @@ mod collect {\n                 inputs: [t_arg], output: ty::mk_nil(cx.tcx),\n                 ret_style: ast::return_val, constraints: []\n             });\n-            write::ty_only(cx.tcx, it.id, t_res);\n-            write::ty_only(cx.tcx, ctor_id, t_ctor);\n+            write_ty(cx.tcx, it.id, t_res);\n+            write_ty(cx.tcx, ctor_id, t_ctor);\n             cx.tcx.tcache.insert(local_def(ctor_id),\n                                  {bounds: bounds, ty: t_ctor});\n-            write::ty_only(cx.tcx, dtor_id, t_dtor);\n+            write_ty(cx.tcx, dtor_id, t_dtor);\n           }\n           ast::item_iface(_, ms) {\n             let tpt = ty_of_item(cx.tcx, m_collect, it);\n-            write::ty_only(cx.tcx, it.id, tpt.ty);\n+            write_ty(cx.tcx, it.id, tpt.ty);\n             ty::store_iface_methods(cx.tcx, it.id, @vec::map(ms, {|m|\n                 ty_of_ty_method(cx.tcx, m_collect, m)\n             }));\n@@ -764,7 +741,7 @@ mod collect {\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n             let tpt = ty_of_item(cx.tcx, m_collect, it);\n-            write::ty_only(cx.tcx, it.id, tpt.ty);\n+            write_ty(cx.tcx, it.id, tpt.ty);\n           }\n         }\n     }\n@@ -778,7 +755,7 @@ mod collect {\n             // FIXME: Native types have no annotation. Should they? --pcw\n           }\n           ast::native_item_fn(_, _) {\n-            write::ty_only(cx.tcx, i.id, tpt.ty);\n+            write_ty(cx.tcx, i.id, tpt.ty);\n           }\n         }\n     }\n@@ -971,28 +948,24 @@ mod writeback {\n         }\n     }\n     fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id) {\n-        let fcx = wbcx.fcx;\n-        let tpot = ty::node_id_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx, id);\n-        let new_ty =\n-            alt resolve_type_vars_in_type(fcx, sp, tpot.ty) {\n-              some(t) { t }\n-              none { wbcx.success = false; ret }\n-            };\n-        let new_substs_opt;\n-        alt tpot.substs {\n-          none { new_substs_opt = none; }\n+        let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n+        alt resolve_type_vars_in_type(fcx, sp, ty::node_id_to_type(tcx, id)) {\n+          some(t) { write_ty(tcx, id, t); }\n+          none { wbcx.success = false; ret }\n+        }\n+        alt tcx.node_type_substs.find(id) {\n           some(substs) {\n-            let new_substs: [ty::t] = [];\n+            let new_substs = [];\n             for subst: ty::t in substs {\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n                   some(t) { new_substs += [t]; }\n                   none { wbcx.success = false; ret; }\n                 }\n             }\n-            new_substs_opt = some(new_substs);\n+            write_substs(tcx, id, new_substs);\n           }\n+          none {}\n         }\n-        write::ty(fcx.ccx.tcx, id, {substs: new_substs_opt, ty: new_ty});\n     }\n \n     type wb_ctxt =\n@@ -1037,7 +1010,7 @@ mod writeback {\n             ty::unify::resolve_type_var(wbcx.fcx.ccx.tcx, some(l.span),\n                                         wbcx.fcx.var_bindings, var_id);\n         alt fix_rslt {\n-          fix_ok(lty) { write::ty_only(wbcx.fcx.ccx.tcx, l.node.id, lty); }\n+          fix_ok(lty) { write_ty(wbcx.fcx.ccx.tcx, l.node.id, lty); }\n           fix_err(_) {\n             wbcx.fcx.ccx.tcx.sess.span_err(l.span,\n                                            \"cannot determine a type \\\n@@ -1185,53 +1158,48 @@ fn valid_range_bounds(from: @ast::expr, to: @ast::expr) -> bool {\n // their types immediately.\n fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n              expected: ty::t) {\n-    alt normalize_pat(fcx.ccx.tcx, pat).node {\n+    let tcx = fcx.ccx.tcx;\n+    alt normalize_pat(tcx, pat).node {\n       ast::pat_wild {\n           alt structure_of(fcx, pat.span, expected) {\n                   ty::ty_enum(_, expected_tps) {\n-                      let path_tpt = {substs: some(expected_tps),\n-                                      ty: expected};\n-                      write::ty_fixup(fcx, pat.id, path_tpt);\n+                    write_ty_substs(tcx, pat.id, expected,\n+                                    expected_tps);\n                   }\n                   _ {\n-                      write::ty_only_fixup(fcx, pat.id, expected);\n+                    write_ty(tcx, pat.id, expected);\n                   }\n               }\n       }\n       ast::pat_lit(lt) {\n         check_expr_with(fcx, lt, expected);\n-        write::ty_only_fixup(fcx, pat.id, expr_ty(fcx.ccx.tcx, lt));\n+        write_ty(tcx, pat.id, expr_ty(tcx, lt));\n       }\n       ast::pat_range(begin, end) {\n         check_expr_with(fcx, begin, expected);\n         check_expr_with(fcx, end, expected);\n-        let b_ty = resolve_type_vars_if_possible(fcx, expr_ty(fcx.ccx.tcx,\n-                                                              begin));\n-        if !ty::same_type(fcx.ccx.tcx, b_ty, resolve_type_vars_if_possible(\n-            fcx, expr_ty(fcx.ccx.tcx, end))) {\n-            fcx.ccx.tcx.sess.span_err(pat.span, \"mismatched types in range\");\n-        } else if !ty::type_is_numeric(fcx.ccx.tcx, b_ty) {\n-            fcx.ccx.tcx.sess.span_err(pat.span,\n-                                      \"non-numeric type used in range\");\n+        let b_ty = resolve_type_vars_if_possible(fcx, expr_ty(tcx, begin));\n+        if !ty::same_type(tcx, b_ty, resolve_type_vars_if_possible(\n+            fcx, expr_ty(tcx, end))) {\n+            tcx.sess.span_err(pat.span, \"mismatched types in range\");\n+        } else if !ty::type_is_numeric(tcx, b_ty) {\n+            tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n         } else if !valid_range_bounds(begin, end) {\n-            fcx.ccx.tcx.sess.span_err(begin.span,\n-                                      \"lower range bound must be less \\\n-                                       than upper\");\n+            tcx.sess.span_err(begin.span, \"lower range bound must be less \\\n+                                           than upper\");\n         }\n-        write::ty_only_fixup(fcx, pat.id, b_ty);\n+        write_ty(tcx, pat.id, b_ty);\n       }\n       ast::pat_ident(name, sub) {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n-        let typ = ty::mk_var(fcx.ccx.tcx, vid);\n+        let typ = ty::mk_var(tcx, vid);\n         typ = demand::simple(fcx, pat.span, expected, typ);\n         let canon_id = map.get(path_to_ident(name));\n         if canon_id != pat.id {\n-            let ct =\n-                ty::mk_var(fcx.ccx.tcx,\n-                           lookup_local(fcx, pat.span, canon_id));\n+            let ct = ty::mk_var(tcx, lookup_local(fcx, pat.span, canon_id));\n             typ = demand::simple(fcx, pat.span, ct, typ);\n         }\n-        write::ty_only_fixup(fcx, pat.id, typ);\n+        write_ty(tcx, pat.id, typ);\n         alt sub {\n           some(p) { check_pat(fcx, map, p, expected); }\n           _ {}\n@@ -1241,92 +1209,75 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         // Typecheck the path.\n         let v_def = lookup_def(fcx, path.span, pat.id);\n         let v_def_ids = ast_util::variant_def_ids(v_def);\n-        let enum_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids.tg);\n-        let path_tpot = instantiate_path(fcx, path, enum_tpt, pat.span);\n+        let ctor_tpt = ty::lookup_item_type(tcx, v_def_ids.tg);\n+        instantiate_path(fcx, path, ctor_tpt, pat.span, pat.id);\n \n         // Take the enum type params out of `expected`.\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_enum(_, expected_tps) {\n-            // Unify with the expected enum type.\n-            let ctor_ty =\n-                ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n-                                                           path_tpot);\n-\n-            let path_tpt =\n-                demand::with_substs(fcx, pat.span, expected, ctor_ty,\n-                                    expected_tps);\n-            path_tpot =\n-                {substs: some::<[ty::t]>(path_tpt.substs), ty: path_tpt.ty};\n-\n+            let ctor_ty = ty::node_id_to_type(tcx, pat.id);\n+            demand::with_substs(fcx, pat.span, expected, ctor_ty,\n+                                expected_tps);\n             // Get the number of arguments in this enum variant.\n             let arg_types =\n                 variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n                                   expected_tps);\n             let subpats_len = vec::len::<@ast::pat>(subpats);\n             if vec::len::<ty::t>(arg_types) > 0u {\n                 // N-ary variant.\n-\n                 let arg_len = vec::len::<ty::t>(arg_types);\n                 if arg_len != subpats_len {\n                     // TODO: note definition of enum variant\n                     // TODO (issue #448): Wrap a #fmt string over multiple\n                     // lines...\n-                    let s =\n-                        #fmt[\"this pattern has %u field%s, but the \\\n-                                       corresponding variant has %u field%s\",\n-                             subpats_len,\n-                             if subpats_len == 1u { \"\" } else { \"s\" },\n-                             arg_len, if arg_len == 1u { \"\" } else { \"s\" }];\n-                    fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n+                    let s = #fmt[\"this pattern has %u field%s, but the \\\n+                                  corresponding variant has %u field%s\",\n+                                 subpats_len,\n+                                 if subpats_len == 1u { \"\" } else { \"s\" },\n+                                 arg_len,\n+                                 if arg_len == 1u { \"\" } else { \"s\" }];\n+                    tcx.sess.span_fatal(pat.span, s);\n                 }\n \n-                // TODO: vec::iter2\n-\n-                let i = 0u;\n-                for subpat: @ast::pat in subpats {\n-                    check_pat(fcx, map, subpat, arg_types[i]);\n-                    i += 1u;\n+                vec::iter2(subpats, arg_types) {|subpat, arg_ty|\n+                    check_pat(fcx, map, subpat, arg_ty);\n                 }\n             } else if subpats_len > 0u {\n                 // TODO: note definition of enum variant\n-                fcx.ccx.tcx.sess.span_fatal\n-                    (pat.span,\n-                     #fmt[\"this pattern has %u field%s, \\\n-                          but the corresponding \\\n-                          variant has no fields\",\n-                                                 subpats_len,\n-                                                 if subpats_len == 1u {\n-                                                     \"\"\n-                                                 } else { \"s\" }]);\n+                tcx.sess.span_fatal\n+                    (pat.span, #fmt[\"this pattern has %u field%s, \\\n+                                     but the corresponding \\\n+                                     variant has no fields\",\n+                                    subpats_len,\n+                                    if subpats_len == 1u { \"\" }\n+                                    else { \"s\" }]);\n             }\n-            write::ty_fixup(fcx, pat.id, path_tpot);\n           }\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n-            fcx.ccx.tcx.sess.span_fatal\n+            tcx.sess.span_fatal\n                 (pat.span,\n                  #fmt[\"mismatched types: expected `%s` but found enum\",\n-                      ty_to_str(fcx.ccx.tcx, expected)]);\n+                      ty_to_str(tcx, expected)]);\n           }\n         }\n-        write::ty_fixup(fcx, pat.id, path_tpot);\n       }\n       ast::pat_rec(fields, etc) {\n         let ex_fields;\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal\n+            tcx.sess.span_fatal\n                 (pat.span,\n                 #fmt[\"mismatched types: expected `%s` but found record\",\n-                                ty_to_str(fcx.ccx.tcx, expected)]);\n+                                ty_to_str(tcx, expected)]);\n           }\n         }\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            fcx.ccx.tcx.sess.span_fatal\n+            tcx.sess.span_fatal\n                 (pat.span, #fmt[\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n@@ -1339,47 +1290,47 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n             alt vec::find(ex_fields, bind matches(f.ident, _)) {\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n               none {\n-                fcx.ccx.tcx.sess.span_fatal(pat.span,\n-                                            #fmt[\"mismatched types: did not \\\n-                                           expect a record with a field `%s`\",\n-                                                 f.ident]);\n+                tcx.sess.span_fatal(pat.span,\n+                                    #fmt[\"mismatched types: did not \\\n+                                          expect a record with a field `%s`\",\n+                                         f.ident]);\n               }\n             }\n         }\n-        write::ty_only_fixup(fcx, pat.id, expected);\n+        write_ty(tcx, pat.id, expected);\n       }\n       ast::pat_tup(elts) {\n         let ex_elts;\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal\n+            tcx.sess.span_fatal\n                 (pat.span,\n                  #fmt[\"mismatched types: expected `%s`, found tuple\",\n-                        ty_to_str(fcx.ccx.tcx, expected)]);\n+                        ty_to_str(tcx, expected)]);\n           }\n         }\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n-            fcx.ccx.tcx.sess.span_fatal\n+            tcx.sess.span_fatal\n                 (pat.span, #fmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n                       fields\", vec::len(ex_elts), e_count]);\n         }\n         let i = 0u;\n         for elt in elts { check_pat(fcx, map, elt, ex_elts[i]); i += 1u; }\n-        write::ty_only_fixup(fcx, pat.id, expected);\n+        write_ty(tcx, pat.id, expected);\n       }\n       ast::pat_box(inner) {\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_box(e_inner) {\n             check_pat(fcx, map, inner, e_inner.ty);\n-            write::ty_only_fixup(fcx, pat.id, expected);\n+            write_ty(tcx, pat.id, expected);\n           }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n+            tcx.sess.span_fatal(pat.span,\n                                         \"mismatched types: expected `\" +\n-                                            ty_to_str(fcx.ccx.tcx, expected) +\n+                                            ty_to_str(tcx, expected) +\n                                             \"` found box\");\n           }\n         }\n@@ -1388,12 +1339,12 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_uniq(e_inner) {\n             check_pat(fcx, map, inner, e_inner.ty);\n-            write::ty_only_fixup(fcx, pat.id, expected);\n+            write_ty(tcx, pat.id, expected);\n           }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(pat.span,\n+            tcx.sess.span_fatal(pat.span,\n                                         \"mismatched types: expected `\" +\n-                                            ty_to_str(fcx.ccx.tcx, expected) +\n+                                            ty_to_str(tcx, expected) +\n                                             \"` found uniq\");\n           }\n         }\n@@ -1581,15 +1532,14 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               unify: unifier,\n                               expected: ty::t) {\n     let tcx = fcx.ccx.tcx;\n-\n     let fty = ty::mk_fn(tcx, ty_of_fn_decl(tcx, m_check_tyvar(fcx),\n                                            proto, decl));\n \n     #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n            expr_to_str(expr),\n            ty_to_str(tcx, fty));\n \n-    write::ty_only_fixup(fcx, expr.id, fty);\n+    write_ty(tcx, expr.id, fty);\n \n     // Unify the type of the function with the expected type before we\n     // typecheck the body so that we have more information about the\n@@ -1672,7 +1622,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                         rhs: @ast::expr, id: ast::node_id) -> bool {\n         let t = next_ty_var(fcx);\n         let bot = check_expr_with(fcx, lhs, t) | check_expr_with(fcx, rhs, t);\n-        write::ty_only_fixup(fcx, id, ty::mk_nil(fcx.ccx.tcx));\n+        write_ty(fcx.ccx.tcx, id, ty::mk_nil(fcx.ccx.tcx));\n         ret bot;\n     }\n \n@@ -1708,7 +1658,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n         };\n-        write::ty_only_fixup(fcx, id, rt_1);\n+        write_ty(fcx.ccx.tcx, id, rt_1);\n         ret bot;\n     }\n \n@@ -1725,7 +1675,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         demand::simple(fcx, local.span,\n                        ty::node_id_to_type(fcx.ccx.tcx, local.node.id),\n                        element_ty);\n-        write::nil_ty(fcx.ccx.tcx, node_id);\n+        write_nil(fcx.ccx.tcx, node_id);\n         ret bot;\n     }\n \n@@ -1754,7 +1704,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 (ty::mk_nil(fcx.ccx.tcx), false)\n               }\n             };\n-        write::ty_only_fixup(fcx, id, if_t);\n+        write_ty(fcx.ccx.tcx, id, if_t);\n         ret if_bot;\n     }\n \n@@ -1773,8 +1723,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         alt lookup_method(fcx, isc, opname, self_t, op_ex.span) {\n           some({method_ty, n_tps: 0u, substs, origin}) {\n             let callee_id = ast_util::op_expr_callee_id(op_ex);\n-            write::ty_fixup(fcx, callee_id, {substs: some(substs),\n-                                             ty: method_ty});\n+            write_ty_substs(fcx.ccx.tcx, callee_id, method_ty, substs);\n             check_call_or_bind(fcx, op_ex.span, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some(ty::ty_fn_ret(fcx.ccx.tcx, method_ty))\n@@ -1828,7 +1777,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     alt expr.node {\n       ast::expr_lit(lit) {\n         let typ = check_lit(fcx.ccx, lit);\n-        write::ty_only_fixup(fcx, id, typ);\n+        write_ty(tcx, id, typ);\n       }\n       ast::expr_binary(binop, lhs, rhs) {\n         let lhs_t = next_ty_var(fcx);\n@@ -1838,7 +1787,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !ast_util::lazy_binop(binop) { bot |= rhs_bot; }\n \n         let result = check_binop(fcx, expr, lhs_t, binop, rhs);\n-        write::ty_only_fixup(fcx, id, result);\n+        write_ty(tcx, id, result);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n@@ -1899,15 +1848,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n           }\n         }\n-        write::ty_only_fixup(fcx, id, oper_t);\n+        write_ty(tcx, id, oper_t);\n       }\n       ast::expr_path(pth) {\n         let defn = lookup_def(fcx, pth.span, id);\n \n         let tpt = ty_param_bounds_and_ty_for_def(fcx, expr.span, defn);\n         if ty::def_has_ty_params(defn) {\n-            let path_tpot = instantiate_path(fcx, pth, tpt, expr.span);\n-            write::ty_fixup(fcx, id, path_tpot);\n+            instantiate_path(fcx, pth, tpt, expr.span, expr.id);\n         } else {\n             // The definition doesn't take type parameters. If the programmer\n             // supplied some, that's an error\n@@ -1916,7 +1864,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                     \"this kind of value does not \\\n                                      take type parameters\");\n             }\n-            write::ty_only_fixup(fcx, id, tpt.ty);\n+            write_ty(tcx, id, tpt.ty);\n         }\n       }\n       ast::expr_mac(_) { tcx.sess.bug(\"unexpanded macro\"); }\n@@ -1926,10 +1874,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           none {/* do nothing */ }\n           some(e) { check_expr_with(fcx, e, ty::mk_str(tcx)); }\n         }\n-        write::bot_ty(tcx, id);\n+        write_bot(tcx, id);\n       }\n-      ast::expr_break { write::bot_ty(tcx, id); bot = true; }\n-      ast::expr_cont { write::bot_ty(tcx, id); bot = true; }\n+      ast::expr_break { write_bot(tcx, id); bot = true; }\n+      ast::expr_cont { write_bot(tcx, id); bot = true; }\n       ast::expr_ret(expr_opt) {\n         bot = true;\n         alt expr_opt {\n@@ -1942,23 +1890,23 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           }\n           some(e) { check_expr_with(fcx, e, fcx.ret_ty); }\n         }\n-        write::bot_ty(tcx, id);\n+        write_bot(tcx, id);\n       }\n       ast::expr_be(e) {\n         // FIXME: prove instead of assert\n         assert (ast_util::is_call_expr(e));\n         check_expr_with(fcx, e, fcx.ret_ty);\n         bot = true;\n-        write::nil_ty(tcx, id);\n+        write_nil(tcx, id);\n       }\n       ast::expr_log(_, lv, e) {\n         bot = check_expr_with(fcx, lv, ty::mk_mach_uint(tcx, ast::ty_u32));\n         bot |= check_expr(fcx, e);\n-        write::nil_ty(tcx, id);\n+        write_nil(tcx, id);\n       }\n       ast::expr_check(_, e) {\n         bot = check_pred_expr(fcx, e);\n-        write::nil_ty(tcx, id);\n+        write_nil(tcx, id);\n       }\n       ast::expr_if_check(cond, thn, elsopt) {\n         bot =\n@@ -1970,14 +1918,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_assert(e) {\n         bot = check_expr_with(fcx, e, ty::mk_bool(tcx));\n-        write::nil_ty(tcx, id);\n+        write_nil(tcx, id);\n       }\n       ast::expr_copy(a) {\n         bot = check_expr_with_unifier(fcx, a, unify, expected);\n-        let tpot =\n-            ty::node_id_to_ty_param_substs_opt_and_ty(tcx, a.id);\n-        write::ty_fixup(fcx, id, tpot);\n-\n+        write_ty(tcx, id, ty::node_id_to_type(tcx, a.id));\n       }\n       ast::expr_move(lhs, rhs) {\n         require_impure(tcx.sess, fcx.purity, expr.span);\n@@ -2014,12 +1959,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_while(cond, body) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n         check_block_no_value(fcx, body);\n-        write::ty_only_fixup(fcx, id, ty::mk_nil(tcx));\n+        write_ty(tcx, id, ty::mk_nil(tcx));\n       }\n       ast::expr_do_while(body, cond) {\n         bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n               check_block_no_value(fcx, body);\n-        write::ty_only_fixup(fcx, id, block_ty(tcx, body));\n+        write_ty(tcx, id, block_ty(tcx, body));\n       }\n       ast::expr_alt(expr, arms) {\n         bot = check_expr(fcx, expr);\n@@ -2047,7 +1992,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n         bot |= !arm_non_bot;\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n-        write::ty_only_fixup(fcx, id, result_ty);\n+        write_ty(tcx, id, result_ty);\n       }\n       ast::expr_fn(proto, decl, body, captures) {\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n@@ -2069,7 +2014,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                ty_to_str(tcx, expected));\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n                                    unify, expected);\n-        write::ty_only_fixup(fcx, id, expected);\n+        write_ty(tcx, id, expected);\n       }\n       ast::expr_block(b) {\n         // If this is an unchecked block, turn off purity-checking\n@@ -2079,7 +2024,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               some(expr) { expr_ty(tcx, expr) }\n               none { ty::mk_nil(tcx) }\n             };\n-        write::ty_only_fixup(fcx, id, typ);\n+        write_ty(tcx, id, typ);\n       }\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n@@ -2126,7 +2071,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let ft = ty::mk_fn(tcx, {proto: lower_bound_proto(proto),\n                                  inputs: out_args, output: rt,\n                                  ret_style: cf, constraints: constrs});\n-        write::ty_only_fixup(fcx, id, ft);\n+        write_ty(tcx, id, ft);\n       }\n       ast::expr_call(f, args, _) {\n         bot = check_call_full(fcx, expr.span, f, args, expr.id);\n@@ -2162,13 +2107,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n           }\n         }\n-        write::ty_only_fixup(fcx, id, t_1);\n+        write_ty(tcx, id, t_1);\n       }\n       ast::expr_vec(args, mut) {\n         let t: ty::t = next_ty_var(fcx);\n         for e: @ast::expr in args { bot |= check_expr_with(fcx, e, t); }\n         let typ = ty::mk_vec(tcx, {ty: t, mut: mut});\n-        write::ty_only_fixup(fcx, id, typ);\n+        write_ty(tcx, id, typ);\n       }\n       ast::expr_tup(elts) {\n         let elt_ts = [];\n@@ -2179,7 +2124,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             elt_ts += [ety];\n         }\n         let typ = ty::mk_tup(tcx, elt_ts);\n-        write::ty_only_fixup(fcx, id, typ);\n+        write_ty(tcx, id, typ);\n       }\n       ast::expr_rec(fields, base) {\n         alt base { none {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n@@ -2198,7 +2143,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           none {\n             fn get_node(f: spanned<field>) -> field { f.node }\n             let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n-            write::ty_only_fixup(fcx, id, typ);\n+            write_ty(tcx, id, typ);\n           }\n           some(bexpr) {\n             bot |= check_expr(fcx, bexpr);\n@@ -2211,7 +2156,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                     \"record update has non-record base\");\n               }\n             }\n-            write::ty_only_fixup(fcx, id, bexpr_t);\n+            write_ty(tcx, id, bexpr_t);\n             for f: spanned<ty::field> in fields_t {\n                 let found = false;\n                 for bf: ty::field in base_fields {\n@@ -2244,7 +2189,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                       \"can't provide type parameters \\\n                                        to a field access\");\n                 }\n-                write::ty_only_fixup(fcx, id, fields[ix].mt.ty);\n+                write_ty(tcx, id, fields[ix].mt.ty);\n                 handled = true;\n               }\n               _ {}\n@@ -2275,13 +2220,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                             i += 1u;\n                         }\n                     }\n-                    write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n+                    write_ty_substs(fcx.ccx.tcx, id, fty, substs);\n                 } else if n_tys > 0u {\n                     tcx.sess.span_fatal(expr.span,\n                                         \"this method does not take type \\\n                                          parameters\");\n                 } else {\n-                    write::ty_only_fixup(fcx, id, fty);\n+                    write_ty(tcx, id, fty);\n                 }\n                 fcx.ccx.method_map.insert(id, origin);\n               }\n@@ -2292,7 +2237,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                field, ty_to_str(tcx, t_err)];\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n-                write::ty_only_fixup(fcx, id, ty::mk_nil(tcx));\n+                write_ty(tcx, id, ty::mk_nil(tcx));\n               }\n             }\n         }\n@@ -2313,19 +2258,19 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) {\n             require_integral(fcx, idx.span, idx_t);\n-            write::ty_only_fixup(fcx, id, mt.ty);\n+            write_ty(tcx, id, mt.ty);\n           }\n           ty::ty_str {\n             require_integral(fcx, idx.span, idx_t);\n             let typ = ty::mk_mach_uint(tcx, ast::ty_u8);\n-            write::ty_only_fixup(fcx, id, typ);\n+            write_ty(tcx, id, typ);\n           }\n           _ {\n             let resolved = structurally_resolved_type(fcx, expr.span,\n                                                       raw_base_t);\n             alt lookup_op_method(fcx, expr, resolved, \"[]\",\n                                  [some(idx)]) {\n-              some(ret_ty) { write::ty_only_fixup(fcx, id, ret_ty); }\n+              some(ret_ty) { write_ty(tcx, id, ret_ty); }\n               _ {\n                 tcx.sess.span_fatal(\n                     expr.span, \"cannot index a value of type `\" +\n@@ -2337,7 +2282,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       _ { tcx.sess.unimpl(\"expr type in typeck::check_expr\"); }\n     }\n-    if bot { write::ty_only_fixup(fcx, expr.id, ty::mk_bot(tcx)); }\n+    if bot { write_ty(tcx, expr.id, ty::mk_bot(tcx)); }\n \n     unify(fcx, expr.span, expected, expr_ty(tcx, expr));\n     ret bot;\n@@ -2375,7 +2320,7 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     alt fcx.locals.find(local.node.id) {\n       some(i) {\n         let t = ty::mk_var(fcx.ccx.tcx, i);\n-        write::ty_only_fixup(fcx, local.node.id, t);\n+        write_ty(fcx.ccx.tcx, local.node.id, t);\n         alt local.node.init {\n           some(init) {\n             bot = check_decl_initializer(fcx, local.node.id, init);\n@@ -2411,14 +2356,14 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n         bot = check_expr(fcx, expr);\n       }\n     }\n-    write::nil_ty(fcx.ccx.tcx, node_id);\n+    write_nil(fcx.ccx.tcx, node_id);\n     ret bot;\n }\n \n fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n     let bot = check_block(fcx, blk);\n     if !bot {\n-        let blkty = ty::node_id_to_monotype(fcx.ccx.tcx, blk.node.id);\n+        let blkty = ty::node_id_to_type(fcx.ccx.tcx, blk.node.id);\n         let nilty = ty::mk_nil(fcx.ccx.tcx);\n         demand::simple(fcx, blk.span, nilty, blkty);\n     }\n@@ -2448,18 +2393,18 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n         bot |= check_stmt(fcx, s);\n     }\n     alt blk.node.expr {\n-      none { write::nil_ty(fcx.ccx.tcx, blk.node.id); }\n+      none { write_nil(fcx.ccx.tcx, blk.node.id); }\n       some(e) {\n         if bot && !warned {\n             fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n         }\n         bot |= check_expr(fcx, e);\n         let ety = expr_ty(fcx.ccx.tcx, e);\n-        write::ty_only_fixup(fcx, blk.node.id, ety);\n+        write_ty(fcx.ccx.tcx, blk.node.id, ety);\n       }\n     }\n     if bot {\n-        write::ty_only_fixup(fcx, blk.node.id, ty::mk_bot(fcx.ccx.tcx));\n+        write_ty(fcx.ccx.tcx, blk.node.id, ty::mk_bot(fcx.ccx.tcx));\n     }\n     ret bot;\n }\n@@ -2697,7 +2642,7 @@ fn check_fn(ccx: @crate_ctxt,\n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n     for arg: ty::arg in args {\n-        write::ty_only_fixup(fcx, decl.inputs[i].id, arg.ty);\n+        write_ty(ccx.tcx, decl.inputs[i].id, arg.ty);\n         i += 1u;\n     }\n \n@@ -2748,7 +2693,7 @@ fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n }\n \n fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id) {\n-    let main_t = ty::node_id_to_monotype(tcx, main_id);\n+    let main_t = ty::node_id_to_type(tcx, main_id);\n     alt ty::struct(tcx, main_t) {\n       ty::ty_fn({proto: ast::proto_bare, inputs, output,\n                  ret_style: ast::return_val, constraints}) {\n@@ -2919,9 +2864,7 @@ mod dict {\n         let cx = fcx.ccx;\n         alt ex.node {\n           ast::expr_path(_) {\n-            let substs = ty::node_id_to_ty_param_substs_opt_and_ty(\n-                cx.tcx, ex.id);\n-            alt substs.substs {\n+            alt cx.tcx.node_type_substs.find(ex.id) {\n               some(ts) {\n                 let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n                 let item_ty = ty::lookup_item_type(cx.tcx, did);"}]}