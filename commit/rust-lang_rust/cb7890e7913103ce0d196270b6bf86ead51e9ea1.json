{"sha": "cb7890e7913103ce0d196270b6bf86ead51e9ea1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNzg5MGU3OTEzMTAzY2UwZDE5NjI3MGI2YmY4NmVhZDUxZTllYTE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-07-16T15:21:41Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-24T16:07:50Z"}, "message": "rustc_symbol_mangling: support structural constants and &str in v0.", "tree": {"sha": "305714e3654b58498e10ec982518bc29c6822e57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/305714e3654b58498e10ec982518bc29c6822e57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb7890e7913103ce0d196270b6bf86ead51e9ea1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7890e7913103ce0d196270b6bf86ead51e9ea1", "html_url": "https://github.com/rust-lang/rust/commit/cb7890e7913103ce0d196270b6bf86ead51e9ea1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb7890e7913103ce0d196270b6bf86ead51e9ea1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "948f19ea8ff76975a77a7cca1e4b42ca8758d3aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/948f19ea8ff76975a77a7cca1e4b42ca8758d3aa", "html_url": "https://github.com/rust-lang/rust/commit/948f19ea8ff76975a77a7cca1e4b42ca8758d3aa"}], "stats": {"total": 104, "additions": 104, "deletions": 0}, "files": [{"sha": "551309f4a8cc43156338bd398175dcbaa31a5ae2", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb7890e7913103ce0d196270b6bf86ead51e9ea1/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7890e7913103ce0d196270b6bf86ead51e9ea1/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=cb7890e7913103ce0d196270b6bf86ead51e9ea1", "patch": "@@ -91,6 +91,7 @@\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n+#![feature(iter_zip)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "80f29aa9c4f192bf1ae1f17ed8941e7192de9433", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cb7890e7913103ce0d196270b6bf86ead51e9ea1/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7890e7913103ce0d196270b6bf86ead51e9ea1/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=cb7890e7913103ce0d196270b6bf86ead51e9ea1", "patch": "@@ -1,8 +1,10 @@\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n@@ -11,6 +13,7 @@ use rustc_target::abi::Integer;\n use rustc_target::spec::abi::Abi;\n \n use std::fmt::Write;\n+use std::iter;\n use std::ops::Range;\n \n pub(super) fn mangle(\n@@ -578,6 +581,106 @@ impl Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n                 let _ = write!(self.out, \"{:x}_\", bits);\n             }\n+\n+            // HACK(eddyb) because `ty::Const` only supports sized values (for now),\n+            // we can't use `deref_const` + supporting `str`, we have to specially\n+            // handle `&str` and include both `&` (\"R\") and `str` (\"e\") prefixes.\n+            ty::Ref(_, ty, hir::Mutability::Not) if *ty == self.tcx.types.str_ => {\n+                self.push(\"R\");\n+                match ct.val {\n+                    ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n+                        // NOTE(eddyb) the following comment was kept from `ty::print::pretty`:\n+                        // The `inspect` here is okay since we checked the bounds, and there are no\n+                        // relocations (we have an active `str` reference here). We don't use this\n+                        // result to affect interpreter execution.\n+                        let slice =\n+                            data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n+                        let s = std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n+\n+                        self.push(\"e\");\n+                        // FIXME(eddyb) use a specialized hex-encoding loop.\n+                        for byte in s.bytes() {\n+                            let _ = write!(self.out, \"{:02x}\", byte);\n+                        }\n+                        self.push(\"_\");\n+                    }\n+\n+                    _ => {\n+                        bug!(\"symbol_names: unsupported `&str` constant: {:?}\", ct);\n+                    }\n+                }\n+            }\n+\n+            ty::Ref(_, _, mutbl) => {\n+                self.push(match mutbl {\n+                    hir::Mutability::Not => \"R\",\n+                    hir::Mutability::Mut => \"Q\",\n+                });\n+                self = self.tcx.deref_const(ty::ParamEnv::reveal_all().and(ct)).print(self)?;\n+            }\n+\n+            ty::Array(..) | ty::Tuple(..) | ty::Adt(..) => {\n+                let contents = self.tcx.destructure_const(ty::ParamEnv::reveal_all().and(ct));\n+                let fields = contents.fields.iter().copied();\n+\n+                let print_field_list = |mut this: Self| {\n+                    for field in fields.clone() {\n+                        this = field.print(this)?;\n+                    }\n+                    this.push(\"E\");\n+                    Ok(this)\n+                };\n+\n+                match *ct.ty.kind() {\n+                    ty::Array(..) => {\n+                        self.push(\"A\");\n+                        self = print_field_list(self)?;\n+                    }\n+                    ty::Tuple(..) => {\n+                        self.push(\"T\");\n+                        self = print_field_list(self)?;\n+                    }\n+                    ty::Adt(def, substs) => {\n+                        let variant_idx =\n+                            contents.variant.expect(\"destructed const of adt without variant idx\");\n+                        let variant_def = &def.variants[variant_idx];\n+\n+                        self.push(\"V\");\n+                        self = self.print_def_path(variant_def.def_id, substs)?;\n+\n+                        match variant_def.ctor_kind {\n+                            CtorKind::Const => {\n+                                self.push(\"U\");\n+                            }\n+                            CtorKind::Fn => {\n+                                self.push(\"T\");\n+                                self = print_field_list(self)?;\n+                            }\n+                            CtorKind::Fictive => {\n+                                self.push(\"S\");\n+                                for (field_def, field) in iter::zip(&variant_def.fields, fields) {\n+                                    // HACK(eddyb) this mimics `path_append`,\n+                                    // instead of simply using `field_def.ident`,\n+                                    // just to be able to handle disambiguators.\n+                                    let disambiguated_field =\n+                                        self.tcx.def_key(field_def.did).disambiguated_data;\n+                                    let field_name =\n+                                        disambiguated_field.data.get_opt_name().map(|s| s.as_str());\n+                                    self.push_disambiguator(\n+                                        disambiguated_field.disambiguator as u64,\n+                                    );\n+                                    self.push_ident(&field_name.as_ref().map_or(\"\", |s| &s[..]));\n+\n+                                    self = field.print(self)?;\n+                                }\n+                                self.push(\"E\");\n+                            }\n+                        }\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty, ct);\n             }"}]}