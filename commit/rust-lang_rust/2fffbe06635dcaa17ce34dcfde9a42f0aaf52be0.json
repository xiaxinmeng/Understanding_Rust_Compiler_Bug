{"sha": "2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZmZiZTA2NjM1ZGNhYTE3Y2UzNGRjZmRlOWE0MmYwYWFmNTJiZTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-21T00:07:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-21T00:07:33Z"}, "message": "auto merge of #17555 : steveklabnik/rust/module_guide, r=alexcrichton\n\nThis is an almost-done draft of a guide on crates and modules. This is a hard guide to get right, I had to remove a chunk of the Guide because it was confusing.\r\n\r\nI've also pushed up https://github.com/steveklabnik/phrases which has matching code. Whenever we finish this guide, I think it'd be good to have a sample crate like this in the rust-lang org for people to compare against. The hardest part of a guide like this is that it depends on multiple files being correct, and being able to point to a repository would be very helpful.\r\n\r\nThings yet to do:\r\n\r\n1. external crates via cargo\r\n2. documentation\r\n\r\nI'm super open to still revising this if it's still confusing. There's been a lot of Reddit discussion about the module system, and I tried to incorporate those posts and the comments into this.", "tree": {"sha": "ea3916f066bfda5709f36665a75f591f0ca9dce3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea3916f066bfda5709f36665a75f591f0ca9dce3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0", "html_url": "https://github.com/rust-lang/rust/commit/2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ef8392b3fd5f81165f1b4637a94c7c226420070", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ef8392b3fd5f81165f1b4637a94c7c226420070", "html_url": "https://github.com/rust-lang/rust/commit/6ef8392b3fd5f81165f1b4637a94c7c226420070"}, {"sha": "8851ec647a40cabce60db23ae86318f3260a8206", "url": "https://api.github.com/repos/rust-lang/rust/commits/8851ec647a40cabce60db23ae86318f3260a8206", "html_url": "https://github.com/rust-lang/rust/commit/8851ec647a40cabce60db23ae86318f3260a8206"}], "stats": {"total": 569, "additions": 569, "deletions": 0}, "files": [{"sha": "8705bdd278ec7b384eb5a54bd0290e4d69d71ea2", "filename": "src/doc/guide-crates.md", "status": "added", "additions": 569, "deletions": 0, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0/src%2Fdoc%2Fguide-crates.md", "raw_url": "https://github.com/rust-lang/rust/raw/2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0/src%2Fdoc%2Fguide-crates.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-crates.md?ref=2fffbe06635dcaa17ce34dcfde9a42f0aaf52be0", "patch": "@@ -0,0 +1,569 @@\n+% The Rust Crates and Modules Guide\n+\n+When a project starts getting large, it's considered a good software\n+engineering practice to split it up into a bunch of smaller pieces, and then\n+fit them together. It's also important to have a well-defined interface, so\n+that some of your functionality is private, and some is public. To facilitate\n+these kinds of things, Rust has a module system.\n+\n+# Basic terminology: Crates and Modules\n+\n+Rust has two distinct terms that relate to the module system: \"crate\" and\n+\"module.\" A crate is synonymous with a 'library' or 'package' in other\n+languages. Hence \"Cargo\" as the name of Rust's package management tool: you\n+ship your crates to others with Cargo. Crates can produce an executable or a\n+shared library, depending on the project.\n+\n+Each crate has an implicit \"root module\" that contains the code for that crate.\n+You can then define a tree of sub-modules under that root module. Modules allow\n+you to partition your code within the crate itself.\n+\n+As an example, let's make a \"phrases\" crate, which will give us various phrases\n+in different languages. To keep things simple, we'll stick to \"greetings\" and\n+\"farewells\" as two kinds of phrases, and use English and Japanese (\u65e5\u672c\u8a9e\uff09 as\n+two languages for those phrases to be in. We'll use this module layout:\n+\n+```text\n+                                +-----------+\n+                            +---| greetings |\n+                            |   +-----------+\n+              +---------+   |\n+              | english |---+\n+              +---------+   |   +-----------+\n+              |             +---| farewells |\n++---------+   |                 +-----------+\n+| phrases |---+ \n++---------+   |                  +-----------+\n+              |              +---| greetings |\n+              +----------+   |   +-----------+\n+              | japanese |---+\n+              +----------+   |\n+                             |   +-----------+\n+                             +---| farewells |\n+                                 +-----------+\n+```\n+\n+In this example, `phrases` is the name of our crate. All of the rest are\n+modules.  You can see that they form a tree, branching out from the crate\n+\"root\", which is the root of the tree: `phrases` itself.\n+\n+Now that we have a plan, let's define these modules in code. To start,\n+generate a new crate with Cargo:\n+\n+```bash\n+$ cargo new phrases\n+$ cd phrases\n+```\n+\n+If you remember, this generates a simple project for us:\n+\n+```bash\n+$ tree .\n+.\n+\u251c\u2500\u2500 Cargo.toml\n+\u2514\u2500\u2500 src\n+    \u2514\u2500\u2500 lib.rs\n+\n+1 directory, 2 files\n+```\n+\n+`src/lib.rs` is our crate root, corresponding to the `phrases` in our diagram\n+above.\n+\n+# Defining Modules\n+\n+To define each of our modules, we use the `mod` keyword. Let's make our\n+`src/lib.rs` look like this:\n+\n+```\n+// in src/lib.rs\n+\n+mod english {\n+    mod greetings {\n+\n+    }\n+\n+    mod farewells {\n+\n+    }\n+}\n+\n+mod japanese {\n+    mod greetings {\n+\n+    }\n+\n+    mod farewells {\n+\n+    }\n+}\n+```\n+\n+After the `mod` keyword, you give the name of the module. Module names follow\n+the conventions for other Rust identifiers: `lower_snake_case`. The contents of\n+each module are within curly braces (`{}`).\n+\n+Within a given `mod`, you can declare sub-`mod`s. We can refer to sub-modules\n+with double-colon (`::`) notation: our four nested modules are\n+`english::greetings`, `english::farewells`, `japanese::greetings`, and\n+`japanese::farewells`. Because these sub-modules are namespaced under their\n+parent module, the names don't conflict: `english::greetings` and\n+`japanese::greetings` are distinct, even though their names are both\n+`greetings`.\n+\n+Because this crate does not have a `main()` function, and is called `lib.rs`,\n+Cargo will build this crate as a library:\n+\n+```bash\n+$ cargo build\n+   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n+$ ls target\n+deps  libphrases-a7448e02a0468eaa.rlib  native\n+```\n+\n+`libphrase-hash.rlib` is the compiled crate. Before we see how to use this\n+crate from another crate, let's break it up into multiple files.\n+\n+# Multiple file crates\n+\n+If each crate were just one file, these files would get very large. It's often\n+easier to split up crates into multiple files, and Rust supports this in two\n+ways.\n+\n+Instead of declaring a module like this:\n+\n+```{rust,ignore}\n+mod english {\n+    // contents of our module go here\n+}\n+```\n+\n+We can instead declare our module like this:\n+\n+```{rust,ignore}\n+mod english;\n+```\n+\n+If we do that, Rust will expect to find either a `english.rs` file, or a\n+`english/mod.rs` file with the contents of our module:\n+\n+```{rust,ignore}\n+// contents of our module go here\n+```\n+\n+Note that in these files, you don't need to re-declare the module: that's\n+already been done with the initial `mod` declaration.\n+\n+Using these two techniques, we can break up our crate into two directories and\n+seven files:\n+\n+```bash\n+$ tree .\n+.\n+\u251c\u2500\u2500 Cargo.lock\n+\u251c\u2500\u2500 Cargo.toml\n+\u251c\u2500\u2500 src\n+\u2502\u00a0\u00a0 \u251c\u2500\u2500 english\n+\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 farewells.rs\n+\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings.rs\n+\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 mod.rs\n+\u2502\u00a0\u00a0 \u251c\u2500\u2500 japanese\n+\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 farewells.rs\n+\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings.rs\n+\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 mod.rs\n+\u2502\u00a0\u00a0 \u2514\u2500\u2500 lib.rs\n+\u2514\u2500\u2500 target\n+    \u251c\u2500\u2500 deps\n+    \u251c\u2500\u2500 libphrases-a7448e02a0468eaa.rlib\n+    \u2514\u2500\u2500 native\n+```\n+\n+`src/lib.rs` is our crate root, and looks like this:\n+\n+```{rust,ignore}\n+// in src/lib.rs\n+\n+mod english;\n+\n+mod japanese;\n+```\n+\n+These two declarations tell Rust to look for either `src/english.rs` and\n+`src/japanese.rs`, or `src/english/mod.rs` and `src/japanese/mod.rs`, depending\n+on our preference. In this case, because our modules have sub-modules, we've\n+chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n+like this:\n+\n+```{rust,ignore}\n+// both src/english/mod.rs and src/japanese/mod.rs\n+\n+mod greetings;\n+\n+mod farewells;\n+```\n+\n+Again, these declarations tell Rust to look for either\n+`src/english/greetings.rs` and `src/japanese/greetings.rs` or\n+`src/english/farewells/mod.rs` and `src/japanese/farewells/mod.rs`. Because\n+these sub-modules don't have their own sub-modules, we've chosen to make them\n+`src/english/greetings.rs` and `src/japanese/farewells.rs`. Whew!\n+\n+Right now, the contents of `src/english/greetings.rs` and\n+`src/japanese/farewells.rs` are both empty at the moment. Let's add some\n+functions.\n+\n+Put this in `src/english/greetings.rs`:\n+\n+```rust\n+// in src/english/greetings.rs\n+\n+fn hello() -> String {\n+    \"Hello!\".to_string()\n+}  \n+```\n+\n+Put this in `src/english/farewells.rs`:\n+\n+```rust\n+// in src/english/farewells.rs\n+\n+fn goodbye() -> String {\n+    \"Goodbye.\".to_string()\n+} \n+```\n+\n+Put this in `src/japanese/greetings.rs`:\n+\n+```rust\n+// in src/japanese/greetings.rs\n+\n+fn hello() -> String {\n+    \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n+}  \n+```\n+\n+Of course, you can copy and paste this from this web page, or just type\n+something else. It's not important that you actually put \"konnichiwa\" to learn\n+about the module system.\n+\n+Put this in `src/japanese/farewells.rs`:\n+\n+```rust\n+// in src/japanese/farewells.rs\n+\n+fn goodbye() -> String {\n+    \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n+} \n+```\n+\n+(This is \"Sayoonara\", if you're curious.)\n+\n+Now that we have our some functionality in our crate, let's try to use it from\n+another crate.\n+\n+# Importing External Crates\n+\n+We have a library crate. Let's make an executable crate that imports and uses\n+our library.\n+\n+Make a `src/main.rs` and put this in it: (it won't quite compile yet)\n+\n+```rust,ignore\n+// in src/main.rs\n+\n+extern crate phrases;\n+\n+fn main() {\n+    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n+    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n+\n+    println!(\"Hello in Japanese: {}\", phrases::japanese::greetings::hello());\n+    println!(\"Goodbye in Japanese: {}\", phrases::japanese::farewells::goodbye());\n+}\n+```\n+\n+The `extern crate` declaration tells Rust that we need to compile and link to\n+the `phrases` crate. We can then use `phrases`' modules in this one. As we\n+mentioned earlier, you can use double colons to refer to sub-modules and the\n+functions inside of them.\n+\n+Also, Cargo assumes that `src/main.rs` is the crate root of a binary crate,\n+rather than a library crate. Once we compile `src/main.rs`, we'll get an\n+executable that we can run. Our package now has two crates: `src/lib.rs` and\n+`src/main.rs`. This pattern is quite common for executable crates: most\n+functionality is in a library crate, and the executable crate uses that\n+library. This way, other programs can also use the library crate, and it's also\n+a nice separation of concerns.\n+\n+This doesn't quite work yet, though. We get four errors that look similar to\n+this:\n+\n+```bash\n+$ cargo build\n+   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n+/home/you/projects/phrases/src/main.rs:4:38: 4:72 error: function `hello` is private\n+/home/you/projects/phrases/src/main.rs:4     println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n+                                                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+note: in expansion of format_args!\n+<std macros>:2:23: 2:77 note: expansion site\n+<std macros>:1:1: 3:2 note: in expansion of println!\n+/home/you/projects/phrases/src/main.rs:4:5: 4:76 note: expansion site\n+\n+```\n+\n+By default, everything is private in Rust. Let's talk about this in some more\n+depth.\n+\n+# Exporting a Public Interface\n+\n+Rust allows you to precisely control which aspects of your interface are\n+public, and so private is the default. To make things public, you use the `pub`\n+keyword. Let's focus on the `english` module first, so let's reduce our `src/main.rs`\n+to just this:\n+\n+```{rust,ignore}\n+// in src/main.rs\n+\n+extern crate phrases;\n+\n+fn main() {\n+    println!(\"Hello in English: {}\", phrases::english::greetings::hello());\n+    println!(\"Goodbye in English: {}\", phrases::english::farewells::goodbye());\n+}\n+```\n+\n+In our `src/lib.rs`, let's add `pub` to the `english` module declaration:\n+\n+```{rust,ignore}\n+// in src/lib.rs\n+\n+pub mod english;\n+\n+mod japanese;\n+```\n+\n+And in our `src/english/mod.rs`, let's make both `pub`:\n+\n+```{rust,ignore}\n+// in src/english/mod.rs\n+\n+pub mod greetings;\n+\n+pub mod farewells;\n+```\n+\n+In our `src/english/greetings.rs`, let's add `pub` to our `fn` declaration:\n+\n+```{rust,ignore}\n+// in src/english/greetings.rs\n+\n+pub fn hello() -> String {\n+    \"Hello!\".to_string()\n+}\n+```\n+\n+And also in `src/english/farewells.rs`:\n+\n+```{rust,ignore}\n+// in src/english/farewells.rs\n+\n+pub fn goodbye() -> String {\n+    \"Goodbye.\".to_string()\n+}\n+```\n+\n+Now, our crate compiles, albeit with warnings about not using the `japanese`\n+functions:\n+\n+```bash\n+$ cargo run\n+   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n+/home/you/projects/phrases/src/japanese/greetings.rs:1:1: 3:2 warning: code is never used: `hello`, #[warn(dead_code)] on by default\n+/home/you/projects/phrases/src/japanese/greetings.rs:1 fn hello() -> String {\n+/home/you/projects/phrases/src/japanese/greetings.rs:2     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n+/home/you/projects/phrases/src/japanese/greetings.rs:3 } \n+/home/you/projects/phrases/src/japanese/farewells.rs:1:1: 3:2 warning: code is never used: `goodbye`, #[warn(dead_code)] on by default\n+/home/you/projects/phrases/src/japanese/farewells.rs:1 fn goodbye() -> String {\n+/home/you/projects/phrases/src/japanese/farewells.rs:2     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n+/home/you/projects/phrases/src/japanese/farewells.rs:3 } \n+     Running `target/phrases`\n+Hello in English: Hello!\n+Goodbye in English: Goodbye.\n+```\n+\n+Now that our functions are public, we can use them. Great! However, typing out\n+`phrases::english::greetings::hello()` is very long and repetitive. Rust has\n+another keyword for importing names into the current scope, so that you can\n+refer to them with shorter names. Let's talk about `use`.\n+\n+# Importing Modules with `use`\n+\n+Rust has a `use` keyword, which allows us to import names into our local scope.\n+Let's change our `src/main.rs` to look like this:\n+\n+```{rust,ignore}\n+// in src/main.rs\n+\n+extern crate phrases;\n+\n+use phrases::english::greetings;\n+use phrases::english::farewells;\n+\n+fn main() {\n+    println!(\"Hello in English: {}\", greetings::hello());\n+    println!(\"Goodbye in English: {}\", farewells::goodbye());\n+}\n+```\n+\n+The two `use` lines import each module into the local scope, so we can refer to\n+the functions by a much shorter name. By convention, when importing functions, it's\n+considered best practice to import the module, rather than the function directly. In\n+other words, you _can_ do this:\n+\n+```{rust,ignore}\n+extern crate phrases;\n+\n+use phrases::english::greetings::hello;\n+use phrases::english::farewells::goodbye;\n+\n+fn main() {\n+    println!(\"Hello in English: {}\", hello());\n+    println!(\"Goodbye in English: {}\", goodbye());\n+}\n+```\n+\n+But it is not idiomatic. This is significantly more likely to introducing a\n+naming conflict. In our short program, it's not a big deal, but as it grows, it\n+becomes a problem. If we have conflicting names, Rust will give a compilation\n+error. For example, if we made the `japanese` functions public, and tried to do\n+this:\n+\n+```{rust,ignore}\n+extern crate phrases;\n+\n+use phrases::english::greetings::hello;\n+use phrases::japanese::greetings::hello;\n+\n+fn main() {\n+    println!(\"Hello in English: {}\", hello());\n+    println!(\"Hello in Japanese: {}\", hello());\n+}\n+```\n+\n+Rust will give us a compile-time error:\n+\n+```{rust,ignore}\n+   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n+/home/you/projects/phrases/src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module\n+/home/you/projects/phrases/src/main.rs:4 use phrases::japanese::greetings::hello;\n+                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+error: aborting due to previous error\n+Could not compile `phrases`.\n+```\n+\n+If we're importing multiple names from the same module, we don't have to type it out\n+twice. Rust has a shortcut syntax for writing this:\n+\n+```{rust,ignore}\n+use phrases::english::greetings;\n+use phrases::english::farewells;\n+```\n+\n+You use curly braces:\n+\n+```{rust,ignore}\n+use phrases::english::{greetings, farewells};\n+```\n+\n+These two declarations are equivalent, but the second is a lot less typing.\n+\n+## Re-exporting with `pub use`\n+\n+You don't just use `use` to shorten identifiers. You can also use it inside of your crate\n+to re-export a function inside another module. This allows you to present an external\n+interface that may not directly map to your internal code organization.\n+\n+Let's look at an example. Modify your `src/main.rs` to read like this:\n+\n+```{rust,ignore}\n+// in src/main.rs\n+\n+extern crate phrases;\n+\n+use phrases::english::{greetings,farewells};\n+use phrases::japanese;\n+\n+fn main() {\n+    println!(\"Hello in English: {}\", greetings::hello());\n+    println!(\"Goodbye in English: {}\", farewells::goodbye());\n+\n+    println!(\"Hello in Japanese: {}\", japanese::hello());\n+    println!(\"Goodbye in Japanese: {}\", japanese::goodbye());\n+}\n+```\n+\n+Then, modify your `src/lib.rs` to make the `japanese` mod public:\n+\n+```{rust,ignore}\n+// in src/lib.rs\n+\n+pub mod english;\n+\n+pub mod japanese;\n+```\n+\n+Next, make the two functions public, first in `src/japanese/greetings.rs`:\n+\n+```{rust,ignore}\n+// in src/japanese/greetings.rs\n+\n+pub fn hello() -> String {\n+    \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n+}\n+```\n+\n+And then in `src/japanese/farewells.rs`:\n+\n+```{rust,ignore}\n+// in src/japanese/farewells.rs\n+\n+pub fn goodbye() -> String {\n+    \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n+}\n+```\n+\n+Finally, modify your `src/japanese/mod.rs` to read like this:\n+\n+```{rust,ignore}\n+// in src/japanese/mod.rs\n+\n+pub use self::greetings::hello;\n+pub use self::farewells::goodbye;\n+\n+mod greetings;\n+\n+mod farewells;\n+```\n+\n+The `pub use` declaration brings the function into scope at this part of our\n+module hierarchy. Because we've `pub use`d this inside of our `japanese`\n+module, we now have a `phrases::japanese::hello()` function and a\n+`phrases::japanese::goodbye()` function, even though the code for them lives in\n+`phrases::japanese::greetings::hello()` and\n+`phrases::japanese::farewells::goodbye()`. Our internal organization doesn't\n+define our external interface.\n+\n+Also, note that we `pub use`d before we declared our `mod`s. Rust requires that\n+`use` declarations go first.\n+\n+This will build and run:\n+\n+```bash\n+$ cargo build\n+   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)\n+     Running `target/phrases`\n+Hello in English: Hello!\n+Goodbye in English: Goodbye.\n+Hello in Japanese: \u3053\u3093\u306b\u3061\u306f\n+Goodbye in Japanese: \u3055\u3088\u3046\u306a\u3089\n+```"}]}