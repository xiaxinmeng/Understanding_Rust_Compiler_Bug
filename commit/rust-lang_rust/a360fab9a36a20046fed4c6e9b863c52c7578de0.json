{"sha": "a360fab9a36a20046fed4c6e9b863c52c7578de0", "node_id": "C_kwDOAAsO6NoAKGEzNjBmYWI5YTM2YTIwMDQ2ZmVkNGM2ZTliODYzYzUyYzc1NzhkZTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-06T10:54:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-06T10:54:27Z"}, "message": "Auto merge of #14261 - Veykril:ty-perf, r=Veykril\n\ninternal: Re-use the resolver in `InferenceContext` instead of rebuilding it whenever needed\n\nThis reduced inference time on my local build by roughly ~1 sec (out of like 60)", "tree": {"sha": "977cca6272c56b5e4b567a7f7358025de61f13f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/977cca6272c56b5e4b567a7f7358025de61f13f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a360fab9a36a20046fed4c6e9b863c52c7578de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a360fab9a36a20046fed4c6e9b863c52c7578de0", "html_url": "https://github.com/rust-lang/rust/commit/a360fab9a36a20046fed4c6e9b863c52c7578de0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a360fab9a36a20046fed4c6e9b863c52c7578de0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900efbefdda057d0a1f81302436c44646bb07f7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/900efbefdda057d0a1f81302436c44646bb07f7e", "html_url": "https://github.com/rust-lang/rust/commit/900efbefdda057d0a1f81302436c44646bb07f7e"}, {"sha": "d8b1ec6a25d800691da50fa7834f8db2a2f124b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b1ec6a25d800691da50fa7834f8db2a2f124b6", "html_url": "https://github.com/rust-lang/rust/commit/d8b1ec6a25d800691da50fa7834f8db2a2f124b6"}], "stats": {"total": 391, "additions": 248, "deletions": 143}, "files": [{"sha": "cab657b807eb133b543fbdbc40c4ea67754fda5f", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=a360fab9a36a20046fed4c6e9b863c52c7578de0", "patch": "@@ -66,6 +66,7 @@ impl ExprScopes {\n         self.scopes[scope].label.clone()\n     }\n \n+    /// Returns the scopes in ascending order.\n     pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n     }"}, {"sha": "eea837ddd23a40994bd4c42efceefe15d30947df", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 162, "deletions": 51, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=a360fab9a36a20046fed4c6e9b863c52c7578de0", "patch": "@@ -1,5 +1,5 @@\n //! Name resolution fa\u00e7ade.\n-use std::{hash::BuildHasherDefault, sync::Arc};\n+use std::{fmt, hash::BuildHasherDefault, sync::Arc};\n \n use base_db::CrateId;\n use hir_expand::name::{name, Name};\n@@ -36,19 +36,34 @@ pub struct Resolver {\n     module_scope: ModuleItemMap,\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n struct ModuleItemMap {\n     def_map: Arc<DefMap>,\n     module_id: LocalModuleId,\n }\n \n-#[derive(Debug, Clone)]\n+impl fmt::Debug for ModuleItemMap {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ModuleItemMap\").field(\"module_id\", &self.module_id).finish()\n+    }\n+}\n+\n+#[derive(Clone)]\n struct ExprScope {\n     owner: DefWithBodyId,\n     expr_scopes: Arc<ExprScopes>,\n     scope_id: ScopeId,\n }\n \n+impl fmt::Debug for ExprScope {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ExprScope\")\n+            .field(\"owner\", &self.owner)\n+            .field(\"scope_id\", &self.scope_id)\n+            .finish()\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n enum Scope {\n     /// All the items and imported names of a module\n@@ -240,55 +255,67 @@ impl Resolver {\n             return self.module_scope.resolve_path_in_value_ns(db, path);\n         }\n \n-        for scope in self.scopes() {\n-            match scope {\n-                Scope::ExprScope(_) if n_segments > 1 => continue,\n-                Scope::ExprScope(scope) => {\n-                    let entry = scope\n-                        .expr_scopes\n-                        .entries(scope.scope_id)\n-                        .iter()\n-                        .find(|entry| entry.name() == first_name);\n-\n-                    if let Some(e) = entry {\n-                        return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(e.pat())));\n+        if n_segments <= 1 {\n+            for scope in self.scopes() {\n+                match scope {\n+                    Scope::ExprScope(scope) => {\n+                        let entry = scope\n+                            .expr_scopes\n+                            .entries(scope.scope_id)\n+                            .iter()\n+                            .find(|entry| entry.name() == first_name);\n+\n+                        if let Some(e) = entry {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(\n+                                e.pat(),\n+                            )));\n+                        }\n                     }\n-                }\n-                Scope::GenericParams { params, def } if n_segments > 1 => {\n-                    if let Some(id) = params.find_type_by_name(first_name, *def) {\n-                        let ty = TypeNs::GenericParam(id);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+                    Scope::GenericParams { params, def } => {\n+                        if let Some(id) = params.find_const_by_name(first_name, *def) {\n+                            let val = ValueNs::GenericParam(id);\n+                            return Some(ResolveValueResult::ValueNs(val));\n+                        }\n                     }\n-                }\n-                Scope::GenericParams { .. } if n_segments != 1 => continue,\n-                Scope::GenericParams { params, def } => {\n-                    if let Some(id) = params.find_const_by_name(first_name, *def) {\n-                        let val = ValueNs::GenericParam(id);\n-                        return Some(ResolveValueResult::ValueNs(val));\n+                    &Scope::ImplDefScope(impl_) => {\n+                        if first_name == &name![Self] {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_)));\n+                        }\n                     }\n-                }\n-\n-                &Scope::ImplDefScope(impl_) => {\n-                    if first_name == &name![Self] {\n-                        return Some(if n_segments > 1 {\n-                            ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1)\n-                        } else {\n-                            ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_))\n-                        });\n+                    // bare `Self` doesn't work in the value namespace in a struct/enum definition\n+                    Scope::AdtScope(_) => continue,\n+                    Scope::BlockScope(m) => {\n+                        if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                            return Some(def);\n+                        }\n                     }\n                 }\n-                // bare `Self` doesn't work in the value namespace in a struct/enum definition\n-                Scope::AdtScope(_) if n_segments == 1 => continue,\n-                Scope::AdtScope(adt) => {\n-                    if first_name == &name![Self] {\n-                        let ty = TypeNs::AdtSelfType(*adt);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+            }\n+        } else {\n+            for scope in self.scopes() {\n+                match scope {\n+                    Scope::ExprScope(_) => continue,\n+                    Scope::GenericParams { params, def } => {\n+                        if let Some(id) = params.find_type_by_name(first_name, *def) {\n+                            let ty = TypeNs::GenericParam(id);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        }\n                     }\n-                }\n-\n-                Scope::BlockScope(m) => {\n-                    if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n-                        return Some(def);\n+                    &Scope::ImplDefScope(impl_) => {\n+                        if first_name == &name![Self] {\n+                            return Some(ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1));\n+                        }\n+                    }\n+                    Scope::AdtScope(adt) => {\n+                        if first_name == &name![Self] {\n+                            let ty = TypeNs::AdtSelfType(*adt);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        }\n+                    }\n+                    Scope::BlockScope(m) => {\n+                        if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                            return Some(def);\n+                        }\n                     }\n                 }\n             }\n@@ -301,8 +328,8 @@ impl Resolver {\n         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back\n         // to resolving to the primitive type, to allow this to still work in the presence of\n         // `use core::u16;`.\n-        if path.kind == PathKind::Plain && path.segments().len() > 1 {\n-            if let Some(builtin) = BuiltinType::by_name(&path.segments()[0]) {\n+        if path.kind == PathKind::Plain && n_segments > 1 {\n+            if let Some(builtin) = BuiltinType::by_name(first_name) {\n                 return Some(ResolveValueResult::Partial(TypeNs::BuiltinType(builtin), 1));\n             }\n         }\n@@ -434,6 +461,15 @@ impl Resolver {\n         traits\n     }\n \n+    pub fn traits_in_scope_from_block_scopes(&self) -> impl Iterator<Item = TraitId> + '_ {\n+        self.scopes()\n+            .filter_map(|scope| match scope {\n+                Scope::BlockScope(m) => Some(m.def_map[m.module_id].scope.traits()),\n+                _ => None,\n+            })\n+            .flatten()\n+    }\n+\n     pub fn module(&self) -> ModuleId {\n         let (def_map, local_id) = self.item_scope();\n         def_map.module_id(local_id)\n@@ -478,8 +514,72 @@ impl Resolver {\n             _ => None,\n         })\n     }\n+    /// `expr_id` is required to be an expression id that comes after the top level expression scope in the given resolver\n+    #[must_use]\n+    pub fn update_to_inner_scope(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        owner: DefWithBodyId,\n+        expr_id: ExprId,\n+    ) -> UpdateGuard {\n+        #[inline(always)]\n+        fn append_expr_scope(\n+            db: &dyn DefDatabase,\n+            resolver: &mut Resolver,\n+            owner: DefWithBodyId,\n+            expr_scopes: &Arc<ExprScopes>,\n+            scope_id: ScopeId,\n+        ) {\n+            resolver.scopes.push(Scope::ExprScope(ExprScope {\n+                owner,\n+                expr_scopes: expr_scopes.clone(),\n+                scope_id,\n+            }));\n+            if let Some(block) = expr_scopes.block(scope_id) {\n+                if let Some(def_map) = db.block_def_map(block) {\n+                    let root = def_map.root();\n+                    resolver\n+                        .scopes\n+                        .push(Scope::BlockScope(ModuleItemMap { def_map, module_id: root }));\n+                    // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n+                    // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n+                    // innermost module scope instead?\n+                }\n+            }\n+        }\n+\n+        let start = self.scopes.len();\n+        let innermost_scope = self.scopes().next();\n+        match innermost_scope {\n+            Some(&Scope::ExprScope(ExprScope { scope_id, ref expr_scopes, owner })) => {\n+                let expr_scopes = expr_scopes.clone();\n+                let scope_chain = expr_scopes\n+                    .scope_chain(expr_scopes.scope_for(expr_id))\n+                    .take_while(|&it| it != scope_id);\n+                for scope_id in scope_chain {\n+                    append_expr_scope(db, self, owner, &expr_scopes, scope_id);\n+                }\n+            }\n+            _ => {\n+                let expr_scopes = db.expr_scopes(owner);\n+                let scope_chain = expr_scopes.scope_chain(expr_scopes.scope_for(expr_id));\n+\n+                for scope_id in scope_chain {\n+                    append_expr_scope(db, self, owner, &expr_scopes, scope_id);\n+                }\n+            }\n+        }\n+        self.scopes[start..].reverse();\n+        UpdateGuard(start)\n+    }\n+\n+    pub fn reset_to_guard(&mut self, UpdateGuard(start): UpdateGuard) {\n+        self.scopes.truncate(start);\n+    }\n }\n \n+pub struct UpdateGuard(usize);\n+\n impl Resolver {\n     fn scopes(&self) -> impl Iterator<Item = &Scope> {\n         self.scopes.iter().rev()\n@@ -576,19 +676,30 @@ impl Scope {\n     }\n }\n \n-// needs arbitrary_self_types to be a method... or maybe move to the def?\n pub fn resolver_for_expr(db: &dyn DefDatabase, owner: DefWithBodyId, expr_id: ExprId) -> Resolver {\n+    let r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n-    resolver_for_scope(db, owner, scopes.scope_for(expr_id))\n+    let scope_id = scopes.scope_for(expr_id);\n+    resolver_for_scope_(db, scopes, scope_id, r, owner)\n }\n \n pub fn resolver_for_scope(\n     db: &dyn DefDatabase,\n     owner: DefWithBodyId,\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n-    let mut r = owner.resolver(db);\n+    let r = owner.resolver(db);\n     let scopes = db.expr_scopes(owner);\n+    resolver_for_scope_(db, scopes, scope_id, r, owner)\n+}\n+\n+fn resolver_for_scope_(\n+    db: &dyn DefDatabase,\n+    scopes: Arc<ExprScopes>,\n+    scope_id: Option<ScopeId>,\n+    mut r: Resolver,\n+    owner: DefWithBodyId,\n+) -> Resolver {\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     r.scopes.reserve(scope_chain.len());\n "}, {"sha": "869b39ab37d26aba2d9a770f9f51605163c93447", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=a360fab9a36a20046fed4c6e9b863c52c7578de0", "patch": "@@ -33,7 +33,7 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n use la_arena::ArenaMap;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::always;\n \n use crate::{\n@@ -423,6 +423,8 @@ pub(crate) struct InferenceContext<'a> {\n     pub(crate) resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n+    /// The traits in scope, disregarding block modules. This is used for caching purposes.\n+    traits_in_scope: FxHashSet<TraitId>,\n     pub(crate) result: InferenceResult,\n     /// The return type of the function being inferred, the closure or async block if we're\n     /// currently within one.\n@@ -505,6 +507,7 @@ impl<'a> InferenceContext<'a> {\n             db,\n             owner,\n             body,\n+            traits_in_scope: resolver.traits_in_scope(db.upcast()),\n             resolver,\n             diverges: Diverges::Maybe,\n             breakables: Vec::new(),\n@@ -706,7 +709,6 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        // FIXME use right resolver for block\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let ty = ctx.lower_ty(type_ref);\n         let ty = self.insert_type_vars(ty);\n@@ -822,12 +824,11 @@ impl<'a> InferenceContext<'a> {\n             Some(path) => path,\n             None => return (self.err_ty(), None),\n         };\n-        let resolver = &self.resolver;\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         // FIXME: this should resolve assoc items as well, see this example:\n         // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n         let (resolution, unresolved) = if value_ns {\n-            match resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path()) {\n                 Some(ResolveValueResult::ValueNs(value)) => match value {\n                     ValueNs::EnumVariantId(var) => {\n                         let substs = ctx.substs_from_path(path, var.into(), true);\n@@ -848,7 +849,7 @@ impl<'a> InferenceContext<'a> {\n                 None => return (self.err_ty(), None),\n             }\n         } else {\n-            match resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n                 None => return (self.err_ty(), None),\n             }\n@@ -1058,6 +1059,15 @@ impl<'a> InferenceContext<'a> {\n         let struct_ = self.resolve_lang_item(LangItem::VaList)?.as_struct()?;\n         Some(struct_.into())\n     }\n+\n+    fn get_traits_in_scope(&self) -> Either<FxHashSet<TraitId>, &FxHashSet<TraitId>> {\n+        let mut b_traits = self.resolver.traits_in_scope_from_block_scopes().peekable();\n+        if b_traits.peek().is_some() {\n+            Either::Left(self.traits_in_scope.iter().copied().chain(b_traits).collect())\n+        } else {\n+            Either::Right(&self.traits_in_scope)\n+        }\n+    }\n }\n \n /// When inferring an expression, we propagate downward whatever type hint we"}, {"sha": "cca84488c94c83e3846296e12da8a769003f7556", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a360fab9a36a20046fed4c6e9b863c52c7578de0", "patch": "@@ -15,7 +15,6 @@ use hir_def::{\n     generics::TypeOrConstParamData,\n     lang_item::LangItem,\n     path::{GenericArg, GenericArgs},\n-    resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n use hir_expand::name::{name, Name};\n@@ -457,9 +456,10 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             Expr::Path(p) => {\n-                // FIXME this could be more efficient...\n-                let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n-                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n+                let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, tgt_expr);\n+                let ty = self.infer_path(p, tgt_expr.into()).unwrap_or_else(|| self.err_ty());\n+                self.resolver.reset_to_guard(g);\n+                ty\n             }\n             Expr::Continue { label } => {\n                 if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n@@ -1168,8 +1168,8 @@ impl<'a> InferenceContext<'a> {\n         expected: &Expectation,\n     ) -> Ty {\n         let coerce_ty = expected.coercion_target_type(&mut self.table);\n-        let old_resolver =\n-            mem::replace(&mut self.resolver, resolver_for_expr(self.db.upcast(), self.owner, expr));\n+        let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, expr);\n+\n         let (break_ty, ty) =\n             self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty.clone()), label, |this| {\n                 for stmt in statements {\n@@ -1256,7 +1256,7 @@ impl<'a> InferenceContext<'a> {\n                     }\n                 }\n             });\n-        self.resolver = old_resolver;\n+        self.resolver.reset_to_guard(g);\n \n         break_ty.unwrap_or(ty)\n     }\n@@ -1349,14 +1349,14 @@ impl<'a> InferenceContext<'a> {\n             None => {\n                 // no field found,\n                 let method_with_same_name_exists = {\n-                    let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n-                    let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n+                    self.get_traits_in_scope();\n \n+                    let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n                     method_resolution::lookup_method(\n                         self.db,\n                         &canonicalized_receiver.value,\n                         self.trait_env.clone(),\n-                        &traits_in_scope,\n+                        self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n                         VisibleFromModule::Filter(self.resolver.module()),\n                         name,\n                     )\n@@ -1385,13 +1385,11 @@ impl<'a> InferenceContext<'a> {\n         let receiver_ty = self.infer_expr(receiver, &Expectation::none());\n         let canonicalized_receiver = self.canonicalize(receiver_ty.clone());\n \n-        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n-\n         let resolved = method_resolution::lookup_method(\n             self.db,\n             &canonicalized_receiver.value,\n             self.trait_env.clone(),\n-            &traits_in_scope,\n+            self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n             VisibleFromModule::Filter(self.resolver.module()),\n             method_name,\n         );"}, {"sha": "a7bd009e34bd88c955c773496f1a8b8a6c6fe9cd", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=a360fab9a36a20046fed4c6e9b863c52c7578de0", "patch": "@@ -245,9 +245,8 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_record_pat_like(p.as_deref(), &expected, default_bm, pat, subs)\n             }\n             Pat::Path(path) => {\n-                // FIXME use correct resolver for the surrounding expression\n-                let resolver = self.resolver.clone();\n-                self.infer_path(&resolver, path, pat.into()).unwrap_or_else(|| self.err_ty())\n+                // FIXME update resolver for the surrounding expression\n+                self.infer_path(path, pat.into()).unwrap_or_else(|| self.err_ty())\n             }\n             Pat::Bind { mode, name: _, subpat } => {\n                 return self.infer_bind_pat(pat, *mode, default_bm, *subpat, &expected);"}, {"sha": "891e1fab2ed478622ae1883889e759aabdb10167", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 55, "deletions": 69, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=a360fab9a36a20046fed4c6e9b863c52c7578de0", "patch": "@@ -3,7 +3,7 @@\n use chalk_ir::cast::Cast;\n use hir_def::{\n     path::{Path, PathSegment},\n-    resolver::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n+    resolver::{ResolveValueResult, TypeNs, ValueNs},\n     AdtId, AssocItemId, EnumVariantId, ItemContainerId, Lookup,\n };\n use hir_expand::name::Name;\n@@ -21,41 +21,31 @@ use crate::{\n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n impl<'a> InferenceContext<'a> {\n-    pub(super) fn infer_path(\n-        &mut self,\n-        resolver: &Resolver,\n-        path: &Path,\n-        id: ExprOrPatId,\n-    ) -> Option<Ty> {\n-        let ty = self.resolve_value_path(resolver, path, id)?;\n+    pub(super) fn infer_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n+        let ty = self.resolve_value_path(path, id)?;\n         let ty = self.insert_type_vars(ty);\n         let ty = self.normalize_associated_types_in(ty);\n         Some(ty)\n     }\n \n-    fn resolve_value_path(\n-        &mut self,\n-        resolver: &Resolver,\n-        path: &Path,\n-        id: ExprOrPatId,\n-    ) -> Option<Ty> {\n+    fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n         let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n             let Some(last) = path.segments().last() else { return None };\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n-            let ctx = crate::lower::TyLoweringContext::new(self.db, resolver);\n+            let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n             let (ty, _) = ctx.lower_ty_relative_path(ty, None, remaining_segments_for_ty);\n-            self.resolve_ty_assoc_item(ty, last.name, id)?\n+            self.resolve_ty_assoc_item(ty, last.name, id).map(|(it, substs)| (it, Some(substs)))?\n         } else {\n             // FIXME: report error, unresolved first path segment\n             let value_or_partial =\n-                resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n+                self.resolver.resolve_path_in_value_ns(self.db.upcast(), path.mod_path())?;\n \n             match value_or_partial {\n                 ResolveValueResult::ValueNs(it) => (it, None),\n-                ResolveValueResult::Partial(def, remaining_index) => {\n-                    self.resolve_assoc_item(def, path, remaining_index, id)?\n-                }\n+                ResolveValueResult::Partial(def, remaining_index) => self\n+                    .resolve_assoc_item(def, path, remaining_index, id)\n+                    .map(|(it, substs)| (it, Some(substs)))?,\n             }\n         };\n \n@@ -123,7 +113,7 @@ impl<'a> InferenceContext<'a> {\n         path: &Path,\n         remaining_index: usize,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         assert!(remaining_index < path.segments().len());\n         // there may be more intermediate segments between the resolved one and\n         // the end. Only the last segment needs to be resolved to a value; from\n@@ -176,7 +166,7 @@ impl<'a> InferenceContext<'a> {\n         trait_ref: TraitRef,\n         segment: PathSegment<'_>,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         let trait_ = trait_ref.hir_trait_id();\n         let item =\n             self.db.trait_data(trait_).items.iter().map(|(_name, id)| (*id)).find_map(|item| {\n@@ -212,15 +202,15 @@ impl<'a> InferenceContext<'a> {\n         };\n \n         self.write_assoc_resolution(id, item, trait_ref.substitution.clone());\n-        Some((def, Some(trait_ref.substitution)))\n+        Some((def, trait_ref.substitution))\n     }\n \n     fn resolve_ty_assoc_item(\n         &mut self,\n         ty: Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         if let TyKind::Error = ty.kind(Interner) {\n             return None;\n         }\n@@ -230,78 +220,74 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         let canonical_ty = self.canonicalize(ty.clone());\n-        let traits_in_scope = self.resolver.traits_in_scope(self.db.upcast());\n \n         let mut not_visible = None;\n         let res = method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n             self.table.trait_env.clone(),\n-            &traits_in_scope,\n+            self.get_traits_in_scope().as_ref().left_or_else(|&it| it),\n             VisibleFromModule::Filter(self.resolver.module()),\n             Some(name),\n             method_resolution::LookupMode::Path,\n             |_ty, item, visible| {\n-                let (def, container) = match item {\n-                    AssocItemId::FunctionId(f) => {\n-                        (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n-                    }\n-                    AssocItemId::ConstId(c) => {\n-                        (ValueNs::ConstId(c), c.lookup(self.db.upcast()).container)\n-                    }\n-                    AssocItemId::TypeAliasId(_) => unreachable!(),\n-                };\n-                let substs = match container {\n-                    ItemContainerId::ImplId(impl_id) => {\n-                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n-                            .fill_with_inference_vars(&mut self.table)\n-                            .build();\n-                        let impl_self_ty =\n-                            self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n-                        self.unify(&impl_self_ty, &ty);\n-                        impl_substs\n-                    }\n-                    ItemContainerId::TraitId(trait_) => {\n-                        // we're picking this method\n-                        let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n-                            .push(ty.clone())\n-                            .fill_with_inference_vars(&mut self.table)\n-                            .build();\n-                        self.push_obligation(trait_ref.clone().cast(Interner));\n-                        trait_ref.substitution\n-                    }\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                        never!(\"assoc item contained in module/extern block\");\n-                        return None;\n-                    }\n-                };\n-\n                 if visible {\n-                    Some((def, item, Some(substs), true))\n+                    Some((item, true))\n                 } else {\n                     if not_visible.is_none() {\n-                        not_visible = Some((def, item, Some(substs), false));\n+                        not_visible = Some((item, false));\n                     }\n                     None\n                 }\n             },\n         );\n         let res = res.or(not_visible);\n-        if let Some((_, item, Some(ref substs), visible)) = res {\n-            self.write_assoc_resolution(id, item, substs.clone());\n-            if !visible {\n-                self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item })\n+        let (item, visible) = res?;\n+\n+        let (def, container) = match item {\n+            AssocItemId::FunctionId(f) => {\n+                (ValueNs::FunctionId(f), f.lookup(self.db.upcast()).container)\n+            }\n+            AssocItemId::ConstId(c) => (ValueNs::ConstId(c), c.lookup(self.db.upcast()).container),\n+            AssocItemId::TypeAliasId(_) => unreachable!(),\n+        };\n+        let substs = match container {\n+            ItemContainerId::ImplId(impl_id) => {\n+                let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n+                    .fill_with_inference_vars(&mut self.table)\n+                    .build();\n+                let impl_self_ty = self.db.impl_self_ty(impl_id).substitute(Interner, &impl_substs);\n+                self.unify(&impl_self_ty, &ty);\n+                impl_substs\n+            }\n+            ItemContainerId::TraitId(trait_) => {\n+                // we're picking this method\n+                let trait_ref = TyBuilder::trait_ref(self.db, trait_)\n+                    .push(ty.clone())\n+                    .fill_with_inference_vars(&mut self.table)\n+                    .build();\n+                self.push_obligation(trait_ref.clone().cast(Interner));\n+                trait_ref.substitution\n+            }\n+            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                never!(\"assoc item contained in module/extern block\");\n+                return None;\n             }\n+        };\n+\n+        self.write_assoc_resolution(id, item, substs.clone());\n+        if !visible {\n+            self.push_diagnostic(InferenceDiagnostic::PrivateAssocItem { id, item });\n         }\n-        res.map(|(def, _, substs, _)| (def, substs))\n+        Some((def, substs))\n     }\n \n     fn resolve_enum_variant_on_ty(\n         &mut self,\n         ty: &Ty,\n         name: &Name,\n         id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substitution>)> {\n+    ) -> Option<(ValueNs, Substitution)> {\n         let ty = self.resolve_ty_shallow(ty);\n         let (enum_id, subst) = match ty.as_adt() {\n             Some((AdtId::EnumId(e), subst)) => (e, subst),\n@@ -311,6 +297,6 @@ impl<'a> InferenceContext<'a> {\n         let local_id = enum_data.variant(name)?;\n         let variant = EnumVariantId { parent: enum_id, local_id };\n         self.write_variant_resolution(id, variant.into());\n-        Some((ValueNs::EnumVariantId(variant), Some(subst.clone())))\n+        Some((ValueNs::EnumVariantId(variant), subst.clone()))\n     }\n }"}, {"sha": "bcd63d9472a8102c854790ad722f79558e261b50", "filename": "crates/hir-ty/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a360fab9a36a20046fed4c6e9b863c52c7578de0/crates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=a360fab9a36a20046fed4c6e9b863c52c7578de0", "patch": "@@ -163,7 +163,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 } else {\n                     ty.display_test(&db).to_string()\n                 };\n-                assert_eq!(actual, expected);\n+                assert_eq!(actual, expected, \"type annotation differs at {:#?}\", range.range);\n             }\n         }\n \n@@ -179,7 +179,7 @@ fn check_impl(ra_fixture: &str, allow_none: bool, only_types: bool, display_sour\n                 } else {\n                     ty.display_test(&db).to_string()\n                 };\n-                assert_eq!(actual, expected);\n+                assert_eq!(actual, expected, \"type annotation differs at {:#?}\", range.range);\n             }\n             if let Some(expected) = adjustments.remove(&range) {\n                 let adjustments = inference_result"}]}