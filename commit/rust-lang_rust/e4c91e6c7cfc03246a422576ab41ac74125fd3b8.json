{"sha": "e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YzkxZTZjN2NmYzAzMjQ2YTQyMjU3NmFiNDFhYzc0MTI1ZmQzYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-17T09:11:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-17T09:11:56Z"}, "message": "auto merge of #12735 : eddyb/rust/at-exodus-chapter-11, r=cmr", "tree": {"sha": "bf813a516c3fdfd864e1ae3422b93f22da28bdf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf813a516c3fdfd864e1ae3422b93f22da28bdf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "html_url": "https://github.com/rust-lang/rust/commit/e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6d5b8f6ff7b9feaf8f11e2624c6eeeeb5b3a9d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6d5b8f6ff7b9feaf8f11e2624c6eeeeb5b3a9d9", "html_url": "https://github.com/rust-lang/rust/commit/b6d5b8f6ff7b9feaf8f11e2624c6eeeeb5b3a9d9"}, {"sha": "e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc", "html_url": "https://github.com/rust-lang/rust/commit/e2ebc8f81138bcad019f43a3af0cddb0dc0dcfbc"}], "stats": {"total": 11738, "additions": 5578, "deletions": 6160}, "files": [{"sha": "863b91f9b32dd4fdc6289f5e84380bfebb793eab", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -28,17 +28,17 @@ use syntax::abi;\n \n pub static METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n-pub struct Archive {\n-    priv sess: Session,\n+pub struct Archive<'a> {\n+    priv sess: &'a Session,\n     priv dst: Path,\n }\n \n pub struct ArchiveRO {\n     priv ptr: ArchiveRef,\n }\n \n-fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n-        paths: &[&Path]) -> ProcessOutput {\n+fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n+          paths: &[&Path]) -> ProcessOutput {\n     let ar = get_ar_prog(sess);\n \n     let mut args = vec!(args.to_owned());\n@@ -74,16 +74,16 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n     }\n }\n \n-impl Archive {\n+impl<'a> Archive<'a> {\n     /// Initializes a new static archive with the given object file\n-    pub fn create<'a>(sess: Session, dst: &'a Path,\n-                      initial_object: &'a Path) -> Archive {\n+    pub fn create<'b>(sess: &'a Session, dst: &'b Path,\n+                      initial_object: &'b Path) -> Archive<'a> {\n         run_ar(sess, \"crus\", None, [dst, initial_object]);\n         Archive { sess: sess, dst: dst.clone() }\n     }\n \n     /// Opens an existing static archive\n-    pub fn open(sess: Session, dst: Path) -> Archive {\n+    pub fn open(sess: &'a Session, dst: Path) -> Archive<'a> {\n         assert!(dst.exists());\n         Archive { sess: sess, dst: dst }\n     }\n@@ -206,7 +206,7 @@ impl Archive {\n         let unixlibname = format!(\"lib{}.a\", name);\n \n         let mut rustpath = filesearch::rust_path();\n-        rustpath.push(self.sess.filesearch.get_target_lib_path());\n+        rustpath.push(self.sess.filesearch().get_target_lib_path());\n         let addl_lib_search_paths = self.sess\n                                         .opts\n                                         .addl_lib_search_paths"}, {"sha": "edb9d11b11a0d337821b167fd2425248896c175b", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -54,7 +54,7 @@ pub enum OutputType {\n     OutputTypeExe,\n }\n \n-pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n+pub fn llvm_err(sess: &Session, msg: ~str) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n@@ -68,7 +68,7 @@ pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n }\n \n pub fn WriteOutputFile(\n-        sess: Session,\n+        sess: &Session,\n         target: lib::llvm::TargetMachineRef,\n         pm: lib::llvm::PassManagerRef,\n         m: ModuleRef,\n@@ -125,7 +125,7 @@ pub mod write {\n         }\n     }\n \n-    pub fn run_passes(sess: Session,\n+    pub fn run_passes(sess: &Session,\n                       trans: &CrateTranslation,\n                       output_types: &[OutputType],\n                       output: &OutputFilenames) {\n@@ -156,7 +156,7 @@ pub mod write {\n \n             let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|t| {\n                 sess.opts.cg.target_cpu.with_c_str(|cpu| {\n-                    target_feature(&sess).with_c_str(|features| {\n+                    target_feature(sess).with_c_str(|features| {\n                         llvm::LLVMRustCreateTargetMachine(\n                             t, cpu, features,\n                             lib::llvm::CodeModelDefault,\n@@ -323,7 +323,7 @@ pub mod write {\n         }\n     }\n \n-    pub fn run_assembler(sess: Session, outputs: &OutputFilenames) {\n+    pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n         let cc = super::get_cc_prog(sess);\n         let assembly = outputs.temp_path(OutputTypeAssembly);\n         let object = outputs.path(OutputTypeObject);\n@@ -351,7 +351,7 @@ pub mod write {\n         }\n     }\n \n-    unsafe fn configure_llvm(sess: Session) {\n+    unsafe fn configure_llvm(sess: &Session) {\n         use sync::one::{Once, ONCE_INIT};\n         static mut INIT: Once = ONCE_INIT;\n \n@@ -534,7 +534,7 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &mut Sha256,\n+fn symbol_hash(tcx: &ty::ctxt, symbol_hasher: &mut Sha256,\n                t: ty::t, link_meta: &LinkMeta) -> ~str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n@@ -559,7 +559,7 @@ fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n \n     let mut type_hashcodes = ccx.type_hashcodes.borrow_mut();\n     let mut symbol_hasher = ccx.symbol_hasher.borrow_mut();\n-    let hash = symbol_hash(ccx.tcx, symbol_hasher.get(), t, &ccx.link_meta);\n+    let hash = symbol_hash(ccx.tcx(), symbol_hasher.get(), t, &ccx.link_meta);\n     type_hashcodes.get().insert(t, hash.clone());\n     hash\n }\n@@ -694,7 +694,7 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n-    let s = ppaux::ty_to_short_str(ccx.tcx, t);\n+    let s = ppaux::ty_to_short_str(ccx.tcx(), t);\n     let path = [PathName(token::intern(name)),\n                 PathName(token::intern(s))];\n     let hash = get_symbol_hash(ccx, t);\n@@ -704,7 +704,7 @@ pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n                                             name: &str) -> ~str {\n-    let s = ppaux::ty_to_str(ccx.tcx, t);\n+    let s = ppaux::ty_to_str(ccx.tcx(), t);\n     let path = [PathName(token::intern(s)),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n@@ -719,7 +719,7 @@ pub fn output_lib_filename(id: &CrateId) -> ~str {\n     format!(\"{}-{}-{}\", id.name, crate_id_hash(id), id.version_or_default())\n }\n \n-pub fn get_cc_prog(sess: Session) -> ~str {\n+pub fn get_cc_prog(sess: &Session) -> ~str {\n     match sess.opts.cg.linker {\n         Some(ref linker) => return linker.to_owned(),\n         None => {}\n@@ -737,7 +737,7 @@ pub fn get_cc_prog(sess: Session) -> ~str {\n     get_system_tool(sess, \"cc\")\n }\n \n-pub fn get_ar_prog(sess: Session) -> ~str {\n+pub fn get_ar_prog(sess: &Session) -> ~str {\n     match sess.opts.cg.ar {\n         Some(ref ar) => return ar.to_owned(),\n         None => {}\n@@ -746,7 +746,7 @@ pub fn get_ar_prog(sess: Session) -> ~str {\n     get_system_tool(sess, \"ar\")\n }\n \n-fn get_system_tool(sess: Session, tool: &str) -> ~str {\n+fn get_system_tool(sess: &Session, tool: &str) -> ~str {\n     match sess.targ_cfg.os {\n         abi::OsAndroid => match sess.opts.cg.android_cross_path {\n             Some(ref path) => {\n@@ -765,7 +765,7 @@ fn get_system_tool(sess: Session, tool: &str) -> ~str {\n     }\n }\n \n-fn remove(sess: Session, path: &Path) {\n+fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}\n         Err(e) => {\n@@ -776,7 +776,7 @@ fn remove(sess: Session, path: &Path) {\n \n /// Perform the linkage portion of the compilation phase. This will generate all\n /// of the requested outputs for this compilation session.\n-pub fn link_binary(sess: Session,\n+pub fn link_binary(sess: &Session,\n                    trans: &CrateTranslation,\n                    outputs: &OutputFilenames,\n                    id: &CrateId) -> Vec<Path> {\n@@ -830,7 +830,7 @@ pub fn filename_for_input(sess: &Session, crate_type: session::CrateType,\n     }\n }\n \n-fn link_binary_output(sess: Session,\n+fn link_binary_output(sess: &Session,\n                       trans: &CrateTranslation,\n                       crate_type: session::CrateType,\n                       outputs: &OutputFilenames,\n@@ -840,7 +840,7 @@ fn link_binary_output(sess: Session,\n         Some(ref file) => file.clone(),\n         None => {\n             let out_filename = outputs.path(OutputTypeExe);\n-            filename_for_input(&sess, crate_type, id, &out_filename)\n+            filename_for_input(sess, crate_type, id, &out_filename)\n         }\n     };\n \n@@ -883,10 +883,10 @@ fn link_binary_output(sess: Session,\n // rlib primarily contains the object file of the crate, but it also contains\n // all of the object files from native libraries. This is done by unzipping\n // native libraries and inserting all of the contents into this archive.\n-fn link_rlib(sess: Session,\n-             trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n-             obj_filename: &Path,\n-             out_filename: &Path) -> Archive {\n+fn link_rlib<'a>(sess: &'a Session,\n+                 trans: Option<&CrateTranslation>, // None == no metadata/bytecode\n+                 obj_filename: &Path,\n+                 out_filename: &Path) -> Archive<'a> {\n     let mut a = Archive::create(sess, out_filename, obj_filename);\n \n     let used_libraries = sess.cstore.get_used_libraries();\n@@ -985,7 +985,7 @@ fn link_rlib(sess: Session,\n // There's no need to include metadata in a static archive, so ensure to not\n // link in the metadata object file (and also don't prepare the archive with a\n // metadata file).\n-fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n+fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n     let mut a = link_rlib(sess, None, obj_filename, out_filename);\n     a.add_native_library(\"morestack\").unwrap();\n     a.add_native_library(\"compiler-rt\").unwrap();\n@@ -1000,7 +1000,7 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n             }\n         };\n         a.add_rlib(&p, name, sess.lto()).unwrap();\n-        let native_libs = csearch::get_native_libraries(sess.cstore, cnum);\n+        let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         for &(kind, ref lib) in native_libs.iter() {\n             let name = match kind {\n                 cstore::NativeStatic => \"static library\",\n@@ -1016,7 +1016,7 @@ fn link_staticlib(sess: Session, obj_filename: &Path, out_filename: &Path) {\n //\n // This will invoke the system linker/cc to create the resulting file. This\n // links to all upstream files as well.\n-fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n+fn link_natively(sess: &Session, dylib: bool, obj_filename: &Path,\n                  out_filename: &Path) {\n     let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n     // The invocations of cc share some flags across platforms\n@@ -1066,7 +1066,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     }\n }\n \n-fn link_args(sess: Session,\n+fn link_args(sess: &Session,\n              dylib: bool,\n              tmpdir: &Path,\n              obj_filename: &Path,\n@@ -1075,7 +1075,7 @@ fn link_args(sess: Session,\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let lib_path = sess.filesearch.get_target_lib_path();\n+    let lib_path = sess.filesearch().get_target_lib_path();\n     let stage: ~str = ~\"-L\" + lib_path.as_str().unwrap();\n \n     let mut args = vec!(stage);\n@@ -1248,7 +1248,7 @@ fn link_args(sess: Session,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut Vec<~str> , sess: Session) {\n+fn add_local_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n     let addl_lib_search_paths = sess.opts.addl_lib_search_paths.borrow();\n     for path in addl_lib_search_paths.get().iter() {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n@@ -1281,7 +1281,7 @@ fn add_local_native_libraries(args: &mut Vec<~str> , sess: Session) {\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n+fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n                             dylib: bool, tmpdir: &Path) {\n \n     // As a limitation of the current implementation, we require that everything\n@@ -1302,8 +1302,8 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n     // * If one form of linking fails, the second is also attempted\n     // * If both forms fail, then we emit an error message\n \n-    let dynamic = get_deps(sess.cstore, cstore::RequireDynamic);\n-    let statik = get_deps(sess.cstore, cstore::RequireStatic);\n+    let dynamic = get_deps(&sess.cstore, cstore::RequireDynamic);\n+    let statik = get_deps(&sess.cstore, cstore::RequireStatic);\n     match (dynamic, statik, sess.opts.cg.prefer_dynamic, dylib) {\n         (_, Some(deps), false, false) => {\n             add_static_crates(args, sess, tmpdir, deps)\n@@ -1352,9 +1352,8 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n     }\n \n     // Converts a library file-stem into a cc -l argument\n-    fn unlib(config: @session::Config, stem: &str) -> ~str {\n-        if stem.starts_with(\"lib\") &&\n-            config.os != abi::OsWin32 {\n+    fn unlib(config: &session::Config, stem: &str) -> ~str {\n+        if stem.starts_with(\"lib\") && config.os != abi::OsWin32 {\n             stem.slice(3, stem.len()).to_owned()\n         } else {\n             stem.to_owned()\n@@ -1376,8 +1375,8 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n     }\n \n     // Adds the static \"rlib\" versions of all crates to the command line.\n-    fn add_static_crates(args: &mut Vec<~str> , sess: Session, tmpdir: &Path,\n-                         crates: Vec<(ast::CrateNum, Path)> ) {\n+    fn add_static_crates(args: &mut Vec<~str>, sess: &Session, tmpdir: &Path,\n+                         crates: Vec<(ast::CrateNum, Path)>) {\n         for (cnum, cratepath) in crates.move_iter() {\n             // When performing LTO on an executable output, all of the\n             // bytecode from the upstream libraries has already been\n@@ -1423,7 +1422,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crates(args: &mut Vec<~str> , sess: Session,\n+    fn add_dynamic_crates(args: &mut Vec<~str>, sess: &Session,\n                           crates: Vec<(ast::CrateNum, Path)> ) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n@@ -1434,7 +1433,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n             // what its name is\n             let dir = cratepath.dirname_str().unwrap();\n             if !dir.is_empty() { args.push(\"-L\" + dir); }\n-            let libarg = unlib(sess.targ_cfg, cratepath.filestem_str().unwrap());\n+            let libarg = unlib(&sess.targ_cfg, cratepath.filestem_str().unwrap());\n             args.push(\"-l\" + libarg);\n         }\n     }\n@@ -1458,8 +1457,8 @@ fn add_upstream_rust_crates(args: &mut Vec<~str> , sess: Session,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(args: &mut Vec<~str> , sess: Session) {\n-    let cstore = sess.cstore;\n+fn add_upstream_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n+    let cstore = &sess.cstore;\n     cstore.iter_crate_data(|cnum, _| {\n         let libs = csearch::get_native_libraries(cstore, cnum);\n         for &(kind, ref lib) in libs.iter() {"}, {"sha": "b42e8f1b92e2cede46d5347cab6d0983f0b947f6", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -18,7 +18,7 @@ use util::common::time;\n use std::libc;\n use flate;\n \n-pub fn run(sess: session::Session, llmod: ModuleRef,\n+pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[~str]) {\n     if sess.opts.cg.prefer_dynamic {\n         sess.err(\"cannot prefer dynamic linking when performing LTO\");"}, {"sha": "d8feb0a47b3b934f80818149a0b3fe17dd3d07ee", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use driver::session;\n+use driver::session::Session;\n use metadata::cstore;\n use metadata::filesearch;\n \n@@ -22,7 +22,7 @@ fn not_win32(os: abi::Os) -> bool {\n   os != abi::OsWin32\n }\n \n-pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str> {\n+pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<~str> {\n     let os = sess.targ_cfg.os;\n \n     // No rpath on windows\n@@ -40,7 +40,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str>\n \n     debug!(\"preparing the RPATH!\");\n \n-    let sysroot = sess.filesearch.sysroot;\n+    let sysroot = sess.filesearch().sysroot;\n     let output = out_filename;\n     let libs = sess.cstore.get_used_crates(cstore::RequireDynamic);\n     let libs = libs.move_iter().filter_map(|(_, l)| l.map(|p| p.clone())).collect();\n@@ -54,9 +54,9 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str>\n     flags\n }\n \n-fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n+fn get_sysroot_absolute_rt_lib(sess: &Session) -> Path {\n     let r = filesearch::relative_target_lib_path(sess.opts.target_triple);\n-    let mut p = sess.filesearch.sysroot.join(&r);\n+    let mut p = sess.filesearch().sysroot.join(&r);\n     p.push(os::dll_filename(\"rustrt\"));\n     p\n }"}, {"sha": "e7c1e214d070a9e6ee126a6975cd658f055ecec5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 193, "deletions": 181, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -13,7 +13,7 @@ use back::link;\n use back::{arm, x86, x86_64, mips};\n use driver::session::{Aggressive, CrateTypeExecutable, CrateType,\n                       FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n-use driver::session::{Session, Session_, No, Less, Default};\n+use driver::session::{Session, No, Less, Default};\n use driver::session;\n use front;\n use lib::llvm::llvm;\n@@ -27,18 +27,18 @@ use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n-use util::nodemap::NodeSet;\n+use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::{json, Encodable};\n \n use std::cell::{Cell, RefCell};\n use std::io;\n use std::io::fs;\n use std::io::MemReader;\n+use std::mem::drop;\n use std::os;\n use std::vec_ng::Vec;\n use std::vec_ng;\n-use collections::HashMap;\n use getopts::{optopt, optmulti, optflag, optflagopt};\n use getopts;\n use syntax::ast;\n@@ -74,13 +74,13 @@ pub fn anon_src() -> ~str {\n \n pub fn source_name(input: &Input) -> ~str {\n     match *input {\n-      // FIXME (#9639): This needs to handle non-utf8 paths\n-      FileInput(ref ifile) => ifile.as_str().unwrap().to_str(),\n-      StrInput(_) => anon_src()\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        FileInput(ref ifile) => ifile.as_str().unwrap().to_str(),\n+        StrInput(_) => anon_src()\n     }\n }\n \n-pub fn default_configuration(sess: Session) ->\n+pub fn default_configuration(sess: &Session) ->\n    ast::CrateConfig {\n     let tos = match sess.targ_cfg.os {\n         abi::OsWin32 =>   InternedString::new(\"win32\"),\n@@ -123,7 +123,7 @@ pub fn append_configuration(cfg: &mut ast::CrateConfig,\n     }\n }\n \n-pub fn build_configuration(sess: Session) -> ast::CrateConfig {\n+pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess);\n@@ -146,11 +146,10 @@ pub fn build_configuration(sess: Session) -> ast::CrateConfig {\n fn parse_cfgspecs(cfgspecs: Vec<~str> )\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n-        let sess = parse::new_parse_sess();\n         parse::parse_meta_from_source_str(\"cfgspec\".to_str(),\n                                           s,\n                                           Vec::new(),\n-                                          sess)\n+                                          &parse::new_parse_sess())\n     }).collect::<ast::CrateConfig>()\n }\n \n@@ -170,18 +169,18 @@ impl Input {\n     }\n }\n \n-pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &Input)\n+pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     -> ast::Crate {\n     let krate = time(sess.time_passes(), \"parsing\", (), |_| {\n         match *input {\n             FileInput(ref file) => {\n-                parse::parse_crate_from_file(&(*file), cfg.clone(), sess.parse_sess)\n+                parse::parse_crate_from_file(&(*file), cfg.clone(), &sess.parse_sess)\n             }\n             StrInput(ref src) => {\n                 parse::parse_crate_from_source_str(anon_src(),\n                                                    (*src).clone(),\n                                                    cfg.clone(),\n-                                                   sess.parse_sess)\n+                                                   &sess.parse_sess)\n             }\n         }\n     });\n@@ -206,15 +205,15 @@ pub fn phase_1_parse_input(sess: Session, cfg: ast::CrateConfig, input: &Input)\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided and injection of a dependency on the\n /// standard library and prelude.\n-pub fn phase_2_configure_and_expand(sess: Session,\n+pub fn phase_2_configure_and_expand(sess: &Session,\n                                     loader: &mut CrateLoader,\n                                     mut krate: ast::Crate,\n                                     crate_id: &CrateId)\n                                     -> (ast::Crate, syntax::ast_map::Map) {\n     let time_passes = sess.time_passes();\n \n-    sess.building_library.set(session::building_library(sess.opts, &krate));\n-    sess.crate_types.set(session::collect_crate_types(&sess,\n+    sess.building_library.set(session::building_library(&sess.opts, &krate));\n+    sess.crate_types.set(session::collect_crate_types(sess,\n                                                       krate.attrs\n                                                            .as_slice()));\n \n@@ -241,7 +240,7 @@ pub fn phase_2_configure_and_expand(sess: Session,\n             deriving_hash_type_parameter: sess.features.default_type_params.get(),\n             crate_id: crate_id.clone(),\n         };\n-        syntax::ext::expand::expand_crate(sess.parse_sess,\n+        syntax::ext::expand::expand_crate(&sess.parse_sess,\n                                           cfg,\n                                           krate)\n     });\n@@ -276,7 +275,7 @@ pub struct CrateAnalysis {\n     public_items: middle::privacy::PublicItems,\n     ty_cx: ty::ctxt,\n     maps: astencode::Maps,\n-    reachable: @RefCell<NodeSet>,\n+    reachable: NodeSet,\n }\n \n /// Run the resolution, typechecking, region checking and other\n@@ -289,12 +288,12 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n     let time_passes = sess.time_passes();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n-         creader::read_crates(sess, krate,\n+         creader::read_crates(&sess, krate,\n                               session::sess_os_to_meta_os(sess.targ_cfg.os),\n                               token::get_ident_interner()));\n \n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n-                          middle::lang_items::collect_language_items(krate, sess));\n+                          middle::lang_items::collect_language_items(krate, &sess));\n \n     let middle::resolve::CrateMap {\n         def_map: def_map,\n@@ -304,93 +303,92 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n         last_private_map: last_private_map\n     } =\n         time(time_passes, \"resolution\", (), |_|\n-             middle::resolve::resolve_crate(sess, lang_items, krate));\n+             middle::resolve::resolve_crate(&sess, lang_items, krate));\n \n     let named_region_map = time(time_passes, \"lifetime resolution\", (),\n-                                |_| middle::resolve_lifetime::krate(sess, krate));\n+                                |_| middle::resolve_lifetime::krate(&sess, krate));\n \n     time(time_passes, \"looking for entry point\", (),\n-         |_| middle::entry::find_entry_point(sess, krate, &ast_map));\n+         |_| middle::entry::find_entry_point(&sess, krate, &ast_map));\n \n     sess.macro_registrar_fn.with_mut(|r| *r =\n         time(time_passes, \"looking for macro registrar\", (), |_|\n             syntax::ext::registrar::find_macro_registrar(\n-                sess.span_diagnostic, krate)));\n+                sess.diagnostic(), krate)));\n \n     let freevars = time(time_passes, \"freevar finding\", (), |_|\n                         freevars::annotate_freevars(def_map, krate));\n \n     let region_map = time(time_passes, \"region resolution\", (), |_|\n-                          middle::region::resolve_crate(sess, krate));\n+                          middle::region::resolve_crate(&sess, krate));\n \n     let ty_cx = ty::mk_ctxt(sess, def_map, named_region_map, ast_map,\n                             freevars, region_map, lang_items);\n \n     // passes are timed inside typeck\n-    let (method_map, vtable_map) = typeck::check_crate(ty_cx, trait_map, krate);\n+    let (method_map, vtable_map) = typeck::check_crate(&ty_cx, trait_map, krate);\n \n     time(time_passes, \"check static items\", (), |_|\n-         middle::check_static::check_crate(ty_cx, krate));\n+         middle::check_static::check_crate(&ty_cx, krate));\n \n     // These next two const passes can probably be merged\n     time(time_passes, \"const marking\", (), |_|\n-         middle::const_eval::process_crate(krate, ty_cx));\n+         middle::const_eval::process_crate(krate, &ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(sess, krate, def_map,\n-                                          method_map, ty_cx));\n+         middle::check_const::check_crate(krate, def_map, method_map, &ty_cx));\n \n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 middle::privacy::check_crate(ty_cx, &method_map, &exp_map2,\n+                 middle::privacy::check_crate(&ty_cx, &method_map, &exp_map2,\n                                               a, b, krate));\n \n     time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(ty_cx, method_map, krate));\n+         middle::effect::check_crate(&ty_cx, method_map, krate));\n \n     time(time_passes, \"loop checking\", (), |_|\n-         middle::check_loop::check_crate(ty_cx, krate));\n+         middle::check_loop::check_crate(&ty_cx, krate));\n \n     let middle::moves::MoveMaps {moves_map, moved_variables_set,\n                                  capture_map} =\n         time(time_passes, \"compute moves\", (), |_|\n-             middle::moves::compute_moves(ty_cx, method_map, krate));\n+             middle::moves::compute_moves(&ty_cx, method_map, krate));\n \n     time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(ty_cx, method_map,\n-                                          moves_map, krate));\n+         middle::check_match::check_crate(&ty_cx, method_map,\n+                                          &moves_map, krate));\n \n     time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(ty_cx, method_map,\n-                                       capture_map, krate));\n+         middle::liveness::check_crate(&ty_cx, method_map,\n+                                       &capture_map, krate));\n \n     let root_map =\n         time(time_passes, \"borrow checking\", (), |_|\n-             middle::borrowck::check_crate(ty_cx, method_map,\n-                                           moves_map, moved_variables_set,\n-                                           capture_map, krate));\n+             middle::borrowck::check_crate(&ty_cx, method_map,\n+                                           &moves_map, &moved_variables_set,\n+                                           &capture_map, krate));\n+\n+    drop(moves_map);\n+    drop(moved_variables_set);\n \n     time(time_passes, \"kind checking\", (), |_|\n-         kind::check_crate(ty_cx, method_map, krate));\n+         kind::check_crate(&ty_cx, method_map, krate));\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n-             reachable::find_reachable(ty_cx, method_map, &exported_items));\n-\n-    {\n-        let reachable_map = reachable_map.borrow();\n-        time(time_passes, \"death checking\", (), |_| {\n-             middle::dead::check_crate(ty_cx,\n-                                       method_map,\n-                                       &exported_items,\n-                                       reachable_map.get(),\n-                                       krate)\n-        });\n-    }\n+             reachable::find_reachable(&ty_cx, method_map, &exported_items));\n+\n+    time(time_passes, \"death checking\", (), |_| {\n+        middle::dead::check_crate(&ty_cx,\n+                                  method_map,\n+                                  &exported_items,\n+                                  &reachable_map,\n+                                  krate)\n+    });\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(ty_cx, method_map, &exported_items, krate));\n+         lint::check_crate(&ty_cx, method_map, &exported_items, krate));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n@@ -401,7 +399,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n             root_map: root_map,\n             method_map: method_map,\n             vtable_map: vtable_map,\n-            capture_map: capture_map\n+            capture_map: RefCell::new(capture_map)\n         },\n         reachable: reachable_map\n     }\n@@ -418,17 +416,19 @@ pub struct CrateTranslation {\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm(sess: Session,\n-                                 krate: ast::Crate,\n-                                 analysis: &CrateAnalysis,\n-                                 outputs: &OutputFilenames) -> CrateTranslation {\n-    time(sess.time_passes(), \"translation\", krate, |krate|\n-         trans::base::trans_crate(sess, krate, analysis, outputs))\n+pub fn phase_4_translate_to_llvm(krate: ast::Crate,\n+                                 analysis: CrateAnalysis,\n+                                 outputs: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n+    // Option dance to work around the lack of stack once closures.\n+    let time_passes = analysis.ty_cx.sess.time_passes();\n+    let mut analysis = Some(analysis);\n+    time(time_passes, \"translation\", krate, |krate|\n+         trans::base::trans_crate(krate, analysis.take_unwrap(), outputs))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n-pub fn phase_5_run_llvm_passes(sess: Session,\n+pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &CrateTranslation,\n                                outputs: &OutputFilenames) {\n     if sess.opts.cg.no_integrated_as {\n@@ -454,7 +454,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n \n /// Run the linker on any artifacts that resulted from the LLVM run.\n /// This should produce either a finished executable or library.\n-pub fn phase_6_link_output(sess: Session,\n+pub fn phase_6_link_output(sess: &Session,\n                            trans: &CrateTranslation,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(), \"linking\", (), |_|\n@@ -464,15 +464,15 @@ pub fn phase_6_link_output(sess: Session,\n                            &trans.link.crateid));\n }\n \n-pub fn stop_after_phase_3(sess: Session) -> bool {\n+pub fn stop_after_phase_3(sess: &Session) -> bool {\n    if sess.opts.no_trans {\n         debug!(\"invoked with --no-trans, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n-pub fn stop_after_phase_1(sess: Session) -> bool {\n+pub fn stop_after_phase_1(sess: &Session) -> bool {\n     if sess.opts.parse_only {\n         debug!(\"invoked with --parse-only, returning early from compile_input\");\n         return true;\n@@ -483,23 +483,23 @@ pub fn stop_after_phase_1(sess: Session) -> bool {\n     return sess.opts.debugging_opts & session::AST_JSON_NOEXPAND != 0;\n }\n \n-pub fn stop_after_phase_2(sess: Session) -> bool {\n+pub fn stop_after_phase_2(sess: &Session) -> bool {\n     if sess.opts.no_analysis {\n         debug!(\"invoked with --no-analysis, returning early from compile_input\");\n         return true;\n     }\n     return sess.opts.debugging_opts & session::AST_JSON != 0;\n }\n \n-pub fn stop_after_phase_5(sess: Session) -> bool {\n+pub fn stop_after_phase_5(sess: &Session) -> bool {\n     if !sess.opts.output_types.iter().any(|&i| i == link::OutputTypeExe) {\n         debug!(\"not building executable, returning early from compile_input\");\n         return true;\n     }\n     return false;\n }\n \n-fn write_out_deps(sess: Session,\n+fn write_out_deps(sess: &Session,\n                   input: &Input,\n                   outputs: &OutputFilenames,\n                   krate: &ast::Crate) -> io::IoResult<()> {\n@@ -512,7 +512,7 @@ fn write_out_deps(sess: Session,\n             link::OutputTypeExe => {\n                 let crate_types = sess.crate_types.borrow();\n                 for output in crate_types.get().iter() {\n-                    let p = link::filename_for_input(&sess, *output, &id, &file);\n+                    let p = link::filename_for_input(sess, *output, &id, &file);\n                     out_filenames.push(p);\n                 }\n             }\n@@ -540,19 +540,14 @@ fn write_out_deps(sess: Session,\n \n     // Build a list of files used to compile the output and\n     // write Makefile-compatible dependency rules\n-    let files: Vec<~str> = {\n-        let files = sess.codemap.files.borrow();\n-        files.get()\n-             .iter()\n-             .filter_map(|fmap| {\n-                 if fmap.is_real_file() {\n-                     Some(fmap.name.clone())\n-                 } else {\n-                     None\n-                 }\n-             })\n-             .collect()\n-    };\n+    let files: Vec<~str> = sess.codemap().files.borrow().get()\n+                               .iter().filter_map(|fmap| {\n+                                    if fmap.deref().is_real_file() {\n+                                        Some(fmap.deref().name.clone())\n+                                    } else {\n+                                        None\n+                                    }\n+                                }).collect();\n     let mut file = try!(io::File::create(&deps_filename));\n     for path in out_filenames.iter() {\n         try!(write!(&mut file as &mut Writer,\n@@ -566,65 +561,70 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let outputs;\n-    let trans = {\n-        let (expanded_crate, ast_map) = {\n-            let krate = phase_1_parse_input(sess, cfg, input);\n-            if stop_after_phase_1(sess) { return; }\n-            outputs = build_output_filenames(input,\n-                                             outdir,\n-                                             output,\n-                                             krate.attrs.as_slice(),\n-                                             sess);\n-            let loader = &mut Loader::new(sess);\n+    let (outputs, trans, sess) = {\n+        let (outputs, expanded_crate, ast_map) = {\n+            let krate = phase_1_parse_input(&sess, cfg, input);\n+            if stop_after_phase_1(&sess) { return; }\n+            let outputs = build_output_filenames(input,\n+                                                 outdir,\n+                                                 output,\n+                                                 krate.attrs.as_slice(),\n+                                                 &sess);\n+            let loader = &mut Loader::new(&sess);\n             let id = link::find_crate_id(krate.attrs.as_slice(),\n                                          outputs.out_filestem);\n-            phase_2_configure_and_expand(sess, loader, krate, &id)\n+            let (expanded_crate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n+                                                                         krate, &id);\n+            (outputs, expanded_crate, ast_map)\n         };\n+        write_out_deps(&sess, input, &outputs, &expanded_crate).unwrap();\n \n-        write_out_deps(sess, input, &outputs, &expanded_crate).unwrap();\n-\n-        if stop_after_phase_2(sess) { return; }\n+        if stop_after_phase_2(&sess) { return; }\n \n         let analysis = phase_3_run_analysis_passes(sess, &expanded_crate, ast_map);\n-        if stop_after_phase_3(sess) { return; }\n-        phase_4_translate_to_llvm(sess, expanded_crate, &analysis, &outputs)\n+        if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n+        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate,\n+                                                     analysis, &outputs);\n+        (outputs, trans, tcx.sess)\n     };\n-    phase_5_run_llvm_passes(sess, &trans, &outputs);\n-    if stop_after_phase_5(sess) { return; }\n-    phase_6_link_output(sess, &trans, &outputs);\n+    phase_5_run_llvm_passes(&sess, &trans, &outputs);\n+    if stop_after_phase_5(&sess) { return; }\n+    phase_6_link_output(&sess, &trans, &outputs);\n }\n \n struct IdentifiedAnnotation;\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n-    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n+    fn pre(&self,\n+           s: &mut pprust::State<IdentifiedAnnotation>,\n+           node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n-            pprust::NodeExpr(s, _) => pprust::popen(s),\n+            pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n-    fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n+    fn post(&self,\n+            s: &mut pprust::State<IdentifiedAnnotation>,\n+            node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n-            pprust::NodeItem(s, item) => {\n+            pprust::NodeItem(item) => {\n                 try!(pp::space(&mut s.s));\n-                try!(pprust::synth_comment(s, item.id.to_str()));\n+                s.synth_comment(item.id.to_str())\n             }\n-            pprust::NodeBlock(s, blk) => {\n+            pprust::NodeBlock(blk) => {\n                 try!(pp::space(&mut s.s));\n-                try!(pprust::synth_comment(s, ~\"block \" + blk.id.to_str()));\n+                s.synth_comment(~\"block \" + blk.id.to_str())\n             }\n-            pprust::NodeExpr(s, expr) => {\n+            pprust::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n-                try!(pprust::synth_comment(s, expr.id.to_str()));\n-                try!(pprust::pclose(s));\n+                try!(s.synth_comment(expr.id.to_str()));\n+                s.pclose()\n             }\n-            pprust::NodePat(s, pat) => {\n+            pprust::NodePat(pat) => {\n                 try!(pp::space(&mut s.s));\n-                try!(pprust::synth_comment(s, ~\"pat \" + pat.id.to_str()));\n+                s.synth_comment(~\"pat \" + pat.id.to_str())\n             }\n         }\n-        Ok(())\n     }\n }\n \n@@ -633,71 +633,91 @@ struct TypedAnnotation {\n }\n \n impl pprust::PpAnn for TypedAnnotation {\n-    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n+    fn pre(&self,\n+           s: &mut pprust::State<TypedAnnotation>,\n+           node: pprust::AnnNode) -> io::IoResult<()> {\n         match node {\n-            pprust::NodeExpr(s, _) => pprust::popen(s),\n+            pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n-    fn post(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n-        let tcx = self.analysis.ty_cx;\n+    fn post(&self,\n+            s: &mut pprust::State<TypedAnnotation>,\n+            node: pprust::AnnNode) -> io::IoResult<()> {\n+        let tcx = &self.analysis.ty_cx;\n         match node {\n-            pprust::NodeExpr(s, expr) => {\n+            pprust::NodeExpr(expr) => {\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n                                 ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr))));\n-                try!(pprust::pclose(s));\n+                s.pclose()\n             }\n-            _ => ()\n+            _ => Ok(())\n         }\n-        Ok(())\n     }\n }\n \n pub fn pretty_print_input(sess: Session,\n                           cfg: ast::CrateConfig,\n                           input: &Input,\n                           ppm: PpMode) {\n-    let krate = phase_1_parse_input(sess, cfg, input);\n+    let krate = phase_1_parse_input(&sess, cfg, input);\n     let id = link::find_crate_id(krate.attrs.as_slice(), input.filestem());\n \n     let (krate, ast_map, is_expanded) = match ppm {\n         PpmExpanded | PpmExpandedIdentified | PpmTyped => {\n-            let loader = &mut Loader::new(sess);\n-            let (krate, ast_map) = phase_2_configure_and_expand(sess, loader,\n+            let loader = &mut Loader::new(&sess);\n+            let (krate, ast_map) = phase_2_configure_and_expand(&sess, loader,\n                                                                 krate, &id);\n             (krate, Some(ast_map), true)\n         }\n         _ => (krate, None, false)\n     };\n \n-    let annotation = match ppm {\n+    let src_name = source_name(input);\n+    let src = sess.codemap().get_filemap(src_name).deref().src.as_bytes().to_owned();\n+    let mut rdr = MemReader::new(src);\n+\n+    match ppm {\n         PpmIdentified | PpmExpandedIdentified => {\n-            ~IdentifiedAnnotation as ~pprust::PpAnn\n+            pprust::print_crate(sess.codemap(),\n+                                sess.diagnostic(),\n+                                &krate,\n+                                src_name,\n+                                &mut rdr,\n+                                ~io::stdout(),\n+                                &IdentifiedAnnotation,\n+                                is_expanded)\n         }\n         PpmTyped => {\n             let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n             let analysis = phase_3_run_analysis_passes(sess, &krate, ast_map);\n-            ~TypedAnnotation {\n+            let annotation = TypedAnnotation {\n                 analysis: analysis\n-            } as ~pprust::PpAnn:\n+            };\n+            pprust::print_crate(annotation.analysis.ty_cx.sess.codemap(),\n+                                annotation.analysis.ty_cx.sess.diagnostic(),\n+                                &krate,\n+                                src_name,\n+                                &mut rdr,\n+                                ~io::stdout(),\n+                                &annotation,\n+                                is_expanded)\n         }\n-        _ => ~pprust::NoAnn as ~pprust::PpAnn:,\n-    };\n+        _ => {\n+            pprust::print_crate(sess.codemap(),\n+                                sess.diagnostic(),\n+                                &krate,\n+                                src_name,\n+                                &mut rdr,\n+                                ~io::stdout(),\n+                                &pprust::NoAnn,\n+                                is_expanded)\n+        }\n+    }.unwrap()\n \n-    let src = &sess.codemap.get_filemap(source_name(input)).src;\n-    let mut rdr = MemReader::new(src.as_bytes().to_owned());\n-    let stdout = io::stdout();\n-    pprust::print_crate(sess.codemap,\n-                        sess.span_diagnostic,\n-                        &krate,\n-                        source_name(input),\n-                        &mut rdr,\n-                        ~stdout as ~io::Writer,\n-                        annotation,\n-                        is_expanded).unwrap();\n }\n \n pub fn get_os(triple: &str) -> Option<abi::Os> {\n@@ -735,8 +755,7 @@ static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'stat\n \n     (\"mips\",   abi::Mips)];\n \n-pub fn build_target_config(sopts: @session::Options)\n-                           -> @session::Config {\n+pub fn build_target_config(sopts: &session::Options) -> session::Config {\n     let os = match get_os(sopts.target_triple) {\n       Some(os) => os,\n       None => early_error(\"unknown operating system\")\n@@ -758,14 +777,13 @@ pub fn build_target_config(sopts: @session::Options)\n       abi::Arm => arm::get_target_strs(target_triple, os),\n       abi::Mips => mips::get_target_strs(target_triple, os)\n     };\n-    let target_cfg = @session::Config {\n+    session::Config {\n         os: os,\n         arch: arch,\n         target_strs: target_strs,\n         int_type: int_type,\n         uint_type: uint_type,\n-    };\n-    return target_cfg;\n+    }\n }\n \n pub fn host_triple() -> ~str {\n@@ -780,8 +798,7 @@ pub fn host_triple() -> ~str {\n     (env!(\"CFG_COMPILER\")).to_owned()\n }\n \n-pub fn build_session_options(matches: &getopts::Matches)\n-                             -> @session::Options {\n+pub fn build_session_options(matches: &getopts::Matches) -> session::Options {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     for unparsed_crate_type in unparsed_crate_types.iter() {\n@@ -871,7 +888,7 @@ pub fn build_session_options(matches: &getopts::Matches)\n         output_types.push(link::OutputTypeExe);\n     }\n \n-    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| @Path::new(m));\n+    let sysroot_opt = matches.opt_str(\"sysroot\").map(|m| Path::new(m));\n     let target = matches.opt_str(\"target\").unwrap_or(host_triple());\n     let opt_level = {\n         if (debugging_opts & session::NO_OPT) != 0 {\n@@ -932,14 +949,14 @@ pub fn build_session_options(matches: &getopts::Matches)\n                        matches.opt_present(\"crate-file-name\"));\n     let cg = build_codegen_options(matches);\n \n-    let sopts = @session::Options {\n+    session::Options {\n         crate_types: crate_types,\n         gc: gc,\n         optimize: opt_level,\n         debuginfo: debuginfo,\n         lint_opts: lint_opts,\n         output_types: output_types,\n-        addl_lib_search_paths: @RefCell::new(addl_lib_search_paths),\n+        addl_lib_search_paths: RefCell::new(addl_lib_search_paths),\n         maybe_sysroot: sysroot_opt,\n         target_triple: target,\n         cfg: cfg,\n@@ -951,8 +968,7 @@ pub fn build_session_options(matches: &getopts::Matches)\n         write_dependency_info: write_dependency_info,\n         print_metas: print_metas,\n         cg: cg,\n-    };\n-    return sopts;\n+    }\n }\n \n pub fn build_codegen_options(matches: &getopts::Matches)\n@@ -986,30 +1002,28 @@ pub fn build_codegen_options(matches: &getopts::Matches)\n     return cg;\n }\n \n-pub fn build_session(sopts: @session::Options,\n+pub fn build_session(sopts: session::Options,\n                      local_crate_source_file: Option<Path>)\n                      -> Session {\n-    let codemap = @codemap::CodeMap::new();\n+    let codemap = codemap::CodeMap::new();\n     let diagnostic_handler =\n         diagnostic::default_handler();\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    build_session_(sopts, local_crate_source_file, codemap, span_diagnostic_handler)\n+    build_session_(sopts, local_crate_source_file, span_diagnostic_handler)\n }\n \n-pub fn build_session_(sopts: @session::Options,\n+pub fn build_session_(sopts: session::Options,\n                       local_crate_source_file: Option<Path>,\n-                      codemap: @codemap::CodeMap,\n-                      span_diagnostic_handler: @diagnostic::SpanHandler)\n+                      span_diagnostic: diagnostic::SpanHandler)\n                       -> Session {\n-    let target_cfg = build_target_config(sopts);\n-    let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler, codemap);\n-    let cstore = @CStore::new(token::get_ident_interner());\n-    let filesearch = @filesearch::FileSearch::new(\n-        &sopts.maybe_sysroot,\n-        sopts.target_triple,\n-        sopts.addl_lib_search_paths);\n+    let target_cfg = build_target_config(&sopts);\n+    let p_s = parse::new_parse_sess_special_handler(span_diagnostic);\n+    let default_sysroot = match sopts.maybe_sysroot {\n+        Some(_) => None,\n+        None => Some(filesearch::get_or_default_sysroot())\n+    };\n \n     // Make the path absolute, if necessary\n     let local_crate_source_file = local_crate_source_file.map(|path|\n@@ -1020,30 +1034,28 @@ pub fn build_session_(sopts: @session::Options,\n         }\n     );\n \n-    @Session_ {\n+    Session {\n         targ_cfg: target_cfg,\n         opts: sopts,\n-        cstore: cstore,\n+        cstore: CStore::new(token::get_ident_interner()),\n         parse_sess: p_s,\n-        codemap: codemap,\n         // For a library crate, this is always none\n         entry_fn: RefCell::new(None),\n         entry_type: Cell::new(None),\n         macro_registrar_fn: RefCell::new(None),\n-        span_diagnostic: span_diagnostic_handler,\n-        filesearch: filesearch,\n+        default_sysroot: default_sysroot,\n         building_library: Cell::new(false),\n         local_crate_source_file: local_crate_source_file,\n         working_dir: os::getcwd(),\n-        lints: RefCell::new(HashMap::new()),\n+        lints: RefCell::new(NodeMap::new()),\n         node_id: Cell::new(1),\n-        crate_types: @RefCell::new(Vec::new()),\n+        crate_types: RefCell::new(Vec::new()),\n         features: front::feature_gate::Features::new(),\n         recursion_limit: Cell::new(64),\n     }\n }\n \n-pub fn parse_pretty(sess: Session, name: &str) -> PpMode {\n+pub fn parse_pretty(sess: &Session, name: &str) -> PpMode {\n     match name {\n       &\"normal\" => PpmNormal,\n       &\"expanded\" => PpmExpanded,\n@@ -1143,7 +1155,7 @@ pub fn build_output_filenames(input: &Input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n                               attrs: &[ast::Attribute],\n-                              sess: Session)\n+                              sess: &Session)\n                            -> OutputFilenames {\n     match *ofile {\n         None => {\n@@ -1196,7 +1208,7 @@ pub fn early_error(msg: &str) -> ! {\n     fail!(diagnostic::FatalError);\n }\n \n-pub fn list_metadata(sess: Session, path: &Path,\n+pub fn list_metadata(sess: &Session, path: &Path,\n                      out: &mut io::Writer) -> io::IoResult<()> {\n     metadata::loader::list_file_metadata(\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out)\n@@ -1222,7 +1234,7 @@ mod test {\n             };\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None);\n-        let cfg = build_configuration(sess);\n+        let cfg = build_configuration(&sess);\n         assert!((attr::contains_name(cfg.as_slice(), \"test\")));\n     }\n \n@@ -1241,7 +1253,7 @@ mod test {\n             };\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None);\n-        let cfg = build_configuration(sess);\n+        let cfg = build_configuration(&sess);\n         let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());"}, {"sha": "8d3048a80b29f6cfc3365ee5611c464b5df605d2", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 49, "deletions": 39, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -16,6 +16,7 @@ use front;\n use metadata::filesearch;\n use metadata;\n use middle::lint;\n+use util::nodemap::NodeMap;\n \n use syntax::attr::AttrMetaMethods;\n use syntax::ast::NodeId;\n@@ -28,7 +29,7 @@ use syntax;\n \n use std::cell::{Cell, RefCell};\n use std::vec_ng::Vec;\n-use collections::{HashMap,HashSet};\n+use collections::HashSet;\n \n pub struct Config {\n     os: abi::Os,\n@@ -134,8 +135,8 @@ pub struct Options {\n     // This was mutable for rustpkg, which updates search paths based on the\n     // parsed code. It remains mutable in case its replacements wants to use\n     // this.\n-    addl_lib_search_paths: @RefCell<HashSet<Path>>,\n-    maybe_sysroot: Option<@Path>,\n+    addl_lib_search_paths: RefCell<HashSet<Path>>,\n+    maybe_sysroot: Option<Path>,\n     target_triple: ~str,\n     // User-specified cfg meta items. The compiler itself will add additional\n     // items to the crate config, and during parsing the entire crate config\n@@ -173,84 +174,79 @@ pub enum CrateType {\n     CrateTypeStaticlib,\n }\n \n-pub struct Session_ {\n-    targ_cfg: @Config,\n-    opts: @Options,\n-    cstore: @metadata::cstore::CStore,\n-    parse_sess: @ParseSess,\n-    codemap: @codemap::CodeMap,\n+pub struct Session {\n+    targ_cfg: Config,\n+    opts: Options,\n+    cstore: metadata::cstore::CStore,\n+    parse_sess: ParseSess,\n     // For a library crate, this is always none\n     entry_fn: RefCell<Option<(NodeId, codemap::Span)>>,\n     entry_type: Cell<Option<EntryFnType>>,\n-    span_diagnostic: @diagnostic::SpanHandler,\n     macro_registrar_fn: RefCell<Option<ast::DefId>>,\n-    filesearch: @filesearch::FileSearch,\n+    default_sysroot: Option<Path>,\n     building_library: Cell<bool>,\n     // The name of the root source file of the crate, in the local file system. The path is always\n     // expected to be absolute. `None` means that there is no source file.\n     local_crate_source_file: Option<Path>,\n     working_dir: Path,\n-    lints: RefCell<HashMap<ast::NodeId,\n-                           Vec<(lint::Lint, codemap::Span, ~str)> >>,\n+    lints: RefCell<NodeMap<Vec<(lint::Lint, codemap::Span, ~str)>>>,\n     node_id: Cell<ast::NodeId>,\n-    crate_types: @RefCell<Vec<CrateType> >,\n+    crate_types: RefCell<Vec<CrateType>>,\n     features: front::feature_gate::Features,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n     recursion_limit: Cell<uint>,\n }\n \n-pub type Session = @Session_;\n-\n-impl Session_ {\n+impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n-        self.span_diagnostic.span_fatal(sp, msg)\n+        self.diagnostic().span_fatal(sp, msg)\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n-        self.span_diagnostic.handler().fatal(msg)\n+        self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_err(sp, msg)\n+        self.diagnostic().span_err(sp, msg)\n     }\n     pub fn err(&self, msg: &str) {\n-        self.span_diagnostic.handler().err(msg)\n+        self.diagnostic().handler().err(msg)\n     }\n     pub fn err_count(&self) -> uint {\n-        self.span_diagnostic.handler().err_count()\n+        self.diagnostic().handler().err_count()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.span_diagnostic.handler().has_errors()\n+        self.diagnostic().handler().has_errors()\n     }\n     pub fn abort_if_errors(&self) {\n-        self.span_diagnostic.handler().abort_if_errors()\n+        self.diagnostic().handler().abort_if_errors()\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_warn(sp, msg)\n+        self.diagnostic().span_warn(sp, msg)\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.span_diagnostic.handler().warn(msg)\n+        self.diagnostic().handler().warn(msg)\n     }\n     pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_note(sp, msg)\n+        self.diagnostic().span_note(sp, msg)\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.span_diagnostic.span_end_note(sp, msg)\n+        self.diagnostic().span_end_note(sp, msg)\n     }\n     pub fn note(&self, msg: &str) {\n-        self.span_diagnostic.handler().note(msg)\n+        self.diagnostic().handler().note(msg)\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.span_diagnostic.span_bug(sp, msg)\n+        self.diagnostic().span_bug(sp, msg)\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.span_diagnostic.handler().bug(msg)\n+        self.diagnostic().handler().bug(msg)\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_diagnostic.span_unimpl(sp, msg)\n+        self.diagnostic().span_unimpl(sp, msg)\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.span_diagnostic.handler().unimpl(msg)\n+        self.diagnostic().handler().unimpl(msg)\n     }\n     pub fn add_lint(&self,\n                     lint: lint::Lint,\n@@ -277,12 +273,15 @@ impl Session_ {\n \n         v\n     }\n-    pub fn diagnostic(&self) -> @diagnostic::SpanHandler {\n-        self.span_diagnostic\n+    pub fn diagnostic<'a>(&'a self) -> &'a diagnostic::SpanHandler {\n+        &self.parse_sess.span_diagnostic\n     }\n     pub fn debugging_opt(&self, opt: u64) -> bool {\n         (self.opts.debugging_opts & opt) != 0\n     }\n+    pub fn codemap<'a>(&'a self) -> &'a codemap::CodeMap {\n+        &self.parse_sess.span_diagnostic.cm\n+    }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n@@ -316,18 +315,29 @@ impl Session_ {\n     pub fn show_span(&self) -> bool {\n         self.debugging_opt(SHOW_SPAN)\n     }\n+    pub fn filesearch<'a>(&'a self) -> filesearch::FileSearch<'a> {\n+        let sysroot = match self.opts.maybe_sysroot {\n+            Some(ref sysroot) => sysroot,\n+            None => self.default_sysroot.as_ref()\n+                        .expect(\"missing sysroot and default_sysroot in Session\")\n+        };\n+        filesearch::FileSearch::new(\n+            sysroot,\n+            self.opts.target_triple,\n+            &self.opts.addl_lib_search_paths)\n+    }\n }\n \n /// Some reasonable defaults\n-pub fn basic_options() -> @Options {\n-    @Options {\n+pub fn basic_options() -> Options {\n+    Options {\n         crate_types: Vec::new(),\n         gc: false,\n         optimize: No,\n         debuginfo: NoDebugInfo,\n         lint_opts: Vec::new(),\n         output_types: Vec::new(),\n-        addl_lib_search_paths: @RefCell::new(HashSet::new()),\n+        addl_lib_search_paths: RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n         cfg: Vec::new(),\n@@ -451,7 +461,7 @@ cgoptions!(\n )\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Clone>(sess: Session, opt: Option<T>, msg: || -> ~str) -> T {\n+pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> ~str) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n "}, {"sha": "f7c919131a80939eb1a1e8bb78184b6d18c2f98e", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -13,17 +13,17 @@ use driver::session::Session;\n use syntax::ast;\n use syntax::ast_map;\n \n-struct NodeIdAssigner {\n-    sess: Session\n+struct NodeIdAssigner<'a> {\n+    sess: &'a Session\n }\n \n-impl ast_map::FoldOps for NodeIdAssigner {\n+impl<'a> ast_map::FoldOps for NodeIdAssigner<'a> {\n     fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n         assert_eq!(old_id, ast::DUMMY_NODE_ID);\n         self.sess.next_node_id()\n     }\n }\n \n-pub fn assign_node_ids_and_map(sess: Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n+pub fn assign_node_ids_and_map(sess: &Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n     ast_map::map_crate(krate, NodeIdAssigner { sess: sess })\n }"}, {"sha": "99de2060eeecf295218d13d953eb1169951bf4aa", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -86,12 +86,12 @@ impl Features {\n     }\n }\n \n-struct Context {\n-    features: Vec<&'static str> ,\n-    sess: Session,\n+struct Context<'a> {\n+    features: Vec<&'static str>,\n+    sess: &'a Session,\n }\n \n-impl Context {\n+impl<'a> Context<'a> {\n     fn gate_feature(&self, feature: &str, span: Span, explain: &str) {\n         if !self.has_feature(feature) {\n             self.sess.span_err(span, explain);\n@@ -114,7 +114,7 @@ impl Context {\n     }\n }\n \n-impl Visitor<()> for Context {\n+impl<'a> Visitor<()> for Context<'a> {\n     fn visit_ident(&mut self, sp: Span, id: ast::Ident, _: ()) {\n         if !token::get_ident(id).get().is_ascii() {\n             self.gate_feature(\"non_ascii_idents\", sp,\n@@ -293,7 +293,7 @@ impl Visitor<()> for Context {\n     }\n }\n \n-pub fn check_crate(sess: Session, krate: &ast::Crate) {\n+pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n     let mut cx = Context {\n         features: Vec::new(),\n         sess: sess,"}, {"sha": "36db4e422c11d2bc679e490d5102f5e615d7696d", "filename": "src/librustc/front/show_span.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fshow_span.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -19,18 +19,18 @@ use syntax::visit::Visitor;\n \n use driver::session::Session;\n \n-struct ShowSpanVisitor {\n-    sess: Session\n+struct ShowSpanVisitor<'a> {\n+    sess: &'a Session\n }\n \n-impl Visitor<()> for ShowSpanVisitor {\n+impl<'a> Visitor<()> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr, _: ()) {\n         self.sess.span_note(e.span, \"expression\");\n         visit::walk_expr(self, e, ());\n     }\n }\n \n-pub fn run(sess: Session, krate: &ast::Crate) {\n+pub fn run(sess: &Session, krate: &ast::Crate) {\n     let mut v = ShowSpanVisitor { sess: sess };\n     visit::walk_crate(&mut v, krate, ());\n }"}, {"sha": "407476461673f3aa0eea74b1e58cb9a3e0b66078", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -26,7 +26,7 @@ use syntax::util::small_vector::SmallVector;\n \n pub static VERSION: &'static str = \"0.10-pre\";\n \n-pub fn maybe_inject_crates_ref(sess: Session, krate: ast::Crate)\n+pub fn maybe_inject_crates_ref(sess: &Session, krate: ast::Crate)\n                                -> ast::Crate {\n     if use_std(&krate) {\n         inject_crates_ref(sess, krate)\n@@ -35,7 +35,7 @@ pub fn maybe_inject_crates_ref(sess: Session, krate: ast::Crate)\n     }\n }\n \n-pub fn maybe_inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n+pub fn maybe_inject_prelude(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     if use_std(&krate) {\n         inject_prelude(sess, krate)\n     } else {\n@@ -55,8 +55,8 @@ fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"no_implicit_prelude\")\n }\n \n-struct StandardLibraryInjector {\n-    sess: Session,\n+struct StandardLibraryInjector<'a> {\n+    sess: &'a Session,\n }\n \n pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n@@ -71,7 +71,7 @@ pub fn with_version(krate: &str) -> Option<(InternedString, ast::StrStyle)> {\n     }\n }\n \n-impl fold::Folder for StandardLibraryInjector {\n+impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n         let mut vis = vec!(ast::ViewItem {\n             node: ast::ViewItemExternCrate(token::str_to_ident(\"std\"),\n@@ -120,19 +120,19 @@ impl fold::Folder for StandardLibraryInjector {\n     }\n }\n \n-fn inject_crates_ref(sess: Session, krate: ast::Crate) -> ast::Crate {\n+fn inject_crates_ref(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     let mut fold = StandardLibraryInjector {\n         sess: sess,\n     };\n     fold.fold_crate(krate)\n }\n \n-struct PreludeInjector {\n-    sess: Session,\n+struct PreludeInjector<'a> {\n+    sess: &'a Session,\n }\n \n \n-impl fold::Folder for PreludeInjector {\n+impl<'a> fold::Folder for PreludeInjector<'a> {\n     fn fold_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n         if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n@@ -193,7 +193,7 @@ impl fold::Folder for PreludeInjector {\n     }\n }\n \n-fn inject_prelude(sess: Session, krate: ast::Crate) -> ast::Crate {\n+fn inject_prelude(sess: &Session, krate: ast::Crate) -> ast::Crate {\n     let mut fold = PreludeInjector {\n         sess: sess,\n     };"}, {"sha": "cf5373fd17de7918a308eb5f0222569dc17de2ea", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -13,7 +13,7 @@\n #[allow(dead_code)];\n #[allow(unused_imports)];\n \n-use driver::session;\n+use driver::session::Session;\n use front::config;\n use front::std_inject::with_version;\n use metadata::creader::Loader;\n@@ -47,8 +47,8 @@ struct Test {\n }\n \n struct TestCtxt<'a> {\n-    sess: session::Session,\n-    path: RefCell<Vec<ast::Ident> >,\n+    sess: &'a Session,\n+    path: RefCell<Vec<ast::Ident>>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: RefCell<Vec<Test> >,\n     is_test_crate: bool,\n@@ -57,7 +57,7 @@ struct TestCtxt<'a> {\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn modify_for_testing(sess: session::Session,\n+pub fn modify_for_testing(sess: &Session,\n                           krate: ast::Crate) -> ast::Crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n@@ -161,12 +161,12 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     }\n }\n \n-fn generate_test_harness(sess: session::Session, krate: ast::Crate)\n+fn generate_test_harness(sess: &Session, krate: ast::Crate)\n                          -> ast::Crate {\n     let loader = &mut Loader::new(sess);\n     let mut cx: TestCtxt = TestCtxt {\n         sess: sess,\n-        ext_cx: ExtCtxt::new(sess.parse_sess, sess.opts.cfg.clone(),\n+        ext_cx: ExtCtxt::new(&sess.parse_sess, sess.opts.cfg.clone(),\n                              ExpansionConfig {\n                                  loader: loader,\n                                  deriving_hash_type_parameter: false,"}, {"sha": "9409d8c457fb4ee96f1c8e65eae978359c3f4015", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -290,36 +290,36 @@ pub fn run_compiler(args: &[~str]) {\n     let sess = d::build_session(sopts, input_file_path);\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n-    let cfg = d::build_configuration(sess);\n+    let cfg = d::build_configuration(&sess);\n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        d::parse_pretty(sess, a)\n+        d::parse_pretty(&sess, a)\n     });\n     match pretty {\n-      Some::<d::PpMode>(ppm) => {\n-        d::pretty_print_input(sess, cfg, &input, ppm);\n-        return;\n-      }\n-      None::<d::PpMode> => {/* continue */ }\n+        Some::<d::PpMode>(ppm) => {\n+            d::pretty_print_input(sess, cfg, &input, ppm);\n+            return;\n+        }\n+        None::<d::PpMode> => {/* continue */ }\n     }\n     let ls = matches.opt_present(\"ls\");\n     if ls {\n         match input {\n-          d::FileInput(ref ifile) => {\n-            let mut stdout = io::stdout();\n-            d::list_metadata(sess, &(*ifile), &mut stdout).unwrap();\n-          }\n-          d::StrInput(_) => {\n-            d::early_error(\"can not list metadata for stdin\");\n-          }\n+            d::FileInput(ref ifile) => {\n+                let mut stdout = io::stdout();\n+                d::list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n+            }\n+            d::StrInput(_) => {\n+                d::early_error(\"can not list metadata for stdin\");\n+            }\n         }\n         return;\n     }\n-    let (crate_id, crate_name, crate_file_name) = sopts.print_metas;\n+    let (crate_id, crate_name, crate_file_name) = sess.opts.print_metas;\n     // these nasty nested conditions are to avoid doing extra work\n     if crate_id || crate_name || crate_file_name {\n-        let attrs = parse_crate_attrs(sess, &input);\n+        let attrs = parse_crate_attrs(&sess, &input);\n         let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n-                                                  attrs.as_slice(), sess);\n+                                                  attrs.as_slice(), &sess);\n         let id = link::find_crate_id(attrs.as_slice(), t_outputs.out_filestem);\n \n         if crate_id {\n@@ -344,19 +344,19 @@ pub fn run_compiler(args: &[~str]) {\n     d::compile_input(sess, cfg, &input, &odir, &ofile);\n }\n \n-fn parse_crate_attrs(sess: session::Session, input: &d::Input) ->\n+fn parse_crate_attrs(sess: &session::Session, input: &d::Input) ->\n                      Vec<ast::Attribute> {\n     let result = match *input {\n         d::FileInput(ref ifile) => {\n             parse::parse_crate_attrs_from_file(ifile,\n                                                Vec::new(),\n-                                               sess.parse_sess)\n+                                               &sess.parse_sess)\n         }\n         d::StrInput(ref src) => {\n             parse::parse_crate_attrs_from_source_str(d::anon_src(),\n                                                      (*src).clone(),\n                                                      Vec::new(),\n-                                                     sess.parse_sess)\n+                                                     &sess.parse_sess)\n         }\n     };\n     result.move_iter().collect()"}, {"sha": "74e180072faa49bb28ee13c8390c02c522752c59", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -39,7 +39,7 @@ use syntax::visit;\n \n // Traverses an AST, reading all the information about use'd crates and extern\n // libraries necessary for later resolving, typechecking, linking, etc.\n-pub fn read_crates(sess: Session,\n+pub fn read_crates(sess: &Session,\n                    krate: &ast::Crate,\n                    os: loader::Os,\n                    intr: @IdentInterner) {\n@@ -51,30 +51,21 @@ pub fn read_crates(sess: Session,\n         intr: intr\n     };\n     visit_crate(&e, krate);\n-    {\n-        let mut v = ReadCrateVisitor {\n-            e: &mut e\n-        };\n-        visit::walk_crate(&mut v, krate, ());\n-    }\n+    visit::walk_crate(&mut e, krate, ());\n     let crate_cache = e.crate_cache.borrow();\n     dump_crates(crate_cache.get().as_slice());\n     warn_if_multiple_versions(&mut e,\n                               sess.diagnostic(),\n                               crate_cache.get().as_slice());\n }\n \n-struct ReadCrateVisitor<'a> {\n-    e: &'a mut Env,\n-}\n-\n-impl<'a> visit::Visitor<()> for ReadCrateVisitor<'a> {\n+impl<'a> visit::Visitor<()> for Env<'a> {\n     fn visit_view_item(&mut self, a: &ast::ViewItem, _: ()) {\n-        visit_view_item(self.e, a);\n+        visit_view_item(self, a);\n         visit::walk_view_item(self, a, ());\n     }\n     fn visit_item(&mut self, a: &ast::Item, _: ()) {\n-        visit_item(self.e, a);\n+        visit_item(self, a);\n         visit::walk_item(self, a, ());\n     }\n }\n@@ -97,7 +88,7 @@ fn dump_crates(crate_cache: &[cache_entry]) {\n }\n \n fn warn_if_multiple_versions(e: &mut Env,\n-                             diag: @SpanHandler,\n+                             diag: &SpanHandler,\n                              crate_cache: &[cache_entry]) {\n     if crate_cache.len() != 0u {\n         let name = crate_cache[crate_cache.len() - 1].crate_id.name.clone();\n@@ -120,21 +111,19 @@ fn warn_if_multiple_versions(e: &mut Env,\n     }\n }\n \n-struct Env {\n-    sess: Session,\n+struct Env<'a> {\n+    sess: &'a Session,\n     os: loader::Os,\n     crate_cache: @RefCell<Vec<cache_entry>>,\n     next_crate_num: ast::CrateNum,\n     intr: @IdentInterner\n }\n \n fn visit_crate(e: &Env, c: &ast::Crate) {\n-    let cstore = e.sess.cstore;\n-\n     for a in c.attrs.iter().filter(|m| m.name().equiv(&(\"link_args\"))) {\n         match a.value_str() {\n-          Some(ref linkarg) => cstore.add_used_link_args(linkarg.get()),\n-          None => { /* fallthrough */ }\n+            Some(ref linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n+            None => { /* fallthrough */ }\n         }\n     }\n }\n@@ -204,7 +193,6 @@ fn visit_item(e: &Env, i: &ast::Item) {\n             }\n \n             // First, add all of the custom link_args attributes\n-            let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n                 .filter_map(|at| if at.name().equiv(&(\"link_args\")) {\n                     Some(at)\n@@ -214,13 +202,12 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                 .to_owned_vec();\n             for m in link_args.iter() {\n                 match m.value_str() {\n-                    Some(linkarg) => cstore.add_used_link_args(linkarg.get()),\n+                    Some(linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n                     None => { /* fallthrough */ }\n                 }\n             }\n \n             // Next, process all of the #[link(..)]-style arguments\n-            let cstore = e.sess.cstore;\n             let link_args = i.attrs.iter()\n                 .filter_map(|at| if at.name().equiv(&(\"link\")) {\n                     Some(at)\n@@ -269,7 +256,7 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                         if n.get().is_empty() {\n                             e.sess.span_err(m.span, \"#[link(name = \\\"\\\")] given with empty name\");\n                         } else {\n-                            cstore.add_used_library(n.get().to_owned(), kind);\n+                            e.sess.cstore.add_used_library(n.get().to_owned(), kind);\n                         }\n                     }\n                     None => {}\n@@ -353,18 +340,15 @@ fn resolve_crate(e: &mut Env,\n                 cnum: cnum\n             };\n \n-            let cstore = e.sess.cstore;\n-            cstore.set_crate_data(cnum, cmeta);\n-            cstore.add_used_crate_source(cstore::CrateSource {\n+            e.sess.cstore.set_crate_data(cnum, cmeta);\n+            e.sess.cstore.add_used_crate_source(cstore::CrateSource {\n                 dylib: dylib,\n                 rlib: rlib,\n                 cnum: cnum,\n             });\n-            return cnum;\n-        }\n-        Some(cnum) => {\n-            return cnum;\n+            cnum\n         }\n+        Some(cnum) => cnum\n     }\n }\n \n@@ -391,12 +375,12 @@ fn resolve_crate_deps(e: &mut Env,\n     return @RefCell::new(cnum_map);\n }\n \n-pub struct Loader {\n-    priv env: Env,\n+pub struct Loader<'a> {\n+    priv env: Env<'a>,\n }\n \n-impl Loader {\n-    pub fn new(sess: Session) -> Loader {\n+impl<'a> Loader<'a> {\n+    pub fn new(sess: &'a Session) -> Loader<'a> {\n         let os = driver::get_os(driver::host_triple()).unwrap();\n         let os = session::sess_os_to_meta_os(os);\n         Loader {\n@@ -411,7 +395,7 @@ impl Loader {\n     }\n }\n \n-impl CrateLoader for Loader {\n+impl<'a> CrateLoader for Loader<'a> {\n     fn load_crate(&mut self, krate: &ast::ViewItem) -> MacroCrate {\n         let info = extract_crate_info(&self.env, krate).unwrap();\n         let cnum = resolve_crate(&mut self.env, None, info.ident,\n@@ -424,12 +408,12 @@ impl CrateLoader for Loader {\n     }\n \n     fn get_exported_macros(&mut self, cnum: ast::CrateNum) -> Vec<~str> {\n-        csearch::get_exported_macros(self.env.sess.cstore, cnum).move_iter()\n-                                                                .collect()\n+        csearch::get_exported_macros(&self.env.sess.cstore, cnum).move_iter()\n+                                                                 .collect()\n     }\n \n     fn get_registrar_symbol(&mut self, cnum: ast::CrateNum) -> Option<~str> {\n-        let cstore = self.env.sess.cstore;\n+        let cstore = &self.env.sess.cstore;\n         csearch::get_macro_registrar_fn(cstore, cnum)\n             .map(|did| csearch::get_symbol(cstore, did))\n     }"}, {"sha": "d41d01f3c85cba4feef522fb6e6ac60818b9cb56", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -34,19 +34,19 @@ pub struct StaticMethodInfo {\n     vis: ast::Visibility,\n }\n \n-pub fn get_symbol(cstore: @cstore::CStore, def: ast::DefId) -> ~str {\n+pub fn get_symbol(cstore: &cstore::CStore, def: ast::DefId) -> ~str {\n     let cdata = cstore.get_crate_data(def.krate).data();\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-pub fn get_type_param_count(cstore: @cstore::CStore, def: ast::DefId)\n+pub fn get_type_param_count(cstore: &cstore::CStore, def: ast::DefId)\n                          -> uint {\n     let cdata = cstore.get_crate_data(def.krate).data();\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n /// Iterates over all the language items in the given crate.\n-pub fn each_lang_item(cstore: @cstore::CStore,\n+pub fn each_lang_item(cstore: &cstore::CStore,\n                       cnum: ast::CrateNum,\n                       f: |ast::NodeId, uint| -> bool)\n                       -> bool {\n@@ -55,7 +55,7 @@ pub fn each_lang_item(cstore: @cstore::CStore,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item(cstore: @cstore::CStore,\n+pub fn each_child_of_item(cstore: &cstore::CStore,\n                           def_id: ast::DefId,\n                           callback: |decoder::DefLike,\n                                      ast::Ident,\n@@ -72,7 +72,7 @@ pub fn each_child_of_item(cstore: @cstore::CStore,\n }\n \n /// Iterates over each top-level crate item.\n-pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n+pub fn each_top_level_item_of_crate(cstore: &cstore::CStore,\n                                     cnum: ast::CrateNum,\n                                     callback: |decoder::DefLike,\n                                                ast::Ident,\n@@ -87,8 +87,8 @@ pub fn each_top_level_item_of_crate(cstore: @cstore::CStore,\n                                           callback)\n }\n \n-pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n-    let cstore = tcx.cstore;\n+pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     let path = decoder::get_item_path(cdata, def.node);\n \n@@ -107,118 +107,118 @@ pub enum found_ast {\n // Finds the AST for this item in the crate metadata, if any.  If the item was\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n-pub fn maybe_get_item_ast(tcx: ty::ctxt, def: ast::DefId,\n+pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n                           decode_inlined_item: decoder::DecodeInlinedItem)\n                        -> found_ast {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::maybe_get_item_ast(cdata, tcx, def.node, decode_inlined_item)\n }\n \n-pub fn get_enum_variants(tcx: ty::ctxt, def: ast::DefId)\n+pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n                       -> Vec<@ty::VariantInfo> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n-pub fn get_impl(tcx: ty::ctxt, impl_def_id: ast::DefId)\n+pub fn get_impl(tcx: &ty::ctxt, impl_def_id: ast::DefId)\n                 -> ty::Impl {\n-    let cdata = tcx.cstore.get_crate_data(impl_def_id.krate);\n-    decoder::get_impl(tcx.cstore.intr, cdata, impl_def_id.node, tcx)\n+    let cdata = tcx.sess.cstore.get_crate_data(impl_def_id.krate);\n+    decoder::get_impl(tcx.sess.cstore.intr, cdata, impl_def_id.node, tcx)\n }\n \n-pub fn get_method(tcx: ty::ctxt, def: ast::DefId) -> ty::Method {\n-    let cdata = tcx.cstore.get_crate_data(def.krate);\n-    decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n+pub fn get_method(tcx: &ty::ctxt, def: ast::DefId) -> ty::Method {\n+    let cdata = tcx.sess.cstore.get_crate_data(def.krate);\n+    decoder::get_method(tcx.sess.cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_method_name_and_explicit_self(cstore: @cstore::CStore,\n+pub fn get_method_name_and_explicit_self(cstore: &cstore::CStore,\n                                          def: ast::DefId)\n                                      -> (ast::Ident, ast::ExplicitSelf_)\n {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_trait_method_def_ids(cstore: @cstore::CStore,\n+pub fn get_trait_method_def_ids(cstore: &cstore::CStore,\n                                 def: ast::DefId) -> Vec<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_method_def_ids(cdata, def.node)\n }\n \n-pub fn get_item_variances(cstore: @cstore::CStore,\n+pub fn get_item_variances(cstore: &cstore::CStore,\n                           def: ast::DefId) -> ty::ItemVariances {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_item_variances(cdata, def.node)\n }\n \n-pub fn get_provided_trait_methods(tcx: ty::ctxt,\n+pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n                                   def: ast::DefId)\n                                -> Vec<@ty::Method> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n-    let cstore = tcx.cstore;\n+pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-pub fn get_type_name_if_impl(cstore: @cstore::CStore, def: ast::DefId)\n+pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Ident> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type_name_if_impl(cdata, def.node)\n }\n \n-pub fn get_static_methods_if_impl(cstore: @cstore::CStore,\n+pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n                                   def: ast::DefId)\n                                -> Option<Vec<StaticMethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_item_attrs(cstore: @cstore::CStore,\n+pub fn get_item_attrs(cstore: &cstore::CStore,\n                       def_id: ast::DefId,\n                       f: |Vec<@ast::MetaItem> |) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n-pub fn get_struct_fields(cstore: @cstore::CStore,\n+pub fn get_struct_fields(cstore: &cstore::CStore,\n                          def: ast::DefId)\n                       -> Vec<ty::field_ty> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_type(tcx: ty::ctxt,\n+pub fn get_type(tcx: &ty::ctxt,\n                 def: ast::DefId)\n              -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n-pub fn get_trait_def(tcx: ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n-    let cstore = tcx.cstore;\n+pub fn get_trait_def(tcx: &ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n-pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n+pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(class_id.krate);\n     let all_items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n-    let class_doc = expect(tcx.diag,\n+    let class_doc = expect(tcx.sess.diagnostic(),\n                            decoder::maybe_find_item(class_id.node, all_items),\n                            || format!(\"get_field_type: class ID {:?} not found\",\n                                    class_id) );\n-    let the_field = expect(tcx.diag,\n+    let the_field = expect(tcx.sess.diagnostic(),\n         decoder::maybe_find_item(def.node, class_doc),\n         || format!(\"get_field_type: in class {:?}, field ID {:?} not found\",\n                  class_id, def) );\n@@ -232,58 +232,58 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n \n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n-pub fn get_impl_trait(tcx: ty::ctxt,\n+pub fn get_impl_trait(tcx: &ty::ctxt,\n                       def: ast::DefId) -> Option<@ty::TraitRef> {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n // Given a def_id for an impl, return information about its vtables\n-pub fn get_impl_vtables(tcx: ty::ctxt,\n+pub fn get_impl_vtables(tcx: &ty::ctxt,\n                         def: ast::DefId) -> typeck::impl_res {\n-    let cstore = tcx.cstore;\n+    let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_vtables(cdata, def.node, tcx)\n }\n \n-pub fn get_impl_method(cstore: @cstore::CStore,\n+pub fn get_impl_method(cstore: &cstore::CStore,\n                        def: ast::DefId,\n                        mname: ast::Ident)\n                     -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n-pub fn get_item_visibility(cstore: @cstore::CStore,\n+pub fn get_item_visibility(cstore: &cstore::CStore,\n                            def_id: ast::DefId)\n                         -> ast::Visibility {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_item_visibility(cdata, def_id.node)\n }\n \n-pub fn get_native_libraries(cstore: @cstore::CStore,\n+pub fn get_native_libraries(cstore: &cstore::CStore,\n                             crate_num: ast::CrateNum)\n                                 -> Vec<(cstore::NativeLibaryKind, ~str)> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_native_libraries(cdata)\n }\n \n-pub fn each_impl(cstore: @cstore::CStore,\n+pub fn each_impl(cstore: &cstore::CStore,\n                  crate_num: ast::CrateNum,\n                  callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::each_impl(cdata, callback)\n }\n \n-pub fn each_implementation_for_type(cstore: @cstore::CStore,\n+pub fn each_implementation_for_type(cstore: &cstore::CStore,\n                                     def_id: ast::DefId,\n                                     callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::each_implementation_for_type(cdata, def_id.node, callback)\n }\n \n-pub fn each_implementation_for_trait(cstore: @cstore::CStore,\n+pub fn each_implementation_for_trait(cstore: &cstore::CStore,\n                                      def_id: ast::DefId,\n                                      callback: |ast::DefId|) {\n     let cdata = cstore.get_crate_data(def_id.krate);\n@@ -293,22 +293,22 @@ pub fn each_implementation_for_trait(cstore: @cstore::CStore,\n /// If the given def ID describes a method belonging to a trait (either a\n /// default method or an implementation of a trait method), returns the ID of\n /// the trait that the method belongs to. Otherwise, returns `None`.\n-pub fn get_trait_of_method(cstore: @cstore::CStore,\n+pub fn get_trait_of_method(cstore: &cstore::CStore,\n                            def_id: ast::DefId,\n-                           tcx: ty::ctxt)\n+                           tcx: &ty::ctxt)\n                            -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(def_id.krate);\n     decoder::get_trait_of_method(cdata, def_id.node, tcx)\n }\n \n-pub fn get_macro_registrar_fn(cstore: @cstore::CStore,\n+pub fn get_macro_registrar_fn(cstore: &cstore::CStore,\n                               crate_num: ast::CrateNum)\n                               -> Option<ast::DefId> {\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_macro_registrar_fn(cdata)\n }\n \n-pub fn get_exported_macros(cstore: @cstore::CStore,\n+pub fn get_exported_macros(cstore: &cstore::CStore,\n                            crate_num: ast::CrateNum)\n                            -> Vec<~str> {\n     let cdata = cstore.get_crate_data(crate_num);"}, {"sha": "8f785268ae03f0c37642644c8219799f2b2aa2b0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -219,35 +219,35 @@ fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n     })\n }\n \n-fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n+fn doc_type(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n-fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n+fn doc_method_fty(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n     parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n-                 tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n+                 tcx: &ty::ctxt, cdata: Cmd) -> ty::t {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn doc_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n-fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n+fn item_trait_ref(doc: ebml::Doc, tcx: &ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n fn item_ty_param_defs(item: ebml::Doc,\n-                      tcx: ty::ctxt,\n+                      tcx: &ty::ctxt,\n                       cdata: Cmd,\n                       tag: uint)\n                       -> Rc<Vec<ty::TypeParameterDef> > {\n@@ -378,7 +378,7 @@ fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n \n pub fn get_trait_def(cdata: Cmd,\n                      item_id: ast::NodeId,\n-                     tcx: ty::ctxt) -> ty::TraitDef\n+                     tcx: &ty::ctxt) -> ty::TraitDef\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n@@ -403,7 +403,7 @@ pub fn get_trait_def(cdata: Cmd,\n     }\n }\n \n-pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data());\n@@ -427,7 +427,7 @@ pub fn get_type_param_count(data: &[u8], id: ast::NodeId) -> uint {\n \n pub fn get_impl_trait(cdata: Cmd,\n                       id: ast::NodeId,\n-                      tcx: ty::ctxt) -> Option<@ty::TraitRef>\n+                      tcx: &ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n@@ -437,7 +437,7 @@ pub fn get_impl_trait(cdata: Cmd,\n \n pub fn get_impl_vtables(cdata: Cmd,\n                         id: ast::NodeId,\n-                        tcx: ty::ctxt) -> typeck::impl_res\n+                        tcx: &ty::ctxt) -> typeck::impl_res\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n@@ -672,12 +672,12 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n }\n \n pub type DecodeInlinedItem<'a> = 'a |cdata: @cstore::crate_metadata,\n-                                     tcx: ty::ctxt,\n-                                     path: Vec<ast_map::PathElem> ,\n+                                     tcx: &ty::ctxt,\n+                                     path: Vec<ast_map::PathElem>,\n                                      par_doc: ebml::Doc|\n                                      -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n \n-pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n+pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n                           decode_inlined_item: DecodeInlinedItem)\n                           -> csearch::found_ast {\n     debug!(\"Looking up item: {}\", id);\n@@ -702,7 +702,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n }\n \n pub fn get_enum_variants(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n-                     tcx: ty::ctxt) -> Vec<@ty::VariantInfo> {\n+                     tcx: &ty::ctxt) -> Vec<@ty::VariantInfo> {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n@@ -761,7 +761,7 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n }\n \n fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n-                     tcx: ty::ctxt) -> Vec<@ty::Method> {\n+                     tcx: &ty::ctxt) -> Vec<@ty::Method> {\n     let mut rslt = Vec::new();\n     reader::tagged_docs(item, tag_item_impl_method, |doc| {\n         let m_did = reader::with_doc_data(doc, parse_def_id);\n@@ -774,7 +774,7 @@ fn item_impl_methods(intr: @IdentInterner, cdata: Cmd, item: ebml::Doc,\n \n /// Returns information about the given implementation.\n pub fn get_impl(intr: @IdentInterner, cdata: Cmd, impl_id: ast::NodeId,\n-               tcx: ty::ctxt)\n+               tcx: &ty::ctxt)\n                 -> ty::Impl {\n     let data = cdata.data();\n     let impl_item = lookup_item(impl_id, data);\n@@ -800,7 +800,7 @@ pub fn get_method_name_and_explicit_self(\n }\n \n pub fn get_method(intr: @IdentInterner, cdata: Cmd, id: ast::NodeId,\n-                  tcx: ty::ctxt) -> ty::Method\n+                  tcx: &ty::ctxt) -> ty::Method\n {\n     let method_doc = lookup_item(id, cdata.data());\n     let def_id = item_def_id(method_doc, cdata);\n@@ -858,7 +858,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n }\n \n pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n-                                  id: ast::NodeId, tcx: ty::ctxt) ->\n+                                  id: ast::NodeId, tcx: &ty::ctxt) ->\n         Vec<@ty::Method> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n@@ -878,7 +878,7 @@ pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,\n }\n \n /// Returns the supertraits of the given trait.\n-pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                     -> Vec<@ty::TraitRef> {\n     let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n@@ -1235,7 +1235,7 @@ pub fn each_implementation_for_trait(cdata: Cmd,\n     });\n }\n \n-pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n+pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                            -> Option<ast::DefId> {\n     let item_doc = lookup_item(id, cdata.data());\n     let parent_item_id = match item_parent_item(item_doc) {"}, {"sha": "b869e0a7d91ce13b644633c11aeff562667d5ab0", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -68,13 +68,13 @@ pub type EncodeInlinedItem<'a> = 'a |ecx: &EncodeContext,\n                                      ii: InlinedItemRef|;\n \n pub struct EncodeParams<'a> {\n-    diag: @SpanHandler,\n-    tcx: ty::ctxt,\n+    diag: &'a SpanHandler,\n+    tcx: &'a ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'a RefCell<NodeMap<~str>>,\n     non_inlineable_statics: &'a RefCell<NodeSet>,\n     link_meta: &'a LinkMeta,\n-    cstore: @cstore::CStore,\n+    cstore: &'a cstore::CStore,\n     encode_inlined_item: EncodeInlinedItem<'a>,\n }\n \n@@ -95,8 +95,8 @@ pub struct Stats {\n }\n \n pub struct EncodeContext<'a> {\n-    diag: @SpanHandler,\n-    tcx: ty::ctxt,\n+    diag: &'a SpanHandler,\n+    tcx: &'a ty::ctxt,\n     stats: @Stats,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'a RefCell<NodeMap<~str>>,\n@@ -129,7 +129,7 @@ fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n                     ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n+    let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n@@ -165,7 +165,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n                              ecx: &EncodeContext,\n                              params: &[ty::TypeParameterDef],\n                              tag: uint) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n+    let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n@@ -222,7 +222,7 @@ fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: DefId) {\n pub fn write_type(ecx: &EncodeContext,\n                   ebml_w: &mut writer::Encoder,\n                   typ: ty::t) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n+    let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n@@ -234,7 +234,7 @@ pub fn write_type(ecx: &EncodeContext,\n pub fn write_vstore(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     vstore: ty::vstore) {\n-    let ty_str_ctxt = @tyencode::ctxt {\n+    let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n@@ -256,7 +256,7 @@ fn encode_method_fty(ecx: &EncodeContext,\n                      typ: &ty::BareFnTy) {\n     ebml_w.start_tag(tag_item_method_fty);\n \n-    let ty_str_ctxt = @tyencode::ctxt {\n+    let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n@@ -904,7 +904,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n \n     debug!(\"encoding info for item at {}\",\n-           ecx.tcx.sess.codemap.span_to_str(item.span));\n+           ecx.tcx.sess.codemap().span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n     match item.node {\n@@ -1630,7 +1630,7 @@ impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         match item.node {\n             ItemMac(..) => {\n-                let def = self.ecx.tcx.sess.codemap.span_to_snippet(item.span)\n+                let def = self.ecx.tcx.sess.codemap().span_to_snippet(item.span)\n                     .expect(\"Unable to find source for macro\");\n                 self.ebml_w.start_tag(tag_macro_def);\n                 self.ebml_w.wr_str(def);\n@@ -1899,9 +1899,9 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n-    let cx = @tyencode::ctxt {\n-        diag: tcx.diag,\n+pub fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> ~str {\n+    let cx = &tyencode::ctxt {\n+        diag: tcx.sess.diagnostic(),\n         ds: def_to_str,\n         tcx: tcx,\n         abbrevs: tyencode::ac_no_abbrevs};"}, {"sha": "f73a3f35c2b6a86591e915701c98350826e22502", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -11,7 +11,6 @@\n #[allow(non_camel_case_types)];\n \n use std::cell::RefCell;\n-use std::option;\n use std::os;\n use std::io::fs;\n use std::vec_ng::Vec;\n@@ -27,13 +26,13 @@ pub enum FileMatch { FileMatches, FileDoesntMatch }\n /// a file found in that directory.\n pub type pick<'a> = 'a |path: &Path| -> FileMatch;\n \n-pub struct FileSearch {\n-    sysroot: @Path,\n-    addl_lib_search_paths: @RefCell<HashSet<Path>>,\n-    target_triple: ~str\n+pub struct FileSearch<'a> {\n+    sysroot: &'a Path,\n+    addl_lib_search_paths: &'a RefCell<HashSet<Path>>,\n+    target_triple: &'a str\n }\n \n-impl FileSearch {\n+impl<'a> FileSearch<'a> {\n     pub fn for_each_lib_search_path(&self, f: |&Path| -> FileMatch) {\n         let mut visited_dirs = HashSet::new();\n         let mut found = false;\n@@ -127,15 +126,14 @@ impl FileSearch {\n         });\n     }\n \n-    pub fn new(maybe_sysroot: &Option<@Path>,\n-               target_triple: &str,\n-               addl_lib_search_paths: @RefCell<HashSet<Path>>) -> FileSearch {\n-        let sysroot = get_sysroot(maybe_sysroot);\n+    pub fn new(sysroot: &'a Path,\n+               target_triple: &'a str,\n+               addl_lib_search_paths: &'a RefCell<HashSet<Path>>) -> FileSearch<'a> {\n         debug!(\"using sysroot = {}\", sysroot.display());\n-        FileSearch{\n+        FileSearch {\n             sysroot: sysroot,\n             addl_lib_search_paths: addl_lib_search_paths,\n-            target_triple: target_triple.to_owned()\n+            target_triple: target_triple\n         }\n     }\n }\n@@ -179,15 +177,8 @@ pub fn get_or_default_sysroot() -> Path {\n     }\n \n     match canonicalize(os::self_exe_name()) {\n-      option::Some(p) => { let mut p = p; p.pop(); p.pop(); p }\n-      option::None => fail!(\"can't determine value for sysroot\")\n-    }\n-}\n-\n-fn get_sysroot(maybe_sysroot: &Option<@Path>) -> @Path {\n-    match *maybe_sysroot {\n-      option::Some(sr) => sr,\n-      option::None => @get_or_default_sysroot()\n+        Some(mut p) => { p.pop(); p.pop(); p }\n+        None => fail!(\"can't determine value for sysroot\")\n     }\n }\n "}, {"sha": "28556105c7b9c902b1467d372f015a046881815a", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -46,7 +46,7 @@ pub enum Os {\n }\n \n pub struct Context<'a> {\n-    sess: Session,\n+    sess: &'a Session,\n     span: Span,\n     ident: &'a str,\n     crate_id: &'a CrateId,\n@@ -110,7 +110,7 @@ impl<'a> Context<'a> {\n     }\n \n     fn find_library_crate(&mut self) -> Option<Library> {\n-        let filesearch = self.sess.filesearch;\n+        let filesearch = self.sess.filesearch();\n         let (dyprefix, dysuffix) = self.dylibname();\n \n         // want: crate_name.dir_part() + prefix + crate_name.file_part + \"-\"\n@@ -352,7 +352,7 @@ impl<'a> Context<'a> {\n     }\n }\n \n-pub fn note_crateid_attr(diag: @SpanHandler, crateid: &CrateId) {\n+pub fn note_crateid_attr(diag: &SpanHandler, crateid: &CrateId) {\n     diag.handler().note(format!(\"crate_id: {}\", crateid.to_str()));\n }\n "}, {"sha": "1abbf1307c119484d519eb09c28d37efd568a171", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -62,7 +62,7 @@ pub struct PState<'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: uint,\n-    tcx: ty::ctxt\n+    tcx: &'a ty::ctxt\n }\n \n fn peek(st: &PState) -> char {\n@@ -105,7 +105,7 @@ fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n }\n \n pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n-                             pos: uint, tcx: ty::ctxt) -> PState<'a> {\n+                             pos: uint, tcx: &'a ty::ctxt) -> PState<'a> {\n     PState {\n         data: data,\n         krate: crate_num,\n@@ -114,25 +114,25 @@ pub fn parse_state_from_data<'a>(data: &'a [u8], crate_num: ast::CrateNum,\n     }\n }\n \n-pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                      conv: conv_did) -> ty::t {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_ty(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_bare_fn_ty_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                              conv: conv_did) -> ty::BareFnTy {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_trait_ref_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                             conv: conv_did) -> ty::TraitRef {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_trait_ref(&mut st, conv)\n }\n \n-pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: ty::ctxt,\n+pub fn parse_substs_data(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n                          conv: conv_did) -> ty::substs {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_substs(&mut st, conv)\n@@ -565,7 +565,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n }\n \n pub fn parse_type_param_def_data(data: &[u8], start: uint,\n-                                 crate_num: ast::CrateNum, tcx: ty::ctxt,\n+                                 crate_num: ast::CrateNum, tcx: &ty::ctxt,\n                                  conv: conv_did) -> ty::TypeParameterDef\n {\n     let mut st = parse_state_from_data(data, crate_num, start, tcx);"}, {"sha": "e78fe8e72a8d12f418ae0b8701373a462b3a4dc8", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -29,18 +29,17 @@ use syntax::ast;\n use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token;\n-use syntax::print::pprust::*;\n \n macro_rules! mywrite( ($wr:expr, $($arg:tt)*) => (\n     format_args!(|a| { mywrite($wr, a) }, $($arg)*)\n ) )\n \n-pub struct ctxt {\n-    diag: @SpanHandler,\n+pub struct ctxt<'a> {\n+    diag: &'a SpanHandler,\n     // Def -> str Callback:\n-    ds: extern \"Rust\" fn(DefId) -> ~str,\n+    ds: fn(DefId) -> ~str,\n     // The type context.\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     abbrevs: abbrev_ctxt\n }\n \n@@ -62,7 +61,7 @@ fn mywrite(w: &mut MemWriter, fmt: &fmt::Arguments) {\n     fmt::write(&mut *w as &mut io::Writer, fmt);\n }\n \n-pub fn enc_ty(w: &mut MemWriter, cx: @ctxt, t: ty::t) {\n+pub fn enc_ty(w: &mut MemWriter, cx: &ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n           let result_str_opt;\n@@ -131,7 +130,7 @@ fn enc_mutability(w: &mut MemWriter, mt: ast::Mutability) {\n     }\n }\n \n-fn enc_mt(w: &mut MemWriter, cx: @ctxt, mt: ty::mt) {\n+fn enc_mt(w: &mut MemWriter, cx: &ctxt, mt: ty::mt) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n@@ -146,15 +145,15 @@ fn enc_opt<T>(w: &mut MemWriter, t: Option<T>, enc_f: |&mut MemWriter, T|) {\n     }\n }\n \n-pub fn enc_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::substs) {\n+pub fn enc_substs(w: &mut MemWriter, cx: &ctxt, substs: &ty::substs) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_opt(w, substs.self_ty, |w, t| enc_ty(w, cx, t));\n     mywrite!(w, \"[\");\n     for t in substs.tps.iter() { enc_ty(w, cx, *t); }\n     mywrite!(w, \"]\");\n }\n \n-fn enc_region_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n+fn enc_region_substs(w: &mut MemWriter, cx: &ctxt, substs: &ty::RegionSubsts) {\n     match *substs {\n         ty::ErasedRegions => {\n             mywrite!(w, \"e\");\n@@ -169,7 +168,7 @@ fn enc_region_substs(w: &mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n     }\n }\n \n-fn enc_region(w: &mut MemWriter, cx: @ctxt, r: ty::Region) {\n+fn enc_region(w: &mut MemWriter, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n             mywrite!(w, \"b[{}|\", id);\n@@ -203,7 +202,7 @@ fn enc_region(w: &mut MemWriter, cx: @ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_bound_region(w: &mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n+fn enc_bound_region(w: &mut MemWriter, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n             mywrite!(w, \"a{}|\", idx);\n@@ -219,7 +218,7 @@ fn enc_bound_region(w: &mut MemWriter, cx: @ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_vstore(w: &mut MemWriter, cx: @ctxt, v: ty::vstore) {\n+pub fn enc_vstore(w: &mut MemWriter, cx: &ctxt, v: ty::vstore) {\n     mywrite!(w, \"/\");\n     match v {\n         ty::vstore_fixed(u) => mywrite!(w, \"{}|\", u),\n@@ -231,12 +230,12 @@ pub fn enc_vstore(w: &mut MemWriter, cx: @ctxt, v: ty::vstore) {\n     }\n }\n \n-pub fn enc_trait_ref(w: &mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n+pub fn enc_trait_ref(w: &mut MemWriter, cx: &ctxt, s: &ty::TraitRef) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, &s.substs);\n }\n \n-pub fn enc_trait_store(w: &mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n+pub fn enc_trait_store(w: &mut MemWriter, cx: &ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => mywrite!(w, \"~\"),\n         ty::RegionTraitStore(re) => {\n@@ -246,7 +245,7 @@ pub fn enc_trait_store(w: &mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     }\n }\n \n-fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n+fn enc_sty(w: &mut MemWriter, cx: &ctxt, st: &ty::sty) {\n     match *st {\n         ty::ty_nil => mywrite!(w, \"n\"),\n         ty::ty_bot => mywrite!(w, \"z\"),\n@@ -372,13 +371,13 @@ fn enc_onceness(w: &mut MemWriter, o: Onceness) {\n     }\n }\n \n-pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::BareFnTy) {\n+pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n     enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_closure_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n+fn enc_closure_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::ClosureTy) {\n     enc_sigil(w, ft.sigil);\n     enc_purity(w, ft.purity);\n     enc_onceness(w, ft.onceness);\n@@ -389,7 +388,7 @@ fn enc_closure_ty(w: &mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-fn enc_fn_sig(w: &mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n+fn enc_fn_sig(w: &mut MemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n     mywrite!(w, \"[{}|\", fsig.binder_id);\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n@@ -403,7 +402,7 @@ fn enc_fn_sig(w: &mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n     enc_ty(w, cx, fsig.output);\n }\n \n-fn enc_bounds(w: &mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n+fn enc_bounds(w: &mut MemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n     for bound in bs.builtin_bounds.iter() {\n         match bound {\n             ty::BoundSend => mywrite!(w, \"S\"),\n@@ -422,7 +421,7 @@ fn enc_bounds(w: &mut MemWriter, cx: @ctxt, bs: &ty::ParamBounds) {\n     mywrite!(w, \".\");\n }\n \n-pub fn enc_type_param_def(w: &mut MemWriter, cx: @ctxt, v: &ty::TypeParameterDef) {\n+pub fn enc_type_param_def(w: &mut MemWriter, cx: &ctxt, v: &ty::TypeParameterDef) {\n     mywrite!(w, \"{}:{}|\", token::get_ident(v.ident), (cx.ds)(v.def_id));\n     enc_bounds(w, cx, v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));"}, {"sha": "883883e5046467b21d2554ffd858e2d191b58443", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 92, "deletions": 95, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -34,6 +34,7 @@ use syntax;\n \n use std::libc;\n use std::cast;\n+use std::cell::RefCell;\n use std::io::Seek;\n use std::rc::Rc;\n use std::vec_ng::Vec;\n@@ -53,27 +54,27 @@ pub struct Maps {\n     root_map: middle::borrowck::root_map,\n     method_map: middle::typeck::MethodMap,\n     vtable_map: middle::typeck::vtable_map,\n-    capture_map: middle::moves::CaptureMap,\n+    capture_map: RefCell<middle::moves::CaptureMap>,\n }\n \n-struct DecodeContext {\n+struct DecodeContext<'a> {\n     cdata: @cstore::crate_metadata,\n-    tcx: ty::ctxt,\n-    maps: Maps\n+    tcx: &'a ty::ctxt,\n+    maps: &'a Maps\n }\n \n-struct ExtendedDecodeContext {\n-    dcx: @DecodeContext,\n+struct ExtendedDecodeContext<'a> {\n+    dcx: &'a DecodeContext<'a>,\n     from_id_range: ast_util::IdRange,\n     to_id_range: ast_util::IdRange\n }\n \n trait tr {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> Self;\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> Self;\n }\n \n trait tr_intern {\n-    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::DefId;\n+    fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n }\n \n // ______________________________________________________________________\n@@ -82,7 +83,7 @@ trait tr_intern {\n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            ebml_w: &mut writer::Encoder,\n                            ii: e::InlinedItemRef,\n-                           maps: Maps) {\n+                           maps: &Maps) {\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n@@ -114,12 +115,12 @@ pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n }\n \n pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n-                           tcx: ty::ctxt,\n-                           maps: Maps,\n-                           path: Vec<ast_map::PathElem> ,\n+                           tcx: &ty::ctxt,\n+                           maps: &Maps,\n+                           path: Vec<ast_map::PathElem>,\n                            par_doc: ebml::Doc)\n-                           -> Result<ast::InlinedItem, Vec<ast_map::PathElem> > {\n-    let dcx = @DecodeContext {\n+                           -> Result<ast::InlinedItem, Vec<ast_map::PathElem>> {\n+    let dcx = &DecodeContext {\n         cdata: cdata,\n         tcx: tcx,\n         maps: maps\n@@ -137,8 +138,8 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         });\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n-        let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n-        let xcx = @ExtendedDecodeContext {\n+        let to_id_range = reserve_id_range(&dcx.tcx.sess, from_id_range);\n+        let xcx = &ExtendedDecodeContext {\n             dcx: dcx,\n             from_id_range: from_id_range,\n             to_id_range: to_id_range\n@@ -154,7 +155,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                path_as_str.unwrap(),\n                token::get_ident(ident));\n-        region::resolve_inlined_item(tcx.sess, &tcx.region_maps, &ii);\n+        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, &ii);\n         decode_side_tables(xcx, ast_doc);\n         match ii {\n           ast::IIItem(i) => {\n@@ -178,7 +179,7 @@ pub fn decode_exported_macro(par_doc: ebml::Doc) -> @ast::Item {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-fn reserve_id_range(sess: Session,\n+fn reserve_id_range(sess: &Session,\n                     from_id_range: ast_util::IdRange) -> ast_util::IdRange {\n     // Handle the case of an empty range:\n     if from_id_range.empty() { return from_id_range; }\n@@ -188,7 +189,7 @@ fn reserve_id_range(sess: Session,\n     ast_util::IdRange { min: to_id_min, max: to_id_max }\n }\n \n-impl ExtendedDecodeContext {\n+impl<'a> ExtendedDecodeContext<'a> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n@@ -245,25 +246,25 @@ impl ExtendedDecodeContext {\n }\n \n impl tr_intern for ast::DefId {\n-    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::DefId {\n+    fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n         xcx.tr_intern_def_id(*self)\n     }\n }\n \n impl tr for ast::DefId {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::DefId {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n         xcx.tr_def_id(*self)\n     }\n }\n \n impl tr for Option<ast::DefId> {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> Option<ast::DefId> {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> Option<ast::DefId> {\n         self.map(|d| xcx.tr_def_id(d))\n     }\n }\n \n impl tr for Span {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> Span {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> Span {\n         xcx.tr_span(*self)\n     }\n }\n@@ -279,13 +280,13 @@ impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::DefId;\n+    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n     fn read_def_id_noxcx(&mut self,\n                          cdata: @cstore::crate_metadata) -> ast::DefId;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n-    fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::DefId {\n+    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self);\n         did.tr(xcx)\n     }\n@@ -375,11 +376,11 @@ fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n     Decodable::decode(&mut d)\n }\n \n-struct AstRenumberer {\n-    xcx: @ExtendedDecodeContext,\n+struct AstRenumberer<'a> {\n+    xcx: &'a ExtendedDecodeContext<'a>,\n }\n \n-impl ast_map::FoldOps for AstRenumberer {\n+impl<'a> ast_map::FoldOps for AstRenumberer<'a> {\n     fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n         if id == ast::DUMMY_NODE_ID {\n             // Used by ast_map to map the NodeInlinedParent.\n@@ -393,7 +394,7 @@ impl ast_map::FoldOps for AstRenumberer {\n     }\n }\n \n-fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n+fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n                         map: &ast_map::Map,\n                         path: Vec<ast_map::PathElem> ,\n                         ii: ast::InlinedItem) -> ast::InlinedItem {\n@@ -416,14 +417,14 @@ fn renumber_and_map_ast(xcx: @ExtendedDecodeContext,\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n+fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n     let mut dsr = reader::Decoder(doc);\n     let def: ast::Def = Decodable::decode(&mut dsr);\n     def.tr(xcx)\n }\n \n impl tr for ast::Def {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::Def {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ast::Def {\n         match *self {\n           ast::DefFn(did, p) => ast::DefFn(did.tr(xcx), p),\n           ast::DefStaticMethod(did, wrapped_did2, p) => {\n@@ -476,7 +477,7 @@ impl tr for ast::Def {\n // Encoding and decoding of adjustment information\n \n impl tr for ty::AutoDerefRef {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoDerefRef {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef {\n         ty::AutoDerefRef {\n             autoderefs: self.autoderefs,\n             autoref: match self.autoref {\n@@ -488,13 +489,13 @@ impl tr for ty::AutoDerefRef {\n }\n \n impl tr for ty::AutoRef {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoRef {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::AutoRef {\n         self.map_region(|r| r.tr(xcx))\n     }\n }\n \n impl tr for ty::Region {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::Region {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::Region {\n         match *self {\n             ty::ReLateBound(id, br) => ty::ReLateBound(xcx.tr_id(id),\n                                                        br.tr(xcx)),\n@@ -512,7 +513,7 @@ impl tr for ty::Region {\n }\n \n impl tr for ty::BoundRegion {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::BoundRegion {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::BoundRegion {\n         match *self {\n             ty::BrAnon(_) |\n             ty::BrFresh(_) => *self,\n@@ -530,20 +531,20 @@ fn encode_freevar_entry(ebml_w: &mut writer::Encoder, fv: @freevar_entry) {\n }\n \n trait ebml_decoder_helper {\n-    fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry;\n }\n \n impl<'a> ebml_decoder_helper for reader::Decoder<'a> {\n-    fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self);\n         fv.tr(xcx)\n     }\n }\n \n impl tr for freevar_entry {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> freevar_entry {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> freevar_entry {\n         freevar_entry {\n             def: self.def.tr(xcx),\n             span: self.span.tr(xcx),\n@@ -555,20 +556,20 @@ impl tr for freevar_entry {\n // Encoding and decoding of CaptureVar information\n \n trait capture_var_helper {\n-    fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_capture_var(&mut self, xcx: &ExtendedDecodeContext)\n                         -> moves::CaptureVar;\n }\n \n impl<'a> capture_var_helper for reader::Decoder<'a> {\n-    fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_capture_var(&mut self, xcx: &ExtendedDecodeContext)\n                         -> moves::CaptureVar {\n         let cvar: moves::CaptureVar = Decodable::decode(self);\n         cvar.tr(xcx)\n     }\n }\n \n impl tr for moves::CaptureVar {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> moves::CaptureVar {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> moves::CaptureVar {\n         moves::CaptureVar {\n             def: self.def.tr(xcx),\n             span: self.span.tr(xcx),\n@@ -581,7 +582,7 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of MethodCallee\n \n trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, xcx: @ExtendedDecodeContext) -> MethodCallee;\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> MethodCallee;\n }\n \n fn encode_method_callee(ecx: &e::EncodeContext,\n@@ -601,7 +602,7 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, xcx: @ExtendedDecodeContext) -> MethodCallee {\n+    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> MethodCallee {\n         self.read_struct(\"MethodCallee\", 3, |this| {\n             MethodCallee {\n                 origin: this.read_struct_field(\"origin\", 0, |this| {\n@@ -621,7 +622,7 @@ impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n }\n \n impl tr for MethodOrigin {\n-    fn tr(&self, xcx: @ExtendedDecodeContext) -> MethodOrigin {\n+    fn tr(&self, xcx: &ExtendedDecodeContext) -> MethodOrigin {\n         match *self {\n             typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(xcx)),\n             typeck::MethodParam(ref mp) => {\n@@ -702,19 +703,19 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n \n pub trait vtable_decoder_helpers {\n     fn read_vtable_res(&mut self,\n-                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res;\n     fn read_vtable_param_res(&mut self,\n-                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res;\n     fn read_vtable_origin(&mut self,\n-                          tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                           -> typeck::vtable_origin;\n }\n \n impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     fn read_vtable_res(&mut self,\n-                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                       tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_param_res(tcx, cdata))\n@@ -723,7 +724,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_param_res(&mut self,\n-                             tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                             tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_origin(tcx, cdata))\n@@ -732,7 +733,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_vtable_origin(&mut self,\n-                          tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                          tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n         -> typeck::vtable_origin {\n         self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n@@ -775,12 +776,12 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n // Encoding and decoding the side tables\n \n trait get_ty_str_ctxt {\n-    fn ty_str_ctxt(&self) -> @tyencode::ctxt;\n+    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a>;\n }\n \n impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n-    fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n-        @tyencode::ctxt {\n+    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a> {\n+        tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),\n             ds: e::def_to_str,\n             tcx: self.tcx,\n@@ -821,7 +822,7 @@ impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n                            type_param_def: &ty::TypeParameterDef) {\n         self.emit_opaque(|this| {\n             tyencode::enc_type_param_def(this.writer,\n-                                         ecx.ty_str_ctxt(),\n+                                         &ecx.ty_str_ctxt(),\n                                          type_param_def)\n         })\n     }\n@@ -850,7 +851,7 @@ impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n     }\n \n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &ty::substs) {\n-        self.emit_opaque(|this| tyencode::enc_substs(this.writer, ecx.ty_str_ctxt(), substs))\n+        self.emit_opaque(|this| tyencode::enc_substs(this.writer, &ecx.ty_str_ctxt(), substs))\n     }\n \n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment) {\n@@ -906,7 +907,7 @@ impl<'a> write_tag_and_id for writer::Encoder<'a> {\n struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *libc::c_void,\n     new_ebml_w: &'a mut writer::Encoder<'b>,\n-    maps: Maps,\n+    maps: &'a Maps,\n }\n \n impl<'a,'b> ast_util::IdVisitingOperation for\n@@ -929,7 +930,7 @@ impl<'a,'b> ast_util::IdVisitingOperation for\n }\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n-                             maps: Maps,\n+                             maps: &Maps,\n                              ebml_w: &mut writer::Encoder,\n                              ii: &ast::InlinedItem) {\n     ebml_w.start_tag(c::tag_table as uint);\n@@ -951,7 +952,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n }\n \n fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n-                             maps: Maps,\n+                             maps: &Maps,\n                              ebml_w: &mut writer::Encoder,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n@@ -1075,20 +1076,16 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    {\n-        let capture_map = maps.capture_map.borrow();\n-        let r = capture_map.get().find(&id);\n-        for &cap_vars in r.iter() {\n-            ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n-                ebml_w.id(id);\n-                ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(cap_vars.deref().as_slice(),\n-                                         |ebml_w, cap_var| {\n-                        cap_var.encode(ebml_w);\n-                    })\n+    for &cap_vars in maps.capture_map.borrow().get().find(&id).iter() {\n+        ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n+            ebml_w.id(id);\n+            ebml_w.tag(c::tag_table_val, |ebml_w| {\n+                ebml_w.emit_from_vec(cap_vars.deref().as_slice(),\n+                                        |ebml_w, cap_var| {\n+                    cap_var.encode(ebml_w);\n                 })\n             })\n-        }\n+        })\n     }\n }\n \n@@ -1105,32 +1102,32 @@ impl<'a> doc_decoder_helpers for ebml::Doc<'a> {\n }\n \n trait ebml_decoder_decoder_helpers {\n-    fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> Vec<ty::t> ;\n-    fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t;\n+    fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t>;\n+    fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n                            -> ty::TypeParameterDef;\n-    fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_ty_param_bounds_and_ty(&mut self, xcx: &ExtendedDecodeContext)\n                                 -> ty::ty_param_bounds_and_ty;\n-    fn read_substs(&mut self, xcx: @ExtendedDecodeContext) -> ty::substs;\n-    fn read_auto_adjustment(&mut self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment;\n+    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> ty::substs;\n+    fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n     fn convert_def_id(&mut self,\n-                      xcx: @ExtendedDecodeContext,\n+                      xcx: &ExtendedDecodeContext,\n                       source: DefIdSource,\n                       did: ast::DefId)\n                       -> ast::DefId;\n \n     // Versions of the type reading functions that don't need the full\n     // ExtendedDecodeContext.\n     fn read_ty_noxcx(&mut self,\n-                     tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n+                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n     fn read_tys_noxcx(&mut self,\n-                      tcx: ty::ctxt,\n-                      cdata: @cstore::crate_metadata) -> Vec<ty::t> ;\n+                      tcx: &ty::ctxt,\n+                      cdata: @cstore::crate_metadata) -> Vec<ty::t>;\n }\n \n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n-                     tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n+                     tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n             tydecode::parse_ty_data(\n                 doc.data,\n@@ -1142,14 +1139,14 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys_noxcx(&mut self,\n-                      tcx: ty::ctxt,\n+                      tcx: &ty::ctxt,\n                       cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| this.read_ty_noxcx(tcx, cdata) )\n             .move_iter()\n             .collect()\n     }\n \n-    fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n+    fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1177,11 +1174,11 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> Vec<ty::t> {\n+    fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t> {\n         self.read_to_vec(|this| this.read_ty(xcx)).move_iter().collect()\n     }\n \n-    fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n                            -> ty::TypeParameterDef {\n         self.read_opaque(|this, doc| {\n             tydecode::parse_type_param_def_data(\n@@ -1193,7 +1190,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         })\n     }\n \n-    fn read_ty_param_bounds_and_ty(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_ty_param_bounds_and_ty(&mut self, xcx: &ExtendedDecodeContext)\n                                    -> ty::ty_param_bounds_and_ty {\n         self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n             ty::ty_param_bounds_and_ty {\n@@ -1225,7 +1222,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         })\n     }\n \n-    fn read_substs(&mut self, xcx: @ExtendedDecodeContext) -> ty::substs {\n+    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> ty::substs {\n         self.read_opaque(|this, doc| {\n             tydecode::parse_substs_data(doc.data,\n                                         xcx.dcx.cdata.cnum,\n@@ -1235,7 +1232,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         })\n     }\n \n-    fn read_auto_adjustment(&mut self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n+    fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\", \"AutoObject\"];\n             this.read_enum_variant(variants, |this, i| {\n@@ -1281,7 +1278,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn convert_def_id(&mut self,\n-                      xcx: @ExtendedDecodeContext,\n+                      xcx: &ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n                       did: ast::DefId)\n                       -> ast::DefId {\n@@ -1322,7 +1319,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n }\n \n-fn decode_side_tables(xcx: @ExtendedDecodeContext,\n+fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                       ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n@@ -1446,17 +1443,17 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n #[cfg(test)]\n trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::CrateConfig;\n-    fn parse_sess(&self) -> @parse::ParseSess;\n+    fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess;\n     fn call_site(&self) -> Span;\n     fn ident_of(&self, st: &str) -> ast::Ident;\n }\n \n #[cfg(test)]\n-impl fake_ext_ctxt for @parse::ParseSess {\n+impl fake_ext_ctxt for parse::ParseSess {\n     fn cfg(&self) -> ast::CrateConfig {\n         Vec::new()\n     }\n-    fn parse_sess(&self) -> @parse::ParseSess { *self }\n+    fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess { self }\n     fn call_site(&self) -> Span {\n         codemap::Span {\n             lo: codemap::BytePos(0),\n@@ -1470,7 +1467,7 @@ impl fake_ext_ctxt for @parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn mk_ctxt() -> @parse::ParseSess {\n+fn mk_ctxt() -> parse::ParseSess {\n     parse::new_parse_sess()\n }\n \n@@ -1520,7 +1517,7 @@ fn test_more() {\n #[test]\n fn test_simplification() {\n     let cx = mk_ctxt();\n-    let item = quote_item!(cx,\n+    let item = quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: Vec::new()};"}, {"sha": "5faf9c9986baeb8a24404ff5763c578727397cd4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -32,9 +32,9 @@ use syntax::visit;\n use util::ppaux::Repr;\n \n struct CheckLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt,\n-    dfcx_loans: &'a LoanDataFlow,\n-    move_data: move_data::FlowedMoveData,\n+    bccx: &'a BorrowckCtxt<'a>,\n+    dfcx_loans: &'a LoanDataFlow<'a>,\n+    move_data: move_data::FlowedMoveData<'a>,\n     all_loans: &'a [Loan],\n }\n \n@@ -87,7 +87,7 @@ enum MoveError {\n }\n \n impl<'a> CheckLoanCtxt<'a> {\n-    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)\n                             -> bool {\n@@ -715,9 +715,7 @@ impl<'a> CheckLoanCtxt<'a> {\n     fn check_captured_variables(&self,\n                                 closure_id: ast::NodeId,\n                                 span: Span) {\n-        let capture_map = self.bccx.capture_map.borrow();\n-        let cap_vars = capture_map.get().get(&closure_id);\n-        for cap_var in cap_vars.deref().iter() {\n+        for cap_var in self.bccx.capture_map.get(&closure_id).deref().iter() {\n             let var_id = ast_util::def_id_of_def(cap_var.def).node;\n             let var_path = @LpVar(var_id);\n             self.check_if_path_is_moved(closure_id, span,"}, {"sha": "3d5ea0e89b2e6224ae6f3cedcc87e0885b48e249", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -47,9 +47,7 @@ pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n pub fn gather_captures(bccx: &BorrowckCtxt,\n                        move_data: &MoveData,\n                        closure_expr: &ast::Expr) {\n-    let capture_map = bccx.capture_map.borrow();\n-    let captured_vars = capture_map.get().get(&closure_expr.id);\n-    for captured_var in captured_vars.deref().iter() {\n+    for captured_var in bccx.capture_map.get(&closure_expr.id).deref().iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n                 let cmt = bccx.cat_captured_var(closure_expr.id,"}, {"sha": "7f810aabf0fdf711ffa5f202fc4aa54e0853bce7", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -48,7 +48,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n // Private\n \n struct GuaranteeLifetimeContext<'a> {\n-    bccx: &'a BorrowckCtxt,\n+    bccx: &'a BorrowckCtxt<'a>,\n \n     // the node id of the function body for the enclosing item\n     item_scope_id: ast::NodeId,\n@@ -65,7 +65,7 @@ struct GuaranteeLifetimeContext<'a> {\n }\n \n impl<'a> GuaranteeLifetimeContext<'a> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt {\n         self.bccx.tcx\n     }\n \n@@ -261,10 +261,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n         match cmt.guarantor().cat {\n             mc::cat_local(id) |\n             mc::cat_arg(id) => {\n-                let moved_variables_set = self.bccx\n-                                              .moved_variables_set\n-                                              .borrow();\n-                moved_variables_set.get().contains(&id)\n+                self.bccx.moved_variables_set.contains(&id)\n             }\n             mc::cat_rvalue(..) |\n             mc::cat_static_item |"}, {"sha": "3c3c4371ebb01472d90867287ee2b7d6388c7c06", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -27,7 +27,6 @@ use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::{Repr};\n \n-use std::cell::RefCell;\n use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n@@ -69,10 +68,10 @@ mod gather_moves;\n /// body of the while loop and we will refuse to root the pointer `&*x`\n /// because it would have to be rooted for a region greater than `root_ub`.\n struct GatherLoanCtxt<'a> {\n-    bccx: &'a BorrowckCtxt,\n+    bccx: &'a BorrowckCtxt<'a>,\n     id_range: IdRange,\n     move_data: move_data::MoveData,\n-    all_loans: @RefCell<Vec<Loan> >,\n+    all_loans: Vec<Loan>,\n     item_ub: ast::NodeId,\n     repeating_ids: Vec<ast::NodeId> }\n \n@@ -104,19 +103,20 @@ impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n }\n \n pub fn gather_loans(bccx: &BorrowckCtxt, decl: &ast::FnDecl, body: &ast::Block)\n-                    -> (IdRange, @RefCell<Vec<Loan> >, move_data::MoveData) {\n+                    -> (IdRange, Vec<Loan>, move_data::MoveData) {\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n         id_range: IdRange::max(),\n-        all_loans: @RefCell::new(Vec::new()),\n+        all_loans: Vec::new(),\n         item_ub: body.id,\n         repeating_ids: vec!(body.id),\n         move_data: MoveData::new()\n     };\n     glcx.gather_fn_arg_patterns(decl, body);\n \n     glcx.visit_block(body, ());\n-    return (glcx.id_range, glcx.all_loans, glcx.move_data);\n+    let GatherLoanCtxt { id_range, all_loans, move_data, .. } = glcx;\n+    (id_range, all_loans, move_data)\n }\n \n fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n@@ -315,7 +315,7 @@ fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |@LoanPath\n }\n \n impl<'a> GatherLoanCtxt<'a> {\n-    pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+    pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n \n     pub fn push_repeating_id(&mut self, id: ast::NodeId) {\n         self.repeating_ids.push(id);\n@@ -440,9 +440,7 @@ impl<'a> GatherLoanCtxt<'a> {\n \n     fn guarantee_captures(&mut self,\n                           closure_expr: &ast::Expr) {\n-        let capture_map = self.bccx.capture_map.borrow();\n-        let captured_vars = capture_map.get().get(&closure_expr.id);\n-        for captured_var in captured_vars.deref().iter() {\n+        for captured_var in self.bccx.capture_map.get(&closure_expr.id).deref().iter() {\n             match captured_var.mode {\n                 moves::CapCopy | moves::CapMove => { continue; }\n                 moves::CapRef => { }\n@@ -584,9 +582,8 @@ impl<'a> GatherLoanCtxt<'a> {\n                     self.mark_loan_path_as_mutated(loan_path);\n                 }\n \n-                let all_loans = self.all_loans.borrow();\n                 Loan {\n-                    index: all_loans.get().len(),\n+                    index: self.all_loans.len(),\n                     loan_path: loan_path,\n                     cmt: cmt,\n                     kind: req_kind,\n@@ -605,10 +602,7 @@ impl<'a> GatherLoanCtxt<'a> {\n         // let loan_path = loan.loan_path;\n         // let loan_gen_scope = loan.gen_scope;\n         // let loan_kill_scope = loan.kill_scope;\n-        {\n-            let mut all_loans = self.all_loans.borrow_mut();\n-            all_loans.get().push(loan);\n-        }\n+        self.all_loans.push(loan);\n \n         // if loan_gen_scope != borrow_id {\n             // FIXME(#6268) Nested method calls"}, {"sha": "228e02fa0ac78f9d97370c41e817c76a3059d68e", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -46,7 +46,7 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n // Private\n \n struct RestrictionsContext<'a> {\n-    bccx: &'a BorrowckCtxt,\n+    bccx: &'a BorrowckCtxt<'a>,\n     span: Span,\n     cmt_original: mc::cmt,\n     loan_region: ty::Region,"}, {"sha": "bb6956556b57e38e4b92ea0380957d52121b1150", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -18,6 +18,7 @@ use middle::typeck;\n use middle::moves;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n+use util::nodemap::NodeSet;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::cell::{Cell, RefCell};\n@@ -61,20 +62,20 @@ impl Clone for LoanDataFlowOperator {\n     }\n }\n \n-pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n+pub type LoanDataFlow<'a> = DataFlowContext<'a, LoanDataFlowOperator>;\n \n-impl Visitor<()> for BorrowckCtxt {\n+impl<'a> Visitor<()> for BorrowckCtxt<'a> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         borrowck_fn(self, fk, fd, b, s, n);\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n-                   moves_map: moves::MovesMap,\n-                   moved_variables_set: moves::MovedVariablesSet,\n-                   capture_map: moves::CaptureMap,\n+                   moves_map: &NodeSet,\n+                   moved_variables_set: &NodeSet,\n+                   capture_map: &moves::CaptureMap,\n                    krate: &ast::Crate)\n                    -> root_map {\n     let mut bccx = BorrowckCtxt {\n@@ -127,14 +128,13 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     // Check the body of fn items.\n     let (id_range, all_loans, move_data) =\n         gather_loans::gather_loans(this, decl, body);\n-    let all_loans = all_loans.borrow();\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              this.method_map,\n                              LoanDataFlowOperator,\n                              id_range,\n-                             all_loans.get().len());\n-    for (loan_idx, loan) in all_loans.get().iter().enumerate() {\n+                             all_loans.len());\n+    for (loan_idx, loan) in all_loans.iter().enumerate() {\n         loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n         loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n     }\n@@ -147,20 +147,20 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                                                       body);\n \n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                             all_loans.get().as_slice(), body);\n+                             all_loans.as_slice(), body);\n \n     visit::walk_fn(this, fk, decl, body, sp, id, ());\n }\n \n // ----------------------------------------------------------------------\n // Type definitions\n \n-pub struct BorrowckCtxt {\n-    tcx: ty::ctxt,\n+pub struct BorrowckCtxt<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n-    moves_map: moves::MovesMap,\n-    moved_variables_set: moves::MovedVariablesSet,\n-    capture_map: moves::CaptureMap,\n+    moves_map: &'a NodeSet,\n+    moved_variables_set: &'a NodeSet,\n+    capture_map: &'a moves::CaptureMap,\n     root_map: root_map,\n \n     // Statistics:\n@@ -335,7 +335,7 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n }\n \n impl Repr for RestrictionSet {\n-    fn repr(&self, _tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ty::ctxt) -> ~str {\n         format!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n     }\n }\n@@ -405,7 +405,7 @@ pub enum MovedValueUseKind {\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n-impl BorrowckCtxt {\n+impl<'a> BorrowckCtxt<'a> {\n     pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n                            -> bool {\n         self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n@@ -417,11 +417,10 @@ impl BorrowckCtxt {\n     }\n \n     pub fn is_move(&self, id: ast::NodeId) -> bool {\n-        let moves_map = self.moves_map.borrow();\n-        moves_map.get().contains(&id)\n+        self.moves_map.contains(&id)\n     }\n \n-    pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper> {\n+    pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper<'a>> {\n         mc::MemCategorizationContext {\n             typer: TcxTyper {\n                 tcx: self.tcx,\n@@ -601,7 +600,7 @@ impl BorrowckCtxt {\n             }\n         }\n \n-        fn move_suggestion(tcx: ty::ctxt, ty: ty::t, default_msg: &'static str)\n+        fn move_suggestion(tcx: &ty::ctxt, ty: ty::t, default_msg: &'static str)\n                           -> &'static str {\n             match ty::get(ty).sty {\n                 ty::ty_closure(ref cty) if cty.sigil == ast::BorrowedSigil =>\n@@ -871,7 +870,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n }\n \n impl Repr for Loan {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n              self.index,\n              self.loan_path.repr(tcx),\n@@ -883,15 +882,15 @@ impl Repr for Loan {\n }\n \n impl Repr for Restriction {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"Restriction({}, {:x})\",\n              self.loan_path.repr(tcx),\n              self.set.bits as uint)\n     }\n }\n \n impl Repr for LoanPath {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match self {\n             &LpVar(id) => {\n                 format!(\"$({})\", tcx.map.node_to_str(id))\n@@ -910,21 +909,21 @@ impl Repr for LoanPath {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub struct TcxTyper {\n-    tcx: ty::ctxt,\n+pub struct TcxTyper<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n }\n \n-impl mc::Typer for TcxTyper {\n-    fn tcx(&self) -> ty::ctxt {\n+impl<'a> mc::Typer for TcxTyper<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.tcx\n     }\n \n     fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n         Ok(ty::node_id_to_type(self.tcx, id))\n     }\n \n-    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n         self.method_map.borrow().get().find(&method_call).map(|method| method.ty)\n     }\n "}, {"sha": "66e92583edb68fe2347643c4c3aaf171ea26a4a0", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -55,15 +55,15 @@ pub struct MoveData {\n     assignee_ids: RefCell<HashSet<ast::NodeId>>,\n }\n \n-pub struct FlowedMoveData {\n+pub struct FlowedMoveData<'a> {\n     move_data: MoveData,\n \n-    dfcx_moves: MoveDataFlow,\n+    dfcx_moves: MoveDataFlow<'a>,\n \n     // We could (and maybe should, for efficiency) combine both move\n     // and assign data flow into one, but this way it's easier to\n     // distinguish the bits that correspond to moves and assignments.\n-    dfcx_assign: AssignDataFlow\n+    dfcx_assign: AssignDataFlow<'a>\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n@@ -159,7 +159,7 @@ impl Clone for MoveDataFlowOperator {\n     }\n }\n \n-pub type MoveDataFlow = DataFlowContext<MoveDataFlowOperator>;\n+pub type MoveDataFlow<'a> = DataFlowContext<'a, MoveDataFlowOperator>;\n \n pub struct AssignDataFlowOperator;\n \n@@ -171,7 +171,7 @@ impl Clone for AssignDataFlowOperator {\n     }\n }\n \n-pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n+pub type AssignDataFlow<'a> = DataFlowContext<'a, AssignDataFlowOperator>;\n \n impl MoveData {\n     pub fn new() -> MoveData {\n@@ -236,7 +236,7 @@ impl MoveData {\n     }\n \n     pub fn move_path(&self,\n-                     tcx: ty::ctxt,\n+                     tcx: &ty::ctxt,\n                      lp: @LoanPath) -> MovePathIndex {\n         /*!\n          * Returns the existing move path index for `lp`, if any,\n@@ -355,7 +355,7 @@ impl MoveData {\n     }\n \n     pub fn add_move(&self,\n-                    tcx: ty::ctxt,\n+                    tcx: &ty::ctxt,\n                     lp: @LoanPath,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n@@ -390,7 +390,7 @@ impl MoveData {\n     }\n \n     pub fn add_assignment(&self,\n-                          tcx: ty::ctxt,\n+                          tcx: &ty::ctxt,\n                           lp: @LoanPath,\n                           assign_id: ast::NodeId,\n                           span: Span,\n@@ -435,7 +435,7 @@ impl MoveData {\n     }\n \n     fn add_gen_kills(&self,\n-                     tcx: ty::ctxt,\n+                     tcx: &ty::ctxt,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         /*!\n@@ -566,13 +566,13 @@ impl MoveData {\n     }\n }\n \n-impl FlowedMoveData {\n+impl<'a> FlowedMoveData<'a> {\n     pub fn new(move_data: MoveData,\n-               tcx: ty::ctxt,\n+               tcx: &'a ty::ctxt,\n                method_map: typeck::MethodMap,\n                id_range: ast_util::IdRange,\n                body: &ast::Block)\n-               -> FlowedMoveData {\n+               -> FlowedMoveData<'a> {\n         let mut dfcx_moves = {\n             let moves = move_data.moves.borrow();\n             DataFlowContext::new(tcx,"}, {"sha": "1c3f62df73f56314af7f66287738b326b57abc8c", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -18,8 +18,8 @@ use syntax::ast_util;\n use syntax::opt_vec;\n use util::nodemap::NodeMap;\n \n-struct CFGBuilder {\n-    tcx: ty::ctxt,\n+struct CFGBuilder<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n     exit_map: NodeMap<CFGIndex>,\n     graph: CFGGraph,\n@@ -32,7 +32,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break\n }\n \n-pub fn construct(tcx: ty::ctxt,\n+pub fn construct(tcx: &ty::ctxt,\n                  method_map: typeck::MethodMap,\n                  blk: &ast::Block) -> CFG {\n     let mut cfg_builder = CFGBuilder {\n@@ -51,7 +51,7 @@ pub fn construct(tcx: ty::ctxt,\n          exit: exit}\n }\n \n-impl CFGBuilder {\n+impl<'a> CFGBuilder<'a> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n         for &stmt in blk.stmts.iter() {"}, {"sha": "5b4a5f89ea9288b8ff8799f424753fb919252dfa", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -53,7 +53,7 @@ pub struct CFGIndices {\n }\n \n impl CFG {\n-    pub fn new(tcx: ty::ctxt,\n+    pub fn new(tcx: &ty::ctxt,\n                method_map: typeck::MethodMap,\n                blk: &ast::Block) -> CFG {\n         construct::construct(tcx, method_map, blk)"}, {"sha": "53a53a66335577f9fc243af6c006d49f9d8c4da6", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 37, "deletions": 56, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -21,50 +21,42 @@ use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-pub struct CheckCrateVisitor {\n-    sess: Session,\n+pub struct CheckCrateVisitor<'a> {\n     def_map: resolve::DefMap,\n     method_map: typeck::MethodMap,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n }\n \n-impl Visitor<bool> for CheckCrateVisitor {\n+impl<'a> Visitor<bool> for CheckCrateVisitor<'a> {\n     fn visit_item(&mut self, i: &Item, env: bool) {\n-        check_item(self, self.sess, self.def_map, i, env);\n+        check_item(self, i, env);\n     }\n     fn visit_pat(&mut self, p: &Pat, env: bool) {\n         check_pat(self, p, env);\n     }\n     fn visit_expr(&mut self, ex: &Expr, env: bool) {\n-        check_expr(self, self.sess, self.def_map, self.method_map,\n-                   self.tcx, ex, env);\n+        check_expr(self, ex, env);\n     }\n }\n \n-pub fn check_crate(sess: Session,\n-                   krate: &Crate,\n+pub fn check_crate(krate: &Crate,\n                    def_map: resolve::DefMap,\n                    method_map: typeck::MethodMap,\n-                   tcx: ty::ctxt) {\n+                   tcx: &ty::ctxt) {\n     let mut v = CheckCrateVisitor {\n-        sess: sess,\n         def_map: def_map,\n         method_map: method_map,\n         tcx: tcx,\n     };\n     visit::walk_crate(&mut v, krate, false);\n-    sess.abort_if_errors();\n+    tcx.sess.abort_if_errors();\n }\n \n-pub fn check_item(v: &mut CheckCrateVisitor,\n-                  sess: Session,\n-                  def_map: resolve::DefMap,\n-                  it: &Item,\n-                  _is_const: bool) {\n+fn check_item(v: &mut CheckCrateVisitor, it: &Item, _is_const: bool) {\n     match it.node {\n         ItemStatic(_, _, ex) => {\n             v.visit_expr(ex, true);\n-            check_item_recursion(sess, &v.tcx.map, def_map, it);\n+            check_item_recursion(&v.tcx.sess, &v.tcx.map, v.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n             for var in (*enum_definition).variants.iter() {\n@@ -77,8 +69,8 @@ pub fn check_item(v: &mut CheckCrateVisitor,\n     }\n }\n \n-pub fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n-    fn is_str(e: @Expr) -> bool {\n+fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n+    fn is_str(e: &Expr) -> bool {\n         match e.node {\n             ExprVstore(expr, ExprVstoreUniq) => {\n                 match expr.node {\n@@ -100,36 +92,30 @@ pub fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n     }\n }\n \n-pub fn check_expr(v: &mut CheckCrateVisitor,\n-                  sess: Session,\n-                  def_map: resolve::DefMap,\n-                  method_map: typeck::MethodMap,\n-                  tcx: ty::ctxt,\n-                  e: &Expr,\n-                  is_const: bool) {\n+fn check_expr(v: &mut CheckCrateVisitor, e: &Expr, is_const: bool) {\n     if is_const {\n         match e.node {\n           ExprUnary(UnDeref, _) => { }\n           ExprUnary(UnBox, _) | ExprUnary(UnUniq, _) => {\n-            sess.span_err(e.span,\n-                          \"cannot do allocations in constant expressions\");\n+            v.tcx.sess.span_err(e.span,\n+                                \"cannot do allocations in constant expressions\");\n             return;\n           }\n           ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n-              let method_call = typeck::MethodCall::expr(e.id);\n-            if method_map.borrow().get().contains_key(&method_call) {\n-                sess.span_err(e.span, \"user-defined operators are not \\\n-                                       allowed in constant expressions\");\n+            let method_call = typeck::MethodCall::expr(e.id);\n+            if v.method_map.borrow().get().contains_key(&method_call) {\n+                v.tcx.sess.span_err(e.span, \"user-defined operators are not \\\n+                                             allowed in constant expressions\");\n             }\n           }\n           ExprLit(_) => (),\n           ExprCast(_, _) => {\n-            let ety = ty::expr_ty(tcx, e);\n+            let ety = ty::expr_ty(v.tcx, e);\n             if !ty::type_is_numeric(ety) && !ty::type_is_unsafe_ptr(ety) {\n-                sess.span_err(e.span, ~\"can not cast to `\" +\n-                              ppaux::ty_to_str(tcx, ety) +\n-                              \"` in a constant expression\");\n+                v.tcx.sess.span_err(e.span, ~\"can not cast to `\" +\n+                                              ppaux::ty_to_str(v.tcx, ety) +\n+                                             \"` in a constant expression\");\n             }\n           }\n           ExprPath(ref pth) => {\n@@ -138,37 +124,33 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n             // foo::<bar> in a const. Currently that is only done on\n             // a path in trans::callee that only works in block contexts.\n             if !pth.segments.iter().all(|segment| segment.types.is_empty()) {\n-                sess.span_err(\n-                    e.span, \"paths in constants may only refer to \\\n-                             items without type parameters\");\n+                v.tcx.sess.span_err(e.span,\n+                                    \"paths in constants may only refer to \\\n+                                     items without type parameters\");\n             }\n-            let def_map = def_map.borrow();\n-            match def_map.get().find(&e.id) {\n+            match v.def_map.borrow().get().find(&e.id) {\n               Some(&DefStatic(..)) |\n               Some(&DefFn(_, _)) |\n               Some(&DefVariant(_, _, _)) |\n               Some(&DefStruct(_)) => { }\n \n               Some(&def) => {\n                 debug!(\"(checking const) found bad def: {:?}\", def);\n-                sess.span_err(\n-                    e.span,\n+                v.tcx.sess.span_err(e.span,\n                     \"paths in constants may only refer to \\\n                      constants or functions\");\n               }\n               None => {\n-                sess.span_bug(e.span, \"unbound path in const?!\");\n+                v.tcx.sess.span_bug(e.span, \"unbound path in const?!\");\n               }\n             }\n           }\n           ExprCall(callee, _) => {\n-            let def_map = def_map.borrow();\n-            match def_map.get().find(&callee.id) {\n+            match v.def_map.borrow().get().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n                 _ => {\n-                    sess.span_err(\n-                        e.span,\n+                    v.tcx.sess.span_err(e.span,\n                         \"function calls in constants are limited to \\\n                          struct and enum constructors\");\n                 }\n@@ -184,18 +166,17 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           ExprRepeat(..) |\n           ExprStruct(..) => { }\n           ExprAddrOf(..) => {\n-                sess.span_err(\n-                    e.span,\n+                v.tcx.sess.span_err(e.span,\n                     \"references in constants may only refer to \\\n                      immutable values\");\n           },\n           ExprVstore(_, ExprVstoreUniq) => {\n-              sess.span_err(e.span, \"cannot allocate vectors in constant expressions\")\n+              v.tcx.sess.span_err(e.span, \"cannot allocate vectors in constant expressions\")\n           },\n \n           _ => {\n-            sess.span_err(e.span,\n-                          \"constant contains unimplemented expression type\");\n+            v.tcx.sess.span_err(e.span,\n+                                \"constant contains unimplemented expression type\");\n             return;\n           }\n         }\n@@ -205,14 +186,14 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n \n struct CheckItemRecursionVisitor<'a> {\n     root_it: &'a Item,\n-    sess: Session,\n+    sess: &'a Session,\n     ast_map: &'a ast_map::Map,\n     def_map: resolve::DefMap,\n     idstack: Vec<NodeId> }\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n-pub fn check_item_recursion<'a>(sess: Session,\n+pub fn check_item_recursion<'a>(sess: &'a Session,\n                                 ast_map: &'a ast_map::Map,\n                                 def_map: resolve::DefMap,\n                                 it: &'a Item) {"}, {"sha": "4b99ce2850539fd0c489c103ae53920dfcc2ad1a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -20,15 +20,15 @@ enum Context {\n     Normal, Loop, Closure\n }\n \n-struct CheckLoopVisitor {\n-    tcx: ty::ctxt,\n+struct CheckLoopVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n }\n \n-pub fn check_crate(tcx: ty::ctxt, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckLoopVisitor { tcx: tcx }, krate, Normal)\n }\n \n-impl Visitor<Context> for CheckLoopVisitor {\n+impl<'a> Visitor<Context> for CheckLoopVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _cx: Context) {\n         visit::walk_item(self, i, Normal);\n     }\n@@ -52,7 +52,7 @@ impl Visitor<Context> for CheckLoopVisitor {\n     }\n }\n \n-impl CheckLoopVisitor {\n+impl<'a> CheckLoopVisitor<'a> {\n     fn require_loop(&self, name: &str, cx: Context, span: Span) {\n         match cx {\n             Loop => {}"}, {"sha": "610abe749c615092ea642b14e0f17dfabfe16bb0", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 29, "deletions": 42, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -16,7 +16,7 @@ use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::MethodMap;\n-use middle::moves;\n+use util::nodemap::NodeSet;\n use util::ppaux::ty_to_str;\n \n use std::cmp;\n@@ -30,47 +30,41 @@ use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n \n-struct MatchCheckCtxt {\n-    tcx: ty::ctxt,\n+struct MatchCheckCtxt<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: MethodMap,\n-    moves_map: moves::MovesMap\n+    moves_map: &'a NodeSet\n }\n \n-struct CheckMatchVisitor {\n-    cx: @MatchCheckCtxt\n-}\n-\n-impl Visitor<()> for CheckMatchVisitor {\n+impl<'a> Visitor<()> for MatchCheckCtxt<'a> {\n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n-        check_expr(self, self.cx, ex, ());\n+        check_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &Local, _: ()) {\n-        check_local(self, self.cx, l, ());\n+        check_local(self, l);\n     }\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n-        check_fn(self, self.cx, fk, fd, b, s, n, ());\n+        check_fn(self, fk, fd, b, s, n);\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: MethodMap,\n-                   moves_map: moves::MovesMap,\n+                   moves_map: &NodeSet,\n                    krate: &Crate) {\n-    let cx = @MatchCheckCtxt {tcx: tcx,\n-                              method_map: method_map,\n-                              moves_map: moves_map};\n-    let mut v = CheckMatchVisitor { cx: cx };\n+    let mut cx = MatchCheckCtxt {\n+        tcx: tcx,\n+        method_map: method_map,\n+        moves_map: moves_map\n+    };\n \n-    visit::walk_crate(&mut v, krate, ());\n+    visit::walk_crate(&mut cx, krate, ());\n \n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(v: &mut CheckMatchVisitor,\n-                  cx: @MatchCheckCtxt,\n-                  ex: &Expr,\n-                  s: ()) {\n-    visit::walk_expr(v, ex, s);\n+fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n+    visit::walk_expr(cx, ex, ());\n     match ex.node {\n       ExprMatch(scrut, ref arms) => {\n         // First, check legality of move bindings.\n@@ -871,11 +865,8 @@ fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {\n     }\n }\n \n-fn check_local(v: &mut CheckMatchVisitor,\n-                   cx: &MatchCheckCtxt,\n-                   loc: &Local,\n-                   s: ()) {\n-    visit::walk_local(v, loc, s);\n+fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n+    visit::walk_local(cx, loc, ());\n     if is_refutable(cx, loc.pat) {\n         cx.tcx.sess.span_err(loc.pat.span,\n                              \"refutable pattern in local binding\");\n@@ -885,15 +876,13 @@ fn check_local(v: &mut CheckMatchVisitor,\n     check_legality_of_move_bindings(cx, false, [ loc.pat ]);\n }\n \n-fn check_fn(v: &mut CheckMatchVisitor,\n-                cx: &MatchCheckCtxt,\n-                kind: &FnKind,\n-                decl: &FnDecl,\n-                body: &Block,\n-                sp: Span,\n-                id: NodeId,\n-                s: ()) {\n-    visit::walk_fn(v, kind, decl, body, sp, id, s);\n+fn check_fn(cx: &mut MatchCheckCtxt,\n+            kind: &FnKind,\n+            decl: &FnDecl,\n+            body: &Block,\n+            sp: Span,\n+            id: NodeId) {\n+    visit::walk_fn(cx, kind, decl, body, sp, id, ());\n     for input in decl.inputs.iter() {\n         if is_refutable(cx, input.pat) {\n             cx.tcx.sess.span_err(input.pat.span,\n@@ -964,8 +953,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     by_ref_span = Some(span);\n                 }\n                 BindByValue(_) => {\n-                    let moves_map = cx.moves_map.borrow();\n-                    if moves_map.get().contains(&id) {\n+                    if cx.moves_map.contains(&id) {\n                         any_by_move = true;\n                     }\n                 }\n@@ -1002,8 +990,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     PatIdent(_, _, sub) => {\n-                        let moves_map = cx.moves_map.borrow();\n-                        if moves_map.get().contains(&p.id) {\n+                        if cx.moves_map.contains(&p.id) {\n                             check_move(p, sub);\n                         }\n                     }"}, {"sha": "e80c60ad015d834231628b35d5ea1c85456d9526", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -30,7 +30,7 @@ use syntax::visit;\n use syntax::print::pprust;\n \n \n-fn safe_type_for_static_mut(cx: ty::ctxt, e: &ast::Expr) -> Option<~str> {\n+fn safe_type_for_static_mut(cx: &ty::ctxt, e: &ast::Expr) -> Option<~str> {\n     let node_ty = ty::node_id_to_type(cx, e.id);\n     let tcontents = ty::type_contents(cx, node_ty);\n     debug!(\"safe_type_for_static_mut(dtor={}, managed={}, owned={})\",\n@@ -49,16 +49,15 @@ fn safe_type_for_static_mut(cx: ty::ctxt, e: &ast::Expr) -> Option<~str> {\n     Some(format!(\"mutable static items are not allowed to have {}\", suffix))\n }\n \n-struct CheckStaticVisitor {\n-    tcx: ty::ctxt,\n+struct CheckStaticVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n }\n \n-pub fn check_crate(tcx: ty::ctxt, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n     visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx }, krate, false)\n }\n \n-impl CheckStaticVisitor {\n-\n+impl<'a> CheckStaticVisitor<'a> {\n     fn report_error(&self, span: Span, result: Option<~str>) -> bool {\n         match result {\n             None => { false }\n@@ -70,7 +69,7 @@ impl CheckStaticVisitor {\n     }\n }\n \n-impl Visitor<bool> for CheckStaticVisitor {\n+impl<'a> Visitor<bool> for CheckStaticVisitor<'a> {\n \n     fn visit_item(&mut self, i: &ast::Item, _is_const: bool) {\n         debug!(\"visit_item(item={})\", pprust::item_to_str(i));"}, {"sha": "c5a466f599df02ba6ad42e6377dfb31d1e5d5dd9", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -15,7 +15,6 @@ use middle::astencode;\n \n use middle::ty;\n use middle::typeck::astconv;\n-use middle;\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n \n use syntax::ast::*;\n@@ -84,7 +83,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn lookup_const(tcx: ty::ctxt, e: &Expr) -> Option<@Expr> {\n+pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<@Expr> {\n     let opt_def = {\n         let def_map = tcx.def_map.borrow();\n         def_map.get().find_copy(&e.id)\n@@ -100,7 +99,7 @@ pub fn lookup_const(tcx: ty::ctxt, e: &Expr) -> Option<@Expr> {\n     }\n }\n \n-pub fn lookup_variant_by_id(tcx: ty::ctxt,\n+pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n                        -> Option<@Expr> {\n@@ -127,23 +126,18 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             }\n         }\n     } else {\n-        {\n-            let extern_const_variants = tcx.extern_const_variants.borrow();\n-            match extern_const_variants.get().find(&variant_def) {\n-                Some(&e) => return e,\n-                None => {}\n-            }\n+        match tcx.extern_const_variants.borrow().get().find(&variant_def) {\n+            Some(&e) => return e,\n+            None => {}\n         }\n         let maps = astencode::Maps {\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n-            capture_map: @RefCell::new(NodeMap::new())\n+            capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n-            |a, b, c, d| astencode::decode_inlined_item(a, b,\n-                                                        maps,\n-                                                        c, d)) {\n+            |a, b, c, d| astencode::decode_inlined_item(a, b, &maps, c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n                     variant_expr(variants.as_slice(), variant_def.node)\n@@ -152,16 +146,12 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             },\n             _ => None\n         };\n-        {\n-            let mut extern_const_variants = tcx.extern_const_variants\n-                                               .borrow_mut();\n-            extern_const_variants.get().insert(variant_def, e);\n-            return e;\n-        }\n+        tcx.extern_const_variants.borrow_mut().get().insert(variant_def, e);\n+        return e;\n     }\n }\n \n-pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n+pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n                           -> Option<@Expr> {\n     if ast_util::is_local(def_id) {\n         {\n@@ -188,10 +178,10 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(FnvHashMap::new()),\n             vtable_map: @RefCell::new(NodeMap::new()),\n-            capture_map: @RefCell::new(NodeMap::new())\n+            capture_map: RefCell::new(NodeMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,\n-            |a, b, c, d| astencode::decode_inlined_item(a, b, maps, c, d)) {\n+            |a, b, c, d| astencode::decode_inlined_item(a, b, &maps, c, d)) {\n             csearch::found(ast::IIItem(item)) => match item.node {\n                 ItemStatic(_, ast::MutImmutable, const_expr) => Some(const_expr),\n                 _ => None\n@@ -207,12 +197,12 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n     }\n }\n \n-struct ConstEvalVisitor {\n-    tcx: ty::ctxt,\n+struct ConstEvalVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n     ccache: constness_cache,\n }\n \n-impl ConstEvalVisitor {\n+impl<'a> ConstEvalVisitor<'a> {\n     fn classify(&mut self, e: &Expr) -> constness {\n         let did = ast_util::local_def(e.id);\n         match self.ccache.find(&did) {\n@@ -297,14 +287,14 @@ impl ConstEvalVisitor {\n \n }\n \n-impl Visitor<()> for ConstEvalVisitor {\n+impl<'a> Visitor<()> for ConstEvalVisitor<'a> {\n     fn visit_expr_post(&mut self, e: &Expr, _: ()) {\n         self.classify(e);\n     }\n }\n \n pub fn process_crate(krate: &ast::Crate,\n-                     tcx: ty::ctxt) {\n+                     tcx: &ty::ctxt) {\n     let mut v = ConstEvalVisitor {\n         tcx: tcx,\n         ccache: DefIdMap::new(),\n@@ -326,16 +316,15 @@ pub enum const_val {\n     const_bool(bool)\n }\n \n-pub fn eval_const_expr(tcx: middle::ty::ctxt, e: &Expr) -> const_val {\n-    match eval_const_expr_partial(&tcx, e) {\n+pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n+    match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n         Err(s) => tcx.sess.span_fatal(e.span, s)\n     }\n }\n \n pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n                             -> Result<const_val, ~str> {\n-    use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n     match e.node {\n       ExprUnary(UnNeg, inner) => {\n@@ -496,7 +485,7 @@ pub fn eval_const_expr_partial<T: ty::ExprTyProvider>(tcx: &T, e: &Expr)\n       }\n       ExprPath(_) => {\n           match lookup_const(tcx.ty_ctxt(), e) {\n-              Some(actual_e) => eval_const_expr_partial(&tcx.ty_ctxt(), actual_e),\n+              Some(actual_e) => eval_const_expr_partial(tcx.ty_ctxt(), actual_e),\n               None => Err(~\"non-constant path in constant expr\")\n           }\n       }\n@@ -540,11 +529,11 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n     }\n }\n \n-pub fn compare_lit_exprs(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n+pub fn compare_lit_exprs(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<int> {\n     compare_const_vals(&eval_const_expr(tcx, a), &eval_const_expr(tcx, b))\n }\n \n-pub fn lit_expr_eq(tcx: middle::ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n+pub fn lit_expr_eq(tcx: &ty::ctxt, a: &Expr, b: &Expr) -> Option<bool> {\n     compare_lit_exprs(tcx, a, b).map(|val| val == 0)\n }\n "}, {"sha": "4253f90ef794a2d8ebdeb35f73a8084f32f38701", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -31,8 +31,8 @@ use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n #[deriving(Clone)]\n-pub struct DataFlowContext<O> {\n-    priv tcx: ty::ctxt,\n+pub struct DataFlowContext<'a, O> {\n+    priv tcx: &'a ty::ctxt,\n     priv method_map: typeck::MethodMap,\n \n     /// the data flow operator\n@@ -73,8 +73,8 @@ pub trait DataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint;\n }\n \n-struct PropagationContext<'a, O> {\n-    dfcx: &'a mut DataFlowContext<O>,\n+struct PropagationContext<'a, 'b, O> {\n+    dfcx: &'a mut DataFlowContext<'b, O>,\n     changed: bool\n }\n \n@@ -83,13 +83,15 @@ struct LoopScope<'a> {\n     break_bits: Vec<uint>\n }\n \n-impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n-    fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n-        let (ps, id) = match node {\n-            pprust::NodeExpr(ps, expr) => (ps, expr.id),\n-            pprust::NodeBlock(ps, blk) => (ps, blk.id),\n-            pprust::NodeItem(ps, _) => (ps, 0),\n-            pprust::NodePat(ps, pat) => (ps, pat.id)\n+impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n+    fn pre(&self,\n+           ps: &mut pprust::State<DataFlowContext<'a, O>>,\n+           node: pprust::AnnNode) -> io::IoResult<()> {\n+        let id = match node {\n+            pprust::NodeExpr(expr) => expr.id,\n+            pprust::NodeBlock(blk) => blk.id,\n+            pprust::NodeItem(_) => 0,\n+            pprust::NodePat(pat) => pat.id\n         };\n \n         if self.nodeid_to_bitset.contains_key(&id) {\n@@ -111,21 +113,20 @@ impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n                 ~\"\"\n             };\n \n-            let comment_str = format!(\"id {}: {}{}{}\",\n-                                      id, entry_str, gens_str, kills_str);\n-            try!(pprust::synth_comment(ps, comment_str));\n+            try!(ps.synth_comment(format!(\"id {}: {}{}{}\", id, entry_str,\n+                                          gens_str, kills_str)));\n             try!(pp::space(&mut ps.s));\n         }\n         Ok(())\n     }\n }\n \n-impl<O:DataFlowOperator> DataFlowContext<O> {\n-    pub fn new(tcx: ty::ctxt,\n+impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n+    pub fn new(tcx: &'a ty::ctxt,\n                method_map: typeck::MethodMap,\n                oper: O,\n                id_range: IdRange,\n-               bits_per_id: uint) -> DataFlowContext<O> {\n+               bits_per_id: uint) -> DataFlowContext<'a, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n \n         debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n@@ -315,8 +316,8 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n     }\n }\n \n-impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n-//                      ^^^^^^^^^^^^^ only needed for pretty printing\n+impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n+//                          ^^^^^^^^^^^^^ only needed for pretty printing\n     pub fn propagate(&mut self, blk: &ast::Block) {\n         //! Performs the data flow analysis.\n \n@@ -327,7 +328,7 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n \n         {\n             let mut propcx = PropagationContext {\n-                dfcx: self,\n+                dfcx: &mut *self,\n                 changed: true\n             };\n \n@@ -351,16 +352,15 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     fn pretty_print_to(&self, wr: ~io::Writer,\n                        blk: &ast::Block) -> io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n-        try!(pprust::cbox(&mut ps, pprust::indent_unit));\n-        try!(pprust::ibox(&mut ps, 0u));\n-        try!(pprust::print_block(&mut ps, blk));\n-        try!(pp::eof(&mut ps.s));\n-        Ok(())\n+        try!(ps.cbox(pprust::indent_unit));\n+        try!(ps.ibox(0u));\n+        try!(ps.print_block(blk));\n+        pp::eof(&mut ps.s)\n     }\n }\n \n-impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n-    fn tcx(&self) -> ty::ctxt {\n+impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n+    fn tcx(&self) -> &'b ty::ctxt {\n         self.dfcx.tcx\n     }\n "}, {"sha": "03d51f06ab57430f89220bdb9ce4df6b69a2a6f0", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -35,7 +35,7 @@ pub static DEAD_CODE_LINT_STR: &'static str = \"dead_code\";\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n+fn should_explore(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n     if !is_local(def_id) {\n         return false;\n     }\n@@ -49,17 +49,17 @@ fn should_explore(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n     }\n }\n \n-struct MarkSymbolVisitor {\n-    worklist: Vec<ast::NodeId> ,\n+struct MarkSymbolVisitor<'a> {\n+    worklist: Vec<ast::NodeId>,\n     method_map: typeck::MethodMap,\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     live_symbols: ~HashSet<ast::NodeId>,\n }\n \n-impl MarkSymbolVisitor {\n-    fn new(tcx: ty::ctxt,\n+impl<'a> MarkSymbolVisitor<'a> {\n+    fn new(tcx: &'a ty::ctxt,\n            method_map: typeck::MethodMap,\n-           worklist: Vec<ast::NodeId> ) -> MarkSymbolVisitor {\n+           worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             method_map: method_map,\n@@ -175,7 +175,7 @@ impl MarkSymbolVisitor {\n     }\n }\n \n-impl Visitor<()> for MarkSymbolVisitor {\n+impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n         match expr.node {\n@@ -253,7 +253,7 @@ impl Visitor<()> for LifeSeeder {\n     }\n }\n \n-fn create_and_seed_worklist(tcx: ty::ctxt,\n+fn create_and_seed_worklist(tcx: &ty::ctxt,\n                             exported_items: &privacy::ExportedItems,\n                             reachable_symbols: &NodeSet,\n                             krate: &ast::Crate) -> Vec<ast::NodeId> {\n@@ -286,7 +286,7 @@ fn create_and_seed_worklist(tcx: ty::ctxt,\n     return life_seeder.worklist;\n }\n \n-fn find_live(tcx: ty::ctxt,\n+fn find_live(tcx: &ty::ctxt,\n              method_map: typeck::MethodMap,\n              exported_items: &privacy::ExportedItems,\n              reachable_symbols: &NodeSet,\n@@ -316,12 +316,12 @@ fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     }\n }\n \n-struct DeadVisitor {\n-    tcx: ty::ctxt,\n+struct DeadVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n     live_symbols: ~HashSet<ast::NodeId>,\n }\n \n-impl DeadVisitor {\n+impl<'a> DeadVisitor<'a> {\n     // id := node id of an item's definition.\n     // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n     //            `None` otherwise.\n@@ -368,7 +368,7 @@ impl DeadVisitor {\n     }\n }\n \n-impl Visitor<()> for DeadVisitor {\n+impl<'a> Visitor<()> for DeadVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         let ctor_id = get_struct_ctor_id(item);\n         if !self.symbol_is_live(item.id, ctor_id) && should_warn(item) {\n@@ -409,7 +409,7 @@ impl Visitor<()> for DeadVisitor {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    exported_items: &privacy::ExportedItems,\n                    reachable_symbols: &NodeSet,"}, {"sha": "592c4f7e29e423debd8f2b6146697674b40dfd01", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -35,16 +35,16 @@ fn type_is_unsafe_function(ty: ty::t) -> bool {\n     }\n }\n \n-struct EffectCheckVisitor {\n-    tcx: ty::ctxt,\n+struct EffectCheckVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n \n     /// The method map.\n     method_map: MethodMap,\n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n }\n \n-impl EffectCheckVisitor {\n+impl<'a> EffectCheckVisitor<'a> {\n     fn require_unsafe(&mut self, span: Span, description: &str) {\n         match self.unsafe_context {\n             SafeContext => {\n@@ -80,7 +80,7 @@ impl EffectCheckVisitor {\n     }\n }\n \n-impl Visitor<()> for EffectCheckVisitor {\n+impl<'a> Visitor<()> for EffectCheckVisitor<'a> {\n     fn visit_fn(&mut self, fn_kind: &visit::FnKind, fn_decl: &ast::FnDecl,\n                 block: &ast::Block, span: Span, node_id: ast::NodeId, _:()) {\n \n@@ -191,7 +191,7 @@ impl Visitor<()> for EffectCheckVisitor {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt, method_map: MethodMap, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, method_map: MethodMap, krate: &ast::Crate) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n         method_map: method_map,"}, {"sha": "88a6f7aa1e24ebb12d354fde0a7d38592035e866", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -21,7 +21,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n struct EntryContext<'a> {\n-    session: Session,\n+    session: &'a Session,\n \n     ast_map: &'a ast_map::Map,\n \n@@ -48,7 +48,7 @@ impl<'a> Visitor<()> for EntryContext<'a> {\n     }\n }\n \n-pub fn find_entry_point(session: Session, krate: &Crate, ast_map: &ast_map::Map) {\n+pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map) {\n     if session.building_library.get() {\n         // No need to find a main function\n         return;"}, {"sha": "1ccc5e51487a2e93425d92f0b86696065d5b6b62", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -141,14 +141,14 @@ pub fn annotate_freevars(def_map: resolve::DefMap, krate: &ast::Crate) ->\n     freevars\n }\n \n-pub fn get_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> freevar_info {\n+pub fn get_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> freevar_info {\n     let freevars = tcx.freevars.borrow();\n     match freevars.get().find(&fid) {\n         None => fail!(\"get_freevars: {} has no freevars\", fid),\n         Some(&d) => return d\n     }\n }\n \n-pub fn has_freevars(tcx: ty::ctxt, fid: ast::NodeId) -> bool {\n+pub fn has_freevars(tcx: &ty::ctxt, fid: ast::NodeId) -> bool {\n     !get_freevars(tcx, fid).is_empty()\n }"}, {"sha": "cc1fdc7699169fd20ebd7a49144bf72363755ec1", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -52,12 +52,12 @@ use syntax::visit::Visitor;\n // types.\n \n #[deriving(Clone)]\n-pub struct Context {\n-    tcx: ty::ctxt,\n+pub struct Context<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n }\n \n-impl Visitor<()> for Context {\n+impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_expr(&mut self, ex: &Expr, _: ()) {\n         check_expr(self, ex);\n@@ -76,7 +76,7 @@ impl Visitor<()> for Context {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    krate: &Crate) {\n     let mut ctx = Context {\n@@ -324,7 +324,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n             check_trait_cast(cx, source_ty, target_ty, source.span);\n         }\n         ExprRepeat(element, count_expr, _) => {\n-            let count = ty::eval_repeat_count(&cx.tcx, count_expr);\n+            let count = ty::eval_repeat_count(cx.tcx, count_expr);\n             if count > 1 {\n                 let element_ty = ty::expr_ty(cx.tcx, element);\n                 check_copy(cx, element_ty, element.span,\n@@ -476,7 +476,7 @@ pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n     }\n }\n \n-pub fn check_static(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n+pub fn check_static(tcx: &ty::ctxt, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {\n           ty::ty_param(..) => {"}, {"sha": "2ce34a31129ecc512e82547b75efe8331825aa17", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -103,27 +103,23 @@ impl LanguageItems {\n     )*\n }\n \n-struct LanguageItemCollector {\n+struct LanguageItemCollector<'a> {\n     items: LanguageItems,\n \n-    session: Session,\n+    session: &'a Session,\n \n     item_refs: HashMap<&'static str, uint>,\n }\n \n-struct LanguageItemVisitor<'a> {\n-    this: &'a mut LanguageItemCollector,\n-}\n-\n-impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n+impl<'a> Visitor<()> for LanguageItemCollector<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         match extract(item.attrs.as_slice()) {\n             Some(value) => {\n-                let item_index = self.this.item_refs.find_equiv(&value).map(|x| *x);\n+                let item_index = self.item_refs.find_equiv(&value).map(|x| *x);\n \n                 match item_index {\n                     Some(item_index) => {\n-                        self.this.collect_item(item_index, local_def(item.id))\n+                        self.collect_item(item_index, local_def(item.id))\n                     }\n                     None => {}\n                 }\n@@ -135,8 +131,8 @@ impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n     }\n }\n \n-impl LanguageItemCollector {\n-    pub fn new(session: Session) -> LanguageItemCollector {\n+impl<'a> LanguageItemCollector<'a> {\n+    pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n         let mut item_refs = HashMap::new();\n \n         $( item_refs.insert($name, $variant as uint); )*\n@@ -165,12 +161,11 @@ impl LanguageItemCollector {\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {\n-        let mut v = LanguageItemVisitor { this: self };\n-        visit::walk_crate(&mut v, krate, ());\n+        visit::walk_crate(self, krate, ());\n     }\n \n     pub fn collect_external_language_items(&mut self) {\n-        let crate_store = self.session.cstore;\n+        let crate_store = &self.session.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_lang_item(crate_store, crate_number, |node_id, item_index| {\n                 let def_id = ast::DefId { krate: crate_number, node: node_id };\n@@ -200,7 +195,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n }\n \n pub fn collect_language_items(krate: &ast::Crate,\n-                              session: Session) -> @LanguageItems {\n+                              session: &Session) -> @LanguageItems {\n     let mut collector = LanguageItemCollector::new(session);\n     collector.collect(krate);\n     let LanguageItemCollector { items, .. } = collector;"}, {"sha": "6ea26a9c5aab3ca7ab1320dc64de0b1d22a4783c", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -427,7 +427,7 @@ struct Context<'a> {\n     // Current levels of each lint warning\n     cur: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     // maps from an expression id that corresponds to a method call to the\n     // details of the method to be invoked\n     method_map: typeck::MethodMap,\n@@ -530,7 +530,7 @@ impl<'a> Context<'a> {\n         // of what we changed so we can roll everything back after invoking the\n         // specified closure\n         let mut pushed = 0u;\n-        each_lint(self.tcx.sess, attrs, |meta, level, lintname| {\n+        each_lint(&self.tcx.sess, attrs, |meta, level, lintname| {\n             match self.dict.find_equiv(&lintname) {\n                 None => {\n                     self.span_lint(\n@@ -594,7 +594,7 @@ impl<'a> Context<'a> {\n \n // Check that every lint from the list of attributes satisfies `f`.\n // Return true if that's the case. Otherwise return false.\n-pub fn each_lint(sess: session::Session,\n+pub fn each_lint(sess: &session::Session,\n                  attrs: &[ast::Attribute],\n                  f: |@ast::MetaItem, level, InternedString| -> bool)\n                  -> bool {\n@@ -670,7 +670,7 @@ fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n     }\n }\n impl<'a> AstConv for Context<'a>{\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         ty::lookup_item_type(self.tcx, id)\n@@ -795,7 +795,7 @@ fn check_type_limits(cx: &Context, e: &ast::Expr) {\n         }\n     }\n \n-    fn check_limits(tcx: ty::ctxt, binop: ast::BinOp,\n+    fn check_limits(tcx: &ty::ctxt, binop: ast::BinOp,\n                     l: &ast::Expr, r: &ast::Expr) -> bool {\n         let (lit, expr, swap) = match (&l.node, &r.node) {\n             (&ast::ExprLit(_), _) => (l, r, true),\n@@ -1100,7 +1100,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n                     _ => {}\n                 }\n             } else {\n-                csearch::get_item_attrs(cx.tcx.sess.cstore, did, |attrs| {\n+                csearch::get_item_attrs(&cx.tcx.sess.cstore, did, |attrs| {\n                     if attr::contains_name(attrs.as_slice(), \"must_use\") {\n                         cx.span_lint(UnusedMustUse, s.span,\n                                      \"unused result which must be used\");\n@@ -1562,7 +1562,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n         let mut s = None;\n         // run through all the attributes and take the first\n         // stability one.\n-        csearch::get_item_attrs(cx.tcx.cstore, id, |meta_items| {\n+        csearch::get_item_attrs(&cx.tcx.sess.cstore, id, |meta_items| {\n             if s.is_none() {\n                 s = attr::find_stability(meta_items.move_iter())\n             }\n@@ -1749,7 +1749,7 @@ impl<'a> IdVisitingOperation for Context<'a> {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n                    exported_items: &privacy::ExportedItems,\n                    krate: &ast::Crate) {"}, {"sha": "2d4cbee243e89aff59a37ba2a7caf6dcff9f4e6c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 322, "deletions": 430, "changes": 752, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -111,9 +111,9 @@ use middle::moves;\n use util::nodemap::NodeMap;\n \n use std::cast::transmute;\n-use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::io;\n+use std::rc::Rc;\n use std::str;\n use std::uint;\n use std::vec_ng::Vec;\n@@ -126,9 +126,9 @@ use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n \n #[deriving(Eq)]\n-pub struct Variable(uint);\n+struct Variable(uint);\n #[deriving(Eq)]\n-pub struct LiveNode(uint);\n+struct LiveNode(uint);\n \n impl Variable {\n     fn get(&self) -> uint { let Variable(v) = *self; v }\n@@ -145,15 +145,15 @@ impl Clone for LiveNode {\n }\n \n #[deriving(Eq)]\n-pub enum LiveNodeKind {\n+enum LiveNodeKind {\n     FreeVarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n     ExitNode\n }\n \n-fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n-    let cm = cx.sess.codemap;\n+fn live_node_kind_to_str(lnk: LiveNodeKind, cx: &ty::ctxt) -> ~str {\n+    let cm = cx.sess.codemap();\n     match lnk {\n         FreeVarNode(s) => format!(\"Free var node [{}]\", cm.span_to_str(s)),\n         ExprNode(s)    => format!(\"Expr node [{}]\", cm.span_to_str(s)),\n@@ -162,25 +162,20 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     }\n }\n \n-struct LivenessVisitor;\n-\n-impl Visitor<@IrMaps> for LivenessVisitor {\n-    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, e: @IrMaps) {\n-        visit_fn(self, fk, fd, b, s, n, e);\n+impl<'a> Visitor<()> for IrMaps<'a> {\n+    fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n+        visit_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local, e: @IrMaps) { visit_local(self, l, e); }\n-    fn visit_expr(&mut self, ex: &Expr, e: @IrMaps) { visit_expr(self, ex, e); }\n-    fn visit_arm(&mut self, a: &Arm, e: @IrMaps) { visit_arm(self, a, e); }\n+    fn visit_local(&mut self, l: &Local, _: ()) { visit_local(self, l); }\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) { visit_expr(self, ex); }\n+    fn visit_arm(&mut self, a: &Arm, _: ()) { visit_arm(self, a); }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: typeck::MethodMap,\n-                   capture_map: moves::CaptureMap,\n+                   capture_map: &moves::CaptureMap,\n                    krate: &Crate) {\n-    let mut visitor = LivenessVisitor;\n-\n-    let initial_maps = @IrMaps(tcx, method_map, capture_map);\n-    visit::walk_crate(&mut visitor, krate, initial_maps);\n+    visit::walk_crate(&mut IrMaps(tcx, method_map, capture_map), krate, ());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -219,104 +214,97 @@ impl fmt::Show for Variable {\n // assignment.  And so forth.\n \n impl LiveNode {\n-    pub fn is_valid(&self) -> bool {\n+    fn is_valid(&self) -> bool {\n         self.get() != uint::MAX\n     }\n }\n \n fn invalid_node() -> LiveNode { LiveNode(uint::MAX) }\n \n-pub struct CaptureInfo {\n+struct CaptureInfo {\n     ln: LiveNode,\n     is_move: bool,\n     var_nid: NodeId\n }\n \n-pub enum LocalKind {\n+enum LocalKind {\n     FromMatch(BindingMode),\n     FromLetWithInitializer,\n     FromLetNoInitializer\n }\n \n-pub struct LocalInfo {\n+struct LocalInfo {\n     id: NodeId,\n     ident: Ident,\n     is_mutbl: bool,\n     kind: LocalKind,\n }\n \n-pub enum VarKind {\n+enum VarKind {\n     Arg(NodeId, Ident),\n     Local(LocalInfo),\n     ImplicitRet\n }\n \n-pub struct IrMaps {\n-    tcx: ty::ctxt,\n+struct IrMaps<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: typeck::MethodMap,\n-    capture_map: moves::CaptureMap,\n-\n-    num_live_nodes: Cell<uint>,\n-    num_vars: Cell<uint>,\n-    live_node_map: RefCell<NodeMap<LiveNode>>,\n-    variable_map: RefCell<NodeMap<Variable>>,\n-    capture_info_map: RefCell<NodeMap<@Vec<CaptureInfo> >>,\n-    var_kinds: RefCell<Vec<VarKind> >,\n-    lnks: RefCell<Vec<LiveNodeKind> >,\n+    capture_map: &'a moves::CaptureMap,\n+\n+    num_live_nodes: uint,\n+    num_vars: uint,\n+    live_node_map: NodeMap<LiveNode>,\n+    variable_map: NodeMap<Variable>,\n+    capture_info_map: NodeMap<Rc<Vec<CaptureInfo>>>,\n+    var_kinds: Vec<VarKind>,\n+    lnks: Vec<LiveNodeKind>,\n }\n \n-fn IrMaps(tcx: ty::ctxt,\n-          method_map: typeck::MethodMap,\n-          capture_map: moves::CaptureMap)\n-       -> IrMaps {\n+fn IrMaps<'a>(tcx: &'a ty::ctxt,\n+              method_map: typeck::MethodMap,\n+              capture_map: &'a moves::CaptureMap)\n+              -> IrMaps<'a> {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n         capture_map: capture_map,\n-        num_live_nodes: Cell::new(0),\n-        num_vars: Cell::new(0),\n-        live_node_map: RefCell::new(NodeMap::new()),\n-        variable_map: RefCell::new(NodeMap::new()),\n-        capture_info_map: RefCell::new(NodeMap::new()),\n-        var_kinds: RefCell::new(Vec::new()),\n-        lnks: RefCell::new(Vec::new()),\n+        num_live_nodes: 0,\n+        num_vars: 0,\n+        live_node_map: NodeMap::new(),\n+        variable_map: NodeMap::new(),\n+        capture_info_map: NodeMap::new(),\n+        var_kinds: Vec::new(),\n+        lnks: Vec::new(),\n     }\n }\n \n-impl IrMaps {\n-    pub fn add_live_node(&self, lnk: LiveNodeKind) -> LiveNode {\n-        let num_live_nodes = self.num_live_nodes.get();\n-        let ln = LiveNode(num_live_nodes);\n-        let mut lnks = self.lnks.borrow_mut();\n-        lnks.get().push(lnk);\n-        self.num_live_nodes.set(num_live_nodes + 1);\n+impl<'a> IrMaps<'a> {\n+    fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n+        let ln = LiveNode(self.num_live_nodes);\n+        self.lnks.push(lnk);\n+        self.num_live_nodes += 1;\n \n         debug!(\"{} is of kind {}\", ln.to_str(),\n                live_node_kind_to_str(lnk, self.tcx));\n \n         ln\n     }\n \n-    pub fn add_live_node_for_node(&self, node_id: NodeId, lnk: LiveNodeKind) {\n+    fn add_live_node_for_node(&mut self, node_id: NodeId, lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n-        let mut live_node_map = self.live_node_map.borrow_mut();\n-        live_node_map.get().insert(node_id, ln);\n+        self.live_node_map.insert(node_id, ln);\n \n         debug!(\"{} is node {}\", ln.to_str(), node_id);\n     }\n \n-    pub fn add_variable(&self, vk: VarKind) -> Variable {\n-        let v = Variable(self.num_vars.get());\n-        {\n-            let mut var_kinds = self.var_kinds.borrow_mut();\n-            var_kinds.get().push(vk);\n-        }\n-        self.num_vars.set(self.num_vars.get() + 1);\n+    fn add_variable(&mut self, vk: VarKind) -> Variable {\n+        let v = Variable(self.num_vars);\n+        self.var_kinds.push(vk);\n+        self.num_vars += 1;\n \n         match vk {\n             Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n-                let mut variable_map = self.variable_map.borrow_mut();\n-                variable_map.get().insert(node_id, v);\n+                self.variable_map.insert(node_id, v);\n             },\n             ImplicitRet => {}\n         }\n@@ -326,9 +314,8 @@ impl IrMaps {\n         v\n     }\n \n-    pub fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n-        let variable_map = self.variable_map.borrow();\n-        match variable_map.get().find(&node_id) {\n+    fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n+        match self.variable_map.find(&node_id) {\n           Some(&var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n@@ -337,38 +324,25 @@ impl IrMaps {\n         }\n     }\n \n-    pub fn variable_name(&self, var: Variable) -> ~str {\n-        let var_kinds = self.var_kinds.borrow();\n-        match var_kinds.get().get(var.get()) {\n+    fn variable_name(&self, var: Variable) -> ~str {\n+        match self.var_kinds.get(var.get()) {\n             &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n                 token::get_ident(nm).get().to_str()\n             },\n             &ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n-    pub fn set_captures(&self, node_id: NodeId, cs: Vec<CaptureInfo> ) {\n-        let mut capture_info_map = self.capture_info_map.borrow_mut();\n-        capture_info_map.get().insert(node_id, @cs);\n+    fn set_captures(&mut self, node_id: NodeId, cs: Vec<CaptureInfo>) {\n+        self.capture_info_map.insert(node_id, Rc::new(cs));\n     }\n \n-    pub fn captures(&self, expr: &Expr) -> @Vec<CaptureInfo> {\n-        let capture_info_map = self.capture_info_map.borrow();\n-        match capture_info_map.get().find(&expr.id) {\n-          Some(&caps) => caps,\n-          None => {\n-            self.tcx.sess.span_bug(expr.span, \"no registered caps\");\n-          }\n-        }\n-    }\n-\n-    pub fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n-        let lnks = self.lnks.borrow();\n-        *lnks.get().get(ln.get())\n+    fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n+        *self.lnks.get(ln.get())\n     }\n }\n \n-impl Visitor<()> for Liveness {\n+impl<'a> Visitor<()> for Liveness<'a> {\n     fn visit_fn(&mut self, fk: &FnKind, fd: &FnDecl, b: &Block, s: Span, n: NodeId, _: ()) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n@@ -383,25 +357,24 @@ impl Visitor<()> for Liveness {\n     }\n }\n \n-fn visit_fn(v: &mut LivenessVisitor,\n+fn visit_fn(ir: &mut IrMaps,\n             fk: &FnKind,\n             decl: &FnDecl,\n             body: &Block,\n             sp: Span,\n-            id: NodeId,\n-            this: @IrMaps) {\n+            id: NodeId) {\n     debug!(\"visit_fn: id={}\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let fn_maps = @IrMaps(this.tcx, this.method_map, this.capture_map);\n+    let mut fn_maps = IrMaps(ir.tcx, ir.method_map, ir.capture_map);\n \n     unsafe {\n-        debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(fn_maps));\n+        debug!(\"creating fn_maps: {}\", transmute::<&IrMaps, *IrMaps>(&fn_maps));\n     }\n \n     for arg in decl.inputs.iter() {\n-        pat_util::pat_bindings(this.tcx.def_map,\n+        pat_util::pat_bindings(ir.tcx.def_map,\n                                arg.pat,\n                                |_bm, arg_id, _x, path| {\n             debug!(\"adding argument {}\", arg_id);\n@@ -412,7 +385,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    visit::walk_fn(v, fk, decl, body, sp, id, fn_maps);\n+    visit::walk_fn(&mut fn_maps, fk, decl, body, sp, id, ());\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n@@ -425,7 +398,7 @@ fn visit_fn(v: &mut LivenessVisitor,\n     };\n \n     // compute liveness\n-    let mut lsets = Liveness(fn_maps, specials);\n+    let mut lsets = Liveness(&mut fn_maps, specials);\n     let entry_ln = lsets.compute(decl, body);\n \n     // check for various error conditions\n@@ -434,12 +407,11 @@ fn visit_fn(v: &mut LivenessVisitor,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(v: &mut LivenessVisitor, local: &Local, this: @IrMaps) {\n-    let def_map = this.tcx.def_map;\n-    pat_util::pat_bindings(def_map, local.pat, |bm, p_id, sp, path| {\n+fn visit_local(ir: &mut IrMaps, local: &Local) {\n+    pat_util::pat_bindings(ir.tcx.def_map, local.pat, |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n-        this.add_live_node_for_node(p_id, VarDefNode(sp));\n+        ir.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.init {\n           Some(_) => FromLetWithInitializer,\n           None => FromLetNoInitializer\n@@ -448,67 +420,63 @@ fn visit_local(v: &mut LivenessVisitor, local: &Local, this: @IrMaps) {\n             BindByValue(MutMutable) => true,\n             _ => false\n         };\n-        this.add_variable(Local(LocalInfo {\n+        ir.add_variable(Local(LocalInfo {\n           id: p_id,\n           ident: name,\n           is_mutbl: mutbl,\n           kind: kind\n         }));\n     });\n-    visit::walk_local(v, local, this);\n+    visit::walk_local(ir, local, ());\n }\n \n-fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @IrMaps) {\n-    let def_map = this.tcx.def_map;\n+fn visit_arm(ir: &mut IrMaps, arm: &Arm) {\n     for pat in arm.pats.iter() {\n-        pat_util::pat_bindings(def_map, *pat, |bm, p_id, sp, path| {\n+        pat_util::pat_bindings(ir.tcx.def_map, *pat, |bm, p_id, sp, path| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n             let mutbl = match bm {\n                 BindByValue(MutMutable) => true,\n                 _ => false\n             };\n-            this.add_live_node_for_node(p_id, VarDefNode(sp));\n-            this.add_variable(Local(LocalInfo {\n+            ir.add_live_node_for_node(p_id, VarDefNode(sp));\n+            ir.add_variable(Local(LocalInfo {\n                 id: p_id,\n                 ident: name,\n                 is_mutbl: mutbl,\n                 kind: FromMatch(bm)\n             }));\n         })\n     }\n-    visit::walk_arm(v, arm, this);\n+    visit::walk_arm(ir, arm, ());\n }\n \n-fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n+fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ExprPath(_) => {\n-        let def_map = this.tcx.def_map.borrow();\n-        let def = def_map.get().get_copy(&expr.id);\n+        let def = ir.tcx.def_map.borrow().get().get_copy(&expr.id);\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n-            this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+            ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        visit::walk_expr(v, expr, this);\n+        visit::walk_expr(ir, expr, ());\n       }\n       ExprFnBlock(..) | ExprProc(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n-        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n \n         // Make a live_node for each captured variable, with the span\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n         // construction site.\n-        let capture_map = this.capture_map.borrow();\n-        let cvs = capture_map.get().get(&expr.id);\n         let mut call_caps = Vec::new();\n-        for cv in cvs.deref().iter() {\n+        for cv in ir.capture_map.get(&expr.id).deref().iter() {\n             match moves::moved_variable_node_id_from_def(cv.def) {\n               Some(rv) => {\n-                let cv_ln = this.add_live_node(FreeVarNode(cv.span));\n+                let cv_ln = ir.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n                     // var must be dead afterwards\n                     moves::CapMove => true,\n@@ -523,20 +491,20 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n               None => {}\n             }\n         }\n-        this.set_captures(expr.id, call_caps);\n+        ir.set_captures(expr.id, call_caps);\n \n-        visit::walk_expr(v, expr, this);\n+        visit::walk_expr(ir, expr, ());\n       }\n \n       // live nodes required for interesting control flow:\n       ExprIf(..) | ExprMatch(..) | ExprWhile(..) | ExprLoop(..) => {\n-        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(v, expr, this);\n+        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        visit::walk_expr(ir, expr, ());\n       }\n       ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n       ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n-        this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        visit::walk_expr(v, expr, this);\n+        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        visit::walk_expr(ir, expr, ());\n       }\n \n       // otherwise, live nodes are not required:\n@@ -548,7 +516,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n       ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n       ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n       ExprInlineAsm(..) | ExprBox(..) => {\n-          visit::walk_expr(v, expr, this);\n+          visit::walk_expr(ir, expr, ());\n       }\n     }\n }\n@@ -560,7 +528,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n // the same basic propagation framework in all cases.\n \n #[deriving(Clone)]\n-pub struct Users {\n+struct Users {\n     reader: LiveNode,\n     writer: LiveNode,\n     used: bool\n@@ -574,7 +542,7 @@ fn invalid_users() -> Users {\n     }\n }\n \n-pub struct Specials {\n+struct Specials {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n     no_ret_var: Variable\n@@ -584,76 +552,66 @@ static ACC_READ: uint = 1u;\n static ACC_WRITE: uint = 2u;\n static ACC_USE: uint = 4u;\n \n-pub type LiveNodeMap = @RefCell<NodeMap<LiveNode>>;\n-\n-pub struct Liveness {\n-    tcx: ty::ctxt,\n-    ir: @IrMaps,\n+struct Liveness<'a> {\n+    ir: &'a mut IrMaps<'a>,\n     s: Specials,\n-    successors: @RefCell<Vec<LiveNode> >,\n-    users: @RefCell<Vec<Users> >,\n+    successors: Vec<LiveNode>,\n+    users: Vec<Users>,\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n-    loop_scope: @RefCell<Vec<NodeId> >,\n+    loop_scope: Vec<NodeId>,\n     // mappings from loop node ID to LiveNode\n     // (\"break\" label should map to loop node ID,\n     // it probably doesn't now)\n-    break_ln: LiveNodeMap,\n-    cont_ln: LiveNodeMap\n+    break_ln: NodeMap<LiveNode>,\n+    cont_ln: NodeMap<LiveNode>\n }\n \n-fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n+fn Liveness<'a>(ir: &'a mut IrMaps<'a>, specials: Specials) -> Liveness<'a> {\n     Liveness {\n         ir: ir,\n-        tcx: ir.tcx,\n         s: specials,\n-        successors: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get(),\n-                                                 invalid_node())),\n-        users: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get() *\n-                                            ir.num_vars.get(),\n-                                            invalid_users())),\n-        loop_scope: @RefCell::new(Vec::new()),\n-        break_ln: @RefCell::new(NodeMap::new()),\n-        cont_ln: @RefCell::new(NodeMap::new()),\n+        successors: Vec::from_elem(ir.num_live_nodes, invalid_node()),\n+        users: Vec::from_elem(ir.num_live_nodes * ir.num_vars, invalid_users()),\n+        loop_scope: Vec::new(),\n+        break_ln: NodeMap::new(),\n+        cont_ln: NodeMap::new(),\n     }\n }\n \n-impl Liveness {\n-    pub fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n-        let ir: &IrMaps = self.ir;\n-        let live_node_map = ir.live_node_map.borrow();\n-        match live_node_map.get().find(&node_id) {\n+impl<'a> Liveness<'a> {\n+    fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n+        match self.ir.live_node_map.find(&node_id) {\n           Some(&ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n             // above and the propagation code below; the two sets of\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n-            self.tcx.sess.span_bug(\n+            self.ir.tcx.sess.span_bug(\n                 span, format!(\"no live node registered for node {}\",\n                            node_id));\n           }\n         }\n     }\n \n-    pub fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n+    fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n         self.ir.variable(node_id, span)\n     }\n \n-    pub fn pat_bindings(&self,\n-                        pat: @Pat,\n-                        f: |LiveNode, Variable, Span, NodeId|) {\n-        let def_map = self.tcx.def_map;\n-        pat_util::pat_bindings(def_map, pat, |_bm, p_id, sp, _n| {\n+    fn pat_bindings(&mut self,\n+                    pat: &Pat,\n+                    f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n+        pat_util::pat_bindings(self.ir.tcx.def_map, pat, |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n-            f(ln, var, sp, p_id);\n+            f(self, ln, var, sp, p_id);\n         })\n     }\n \n-    pub fn arm_pats_bindings(&self,\n-                             pats: &[@Pat],\n-                             f: |LiveNode, Variable, Span, NodeId|) {\n+    fn arm_pats_bindings(&mut self,\n+                         pats: &[@Pat],\n+                         f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -662,86 +620,77 @@ impl Liveness {\n         }\n     }\n \n-    pub fn define_bindings_in_pat(&self, pat: @Pat, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn define_bindings_in_pat(&mut self, pat: @Pat, succ: LiveNode)\n+                              -> LiveNode {\n         self.define_bindings_in_arm_pats([pat], succ)\n     }\n \n-    pub fn define_bindings_in_arm_pats(&self, pats: &[@Pat], succ: LiveNode)\n-                                       -> LiveNode {\n+    fn define_bindings_in_arm_pats(&mut self, pats: &[@Pat], succ: LiveNode)\n+                                   -> LiveNode {\n         let mut succ = succ;\n-        self.arm_pats_bindings(pats, |ln, var, _sp, _id| {\n-            self.init_from_succ(ln, succ);\n-            self.define(ln, var);\n+        self.arm_pats_bindings(pats, |this, ln, var, _sp, _id| {\n+            this.init_from_succ(ln, succ);\n+            this.define(ln, var);\n             succ = ln;\n         });\n         succ\n     }\n \n-    pub fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n-        ln.get() * self.ir.num_vars.get() + var.get()\n+    fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n+        ln.get() * self.ir.num_vars + var.get()\n     }\n \n-    pub fn live_on_entry(&self, ln: LiveNode, var: Variable)\n-                         -> Option<LiveNodeKind> {\n+    fn live_on_entry(&self, ln: LiveNode, var: Variable)\n+                      -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let users = self.users.borrow();\n-        let reader = users.get().get(self.idx(ln, var)).reader;\n+        let reader = self.users.get(self.idx(ln, var)).reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n     /*\n     Is this variable live on entry to any of its successor nodes?\n     */\n-    pub fn live_on_exit(&self, ln: LiveNode, var: Variable)\n-                        -> Option<LiveNodeKind> {\n-        let successor = {\n-            let successors = self.successors.borrow();\n-            *successors.get().get(ln.get())\n-        };\n+    fn live_on_exit(&self, ln: LiveNode, var: Variable)\n+                    -> Option<LiveNodeKind> {\n+        let successor = *self.successors.get(ln.get());\n         self.live_on_entry(successor, var)\n     }\n \n-    pub fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n+    fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        let users = self.users.borrow();\n-        users.get().get(self.idx(ln, var)).used\n+        self.users.get(self.idx(ln, var)).used\n     }\n \n-    pub fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n-                             -> Option<LiveNodeKind> {\n+    fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n+                         -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let users = self.users.borrow();\n-        let writer = users.get().get(self.idx(ln, var)).writer;\n+        let writer = self.users.get(self.idx(ln, var)).writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n-    pub fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n-                            -> Option<LiveNodeKind> {\n-        let successor = {\n-            let successors = self.successors.borrow();\n-            *successors.get().get(ln.get())\n-        };\n+    fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n+                        -> Option<LiveNodeKind> {\n+        let successor = *self.successors.get(ln.get());\n         self.assigned_on_entry(successor, var)\n     }\n \n-    pub fn indices2(&self,\n-                    ln: LiveNode,\n-                    succ_ln: LiveNode,\n-                    op: |uint, uint|) {\n+    fn indices2(&mut self,\n+                ln: LiveNode,\n+                succ_ln: LiveNode,\n+                op: |&mut Liveness<'a>, uint, uint|) {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n-        for var_idx in range(0u, self.ir.num_vars.get()) {\n-            op(node_base_idx + var_idx, succ_base_idx + var_idx);\n+        for var_idx in range(0u, self.ir.num_vars) {\n+            op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n \n-    pub fn write_vars(&self,\n-                      wr: &mut io::Writer,\n-                      ln: LiveNode,\n-                      test: |uint| -> LiveNode) -> io::IoResult<()> {\n+    fn write_vars(&self,\n+                  wr: &mut io::Writer,\n+                  ln: LiveNode,\n+                  test: |uint| -> LiveNode) -> io::IoResult<()> {\n         let node_base_idx = self.idx(ln, Variable(0));\n-        for var_idx in range(0u, self.ir.num_vars.get()) {\n+        for var_idx in range(0u, self.ir.num_vars) {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 try!(write!(wr, \" {}\", Variable(var_idx).to_str()));\n@@ -750,28 +699,26 @@ impl Liveness {\n         Ok(())\n     }\n \n-    pub fn find_loop_scope(&self,\n-                           opt_label: Option<Ident>,\n-                           id: NodeId,\n-                           sp: Span)\n-                           -> NodeId {\n+    fn find_loop_scope(&self,\n+                       opt_label: Option<Ident>,\n+                       id: NodeId,\n+                       sp: Span)\n+                       -> NodeId {\n         match opt_label {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                let def_map = self.tcx.def_map.borrow();\n-                match def_map.get().find(&id) {\n+                match self.ir.tcx.def_map.borrow().get().find(&id) {\n                     Some(&DefLabel(loop_id)) => loop_id,\n-                    _ => self.tcx.sess.span_bug(sp, \"label on break/loop \\\n-                                                     doesn't refer to a loop\")\n+                    _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n+                                                        doesn't refer to a loop\")\n                 }\n             }\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                let loop_scope = self.loop_scope.borrow();\n-                if loop_scope.get().len() == 0 {\n-                    self.tcx.sess.span_bug(sp, \"break outside loop\");\n+                if self.loop_scope.len() == 0 {\n+                    self.ir.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     // FIXME(#5275): this shouldn't have to be a method...\n                     self.last_loop_scope()\n@@ -780,54 +727,26 @@ impl Liveness {\n         }\n     }\n \n-    pub fn last_loop_scope(&self) -> NodeId {\n-        let loop_scope = self.loop_scope.borrow();\n-        *loop_scope.get().last().unwrap()\n+    fn last_loop_scope(&self) -> NodeId {\n+        *self.loop_scope.last().unwrap()\n     }\n \n     #[allow(unused_must_use)]\n-    pub fn ln_str(&self, ln: LiveNode) -> ~str {\n+    fn ln_str(&self, ln: LiveNode) -> ~str {\n         let mut wr = io::MemWriter::new();\n         {\n             let wr = &mut wr as &mut io::Writer;\n-            {\n-                let lnks = self.ir.lnks.try_borrow();\n-                write!(wr,\n-                       \"[ln({}) of kind {:?} reads\",\n-                       ln.get(),\n-                       lnks.and_then(|lnks| Some(*lnks.get().get(ln.get()))));\n-            }\n-            let users = self.users.try_borrow();\n-            match users {\n-                Some(users) => {\n-                    self.write_vars(wr, ln, |idx| users.get().get(idx).reader);\n-                    write!(wr, \"  writes\");\n-                    self.write_vars(wr, ln, |idx| users.get().get(idx).writer);\n-                }\n-                None => {\n-                    write!(wr, \"  (users borrowed)\");\n-                }\n-            }\n-            let successors = self.successors.try_borrow();\n-            match successors {\n-                Some(successors) => {\n-                    write!(wr,\n-                           \"  precedes {}]\",\n-                           successors.get().get(ln.get()).to_str());\n-                }\n-                None => {\n-                    write!(wr, \"  precedes (successors borrowed)]\");\n-                }\n-            }\n+            write!(wr, \"[ln({}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n+            self.write_vars(wr, ln, |idx| self.users.get(idx).reader);\n+            write!(wr, \"  writes\");\n+            self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n+            write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_str());\n         }\n         str::from_utf8_owned(wr.unwrap()).unwrap()\n     }\n \n-    pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n-        {\n-            let mut successors = self.successors.borrow_mut();\n-            *successors.get().get_mut(ln.get()) = succ_ln;\n-        }\n+    fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n+        *self.successors.get_mut(ln.get()) = succ_ln;\n \n         // It is not necessary to initialize the\n         // values to empty because this is the value\n@@ -839,37 +758,32 @@ impl Liveness {\n         // }\n     }\n \n-    pub fn init_from_succ(&self, ln: LiveNode, succ_ln: LiveNode) {\n+    fn init_from_succ(&mut self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n-        {\n-            let mut successors = self.successors.borrow_mut();\n-            *successors.get().get_mut(ln.get()) = succ_ln;\n-        }\n+        *self.successors.get_mut(ln.get()) = succ_ln;\n \n-        self.indices2(ln, succ_ln, |idx, succ_idx| {\n-            let mut users = self.users.borrow_mut();\n-            *users.get().get_mut(idx) = *users.get().get(succ_idx)\n+        self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n+            *this.users.get_mut(idx) = *this.users.get(succ_idx)\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n-    pub fn merge_from_succ(&self,\n-                           ln: LiveNode,\n-                           succ_ln: LiveNode,\n-                           first_merge: bool)\n-                           -> bool {\n+    fn merge_from_succ(&mut self,\n+                       ln: LiveNode,\n+                       succ_ln: LiveNode,\n+                       first_merge: bool)\n+                       -> bool {\n         if ln == succ_ln { return false; }\n \n         let mut changed = false;\n-        self.indices2(ln, succ_ln, |idx, succ_idx| {\n-            let mut users = self.users.borrow_mut();\n-            changed |= copy_if_invalid(users.get().get(succ_idx).reader,\n-                                       &mut users.get().get_mut(idx).reader);\n-            changed |= copy_if_invalid(users.get().get(succ_idx).writer,\n-                                       &mut users.get().get_mut(idx).writer);\n-            if users.get().get(succ_idx).used && !users.get().get(idx).used {\n-                users.get().get_mut(idx).used = true;\n+        self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n+            changed |= copy_if_invalid(this.users.get(succ_idx).reader,\n+                                       &mut this.users.get_mut(idx).reader);\n+            changed |= copy_if_invalid(this.users.get(succ_idx).writer,\n+                                       &mut this.users.get_mut(idx).writer);\n+            if this.users.get(succ_idx).used && !this.users.get(idx).used {\n+                this.users.get_mut(idx).used = true;\n                 changed = true;\n             }\n         });\n@@ -879,34 +793,34 @@ impl Liveness {\n         return changed;\n \n         fn copy_if_invalid(src: LiveNode, dst: &mut LiveNode) -> bool {\n-            if src.is_valid() {\n-                if !dst.is_valid() {\n-                    *dst = src;\n-                    return true;\n-                }\n+            if src.is_valid() && !dst.is_valid() {\n+                *dst = src;\n+                true\n+            } else {\n+                false\n             }\n-            return false;\n         }\n     }\n \n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n-    pub fn define(&self, writer: LiveNode, var: Variable) {\n+    fn define(&mut self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n-        let mut users = self.users.borrow_mut();\n-        users.get().get_mut(idx).reader = invalid_node();\n-        users.get().get_mut(idx).writer = invalid_node();\n+        self.users.get_mut(idx).reader = invalid_node();\n+        self.users.get_mut(idx).writer = invalid_node();\n \n         debug!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n     }\n \n     // Either read, write, or both depending on the acc bitset\n-    pub fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n+    fn acc(&mut self, ln: LiveNode, var: Variable, acc: uint) {\n+        debug!(\"{} accesses[{:x}] {}: {}\",\n+               ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n+\n         let idx = self.idx(ln, var);\n-        let mut users = self.users.borrow_mut();\n-        let user = users.get().get_mut(idx);\n+        let user = self.users.get_mut(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();\n@@ -922,14 +836,11 @@ impl Liveness {\n         if (acc & ACC_USE) != 0 {\n             user.used = true;\n         }\n-\n-        debug!(\"{} accesses[{:x}] {}: {}\",\n-               ln.to_str(), acc, var.to_str(), self.ln_str(ln));\n     }\n \n     // _______________________________________________________________________\n \n-    pub fn compute(&self, decl: &FnDecl, body: &Block) -> LiveNode {\n+    fn compute(&mut self, decl: &FnDecl, body: &Block) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -938,12 +849,12 @@ impl Liveness {\n \n         let entry_ln: LiveNode =\n             self.with_loop_nodes(body.id, self.s.exit_ln, self.s.exit_ln,\n-              || { self.propagate_through_fn_block(decl, body) });\n+              |this| this.propagate_through_fn_block(decl, body));\n \n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={})\",\n                {\n-                   for ln_idx in range(0u, self.ir.num_live_nodes.get()) {\n+                   for ln_idx in range(0u, self.ir.num_live_nodes) {\n                        debug!(\"{}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id\n@@ -953,8 +864,8 @@ impl Liveness {\n         entry_ln\n     }\n \n-    pub fn propagate_through_fn_block(&self, _: &FnDecl, blk: &Block)\n-                                      -> LiveNode {\n+    fn propagate_through_fn_block(&mut self, _: &FnDecl, blk: &Block)\n+                                  -> LiveNode {\n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n         self.init_from_succ(self.s.fallthrough_ln, self.s.exit_ln);\n@@ -965,33 +876,33 @@ impl Liveness {\n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n     }\n \n-    pub fn propagate_through_block(&self, blk: &Block, succ: LiveNode)\n-                                   -> LiveNode {\n+    fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n+                               -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.expr, succ);\n         blk.stmts.rev_iter().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(*stmt, succ)\n         })\n     }\n \n-    pub fn propagate_through_stmt(&self, stmt: &Stmt, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_stmt(&mut self, stmt: &Stmt, succ: LiveNode)\n+                              -> LiveNode {\n         match stmt.node {\n-          StmtDecl(decl, _) => {\n-            return self.propagate_through_decl(decl, succ);\n-          }\n+            StmtDecl(decl, _) => {\n+                self.propagate_through_decl(decl, succ)\n+            }\n \n-          StmtExpr(expr, _) | StmtSemi(expr, _) => {\n-            return self.propagate_through_expr(expr, succ);\n-          }\n+            StmtExpr(expr, _) | StmtSemi(expr, _) => {\n+                self.propagate_through_expr(expr, succ)\n+            }\n \n-          StmtMac(..) => {\n-            self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n-          }\n+            StmtMac(..) => {\n+                self.ir.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n+            }\n         }\n     }\n \n-    pub fn propagate_through_decl(&self, decl: &Decl, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_decl(&mut self, decl: &Decl, succ: LiveNode)\n+                              -> LiveNode {\n         match decl.node {\n             DeclLocal(ref local) => {\n                 self.propagate_through_local(*local, succ)\n@@ -1000,8 +911,8 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_local(&self, local: &Local, succ: LiveNode)\n-                                   -> LiveNode {\n+    fn propagate_through_local(&mut self, local: &Local, succ: LiveNode)\n+                               -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n         // the live variable as defined if it was initialized, and then we\n@@ -1020,24 +931,24 @@ impl Liveness {\n         self.define_bindings_in_pat(local.pat, succ)\n     }\n \n-    pub fn propagate_through_exprs(&self, exprs: &[@Expr], succ: LiveNode)\n-                                   -> LiveNode {\n+    fn propagate_through_exprs(&mut self, exprs: &[@Expr], succ: LiveNode)\n+                               -> LiveNode {\n         exprs.rev_iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         })\n     }\n \n-    pub fn propagate_through_opt_expr(&self,\n-                                      opt_expr: Option<@Expr>,\n-                                      succ: LiveNode)\n-                                      -> LiveNode {\n+    fn propagate_through_opt_expr(&mut self,\n+                                  opt_expr: Option<@Expr>,\n+                                  succ: LiveNode)\n+                                  -> LiveNode {\n         opt_expr.iter().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         })\n     }\n \n-    pub fn propagate_through_expr(&self, expr: @Expr, succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n+                              -> LiveNode {\n         debug!(\"propagate_through_expr: {}\", expr_to_str(expr));\n \n         match expr.node {\n@@ -1058,16 +969,21 @@ impl Liveness {\n               The next-node for a break is the successor of the entire\n               loop. The next-node for a continue is the top of this loop.\n               */\n-              self.with_loop_nodes(blk.id, succ,\n-                  self.live_node(expr.id, expr.span), || {\n+              let node = self.live_node(expr.id, expr.span);\n+              self.with_loop_nodes(blk.id, succ, node, |this| {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n-                 let caps = self.ir.captures(expr);\n-                 caps.rev_iter().fold(succ, |succ, cap| {\n-                     self.init_from_succ(cap.ln, succ);\n-                     let var = self.variable(cap.var_nid, expr.span);\n-                     self.acc(cap.ln, var, ACC_READ | ACC_USE);\n+                 let caps = match this.ir.capture_info_map.find(&expr.id) {\n+                    Some(caps) => caps.clone(),\n+                    None => {\n+                        this.ir.tcx.sess.span_bug(expr.span, \"no registered caps\");\n+                     }\n+                 };\n+                 caps.deref().rev_iter().fold(succ, |succ, cap| {\n+                     this.init_from_succ(cap.ln, succ);\n+                     let var = this.variable(cap.var_nid, expr.span);\n+                     this.acc(cap.ln, var, ACC_READ | ACC_USE);\n                      cap.ln\n                  })\n               })\n@@ -1151,11 +1067,10 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              let break_ln = self.break_ln.borrow();\n-              match break_ln.get().find(&sc) {\n+              match self.break_ln.find(&sc) {\n                   Some(&b) => b,\n-                  None => self.tcx.sess.span_bug(expr.span,\n-                                                 \"break to unknown label\")\n+                  None => self.ir.tcx.sess.span_bug(expr.span,\n+                                                    \"break to unknown label\")\n               }\n           }\n \n@@ -1166,11 +1081,10 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n-              let cont_ln = self.cont_ln.borrow();\n-              match cont_ln.get().find(&sc) {\n+              match self.cont_ln.find(&sc) {\n                   Some(&b) => b,\n-                  None => self.tcx.sess.span_bug(expr.span,\n-                                                 \"loop to unknown label\")\n+                  None => self.ir.tcx.sess.span_bug(expr.span,\n+                                                    \"loop to unknown label\")\n               }\n           }\n \n@@ -1215,7 +1129,7 @@ impl Liveness {\n           ExprCall(f, ref args) => {\n             // calling a fn with bot return type means that the fn\n             // will fail, and hence the successors can be ignored\n-            let t_ret = ty::ty_fn_ret(ty::expr_ty(self.tcx, f));\n+            let t_ret = ty::ty_fn_ret(ty::expr_ty(self.ir.tcx, f));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n             let succ = self.propagate_through_exprs(args.as_slice(), succ);\n@@ -1225,7 +1139,7 @@ impl Liveness {\n           ExprMethodCall(_, _, ref args) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n-            let t_ret = ty::node_id_to_type(self.tcx, expr.id);\n+            let t_ret = ty::node_id_to_type(self.ir.tcx, expr.id);\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n             self.propagate_through_exprs(args.as_slice(), succ)\n@@ -1280,15 +1194,15 @@ impl Liveness {\n           }\n \n           ExprMac(..) => {\n-            self.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n+            self.ir.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n     }\n \n-    pub fn propagate_through_lvalue_components(&self,\n-                                               expr: @Expr,\n-                                               succ: LiveNode)\n-                                               -> LiveNode {\n+    fn propagate_through_lvalue_components(&mut self,\n+                                           expr: &Expr,\n+                                           succ: LiveNode)\n+                                           -> LiveNode {\n         // # Lvalues\n         //\n         // In general, the full flow graph structure for an\n@@ -1346,8 +1260,8 @@ impl Liveness {\n     }\n \n     // see comment on propagate_through_lvalue()\n-    pub fn write_lvalue(&self, expr: &Expr, succ: LiveNode, acc: uint)\n-                        -> LiveNode {\n+    fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n+                    -> LiveNode {\n         match expr.node {\n           ExprPath(_) => self.access_path(expr, succ, acc),\n \n@@ -1359,10 +1273,9 @@ impl Liveness {\n         }\n     }\n \n-    pub fn access_path(&self, expr: &Expr, succ: LiveNode, acc: uint)\n-                       -> LiveNode {\n-        let def_map = self.tcx.def_map.borrow();\n-        let def = def_map.get().get_copy(&expr.id);\n+    fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: uint)\n+                   -> LiveNode {\n+        let def = self.ir.tcx.def_map.borrow().get().get_copy(&expr.id);\n         match moves::moved_variable_node_id_from_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1377,12 +1290,12 @@ impl Liveness {\n         }\n     }\n \n-    pub fn propagate_through_loop(&self,\n-                                  expr: &Expr,\n-                                  cond: Option<@Expr>,\n-                                  body: &Block,\n-                                  succ: LiveNode)\n-                                  -> LiveNode {\n+    fn propagate_through_loop(&mut self,\n+                              expr: &Expr,\n+                              cond: Option<@Expr>,\n+                              body: &Block,\n+                              succ: LiveNode)\n+                              -> LiveNode {\n \n         /*\n \n@@ -1418,8 +1331,8 @@ impl Liveness {\n                expr.id, block_to_str(body));\n \n         let cond_ln = self.propagate_through_opt_expr(cond, ln);\n-        let body_ln = self.with_loop_nodes(expr.id, succ, ln, || {\n-            self.propagate_through_block(body, cond_ln)\n+        let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n+            this.propagate_through_block(body, cond_ln)\n         });\n \n         // repeat until fixed point is reached:\n@@ -1428,37 +1341,24 @@ impl Liveness {\n             assert!(cond_ln == self.propagate_through_opt_expr(cond,\n                                                                     ln));\n             assert!(body_ln == self.with_loop_nodes(expr.id, succ, ln,\n-            || {\n-                self.propagate_through_block(body, cond_ln)\n-            }));\n+            |this| this.propagate_through_block(body, cond_ln)));\n         }\n \n         cond_ln\n     }\n \n-    pub fn with_loop_nodes<R>(\n-                           &self,\n-                           loop_node_id: NodeId,\n-                           break_ln: LiveNode,\n-                           cont_ln: LiveNode,\n-                           f: || -> R)\n-                           -> R {\n+    fn with_loop_nodes<R>(&mut self,\n+                          loop_node_id: NodeId,\n+                          break_ln: LiveNode,\n+                          cont_ln: LiveNode,\n+                          f: |&mut Liveness<'a>| -> R)\n+                          -> R {\n         debug!(\"with_loop_nodes: {} {}\", loop_node_id, break_ln.get());\n-        {\n-            let mut loop_scope = self.loop_scope.borrow_mut();\n-            loop_scope.get().push(loop_node_id);\n-        }\n-        {\n-            let mut this_break_ln = self.break_ln.borrow_mut();\n-            let mut this_cont_ln = self.cont_ln.borrow_mut();\n-            this_break_ln.get().insert(loop_node_id, break_ln);\n-            this_cont_ln.get().insert(loop_node_id, cont_ln);\n-        }\n-        let r = f();\n-        {\n-            let mut loop_scope = self.loop_scope.borrow_mut();\n-            loop_scope.get().pop();\n-        }\n+        self.loop_scope.push(loop_node_id);\n+        self.break_ln.insert(loop_node_id, break_ln);\n+        self.cont_ln.insert(loop_node_id, cont_ln);\n+        let r = f(self);\n+        self.loop_scope.pop();\n         r\n     }\n }\n@@ -1472,7 +1372,7 @@ fn check_local(this: &mut Liveness, local: &Local) {\n             this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n         },\n         None => {\n-            this.pat_bindings(local.pat, |ln, var, sp, id| {\n+            this.pat_bindings(local.pat, |this, ln, var, sp, id| {\n                 this.warn_about_unused(sp, id, ln, var);\n             })\n         }\n@@ -1482,7 +1382,7 @@ fn check_local(this: &mut Liveness, local: &Local) {\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    this.arm_pats_bindings(arm.pats.as_slice(), |ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.as_slice(), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm, ());\n@@ -1542,37 +1442,30 @@ fn check_fn(_v: &Liveness,\n     // do not check contents of nested fns\n }\n \n-pub enum ReadKind {\n-    PossiblyUninitializedVariable,\n-    PossiblyUninitializedField,\n-    MovedValue,\n-    PartiallyMovedValue\n-}\n-\n-impl Liveness {\n-    pub fn check_ret(&self,\n-                     id: NodeId,\n-                     sp: Span,\n-                     _fk: &FnKind,\n-                     entry_ln: LiveNode,\n-                     body: &Block) {\n+impl<'a> Liveness<'a> {\n+    fn check_ret(&self,\n+                 id: NodeId,\n+                 sp: Span,\n+                 _fk: &FnKind,\n+                 entry_ln: LiveNode,\n+                 body: &Block) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n             // function without any kind of return expression:\n \n-            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, id));\n+            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.ir.tcx, id));\n             if ty::type_is_nil(t_ret) {\n                 // for nil return types, it is ok to not return a value expl.\n             } else if ty::type_is_bot(t_ret) {\n                 // for bot return types, not ok.  Function should fail.\n-                self.tcx.sess.span_err(\n+                self.ir.tcx.sess.span_err(\n                     sp, \"some control paths may return\");\n             } else {\n                 let ends_with_stmt = match body.expr {\n                     None if body.stmts.len() > 0 =>\n                         match body.stmts.last().unwrap().node {\n                             StmtSemi(e, _) => {\n-                                let t_stmt = ty::expr_ty(self.tcx, e);\n+                                let t_stmt = ty::expr_ty(self.ir.tcx, e);\n                                 ty::get(t_stmt).sty == ty::get(t_ret).sty\n                             },\n                             _ => false\n@@ -1586,20 +1479,19 @@ impl Liveness {\n                         hi: last_stmt.span.hi,\n                         expn_info: last_stmt.span.expn_info\n                     };\n-                    self.tcx.sess.span_note(\n+                    self.ir.tcx.sess.span_note(\n                         span_semicolon, \"consider removing this semicolon:\");\n                 }\n-                self.tcx.sess.span_err(\n+                self.ir.tcx.sess.span_err(\n                     sp, \"not all control paths return a value\");\n            }\n         }\n     }\n \n-    pub fn check_lvalue(&mut self, expr: @Expr) {\n+    fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n           ExprPath(_) => {\n-            let def_map = self.tcx.def_map.borrow();\n-            match def_map.get().get_copy(&expr.id) {\n+            match self.ir.tcx.def_map.borrow().get().get_copy(&expr.id) {\n               DefLocal(nid, _) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n@@ -1630,14 +1522,14 @@ impl Liveness {\n        }\n     }\n \n-    pub fn should_warn(&self, var: Variable) -> Option<~str> {\n+    fn should_warn(&self, var: Variable) -> Option<~str> {\n         let name = self.ir.variable_name(var);\n         if name.len() == 0 || name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    pub fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: &FnDecl, entry_ln: LiveNode) {\n         for arg in decl.inputs.iter() {\n-            pat_util::pat_bindings(self.tcx.def_map,\n+            pat_util::pat_bindings(self.ir.tcx.def_map,\n                                    arg.pat,\n                                    |_bm, p_id, sp, path| {\n                 let var = self.variable(p_id, sp);\n@@ -1650,20 +1542,20 @@ impl Liveness {\n         }\n     }\n \n-    pub fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @Pat) {\n-        self.pat_bindings(pat, |ln, var, sp, id| {\n-            if !self.warn_about_unused(sp, id, ln, var) {\n-                self.warn_about_dead_assign(sp, id, ln, var);\n+    fn warn_about_unused_or_dead_vars_in_pat(&mut self, pat: &Pat) {\n+        self.pat_bindings(pat, |this, ln, var, sp, id| {\n+            if !this.warn_about_unused(sp, id, ln, var) {\n+                this.warn_about_dead_assign(sp, id, ln, var);\n             }\n         })\n     }\n \n-    pub fn warn_about_unused(&self,\n-                             sp: Span,\n-                             id: NodeId,\n-                             ln: LiveNode,\n-                             var: Variable)\n-                             -> bool {\n+    fn warn_about_unused(&self,\n+                         sp: Span,\n+                         id: NodeId,\n+                         ln: LiveNode,\n+                         var: Variable)\n+                         -> bool {\n         if !self.used_on_entry(ln, var) {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n@@ -1678,11 +1570,11 @@ impl Liveness {\n                 };\n \n                 if is_assigned {\n-                    self.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n                         format!(\"variable `{}` is assigned to, \\\n                                   but never used\", *name));\n                 } else {\n-                    self.tcx.sess.add_lint(UnusedVariable, id, sp,\n+                    self.ir.tcx.sess.add_lint(UnusedVariable, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1692,15 +1584,15 @@ impl Liveness {\n         }\n     }\n \n-    pub fn warn_about_dead_assign(&self,\n-                                  sp: Span,\n-                                  id: NodeId,\n-                                  ln: LiveNode,\n-                                  var: Variable) {\n+    fn warn_about_dead_assign(&self,\n+                              sp: Span,\n+                              id: NodeId,\n+                              ln: LiveNode,\n+                              var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.tcx.sess.add_lint(DeadAssignment, id, sp,\n+                self.ir.tcx.sess.add_lint(DeadAssignment, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}, {"sha": "be0aef64351ecba064d4588f4ba9c00ab7dc59b0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -216,7 +216,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     }\n }\n \n-pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n+pub fn deref_kind(tcx: &ty::ctxt, t: ty::t) -> deref_kind {\n     match opt_deref_kind(t) {\n       Some(k) => k,\n       None => {\n@@ -267,9 +267,9 @@ pub type McResult<T> = Result<T, ()>;\n  * can be sure that only `Ok` results will occur.\n  */\n pub trait Typer {\n-    fn tcx(&self) -> ty::ctxt;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n     fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n-    fn node_method_ty(&mut self, method_call: typeck::MethodCall) -> Option<ty::t>;\n+    fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n     fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n     fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n@@ -351,7 +351,7 @@ macro_rules! if_ok(\n )\n \n impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.typer.tcx()\n     }\n \n@@ -886,7 +886,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         let cmt_slice = self.cat_index(slice_pat, vec_cmt, 0);\n         return Ok((cmt_slice, slice_mutbl, slice_r));\n \n-        fn vec_slice_info(tcx: ty::ctxt,\n+        fn vec_slice_info(tcx: &ty::ctxt,\n                           pat: @ast::Pat,\n                           slice_ty: ty::t)\n                           -> (ast::Mutability, ty::Region) {\n@@ -996,10 +996,9 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        let tcx = self.tcx();\n         debug!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_str(pat),\n-               cmt.repr(tcx));\n+               cmt.repr(self.tcx()));\n \n         op(self, cmt, pat);\n \n@@ -1187,7 +1186,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n /// The node_id here is the node of the expression that references the field.\n /// This function looks it up in the def map in case the type happens to be\n /// an enum to determine which variant is in use.\n-pub fn field_mutbl(tcx: ty::ctxt,\n+pub fn field_mutbl(tcx: &ty::ctxt,\n                    base_ty: ty::t,\n                    // FIXME #6993: change type to Name\n                    f_name: ast::Ident,\n@@ -1312,7 +1311,7 @@ impl cmt_ {\n }\n \n impl Repr for cmt_ {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"\\\\{{} id:{} m:{:?} ty:{}\\\\}\",\n              self.cat.repr(tcx),\n              self.id,\n@@ -1322,7 +1321,7 @@ impl Repr for cmt_ {\n }\n \n impl Repr for categorization {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             cat_static_item |\n             cat_rvalue(..) |\n@@ -1365,7 +1364,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n }\n \n impl Repr for InteriorKind {\n-    fn repr(&self, _tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ty::ctxt) -> ~str {\n         match *self {\n             InteriorField(NamedField(fld)) => {\n                 token::get_name(fld).get().to_str()"}, {"sha": "3d476832fd6bcc72fd28c249886db0b680be58ac", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 30, "deletions": 58, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -137,7 +137,6 @@ use util::common::indenter;\n use util::ppaux::UserString;\n use util::nodemap::{NodeMap, NodeSet};\n \n-use std::cell::RefCell;\n use std::rc::Rc;\n use std::vec_ng::Vec;\n use syntax::ast::*;\n@@ -160,29 +159,25 @@ pub struct CaptureVar {\n     mode: CaptureMode // How variable is being accessed\n }\n \n-pub type CaptureMap = @RefCell<NodeMap<Rc<Vec<CaptureVar> >>>;\n-\n-pub type MovesMap = @RefCell<NodeSet>;\n-\n-/**\n- * Set of variable node-ids that are moved.\n- *\n- * Note: The `VariableMovesMap` stores expression ids that\n- * are moves, whereas this set stores the ids of the variables\n- * that are moved at some point */\n-pub type MovedVariablesSet = @RefCell<NodeSet>;\n+pub type CaptureMap = NodeMap<Rc<Vec<CaptureVar>>>;\n \n /** See the section Output on the module comment for explanation. */\n #[deriving(Clone)]\n pub struct MoveMaps {\n-    moves_map: MovesMap,\n-    moved_variables_set: MovedVariablesSet,\n+    moves_map: NodeSet,\n+    /**\n+     * Set of variable node-ids that are moved.\n+     *\n+     * Note: The `moves_map` stores expression ids that are moves,\n+     * whereas this set stores the ids of the variables that are\n+     * moved at some point */\n+    moved_variables_set: NodeSet,\n     capture_map: CaptureMap\n }\n \n #[deriving(Clone)]\n-struct VisitContext {\n-    tcx: ty::ctxt,\n+struct VisitContext<'a> {\n+    tcx: &'a ty::ctxt,\n     method_map: MethodMap,\n     move_maps: MoveMaps\n }\n@@ -193,7 +188,7 @@ enum UseMode {\n     Read         // Read no matter what the type.\n }\n \n-impl visit::Visitor<()> for VisitContext {\n+impl<'a> visit::Visitor<()> for VisitContext<'a> {\n     fn visit_fn(&mut self, fk: &visit::FnKind, fd: &FnDecl,\n                 b: &Block, s: Span, n: NodeId, _: ()) {\n         compute_modes_for_fn(self, fk, fd, b, s, n);\n@@ -208,22 +203,21 @@ impl visit::Visitor<()> for VisitContext {\n     fn visit_ty(&mut self, _t: &Ty, _: ()) {}\n }\n \n-pub fn compute_moves(tcx: ty::ctxt,\n+pub fn compute_moves(tcx: &ty::ctxt,\n                      method_map: MethodMap,\n                      krate: &Crate) -> MoveMaps\n {\n     let mut visit_cx = VisitContext {\n         tcx: tcx,\n         method_map: method_map,\n         move_maps: MoveMaps {\n-            moves_map: @RefCell::new(NodeSet::new()),\n-            capture_map: @RefCell::new(NodeMap::new()),\n-            moved_variables_set: @RefCell::new(NodeSet::new())\n+            moves_map: NodeSet::new(),\n+            moved_variables_set: NodeSet::new(),\n+            capture_map: NodeMap::new()\n         }\n     };\n-    let visit_cx = &mut visit_cx;\n-    visit::walk_crate(visit_cx, krate, ());\n-    return visit_cx.move_maps;\n+    visit::walk_crate(&mut visit_cx, krate, ());\n+    visit_cx.move_maps\n }\n \n pub fn moved_variable_node_id_from_def(def: Def) -> Option<NodeId> {\n@@ -265,7 +259,7 @@ fn compute_modes_for_expr(cx: &mut VisitContext,\n     cx.consume_expr(expr);\n }\n \n-impl VisitContext {\n+impl<'a> VisitContext<'a> {\n     pub fn consume_exprs(&mut self, exprs: &[@Expr]) {\n         for expr in exprs.iter() {\n             self.consume_expr(*expr);\n@@ -284,7 +278,7 @@ impl VisitContext {\n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr,\n                                            self.method_map.borrow().get());\n         if ty::type_moves_by_default(self.tcx, expr_ty) {\n-            self.move_maps.moves_map.borrow_mut().get().insert(expr.id);\n+            self.move_maps.moves_map.insert(expr.id);\n             self.use_expr(expr, Move);\n         } else {\n             self.use_expr(expr, Read);\n@@ -349,20 +343,15 @@ impl VisitContext {\n                         let def = def_map.get().get_copy(&expr.id);\n                         let r = moved_variable_node_id_from_def(def);\n                         for &id in r.iter() {\n-                            let mut moved_variables_set =\n-                                self.move_maps\n-                                    .moved_variables_set\n-                                    .borrow_mut();\n-                            moved_variables_set.get().insert(id);\n+                            self.move_maps.moved_variables_set.insert(id);\n                         }\n                     }\n                     Read => {}\n                 }\n             }\n \n             ExprUnary(UnDeref, base) => {      // *base\n-                if !self.use_overloaded_operator(expr, base, [])\n-                {\n+                if !self.use_overloaded_operator(expr, base, []) {\n                     // Moving out of *base moves out of base.\n                     self.use_expr(base, comp_mode);\n                 }\n@@ -374,8 +363,7 @@ impl VisitContext {\n             }\n \n             ExprIndex(lhs, rhs) => {           // lhs[rhs]\n-                if !self.use_overloaded_operator(expr, lhs, [rhs])\n-                {\n+                if !self.use_overloaded_operator(expr, lhs, [rhs]) {\n                     self.use_expr(lhs, comp_mode);\n                     self.consume_expr(rhs);\n                 }\n@@ -400,12 +388,7 @@ impl VisitContext {\n                 // closures should be noncopyable, they shouldn't move by default;\n                 // calling a closure should only consume it if it's once.\n                 if mode == Move {\n-                    {\n-                        let mut moves_map = self.move_maps\n-                                                .moves_map\n-                                                .borrow_mut();\n-                        moves_map.get().insert(callee.id);\n-                    }\n+                    self.move_maps.moves_map.insert(callee.id);\n                 }\n                 self.use_expr(callee, mode);\n                 self.use_fn_args(args.as_slice());\n@@ -444,7 +427,7 @@ impl VisitContext {\n                             ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n \n-                    fn has_dtor(tcx: ty::ctxt, ty: ty::t) -> bool {\n+                    fn has_dtor(tcx: &ty::ctxt, ty: ty::t) -> bool {\n                         use middle::ty::{get,ty_struct,ty_enum};\n                         match get(ty).sty {\n                             ty_struct(did, _) | ty_enum(did, _) => ty::has_dtor(tcx, did),\n@@ -520,15 +503,13 @@ impl VisitContext {\n             ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, lhs) => {\n-                if !self.use_overloaded_operator(expr, lhs, [])\n-                {\n+                if !self.use_overloaded_operator(expr, lhs, []) {\n                     self.consume_expr(lhs);\n                 }\n             }\n \n             ExprBinary(_, lhs, rhs) => {\n-                if !self.use_overloaded_operator(expr, lhs, [rhs])\n-                {\n+                if !self.use_overloaded_operator(expr, lhs, [rhs]) {\n                     self.consume_expr(lhs);\n                     self.consume_expr(rhs);\n                 }\n@@ -574,12 +555,7 @@ impl VisitContext {\n                     self.use_pat(a.pat);\n                 }\n                 let cap_vars = self.compute_captures(expr.id);\n-                {\n-                    let mut capture_map = self.move_maps\n-                                              .capture_map\n-                                              .borrow_mut();\n-                    capture_map.get().insert(expr.id, cap_vars);\n-                }\n+                self.move_maps.capture_map.insert(expr.id, cap_vars);\n                 self.consume_block(body);\n             }\n \n@@ -657,16 +633,12 @@ impl VisitContext {\n                    id, bm, binding_moves);\n \n             if binding_moves {\n-                {\n-                    let mut moves_map = self.move_maps.moves_map.borrow_mut();\n-                    moves_map.get().insert(id);\n-                }\n+                self.move_maps.moves_map.insert(id);\n             }\n         })\n     }\n \n-    pub fn use_fn_args(&mut self,\n-                       arg_exprs: &[@Expr]) {\n+    pub fn use_fn_args(&mut self, arg_exprs: &[@Expr]) {\n         //! Uses the argument expressions.\n         for arg_expr in arg_exprs.iter() {\n             self.use_fn_arg(*arg_expr);"}, {"sha": "1de38d8a461e4a2e5e6513ab9af0409d4cd70caa", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -142,7 +142,7 @@ impl Visitor<()> for ParentVisitor {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct EmbargoVisitor<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     exp_map2: &'a resolve::ExportMap2,\n \n     // This flag is an indicator of whether the previous item in the\n@@ -345,7 +345,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct PrivacyVisitor<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     curitem: ast::NodeId,\n     in_fn: bool,\n     in_foreign: bool,\n@@ -585,7 +585,7 @@ impl<'a> PrivacyVisitor<'a> {\n                 }\n             }\n         } else {\n-            let cstore = self.tcx.sess.cstore;\n+            let cstore = &self.tcx.sess.cstore;\n             match enum_id {\n                 Some(enum_id) => {\n                     let v = csearch::get_enum_variants(self.tcx, enum_id);\n@@ -920,12 +920,12 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n /// The privacy sanity check visitor, ensures unnecessary visibility isn't here\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct SanePrivacyVisitor {\n-    tcx: ty::ctxt,\n+struct SanePrivacyVisitor<'a> {\n+    tcx: &'a ty::ctxt,\n     in_fn: bool,\n }\n \n-impl Visitor<()> for SanePrivacyVisitor {\n+impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n     fn visit_item(&mut self, item: &ast::Item, _: ()) {\n         if self.in_fn {\n             self.check_all_inherited(item);\n@@ -976,7 +976,7 @@ impl Visitor<()> for SanePrivacyVisitor {\n     }\n }\n \n-impl SanePrivacyVisitor {\n+impl<'a> SanePrivacyVisitor<'a> {\n     /// Validates all of the visibility qualifers placed on the item given. This\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n@@ -1159,7 +1159,7 @@ impl SanePrivacyVisitor {\n }\n \n struct VisiblePrivateTypesVisitor<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     exported_items: &'a ExportedItems,\n     public_items: &'a PublicItems,\n }\n@@ -1403,7 +1403,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n     fn visit_expr(&mut self, _: &ast::Expr, _: ()) {}\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    method_map: &MethodMap,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,"}, {"sha": "44a0fb61b243384b8f9c96d9749a22863a7ec22d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 47, "deletions": 97, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -20,7 +20,6 @@ use middle::typeck;\n use middle::privacy;\n use util::nodemap::NodeSet;\n \n-use std::cell::RefCell;\n use std::vec_ng::Vec;\n use collections::HashSet;\n use syntax::ast;\n@@ -59,7 +58,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n     }\n }\n \n-fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n+fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n     if attributes_specify_inlining(method.attrs.as_slice()) ||\n         generics_require_inlining(&method.generics) {\n@@ -83,34 +82,26 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::Method,\n }\n \n // Information needed while computing reachability.\n-struct ReachableContext {\n+struct ReachableContext<'a> {\n     // The type context.\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     // The method map, which links node IDs of method call expressions to the\n     // methods they've been resolved to.\n     method_map: typeck::MethodMap,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @RefCell<NodeSet>,\n+    reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @RefCell<Vec<ast::NodeId> >,\n+    worklist: Vec<ast::NodeId>,\n }\n \n-struct MarkSymbolVisitor {\n-    worklist: @RefCell<Vec<ast::NodeId> >,\n-    method_map: typeck::MethodMap,\n-    tcx: ty::ctxt,\n-    reachable_symbols: @RefCell<NodeSet>,\n-}\n-\n-impl Visitor<()> for MarkSymbolVisitor {\n+impl<'a> Visitor<()> for ReachableContext<'a> {\n \n     fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n-                let def_map = self.tcx.def_map.borrow();\n-                let def = match def_map.get().find(&expr.id) {\n+                let def = match self.tcx.def_map.borrow().get().find(&expr.id) {\n                     Some(&def) => def,\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n@@ -120,29 +111,22 @@ impl Visitor<()> for MarkSymbolVisitor {\n \n                 let def_id = def_id_of_def(def);\n                 if is_local(def_id) {\n-                    if ReachableContext::\n-                        def_id_represents_local_inlined_item(self.tcx, def_id) {\n-                            {\n-                                let mut worklist = self.worklist.borrow_mut();\n-                                worklist.get().push(def_id.node)\n-                            }\n+                    if self.def_id_represents_local_inlined_item(def_id) {\n+                        self.worklist.push(def_id.node)\n                     } else {\n                         match def {\n                             // If this path leads to a static, then we may have\n                             // to do some work to figure out whether the static\n                             // is indeed reachable (address_insignificant\n                             // statics are *never* reachable).\n                             ast::DefStatic(..) => {\n-                                let mut worklist = self.worklist.borrow_mut();\n-                                worklist.get().push(def_id.node);\n+                                self.worklist.push(def_id.node);\n                             }\n \n                             // If this wasn't a static, then this destination is\n                             // surely reachable.\n                             _ => {\n-                                let mut reachable_symbols =\n-                                    self.reachable_symbols.borrow_mut();\n-                                reachable_symbols.get().insert(def_id.node);\n+                                self.reachable_symbols.insert(def_id.node);\n                             }\n                         }\n                     }\n@@ -153,13 +137,10 @@ impl Visitor<()> for MarkSymbolVisitor {\n                 match self.method_map.borrow().get().get(&method_call).origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n-                            if ReachableContext::\n-                                def_id_represents_local_inlined_item(\n-                                    self.tcx,\n-                                    def_id) {\n-                                self.worklist.borrow_mut().get().push(def_id.node)\n+                            if self.def_id_represents_local_inlined_item(def_id) {\n+                                self.worklist.push(def_id.node)\n                             }\n-                            self.reachable_symbols.borrow_mut().get().insert(def_id.node);\n+                            self.reachable_symbols.insert(def_id.node);\n                         }\n                     }\n                     _ => {}\n@@ -177,27 +158,26 @@ impl Visitor<()> for MarkSymbolVisitor {\n     }\n }\n \n-impl ReachableContext {\n+impl<'a> ReachableContext<'a> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: ty::ctxt, method_map: typeck::MethodMap) -> ReachableContext {\n+    fn new(tcx: &'a ty::ctxt, method_map: typeck::MethodMap) -> ReachableContext<'a> {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n-            reachable_symbols: @RefCell::new(NodeSet::new()),\n-            worklist: @RefCell::new(Vec::new()),\n+            reachable_symbols: NodeSet::new(),\n+            worklist: Vec::new(),\n         }\n     }\n \n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n-    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: ast::DefId)\n-                                            -> bool {\n+    fn def_id_represents_local_inlined_item(&self, def_id: ast::DefId) -> bool {\n         if def_id.krate != ast::LOCAL_CRATE {\n             return false\n         }\n \n         let node_id = def_id.node;\n-        match tcx.map.find(node_id) {\n+        match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n                     ast::ItemFn(..) => item_might_be_inlined(item),\n@@ -215,11 +195,11 @@ impl ReachableContext {\n                         attributes_specify_inlining(method.attrs.as_slice()) {\n                     true\n                 } else {\n-                    let impl_did = tcx.map.get_parent_did(node_id);\n+                    let impl_did = self.tcx.map.get_parent_did(node_id);\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n                     assert!(impl_did.krate == ast::LOCAL_CRATE);\n-                    match tcx.map.expect_item(impl_did.node).node {\n+                    match self.tcx.map.expect_item(impl_did.node).node {\n                         ast::ItemImpl(ref generics, _, _, _) => {\n                             generics_require_inlining(generics)\n                         }\n@@ -232,40 +212,21 @@ impl ReachableContext {\n         }\n     }\n \n-    // Helper function to set up a visitor for `propagate()` below.\n-    fn init_visitor(&self) -> MarkSymbolVisitor {\n-        let (worklist, method_map) = (self.worklist, self.method_map);\n-        let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n-\n-        MarkSymbolVisitor {\n-            worklist: worklist,\n-            method_map: method_map,\n-            tcx: tcx,\n-            reachable_symbols: reachable_symbols,\n-        }\n-    }\n-\n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n-    fn propagate(&self) {\n-        let mut visitor = self.init_visitor();\n+    fn propagate(&mut self) {\n         let mut scanned = HashSet::new();\n         loop {\n-            let search_item = {\n-                let mut worklist = self.worklist.borrow_mut();\n-                if worklist.get().len() == 0 {\n-                    break\n-                }\n-                let search_item = worklist.get().pop().unwrap();\n-                if scanned.contains(&search_item) {\n-                    continue\n-                }\n-                search_item\n-            };\n+            if self.worklist.len() == 0 {\n+                break\n+            }\n+            let search_item = self.worklist.pop().unwrap();\n+            if scanned.contains(&search_item) {\n+                continue\n+            }\n \n             scanned.insert(search_item);\n             match self.tcx.map.find(search_item) {\n-                Some(ref item) => self.propagate_node(item, search_item,\n-                                                  &mut visitor),\n+                Some(ref item) => self.propagate_node(item, search_item),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n@@ -276,9 +237,8 @@ impl ReachableContext {\n         }\n     }\n \n-    fn propagate_node(&self, node: &ast_map::Node,\n-                      search_item: ast::NodeId,\n-                      visitor: &mut MarkSymbolVisitor) {\n+    fn propagate_node(&mut self, node: &ast_map::Node,\n+                      search_item: ast::NodeId) {\n         if !self.tcx.sess.building_library.get() {\n             // If we are building an executable, then there's no need to flag\n             // anything as external except for `extern fn` types. These\n@@ -289,9 +249,7 @@ impl ReachableContext {\n                 ast_map::NodeItem(item) => {\n                     match item.node {\n                         ast::ItemFn(_, ast::ExternFn, _, _, _) => {\n-                            let mut reachable_symbols =\n-                                self.reachable_symbols.borrow_mut();\n-                            reachable_symbols.get().insert(search_item);\n+                            self.reachable_symbols.insert(search_item);\n                         }\n                         _ => {}\n                     }\n@@ -303,16 +261,15 @@ impl ReachableContext {\n             // continue to participate in linkage after this product is\n             // produced. In this case, we traverse the ast node, recursing on\n             // all reachable nodes from this one.\n-            let mut reachable_symbols = self.reachable_symbols.borrow_mut();\n-            reachable_symbols.get().insert(search_item);\n+            self.reachable_symbols.insert(search_item);\n         }\n \n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n                     ast::ItemFn(_, _, _, _, search_block) => {\n                         if item_might_be_inlined(item) {\n-                            visit::walk_block(visitor, search_block, ())\n+                            visit::walk_block(self, search_block, ())\n                         }\n                     }\n \n@@ -321,9 +278,7 @@ impl ReachableContext {\n                     ast::ItemStatic(..) => {\n                         if attr::contains_name(item.attrs.as_slice(),\n                                                \"address_insignificant\") {\n-                            let mut reachable_symbols =\n-                                self.reachable_symbols.borrow_mut();\n-                            reachable_symbols.get().remove(&search_item);\n+                            self.reachable_symbols.remove(&search_item);\n                         }\n                     }\n \n@@ -348,14 +303,14 @@ impl ReachableContext {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::Provided(ref method) => {\n-                        visit::walk_block(visitor, method.body, ())\n+                        visit::walk_block(self, method.body, ())\n                     }\n                 }\n             }\n             ast_map::NodeMethod(method) => {\n                 let did = self.tcx.map.get_parent_did(search_item);\n                 if method_might_be_inlined(self.tcx, method, did) {\n-                    visit::walk_block(visitor, method.body, ())\n+                    visit::walk_block(self, method.body, ())\n                 }\n             }\n             // Nothing to recurse on for these\n@@ -375,42 +330,37 @@ impl ReachableContext {\n     // FIXME(pcwalton): This is a conservative overapproximation, but fixing\n     // this properly would result in the necessity of computing *type*\n     // reachability, which might result in a compile time loss.\n-    fn mark_destructors_reachable(&self) {\n-        let destructor_for_type = self.tcx.destructor_for_type.borrow();\n-        for (_, destructor_def_id) in destructor_for_type.get().iter() {\n+    fn mark_destructors_reachable(&mut self) {\n+        for (_, destructor_def_id) in self.tcx.destructor_for_type.borrow().get().iter() {\n             if destructor_def_id.krate == ast::LOCAL_CRATE {\n-                let mut reachable_symbols = self.reachable_symbols\n-                                                .borrow_mut();\n-                reachable_symbols.get().insert(destructor_def_id.node);\n+                self.reachable_symbols.insert(destructor_def_id.node);\n             }\n         }\n     }\n }\n \n-pub fn find_reachable(tcx: ty::ctxt,\n+pub fn find_reachable(tcx: &ty::ctxt,\n                       method_map: typeck::MethodMap,\n                       exported_items: &privacy::ExportedItems)\n-                      -> @RefCell<NodeSet> {\n-    let reachable_context = ReachableContext::new(tcx, method_map);\n+                      -> NodeSet {\n+    let mut reachable_context = ReachableContext::new(tcx, method_map);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass along with all local lang items. If\n     //         other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    let mut worklist = reachable_context.worklist.borrow_mut();\n     for &id in exported_items.iter() {\n-        worklist.get().push(id);\n+        reachable_context.worklist.push(id);\n     }\n     for (_, item) in tcx.lang_items.items() {\n         match *item {\n             Some(did) if is_local(did) => {\n-                worklist.get().push(did.node);\n+                reachable_context.worklist.push(did.node);\n             }\n             _ => {}\n         }\n     }\n-    drop(worklist);\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     reachable_context.propagate();"}, {"sha": "a13dce65f513e3e82b4dca0b23e2ab1587fa1597", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -92,7 +92,7 @@ pub struct Context {\n }\n \n struct RegionResolutionVisitor<'a> {\n-    sess: Session,\n+    sess: &'a Session,\n \n     // Generated maps:\n     region_maps: &'a RegionMaps,\n@@ -847,7 +847,7 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n                                body.id={}, \\\n                                cx.parent={})\",\n            id,\n-           visitor.sess.codemap.span_to_str(sp),\n+           visitor.sess.codemap().span_to_str(sp),\n            body.id,\n            cx.parent);\n \n@@ -909,7 +909,7 @@ impl<'a> Visitor<Context> for RegionResolutionVisitor<'a> {\n     }\n }\n \n-pub fn resolve_crate(sess: Session, krate: &ast::Crate) -> RegionMaps {\n+pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n         scope_map: RefCell::new(NodeMap::new()),\n         var_map: RefCell::new(NodeMap::new()),\n@@ -928,7 +928,7 @@ pub fn resolve_crate(sess: Session, krate: &ast::Crate) -> RegionMaps {\n     return maps;\n }\n \n-pub fn resolve_inlined_item(sess: Session,\n+pub fn resolve_inlined_item(sess: &Session,\n                             region_maps: &RegionMaps,\n                             item: &ast::InlinedItem) {\n     let cx = Context {parent: None,"}, {"sha": "2784be5a01bcd6c6f4cbc21b3b8a02015f9584cb", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -153,7 +153,7 @@ enum NameDefinition {\n     ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n }\n \n-impl Visitor<()> for Resolver {\n+impl<'a> Visitor<()> for Resolver<'a> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n         self.resolve_item(item);\n     }\n@@ -787,9 +787,9 @@ fn namespace_error_to_str(ns: NamespaceError) -> &'static str {\n     }\n }\n \n-fn Resolver(session: Session,\n-            lang_items: @LanguageItems,\n-            crate_span: Span) -> Resolver {\n+fn Resolver<'a>(session: &'a Session,\n+                lang_items: @LanguageItems,\n+                crate_span: Span) -> Resolver<'a> {\n     let graph_root = @NameBindings();\n \n     graph_root.define_module(NoParentLink,\n@@ -802,7 +802,7 @@ fn Resolver(session: Session,\n     let current_module = graph_root.get_module();\n \n     let this = Resolver {\n-        session: @session,\n+        session: session,\n         lang_items: lang_items,\n \n         // The outermost module has def ID 0; this is not reflected in the\n@@ -843,8 +843,8 @@ fn Resolver(session: Session,\n }\n \n /// The main resolver class.\n-struct Resolver {\n-    session: @Session,\n+struct Resolver<'a> {\n+    session: &'a Session,\n     lang_items: @LanguageItems,\n \n     graph_root: @NameBindings,\n@@ -896,11 +896,11 @@ struct Resolver {\n     used_imports: HashSet<(NodeId, Namespace)>,\n }\n \n-struct BuildReducedGraphVisitor<'a> {\n-    resolver: &'a mut Resolver,\n+struct BuildReducedGraphVisitor<'a, 'b> {\n+    resolver: &'a mut Resolver<'b>,\n }\n \n-impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n+impl<'a, 'b> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &Item, context: ReducedGraphParent) {\n         let p = self.resolver.build_reduced_graph_for_item(item, context);\n@@ -928,16 +928,16 @@ impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n \n }\n \n-struct UnusedImportCheckVisitor<'a> { resolver: &'a mut Resolver }\n+struct UnusedImportCheckVisitor<'a, 'b> { resolver: &'a mut Resolver<'b> }\n \n-impl<'a> Visitor<()> for UnusedImportCheckVisitor<'a> {\n+impl<'a, 'b> Visitor<()> for UnusedImportCheckVisitor<'a, 'b> {\n     fn visit_view_item(&mut self, vi: &ViewItem, _: ()) {\n         self.resolver.check_for_item_unused_imports(vi);\n         visit::walk_view_item(self, vi, ());\n     }\n }\n \n-impl Resolver {\n+impl<'a> Resolver<'a> {\n     /// The main name resolution procedure.\n     fn resolve(&mut self, krate: &ast::Crate) {\n         self.build_reduced_graph(krate);\n@@ -1690,11 +1690,11 @@ impl Resolver {\n               // to the trait info.\n \n               let method_def_ids =\n-                csearch::get_trait_method_def_ids(self.session.cstore, def_id);\n+                csearch::get_trait_method_def_ids(&self.session.cstore, def_id);\n               let mut interned_method_names = HashSet::new();\n               for &method_def_id in method_def_ids.iter() {\n                   let (method_name, explicit_self) =\n-                      csearch::get_method_name_and_explicit_self(self.session.cstore,\n+                      csearch::get_method_name_and_explicit_self(&self.session.cstore,\n                                                                  method_def_id);\n \n                   debug!(\"(building reduced graph for \\\n@@ -1743,7 +1743,7 @@ impl Resolver {\n                     crate) building type and value for {}\",\n                    final_ident);\n             child_name_bindings.define_type(def, DUMMY_SP, is_public);\n-            if csearch::get_struct_fields(self.session.cstore, def_id).len() == 0 {\n+            if csearch::get_struct_fields(&self.session.cstore, def_id).len() == 0 {\n                 child_name_bindings.define_value(def, DUMMY_SP, is_public);\n             }\n             self.structs.insert(def_id);\n@@ -1775,7 +1775,7 @@ impl Resolver {\n                     DefForeignMod(def_id) => {\n                         // Foreign modules have no names. Recur and populate\n                         // eagerly.\n-                        csearch::each_child_of_item(self.session.cstore,\n+                        csearch::each_child_of_item(&self.session.cstore,\n                                                     def_id,\n                                                     |def_like,\n                                                      child_ident,\n@@ -1805,11 +1805,11 @@ impl Resolver {\n             }\n             DlImpl(def) => {\n                 // We only process static methods of impls here.\n-                match csearch::get_type_name_if_impl(self.session.cstore, def) {\n+                match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n                     None => {}\n                     Some(final_ident) => {\n                         let static_methods_opt =\n-                            csearch::get_static_methods_if_impl(self.session.cstore, def);\n+                            csearch::get_static_methods_if_impl(&self.session.cstore, def);\n                         match static_methods_opt {\n                             Some(ref static_methods) if\n                                 static_methods.len() >= 1 => {\n@@ -1910,7 +1910,7 @@ impl Resolver {\n             Some(def_id) => def_id,\n         };\n \n-        csearch::each_child_of_item(self.session.cstore,\n+        csearch::each_child_of_item(&self.session.cstore,\n                                     def_id,\n                                     |def_like, child_ident, visibility| {\n             debug!(\"(populating external module) ... found ident: {}\",\n@@ -1936,7 +1936,7 @@ impl Resolver {\n     /// crate.\n     fn build_reduced_graph_for_external_crate(&mut self,\n                                               root: @Module) {\n-        csearch::each_top_level_item_of_crate(self.session.cstore,\n+        csearch::each_top_level_item_of_crate(&self.session.cstore,\n                                               root.def_id\n                                                   .get()\n                                                   .unwrap()\n@@ -3275,7 +3275,7 @@ impl Resolver {\n         let import_count = imports.get().len();\n         if index != import_count {\n             let sn = self.session\n-                         .codemap\n+                         .codemap()\n                          .span_to_snippet(imports.get().get(index).span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n@@ -5449,7 +5449,7 @@ impl Resolver {\n     // public or private item, we will check the correct thing, dependent on how the import\n     // is used.\n     fn finalize_import(&mut self, id: NodeId, span: Span) {\n-        debug!(\"finalizing import uses for {}\", self.session.codemap.span_to_snippet(span));\n+        debug!(\"finalizing import uses for {}\", self.session.codemap().span_to_snippet(span));\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n@@ -5571,7 +5571,7 @@ pub struct CrateMap {\n }\n \n /// Entry point to crate resolution.\n-pub fn resolve_crate(session: Session,\n+pub fn resolve_crate(session: &Session,\n                      lang_items: @LanguageItems,\n                      krate: &Crate)\n                   -> CrateMap {"}, {"sha": "da424ea2e15746a7419da2e3c81a2b531d1f2555", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -17,8 +17,7 @@\n  * way. Therefore we break lifetime name resolution into a separate pass.\n  */\n \n-use driver::session;\n-use std::cell::RefCell;\n+use driver::session::Session;\n use std::vec_ng::Vec;\n use util::nodemap::NodeMap;\n use syntax::ast;\n@@ -40,9 +39,9 @@ fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n     token::get_name(*lt_name)\n }\n \n-struct LifetimeContext {\n-    sess: session::Session,\n-    named_region_map: @RefCell<NamedRegionMap>,\n+struct LifetimeContext<'a> {\n+    sess: &'a Session,\n+    named_region_map: NamedRegionMap,\n }\n \n enum ScopeChain<'a> {\n@@ -60,18 +59,17 @@ enum ScopeChain<'a> {\n \n type Scope<'a> = &'a ScopeChain<'a>;\n \n-pub fn krate(sess: session::Session, krate: &ast::Crate)\n-             -> @RefCell<NamedRegionMap> {\n+pub fn krate(sess: &Session, krate: &ast::Crate) -> NamedRegionMap {\n     let mut ctxt = LifetimeContext {\n         sess: sess,\n-        named_region_map: @RefCell::new(NodeMap::new())\n+        named_region_map: NodeMap::new()\n     };\n     visit::walk_crate(&mut ctxt, krate, &RootScope);\n     sess.abort_if_errors();\n     ctxt.named_region_map\n }\n \n-impl<'a> Visitor<Scope<'a>> for LifetimeContext {\n+impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n     fn visit_item(&mut self,\n                   item: &ast::Item,\n                   _: Scope<'a>) {\n@@ -181,7 +179,7 @@ impl<'a> ScopeChain<'a> {\n     }\n }\n \n-impl LifetimeContext {\n+impl<'a> LifetimeContext<'a> {\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_fn_decl(&mut self,\n                      n: ast::NodeId,\n@@ -237,7 +235,7 @@ impl LifetimeContext {\n         debug!(\"popping fn scope id={} due to fn item/method\", n);\n     }\n \n-    fn resolve_lifetime_ref(&self,\n+    fn resolve_lifetime_ref(&mut self,\n                             lifetime_ref: &ast::Lifetime,\n                             scope: Scope) {\n         // Walk up the scope chain, tracking the number of fn scopes\n@@ -293,7 +291,7 @@ impl LifetimeContext {\n         self.unresolved_lifetime_ref(lifetime_ref);\n     }\n \n-    fn resolve_free_lifetime_ref(&self,\n+    fn resolve_free_lifetime_ref(&mut self,\n                                  scope_id: ast::NodeId,\n                                  lifetime_ref: &ast::Lifetime,\n                                  scope: Scope) {\n@@ -374,7 +372,7 @@ impl LifetimeContext {\n         }\n     }\n \n-    fn insert_lifetime(&self,\n+    fn insert_lifetime(&mut self,\n                        lifetime_ref: &ast::Lifetime,\n                        def: ast::DefRegion) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n@@ -387,8 +385,7 @@ impl LifetimeContext {\n                 lifetime_to_str(lifetime_ref),\n                 lifetime_ref.id,\n                 def);\n-        let mut named_region_map = self.named_region_map.borrow_mut();\n-        named_region_map.get().insert(lifetime_ref.id, def);\n+        self.named_region_map.insert(lifetime_ref.id, def);\n     }\n }\n "}, {"sha": "f82b43adc430f9a101b561402e26cffa5a1bc806", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -29,10 +29,10 @@ use syntax::opt_vec::OptVec;\n // information available (for better errors).\n \n pub trait Subst {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> Self {\n+    fn subst(&self, tcx: &ty::ctxt, substs: &ty::substs) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Self;\n }\n@@ -46,7 +46,7 @@ pub trait Subst {\n // our current method/trait matching algorithm. - Niko\n \n impl Subst for ty::t {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::t {\n         if ty::substs_is_noop(substs) && !ty::type_has_params(*self) {\n@@ -64,7 +64,7 @@ impl Subst for ty::t {\n }\n \n struct SubstFolder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     substs: &'a ty::substs,\n \n     // The location for which the substitution is performed, if available.\n@@ -75,7 +75,7 @@ struct SubstFolder<'a> {\n }\n \n impl<'a> TypeFolder for SubstFolder<'a> {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         r.subst(self.tcx, self.substs)\n@@ -132,30 +132,30 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n // Other types\n \n impl<T:Subst> Subst for Vec<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Vec<T> {\n         self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n impl<T:Subst> Subst for Rc<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Rc<T> {\n         Rc::new(self.deref().subst_spanned(tcx, substs, span))\n     }\n }\n \n impl<T:Subst> Subst for OptVec<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> OptVec<T> {\n         self.map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n \n impl<T:Subst + 'static> Subst for @T {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> @T {\n         match self {\n@@ -165,15 +165,15 @@ impl<T:Subst + 'static> Subst for @T {\n }\n \n impl<T:Subst> Subst for Option<T> {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> Option<T> {\n         self.as_ref().map(|t| t.subst_spanned(tcx, substs, span))\n     }\n }\n \n impl Subst for ty::TraitRef {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::TraitRef {\n         ty::TraitRef {\n@@ -184,7 +184,7 @@ impl Subst for ty::TraitRef {\n }\n \n impl Subst for ty::substs {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::substs {\n         ty::substs {\n@@ -196,7 +196,7 @@ impl Subst for ty::substs {\n }\n \n impl Subst for ty::RegionSubsts {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::RegionSubsts {\n         match *self {\n@@ -211,7 +211,7 @@ impl Subst for ty::RegionSubsts {\n }\n \n impl Subst for ty::BareFnTy {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::BareFnTy {\n         let mut folder = SubstFolder {\n@@ -225,7 +225,7 @@ impl Subst for ty::BareFnTy {\n }\n \n impl Subst for ty::ParamBounds {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::ParamBounds {\n         ty::ParamBounds {\n@@ -236,7 +236,7 @@ impl Subst for ty::ParamBounds {\n }\n \n impl Subst for ty::TypeParameterDef {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::TypeParameterDef {\n         ty::TypeParameterDef {\n@@ -249,7 +249,7 @@ impl Subst for ty::TypeParameterDef {\n }\n \n impl Subst for ty::Generics {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::Generics {\n         ty::Generics {\n@@ -260,15 +260,15 @@ impl Subst for ty::Generics {\n }\n \n impl Subst for ty::RegionParameterDef {\n-    fn subst_spanned(&self, _: ty::ctxt,\n+    fn subst_spanned(&self, _: &ty::ctxt,\n                      _: &ty::substs,\n                      _: Option<Span>) -> ty::RegionParameterDef {\n         *self\n     }\n }\n \n impl Subst for ty::Region {\n-    fn subst_spanned(&self, _tcx: ty::ctxt,\n+    fn subst_spanned(&self, _tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      _: Option<Span>) -> ty::Region {\n         // Note: This routine only handles regions that are bound on\n@@ -290,7 +290,7 @@ impl Subst for ty::Region {\n }\n \n impl Subst for ty::ty_param_bounds_and_ty {\n-    fn subst_spanned(&self, tcx: ty::ctxt,\n+    fn subst_spanned(&self, tcx: &ty::ctxt,\n                      substs: &ty::substs,\n                      span: Option<Span>) -> ty::ty_param_bounds_and_ty {\n         ty::ty_param_bounds_and_ty {"}, {"sha": "7d69db92af2f1524dff36d23e6715d1411c07ebb", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -257,7 +257,7 @@ enum Opt {\n     vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n-fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n+fn opt_eq(tcx: &ty::ctxt, a: &Opt, b: &Opt) -> bool {\n     match (a, b) {\n         (&lit(a), &lit(b)) => {\n             match (a, b) {\n@@ -359,7 +359,7 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n     let def_map = ccx.tcx.def_map.borrow();\n     match def_map.get().get_copy(&pat_id) {\n         ast::DefVariant(enum_id, var_id, _) => {\n-            let variants = ty::enum_variants(ccx.tcx, enum_id);\n+            let variants = ty::enum_variants(ccx.tcx(), enum_id);\n             for v in (*variants).iter() {\n                 if var_id == v.id {\n                     return var(v.disr_val,\n@@ -373,7 +373,7 @@ fn variant_opt(bcx: &Block, pat_id: ast::NodeId) -> Opt {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n-            ccx.sess.bug(\"non-variant or struct in variant_opt()\");\n+            ccx.sess().bug(\"non-variant or struct in variant_opt()\");\n         }\n     }\n }\n@@ -427,7 +427,7 @@ struct Match<'a,'b> {\n     bound_ptrs: Vec<(Ident, ValueRef)> }\n \n impl<'a,'b> Repr for Match<'a,'b> {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n             self.pats.repr(tcx)\n@@ -931,7 +931,7 @@ fn enter_region<'r,\n // on a set of enum variants or a literal.\n fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n     let ccx = bcx.ccx();\n-    fn add_to_set(tcx: ty::ctxt, set: &mut Vec<Opt> , val: Opt) {\n+    fn add_to_set(tcx: &ty::ctxt, set: &mut Vec<Opt>, val: Opt) {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n@@ -960,7 +960,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n         let cur = *br.pats.get(col);\n         match cur.node {\n             ast::PatLit(l) => {\n-                add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n+                add_to_set(ccx.tcx(), &mut found, lit(ExprLit(l)));\n             }\n             ast::PatIdent(..) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n@@ -971,15 +971,15 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 };\n                 match opt_def {\n                     Some(ast::DefVariant(..)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::DefStruct(..)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n                     Some(ast::DefStatic(const_did, false)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n@@ -995,18 +995,18 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n                 match opt_def {\n                     Some(ast::DefFn(..)) |\n                     Some(ast::DefVariant(..)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n                     Some(ast::DefStatic(const_did, false)) => {\n-                        add_to_set(ccx.tcx, &mut found,\n+                        add_to_set(ccx.tcx(), &mut found,\n                                    lit(ConstLit(const_did)));\n                     }\n                     _ => {}\n                 }\n             }\n             ast::PatRange(l1, l2) => {\n-                add_to_set(ccx.tcx, &mut found, range(l1, l2));\n+                add_to_set(ccx.tcx(), &mut found, range(l1, l2));\n             }\n             ast::PatVec(ref before, slice, ref after) => {\n                 let (len, vec_opt) = match slice {\n@@ -1324,8 +1324,7 @@ fn compare_values<'a>(\n             }\n         }\n         _ => {\n-            cx.tcx().sess.bug(\"only scalars and strings supported in \\\n-                                compare_values\");\n+            cx.sess().bug(\"only scalars and strings supported in compare_values\");\n         }\n     }\n }\n@@ -1585,7 +1584,7 @@ fn compile_submatch_continue<'r,\n         let tup_repr = adt::represent_type(bcx.ccx(), tup_ty);\n         let n_tup_elts = match ty::get(tup_ty).sty {\n           ty::ty_tup(ref elts) => elts.len(),\n-          _ => ccx.sess.bug(\"non-tuple type in tuple pattern\")\n+          _ => ccx.sess().bug(\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = Vec::from_fn(n_tup_elts, |i| {\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n@@ -1612,7 +1611,7 @@ fn compile_submatch_continue<'r,\n                     ty::lookup_struct_fields(tcx, struct_id).len();\n             }\n             _ => {\n-                ccx.sess.bug(\"non-struct type in tuple struct pattern\");\n+                ccx.sess().bug(\"non-struct type in tuple struct pattern\");\n             }\n         }\n \n@@ -2093,7 +2092,7 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>,\n             // like `x: T`\n             let arg_ty = node_id_type(bcx, pat.id);\n             if type_of::arg_is_indirect(bcx.ccx(), arg_ty)\n-                && bcx.ccx().sess.opts.debuginfo != FullDebugInfo {\n+                && bcx.sess().opts.debuginfo != FullDebugInfo {\n                 // Don't copy an indirect argument to an alloca, the caller\n                 // already put it in a temporary alloca and gave it up, unless\n                 // we emit extra-debug-info, which requires local allocas :(.\n@@ -2225,7 +2224,7 @@ fn bind_irrefutable_pat<'a>(\n             match def_map.get().find(&pat.id) {\n                 Some(&ast::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n-                    let vinfo = ty::enum_variant_with_id(ccx.tcx,\n+                    let vinfo = ty::enum_variant_with_id(ccx.tcx(),\n                                                          enum_id,\n                                                          var_id);\n                     let args = extract_variant_args(bcx,\n@@ -2297,8 +2296,7 @@ fn bind_irrefutable_pat<'a>(\n             bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n         }\n         ast::PatVec(..) => {\n-            bcx.tcx().sess.span_bug(\n-                pat.span,\n+            bcx.sess().span_bug(pat.span,\n                 format!(\"vector patterns are never irrefutable!\"));\n         }\n         ast::PatWild | ast::PatWildMulti | ast::PatLit(_) | ast::PatRange(_, _) => ()"}, {"sha": "eb57ad022b6557e89496b23d428d515cf341fe82", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -118,7 +118,7 @@ pub fn represent_node(bcx: &Block, node: ast::NodeId) -> @Repr {\n \n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n-    debug!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n+    debug!(\"Representing: {}\", ty_to_str(cx.tcx(), t));\n     {\n         let adt_reprs = cx.adt_reprs.borrow();\n         match adt_reprs.get().find(&t) {\n@@ -140,19 +140,19 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             return Univariant(mk_struct(cx, elems.as_slice(), false), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n-            let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n+            let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n             let mut ftys = fields.map(|field| {\n-                ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n+                ty::lookup_field_type(cx.tcx(), def_id, field.id, substs)\n             });\n-            let packed = ty::lookup_packed(cx.tcx, def_id);\n-            let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n+            let packed = ty::lookup_packed(cx.tcx(), def_id);\n+            let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n             return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n-            let cases = get_cases(cx.tcx, def_id, substs);\n-            let hint = ty::lookup_repr_hint(cx.tcx, def_id);\n+            let cases = get_cases(cx.tcx(), def_id, substs);\n+            let hint = ty::lookup_repr_hint(cx.tcx(), def_id);\n \n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n@@ -177,9 +177,9 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n-                cx.sess.bug(format!(\"non-C-like enum {} with specified \\\n-                                  discriminants\",\n-                                 ty::item_path_str(cx.tcx, def_id)))\n+                cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n+                                      discriminants\",\n+                                      ty::item_path_str(cx.tcx(), def_id)))\n             }\n \n             if cases.len() == 1 {\n@@ -230,13 +230,13 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                           false)\n             }))\n         }\n-        _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n+        _ => cx.sess().bug(\"adt::represent_type called on non-ADT type\")\n     }\n }\n \n /// Determine, without doing translation, whether an ADT must be FFI-safe.\n /// For use in lint or similar, where being sound but slightly incomplete is acceptable.\n-pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n+pub fn is_ffi_safe(tcx: &ty::ctxt, def_id: ast::DefId) -> bool {\n     match ty::get(ty::lookup_item_type(tcx, def_id).ty).sty {\n         ty::ty_enum(def_id, _) => {\n             let variants = ty::enum_variants(tcx, def_id);\n@@ -274,7 +274,7 @@ impl Case {\n     }\n }\n \n-fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n+fn get_cases(tcx: &ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case> {\n     ty::enum_variants(tcx, def_id).map(|vi| {\n         let arg_tys = vi.args.map(|&raw_ty| {\n             ty::subst(tcx, substs, raw_ty)\n@@ -286,7 +286,7 @@ fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> Vec<Case\n \n fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n-    let llty_rec = Type::struct_(lltys, packed);\n+    let llty_rec = Type::struct_(cx, lltys, packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n@@ -324,12 +324,12 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n     match hint {\n         attr::ReprInt(span, ity) => {\n             if !bounds_usable(cx, ity, bounds) {\n-                cx.sess.span_bug(span, \"representation hint insufficient for discriminant range\")\n+                cx.sess().span_bug(span, \"representation hint insufficient for discriminant range\")\n             }\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess.targ_cfg.arch {\n+            attempts = match cx.sess().targ_cfg.arch {\n                 X86 | X86_64 => at_least_32,\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n@@ -415,10 +415,10 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(struct_llfields(cx, st, sizing).as_slice(),\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing).as_slice(),\n                                   st.packed)\n                 }\n-                Some(name) => { assert_eq!(sizing, false); Type::named_struct(name) }\n+                Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n             }\n         }\n         General(ity, ref sts) => {\n@@ -441,12 +441,12 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty) as u64;\n             let align_units = (size + align - 1) / align - 1;\n             let pad_ty = match align {\n-                1 => Type::array(&Type::i8(), align_units),\n-                2 => Type::array(&Type::i16(), align_units),\n-                4 => Type::array(&Type::i32(), align_units),\n-                8 if machine::llalign_of_min(cx, Type::i64()) == 8 =>\n-                                 Type::array(&Type::i64(), align_units),\n-                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(), a / 4),\n+                1 => Type::array(&Type::i8(cx), align_units),\n+                2 => Type::array(&Type::i16(cx), align_units),\n+                4 => Type::array(&Type::i32(cx), align_units),\n+                8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                                 Type::array(&Type::i64(cx), align_units),\n+                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n                                                               align_units),\n                 _ => fail!(\"unsupported enum alignment: {:?}\", align)\n             };\n@@ -456,9 +456,9 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n                            Type::array(&discr_ty, align / discr_size - 1),\n                            pad_ty);\n             match name {\n-                None => Type::struct_(fields.as_slice(), false),\n+                None => Type::struct_(cx, fields.as_slice(), false),\n                 Some(name) => {\n-                    let mut llty = Type::named_struct(name);\n+                    let mut llty = Type::named_struct(cx, name);\n                     llty.set_struct_body(fields.as_slice(), false);\n                     llty\n                 }\n@@ -514,7 +514,7 @@ pub fn trans_get_discr(bcx: &Block, r: &Repr, scrutinee: ValueRef, cast_to: Opti\n             signed = ity.is_signed();\n         }\n         Univariant(..) => {\n-            val = C_u8(0);\n+            val = C_u8(bcx.ccx(), 0);\n             signed = false;\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n@@ -577,11 +577,11 @@ pub fn trans_case<'a>(bcx: &'a Block<'a>, r: &Repr, discr: Disr)\n                                                        discr as u64, true)))\n         }\n         Univariant(..) => {\n-            bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n+            bcx.ccx().sess().bug(\"no cases for univariants or structs\")\n         }\n         NullablePointer{ .. } => {\n             assert!(discr == 0 || discr == 1);\n-            _match::single_result(rslt(bcx, C_i1(discr != 0)))\n+            _match::single_result(rslt(bcx, C_i1(bcx.ccx(), discr != 0)))\n         }\n     }\n }\n@@ -604,7 +604,7 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         }\n         Univariant(ref st, true) => {\n             assert_eq!(discr, 0);\n-            Store(bcx, C_bool(true),\n+            Store(bcx, C_bool(bcx.ccx(), true),\n                   GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n         Univariant(..) => {\n@@ -651,7 +651,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n     match *r {\n         CEnum(..) => {\n-            ccx.sess.bug(\"deref of c-like enum\")\n+            ccx.sess().bug(\"deref of c-like enum\")\n         }\n         Univariant(ref st, _) => {\n             *st.fields.get(0)\n@@ -661,7 +661,7 @@ pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n             *cases.get(0).fields.get(0)\n         }\n         NullablePointer{ .. } => {\n-            ccx.sess.bug(\"deref of nullable ptr\")\n+            ccx.sess().bug(\"deref of nullable ptr\")\n         }\n     }\n }\n@@ -674,7 +674,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n     // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n         CEnum(..) => {\n-            bcx.ccx().sess.bug(\"element access in C-like enum\")\n+            bcx.ccx().sess().bug(\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n             assert_eq!(discr, 0);\n@@ -706,7 +706,7 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n \n     let val = if needs_cast {\n         let fields = st.fields.map(|&ty| type_of::type_of(ccx, ty));\n-        let real_ty = Type::struct_(fields.as_slice(), st.packed);\n+        let real_ty = Type::struct_(ccx, fields.as_slice(), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -719,7 +719,7 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n pub fn trans_drop_flag_ptr(bcx: &Block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n         Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n-        _ => bcx.ccx().sess.bug(\"tried to get drop flag of non-droppable type\")\n+        _ => bcx.ccx().sess().bug(\"tried to get drop flag of non-droppable type\")\n     }\n }\n \n@@ -761,31 +761,31 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n                                               vec_ng::append(\n                                                   vec!(lldiscr),\n                                                   vals).as_slice());\n-            C_struct(vec_ng::append(\n+            C_struct(ccx, vec_ng::append(\n                         contents,\n-                        &[padding(max_sz - case.size)]).as_slice(),\n+                        &[padding(ccx, max_sz - case.size)]).as_slice(),\n                      false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(contents.as_slice(), st.packed)\n+            C_struct(ccx, contents.as_slice(), st.packed)\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n-                C_struct(build_const_struct(ccx,\n-                                            nonnull,\n-                                            vals.as_slice()).as_slice(),\n+                C_struct(ccx, build_const_struct(ccx,\n+                                                 nonnull,\n+                                                 vals).as_slice(),\n                          false)\n             } else {\n                 let vals = nonnull.fields.map(|&ty| {\n                     // Always use null even if it's not the `ptrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).move_iter().collect::<Vec<ValueRef> >();\n-                C_struct(build_const_struct(ccx,\n-                                            nonnull,\n-                                            vals.as_slice()).as_slice(),\n+                C_struct(ccx, build_const_struct(ccx,\n+                                                 nonnull,\n+                                                 vals.as_slice()).as_slice(),\n                          false)\n             }\n         }\n@@ -817,7 +817,7 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n         let target_offset = roundup(offset, type_align);\n         offset = roundup(offset, val_align);\n         if offset != target_offset {\n-            cfields.push(padding(target_offset - offset));\n+            cfields.push(padding(ccx, target_offset - offset));\n             offset = target_offset;\n         }\n         assert!(!is_undef(vals[i]));\n@@ -828,8 +828,8 @@ fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n     return cfields;\n }\n \n-fn padding(size: u64) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(), size))\n+fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(ccx), size))\n }\n \n // FIXME this utility routine should be somewhere more general\n@@ -874,7 +874,7 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n-        CEnum(..) => ccx.sess.bug(\"element access in C-like enum const\"),\n+        CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(ccx, val, ix),\n         General(..) => const_struct_field(ccx, val, ix + 1),\n         NullablePointer{ .. } => const_struct_field(ccx, val, ix)"}, {"sha": "7b04b51910188be220abb972e956c287294706f0", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -86,11 +86,11 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     // Depending on how many outputs we have, the return type is different\n     let output_type = if num_outputs == 0 {\n-        Type::void()\n+        Type::void(bcx.ccx())\n     } else if num_outputs == 1 {\n         *output_types.get(0)\n     } else {\n-        Type::struct_(output_types.as_slice(), false)\n+        Type::struct_(bcx.ccx(), output_types.as_slice(), false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "bcf0b5d5f64bdeed095b67c75454c194613ecdc6", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 327, "deletions": 393, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -34,7 +34,6 @@ use driver::driver::{CrateAnalysis, CrateTranslation};\n use lib::llvm::{ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, Vector};\n use lib;\n-use metadata::common::LinkMeta;\n use metadata::{csearch, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -73,7 +72,6 @@ use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n-use collections::HashMap;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::libc::c_uint;\n@@ -93,8 +91,6 @@ use syntax::{ast, ast_util, ast_map};\n \n use time;\n \n-pub use middle::trans::context::task_llcx;\n-\n local_data_key!(task_local_insn_key: Vec<&'static str> )\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n@@ -135,16 +131,16 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _x: () }\n }\n \n-pub struct StatRecorder {\n-    ccx: @CrateContext,\n+pub struct StatRecorder<'a> {\n+    ccx: &'a CrateContext,\n     name: Option<~str>,\n     start: u64,\n     istart: uint,\n }\n \n-impl StatRecorder {\n-    pub fn new(ccx: @CrateContext, name: ~str) -> StatRecorder {\n-        let start = if ccx.sess.trans_stats() {\n+impl<'a> StatRecorder<'a> {\n+    pub fn new(ccx: &'a CrateContext, name: ~str) -> StatRecorder<'a> {\n+        let start = if ccx.sess().trans_stats() {\n             time::precise_time_ns()\n         } else {\n             0\n@@ -160,9 +156,9 @@ impl StatRecorder {\n }\n \n #[unsafe_destructor]\n-impl Drop for StatRecorder {\n+impl<'a> Drop for StatRecorder<'a> {\n     fn drop(&mut self) {\n-        if self.ccx.sess.trans_stats() {\n+        if self.ccx.sess().trans_stats() {\n             let end = time::precise_time_ns();\n             let elapsed = ((end - self.start) / 1_000_000) as uint;\n             let iend = self.ccx.stats.n_llvm_insns.get();\n@@ -246,7 +242,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n     }\n \n     let f = decl_rust_fn(ccx, false, inputs, output, name);\n-    csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n+    csearch::get_item_attrs(&ccx.sess().cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n     });\n \n@@ -355,8 +351,8 @@ pub fn malloc_raw_dyn<'a>(\n         match li.require(it) {\n             Ok(id) => id,\n             Err(s) => {\n-                bcx.tcx().sess.fatal(format!(\"allocation of `{}` {}\",\n-                                          bcx.ty_to_str(t), s));\n+                bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n+                                         bcx.ty_to_str(t), s));\n             }\n         }\n     }\n@@ -393,7 +389,11 @@ pub fn malloc_raw_dyn<'a>(\n         let r = callee::trans_lang_call(\n             bcx,\n             langcall,\n-            [PointerCast(bcx, drop_glue, Type::glue_fn(Type::i8p()).ptr_to()), size, llalign],\n+            [\n+                PointerCast(bcx, drop_glue, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to()),\n+                size,\n+                llalign\n+            ],\n             None);\n         rslt(r.bcx, PointerCast(r.bcx, r.val, llty))\n     }\n@@ -522,13 +522,13 @@ pub fn set_no_split_stack(f: ValueRef) {\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: ~str) {\n     let mut all_llvm_symbols = ccx.all_llvm_symbols.borrow_mut();\n     if all_llvm_symbols.get().contains(&sym) {\n-        ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n+        ccx.sess().bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     all_llvm_symbols.get().insert(sym);\n }\n \n \n-pub fn get_res_dtor(ccx: @CrateContext,\n+pub fn get_res_dtor(ccx: &CrateContext,\n                     did: ast::DefId,\n                     parent_id: ast::DefId,\n                     substs: &[ty::t])\n@@ -547,15 +547,15 @@ pub fn get_res_dtor(ccx: @CrateContext,\n             tps: Vec::from_slice(substs),\n         };\n \n-        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx, did.node, &tsubsts);\n+        let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx(), did.node, &tsubsts);\n         let (val, _) = monomorphize::monomorphic_fn(ccx, did, &tsubsts, vtables, None, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {\n         get_item_val(ccx, did.node)\n     } else {\n-        let tcx = ccx.tcx;\n-        let name = csearch::get_symbol(ccx.sess.cstore, did);\n+        let tcx = ccx.tcx();\n+        let name = csearch::get_symbol(&ccx.sess().cstore, did);\n         let class_ty = ty::subst_tps(tcx,\n                                      substs,\n                                      None,\n@@ -572,7 +572,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n \n // Structural comparison: a rather involved form of glue.\n pub fn maybe_name_value(cx: &CrateContext, v: ValueRef, s: &str) {\n-    if cx.sess.opts.cg.save_temps {\n+    if cx.sess().opts.cg.save_temps {\n         s.with_c_str(|buf| {\n             unsafe {\n                 llvm::LLVMSetValueName(v, buf)\n@@ -617,16 +617,15 @@ pub fn compare_scalar_values<'a>(\n                              -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: &Block) -> ! {\n-        cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n-                           comparison operator\");\n+        cx.sess().bug(\"compare_scalar_values: must be a comparison operator\");\n     }\n     match nt {\n       nil_type => {\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         match op {\n-          ast::BiEq | ast::BiLe | ast::BiGe => return C_i1(true),\n-          ast::BiNe | ast::BiLt | ast::BiGt => return C_i1(false),\n+          ast::BiEq | ast::BiLe | ast::BiGe => return C_i1(cx.ccx(), true),\n+          ast::BiNe | ast::BiLt | ast::BiGt => return C_i1(cx.ccx(), false),\n           // refinements would be nice\n           _ => die(cx)\n         }\n@@ -745,7 +744,7 @@ pub fn iter_structural_ty<'r,\n           let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n-          let variants = ty::enum_variants(ccx.tcx, tid);\n+          let variants = ty::enum_variants(ccx.tcx(), tid);\n           let n_variants = (*variants).len();\n \n           // NB: we must hit the discriminant first so that structural\n@@ -772,8 +771,8 @@ pub fn iter_structural_ty<'r,\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n                           }\n-                          _ => ccx.sess.unimpl(\"value from adt::trans_case \\\n-                                                in iter_structural_ty\")\n+                          _ => ccx.sess().unimpl(\"value from adt::trans_case \\\n+                                                  in iter_structural_ty\")\n                       }\n                       let variant_cx =\n                           iter_variant(variant_cx,\n@@ -786,8 +785,8 @@ pub fn iter_structural_ty<'r,\n                   }\n                   cx = next_cx;\n               }\n-              _ => ccx.sess.unimpl(\"value from adt::trans_switch \\\n-                                    in iter_structural_ty\")\n+              _ => ccx.sess().unimpl(\"value from adt::trans_switch \\\n+                                      in iter_structural_ty\")\n           }\n       }\n       _ => cx.sess().unimpl(\"type in iter_structural_ty\")\n@@ -865,8 +864,8 @@ pub fn fail_if_zero<'a>(\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       _ => {\n-        cx.tcx().sess.bug(~\"fail-if-zero on unexpected type: \" +\n-                          ty_to_str(cx.ccx().tcx, rhs_t));\n+        cx.sess().bug(~\"fail-if-zero on unexpected type: \" +\n+                      ty_to_str(cx.tcx(), rhs_t));\n       }\n     };\n     with_cond(cx, is_zero, |bcx| {\n@@ -875,11 +874,11 @@ pub fn fail_if_zero<'a>(\n }\n \n pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n-    let name = csearch::get_symbol(ccx.sess.cstore, did);\n+    let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            match fn_ty.abis.for_target(ccx.sess.targ_cfg.os,\n-                                        ccx.sess.targ_cfg.arch) {\n+            match fn_ty.abis.for_target(ccx.sess().targ_cfg.os,\n+                                        ccx.sess().targ_cfg.arch) {\n                 Some(Rust) | Some(RustIntrinsic) => {\n                     get_extern_rust_fn(ccx,\n                                        fn_ty.sig.inputs.as_slice(),\n@@ -921,7 +920,7 @@ pub fn invoke<'a>(\n               -> (ValueRef, &'a Block<'a>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n-        return (C_null(Type::i8()), bcx);\n+        return (C_null(Type::i8(bcx.ccx())), bcx);\n     }\n \n     match bcx.opt_node_id {\n@@ -970,7 +969,7 @@ pub fn invoke<'a>(\n }\n \n pub fn need_invoke(bcx: &Block) -> bool {\n-    if bcx.ccx().sess.no_landing_pads() {\n+    if bcx.sess().no_landing_pads() {\n         return false;\n     }\n \n@@ -984,7 +983,7 @@ pub fn need_invoke(bcx: &Block) -> bool {\n \n pub fn do_spill(bcx: &Block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n-        return C_null(Type::i8p());\n+        return C_null(Type::i8p(bcx.ccx()));\n     }\n     let llptr = alloc_ty(bcx, t, \"\");\n     Store(bcx, v, llptr);\n@@ -1081,16 +1080,16 @@ pub fn with_cond<'a>(\n pub fn call_memcpy(cx: &Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess.targ_cfg.arch {\n+    let key = match ccx.sess().targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memcpy.p0i8.p0i8.i32\",\n         X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n     let memcpy = ccx.intrinsics.get_copy(&key);\n-    let src_ptr = PointerCast(cx, src, Type::i8p());\n-    let dst_ptr = PointerCast(cx, dst, Type::i8p());\n+    let src_ptr = PointerCast(cx, src, Type::i8p(ccx));\n+    let dst_ptr = PointerCast(cx, dst, Type::i8p(ccx));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n-    let align = C_i32(align as i32);\n-    let volatile = C_i1(false);\n+    let align = C_i32(ccx, align as i32);\n+    let volatile = C_i1(ccx, false);\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], []);\n }\n \n@@ -1125,17 +1124,17 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n-    let intrinsic_key = match ccx.sess.targ_cfg.arch {\n+    let intrinsic_key = match ccx.sess().targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memset.p0i8.i32\",\n         X86_64 => \"llvm.memset.p0i8.i64\"\n     };\n \n     let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n-    let llptr = b.pointercast(llptr, Type::i8().ptr_to());\n-    let llzeroval = C_u8(0);\n+    let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n+    let llzeroval = C_u8(ccx, 0);\n     let size = machine::llsize_of(ccx, ty);\n-    let align = C_i32(llalign_of_min(ccx, ty) as i32);\n-    let volatile = C_i1(false);\n+    let align = C_i32(ccx, llalign_of_min(ccx, ty) as i32);\n+    let volatile = C_i1(ccx, false);\n     b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], []);\n }\n \n@@ -1184,24 +1183,6 @@ pub struct BasicBlocks {\n     sa: BasicBlockRef,\n }\n \n-pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n-    unsafe {\n-        let cx = task_llcx();\n-        \"static_allocas\".with_c_str(|buf| {\n-            llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        })\n-    }\n-}\n-\n-pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n-    unsafe {\n-        let cx = task_llcx();\n-        \"return\".with_c_str(|buf| {\n-            llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)\n-        })\n-    }\n-}\n-\n // Creates and returns space for, or returns the argument representing, the\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n@@ -1226,7 +1207,7 @@ pub fn make_return_pointer(fcx: &FunctionContext, output_type: ty::t)\n //\n // Be warned! You must call `init_function` before doing anything with the\n // returned function context.\n-pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n+pub fn new_fn_ctxt<'a>(ccx: &'a CrateContext,\n                        llfndecl: ValueRef,\n                        id: ast::NodeId,\n                        has_env: bool,\n@@ -1239,12 +1220,12 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n \n     debug!(\"new_fn_ctxt(path={}, id={}, param_substs={})\",\n            if id == -1 { ~\"\" } else { ccx.tcx.map.path_to_str(id) },\n-           id, param_substs.repr(ccx.tcx));\n+           id, param_substs.repr(ccx.tcx()));\n \n     let substd_output_type = match param_substs {\n         None => output_type,\n         Some(substs) => {\n-            ty::subst_tps(ccx.tcx,\n+            ty::subst_tps(ccx.tcx(),\n                           substs.tys.as_slice(),\n                           substs.self_ty,\n                           output_type)\n@@ -1297,14 +1278,14 @@ pub fn init_function<'a>(\n     // Use a dummy instruction as the insertion point for all allocas.\n     // This is later removed in FunctionContext::cleanup.\n     fcx.alloca_insert_pt.set(Some(unsafe {\n-        Load(entry_bcx, C_null(Type::i8p()));\n+        Load(entry_bcx, C_null(Type::i8p(fcx.ccx)));\n         llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n     }));\n \n     let substd_output_type = match param_substs {\n         None => output_type,\n         Some(substs) => {\n-            ty::subst_tps(fcx.ccx.tcx,\n+            ty::subst_tps(fcx.ccx.tcx(),\n                           substs.tys.as_slice(),\n                           substs.self_ty,\n                           output_type)\n@@ -1384,7 +1365,7 @@ fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n \n         bcx = _match::store_arg(bcx, args[i].pat, arg_datum, arg_scope_id);\n \n-        if fcx.ccx.sess.opts.debuginfo == FullDebugInfo {\n+        if fcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n             debuginfo::create_argument_metadata(bcx, &args[i]);\n         }\n     }\n@@ -1444,24 +1425,24 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-pub fn trans_closure<'a>(ccx: @CrateContext,\n-                         decl: &ast::FnDecl,\n-                         body: &ast::Block,\n-                         llfndecl: ValueRef,\n-                         param_substs: Option<@param_substs>,\n-                         id: ast::NodeId,\n-                         _attributes: &[ast::Attribute],\n-                         output_type: ty::t,\n-                         maybe_load_env: <'b> |&'b Block<'b>| -> &'b Block<'b>) {\n+pub fn trans_closure(ccx: &CrateContext,\n+                     decl: &ast::FnDecl,\n+                     body: &ast::Block,\n+                     llfndecl: ValueRef,\n+                     param_substs: Option<@param_substs>,\n+                     id: ast::NodeId,\n+                     _attributes: &[ast::Attribute],\n+                     output_type: ty::t,\n+                     maybe_load_env: <'a> |&'a Block<'a>| -> &'a Block<'a>) {\n     ccx.stats.n_closures.set(ccx.stats.n_closures.get() + 1);\n \n     let _icx = push_ctxt(\"trans_closure\");\n     set_uwtable(llfndecl);\n \n     debug!(\"trans_closure(..., param_substs={})\",\n-           param_substs.repr(ccx.tcx));\n+           param_substs.repr(ccx.tcx()));\n \n-    let has_env = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n+    let has_env = match ty::get(ty::node_id_to_type(ccx.tcx(), id)).sty {\n         ty::ty_closure(_) => true,\n         _ => false\n     };\n@@ -1544,22 +1525,22 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-pub fn trans_fn(ccx: @CrateContext,\n+pub fn trans_fn(ccx: &CrateContext,\n                 decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n                 param_substs: Option<@param_substs>,\n                 id: ast::NodeId,\n                 attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx.map.path_to_str(id));\n-    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx));\n+    debug!(\"trans_fn(param_substs={})\", param_substs.repr(ccx.tcx()));\n     let _icx = push_ctxt(\"trans_fn\");\n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), id));\n     trans_closure(ccx, decl, body, llfndecl,\n                   param_substs, id, attrs, output_type, |bcx| bcx);\n }\n \n-pub fn trans_enum_variant(ccx: @CrateContext,\n+pub fn trans_enum_variant(ccx: &CrateContext,\n                           _enum_id: ast::NodeId,\n                           variant: &ast::Variant,\n                           _args: &[ast::VariantArg],\n@@ -1576,7 +1557,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n         llfndecl);\n }\n \n-pub fn trans_tuple_struct(ccx: @CrateContext,\n+pub fn trans_tuple_struct(ccx: &CrateContext,\n                           _fields: &[ast::StructField],\n                           ctor_id: ast::NodeId,\n                           param_substs: Option<@param_substs>,\n@@ -1591,7 +1572,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n         llfndecl);\n }\n \n-fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n+fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n                                            ctor_id: ast::NodeId,\n                                            disr: ty::Disr,\n                                            param_substs: Option<@param_substs>,\n@@ -1608,17 +1589,17 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n         }\n     };\n \n-    let ctor_ty = ty::subst_tps(ccx.tcx,\n+    let ctor_ty = ty::subst_tps(ccx.tcx(),\n                                 ty_param_substs,\n                                 None,\n-                                ty::node_id_to_type(ccx.tcx, ctor_id));\n+                                ty::node_id_to_type(ccx.tcx(), ctor_id));\n \n     let result_ty = match ty::get(ctor_ty).sty {\n         ty::ty_bare_fn(ref bft) => bft.sig.output,\n-        _ => ccx.sess.bug(\n+        _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                   unexpected ctor return type {}\",\n-                 ty_to_str(ccx.tcx, ctor_ty)))\n+                 ty_to_str(ccx.tcx(), ctor_ty)))\n     };\n \n     let arena = TypedArena::new();\n@@ -1648,8 +1629,8 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n     finish_fn(&fcx, bcx);\n }\n \n-pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n-                      id: ast::NodeId, vi: @Vec<@ty::VariantInfo> ,\n+pub fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n+                      id: ast::NodeId, vi: @Vec<@ty::VariantInfo>,\n                       i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n         let disr_val = vi.get(*i).disr_val;\n@@ -1671,17 +1652,17 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n     }\n }\n \n-pub struct TransItemVisitor {\n-    ccx: @CrateContext,\n+pub struct TransItemVisitor<'a> {\n+    ccx: &'a CrateContext,\n }\n \n-impl Visitor<()> for TransItemVisitor {\n+impl<'a> Visitor<()> for TransItemVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _:()) {\n         trans_item(self.ccx, i);\n     }\n }\n \n-pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n+pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     match item.node {\n       ast::ItemFn(decl, purity, _abis, ref generics, body) => {\n@@ -1713,7 +1694,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n       }\n       ast::ItemEnum(ref enum_definition, ref generics) => {\n         if !generics.is_type_parameterized() {\n-            let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n+            let vi = ty::enum_variants(ccx.tcx(), local_def(item.id));\n             let mut i = 0;\n             trans_enum_def(ccx, enum_definition, item.id, vi, &mut i);\n         }\n@@ -1724,16 +1705,16 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n           // because we need to get the value of the bool out of LLVM\n           if attr::contains_name(item.attrs.as_slice(), \"static_assert\") {\n               if m == ast::MutMutable {\n-                  ccx.sess.span_fatal(expr.span,\n-                                      \"cannot have static_assert on a mutable \\\n-                                       static\");\n+                  ccx.sess().span_fatal(expr.span,\n+                                        \"cannot have static_assert on a mutable \\\n+                                         static\");\n               }\n \n               let const_values = ccx.const_values.borrow();\n               let v = const_values.get().get_copy(&item.id);\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n-                      ccx.sess.span_fatal(expr.span, \"static assertion failed\");\n+                      ccx.sess().span_fatal(expr.span, \"static assertion failed\");\n                   }\n               }\n           }\n@@ -1758,7 +1739,7 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::StructDef) {\n+pub fn trans_struct_def(ccx: &CrateContext, struct_def: @ast::StructDef) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -1777,33 +1758,27 @@ pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::StructDef) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @CrateContext, m: &ast::Mod) {\n+pub fn trans_mod(ccx: &CrateContext, m: &ast::Mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n     for item in m.items.iter() {\n         trans_item(ccx, *item);\n     }\n }\n \n-fn finish_register_fn(ccx: @CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n+fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n-    {\n-        let mut item_symbols = ccx.item_symbols.borrow_mut();\n-        item_symbols.get().insert(node_id, sym);\n-    }\n+    ccx.item_symbols.borrow_mut().get().insert(node_id, sym);\n \n-    {\n-        let reachable = ccx.reachable.borrow();\n-        if !reachable.get().contains(&node_id) {\n-            lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n-        }\n+    if !ccx.reachable.contains(&node_id) {\n+        lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     }\n \n-    if is_entry_fn(&ccx.sess, node_id) && !ccx.sess.building_library.get() {\n+    if is_entry_fn(ccx.sess(), node_id) && !ccx.sess().building_library.get() {\n         create_entry_wrapper(ccx, sp, llfn);\n     }\n }\n \n-fn register_fn(ccx: @CrateContext,\n+fn register_fn(ccx: &CrateContext,\n                sp: Span,\n                sym: ~str,\n                node_id: ast::NodeId,\n@@ -1827,7 +1802,7 @@ fn register_fn(ccx: @CrateContext,\n }\n \n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n-pub fn register_fn_llvmty(ccx: @CrateContext,\n+pub fn register_fn_llvmty(ccx: &CrateContext,\n                           sp: Span,\n                           sym: ~str,\n                           node_id: ast::NodeId,\n@@ -1850,10 +1825,10 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-pub fn create_entry_wrapper(ccx: @CrateContext,\n+pub fn create_entry_wrapper(ccx: &CrateContext,\n                            _sp: Span,\n                            main_llfn: ValueRef) {\n-    let et = ccx.sess.entry_type.get().unwrap();\n+    let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         session::EntryMain => {\n             create_entry_fn(ccx, main_llfn, true);\n@@ -1862,10 +1837,10 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         session::EntryNone => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn(ccx: @CrateContext,\n+    fn create_entry_fn(ccx: &CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()],\n+        let llfty = Type::func([ccx.int_type, Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type);\n \n         let llfn = decl_cdecl_fn(ccx.llmod, \"main\", llfty, ty::mk_nil());\n@@ -1881,19 +1856,19 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx.lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.tcx.sess.fatal(s); }\n+                    Err(s) => { ccx.sess().fatal(s); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n                 } else {\n-                    let start_fn_type = csearch::get_type(ccx.tcx,\n+                    let start_fn_type = csearch::get_type(ccx.tcx(),\n                                                           start_def_id).ty;\n                     trans_external_path(ccx, start_def_id, start_fn_type)\n                 };\n \n                 let args = {\n                     let opaque_rust_main = \"rust_main\".with_c_str(|buf| {\n-                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p().to_ref(), buf)\n+                        llvm::LLVMBuildPointerCast(bld, rust_main, Type::i8p(ccx).to_ref(), buf)\n                     });\n \n                     vec!(\n@@ -1942,7 +1917,7 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n     }\n }\n \n-pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n+pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{:?}`)\", id);\n \n     let val = {\n@@ -1957,7 +1932,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n             let item = ccx.tcx.map.get(id);\n             let val = match item {\n                 ast_map::NodeItem(i) => {\n-                    let ty = ty::node_id_to_type(ccx.tcx, i.id);\n+                    let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n                     let sym = exported_name(ccx, id, ty, i.attrs.as_slice());\n \n                     let v = match i.node {\n@@ -1973,7 +1948,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                 match external_srcs.get().find(&i.id) {\n                                     Some(&did) => {\n                                         debug!(\"but found in other crate...\");\n-                                        (csearch::get_symbol(ccx.sess.cstore,\n+                                        (csearch::get_symbol(&ccx.sess().cstore,\n                                                              did), false)\n                                     }\n                                     None => (sym, true)\n@@ -1996,27 +1971,17 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                                     llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n                                 });\n \n-                                {\n-                                    let reachable = ccx.reachable.borrow();\n-                                    if !reachable.get().contains(&id) {\n-                                        lib::llvm::SetLinkage(\n-                                            g,\n-                                            lib::llvm::InternalLinkage);\n-                                    }\n+                                if !ccx.reachable.contains(&id) {\n+                                    lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n                                 }\n \n                                 // Apply the `unnamed_addr` attribute if\n                                 // requested\n                                 if attr::contains_name(i.attrs.as_slice(),\n-                                                       \"address_insignificant\"){\n-                                    {\n-                                        let reachable =\n-                                            ccx.reachable.borrow();\n-                                        if reachable.get().contains(&id) {\n-                                            ccx.sess.span_bug(i.span,\n-                                                \"insignificant static is \\\n-                                                 reachable\");\n-                                        }\n+                                                       \"address_insignificant\") {\n+                                    if ccx.reachable.contains(&id) {\n+                                        ccx.sess().span_bug(i.span,\n+                                            \"insignificant static is reachable\");\n                                     }\n                                     lib::llvm::SetUnnamedAddr(g, true);\n \n@@ -2093,8 +2058,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     debug!(\"get_item_val(): processing a NodeTraitMethod\");\n                     match *trait_method {\n                         ast::Required(_) => {\n-                            ccx.sess.bug(\"unexpected variant: required trait method in \\\n-                                         get_item_val()\");\n+                            ccx.sess().bug(\"unexpected variant: required trait method in \\\n+                                           get_item_val()\");\n                         }\n                         ast::Provided(m) => {\n                             register_method(ccx, id, m)\n@@ -2125,7 +2090,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     match v.node.kind {\n                         ast::TupleVariantKind(ref args) => {\n                             assert!(args.len() != 0u);\n-                            let ty = ty::node_id_to_type(ccx.tcx, id);\n+                            let ty = ty::node_id_to_type(ccx.tcx(), id);\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let enm = ccx.tcx.map.expect_item(parent);\n                             let sym = exported_name(ccx,\n@@ -2152,13 +2117,13 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                     // Only register the constructor if this is a tuple-like struct.\n                     match struct_def.ctor_id {\n                         None => {\n-                            ccx.tcx.sess.bug(\"attempt to register a constructor of \\\n-                                              a non-tuple-like struct\")\n+                            ccx.sess().bug(\"attempt to register a constructor of \\\n+                                            a non-tuple-like struct\")\n                         }\n                         Some(ctor_id) => {\n                             let parent = ccx.tcx.map.get_parent(id);\n                             let struct_item = ccx.tcx.map.expect_item(parent);\n-                            let ty = ty::node_id_to_type(ccx.tcx, ctor_id);\n+                            let ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n                             let sym = exported_name(ccx,\n                                                     id,\n                                                     ty,\n@@ -2173,19 +2138,16 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n \n                 ref variant => {\n-                    ccx.sess.bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                 variant))\n+                    ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n+                                   variant))\n                 }\n             };\n \n             // foreign items (extern fns and extern statics) don't have internal\n             // linkage b/c that doesn't quite make sense. Otherwise items can\n             // have internal linkage if they're not reachable.\n-            {\n-                let reachable = ccx.reachable.borrow();\n-                if !foreign && !reachable.get().contains(&id) {\n-                    lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n-                }\n+            if !foreign && !ccx.reachable.contains(&id) {\n+                lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n             }\n \n             let mut item_vals = ccx.item_vals.borrow_mut();\n@@ -2195,9 +2157,9 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n }\n \n-fn register_method(ccx: @CrateContext, id: ast::NodeId,\n+fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n-    let mty = ty::node_id_to_type(ccx.tcx, id);\n+    let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n     let sym = exported_name(ccx, id, mty, m.attrs.as_slice());\n \n@@ -2217,184 +2179,166 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-macro_rules! ifn (\n-    ($intrinsics:ident, $name:expr, $args:expr, $ret:expr) => ({\n-        let name = $name;\n-        // HACK(eddyb) dummy output type, shouln't affect anything.\n-        let f = decl_cdecl_fn(llmod, name, Type::func($args, &$ret), ty::mk_nil());\n-        $intrinsics.insert(name, f);\n-    })\n-)\n-\n-pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n-    let i8p = Type::i8p();\n-    let mut intrinsics = HashMap::new();\n-\n-    ifn!(intrinsics, \"llvm.memcpy.p0i8.p0i8.i32\",\n-         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memcpy.p0i8.p0i8.i64\",\n-         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memmove.p0i8.p0i8.i32\",\n-         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memmove.p0i8.p0i8.i64\",\n-         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memset.p0i8.i32\",\n-         [i8p, Type::i8(), Type::i32(), Type::i32(), Type::i1()], Type::void());\n-    ifn!(intrinsics, \"llvm.memset.p0i8.i64\",\n-         [i8p, Type::i8(), Type::i64(), Type::i32(), Type::i1()], Type::void());\n-\n-    ifn!(intrinsics, \"llvm.trap\", [], Type::void());\n-    ifn!(intrinsics, \"llvm.debugtrap\", [], Type::void());\n-    ifn!(intrinsics, \"llvm.frameaddress\", [Type::i32()], i8p);\n-\n-    ifn!(intrinsics, \"llvm.powi.f32\", [Type::f32(), Type::i32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.powi.f64\", [Type::f64(), Type::i32()], Type::f64());\n-    ifn!(intrinsics, \"llvm.pow.f32\",  [Type::f32(), Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.pow.f64\",  [Type::f64(), Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.sqrt.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.sqrt.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.sin.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.sin.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.cos.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.cos.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.exp.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.exp.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.exp2.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.exp2.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.log.f32\",  [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.log.f64\",  [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.log10.f32\",[Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.log10.f64\",[Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.log2.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.log2.f64\", [Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.fma.f32\",  [Type::f32(), Type::f32(), Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.fma.f64\",  [Type::f64(), Type::f64(), Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.fabs.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.fabs.f64\", [Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.floor.f32\",[Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.floor.f64\",[Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.ceil.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.ceil.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.trunc.f32\",[Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.trunc.f64\",[Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.rint.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.rint.f64\", [Type::f64()], Type::f64());\n-    ifn!(intrinsics, \"llvm.nearbyint.f32\", [Type::f32()], Type::f32());\n-    ifn!(intrinsics, \"llvm.nearbyint.f64\", [Type::f64()], Type::f64());\n-\n-    ifn!(intrinsics, \"llvm.ctpop.i8\", [Type::i8()], Type::i8());\n-    ifn!(intrinsics, \"llvm.ctpop.i16\",[Type::i16()], Type::i16());\n-    ifn!(intrinsics, \"llvm.ctpop.i32\",[Type::i32()], Type::i32());\n-    ifn!(intrinsics, \"llvm.ctpop.i64\",[Type::i64()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.ctlz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n-    ifn!(intrinsics, \"llvm.ctlz.i16\", [Type::i16(), Type::i1()], Type::i16());\n-    ifn!(intrinsics, \"llvm.ctlz.i32\", [Type::i32(), Type::i1()], Type::i32());\n-    ifn!(intrinsics, \"llvm.ctlz.i64\", [Type::i64(), Type::i1()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.cttz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n-    ifn!(intrinsics, \"llvm.cttz.i16\", [Type::i16(), Type::i1()], Type::i16());\n-    ifn!(intrinsics, \"llvm.cttz.i32\", [Type::i32(), Type::i1()], Type::i32());\n-    ifn!(intrinsics, \"llvm.cttz.i64\", [Type::i64(), Type::i1()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.bswap.i16\",[Type::i16()], Type::i16());\n-    ifn!(intrinsics, \"llvm.bswap.i32\",[Type::i32()], Type::i32());\n-    ifn!(intrinsics, \"llvm.bswap.i64\",[Type::i64()], Type::i64());\n-\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.sadd.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.uadd.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.ssub.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.usub.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.smul.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i8\",\n-        [Type::i8(), Type::i8()], Type::struct_([Type::i8(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i16\",\n-        [Type::i16(), Type::i16()], Type::struct_([Type::i16(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i32\",\n-        [Type::i32(), Type::i32()], Type::struct_([Type::i32(), Type::i1()], false));\n-    ifn!(intrinsics, \"llvm.umul.with.overflow.i64\",\n-        [Type::i64(), Type::i64()], Type::struct_([Type::i64(), Type::i1()], false));\n-\n-    ifn!(intrinsics, \"llvm.expect.i1\", [Type::i1(), Type::i1()], Type::i1());\n+\n+pub fn declare_intrinsics(ccx: &mut CrateContext) {\n+    macro_rules! ifn (\n+        ($name:expr fn() -> $ret:expr) => ({\n+            let name = $name;\n+            // HACK(eddyb) dummy output type, shouln't affect anything.\n+            let f = decl_cdecl_fn(ccx.llmod, name, Type::func([], &$ret), ty::mk_nil());\n+            ccx.intrinsics.insert(name, f);\n+        });\n+        ($name:expr fn($($arg:expr),*) -> $ret:expr) => ({\n+            let name = $name;\n+            // HACK(eddyb) dummy output type, shouln't affect anything.\n+            let f = decl_cdecl_fn(ccx.llmod, name,\n+                                  Type::func([$($arg),*], &$ret), ty::mk_nil());\n+            ccx.intrinsics.insert(name, f);\n+        })\n+    )\n+    macro_rules! mk_struct (\n+        ($($field_ty:expr),*) => (Type::struct_(ccx, [$($field_ty),*], false))\n+    )\n+\n+    let i8p = Type::i8p(ccx);\n+    let void = Type::void(ccx);\n+    let i1 = Type::i1(ccx);\n+    let t_i8 = Type::i8(ccx);\n+    let t_i16 = Type::i16(ccx);\n+    let t_i32 = Type::i32(ccx);\n+    let t_i64 = Type::i64(ccx);\n+    let t_f32 = Type::f32(ccx);\n+    let t_f64 = Type::f64(ccx);\n+\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i32\" fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i64\" fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n+\n+    ifn!(\"llvm.trap\" fn() -> void);\n+    ifn!(\"llvm.debugtrap\" fn() -> void);\n+    ifn!(\"llvm.frameaddress\" fn(t_i32) -> i8p);\n+\n+    ifn!(\"llvm.powi.f32\" fn(t_f32, t_i32) -> t_f32);\n+    ifn!(\"llvm.powi.f64\" fn(t_f64, t_i32) -> t_f64);\n+    ifn!(\"llvm.pow.f32\" fn(t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.pow.f64\" fn(t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.sqrt.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sqrt.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sin.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sin.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.cos.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.cos.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp2.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp2.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log10.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log10.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log2.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log2.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fma.f32\" fn(t_f32, t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.fma.f64\" fn(t_f64, t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fabs.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.fabs.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.floor.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.floor.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.ceil.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.ceil.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.trunc.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.trunc.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.rint.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.rint.f64\" fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.nearbyint.f32\" fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.nearbyint.f64\" fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.ctpop.i8\" fn(t_i8) -> t_i8);\n+    ifn!(\"llvm.ctpop.i16\" fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.ctpop.i32\" fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.ctpop.i64\" fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.ctlz.i8\" fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.ctlz.i16\" fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.ctlz.i32\" fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.ctlz.i64\" fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.cttz.i8\" fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.cttz.i16\" fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.cttz.i32\" fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.cttz.i64\" fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.bswap.i16\" fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.bswap.i32\" fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.bswap.i64\" fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.sadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.uadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.ssub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.usub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.usub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.usub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.usub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.smul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.smul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.smul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.smul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.umul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.umul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.umul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.umul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.expect.i1\" fn(i1, i1) -> i1);\n \n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such. Currently, all of these intrinsics\n     // were introduced in LLVM 3.4, so we case on that.\n     macro_rules! compatible_ifn (\n-        ($intrinsics:ident, $name:expr, $cname:expr, $args:expr, $ret:expr) => ({\n+        ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => ({\n             let name = $name;\n             if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n-                ifn!($intrinsics, $name, $args, $ret);\n+                ifn!(name fn($($arg),*) -> $ret);\n             } else {\n-                let f = decl_cdecl_fn(llmod, $cname,\n-                                      Type::func($args, &$ret),\n+                let f = decl_cdecl_fn(ccx.llmod, stringify!($cname),\n+                                      Type::func([$($arg),*], &$ret),\n                                       ty::mk_nil());\n-                $intrinsics.insert(name, f);\n+                ccx.intrinsics.insert(name, f);\n             }\n         })\n     )\n \n-    compatible_ifn!(intrinsics, \"llvm.copysign.f32\", \"copysignf\",\n-                    [Type::f32(), Type::f32()], Type::f32());\n-    compatible_ifn!(intrinsics, \"llvm.copysign.f64\", \"copysign\",\n-                    [Type::f64(), Type::f64()], Type::f64());\n-    compatible_ifn!(intrinsics, \"llvm.round.f32\", \"roundf\",\n-                    [Type::f32()], Type::f32());\n-    compatible_ifn!(intrinsics, \"llvm.round.f64\", \"round\",\n-                    [Type::f64()], Type::f64());\n+    compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n+    compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);\n+    compatible_ifn!(\"llvm.round.f32\", roundf(t_f32) -> t_f32);\n+    compatible_ifn!(\"llvm.round.f64\", round(t_f64) -> t_f64);\n \n-    return intrinsics;\n-}\n \n-pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'static str, ValueRef>) {\n-    ifn!(intrinsics, \"llvm.dbg.declare\", [Type::metadata(), Type::metadata()], Type::void());\n-    ifn!(intrinsics,\n-         \"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n+    if ccx.sess().opts.debuginfo != NoDebugInfo {\n+        ifn!(\"llvm.dbg.declare\" fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n+        ifn!(\"llvm.dbg.value\" fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n+    }\n }\n \n pub fn trap(bcx: &Block) {\n@@ -2409,50 +2353,49 @@ pub fn symname(name: &str, hash: &str, vers: &str) -> ~str {\n     link::exported_name(ast_map::Values(path.iter()).chain(None), hash, vers)\n }\n \n-pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n-                      llmod: ModuleRef) -> (~str, ValueRef) {\n-    let targ_cfg = sess.targ_cfg;\n-    let int_type = Type::int(targ_cfg.arch);\n+pub fn decl_crate_map(ccx: &mut CrateContext) {\n     let mut n_subcrates = 1;\n-    let cstore = sess.cstore;\n-    while cstore.have_crate_data(n_subcrates) { n_subcrates += 1; }\n-    let is_top = !sess.building_library.get() || sess.opts.cg.gen_crate_map;\n+    while ccx.sess().cstore.have_crate_data(n_subcrates) {\n+        n_subcrates += 1;\n+    }\n+    let is_top = !ccx.sess().building_library.get() || ccx.sess().opts.cg.gen_crate_map;\n     let sym_name = if is_top {\n         ~\"_rust_crate_map_toplevel\"\n     } else {\n-        symname(\"_rust_crate_map_\" + mapmeta.crateid.name,\n-                mapmeta.crate_hash.as_str(),\n-                mapmeta.crateid.version_or_default())\n+        symname(\"_rust_crate_map_\" + ccx.link_meta.crateid.name,\n+                ccx.link_meta.crate_hash.as_str(),\n+                ccx.link_meta.crateid.version_or_default())\n     };\n \n-    let maptype = Type::struct_([\n-        Type::i32(),        // version\n-        int_type.ptr_to(),  // event loop factory\n+    let maptype = Type::struct_(ccx, [\n+        Type::i32(ccx),        // version\n+        ccx.int_type.ptr_to(), // event loop factory\n     ], false);\n     let map = sym_name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(llmod, maptype.to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, maptype.to_ref(), buf)\n         }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::ExternalLinkage);\n \n     // On windows we'd like to export the toplevel cratemap\n     // such that we can find it from libstd.\n-    if targ_cfg.os == OsWin32 && is_top {\n+    if ccx.sess().targ_cfg.os == OsWin32 && is_top {\n         unsafe { llvm::LLVMRustSetDLLExportStorageClass(map) }\n     }\n \n-    return (sym_name, map);\n+    ccx.crate_map_name = sym_name;\n+    ccx.crate_map = map;\n }\n \n-pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n+pub fn fill_crate_map(ccx: &CrateContext, map: ValueRef) {\n     let event_loop_factory = match ccx.tcx.lang_items.event_loop_factory() {\n         Some(did) => unsafe {\n             if is_local(did) {\n                 llvm::LLVMConstPointerCast(get_item_val(ccx, did.node),\n                                            ccx.int_type.ptr_to().to_ref())\n             } else {\n-                let name = csearch::get_symbol(ccx.sess.cstore, did);\n+                let name = csearch::get_symbol(&ccx.sess().cstore, did);\n                 let global = name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type.to_ref(), buf)\n                 });\n@@ -2462,8 +2405,8 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n         None => C_null(ccx.int_type.ptr_to())\n     };\n     unsafe {\n-        llvm::LLVMSetInitializer(map, C_struct(\n-            [C_i32(2),\n+        llvm::LLVMSetInitializer(map, C_struct(ccx,\n+            [C_i32(ccx, 2),\n             event_loop_factory,\n         ], false));\n     }\n@@ -2472,37 +2415,37 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::EncodeInlinedItem<'r>)\n     -> encoder::EncodeParams<'r> {\n \n-        let diag = cx.sess.diagnostic();\n+        let diag = cx.sess().diagnostic();\n         let item_symbols = &cx.item_symbols;\n         let link_meta = &cx.link_meta;\n         encoder::EncodeParams {\n             diag: diag,\n-            tcx: cx.tcx,\n+            tcx: cx.tcx(),\n             reexports2: cx.exp_map2,\n             item_symbols: item_symbols,\n             non_inlineable_statics: &cx.non_inlineable_statics,\n             link_meta: link_meta,\n-            cstore: cx.sess.cstore,\n+            cstore: &cx.sess().cstore,\n             encode_inlined_item: ie,\n         }\n }\n \n pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     use flate;\n \n-    if !cx.sess.building_library.get() {\n+    if !cx.sess().building_library.get() {\n         return Vec::new()\n     }\n \n     let encode_inlined_item: encoder::EncodeInlinedItem =\n-        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii, cx.maps);\n+        |ecx, ebml_w, ii| astencode::encode_inlined_item(ecx, ebml_w, ii, &cx.maps);\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let compressed = encoder::metadata_encoding_version +\n                         flate::deflate_bytes(metadata.as_slice()).as_slice();\n-    let llmeta = C_bytes(compressed);\n-    let llconst = C_struct([llmeta], false);\n+    let llmeta = C_bytes(cx, compressed);\n+    let llconst = C_struct(cx, [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,\n                        cx.link_meta.crateid.version_or_default(), cx.link_meta.crate_hash);\n     let llglobal = name.with_c_str(|buf| {\n@@ -2512,17 +2455,18 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     });\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        cx.sess.targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n+        cx.sess().targ_cfg.target_strs.meta_sect_name.with_c_str(|buf| {\n             llvm::LLVMSetSection(llglobal, buf)\n         });\n     }\n     return metadata;\n }\n \n-pub fn trans_crate(sess: session::Session,\n-                   krate: ast::Crate,\n-                   analysis: &CrateAnalysis,\n-                   output: &OutputFilenames) -> CrateTranslation {\n+pub fn trans_crate(krate: ast::Crate,\n+                   analysis: CrateAnalysis,\n+                   output: &OutputFilenames) -> (ty::ctxt, CrateTranslation) {\n+    let CrateAnalysis { ty_cx: tcx, exp_map2, maps, reachable, .. } = analysis;\n+\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n         use sync::one::{Once, ONCE_INIT};\n@@ -2537,7 +2481,7 @@ pub fn trans_crate(sess: session::Session,\n         });\n \n         if POISONED {\n-            sess.bug(\"couldn't enable multi-threaded LLVM\");\n+            tcx.sess.bug(\"couldn't enable multi-threaded LLVM\");\n         }\n     }\n \n@@ -2553,28 +2497,22 @@ pub fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.crateid.name + \".rs\";\n \n-    let ccx = @CrateContext::new(sess,\n-                                 llmod_id,\n-                                 analysis.ty_cx,\n-                                 analysis.exp_map2,\n-                                 analysis.maps,\n-                                 Sha256::new(),\n-                                 link_meta,\n-                                 analysis.reachable);\n+    let ccx = CrateContext::new(llmod_id, tcx, exp_map2, maps,\n+                                Sha256::new(), link_meta, reachable);\n     {\n         let _icx = push_ctxt(\"text\");\n-        trans_mod(ccx, &krate.module);\n+        trans_mod(&ccx, &krate.module);\n     }\n \n-    fill_crate_map(ccx, ccx.crate_map);\n+    fill_crate_map(&ccx, ccx.crate_map);\n \n     // win32: wart with exporting crate_map symbol\n     // We set the crate map (_rust_crate_map_toplevel) to use dll_export\n     // linkage but that ends up causing the linker to look for a\n     // __rust_crate_map_toplevel symbol (extra underscore) which it will\n     // subsequently fail to find. So to mitigate that we just introduce\n     // an alias from the symbol it expects to the one that actually exists.\n-    if ccx.sess.targ_cfg.os == OsWin32 && !ccx.sess.building_library.get() {\n+    if ccx.sess().targ_cfg.os == OsWin32 && !ccx.sess().building_library.get() {\n \n         let maptype = val_ty(ccx.crate_map).to_ref();\n \n@@ -2586,14 +2524,14 @@ pub fn trans_crate(sess: session::Session,\n         })\n     }\n \n-    glue::emit_tydescs(ccx);\n-    if ccx.sess.opts.debuginfo != NoDebugInfo {\n-        debuginfo::finalize(ccx);\n+    glue::emit_tydescs(&ccx);\n+    if ccx.sess().opts.debuginfo != NoDebugInfo {\n+        debuginfo::finalize(&ccx);\n     }\n \n     // Translate the metadata.\n-    let metadata = write_metadata(ccx, &krate);\n-    if ccx.sess.trans_stats() {\n+    let metadata = write_metadata(&ccx, &krate);\n+    if ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");\n         println!(\"n_static_tydescs: {}\", ccx.stats.n_static_tydescs.get());\n         println!(\"n_glues_created: {}\", ccx.stats.n_glues_created.get());\n@@ -2605,21 +2543,19 @@ pub fn trans_crate(sess: session::Session,\n         println!(\"n_inlines: {}\", ccx.stats.n_inlines.get());\n         println!(\"n_closures: {}\", ccx.stats.n_closures.get());\n         println!(\"fn stats:\");\n-        {\n-            let mut fn_stats = ccx.stats.fn_stats.borrow_mut();\n-            fn_stats.get().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n-                insns_b.cmp(&insns_a)\n-            });\n-            for tuple in fn_stats.get().iter() {\n-                match *tuple {\n-                    (ref name, ms, insns) => {\n-                        println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n-                    }\n+        let mut fn_stats = ccx.stats.fn_stats.borrow_mut();\n+        fn_stats.get().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+            insns_b.cmp(&insns_a)\n+        });\n+        for tuple in fn_stats.get().iter() {\n+            match *tuple {\n+                (ref name, ms, insns) => {\n+                    println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n                 }\n             }\n         }\n     }\n-    if ccx.sess.count_llvm_insns() {\n+    if ccx.sess().count_llvm_insns() {\n         let llvm_insns = ccx.stats.llvm_insns.borrow();\n         for (k, v) in llvm_insns.get().iter() {\n             println!(\"{:7u} {}\", *v, *k);\n@@ -2630,13 +2566,9 @@ pub fn trans_crate(sess: session::Session,\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n \n-    let mut reachable: Vec<~str> = {\n-        let reachable_map = ccx.reachable.borrow();\n-        reachable_map.get().iter().filter_map(|id| {\n-            let item_symbols = ccx.item_symbols.borrow();\n-            item_symbols.get().find(id).map(|s| s.to_owned())\n-        }).collect()\n-    };\n+    let mut reachable: Vec<~str> = ccx.reachable.iter().filter_map(|id| {\n+        ccx.item_symbols.borrow().get().find(id).map(|s| s.to_owned())\n+    }).collect();\n \n     // Make sure that some other crucial symbols are not eliminated from the\n     // module. This includes the main function, the crate map (used for debug\n@@ -2650,12 +2582,14 @@ pub fn trans_crate(sess: session::Session,\n     reachable.push(~\"rust_eh_personality\"); // referenced from .eh_frame section on some platforms\n     reachable.push(~\"rust_eh_personality_catch\"); // referenced from rt/rust_try.ll\n \n-    return CrateTranslation {\n+    let metadata_module = ccx.metadata_llmod;\n+\n+    (ccx.tcx, CrateTranslation {\n         context: llcx,\n         module: llmod,\n         link: link_meta,\n-        metadata_module: ccx.metadata_llmod,\n+        metadata_module: metadata_module,\n         metadata: metadata,\n         reachable: reachable,\n-    };\n+    })\n }"}, {"sha": "79e22ea345529d3ac6767844da8f6564d9cf0b36", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -115,7 +115,7 @@ pub fn Invoke(cx: &Block,\n               attributes: &[(uint, lib::llvm::Attribute)])\n               -> ValueRef {\n     if cx.unreachable.get() {\n-        return C_null(Type::i8());\n+        return C_null(Type::i8(cx.ccx()));\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n@@ -300,14 +300,18 @@ pub fn Not(cx: &Block, v: ValueRef) -> ValueRef {\n /* Memory */\n pub fn Malloc(cx: &Block, ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).malloc(ty)\n     }\n }\n \n pub fn ArrayMalloc(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).array_malloc(ty, val)\n     }\n }\n@@ -357,7 +361,9 @@ pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n \n pub fn VolatileLoad(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).volatile_load(pointer_val)\n     }\n }\n@@ -408,7 +414,9 @@ pub fn AtomicStore(cx: &Block, val: ValueRef, ptr: ValueRef, order: AtomicOrderi\n \n pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).gep(pointer, indices)\n     }\n }\n@@ -418,35 +426,45 @@ pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n #[inline]\n pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).gepi(base, ixs)\n     }\n }\n \n pub fn InBoundsGEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).inbounds_gep(pointer, indices)\n     }\n }\n \n pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n+        }\n         B(cx).struct_gep(pointer, idx)\n     }\n }\n \n pub fn GlobalString(cx: &Block, _str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).global_string(_str)\n     }\n }\n \n pub fn GlobalStringPtr(cx: &Block, _str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n+        }\n         B(cx).global_string_ptr(_str)\n     }\n }\n@@ -591,15 +609,19 @@ pub fn FPCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n pub fn ICmp(cx: &Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).icmp(op, lhs, rhs)\n     }\n }\n \n pub fn FCmp(cx: &Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).fcmp(op, lhs, rhs)\n     }\n }\n@@ -686,58 +708,74 @@ pub fn VAArg(cx: &Block, list: ValueRef, ty: Type) -> ValueRef {\n \n pub fn ExtractElement(cx: &Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).extract_element(vec_val, index)\n     }\n }\n \n pub fn InsertElement(cx: &Block, vec_val: ValueRef, elt_val: ValueRef,\n                      index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).insert_element(vec_val, elt_val, index)\n     }\n }\n \n pub fn ShuffleVector(cx: &Block, v1: ValueRef, v2: ValueRef,\n                      mask: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).shuffle_vector(v1, v2, mask)\n     }\n }\n \n pub fn VectorSplat(cx: &Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).vector_splat(num_elts, elt_val)\n     }\n }\n \n pub fn ExtractValue(cx: &Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).extract_value(agg_val, index)\n     }\n }\n \n pub fn InsertValue(cx: &Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n+        }\n         B(cx).insert_value(agg_val, elt_val, index)\n     }\n }\n \n pub fn IsNull(cx: &Block, val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).is_null(val)\n     }\n }\n \n pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n+        if cx.unreachable.get() {\n+            return llvm::LLVMGetUndef(Type::i1(cx.ccx()).to_ref());\n+        }\n         B(cx).is_not_null(val)\n     }\n }"}, {"sha": "c403d323bf4ce66077a49e620945d19c20e42e98", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -44,13 +44,13 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn count_insn(&self, category: &str) {\n-        if self.ccx.sess.trans_stats() {\n+        if self.ccx.sess().trans_stats() {\n             self.ccx.stats.n_llvm_insns.set(self.ccx\n                                                 .stats\n                                                 .n_llvm_insns\n                                                 .get() + 1);\n         }\n-        if self.ccx.sess.count_llvm_insns() {\n+        if self.ccx.sess().count_llvm_insns() {\n             base::with_insn_ctxt(|v| {\n                 let mut h = self.ccx.stats.llvm_insns.borrow_mut();\n \n@@ -536,13 +536,13 @@ impl<'a> Builder<'a> {\n         // Small vector optimization. This should catch 100% of the cases that\n         // we care about.\n         if ixs.len() < 16 {\n-            let mut small_vec = [ C_i32(0), ..16 ];\n+            let mut small_vec = [ C_i32(self.ccx, 0), ..16 ];\n             for (small_vec_e, &ix) in small_vec.mut_iter().zip(ixs.iter()) {\n-                *small_vec_e = C_i32(ix as i32);\n+                *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n-            let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<Vec<ValueRef> >();\n+            let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n             self.inbounds_gep(base, v.as_slice())\n         }\n@@ -748,21 +748,21 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn add_span_comment(&self, sp: Span, text: &str) {\n-        if self.ccx.sess.asm_comments() {\n-            let s = format!(\"{} ({})\", text, self.ccx.sess.codemap.span_to_str(sp));\n+        if self.ccx.sess().asm_comments() {\n+            let s = format!(\"{} ({})\", text, self.ccx.sess().codemap().span_to_str(sp));\n             debug!(\"{}\", s);\n             self.add_comment(s);\n         }\n     }\n \n     pub fn add_comment(&self, text: &str) {\n-        if self.ccx.sess.asm_comments() {\n+        if self.ccx.sess().asm_comments() {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = format!(\"\\\\# {}\", sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n             let asm = comment_text.with_c_str(|c| {\n                 unsafe {\n-                    llvm::LLVMConstInlineAsm(Type::func([], &Type::void()).to_ref(),\n+                    llvm::LLVMConstInlineAsm(Type::func([], &Type::void(self.ccx)).to_ref(),\n                                              c, noname(), False, False)\n                 }\n             });\n@@ -860,8 +860,9 @@ impl<'a> Builder<'a> {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n-            let vec = self.insert_element(undef, elt, C_i32(0));\n-            self.shuffle_vector(vec, undef, C_null(Type::vector(&Type::i32(), num_elts as u64)))\n+            let vec = self.insert_element(undef, elt, C_i32(self.ccx, 0));\n+            let vec_i32_ty = Type::vector(&Type::i32(self.ccx), num_elts as u64);\n+            self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n         }\n     }\n "}, {"sha": "d760c64544139bf72dd001c43528a02923b113df", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -94,7 +94,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess.targ_cfg.arch {\n+    match ccx.sess().targ_cfg.arch {\n         X86 => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         X86_64 => cabi_x86_64::compute_abi_info(ccx, atys, rty, ret_def),\n         Arm => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),"}, {"sha": "83805cf844f3174e2489c335fa1d8d8ec6e5ad29", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -85,34 +85,34 @@ fn ty_size(ty: Type) -> uint {\n     }\n }\n \n-fn classify_ret_ty(ty: Type) -> ArgType {\n+fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n         return ArgType::direct(ty, None, None, None);\n     }\n     let size = ty_size(ty);\n     if size <= 4 {\n         let llty = if size <= 1 {\n-            Type::i8()\n+            Type::i8(ccx)\n         } else if size <= 2 {\n-            Type::i16()\n+            Type::i16(ccx)\n         } else {\n-            Type::i32()\n+            Type::i32(ccx)\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n     ArgType::indirect(ty, Some(StructRetAttribute))\n }\n \n-fn classify_arg_ty(ty: Type) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n         return ArgType::direct(ty, None, None, None);\n     }\n     let align = ty_align(ty);\n     let size = ty_size(ty);\n     let llty = if align <= 4 {\n-        Type::array(&Type::i32(), ((size + 3) / 4) as u64)\n+        Type::array(&Type::i32(ccx), ((size + 3) / 4) as u64)\n     } else {\n-        Type::array(&Type::i64(), ((size + 7) / 8) as u64)\n+        Type::array(&Type::i64(ccx), ((size + 7) / 8) as u64)\n     };\n     ArgType::direct(ty, Some(llty), None, None)\n }\n@@ -127,20 +127,20 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(_ccx: &CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let mut arg_tys = Vec::new();\n     for &aty in atys.iter() {\n-        let ty = classify_arg_ty(aty);\n+        let ty = classify_arg_ty(ccx, aty);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        classify_ret_ty(rty)\n+        classify_ret_ty(ccx, rty)\n     } else {\n-        ArgType::direct(Type::void(), None, None, None)\n+        ArgType::direct(Type::void(ccx), None, None, None)\n     };\n \n     return FnType {"}, {"sha": "68d9bb82a6c243516c33f97bfa2eeb46d2fff5c6", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -15,7 +15,6 @@ use std::cmp;\n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::StructRetAttribute;\n use middle::trans::context::CrateContext;\n-use middle::trans::context::task_llcx;\n use middle::trans::cabi::*;\n use middle::trans::type_::Type;\n \n@@ -94,7 +93,7 @@ fn classify_ret_ty(ty: Type) -> ArgType {\n     }\n }\n \n-fn classify_arg_ty(ty: Type, offset: &mut uint) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -108,8 +107,8 @@ fn classify_arg_ty(ty: Type, offset: &mut uint) -> ArgType {\n     } else {\n         ArgType::direct(\n             ty,\n-            Some(struct_ty(ty)),\n-            padding_ty(align, orig_offset),\n+            Some(struct_ty(ccx, ty)),\n+            padding_ty(ccx, align, orig_offset),\n             None\n         )\n     }\n@@ -125,16 +124,16 @@ fn is_reg_ty(ty: Type) -> bool {\n     };\n }\n \n-fn padding_ty(align: uint, offset: uint) -> Option<Type> {\n+fn padding_ty(ccx: &CrateContext, align: uint, offset: uint) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n-        return Some(Type::i32());\n+        Some(Type::i32(ccx))\n+    } else {\n+        None\n     }\n-\n-    return None;\n }\n \n-fn coerce_to_int(size: uint) -> Vec<Type> {\n-    let int_ty = Type::i32();\n+fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n+    let int_ty = Type::i32(ccx);\n     let mut args = Vec::new();\n \n     let mut n = size / 32;\n@@ -146,35 +145,34 @@ fn coerce_to_int(size: uint) -> Vec<Type> {\n     let r = size % 32;\n     if r > 0 {\n         unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(task_llcx(), r as c_uint)));\n+            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx, r as c_uint)));\n         }\n     }\n \n     args\n }\n \n-fn struct_ty(ty: Type) -> Type {\n+fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n     let size = ty_size(ty) * 8;\n-    let fields = coerce_to_int(size);\n-    return Type::struct_(fields.as_slice(), false);\n+    Type::struct_(ccx, coerce_to_int(ccx, size).as_slice(), false)\n }\n \n-pub fn compute_abi_info(_ccx: &CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n     let ret_ty = if ret_def {\n         classify_ret_ty(rty)\n     } else {\n-        ArgType::direct(Type::void(), None, None, None)\n+        ArgType::direct(Type::void(ccx), None, None, None)\n     };\n \n     let sret = ret_ty.is_indirect();\n     let mut arg_tys = Vec::new();\n     let mut offset = if sret { 4 } else { 0 };\n \n     for aty in atys.iter() {\n-        let ty = classify_arg_ty(*aty, &mut offset);\n+        let ty = classify_arg_ty(ccx, *aty, &mut offset);\n         arg_tys.push(ty);\n     };\n "}, {"sha": "b2cb6970597872d1c6445f9a24e3eae72e46a670", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -25,7 +25,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n \n     let ret_ty;\n     if !ret_def {\n-        ret_ty = ArgType::direct(Type::void(), None, None, None);\n+        ret_ty = ArgType::direct(Type::void(ccx), None, None, None);\n     } else if rty.kind() == Struct {\n         // Returning a structure. Most often, this will use\n         // a hidden first argument. On some platforms, though,\n@@ -36,13 +36,13 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         // Clang's ABI handling is in lib/CodeGen/TargetInfo.cpp\n \n         enum Strategy { RetValue(Type), RetPointer }\n-        let strategy = match ccx.sess.targ_cfg.os {\n+        let strategy = match ccx.sess().targ_cfg.os {\n             OsWin32 | OsMacos => {\n                 match llsize_of_alloc(ccx, rty) {\n-                    1 => RetValue(Type::i8()),\n-                    2 => RetValue(Type::i16()),\n-                    4 => RetValue(Type::i32()),\n-                    8 => RetValue(Type::i64()),\n+                    1 => RetValue(Type::i8(ccx)),\n+                    2 => RetValue(Type::i16(ccx)),\n+                    4 => RetValue(Type::i32(ccx)),\n+                    8 => RetValue(Type::i64(ccx)),\n                     _ => RetPointer\n                 }\n             }"}, {"sha": "c1ae28005d9b5fa76492b3acd87991b9b4734cbf", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -291,7 +291,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     return cls;\n }\n \n-fn llreg_ty(cls: &[RegClass]) -> Type {\n+fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n     fn llvec_len(cls: &[RegClass]) -> uint {\n         let mut len = 1u;\n         for c in cls.iter() {\n@@ -309,33 +309,34 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n     while i < e {\n         match cls[i] {\n             Int => {\n-                tys.push(Type::i64());\n+                tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n                 let vec_len = llvec_len(cls.tailn(i + 1u));\n-                let vec_ty = Type::vector(&Type::f32(), (vec_len * 2u) as u64);\n+                let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;\n                 continue;\n             }\n             SSEFs => {\n-                tys.push(Type::f32());\n+                tys.push(Type::f32(ccx));\n             }\n             SSEDs => {\n-                tys.push(Type::f64());\n+                tys.push(Type::f64(ccx));\n             }\n             _ => fail!(\"llregtype: unhandled class\")\n         }\n         i += 1u;\n     }\n-    return Type::struct_(tys.as_slice(), false);\n+    return Type::struct_(ccx, tys.as_slice(), false);\n }\n \n-pub fn compute_abi_info(_ccx: &CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    fn x86_64_ty(ty: Type,\n+    fn x86_64_ty(ccx: &CrateContext,\n+                 ty: Type,\n                  is_mem_cls: |cls: &[RegClass]| -> bool,\n                  attr: Attribute)\n                  -> ArgType {\n@@ -345,7 +346,7 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n                 ArgType::indirect(ty, Some(attr))\n             } else {\n                 ArgType::direct(ty,\n-                                Some(llreg_ty(cls.as_slice())),\n+                                Some(llreg_ty(ccx, cls.as_slice())),\n                                 None,\n                                 None)\n             }\n@@ -356,14 +357,14 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n \n     let mut arg_tys = Vec::new();\n     for t in atys.iter() {\n-        let ty = x86_64_ty(*t, |cls| cls.is_pass_byval(), ByValAttribute);\n+        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), ByValAttribute);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        x86_64_ty(rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n+        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), StructRetAttribute)\n     } else {\n-        ArgType::direct(Type::void(), None, None, None)\n+        ArgType::direct(Type::void(ccx), None, None, None)\n     };\n \n     return FnType {"}, {"sha": "61a855a7f0976259c1eb622c40b7f27d8bd24322", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -267,15 +267,15 @@ pub fn trans_fn_ref_with_vtables(\n \n     let _icx = push_ctxt(\"trans_fn_ref_with_vtables\");\n     let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = bcx.tcx();\n \n     debug!(\"trans_fn_ref_with_vtables(bcx={}, def_id={}, node={:?}, \\\n             type_params={}, vtables={})\",\n            bcx.to_str(),\n-           def_id.repr(bcx.tcx()),\n+           def_id.repr(tcx),\n            node,\n-           type_params.repr(bcx.tcx()),\n-           vtables.repr(bcx.tcx()));\n+           type_params.repr(tcx),\n+           vtables.repr(tcx));\n \n     assert!(type_params.iter().all(|t| !ty::type_needs_infer(*t)));\n \n@@ -365,13 +365,13 @@ pub fn trans_fn_ref_with_vtables(\n         true\n     } else if def_id.krate == ast::LOCAL_CRATE {\n         let map_node = session::expect(\n-            ccx.sess,\n-            ccx.tcx.map.find(def_id.node),\n+            ccx.sess(),\n+            tcx.map.find(def_id.node),\n             || format!(\"local item should be in ast map\"));\n \n         match map_node {\n             ast_map::NodeForeignItem(_) => {\n-                ccx.tcx.map.get_foreign_abis(def_id.node).is_intrinsic()\n+                tcx.map.get_foreign_abis(def_id.node).is_intrinsic()\n             }\n             _ => false\n         }\n@@ -502,9 +502,9 @@ pub fn trans_lang_call<'a>(\n                        dest: Option<expr::Dest>)\n                        -> Result<'a> {\n     let fty = if did.krate == ast::LOCAL_CRATE {\n-        ty::node_id_to_type(bcx.ccx().tcx, did.node)\n+        ty::node_id_to_type(bcx.tcx(), did.node)\n     } else {\n-        csearch::get_type(bcx.ccx().tcx, did).ty\n+        csearch::get_type(bcx.tcx(), did).ty\n     };\n     callee::trans_call_inner(bcx,\n                              None,\n@@ -649,7 +649,7 @@ pub fn trans_call_inner<'a>(\n     };\n \n     let mut llresult = unsafe {\n-        llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref())\n+        llvm::LLVMGetUndef(Type::nil(ccx).ptr_to().to_ref())\n     };\n \n     // The code below invokes the function, using either the Rust"}, {"sha": "1acc746b197a13516f600bb765d29d45d68ecbae", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -205,7 +205,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n                 _ => {}\n             }\n         }\n-        self.ccx.tcx.sess.bug(\"no loop scope found\");\n+        self.ccx.sess().bug(\"no loop scope found\");\n     }\n \n     fn normal_exit_block(&'a self,\n@@ -238,18 +238,18 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          * instance of `ty`\n          */\n \n-        if !ty::type_needs_drop(self.ccx.tcx, ty) { return; }\n+        if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n         let drop = ~DropValue {\n             is_immediate: false,\n-            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx, ty),\n+            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n             val: val,\n             ty: ty\n         };\n \n         debug!(\"schedule_drop_mem({:?}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn.val_to_str(val),\n-               ty.repr(self.ccx.tcx));\n+               ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n     }\n@@ -262,18 +262,18 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          * Schedules a (deep) drop of `val`, which is an instance of `ty`\n          */\n \n-        if !ty::type_needs_drop(self.ccx.tcx, ty) { return; }\n+        if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n         let drop = ~DropValue {\n             is_immediate: true,\n-            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx, ty),\n+            on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n             val: val,\n             ty: ty\n         };\n \n         debug!(\"schedule_drop_immediate({:?}, val={}, ty={})\",\n                cleanup_scope,\n                self.ccx.tn.val_to_str(val),\n-               ty.repr(self.ccx.tcx));\n+               ty.repr(self.ccx.tcx()));\n \n         self.schedule_clean(cleanup_scope, drop as ~Cleanup);\n     }\n@@ -330,7 +330,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n             }\n         }\n \n-        self.ccx.tcx.sess.bug(\n+        self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n                     self.ccx.tcx.map.node_to_str(cleanup_scope)));\n     }\n@@ -540,7 +540,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                     }\n \n                     LoopExit(id, _) => {\n-                        self.ccx.tcx.sess.bug(format!(\n+                        self.ccx.sess().bug(format!(\n                                 \"cannot exit from scope {:?}, \\\n                                 not in scope\", id));\n                     }\n@@ -669,7 +669,9 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         // The landing pad return type (the type being propagated). Not sure what\n         // this represents but it's determined by the personality function and\n         // this is what the EH proposal example uses.\n-        let llretty = Type::struct_([Type::i8p(), Type::i32()], false);\n+        let llretty = Type::struct_(self.ccx,\n+                                    [Type::i8p(self.ccx), Type::i32(self.ccx)],\n+                                    false);\n \n         // The exception handling personality function.\n         let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);\n@@ -846,7 +848,7 @@ impl Cleanup for FreeValue {\n     }\n }\n \n-pub fn temporary_scope(tcx: ty::ctxt,\n+pub fn temporary_scope(tcx: &ty::ctxt,\n                        id: ast::NodeId)\n                        -> ScopeId {\n     match tcx.region_maps.temporary_scope(id) {\n@@ -861,7 +863,7 @@ pub fn temporary_scope(tcx: ty::ctxt,\n     }\n }\n \n-pub fn var_scope(tcx: ty::ctxt,\n+pub fn var_scope(tcx: &ty::ctxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n     let r = AstScope(tcx.region_maps.var_scope(id));"}, {"sha": "05375ebeb31a2209080162768ce0211136caa980", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -133,7 +133,7 @@ impl EnvValue {\n }\n \n // Given a closure ty, emits a corresponding tuple ty\n-pub fn mk_closure_tys(tcx: ty::ctxt,\n+pub fn mk_closure_tys(tcx: &ty::ctxt,\n                       bound_values: &[EnvValue])\n                    -> ty::t {\n     // determine the types of the values in the env.  Note that this\n@@ -151,7 +151,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+fn tuplify_box_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n     let ptr = ty::mk_imm_ptr(tcx, ty::mk_i8());\n     ty::mk_tup(tcx, vec!(ty::mk_uint(), ty::mk_nil_ptr(tcx), ptr, ptr, t))\n }\n@@ -161,8 +161,7 @@ fn allocate_cbox<'a>(bcx: &'a Block<'a>,\n                      cdata_ty: ty::t)\n                      -> Result<'a> {\n     let _icx = push_ctxt(\"closure::allocate_cbox\");\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = bcx.tcx();\n \n     // Allocate and initialize the box:\n     match sigil {\n@@ -197,7 +196,7 @@ pub fn store_environment<'a>(\n                          -> ClosureResult<'a> {\n     let _icx = push_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     // compute the type of the closure\n     let cdata_ty = mk_closure_tys(tcx, bound_values.as_slice());\n@@ -227,7 +226,7 @@ pub fn store_environment<'a>(\n     for (i, bv) in bound_values.move_iter().enumerate() {\n         debug!(\"Copy {} into closure\", bv.to_str(ccx));\n \n-        if ccx.sess.asm_comments() {\n+        if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n                                   bv.to_str(ccx)));\n         }\n@@ -301,7 +300,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n \n     // Store the pointer to closure data in an alloca for debug info because that's what the\n     // llvm.dbg.declare intrinsic expects\n-    let env_pointer_alloca = if bcx.ccx().sess.opts.debuginfo == FullDebugInfo {\n+    let env_pointer_alloca = if bcx.sess().opts.debuginfo == FullDebugInfo {\n         let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), cdata_ty), \"__debuginfo_env_ptr\");\n         Store(bcx, llcdata, alloc);\n         Some(alloc)\n@@ -343,7 +342,7 @@ fn load_environment<'a>(bcx: &'a Block<'a>, cdata_ty: ty::t,\n \n fn fill_fn_pair(bcx: &Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n     Store(bcx, llfn, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n-    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p());\n+    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n     Store(bcx, llenvptr, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n }\n \n@@ -409,7 +408,7 @@ pub fn trans_expr_fn<'a>(\n     bcx\n }\n \n-pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n+pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                                closure_ty: ty::t,\n                                def: ast::Def,\n                                fn_ptr: ValueRef,\n@@ -419,9 +418,9 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n         ast::DefFn(did, _) | ast::DefStaticMethod(did, _, _) |\n         ast::DefVariant(_, did, _) | ast::DefStruct(did) => did,\n         _ => {\n-            ccx.sess.bug(format!(\"get_wrapper_for_bare_fn: \\\n-                                  expected a statically resolved fn, got {:?}\",\n-                                  def));\n+            ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n+                                    expected a statically resolved fn, got {:?}\",\n+                                    def));\n         }\n     };\n \n@@ -433,16 +432,16 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n         }\n     }\n \n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     debug!(\"get_wrapper_for_bare_fn(closure_ty={})\", closure_ty.repr(tcx));\n \n     let f = match ty::get(closure_ty).sty {\n         ty::ty_closure(ref f) => f,\n         _ => {\n-            ccx.sess.bug(format!(\"get_wrapper_for_bare_fn: \\\n-                                  expected a closure ty, got {}\",\n-                                  closure_ty.repr(tcx)));\n+            ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\\n+                                    expected a closure ty, got {}\",\n+                                    closure_ty.repr(tcx)));\n         }\n     };\n \n@@ -510,7 +509,7 @@ pub fn make_closure_from_bare_fn<'a>(bcx: &'a Block<'a>,\n                                      -> DatumBlock<'a, Expr>  {\n     let scratch = rvalue_scratch_datum(bcx, closure_ty, \"__adjust\");\n     let wrapper = get_wrapper_for_bare_fn(bcx.ccx(), closure_ty, def, fn_ptr, true);\n-    fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p()));\n+    fill_fn_pair(bcx, scratch.val, wrapper, C_null(Type::i8p(bcx.ccx())));\n \n     DatumBlock(bcx, scratch.to_expr_datum())\n }"}, {"sha": "e812f36e85d68a5d0084ac59fdd8e6cb04915bca", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 52, "deletions": 66, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -18,7 +18,6 @@ use lib::llvm::{True, False, Bool};\n use lib::llvm::llvm;\n use lib;\n use middle::lang_items::LangItem;\n-use middle::trans::base;\n use middle::trans::build;\n use middle::trans::cleanup;\n use middle::trans::datum;\n@@ -49,7 +48,7 @@ pub use middle::trans::context::CrateContext;\n fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_struct(def_id, ref substs) => {\n-            let fields = ty::struct_fields(ccx.tcx, def_id, substs);\n+            let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n                 fields.get(0).ident.name ==\n                     token::special_idents::unnamed_field.name &&\n@@ -62,7 +61,7 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     use middle::trans::machine::llsize_of_alloc;\n     use middle::trans::type_of::sizing_type_of;\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n     let simple = ty::type_is_scalar(ty) || ty::type_is_boxed(ty) ||\n         ty::type_is_unique(ty) || ty::type_is_region_ptr(ty) ||\n         type_is_newtype_immediate(ccx, ty) || ty::type_is_bot(ty) ||\n@@ -100,7 +99,7 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: ty::t) -> bool {\n      * return type (in order to aid with C ABI compatibility).\n      */\n \n-    ty::type_is_nil(ty) || ty::type_is_bot(ty) || ty::type_is_empty(ccx.tcx, ty)\n+    ty::type_is_nil(ty) || ty::type_is_bot(ty) || ty::type_is_empty(ccx.tcx(), ty)\n }\n \n /// Generates a unique symbol based off the name given. This is used to create\n@@ -207,14 +206,14 @@ impl param_substs {\n     }\n }\n \n-fn param_substs_to_str(this: &param_substs, tcx: ty::ctxt) -> ~str {\n+fn param_substs_to_str(this: &param_substs, tcx: &ty::ctxt) -> ~str {\n     format!(\"param_substs \\\\{tys:{}, vtables:{}\\\\}\",\n          this.tys.repr(tcx),\n          this.vtables.repr(tcx))\n }\n \n impl Repr for param_substs {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         param_substs_to_str(self, tcx)\n     }\n }\n@@ -286,7 +285,7 @@ pub struct FunctionContext<'a> {\n     block_arena: &'a TypedArena<Block<'a>>,\n \n     // This function's enclosing crate context.\n-    ccx: @CrateContext,\n+    ccx: &'a CrateContext,\n \n     // Used and maintained by the debuginfo module.\n     debug_context: debuginfo::FunctionDebugContext,\n@@ -330,7 +329,12 @@ impl<'a> FunctionContext<'a> {\n \n     pub fn get_llreturn(&self) -> BasicBlockRef {\n         if self.llreturn.get().is_none() {\n-            self.llreturn.set(Some(base::mk_return_basic_block(self.llfn)));\n+\n+            self.llreturn.set(Some(unsafe {\n+                \"return\".with_c_str(|buf| {\n+                    llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx, self.llfn, buf)\n+                })\n+            }))\n         }\n \n         self.llreturn.get().unwrap()\n@@ -383,13 +387,6 @@ impl<'a> FunctionContext<'a> {\n     }\n }\n \n-pub fn warn_not_to_commit(ccx: &mut CrateContext, msg: &str) {\n-    if !ccx.do_not_commit_warning_issued.get() {\n-        ccx.do_not_commit_warning_issued.set(true);\n-        ccx.sess.warn(msg.to_str() + \" -- do not commit like this!\");\n-    }\n-}\n-\n // Heap selectors. Indicate which heap something should go on.\n #[deriving(Eq)]\n pub enum heap {\n@@ -442,11 +439,11 @@ impl<'a> Block<'a> {\n         })\n     }\n \n-    pub fn ccx(&self) -> @CrateContext { self.fcx.ccx }\n-    pub fn tcx(&self) -> ty::ctxt {\n-        self.fcx.ccx.tcx\n+    pub fn ccx(&self) -> &'a CrateContext { self.fcx.ccx }\n+    pub fn tcx(&self) -> &'a ty::ctxt {\n+        &self.fcx.ccx.tcx\n     }\n-    pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n+    pub fn sess(&self) -> &'a Session { self.fcx.ccx.sess() }\n \n     pub fn ident(&self, ident: Ident) -> ~str {\n         token::get_ident(ident).get().to_str()\n@@ -547,40 +544,40 @@ pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     }\n }\n \n-pub fn C_nil() -> ValueRef {\n-    C_struct([], false)\n+pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n+    C_struct(ccx, [], false)\n }\n \n-pub fn C_bool(val: bool) -> ValueRef {\n-    C_integral(Type::bool(), val as u64, false)\n+pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n+    C_integral(Type::bool(ccx), val as u64, false)\n }\n \n-pub fn C_i1(val: bool) -> ValueRef {\n-    C_integral(Type::i1(), val as u64, false)\n+pub fn C_i1(ccx: &CrateContext, val: bool) -> ValueRef {\n+    C_integral(Type::i1(ccx), val as u64, false)\n }\n \n-pub fn C_i32(i: i32) -> ValueRef {\n-    return C_integral(Type::i32(), i as u64, true);\n+pub fn C_i32(ccx: &CrateContext, i: i32) -> ValueRef {\n+    C_integral(Type::i32(ccx), i as u64, true)\n }\n \n-pub fn C_i64(i: i64) -> ValueRef {\n-    return C_integral(Type::i64(), i as u64, true);\n+pub fn C_i64(ccx: &CrateContext, i: i64) -> ValueRef {\n+    C_integral(Type::i64(ccx), i as u64, true)\n }\n \n-pub fn C_u64(i: u64) -> ValueRef {\n-    return C_integral(Type::i64(), i, false);\n+pub fn C_u64(ccx: &CrateContext, i: u64) -> ValueRef {\n+    C_integral(Type::i64(ccx), i, false)\n }\n \n-pub fn C_int(cx: &CrateContext, i: int) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, true);\n+pub fn C_int(ccx: &CrateContext, i: int) -> ValueRef {\n+    C_integral(ccx.int_type, i as u64, true)\n }\n \n-pub fn C_uint(cx: &CrateContext, i: uint) -> ValueRef {\n-    return C_integral(cx.int_type, i as u64, false);\n+pub fn C_uint(ccx: &CrateContext, i: uint) -> ValueRef {\n+    C_integral(ccx.int_type, i as u64, false)\n }\n \n-pub fn C_u8(i: uint) -> ValueRef {\n-    return C_integral(Type::i8(), i as u64, false);\n+pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n+    C_integral(Type::i8(ccx), i as u64, false)\n }\n \n \n@@ -620,15 +617,15 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString) -> ValueRef {\n pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     unsafe {\n         let len = s.get().len();\n-        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n-        C_struct([cs, C_uint(cx, len)], false)\n+        let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p(cx).to_ref());\n+        C_struct(cx, [cs, C_uint(cx, len)], false)\n     }\n }\n \n pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n     unsafe {\n         let len = data.len();\n-        let lldata = C_bytes(data);\n+        let lldata = C_bytes(cx, data);\n \n         let gsym = token::gensym(\"binary\");\n         let g = format!(\"binary{}\", gsym).with_c_str(|buf| {\n@@ -638,25 +635,14 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         llvm::LLVMSetGlobalConstant(g, True);\n         lib::llvm::SetLinkage(g, lib::llvm::InternalLinkage);\n \n-        let cs = llvm::LLVMConstPointerCast(g, Type::i8p().to_ref());\n-        C_struct([cs, C_uint(cx, len)], false)\n+        let cs = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n+        C_struct(cx, [cs, C_uint(cx, len)], false)\n     }\n }\n \n-pub fn C_zero_byte_arr(size: uint) -> ValueRef {\n+pub fn C_struct(ccx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n     unsafe {\n-        let mut i = 0u;\n-        let mut elts: Vec<ValueRef> = Vec::new();\n-        while i < size { elts.push(C_u8(0u)); i += 1u; }\n-        return llvm::LLVMConstArray(Type::i8().to_ref(),\n-                                    elts.as_ptr(), elts.len() as c_uint);\n-    }\n-}\n-\n-pub fn C_struct(elts: &[ValueRef], packed: bool) -> ValueRef {\n-    unsafe {\n-\n-        llvm::LLVMConstStructInContext(base::task_llcx(),\n+        llvm::LLVMConstStructInContext(ccx.llcx,\n                                        elts.as_ptr(), elts.len() as c_uint,\n                                        packed as Bool)\n     }\n@@ -674,10 +660,10 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n+pub fn C_bytes(ccx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     unsafe {\n         let ptr = bytes.as_ptr() as *c_char;\n-        return llvm::LLVMConstStringInContext(base::task_llcx(), ptr, bytes.len() as c_uint, True);\n+        return llvm::LLVMConstStringInContext(ccx.llcx, ptr, bytes.len() as c_uint, True);\n     }\n }\n \n@@ -860,12 +846,12 @@ pub fn node_vtables(bcx: &Block, id: ast::NodeId)\n // vtables. This should eliminate any vtable_params.\n pub fn resolve_vtables_in_fn_ctxt(fcx: &FunctionContext, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    resolve_vtables_under_param_substs(fcx.ccx.tcx,\n+    resolve_vtables_under_param_substs(fcx.ccx.tcx(),\n                                        fcx.param_substs,\n                                        vts)\n }\n \n-pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n+pub fn resolve_vtables_under_param_substs(tcx: &ty::ctxt,\n                                           param_substs: Option<@param_substs>,\n                                           vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n@@ -877,7 +863,7 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n }\n \n pub fn resolve_param_vtables_under_param_substs(\n-    tcx: ty::ctxt,\n+    tcx: &ty::ctxt,\n     param_substs: Option<@param_substs>,\n     ds: typeck::vtable_param_res)\n     -> typeck::vtable_param_res {\n@@ -890,7 +876,7 @@ pub fn resolve_param_vtables_under_param_substs(\n \n \n \n-pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n+pub fn resolve_vtable_under_param_substs(tcx: &ty::ctxt,\n                                          param_substs: Option<@param_substs>,\n                                          vt: &typeck::vtable_origin)\n                                          -> typeck::vtable_origin {\n@@ -926,7 +912,7 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n     }\n }\n \n-pub fn find_vtable(tcx: ty::ctxt,\n+pub fn find_vtable(tcx: &ty::ctxt,\n                    ps: &param_substs,\n                    n_param: typeck::param_index,\n                    n_bound: uint)\n@@ -955,17 +941,17 @@ pub fn dummy_substs(tps: Vec<ty::t> ) -> ty::substs {\n \n pub fn filename_and_line_num_from_span(bcx: &Block, span: Span)\n                                        -> (ValueRef, ValueRef) {\n-    let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n+    let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n     let filename_cstr = C_cstr(bcx.ccx(),\n-                               token::intern_and_get_ident(loc.file.name));\n-    let filename = build::PointerCast(bcx, filename_cstr, Type::i8p());\n+                               token::intern_and_get_ident(loc.file.deref().name));\n+    let filename = build::PointerCast(bcx, filename_cstr, Type::i8p(bcx.ccx()));\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)\n }\n \n // Casts a Rust bool value to an i1.\n pub fn bool_to_i1(bcx: &Block, llval: ValueRef) -> ValueRef {\n-    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n+    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(bcx.ccx(), false))\n }\n \n pub fn langcall(bcx: &Block,"}, {"sha": "d9868637b8f35949bc7b8ab4f0dcfbdead35b6ca", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 84, "deletions": 85, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -41,40 +41,40 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n-        ast::LitChar(i) => C_integral(Type::char(), i as u64, false),\n+        ast::LitChar(i) => C_integral(Type::char(cx), i as u64, false),\n         ast::LitInt(i, t) => C_integral(Type::int_from_ty(cx, t), i as u64, true),\n         ast::LitUint(u, t) => C_integral(Type::uint_from_ty(cx, t), u, false),\n         ast::LitIntUnsuffixed(i) => {\n-            let lit_int_ty = ty::node_id_to_type(cx.tcx, e.id);\n+            let lit_int_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match ty::get(lit_int_ty).sty {\n                 ty::ty_int(t) => {\n                     C_integral(Type::int_from_ty(cx, t), i as u64, true)\n                 }\n                 ty::ty_uint(t) => {\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n-                _ => cx.sess.span_bug(lit.span,\n+                _ => cx.sess().span_bug(lit.span,\n                         format!(\"integer literal has type {} (expected int or uint)\",\n-                                ty_to_str(cx.tcx, lit_int_ty)))\n+                                ty_to_str(cx.tcx(), lit_int_ty)))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n-            C_floating(fs.get(), Type::float_from_ty(t))\n+            C_floating(fs.get(), Type::float_from_ty(cx, t))\n         }\n         ast::LitFloatUnsuffixed(ref fs) => {\n-            let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n+            let lit_float_ty = ty::node_id_to_type(cx.tcx(), e.id);\n             match ty::get(lit_float_ty).sty {\n                 ty::ty_float(t) => {\n-                    C_floating(fs.get(), Type::float_from_ty(t))\n+                    C_floating(fs.get(), Type::float_from_ty(cx, t))\n                 }\n                 _ => {\n-                    cx.sess.span_bug(lit.span,\n+                    cx.sess().span_bug(lit.span,\n                         \"floating point literal doesn't have the right type\");\n                 }\n             }\n         }\n-        ast::LitBool(b) => C_bool(b),\n-        ast::LitNil => C_nil(),\n+        ast::LitBool(b) => C_bool(cx, b),\n+        ast::LitNil => C_nil(cx),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n         ast::LitBinary(ref data) => C_binary_slice(cx, data.deref().as_slice()),\n     }\n@@ -89,15 +89,15 @@ pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-fn const_vec(cx: @CrateContext, e: &ast::Expr,\n+fn const_vec(cx: &CrateContext, e: &ast::Expr,\n              es: &[@ast::Expr], is_local: bool) -> (ValueRef, Type, bool) {\n-    let vec_ty = ty::expr_ty(cx.tcx, e);\n-    let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n+    let vec_ty = ty::expr_ty(cx.tcx(), e);\n+    let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n     let (vs, inlineable) = vec::unzip(es.iter().map(|e| const_expr(cx, *e, is_local)));\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(vs, false)\n+        C_struct(cx, vs, false)\n     } else {\n         C_array(llunitty, vs)\n     };\n@@ -147,20 +147,20 @@ fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n                     const_deref_newtype(cx, v, t)\n                 }\n                 _ => {\n-                    cx.sess.bug(format!(\"unexpected dereferenceable type {}\",\n-                                     ty_to_str(cx.tcx, t)))\n+                    cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n+                                          ty_to_str(cx.tcx(), t)))\n                 }\n             };\n             (dv, mt.ty)\n         }\n         None => {\n-            cx.sess.bug(format!(\"can't dereference const of type {}\",\n-                             ty_to_str(cx.tcx, t)))\n+            cx.sess().bug(format!(\"can't dereference const of type {}\",\n+                                  ty_to_str(cx.tcx(), t)))\n         }\n     }\n }\n \n-pub fn get_const_val(cx: @CrateContext,\n+pub fn get_const_val(cx: &CrateContext,\n                      mut def_id: ast::DefId) -> (ValueRef, bool) {\n     let contains_key = {\n         let const_values = cx.const_values.borrow();\n@@ -185,12 +185,12 @@ pub fn get_const_val(cx: @CrateContext,\n      !non_inlineable_statics.get().contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool) {\n+pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef, bool) {\n     let (llconst, inlineable) = const_expr_unadjusted(cx, e, is_local);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n-    let ety = ty::expr_ty(cx.tcx, e);\n-    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx, e,\n+    let ety = ty::expr_ty(cx.tcx(), e);\n+    let ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e,\n                                             cx.maps.method_map.borrow().get());\n     let adjustment = {\n         let adjustments = cx.tcx.adjustments.borrow();\n@@ -201,24 +201,24 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n         Some(adj) => {\n             match *adj {\n                 ty::AutoAddEnv(ty::ReStatic, ast::BorrowedSigil) => {\n-                    let def = ty::resolve_expr(cx.tcx, e);\n+                    let def = ty::resolve_expr(cx.tcx(), e);\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n                                                                    def,\n                                                                    llconst,\n                                                                    is_local);\n-                    llconst = C_struct([wrapper, C_null(Type::i8p())], false)\n+                    llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n                 ty::AutoAddEnv(ref r, ref s) => {\n-                    cx.sess\n+                    cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: region \\\n                                          {:?} sigil {:?}\",\n                                         *r,\n                                         *s))\n                 }\n                 ty::AutoObject(..) => {\n-                    cx.sess\n+                    cx.sess()\n                       .span_unimpl(e.span,\n                                    \"unimplemented const coercion to trait \\\n                                     object\");\n@@ -255,9 +255,8 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     assert_eq!(abi::slice_elt_base, 0);\n                                     assert_eq!(abi::slice_elt_len, 1);\n                                     match ty::get(ty).sty {\n-                                        ty::ty_vec(_,\n-                                                   ty::vstore_fixed(len)) => {\n-                                            llconst = C_struct([\n+                                        ty::ty_vec(_, ty::vstore_fixed(len)) => {\n+                                            llconst = C_struct(cx, [\n                                                 llptr,\n                                                 C_uint(cx, len)\n                                             ], false);\n@@ -266,11 +265,11 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                     }\n                                 }\n                                 _ => {\n-                                    cx.sess.span_bug(e.span,\n-                                                     format!(\"unimplemented \\\n-                                                              const autoref \\\n-                                                              {:?}\",\n-                                                             autoref))\n+                                    cx.sess().span_bug(e.span,\n+                                                       format!(\"unimplemented \\\n+                                                                const autoref \\\n+                                                                {:?}\",\n+                                                               autoref))\n                                 }\n                             }\n                         }\n@@ -289,16 +288,16 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess.bug(format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(cx.tcx), ty_to_str(cx.tcx, ety),\n+        cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n+                         e.repr(cx.tcx()), ty_to_str(cx.tcx(), ety),\n                          csize, tsize));\n     }\n     (llconst, inlineable)\n }\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n-fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n+fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n     let map_list = |exprs: &[@ast::Expr]| {\n         exprs.iter().map(|&e| const_expr(cx, e, is_local))\n@@ -321,7 +320,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n \n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let ty = ty::expr_ty(cx.tcx, e1);\n+            let ty = ty::expr_ty(cx.tcx(), e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n             return (match b {\n@@ -397,7 +396,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n           },\n           ast::ExprUnary(u, e) => {\n             let (te, _) = const_expr(cx, e, is_local);\n-            let ty = ty::expr_ty(cx.tcx, e);\n+            let ty = ty::expr_ty(cx.tcx(), e);\n             let is_float = ty::type_is_fp(ty);\n             return (match u {\n               ast::UnBox | ast::UnUniq | ast::UnDeref => {\n@@ -409,9 +408,9 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                     ty::ty_bool => {\n                         // Somewhat questionable, but I believe this is\n                         // correct.\n-                        let te = llvm::LLVMConstTrunc(te, Type::i1().to_ref());\n+                        let te = llvm::LLVMConstTrunc(te, Type::i1(cx).to_ref());\n                         let te = llvm::LLVMConstNot(te);\n-                        llvm::LLVMConstZExt(te, Type::bool().to_ref())\n+                        llvm::LLVMConstZExt(te, Type::bool(cx).to_ref())\n                     }\n                     _ => llvm::LLVMConstNot(te),\n                 }\n@@ -423,25 +422,25 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n             }, true)\n           }\n           ast::ExprField(base, field, _) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n                                             cx.maps.method_map.borrow().get());\n               let brepr = adt::represent_type(cx, bt);\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n-              expr::with_field_tys(cx.tcx, bt, None, |discr, field_tys| {\n-                  let ix = ty::field_idx_strict(cx.tcx, field.name, field_tys);\n+              expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n+                  let ix = ty::field_idx_strict(cx.tcx(), field.name, field_tys);\n                   (adt::const_get_field(cx, brepr, bv, discr, ix), inlineable)\n               })\n           }\n \n           ast::ExprIndex(base, index) => {\n-              let bt = ty::expr_ty_adjusted(cx.tcx, base,\n+              let bt = ty::expr_ty_adjusted(cx.tcx(), base,\n                                             cx.maps.method_map.borrow().get());\n               let (bv, inlineable) = const_expr(cx, base, is_local);\n-              let iv = match const_eval::eval_const_expr(cx.tcx, index) {\n+              let iv = match const_eval::eval_const_expr(cx.tcx(), index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n-                  _ => cx.sess.span_bug(index.span,\n-                                        \"index is not an integer-constant expression\")\n+                  _ => cx.sess().span_bug(index.span,\n+                                          \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n                   ty::ty_vec(_, vstore) | ty::ty_str(vstore) =>\n@@ -453,11 +452,11 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                           let e1 = const_get_elt(cx, bv, [0]);\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n                       },\n-                      _ => cx.sess.span_bug(base.span,\n-                                            \"index-expr base must be fixed-size or slice\")\n+                      _ => cx.sess().span_bug(base.span,\n+                                              \"index-expr base must be fixed-size or slice\")\n                   },\n-                  _ =>  cx.sess.span_bug(base.span,\n-                                         \"index-expr base must be a vector or string type\")\n+                  _ =>  cx.sess().span_bug(base.span,\n+                                           \"index-expr base must be a vector or string type\")\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -468,15 +467,15 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               if iv >= len {\n                   // FIXME #3170: report this earlier on in the const-eval\n                   // pass. Reporting here is a bit late.\n-                  cx.sess.span_err(e.span,\n-                                   \"const index-expr is out of bounds\");\n+                  cx.sess().span_err(e.span,\n+                                     \"const index-expr is out of bounds\");\n               }\n               (const_get_elt(cx, arr, [iv as c_uint]), inlineable)\n           }\n           ast::ExprCast(base, _) => {\n-            let ety = ty::expr_ty(cx.tcx, e);\n+            let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let basety = ty::expr_ty(cx.tcx, base);\n+            let basety = ty::expr_ty(cx.tcx(), base);\n             let (v, inlineable) = const_expr(cx, base, is_local);\n             return (match (expr::cast_type_kind(basety),\n                            expr::cast_type_kind(ety)) {\n@@ -511,8 +510,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                         llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n                     }\n                     expr::cast_float => llvm::LLVMConstUIToFP(iv, llty.to_ref()),\n-                    _ => cx.sess.bug(\"enum cast destination is not \\\n-                                      integral or float\")\n+                    _ => cx.sess().bug(\"enum cast destination is not \\\n+                                        integral or float\")\n                 }\n               }\n               (expr::cast_pointer, expr::cast_pointer) => {\n@@ -522,8 +521,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 llvm::LLVMConstIntToPtr(v, llty.to_ref())\n               }\n               _ => {\n-                cx.sess.impossible_case(e.span,\n-                                        \"bad combination of types for cast\")\n+                cx.sess().impossible_case(e.span,\n+                                          \"bad combination of types for cast\")\n               }\n             }, inlineable)\n           }\n@@ -532,15 +531,15 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               (const_addr_of(cx, e), false)\n           }\n           ast::ExprTup(ref es) => {\n-              let ety = ty::expr_ty(cx.tcx, e);\n+              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let (vals, inlineable) = map_list(es.as_slice());\n               (adt::trans_const(cx, repr, 0, vals.as_slice()), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n-              let ety = ty::expr_ty(cx.tcx, e);\n+              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let tcx = cx.tcx;\n+              let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n                 Some(base) => Some(const_expr(cx, base, is_local)),\n@@ -558,7 +557,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                                     (adt::const_get_field(cx, repr, bv, discr, ix),\n                                      inlineable)\n                                 }\n-                                None => cx.tcx.sess.span_bug(e.span, \"missing struct field\")\n+                                None => cx.sess().span_bug(e.span, \"missing struct field\")\n                               }\n                           }\n                       }\n@@ -580,7 +579,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               ast::ExprLit(ref lit) => {\n                 match lit.node {\n                     ast::LitStr(..) => { const_expr(cx, sub, is_local) }\n-                    _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n+                    _ => { cx.sess().span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }\n               ast::ExprVec(ref es, ast::MutImmutable) => {\n@@ -596,23 +595,23 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);\n                 let p = const_ptrcast(cx, gv, llunitty);\n-                (C_struct([p, C_uint(cx, es.len())], false), false)\n+                (C_struct(cx, [p, C_uint(cx, es.len())], false), false)\n               }\n-              _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n+              _ => cx.sess().span_bug(e.span, \"bad const-slice expr\")\n             }\n           }\n           ast::ExprRepeat(elem, count, _) => {\n-            let vec_ty = ty::expr_ty(cx.tcx, e);\n-            let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n+            let vec_ty = ty::expr_ty(cx.tcx(), e);\n+            let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = match const_eval::eval_const_expr(cx.tcx, count) {\n+            let n = match const_eval::eval_const_expr(cx.tcx(), count) {\n                 const_eval::const_int(i)  => i as uint,\n                 const_eval::const_uint(i) => i as uint,\n-                _ => cx.sess.span_bug(count.span, \"count must be integral const expression.\")\n+                _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n             let vs = vec::from_elem(n, const_expr(cx, elem, is_local).val0());\n             let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(vs, false)\n+                C_struct(cx, vs, false)\n             } else {\n                 C_array(llunitty, vs)\n             };\n@@ -622,15 +621,15 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n             // Assert that there are no type parameters in this path.\n             assert!(pth.segments.iter().all(|seg| seg.types.is_empty()));\n \n-            let tcx = cx.tcx;\n+            let tcx = cx.tcx();\n             let opt_def = {\n                 let def_map = tcx.def_map.borrow();\n                 def_map.get().find_copy(&e.id)\n             };\n             match opt_def {\n                 Some(ast::DefFn(def_id, _purity)) => {\n                     if !ast_util::is_local(def_id) {\n-                        let ty = csearch::get_type(cx.tcx, def_id).ty;\n+                        let ty = csearch::get_type(cx.tcx(), def_id).ty;\n                         (base::trans_external_path(cx, def_id, ty), true)\n                     } else {\n                         assert!(ast_util::is_local(def_id));\n@@ -641,41 +640,41 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                     get_const_val(cx, def_id)\n                 }\n                 Some(ast::DefVariant(enum_did, variant_did, _)) => {\n-                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let ety = ty::expr_ty(cx.tcx(), e);\n                     let repr = adt::represent_type(cx, ety);\n-                    let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                    let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n                     (adt::trans_const(cx, repr, vinfo.disr_val, []), true)\n                 }\n                 Some(ast::DefStruct(_)) => {\n-                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let ety = ty::expr_ty(cx.tcx(), e);\n                     let llty = type_of::type_of(cx, ety);\n                     (C_null(llty), true)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n+                    cx.sess().span_bug(e.span, \"expected a const, fn, struct, or variant def\")\n                 }\n             }\n           }\n           ast::ExprCall(callee, ref args) => {\n-              let tcx = cx.tcx;\n+              let tcx = cx.tcx();\n               let opt_def = {\n                   let def_map = tcx.def_map.borrow();\n                   def_map.get().find_copy(&callee.id)\n               };\n               match opt_def {\n                   Some(ast::DefStruct(_)) => {\n-                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n                       (adt::trans_const(cx, repr, 0, arg_vals.as_slice()),\n                        inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n-                      let ety = ty::expr_ty(cx.tcx, e);\n+                      let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let vinfo = ty::enum_variant_with_id(cx.tcx,\n+                      let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n@@ -684,17 +683,17 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                                         vinfo.disr_val,\n                                         arg_vals.as_slice()), inlineable)\n                   }\n-                  _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n+                  _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n           ast::ExprParen(e) => { const_expr(cx, e, is_local) }\n-          _ => cx.sess.span_bug(e.span,\n+          _ => cx.sess().span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };\n     }\n }\n \n-pub fn trans_const(ccx: @CrateContext, m: ast::Mutability, id: ast::NodeId) {\n+pub fn trans_const(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     unsafe {\n         let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);"}, {"sha": "4ed4f0fb3102c44944872682845875d7101d859a", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 93, "deletions": 115, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n \n-use driver::session;\n use driver::session::NoDebugInfo;\n+use driver::session::Session;\n use lib::llvm::{ContextRef, ModuleRef, ValueRef};\n use lib::llvm::{llvm, TargetData, TypeNames};\n use lib::llvm::mk_target_data;\n@@ -31,15 +31,14 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n-use std::local_data;\n use std::libc::c_uint;\n+use std::ptr;\n use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct CrateContext {\n-    sess: session::Session,\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     metadata_llmod: ModuleRef,\n@@ -49,7 +48,7 @@ pub struct CrateContext {\n     intrinsics: HashMap<&'static str, ValueRef>,\n     item_vals: RefCell<NodeMap<ValueRef>>,\n     exp_map2: resolve::ExportMap2,\n-    reachable: @RefCell<NodeSet>,\n+    reachable: NodeSet,\n     item_symbols: RefCell<NodeMap<~str>>,\n     link_meta: LinkMeta,\n     drop_glues: RefCell<HashMap<ty::t, ValueRef>>,\n@@ -104,7 +103,6 @@ pub struct CrateContext {\n     tcx: ty::ctxt,\n     maps: astencode::Maps,\n     stats: @Stats,\n-    tydesc_type: Type,\n     int_type: Type,\n     opaque_vec_type: Type,\n     builder: BuilderRef_res,\n@@ -115,131 +113,129 @@ pub struct CrateContext {\n     // is not emitted by LLVM's GC pass when no functions use GC.\n     uses_gc: bool,\n     dbg_cx: Option<debuginfo::CrateDebugContext>,\n-    do_not_commit_warning_issued: Cell<bool>,\n }\n \n impl CrateContext {\n-    pub fn new(sess: session::Session,\n-               name: &str,\n+    pub fn new(name: &str,\n                tcx: ty::ctxt,\n                emap2: resolve::ExportMap2,\n                maps: astencode::Maps,\n                symbol_hasher: Sha256,\n                link_meta: LinkMeta,\n-               reachable: @RefCell<NodeSet>)\n+               reachable: NodeSet)\n                -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n-            set_task_llcx(llcx);\n             let llmod = name.with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n             let metadata_llmod = format!(\"{}_metadata\", name).with_c_str(|buf| {\n                 llvm::LLVMModuleCreateWithNameInContext(buf, llcx)\n             });\n-            let data_layout: &str = sess.targ_cfg.target_strs.data_layout;\n-            let targ_triple: &str = sess.targ_cfg.target_strs.target_triple;\n-            data_layout.with_c_str(|buf| {\n+            tcx.sess.targ_cfg.target_strs.data_layout.with_c_str(|buf| {\n                 llvm::LLVMSetDataLayout(llmod, buf);\n                 llvm::LLVMSetDataLayout(metadata_llmod, buf);\n             });\n-            targ_triple.with_c_str(|buf| {\n+            tcx.sess.targ_cfg.target_strs.target_triple.with_c_str(|buf| {\n                 llvm::LLVMRustSetNormalizedTarget(llmod, buf);\n                 llvm::LLVMRustSetNormalizedTarget(metadata_llmod, buf);\n             });\n-            let targ_cfg = sess.targ_cfg;\n \n-            let td = mk_target_data(sess.targ_cfg.target_strs.data_layout);\n-            let tn = TypeNames::new();\n+            let td = mk_target_data(tcx.sess.targ_cfg.target_strs.data_layout);\n \n-            let mut intrinsics = base::declare_intrinsics(llmod);\n-            if sess.opts.debuginfo != NoDebugInfo {\n-                base::declare_dbg_intrinsics(llmod, &mut intrinsics);\n-            }\n-            let int_type = Type::int(targ_cfg.arch);\n-            let tydesc_type = Type::tydesc(targ_cfg.arch);\n-            let opaque_vec_type = Type::opaque_vec(targ_cfg.arch);\n-\n-            let mut str_slice_ty = Type::named_struct(\"str_slice\");\n-            str_slice_ty.set_struct_body([Type::i8p(), int_type], false);\n-\n-            tn.associate_type(\"tydesc\", &tydesc_type);\n-            tn.associate_type(\"str_slice\", &str_slice_ty);\n-\n-            let (crate_map_name, crate_map) = decl_crate_map(sess, link_meta.clone(), llmod);\n-            let dbg_cx = if sess.opts.debuginfo != NoDebugInfo {\n+            let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n             } else {\n                 None\n             };\n \n-            if sess.count_llvm_insns() {\n+            let mut ccx = CrateContext {\n+                llmod: llmod,\n+                llcx: llcx,\n+                metadata_llmod: metadata_llmod,\n+                td: td,\n+                tn: TypeNames::new(),\n+                externs: RefCell::new(HashMap::new()),\n+                intrinsics: HashMap::new(),\n+                item_vals: RefCell::new(NodeMap::new()),\n+                exp_map2: emap2,\n+                reachable: reachable,\n+                item_symbols: RefCell::new(NodeMap::new()),\n+                link_meta: link_meta,\n+                drop_glues: RefCell::new(HashMap::new()),\n+                tydescs: RefCell::new(HashMap::new()),\n+                finished_tydescs: Cell::new(false),\n+                external: RefCell::new(DefIdMap::new()),\n+                external_srcs: RefCell::new(NodeMap::new()),\n+                non_inlineable_statics: RefCell::new(NodeSet::new()),\n+                monomorphized: RefCell::new(HashMap::new()),\n+                monomorphizing: RefCell::new(DefIdMap::new()),\n+                vtables: RefCell::new(HashMap::new()),\n+                const_cstr_cache: RefCell::new(HashMap::new()),\n+                const_globals: RefCell::new(HashMap::new()),\n+                const_values: RefCell::new(NodeMap::new()),\n+                extern_const_values: RefCell::new(DefIdMap::new()),\n+                impl_method_cache: RefCell::new(HashMap::new()),\n+                closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n+                lltypes: RefCell::new(HashMap::new()),\n+                llsizingtypes: RefCell::new(HashMap::new()),\n+                adt_reprs: RefCell::new(HashMap::new()),\n+                symbol_hasher: RefCell::new(symbol_hasher),\n+                type_hashcodes: RefCell::new(HashMap::new()),\n+                all_llvm_symbols: RefCell::new(HashSet::new()),\n+                tcx: tcx,\n+                maps: maps,\n+                stats: @Stats {\n+                    n_static_tydescs: Cell::new(0u),\n+                    n_glues_created: Cell::new(0u),\n+                    n_null_glues: Cell::new(0u),\n+                    n_real_glues: Cell::new(0u),\n+                    n_fns: Cell::new(0u),\n+                    n_monos: Cell::new(0u),\n+                    n_inlines: Cell::new(0u),\n+                    n_closures: Cell::new(0u),\n+                    n_llvm_insns: Cell::new(0u),\n+                    llvm_insns: RefCell::new(HashMap::new()),\n+                    fn_stats: RefCell::new(Vec::new()),\n+                },\n+                int_type: Type::from_ref(ptr::null()),\n+                opaque_vec_type: Type::from_ref(ptr::null()),\n+                builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n+                crate_map: ptr::null(),\n+                crate_map_name: ~\"\",\n+                uses_gc: false,\n+                dbg_cx: dbg_cx,\n+            };\n+\n+            ccx.int_type = Type::int(&ccx);\n+            ccx.opaque_vec_type = Type::opaque_vec(&ccx);\n+\n+            ccx.tn.associate_type(\"tydesc\", &Type::tydesc(&ccx));\n+\n+            let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n+            str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type], false);\n+            ccx.tn.associate_type(\"str_slice\", &str_slice_ty);\n+\n+            decl_crate_map(&mut ccx);\n+\n+            base::declare_intrinsics(&mut ccx);\n+\n+            if ccx.sess().count_llvm_insns() {\n                 base::init_insn_ctxt()\n             }\n \n-            CrateContext {\n-                 sess: sess,\n-                 llmod: llmod,\n-                 llcx: llcx,\n-                 metadata_llmod: metadata_llmod,\n-                 td: td,\n-                 tn: tn,\n-                 externs: RefCell::new(HashMap::new()),\n-                 intrinsics: intrinsics,\n-                 item_vals: RefCell::new(NodeMap::new()),\n-                 exp_map2: emap2,\n-                 reachable: reachable,\n-                 item_symbols: RefCell::new(NodeMap::new()),\n-                 link_meta: link_meta,\n-                 drop_glues: RefCell::new(HashMap::new()),\n-                 tydescs: RefCell::new(HashMap::new()),\n-                 finished_tydescs: Cell::new(false),\n-                 external: RefCell::new(DefIdMap::new()),\n-                 external_srcs: RefCell::new(NodeMap::new()),\n-                 non_inlineable_statics: RefCell::new(NodeSet::new()),\n-                 monomorphized: RefCell::new(HashMap::new()),\n-                 monomorphizing: RefCell::new(DefIdMap::new()),\n-                 vtables: RefCell::new(HashMap::new()),\n-                 const_cstr_cache: RefCell::new(HashMap::new()),\n-                 const_globals: RefCell::new(HashMap::new()),\n-                 const_values: RefCell::new(NodeMap::new()),\n-                 extern_const_values: RefCell::new(DefIdMap::new()),\n-                 impl_method_cache: RefCell::new(HashMap::new()),\n-                 closure_bare_wrapper_cache: RefCell::new(HashMap::new()),\n-                 lltypes: RefCell::new(HashMap::new()),\n-                 llsizingtypes: RefCell::new(HashMap::new()),\n-                 adt_reprs: RefCell::new(HashMap::new()),\n-                 symbol_hasher: RefCell::new(symbol_hasher),\n-                 type_hashcodes: RefCell::new(HashMap::new()),\n-                 all_llvm_symbols: RefCell::new(HashSet::new()),\n-                 tcx: tcx,\n-                 maps: maps,\n-                 stats: @Stats {\n-                   n_static_tydescs: Cell::new(0u),\n-                   n_glues_created: Cell::new(0u),\n-                   n_null_glues: Cell::new(0u),\n-                   n_real_glues: Cell::new(0u),\n-                   n_fns: Cell::new(0u),\n-                   n_monos: Cell::new(0u),\n-                   n_inlines: Cell::new(0u),\n-                   n_closures: Cell::new(0u),\n-                   n_llvm_insns: Cell::new(0u),\n-                   llvm_insns: RefCell::new(HashMap::new()),\n-                   fn_stats: RefCell::new(Vec::new()),\n-                 },\n-                 tydesc_type: tydesc_type,\n-                 int_type: int_type,\n-                 opaque_vec_type: opaque_vec_type,\n-                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                 crate_map: crate_map,\n-                 crate_map_name: crate_map_name,\n-                 uses_gc: false,\n-                 dbg_cx: dbg_cx,\n-                 do_not_commit_warning_issued: Cell::new(false),\n-            }\n+            ccx\n         }\n     }\n \n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        &self.tcx\n+    }\n+\n+    pub fn sess<'a>(&'a self) -> &'a Session {\n+        &self.tcx.sess\n+    }\n+\n     pub fn builder<'a>(&'a self) -> Builder<'a> {\n         Builder::new(self)\n     }\n@@ -250,7 +246,7 @@ impl CrateContext {\n         debug!(\"const_inbounds_gepi: pointer={} indices={:?}\",\n                self.tn.val_to_str(pointer), indices);\n         let v: Vec<ValueRef> =\n-            indices.iter().map(|i| C_i32(*i as i32)).collect();\n+            indices.iter().map(|i| C_i32(self, *i as i32)).collect();\n         unsafe {\n             llvm::LLVMConstInBoundsGEP(pointer,\n                                        v.as_ptr(),\n@@ -273,26 +269,8 @@ impl CrateContext {\n                                     self.int_type.to_ref())\n         }\n     }\n-}\n \n-#[unsafe_destructor]\n-impl Drop for CrateContext {\n-    fn drop(&mut self) {\n-        unset_task_llcx();\n+    pub fn tydesc_type(&self) -> Type {\n+        self.tn.find_type(\"tydesc\").unwrap()\n     }\n }\n-\n-local_data_key!(task_local_llcx_key: @ContextRef)\n-\n-pub fn task_llcx() -> ContextRef {\n-    let opt = local_data::get(task_local_llcx_key, |k| k.map(|k| *k));\n-    *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n-}\n-\n-fn set_task_llcx(c: ContextRef) {\n-    local_data::set(task_local_llcx_key, @c);\n-}\n-\n-fn unset_task_llcx() {\n-    local_data::pop(task_local_llcx_key);\n-}"}, {"sha": "2796eaeb129d80df2f67fa9f969ffb01a2d47a41", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -331,16 +331,14 @@ pub fn trans_fail<'a>(\n                   sp: Span,\n                   fail_str: InternedString)\n                   -> &'a Block<'a> {\n-    let v_fail_str = C_cstr(bcx.ccx(), fail_str);\n-    let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n-    let sess = bcx.sess();\n-    let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-    let v_filename = C_cstr(bcx.ccx(),\n-                            token::intern_and_get_ident(loc.file.name));\n+    let v_fail_str = C_cstr(ccx, fail_str);\n+    let _icx = push_ctxt(\"trans_fail_value\");\n+    let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n+    let v_filename = C_cstr(ccx, token::intern_and_get_ident(loc.file.deref().name));\n     let v_line = loc.line as int;\n-    let v_str = PointerCast(bcx, v_fail_str, Type::i8p());\n-    let v_filename = PointerCast(bcx, v_filename, Type::i8p());\n+    let v_str = PointerCast(bcx, v_fail_str, Type::i8p(ccx));\n+    let v_filename = PointerCast(bcx, v_filename, Type::i8p(ccx));\n     let args = vec!(v_str, v_filename, C_int(ccx, v_line));\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "c334971db5934ab44d99ea00d20cee1d0da9d4d0", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -635,7 +635,7 @@ impl<K:KindOps> Datum<K> {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         format!(\"Datum({}, {}, {:?})\",\n              ccx.tn.val_to_str(self.val),\n-             ty_to_str(ccx.tcx, self.ty),\n+             ty_to_str(ccx.tcx(), self.ty),\n              self.kind)\n     }\n \n@@ -709,11 +709,11 @@ impl<'a> DatumBlock<'a, Expr> {\n         self.datum.shallow_copy(self.bcx, dst)\n     }\n \n-    pub fn ccx(&self) -> @CrateContext {\n+    pub fn ccx(&self) -> &'a CrateContext {\n         self.bcx.ccx()\n     }\n \n-    pub fn tcx(&self) -> ty::ctxt {\n+    pub fn tcx(&self) -> &'a ty::ctxt {\n         self.bcx.tcx()\n     }\n "}, {"sha": "b044ee15b3b133b3de0db8b021b00b89a5444436", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -213,10 +213,10 @@ impl FunctionDebugContext {\n         match *self {\n             FunctionDebugContext(~ref data) => data,\n             DebugInfoDisabled => {\n-                cx.sess.span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n+                cx.sess().span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionWithoutDebugInfo => {\n-                cx.sess.span_bug(span, FunctionDebugContext::should_be_ignored_message());\n+                cx.sess().span_bug(span, FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n@@ -253,7 +253,7 @@ enum VariableKind {\n }\n \n /// Create any deferred debug metadata nodes\n-pub fn finalize(cx: @CrateContext) {\n+pub fn finalize(cx: &CrateContext) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -268,7 +268,7 @@ pub fn finalize(cx: @CrateContext) {\n         // instruct LLVM to emit an older version of dwarf, however,\n         // for OS X to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n-        if cx.sess.targ_cfg.os == abi::OsMacos {\n+        if cx.sess().targ_cfg.os == abi::OsMacos {\n             \"Dwarf Version\".with_c_str(\n                 |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 2));\n         }\n@@ -299,7 +299,7 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n             match lllocals.get().find_copy(&node_id) {\n                 Some(datum) => datum,\n                 None => {\n-                    bcx.tcx().sess.span_bug(span,\n+                    bcx.sess().span_bug(span,\n                         format!(\"no entry in lllocals table for {:?}\",\n                                 node_id));\n                 }\n@@ -338,15 +338,15 @@ pub fn create_captured_var_metadata(bcx: &Block,\n \n     let variable_ident = match ast_item {\n         None => {\n-            cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n+            cx.sess().span_bug(span, \"debuginfo::create_captured_var_metadata: node not found\");\n         }\n         Some(ast_map::NodeLocal(pat)) | Some(ast_map::NodeArg(pat)) => {\n             match pat.node {\n                 ast::PatIdent(_, ref path, _) => {\n                     ast_util::path_to_ident(path)\n                 }\n                 _ => {\n-                    cx.sess\n+                    cx.sess()\n                       .span_bug(span,\n                                 format!(\n                                 \"debuginfo::create_captured_var_metadata() - \\\n@@ -357,7 +357,7 @@ pub fn create_captured_var_metadata(bcx: &Block,\n             }\n         }\n         _ => {\n-            cx.sess.span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n+            cx.sess().span_bug(span, format!(\"debuginfo::create_captured_var_metadata() - \\\n                 Captured var-id refers to unexpected ast_map variant: {:?}\", ast_item));\n         }\n     };\n@@ -369,10 +369,10 @@ pub fn create_captured_var_metadata(bcx: &Block,\n     let byte_offset_of_var_in_env = machine::llelement_offset(cx, llvm_env_data_type, env_index);\n \n     let address_operations = unsafe {\n-        [llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref()),\n-         llvm::LLVMDIBuilderCreateOpPlus(Type::i64().to_ref()),\n-         C_i64(byte_offset_of_var_in_env as i64),\n-         llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref())]\n+        [llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref()),\n+         llvm::LLVMDIBuilderCreateOpPlus(Type::i64(cx).to_ref()),\n+         C_i64(cx, byte_offset_of_var_in_env as i64),\n+         llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref())]\n     };\n \n     let address_op_count = match closure_sigil {\n@@ -441,15 +441,15 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n             match llargs.get().find_copy(&node_id) {\n                 Some(v) => v,\n                 None => {\n-                    bcx.tcx().sess.span_bug(span,\n+                    bcx.sess().span_bug(span,\n                         format!(\"no entry in llargs table for {:?}\",\n                                 node_id));\n                 }\n             }\n         };\n \n         if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null() {\n-            cx.sess.span_bug(span, \"debuginfo::create_argument_metadata() - \\\n+            cx.sess().span_bug(span, \"debuginfo::create_argument_metadata() - \\\n                                     Referenced variable location is not an alloca!\");\n         }\n \n@@ -485,7 +485,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n \n     let cx = fcx.ccx;\n \n-    debug!(\"set_source_location: {}\", cx.sess.codemap.span_to_str(span));\n+    debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_str(span));\n \n     if fcx.debug_context.get_ref(cx, span).source_locations_enabled.get() {\n         let loc = span_start(cx, span);\n@@ -532,7 +532,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                      fn_ast_id: ast::NodeId,\n                                      param_substs: Option<@param_substs>,\n                                      llfn: ValueRef) -> FunctionDebugContext {\n-    if cx.sess.opts.debuginfo == NoDebugInfo {\n+    if cx.sess().opts.debuginfo == NoDebugInfo {\n         return DebugInfoDisabled;\n     }\n \n@@ -551,7 +551,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     (item.ident, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {\n-                    cx.sess.span_bug(item.span,\n+                    cx.sess().span_bug(item.span,\n                         \"create_function_debug_context: item bound to non-function\");\n                 }\n             }\n@@ -579,7 +579,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                         // Don't try to lookup the item path:\n                         false)\n                 }\n-                _ => cx.sess.span_bug(expr.span,\n+                _ => cx.sess().span_bug(expr.span,\n                         \"create_function_debug_context: expected an expr_fn_block here\")\n             }\n         }\n@@ -594,7 +594,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                      true)\n                 }\n                 _ => {\n-                    cx.sess\n+                    cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n                                     fnitem))\n@@ -606,8 +606,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         ast_map::NodeStructCtor(..) => {\n             return FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess.bug(format!(\"create_function_debug_context: \\\n-                                  unexpected sort of node: {:?}\", fnitem))\n+        _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n+                                    unexpected sort of node: {:?}\", fnitem))\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -616,7 +616,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx, fn_ast_id, fn_decl, param_substs, span);\n@@ -652,10 +652,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     // (by being externally visible or by being inlined into something externally visible). It might\n     // better to use the `exported_items` set from `driver::CrateAnalysis` in the future, but (atm)\n     // this set is not available in the translation pass.\n-    let is_local_to_unit = {\n-        let reachable = cx.reachable.borrow();\n-        !reachable.get().contains(&fn_ast_id)\n-    };\n+    let is_local_to_unit = !cx.reachable.contains(&fn_ast_id);\n \n     let fn_metadata = function_name.with_c_str(|function_name| {\n                           linkage_name.with_c_str(|linkage_name| {\n@@ -672,7 +669,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     true,\n                     scope_line as c_uint,\n                     FlagPrototyped as c_uint,\n-                    cx.sess.opts.optimize != session::No,\n+                    cx.sess().opts.optimize != session::No,\n                     llfn,\n                     template_parameters,\n                     ptr::null())\n@@ -708,7 +705,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                               fn_decl: &ast::FnDecl,\n                               param_substs: Option<@param_substs>,\n                               error_span: Span) -> DIArray {\n-        if cx.sess.opts.debuginfo == LimitedDebugInfo {\n+        if cx.sess().opts.debuginfo == LimitedDebugInfo {\n             return create_DIArray(DIB(cx), []);\n         }\n \n@@ -722,11 +719,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             _ => {\n                 assert_type_for_node_id(cx, fn_ast_id, error_span);\n \n-                let return_type = ty::node_id_to_type(cx.tcx, fn_ast_id);\n+                let return_type = ty::node_id_to_type(cx.tcx(), fn_ast_id);\n                 let return_type = match param_substs {\n                     None => return_type,\n                     Some(substs) => {\n-                        ty::subst_tps(cx.tcx,\n+                        ty::subst_tps(cx.tcx(),\n                                       substs.tys.as_slice(),\n                                       substs.self_ty,\n                                       return_type)\n@@ -740,11 +737,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         // Arguments types\n         for arg in fn_decl.inputs.iter() {\n             assert_type_for_node_id(cx, arg.pat.id, arg.pat.span);\n-            let arg_type = ty::node_id_to_type(cx.tcx, arg.pat.id);\n+            let arg_type = ty::node_id_to_type(cx.tcx(), arg.pat.id);\n             let arg_type = match param_substs {\n                 None => arg_type,\n                 Some(substs) => {\n-                    ty::subst_tps(cx.tcx,\n+                    ty::subst_tps(cx.tcx(),\n                                   substs.tys.as_slice(),\n                                   substs.self_ty,\n                                   arg_type)\n@@ -785,15 +782,15 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         if has_self_type {\n             let actual_self_type = self_type.unwrap();\n             // Add self type name to <...> clause of function name\n-            let actual_self_type_name = ppaux::ty_to_str(cx.tcx, actual_self_type);\n+            let actual_self_type_name = ppaux::ty_to_str(cx.tcx(), actual_self_type);\n             name_to_append_suffix_to.push_str(actual_self_type_name);\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n             // Only create type information if full debuginfo is enabled\n-            if cx.sess.opts.debuginfo == FullDebugInfo {\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_self_type_metadata = type_metadata(cx,\n                                                               actual_self_type,\n                                                               codemap::DUMMY_SP);\n@@ -829,15 +826,15 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n-            let actual_type_name = ppaux::ty_to_str(cx.tcx, actual_type);\n+            let actual_type_name = ppaux::ty_to_str(cx.tcx(), actual_type);\n             name_to_append_suffix_to.push_str(actual_type_name);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n \n             // Again, only create type information if full debuginfo is enabled\n-            if cx.sess.opts.debuginfo == FullDebugInfo {\n+            if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n                 let param_metadata = token::get_ident(ident).get()\n                                                             .with_c_str(|name| {\n@@ -873,12 +870,12 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n }\n \n fn compile_unit_metadata(cx: &CrateContext) {\n-    let work_dir = &cx.sess.working_dir;\n-    let compile_unit_name = match cx.sess.local_crate_source_file {\n+    let work_dir = &cx.sess().working_dir;\n+    let compile_unit_name = match cx.sess().local_crate_source_file {\n         None => fallback_path(cx),\n         Some(ref abs_path) => {\n             if abs_path.is_relative() {\n-                cx.sess.warn(\"debuginfo: Invalid path to crate's local root source file!\");\n+                cx.sess().warn(\"debuginfo: Invalid path to crate's local root source file!\");\n                 fallback_path(cx)\n             } else {\n                 match abs_path.path_relative_from(work_dir) {\n@@ -917,7 +914,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                                 compile_unit_name,\n                                 work_dir,\n                                 producer,\n-                                cx.sess.opts.optimize != session::No,\n+                                cx.sess().opts.optimize != session::No,\n                                 flags,\n                                 0,\n                                 split_name);\n@@ -942,7 +939,7 @@ fn declare_local(bcx: &Block,\n                  span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n-    let filename = span_start(cx, span).file.name.clone();\n+    let filename = span_start(cx, span).file.deref().name.clone();\n     let file_metadata = file_metadata(cx, filename);\n \n     let name = token::get_ident(variable_ident);\n@@ -968,7 +965,7 @@ fn declare_local(bcx: &Block,\n                         file_metadata,\n                         loc.line as c_uint,\n                         type_metadata,\n-                        cx.sess.opts.optimize != session::No,\n+                        cx.sess().opts.optimize != session::No,\n                         0,\n                         argument_index)\n                 }\n@@ -1028,7 +1025,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     debug!(\"file_metadata: {}\", full_path);\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    let work_dir = cx.sess.working_dir.as_str().unwrap();\n+    let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n             full_path.slice(work_dir.len() + 1u, full_path.len())\n@@ -1063,7 +1060,7 @@ fn scope_metadata(fcx: &FunctionContext,\n         None => {\n             let node = fcx.ccx.tcx.map.get(node_id);\n \n-            fcx.ccx.sess.span_bug(span,\n+            fcx.ccx.sess().span_bug(span,\n                 format!(\"debuginfo: Could not find scope info for node {:?}\", node));\n         }\n     }\n@@ -1096,7 +1093,7 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n             ast::TyF32 => (~\"f32\", DW_ATE_float),\n             ast::TyF64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n+        _ => cx.sess().bug(\"debuginfo::basic_type_metadata - t is invalid type\")\n     };\n \n     let llvm_type = type_of::type_of(cx, t);\n@@ -1121,7 +1118,7 @@ fn pointer_type_metadata(cx: &CrateContext,\n                       -> DIType {\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n-    let name = ppaux::ty_to_str(cx.tcx, pointer_type);\n+    let name = ppaux::ty_to_str(cx.tcx(), pointer_type);\n     let ptr_metadata = name.with_c_str(|name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreatePointerType(\n@@ -1193,12 +1190,12 @@ fn prepare_struct_metadata(cx: &CrateContext,\n                            substs: &ty::substs,\n                            span: Span)\n                         -> RecursiveTypeDescription {\n-    let struct_name = ppaux::ty_to_str(cx.tcx, struct_type);\n+    let struct_name = ppaux::ty_to_str(cx.tcx(), struct_type);\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n-    let file_name = span_start(cx, definition_span).file.name.clone();\n+    let file_name = span_start(cx, definition_span).file.deref().name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n@@ -1208,7 +1205,7 @@ fn prepare_struct_metadata(cx: &CrateContext,\n                                                   file_metadata,\n                                                   definition_span);\n \n-    let fields = ty::struct_fields(cx.tcx, def_id, substs);\n+    let fields = ty::struct_fields(cx.tcx(), def_id, substs);\n \n     UnfinishedMetadata {\n         cache_id: cache_id_for_type(struct_type),\n@@ -1291,11 +1288,11 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                           component_types: &[ty::t],\n                           span: Span)\n                        -> RecursiveTypeDescription {\n-    let tuple_name = ppaux::ty_to_str(cx.tcx, tuple_type);\n+    let tuple_name = ppaux::ty_to_str(cx.tcx(), tuple_type);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     UnfinishedMetadata {\n         cache_id: cache_id_for_type(tuple_type),\n@@ -1329,7 +1326,7 @@ impl GeneralMemberDescriptionFactory {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n             adt::General(_, ref struct_defs) => struct_defs,\n-            _ => cx.sess.bug(\"unreachable\")\n+            _ => cx.sess().bug(\"unreachable\")\n         };\n \n         struct_defs\n@@ -1396,9 +1393,9 @@ fn describe_enum_variant(cx: &CrateContext,\n                          span: Span)\n                       -> (DICompositeType, Type, MemberDescriptionFactory) {\n     let variant_llvm_type =\n-        Type::struct_(struct_def.fields\n-                                .map(|&t| type_of::type_of(cx, t))\n-                                .as_slice(),\n+        Type::struct_(cx, struct_def.fields\n+                                    .map(|&t| type_of::type_of(cx, t))\n+                                    .as_slice(),\n                       struct_def.packed);\n     // Could some consistency checks here: size, align, field count, discr type\n \n@@ -1451,17 +1448,17 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                          enum_def_id: ast::DefId,\n                          span: Span)\n                       -> RecursiveTypeDescription {\n-    let enum_name = ppaux::ty_to_str(cx.tcx, enum_type);\n+    let enum_name = ppaux::ty_to_str(cx.tcx(), enum_type);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n-    if ty::type_is_empty(cx.tcx, enum_type) {\n+    if ty::type_is_empty(cx.tcx(), enum_type) {\n         let empty_type_metadata = composite_type_metadata(cx,\n-                                                          Type::nil(),\n+                                                          Type::nil(cx),\n                                                           enum_name,\n                                                           [],\n                                                           containing_scope,\n@@ -1471,7 +1468,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         return FinalMetadata(empty_type_metadata);\n     }\n \n-    let variants = ty::enum_variants(cx.tcx, enum_def_id);\n+    let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n@@ -1653,9 +1650,9 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n         if composite_types_completed.get().contains(&composite_type_metadata) {\n-            cx.sess.span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - \\\n-                                               Already completed forward declaration \\\n-                                               re-encountered.\");\n+            cx.sess().span_bug(definition_span, \"debuginfo::set_members_of_composite_type() - \\\n+                                                 Already completed forward declaration \\\n+                                                 re-encountered.\");\n         } else {\n             composite_types_completed.get().insert(composite_type_metadata);\n         }\n@@ -1757,7 +1754,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n                                   content_llvm_type));\n \n     let int_type = ty::mk_int();\n-    let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n+    let nil_pointer_type = ty::mk_nil_ptr(cx.tcx());\n     let nil_pointer_type_metadata = type_metadata(cx, nil_pointer_type, codemap::DUMMY_SP);\n \n     let member_descriptions = [\n@@ -1794,7 +1791,7 @@ fn boxed_type_metadata(cx: &CrateContext,\n     ];\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     return composite_type_metadata(\n         cx,\n@@ -1814,8 +1811,8 @@ fn boxed_type_metadata(cx: &CrateContext,\n         member_llvm_types.len() == 5 &&\n         member_llvm_types[0] == cx.int_type &&\n         member_llvm_types[1] == Type::generic_glue_fn(cx).ptr_to() &&\n-        member_llvm_types[2] == Type::i8().ptr_to() &&\n-        member_llvm_types[3] == Type::i8().ptr_to() &&\n+        member_llvm_types[2] == Type::i8(cx).ptr_to() &&\n+        member_llvm_types[3] == Type::i8(cx).ptr_to() &&\n         member_llvm_types[4] == content_llvm_type\n     }\n }\n@@ -1856,8 +1853,8 @@ fn vec_metadata(cx: &CrateContext,\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let (element_size, element_align) = size_and_align_of(cx, element_llvm_type);\n \n-    let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n-    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx, element_type));\n+    let vec_llvm_type = Type::vec(cx, &element_llvm_type);\n+    let vec_type_name: &str = format!(\"[{}]\", ppaux::ty_to_str(cx.tcx(), element_type));\n \n     let member_llvm_types = vec_llvm_type.field_types();\n \n@@ -1895,16 +1892,16 @@ fn vec_metadata(cx: &CrateContext,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n-    return composite_type_metadata(\n+    composite_type_metadata(\n         cx,\n         vec_llvm_type,\n         vec_type_name,\n         member_descriptions,\n         file_metadata,\n         file_metadata,\n-        span);\n+        span)\n }\n \n fn vec_slice_metadata(cx: &CrateContext,\n@@ -1916,14 +1913,17 @@ fn vec_slice_metadata(cx: &CrateContext,\n     debug!(\"vec_slice_metadata: {:?}\", ty::get(vec_type));\n \n     let slice_llvm_type = type_of::type_of(cx, vec_type);\n-    let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n+    let slice_type_name = ppaux::ty_to_str(cx.tcx(), vec_type);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n                                     member_llvm_types.as_slice(),\n                                     element_type));\n \n-    let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::MutImmutable });\n+    let data_ptr_type = ty::mk_ptr(cx.tcx(), ty::mt {\n+        ty: element_type,\n+        mutbl: ast::MutImmutable\n+    });\n \n     let member_descriptions = [\n         MemberDescription {\n@@ -1943,7 +1943,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     return composite_type_metadata(\n         cx,\n@@ -1969,7 +1969,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n                             span: Span)\n                          -> DICompositeType {\n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n+    let file_metadata = file_metadata(cx, loc.file.deref().name);\n \n     let mut signature_metadata: Vec<DIType> =\n         Vec::with_capacity(signature.inputs.len() + 1);\n@@ -2004,18 +2004,18 @@ fn trait_metadata(cx: &CrateContext,\n     // The implementation provided here is a stub. It makes sure that the trait type is\n     // assigned the correct name, size, namespace, and source location. But it does not describe\n     // the trait's methods.\n-    let last = ty::with_path(cx.tcx, def_id, |mut path| path.last().unwrap());\n+    let last = ty::with_path(cx.tcx(), def_id, |mut path| path.last().unwrap());\n     let ident_string = token::get_name(last.name());\n-    let name = ppaux::trait_store_to_str(cx.tcx, trait_store) +\n+    let name = ppaux::trait_store_to_str(cx.tcx(), trait_store) +\n                ppaux::mutability_to_str(mutability) +\n                ident_string.get();\n     // Add type and region parameters\n-    let name = ppaux::parameterized(cx.tcx, name, &substs.regions,\n+    let name = ppaux::parameterized(cx.tcx(), name, &substs.regions,\n                                     substs.tps.as_slice(), def_id, true);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n-    let file_name = span_start(cx, definition_span).file.name.clone();\n+    let file_name = span_start(cx, definition_span).file.deref().name.clone();\n     let file_metadata = file_metadata(cx, file_name);\n \n     let trait_llvm_type = type_of::type_of(cx, trait_type);\n@@ -2047,7 +2047,7 @@ fn type_metadata(cx: &CrateContext,\n                                       pointer_type: ty::t,\n                                       type_in_box: ty::t)\n                                    -> DIType {\n-        let content_type_name: &str = ppaux::ty_to_str(cx.tcx, type_in_box);\n+        let content_type_name: &str = ppaux::ty_to_str(cx.tcx(), type_in_box);\n         let content_llvm_type = type_of::type_of(cx, type_in_box);\n         let content_type_metadata = type_metadata(\n             cx,\n@@ -2130,9 +2130,9 @@ fn type_metadata(cx: &CrateContext,\n             trait_metadata(cx, def_id, t, substs, trait_store, mutability, bounds)\n         },\n         ty::ty_struct(def_id, ref substs) => {\n-            if ty::type_is_simd(cx.tcx, t) {\n-                let element_type = ty::simd_type(cx.tcx, t);\n-                let len = ty::simd_size(cx.tcx, t);\n+            if ty::type_is_simd(cx.tcx(), t) {\n+                let element_type = ty::simd_type(cx.tcx(), t);\n+                let len = ty::simd_size(cx.tcx(), t);\n                 fixed_vec_metadata(cx, element_type, len, usage_site_span)\n             } else {\n                 prepare_struct_metadata(cx, t, def_id, substs, usage_site_span).finalize(cx)\n@@ -2144,7 +2144,7 @@ fn type_metadata(cx: &CrateContext,\n                                    elements.as_slice(),\n                                    usage_site_span).finalize(cx)\n         }\n-        _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n+        _ => cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };\n \n     let mut created_types = debug_context(cx).created_types.borrow_mut();\n@@ -2179,7 +2179,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n         KnownLocation { scope, line, .. } => {\n             let col = 0; // Always set the column to zero like Clang and GCC\n             debug!(\"setting debug location to {} {}\", line, col);\n-            let elements = [C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n+            let elements = [C_i32(cx, line as i32), C_i32(cx, col as i32), scope, ptr::null()];\n             unsafe {\n                 metadata_node = llvm::LLVMMDNodeInContext(debug_context(cx).llcontext,\n                                                           elements.as_ptr(),\n@@ -2218,7 +2218,7 @@ fn generate_unique_type_id(prefix: &'static str) -> ~str {\n \n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n-    cx.sess.codemap.lookup_char_pos(span.lo)\n+    cx.sess().codemap().lookup_char_pos(span.lo)\n }\n \n fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (u64, u64) {\n@@ -2250,7 +2250,7 @@ fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span: Span) {\n     let node_types = cx.tcx.node_types.borrow();\n     if !node_types.get().contains_key(&(node_id as uint)) {\n-        cx.sess.span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n+        cx.sess().span_bug(error_span, \"debuginfo: Could not find type for node id!\");\n     }\n }\n \n@@ -2315,8 +2315,8 @@ fn populate_scope_map(cx: &CrateContext,\n                                    &mut Vec<ScopeStackEntry> ,\n                                    &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n-        let loc = cx.sess.codemap.lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, loc.file.name);\n+        let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+        let file_metadata = file_metadata(cx, loc.file.deref().name);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -2338,7 +2338,7 @@ fn populate_scope_map(cx: &CrateContext,\n         }\n \n         if scope_stack.last().unwrap().scope_metadata != scope_metadata {\n-            cx.sess.span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n+            cx.sess().span_bug(scope_span, \"debuginfo: Inconsistency in scope management.\");\n         }\n \n         scope_stack.pop();\n@@ -2432,8 +2432,8 @@ fn populate_scope_map(cx: &CrateContext,\n \n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n-                        let loc = cx.sess.codemap.lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, loc.file.name);\n+                        let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                        let file_metadata = file_metadata(cx, loc.file.deref().name);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -2614,13 +2614,13 @@ fn populate_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprForLoop(_, _, _, _) => {\n-                cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n-                                            Found unexpanded for-loop.\");\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                              Found unexpanded for-loop.\");\n             }\n \n             ast::ExprMac(_) => {\n-                cx.sess.span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n-                                            Found unexpanded macro.\");\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                              Found unexpanded macro.\");\n             }\n \n             ast::ExprLoop(block, _) |\n@@ -2751,7 +2751,7 @@ impl NamespaceTreeNode {\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNode {\n-    ty::with_path(cx.tcx, def_id, |path| {\n+    ty::with_path(cx.tcx(), def_id, |path| {\n         // prepend crate name if not already present\n         let krate = if def_id.krate == ast::LOCAL_CRATE {\n             let crate_namespace_ident = token::str_to_ident(cx.link_meta.crateid.name);\n@@ -2827,7 +2827,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> @NamespaceTreeNo\n         match parent_node {\n             Some(node) => node,\n             None => {\n-                cx.sess.bug(format!(\"debuginfo::namespace_for_item(): \\\n+                cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n                     path too short for {:?}\", def_id));\n             }\n         }"}, {"sha": "a38322ef0dcb94ce8c48e4f216db7cc59a9611f8", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -523,7 +523,7 @@ fn trans_index<'a>(bcx: &'a Block<'a>,\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n     let expect = ccx.intrinsics.get_copy(&(\"llvm.expect.i1\"));\n-    let expected = Call(bcx, expect, [bounds_check, C_i1(false)], []);\n+    let expected = Call(bcx, expect, [bounds_check, C_i1(ccx, false)], []);\n     let bcx = with_cond(bcx, expected, |bcx| {\n             controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n         });\n@@ -548,7 +548,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n         ast::DefStatic(did, _) => {\n             let const_ty = expr_ty(bcx, ref_expr);\n \n-            fn get_did(ccx: @CrateContext, did: ast::DefId)\n+            fn get_did(ccx: &CrateContext, did: ast::DefId)\n                        -> ast::DefId {\n                 if did.krate != ast::LOCAL_CRATE {\n                     inline::maybe_instantiate_inline(ccx, did)\n@@ -581,7 +581,7 @@ fn trans_def<'a>(bcx: &'a Block<'a>,\n                     unsafe {\n                         let llty = type_of::type_of(bcx.ccx(), const_ty);\n                         let symbol = csearch::get_symbol(\n-                            bcx.ccx().sess.cstore,\n+                            &bcx.ccx().sess().cstore,\n                             did);\n                         let llval = symbol.with_c_str(|buf| {\n                                 llvm::LLVMAddGlobal(bcx.ccx().llmod,\n@@ -816,7 +816,6 @@ fn trans_def_dps_unadjusted<'a>(\n                             dest: Dest)\n                             -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n-    let ccx = bcx.ccx();\n \n     let lldest = match dest {\n         SaveIn(lldest) => lldest,\n@@ -825,7 +824,7 @@ fn trans_def_dps_unadjusted<'a>(\n \n     match def {\n         ast::DefVariant(tid, vid, _) => {\n-            let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n+            let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n             if variant_info.args.len() > 0u {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx, vid, ExprId(ref_expr.id));\n@@ -834,7 +833,7 @@ fn trans_def_dps_unadjusted<'a>(\n             } else {\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n-                let repr = adt::represent_type(ccx, ty);\n+                let repr = adt::represent_type(bcx.ccx(), ty);\n                 adt::trans_start_init(bcx, repr, lldest,\n                                       variant_info.disr_val);\n                 return bcx;\n@@ -843,8 +842,8 @@ fn trans_def_dps_unadjusted<'a>(\n         ast::DefStruct(_) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty::get(ty).sty {\n-                ty::ty_struct(did, _) if ty::has_dtor(ccx.tcx, did) => {\n-                    let repr = adt::represent_type(ccx, ty);\n+                ty::ty_struct(did, _) if ty::has_dtor(bcx.tcx(), did) => {\n+                    let repr = adt::represent_type(bcx.ccx(), ty);\n                     adt::trans_start_init(bcx, repr, lldest, 0);\n                 }\n                 _ => {}\n@@ -940,7 +939,7 @@ pub fn trans_local_var<'a>(bcx: &'a Block<'a>,\n     }\n }\n \n-pub fn with_field_tys<R>(tcx: ty::ctxt,\n+pub fn with_field_tys<R>(tcx: &ty::ctxt,\n                          ty: ty::t,\n                          node_id_opt: Option<ast::NodeId>,\n                          op: |ty::Disr, (&[ty::field])| -> R)\n@@ -1150,6 +1149,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n                    op: ast::UnOp,\n                    sub_expr: &ast::Expr)\n                    -> DatumBlock<'a, Expr> {\n+    let ccx = bcx.ccx();\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n@@ -1160,7 +1160,7 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n     // Otherwise, we should be in the RvalueDpsExpr path.\n     assert!(\n         op == ast::UnDeref ||\n-        !bcx.ccx().maps.method_map.borrow().get().contains_key(&method_call));\n+        !ccx.maps.method_map.borrow().get().contains_key(&method_call));\n \n     let un_ty = expr_ty(bcx, expr);\n \n@@ -1172,8 +1172,8 @@ fn trans_unary<'a>(bcx: &'a Block<'a>,\n                 let llcond = ICmp(bcx,\n                                   lib::llvm::IntEQ,\n                                   val,\n-                                  C_bool(false));\n-                Select(bcx, llcond, C_bool(true), C_bool(false))\n+                                  C_bool(ccx, false));\n+                Select(bcx, llcond, C_bool(ccx, true), C_bool(ccx, false))\n             } else {\n                 // Note: `Not` is bitwise, not suitable for logical not.\n                 Not(bcx, datum.to_llscalarish(bcx))\n@@ -1361,15 +1361,15 @@ fn trans_eager_binop<'a>(\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_bot(rhs_t) {\n-            C_bool(false)\n+            C_bool(bcx.ccx(), false)\n         } else {\n             if !ty::type_is_scalar(rhs_t) {\n                 bcx.tcx().sess.span_bug(binop_expr.span,\n                                         \"non-scalar comparison\");\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n-            ZExt(bcx, cmpr.val, Type::i8())\n+            ZExt(bcx, cmpr.val, Type::i8(bcx.ccx()))\n         }\n       }\n       _ => {\n@@ -1421,8 +1421,8 @@ fn trans_lazy_binop<'a>(\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, Type::bool(), [lhs, rhs], [past_lhs.llbb,\n-                                                   past_rhs.llbb]);\n+    let phi = Phi(join, Type::bool(bcx.ccx()), [lhs, rhs],\n+                  [past_lhs.llbb, past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }\n@@ -1612,22 +1612,22 @@ fn trans_imm_cast<'a>(bcx: &'a Block<'a>,\n                 bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n             let llexpr_ptr = datum.to_llref();\n             let lldiscrim_a =\n-                adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64()));\n+                adt::trans_get_discr(bcx, repr, llexpr_ptr, Some(Type::i64(ccx)));\n             match k_out {\n                 cast_integral => int_cast(bcx, ll_t_out,\n                                           val_ty(lldiscrim_a),\n                                           lldiscrim_a, true),\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n-                                          {} ({:?}) -> {} ({:?})\",\n-                                          t_in.repr(ccx.tcx), k_in,\n-                                          t_out.repr(ccx.tcx), k_out))\n+                _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n+                                            {} ({:?}) -> {} ({:?})\",\n+                                            t_in.repr(bcx.tcx()), k_in,\n+                                            t_out.repr(bcx.tcx()), k_out))\n             }\n         }\n-        _ => ccx.sess.bug(format!(\"translating unsupported cast: \\\n-                                  {} ({:?}) -> {} ({:?})\",\n-                                  t_in.repr(ccx.tcx), k_in,\n-                                  t_out.repr(ccx.tcx), k_out))\n+        _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n+                                    {} ({:?}) -> {} ({:?})\",\n+                                    t_in.repr(bcx.tcx()), k_in,\n+                                    t_out.repr(bcx.tcx()), k_out))\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -1665,7 +1665,6 @@ fn trans_assign_op<'a>(\n     return result_datum.store_to(bcx, dst_datum.val);\n }\n \n-\n fn auto_ref<'a>(bcx: &'a Block<'a>,\n                 datum: Datum<Expr>,\n                 expr: &ast::Expr)"}, {"sha": "fdc33666e8abb5b26a043d36464c65984bd4b915", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -75,23 +75,23 @@ struct LlvmSignature {\n \n pub fn llvm_calling_convention(ccx: &CrateContext,\n                                abis: AbiSet) -> Option<CallConv> {\n-    let os = ccx.sess.targ_cfg.os;\n-    let arch = ccx.sess.targ_cfg.arch;\n+    let os = ccx.sess().targ_cfg.os;\n+    let arch = ccx.sess().targ_cfg.arch;\n     abis.for_target(os, arch).map(|abi| {\n         match abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n-                ccx.sess.bug(format!(\"asked to register intrinsic fn\"));\n+                ccx.sess().bug(format!(\"asked to register intrinsic fn\"));\n             }\n \n             Rust => {\n                 // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n-                ccx.sess.unimpl(\n+                ccx.sess().unimpl(\n                     format!(\"foreign functions with Rust ABI\"));\n             }\n \n             // It's the ABI's job to select this, not us.\n-            System => ccx.sess.bug(\"system abi should be selected elsewhere\"),\n+            System => ccx.sess().bug(\"system abi should be selected elsewhere\"),\n \n             Stdcall => lib::llvm::X86StdcallCallConv,\n             Fastcall => lib::llvm::X86FastcallCallConv,\n@@ -132,9 +132,9 @@ pub fn llvm_linkage_by_name(name: &str) -> Option<Linkage> {\n     }\n }\n \n-pub fn register_static(ccx: @CrateContext,\n-                       foreign_item: @ast::ForeignItem) -> ValueRef {\n-    let ty = ty::node_id_to_type(ccx.tcx, foreign_item.id);\n+pub fn register_static(ccx: &CrateContext,\n+                       foreign_item: &ast::ForeignItem) -> ValueRef {\n+    let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n     let llty = type_of::type_of(ccx, ty);\n \n     // Treat the crate map static specially in order to\n@@ -145,7 +145,7 @@ pub fn register_static(ccx: @CrateContext,\n     // library then we've already declared the crate map\n     // so use that instead.\n     if attr::contains_name(foreign_item.attrs.as_slice(), \"crate_map\") {\n-        return if ccx.sess.building_library.get() {\n+        return if ccx.sess().building_library.get() {\n             let s = \"_rust_crate_map_toplevel\";\n             let g = unsafe {\n                 s.with_c_str(|buf| {\n@@ -171,15 +171,15 @@ pub fn register_static(ccx: @CrateContext,\n             let linkage = match llvm_linkage_by_name(name.get()) {\n                 Some(linkage) => linkage,\n                 None => {\n-                    ccx.sess.span_fatal(foreign_item.span,\n-                                        \"invalid linkage specified\");\n+                    ccx.sess().span_fatal(foreign_item.span,\n+                                          \"invalid linkage specified\");\n                 }\n             };\n             let llty2 = match ty::get(ty).sty {\n                 ty::ty_ptr(ref mt) => type_of::type_of(ccx, mt.ty),\n                 _ => {\n-                    ccx.sess.span_fatal(foreign_item.span,\n-                                        \"must have type `*T` or `*mut T`\");\n+                    ccx.sess().span_fatal(foreign_item.span,\n+                                          \"must have type `*T` or `*mut T`\");\n                 }\n             };\n             unsafe {\n@@ -205,8 +205,8 @@ pub fn register_static(ccx: @CrateContext,\n     }\n }\n \n-pub fn register_foreign_item_fn(ccx: @CrateContext, abis: AbiSet,\n-                                foreign_item: @ast::ForeignItem) -> ValueRef {\n+pub fn register_foreign_item_fn(ccx: &CrateContext, abis: AbiSet,\n+                                foreign_item: &ast::ForeignItem) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n      * Just adds a LLVM global.\n@@ -215,17 +215,17 @@ pub fn register_foreign_item_fn(ccx: @CrateContext, abis: AbiSet,\n     debug!(\"register_foreign_item_fn(abis={}, \\\n             path={}, \\\n             foreign_item.id={})\",\n-           abis.repr(ccx.tcx),\n+           abis.repr(ccx.tcx()),\n            ccx.tcx.map.path_to_str(foreign_item.id),\n            foreign_item.id);\n \n     let cc = match llvm_calling_convention(ccx, abis) {\n         Some(cc) => cc,\n         None => {\n-            ccx.sess.span_fatal(foreign_item.span,\n+            ccx.sess().span_fatal(foreign_item.span,\n                 format!(\"ABI `{}` has no suitable calling convention \\\n                       for target architecture\",\n-                      abis.user_string(ccx.tcx)));\n+                      abis.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -240,7 +240,7 @@ pub fn register_foreign_item_fn(ccx: @CrateContext, abis: AbiSet,\n     }\n \n     // Create the LLVM value for the C extern fn\n-    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n+    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n \n     let llfn;\n     {\n@@ -294,7 +294,7 @@ pub fn trans_native_call<'a>(\n \n     let (fn_abis, fn_sig) = match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n-        _ => ccx.sess.bug(\"trans_native_call called on non-function type\")\n+        _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n     let ret_def = !return_type_is_void(bcx.ccx(), fn_sig.output);\n@@ -383,10 +383,10 @@ pub fn trans_native_call<'a>(\n         Some(cc) => cc,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n-            ccx.sess.fatal(\n+            ccx.sess().fatal(\n                 format!(\"ABI string `{}` has no suitable ABI \\\n                         for target architecture\",\n-                        fn_abis.user_string(ccx.tcx)));\n+                        fn_abis.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -440,8 +440,8 @@ pub fn trans_native_call<'a>(\n             //   bitcasting to the struct type yields invalid cast errors.\n             let llscratch = base::alloca(bcx, llforeign_ret_ty, \"__cast\");\n             Store(bcx, llforeign_retval, llscratch);\n-            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8().ptr_to());\n-            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8().ptr_to());\n+            let llscratch_i8 = BitCast(bcx, llscratch, Type::i8(ccx).ptr_to());\n+            let llretptr_i8 = BitCast(bcx, llretptr, Type::i8(ccx).ptr_to());\n             let llrust_size = machine::llsize_of_store(ccx, llrust_ret_ty);\n             let llforeign_align = machine::llalign_of_min(ccx, llforeign_ret_ty);\n             let llrust_align = machine::llalign_of_min(ccx, llrust_ret_ty);\n@@ -455,7 +455,7 @@ pub fn trans_native_call<'a>(\n     return bcx;\n }\n \n-pub fn trans_foreign_mod(ccx: @CrateContext, foreign_mod: &ast::ForeignMod) {\n+pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n@@ -499,16 +499,16 @@ pub fn trans_foreign_mod(ccx: @CrateContext, foreign_mod: &ast::ForeignMod) {\n // inline the one into the other. Of course we could just generate the\n // correct code in the first place, but this is much simpler.\n \n-pub fn register_rust_fn_with_foreign_abi(ccx: @CrateContext,\n+pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                                          sp: Span,\n                                          sym: ~str,\n                                          node_id: ast::NodeId)\n                                          -> ValueRef {\n     let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n \n     let tys = foreign_types_for_id(ccx, node_id);\n-    let llfn_ty = lltype_for_fn_from_foreign_types(&tys);\n-    let t = ty::node_id_to_type(ccx.tcx, node_id);\n+    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n+    let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let (cconv, output) = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let c = llvm_calling_convention(ccx, fn_ty.abis);\n@@ -523,7 +523,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @CrateContext,\n     llfn\n }\n \n-pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n+pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n                                       decl: &ast::FnDecl,\n                                       body: &ast::Block,\n                                       attrs: &[ast::Attribute],\n@@ -540,14 +540,14 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n     }\n \n-    fn build_rust_fn(ccx: @CrateContext,\n+    fn build_rust_fn(ccx: &CrateContext,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      attrs: &[ast::Attribute],\n                      id: ast::NodeId)\n                      -> ValueRef {\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n-        let tcx = ccx.tcx;\n+        let tcx = ccx.tcx();\n         let t = ty::node_id_to_type(tcx, id);\n \n         let ps = ccx.tcx.map.with_path(id, |path| {\n@@ -563,10 +563,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                 f\n             }\n             _ => {\n-                ccx.sess.bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n-                                  expected a bare fn ty\",\n-                                  ccx.tcx.map.path_to_str(id),\n-                                  t.repr(tcx)));\n+                ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n+                                       expected a bare fn ty\",\n+                                       ccx.tcx.map.path_to_str(id),\n+                                       t.repr(tcx)));\n             }\n         };\n \n@@ -584,13 +584,13 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         llfn\n     }\n \n-    unsafe fn build_wrap_fn(ccx: @CrateContext,\n+    unsafe fn build_wrap_fn(ccx: &CrateContext,\n                             llrustfn: ValueRef,\n                             llwrapfn: ValueRef,\n                             tys: &ForeignTypes) {\n         let _icx = push_ctxt(\n             \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n-        let tcx = ccx.tcx;\n+        let tcx = ccx.tcx();\n \n         debug!(\"build_wrap_fn(llrustfn={}, llwrapfn={})\",\n                ccx.tn.val_to_str(llrustfn),\n@@ -824,7 +824,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n // This code is kind of a confused mess and needs to be reworked given\n // the massive simplifications that have occurred.\n \n-pub fn link_name(i: @ast::ForeignItem) -> InternedString {\n+pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n      match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n                                               \"link_name\") {\n         None => token::get_ident(i.ident),\n@@ -853,14 +853,14 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n \n fn foreign_types_for_id(ccx: &CrateContext,\n                         id: ast::NodeId) -> ForeignTypes {\n-    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx, id))\n+    foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx(), id))\n }\n \n fn foreign_types_for_fn_ty(ccx: &CrateContext,\n                            ty: ty::t) -> ForeignTypes {\n     let fn_sig = match ty::get(ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n-        _ => ccx.sess.bug(\"foreign_types_for_fn_ty called on non-function type\")\n+        _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let ret_def = !return_type_is_void(ccx, fn_sig.output);\n@@ -873,7 +873,7 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            llsig={} -> {}, \\\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n-           ty.repr(ccx.tcx),\n+           ty.repr(ccx.tcx()),\n            ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n            ccx.tn.type_to_str(llsig.llret_ty),\n            ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty).as_slice()),\n@@ -888,13 +888,13 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n     }\n }\n \n-fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n+fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> Type {\n     let mut llargument_tys = Vec::new();\n \n     let ret_ty = tys.fn_ty.ret_ty;\n     let llreturn_ty = if ret_ty.is_indirect() {\n         llargument_tys.push(ret_ty.ty.ptr_to());\n-        Type::void()\n+        Type::void(ccx)\n     } else {\n         match ret_ty.cast {\n             Some(ty) => ty,\n@@ -929,8 +929,7 @@ fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n }\n \n pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: ty::t) -> Type {\n-    let fn_types = foreign_types_for_fn_ty(ccx, ty);\n-    lltype_for_fn_from_foreign_types(&fn_types)\n+    lltype_for_fn_from_foreign_types(ccx, &foreign_types_for_fn_ty(ccx, ty))\n }\n \n fn add_argument_attributes(tys: &ForeignTypes,"}, {"sha": "3a1572559dd00664c26f14041976e4d6a789bc18", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -46,7 +46,7 @@ pub fn trans_free<'a>(cx: &'a Block<'a>, v: ValueRef) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", FreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p())],\n+        [PointerCast(cx, v, Type::i8p(cx.ccx()))],\n         Some(expr::Ignore)).bcx\n }\n \n@@ -55,7 +55,7 @@ pub fn trans_exchange_free<'a>(cx: &'a Block<'a>, v: ValueRef)\n     let _icx = push_ctxt(\"trans_exchange_free\");\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p())],\n+        [PointerCast(cx, v, Type::i8p(cx.ccx()))],\n         Some(expr::Ignore)).bcx\n }\n \n@@ -74,7 +74,7 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n }\n \n fn get_drop_glue_type(ccx: &CrateContext, t: ty::t) -> ty::t {\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n     if !ty::type_needs_drop(tcx, t) {\n         return ty::mk_i8();\n     }\n@@ -126,42 +126,36 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     drop_ty(bcx, vp, t)\n }\n \n-pub fn get_drop_glue(ccx: @CrateContext, t: ty::t) -> ValueRef {\n+pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     let t = get_drop_glue_type(ccx, t);\n-    {\n-        let drop_glues = ccx.drop_glues.borrow();\n-        match drop_glues.get().find(&t) {\n-            Some(&glue) => return glue,\n-            _ => { }\n-        }\n+    match ccx.drop_glues.borrow().get().find(&t) {\n+        Some(&glue) => return glue,\n+        _ => { }\n     }\n \n-    let llfnty = Type::glue_fn(type_of(ccx, t).ptr_to());\n+    let llfnty = Type::glue_fn(ccx, type_of(ccx, t).ptr_to());\n     let glue = declare_generic_glue(ccx, t, llfnty, \"drop\");\n \n-    {\n-        let mut drop_glues = ccx.drop_glues.borrow_mut();\n-        drop_glues.get().insert(t, glue);\n-    }\n+    ccx.drop_glues.borrow_mut().get().insert(t, glue);\n \n     make_generic_glue(ccx, t, glue, make_drop_glue, \"drop\");\n \n     glue\n }\n \n-pub fn lazily_emit_visit_glue(ccx: @CrateContext, ti: @tydesc_info) {\n+pub fn lazily_emit_visit_glue(ccx: &CrateContext, ti: @tydesc_info) {\n     let _icx = push_ctxt(\"lazily_emit_visit_glue\");\n \n-    let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n+    let llfnty = Type::glue_fn(ccx, type_of(ccx, ti.ty).ptr_to());\n \n     match ti.visit_glue.get() {\n         Some(_) => (),\n         None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!(\"+++ lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"visit\");\n             ti.visit_glue.set(Some(glue_fn));\n             make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n-            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!(\"--- lazily_emit_tydesc_glue VISIT {}\", ppaux::ty_to_str(ccx.tcx(), ti.ty));\n         }\n     }\n }\n@@ -173,7 +167,7 @@ pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n     // GC-based cleanup needs to the see that the roots are live.\n-    if bcx.unreachable.get() && !ccx.sess.no_landing_pads() { return; }\n+    if bcx.unreachable.get() && !ccx.sess().no_landing_pads() { return; }\n \n     let static_glue_fn = match static_ti {\n         None => None,\n@@ -185,7 +179,7 @@ pub fn call_visit_glue(bcx: &Block, v: ValueRef, tydesc: ValueRef,\n \n     // When static type info is available, avoid casting to a generic pointer.\n     let llrawptr = if static_glue_fn.is_none() {\n-        PointerCast(bcx, v, Type::i8p())\n+        PointerCast(bcx, v, Type::i8p(ccx))\n     } else {\n         v\n     };\n@@ -283,7 +277,6 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'a> {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n-    let ccx = bcx.ccx();\n     match ty::get(t).sty {\n         ty::ty_box(body_ty) => {\n             decr_refcnt_maybe_free(bcx, v0, body_ty)\n@@ -323,27 +316,27 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n             with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue)), |bcx| {\n                 let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n                 let dtor = Load(bcx, dtor_ptr);\n-                Call(bcx, dtor, [PointerCast(bcx, lluniquevalue, Type::i8p())], []);\n+                Call(bcx, dtor, [PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))], []);\n                 bcx\n             })\n         }\n         ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => {\n             let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);\n-            let env_ptr_ty = Type::at_box(ccx, Type::i8()).ptr_to();\n+            let env_ptr_ty = Type::at_box(bcx.ccx(), Type::i8(bcx.ccx())).ptr_to();\n             let env = PointerCast(bcx, env, env_ptr_ty);\n             with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n                 let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_tydesc]);\n                 let dtor = Load(bcx, dtor_ptr);\n                 let cdata = GEPi(bcx, env, [0u, abi::box_field_body]);\n-                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p())], []);\n+                Call(bcx, dtor, [PointerCast(bcx, cdata, Type::i8p(bcx.ccx()))], []);\n \n                 // Free the environment itself\n                 trans_exchange_free(bcx, env)\n             })\n         }\n         _ => {\n-            if ty::type_needs_drop(ccx.tcx, t) &&\n+            if ty::type_needs_drop(bcx.tcx(), t) &&\n                 ty::type_is_structural(t) {\n                 iter_structural_ty(bcx, v0, t, drop_ty)\n             } else {\n@@ -403,23 +396,23 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n \n     let llty = type_of(ccx, t);\n \n-    if ccx.sess.count_type_sizes() {\n+    if ccx.sess().count_type_sizes() {\n         println!(\"{}\\t{}\", llsize_of_real(ccx, llty),\n-                 ppaux::ty_to_str(ccx.tcx, t));\n+                 ppaux::ty_to_str(ccx.tcx(), t));\n     }\n \n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n-    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx, t), name);\n+    debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_str(ccx.tcx(), t), name);\n     let gvar = name.with_c_str(|buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type.to_ref(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type().to_ref(), buf)\n         }\n     });\n     note_unique_llvm_symbol(ccx, name);\n \n-    let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx, t));\n+    let ty_name = token::intern_and_get_ident(ppaux::ty_to_str(ccx.tcx(), t));\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     let inf = @tydesc_info {\n@@ -430,29 +423,29 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         name: ty_name,\n         visit_glue: Cell::new(None),\n     };\n-    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n+    debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx(), t));\n     return inf;\n }\n \n fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                         name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, ~\"glue_\" + name);\n-    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n+    debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx(), t));\n     let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty, ty::mk_nil());\n     note_unique_llvm_symbol(ccx, fn_nm);\n     return llfn;\n }\n \n-fn make_generic_glue(ccx: @CrateContext,\n+fn make_generic_glue(ccx: &CrateContext,\n                      t: ty::t,\n                      llfn: ValueRef,\n                      helper: <'a> |&'a Block<'a>, ValueRef, ty::t|\n                                   -> &'a Block<'a>,\n                      name: &str)\n                      -> ValueRef {\n     let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n+    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n     let arena = TypedArena::new();\n@@ -478,7 +471,7 @@ fn make_generic_glue(ccx: @CrateContext,\n     llfn\n }\n \n-pub fn emit_tydescs(ccx: @CrateContext) {\n+pub fn emit_tydescs(ccx: &CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs.set(true);\n@@ -511,7 +504,7 @@ pub fn emit_tydescs(ccx: @CrateContext) {\n               }\n             };\n \n-        let tydesc = C_named_struct(ccx.tydesc_type,\n+        let tydesc = C_named_struct(ccx.tydesc_type(),\n                                     [ti.size, // size\n                                      ti.align, // align\n                                      drop_glue, // drop_glue"}, {"sha": "ee810a652dc987587e0abc793eca2c90793c4344", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -19,7 +19,7 @@ use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr;\n \n-pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n+pub fn maybe_instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> ast::DefId {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n     {\n@@ -28,7 +28,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n             Some(&Some(node_id)) => {\n                 // Already inline\n                 debug!(\"maybe_instantiate_inline({}): already inline as node id {}\",\n-                       ty::item_path_str(ccx.tcx, fn_id), node_id);\n+                       ty::item_path_str(ccx.tcx(), fn_id), node_id);\n                 return local_def(node_id);\n             }\n             Some(&None) => {\n@@ -42,8 +42,8 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n \n     let csearch_result =\n         csearch::maybe_get_item_ast(\n-            ccx.tcx, fn_id,\n-            |a,b,c,d| astencode::decode_inlined_item(a, b, ccx.maps, c, d));\n+            ccx.tcx(), fn_id,\n+            |a,b,c,d| astencode::decode_inlined_item(a, b, &ccx.maps, c, d));\n     return match csearch_result {\n         csearch::not_found => {\n             let mut external = ccx.external.borrow_mut();\n@@ -104,8 +104,8 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n           let mut my_id = 0;\n           match item.node {\n             ast::ItemEnum(_, _) => {\n-              let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n-              let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n+              let vs_here = ty::enum_variants(ccx.tcx(), local_def(item.id));\n+              let vs_there = ty::enum_variants(ccx.tcx(), parent_id);\n               for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n                   if there.id == fn_id { my_id = here.id.node; }\n                   let mut external = ccx.external.borrow_mut();\n@@ -122,14 +122,14 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                 }\n               }\n             }\n-            _ => ccx.sess.bug(\"maybe_instantiate_inline: item has a \\\n-                               non-enum, non-struct parent\")\n+            _ => ccx.sess().bug(\"maybe_instantiate_inline: item has a \\\n+                                 non-enum, non-struct parent\")\n           }\n           trans_item(ccx, item);\n           local_def(my_id)\n         }\n         csearch::found_parent(_, _) => {\n-            ccx.sess.bug(\"maybe_get_item_ast returned a found_parent \\\n+            ccx.sess().bug(\"maybe_get_item_ast returned a found_parent \\\n              with a non-item parent\");\n         }\n         csearch::found(ast::IIMethod(impl_did, is_provided, mth)) => {\n@@ -146,7 +146,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n           // impl type. But we aren't going to translate anyways, so don't.\n           if is_provided { return local_def(mth.id); }\n \n-            let impl_tpt = ty::lookup_item_type(ccx.tcx, impl_did);\n+            let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n             let num_type_params =\n                 impl_tpt.generics.type_param_defs().len() +\n                 mth.generics.ty_params.len();"}, {"sha": "98e63641c12fbfa0834b440d01e89c1036cb58dc", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -31,7 +31,7 @@ use syntax::ast_map;\n use syntax::parse::token;\n use util::ppaux::ty_to_str;\n \n-pub fn get_simple_intrinsic(ccx: @CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n+pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n     let name = match token::get_ident(item.ident).get() {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n@@ -83,7 +83,7 @@ pub fn get_simple_intrinsic(ccx: @CrateContext, item: &ast::ForeignItem) -> Opti\n     Some(ccx.intrinsics.get_copy(&name))\n }\n \n-pub fn trans_intrinsic(ccx: @CrateContext,\n+pub fn trans_intrinsic(ccx: &CrateContext,\n                        decl: ValueRef,\n                        item: &ast::ForeignItem,\n                        substs: @param_substs,\n@@ -99,7 +99,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         // convert `i1` to a `bool`, and write to the out parameter\n         let val = Call(bcx, llfn, [a, b], []);\n         let result = ExtractValue(bcx, val, 0);\n-        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool());\n+        let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n         let ret = C_undef(type_of::type_of(bcx.ccx(), t));\n         let ret = InsertValue(bcx, ret, result, 0);\n         let ret = InsertValue(bcx, ret, overflow, 1);\n@@ -133,7 +133,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n     fn copy_intrinsic(bcx: &Block, allow_overlap: bool, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n         let size = machine::llsize_of(ccx, lltp_ty);\n         let int_size = machine::llbitsize_of_real(ccx, ccx.int_type);\n         let name = if allow_overlap {\n@@ -152,19 +152,19 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n \n         let decl = bcx.fcx.llfn;\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p(ccx));\n+        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p(ccx));\n         let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        let volatile = C_i1(ccx, false);\n+        let llfn = ccx.intrinsics.get_copy(&name);\n         Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n \n     fn memset_intrinsic(bcx: &Block, tp_ty: ty::t) {\n         let ccx = bcx.ccx();\n         let lltp_ty = type_of::type_of(ccx, tp_ty);\n-        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let align = C_i32(ccx, machine::llalign_of_min(ccx, lltp_ty) as i32);\n         let size = machine::llsize_of(ccx, lltp_ty);\n         let name = if machine::llbitsize_of_real(ccx, ccx.int_type) == 32 {\n             \"llvm.memset.p0i8.i32\"\n@@ -174,24 +174,24 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n \n         let decl = bcx.fcx.llfn;\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n-        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p(ccx));\n         let val = get_param(decl, first_real_arg + 1);\n         let count = get_param(decl, first_real_arg + 2);\n-        let volatile = C_i1(false);\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        let volatile = C_i1(ccx, false);\n+        let llfn = ccx.intrinsics.get_copy(&name);\n         Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile], []);\n         RetVoid(bcx);\n     }\n \n     fn count_zeros_intrinsic(bcx: &Block, name: &'static str) {\n         let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n-        let y = C_i1(false);\n+        let y = C_i1(bcx.ccx(), false);\n         let llfn = bcx.ccx().intrinsics.get_copy(&name);\n         let llcall = Call(bcx, llfn, [x, y], []);\n         Ret(bcx, llcall);\n     }\n \n-    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx(), item.id));\n \n     let arena = TypedArena::new();\n     let fcx = new_fn_ctxt(ccx, decl, item.id, false, output_type,\n@@ -218,7 +218,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 \"acq\"     => lib::llvm::Acquire,\n                 \"rel\"     => lib::llvm::Release,\n                 \"acqrel\"  => lib::llvm::AcquireRelease,\n-                _ => ccx.sess.fatal(\"unknown ordering in atomic intrinsic\")\n+                _ => ccx.sess().fatal(\"unknown ordering in atomic intrinsic\")\n             }\n         };\n \n@@ -259,7 +259,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                     \"min\"   => lib::llvm::Min,\n                     \"umax\"  => lib::llvm::UMax,\n                     \"umin\"  => lib::llvm::UMin,\n-                    _ => ccx.sess.fatal(\"unknown atomic operation\")\n+                    _ => ccx.sess().fatal(\"unknown atomic operation\")\n                 };\n \n                 let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n@@ -328,12 +328,13 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         }\n         \"type_id\" => {\n             let hash = ty::hash_crate_independent(\n-                ccx.tcx,\n+                ccx.tcx(),\n                 *substs.tys.get(0),\n                 &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n-            let val = C_named_struct(type_of::type_of(ccx, output_type), [C_u64(hash)]);\n+            let val = C_named_struct(type_of::type_of(ccx, output_type),\n+                                     [C_u64(ccx, hash)]);\n             match bcx.fcx.llretptr.get() {\n                 Some(ptr) => {\n                     Store(bcx, val, ptr);\n@@ -377,13 +378,13 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                     ast_map::NodeExpr(e) => e.span,\n                     _ => fail!(\"transmute has non-expr arg\"),\n                 };\n-                ccx.sess.span_fatal(sp,\n+                ccx.sess().span_fatal(sp,\n                     format!(\"transmute called on types with different sizes: \\\n                              {intype} ({insize, plural, =1{# bit} other{# bits}}) to \\\n                              {outtype} ({outsize, plural, =1{# bit} other{# bits}})\",\n-                            intype = ty_to_str(ccx.tcx, in_type),\n+                            intype = ty_to_str(ccx.tcx(), in_type),\n                             insize = in_type_size as uint,\n-                            outtype = ty_to_str(ccx.tcx, out_type),\n+                            outtype = ty_to_str(ccx.tcx(), out_type),\n                             outsize = out_type_size as uint));\n             }\n \n@@ -421,8 +422,8 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                     // code bloat when `transmute` is used on large structural\n                     // types.\n                     let lldestptr = fcx.llretptr.get().unwrap();\n-                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n-                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n+                    let lldestptr = PointerCast(bcx, lldestptr, Type::i8p(ccx));\n+                    let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p(ccx));\n \n                     let llsize = llsize_of(ccx, llintype);\n                     call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n@@ -434,16 +435,16 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         }\n         \"needs_drop\" => {\n             let tp_ty = *substs.tys.get(0);\n-            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n+            Ret(bcx, C_bool(ccx, ty::type_needs_drop(ccx.tcx(), tp_ty)));\n         }\n         \"owns_managed\" => {\n             let tp_ty = *substs.tys.get(0);\n-            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).owns_managed()));\n+            Ret(bcx, C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed()));\n         }\n         \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);\n-            let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n+            let td = PointerCast(bcx, td, ccx.tydesc_type().ptr_to());\n             glue::call_visit_glue(bcx, visitor, td, None);\n             RetVoid(bcx);\n         }\n@@ -527,7 +528,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?\n-            ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n+            ccx.sess().span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n     fcx.cleanup();"}, {"sha": "cd33bcf6031d18fe5d691c3d8b1f9e38ba559766", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -45,13 +45,13 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-pub fn trans_impl(ccx: @CrateContext,\n+pub fn trans_impl(ccx: &CrateContext,\n                   name: ast::Ident,\n                   methods: &[@ast::Method],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n     let _icx = push_ctxt(\"meth::trans_impl\");\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     debug!(\"trans_impl(name={}, id={:?})\", name.repr(tcx), id);\n \n@@ -84,7 +84,7 @@ pub fn trans_impl(ccx: @CrateContext,\n ///   type parameters and so forth, else None\n /// * `llfn`: the LLVM ValueRef for the method\n ///\n-pub fn trans_method(ccx: @CrateContext, method: &ast::Method,\n+pub fn trans_method(ccx: &CrateContext, method: &ast::Method,\n                     param_substs: Option<@param_substs>,\n                     llfn: ValueRef) -> ValueRef {\n     trans_fn(ccx, method.decl, method.body,\n@@ -108,8 +108,8 @@ pub fn trans_method_callee<'a>(\n             (method.origin, method.ty)\n         }\n         None => {\n-            bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                    \"method call expr wasn't in method map\")\n+            bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                \"method call expr wasn't in method map\")\n         }\n     };\n \n@@ -145,9 +145,9 @@ pub fn trans_method_callee<'a>(\n             let self_expr = match self_expr {\n                 Some(self_expr) => self_expr,\n                 None => {\n-                    bcx.tcx().sess.span_bug(bcx.tcx().map.span(method_call.expr_id),\n-                                            \"self expr wasn't provided for trait object \\\n-                                            callee (trying to call overloaded op?)\")\n+                    bcx.sess().span_bug(bcx.tcx().map.span(method_call.expr_id),\n+                                        \"self expr wasn't provided for trait object \\\n+                                         callee (trying to call overloaded op?)\")\n                 }\n             };\n             trans_trait_callee(bcx,\n@@ -270,7 +270,7 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n     match vtbl {\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n-          let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n+          let mname = ty::trait_method(ccx.tcx(), trait_id, n_method).ident;\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n           // create a concatenated set of substitutions which includes\n@@ -319,16 +319,16 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     * mapped to. */\n \n     let ccx = bcx.ccx();\n-    let method = ty::method(ccx.tcx, mth_did);\n+    let method = ty::method(ccx.tcx(), mth_did);\n     let n_m_tps = method.generics.type_param_defs().len();\n     let node_substs = node_id_type_params(bcx, node);\n-    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n+    debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx()));\n     let ty_substs\n         = vec_ng::append(Vec::from_slice(rcvr_substs),\n                          node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps={:?}\", n_m_tps);\n-    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n-    debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n+    debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx()));\n+    debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx()));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -415,7 +415,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     debug!(\"(translating trait callee) loading second index from pair\");\n     let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n-    let llself = PointerCast(bcx, llbox, Type::i8p());\n+    let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n@@ -425,14 +425,14 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n             type_of_rust_fn(ccx, true, f.sig.inputs.slice_from(1), f.sig.output)\n         }\n         _ => {\n-            ccx.sess.bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n+            ccx.sess().bug(\"meth::trans_trait_callee given non-bare-rust-fn\");\n         }\n     };\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n                                     GEPi(bcx, llpair,\n                                          [0u, abi::trt_field_vtable]),\n-                                    Type::vtable().ptr_to().ptr_to()));\n+                                    Type::vtable(ccx).ptr_to().ptr_to()));\n     let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + 1]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n@@ -445,7 +445,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     };\n }\n \n-pub fn vtable_id(ccx: @CrateContext,\n+pub fn vtable_id(ccx: &CrateContext,\n                  origin: &typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n@@ -500,7 +500,7 @@ pub fn get_vtable(bcx: &Block,\n                     methods.push(vtable_method)\n                 }\n             }\n-            _ => ccx.sess.bug(\"get_vtable: expected a static origin\"),\n+            _ => ccx.sess().bug(\"get_vtable: expected a static origin\"),\n         }\n     }\n \n@@ -526,7 +526,7 @@ pub fn make_vtable(ccx: &CrateContext,\n             components.push(ptr)\n         }\n \n-        let tbl = C_struct(components.as_slice(), false);\n+        let tbl = C_struct(ccx, components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n@@ -544,12 +544,12 @@ fn emit_vtable_methods(bcx: &Block,\n                        vtables: typeck::vtable_res)\n                        -> Vec<ValueRef> {\n     let ccx = bcx.ccx();\n-    let tcx = ccx.tcx;\n+    let tcx = ccx.tcx();\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n         Some(t_id) => t_id.def_id,\n-        None       => ccx.sess.bug(\"make_impl_vtable: don't know how to \\\n-                                    make a vtable for a type impl!\")\n+        None       => ccx.sess().bug(\"make_impl_vtable: don't know how to \\\n+                                      make a vtable for a type impl!\")\n     };\n \n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n@@ -568,7 +568,7 @@ fn emit_vtable_methods(bcx: &Block,\n            ty::type_has_self(ty::mk_bare_fn(tcx, m.fty.clone())) {\n             debug!(\"(making impl vtable) method has self or type params: {}\",\n                    token::get_ident(ident));\n-            C_null(Type::nil().ptr_to())\n+            C_null(Type::nil(ccx).ptr_to())\n         } else {\n             trans_fn_ref_with_vtables(bcx, m_id, ExprId(0), substs, Some(vtables))\n         }"}, {"sha": "0d9b6a087f947f79c5c6392e6f4dba73dc3242f3", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -28,7 +28,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n \n-pub fn monomorphic_fn(ccx: @CrateContext,\n+pub fn monomorphic_fn(ccx: &CrateContext,\n                       fn_id: ast::DefId,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n@@ -41,10 +41,10 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             vtables={}, \\\n             self_vtable={}, \\\n             ref_id={:?})\",\n-           fn_id.repr(ccx.tcx),\n-           real_substs.repr(ccx.tcx),\n-           vtables.repr(ccx.tcx),\n-           self_vtables.repr(ccx.tcx),\n+           fn_id.repr(ccx.tcx()),\n+           real_substs.repr(ccx.tcx()),\n+           vtables.repr(ccx.tcx()),\n+           self_vtables.repr(ccx.tcx()),\n            ref_id);\n \n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n@@ -71,31 +71,31 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             fn_id={}, \\\n             psubsts={}, \\\n             hash_id={:?})\",\n-           fn_id.repr(ccx.tcx),\n-           psubsts.repr(ccx.tcx),\n+           fn_id.repr(ccx.tcx()),\n+           psubsts.repr(ccx.tcx()),\n            hash_id);\n \n     {\n         let monomorphized = ccx.monomorphized.borrow();\n         match monomorphized.get().find(&hash_id) {\n           Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n-                   ty::item_path_str(ccx.tcx, fn_id));\n+                   ty::item_path_str(ccx.tcx(), fn_id));\n             return (val, must_cast);\n           }\n           None => ()\n         }\n     }\n \n-    let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n+    let tpt = ty::lookup_item_type(ccx.tcx(), fn_id);\n     let llitem_ty = tpt.ty;\n \n     // We need to do special handling of the substitutions if we are\n     // calling a static provided method. This is sort of unfortunate.\n     let mut is_static_provided = None;\n \n     let map_node = session::expect(\n-        ccx.sess,\n+        ccx.sess(),\n         ccx.tcx.map.find(fn_id.node),\n         || format!(\"while monomorphizing {:?}, couldn't find it in the \\\n                     item map (may have attempted to monomorphize an item \\\n@@ -123,9 +123,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         _ => {}\n     }\n \n-    debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n+    debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx()));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst_tps(ccx.tcx, psubsts.tys.as_slice(),\n+        None => ty::subst_tps(ccx.tcx(), psubsts.tys.as_slice(),\n                               psubsts.self_ty, llitem_ty),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n@@ -146,9 +146,9 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             let substs = psubsts.tys.slice(0, idx) +\n                 &[psubsts.self_ty.unwrap()] + psubsts.tys.tailn(idx);\n             debug!(\"static default: changed substitution to {}\",\n-                   substs.repr(ccx.tcx));\n+                   substs.repr(ccx.tcx()));\n \n-            ty::subst_tps(ccx.tcx, substs, None, llitem_ty)\n+            ty::subst_tps(ccx.tcx(), substs, None, llitem_ty)\n         }\n     };\n \n@@ -172,8 +172,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         // Random cut-off -- code that needs to instantiate the same function\n         // recursively more than thirty times can probably safely be assumed\n         // to be causing an infinite expansion.\n-        if depth > ccx.sess.recursion_limit.get() {\n-            ccx.sess.span_fatal(ccx.tcx.map.span(fn_id.node),\n+        if depth > ccx.sess().recursion_limit.get() {\n+            ccx.sess().span_fatal(ccx.tcx.map.span(fn_id.node),\n                 \"reached the recursion limit during monomorphization\");\n         }\n \n@@ -207,7 +207,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                   d\n               }\n               _ => {\n-                ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n+                ccx.sess().bug(\"Can't monomorphize this kind of item\")\n               }\n             }\n         }\n@@ -224,7 +224,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         }\n         ast_map::NodeVariant(v) => {\n             let parent = ccx.tcx.map.get_parent(fn_id.node);\n-            let tvs = ty::enum_variants(ccx.tcx, local_def(parent));\n+            let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n             let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl();\n             set_inline_hint(d);\n@@ -239,7 +239,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                                        d);\n                 }\n                 ast::StructVariantKind(_) =>\n-                    ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n+                    ccx.sess().bug(\"can't monomorphize struct variants\"),\n             }\n             d\n         }\n@@ -258,8 +258,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                     d\n                 }\n                 _ => {\n-                    ccx.tcx.sess.bug(format!(\"can't monomorphize a {:?}\",\n-                                             map_node))\n+                    ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n+                                           map_node))\n                 }\n             }\n         }\n@@ -281,7 +281,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         ast_map::NodeArg(..) |\n         ast_map::NodeBlock(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.tcx.sess.bug(format!(\"can't monomorphize a {:?}\", map_node))\n+            ccx.sess().bug(format!(\"can't monomorphize a {:?}\", map_node))\n         }\n     };\n \n@@ -290,11 +290,11 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         monomorphizing.get().insert(fn_id, depth);\n     }\n \n-    debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx, fn_id));\n+    debug!(\"leaving monomorphic fn {}\", ty::item_path_str(ccx.tcx(), fn_id));\n     (lldecl, must_cast)\n }\n \n-pub fn make_mono_id(ccx: @CrateContext,\n+pub fn make_mono_id(ccx: &CrateContext,\n                     item: ast::DefId,\n                     substs: &param_substs) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get\n@@ -303,7 +303,7 @@ pub fn make_mono_id(ccx: @CrateContext,\n     let precise_param_ids: Vec<(ty::t, Option<@Vec<mono_id> >)> = match substs.vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables={} substs={}\",\n-               vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n+               vts.repr(ccx.tcx()), substs.tys.repr(ccx.tcx()));\n         let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n         vts_iter.zip(substs_iter).map(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));"}, {"sha": "397361b83e06add12eae033f7f4df6314afe548b", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -54,7 +54,7 @@ impl<'a> Reflector<'a> {\n     }\n \n     pub fn c_bool(&mut self, b: bool) -> ValueRef {\n-        C_bool(b)\n+        C_bool(self.bcx.ccx(), b)\n     }\n \n     pub fn c_slice(&mut self, s: InternedString) -> ValueRef {\n@@ -65,7 +65,7 @@ impl<'a> Reflector<'a> {\n         let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = rvalue_scratch_datum(bcx, str_ty, \"\");\n         let len = C_uint(bcx.ccx(), s.get().len());\n-        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n+        let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p(bcx.ccx()));\n         Store(bcx, c_str, GEPi(bcx, scratch.val, [ 0, 0 ]));\n         Store(bcx, len, GEPi(bcx, scratch.val, [ 0, 1 ]));\n         scratch.val\n@@ -151,8 +151,8 @@ impl<'a> Reflector<'a> {\n     // Entrypoint\n     pub fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n-        let tcx = bcx.ccx().tcx;\n-        debug!(\"reflect::visit_ty {}\", ty_to_str(bcx.ccx().tcx, t));\n+        let tcx = bcx.tcx();\n+        debug!(\"reflect::visit_ty {}\", ty_to_str(bcx.tcx(), t));\n \n         match ty::get(t).sty {\n           ty::ty_bot => self.leaf(\"bot\"),\n@@ -285,10 +285,10 @@ impl<'a> Reflector<'a> {\n           ty::ty_enum(did, ref substs) => {\n             let ccx = bcx.ccx();\n             let repr = adt::represent_type(bcx.ccx(), t);\n-            let variants = ty::substd_enum_variants(ccx.tcx, did, substs);\n+            let variants = ty::substd_enum_variants(ccx.tcx(), did, substs);\n             let llptrty = type_of(ccx, t).ptr_to();\n-            let opaquety = ty::get_opaque_ty(ccx.tcx).unwrap();\n-            let opaqueptrty = ty::mk_ptr(ccx.tcx, ty::mt { ty: opaquety,\n+            let opaquety = ty::get_opaque_ty(ccx.tcx()).unwrap();\n+            let opaqueptrty = ty::mk_ptr(ccx.tcx(), ty::mt { ty: opaquety,\n                                                            mutbl: ast::MutImmutable });\n \n             let make_get_disr = || {\n@@ -311,7 +311,7 @@ impl<'a> Reflector<'a> {\n                 };\n                 let bcx = fcx.entry_bcx.get().unwrap();\n                 let arg = BitCast(bcx, arg, llptrty);\n-                let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64()));\n+                let ret = adt::trans_get_discr(bcx, repr, arg, Some(Type::i64(ccx)));\n                 Store(bcx, ret, fcx.llretptr.get().unwrap());\n                 match fcx.llreturn.get() {\n                     Some(llreturn) => Br(bcx, llreturn),\n@@ -328,23 +328,23 @@ impl<'a> Reflector<'a> {\n             self.bracketed(\"enum\", enum_args.as_slice(), |this| {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = token::get_ident(v.name);\n-                    let variant_args = vec!(this.c_uint(i),\n-                                         C_u64(v.disr_val),\n+                    let variant_args = [this.c_uint(i),\n+                                         C_u64(ccx, v.disr_val),\n                                          this.c_uint(v.args.len()),\n-                                         this.c_slice(name));\n+                                         this.c_slice(name)];\n                     this.bracketed(\"enum_variant\",\n-                                   variant_args.as_slice(),\n+                                   variant_args,\n                                    |this| {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n                             let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n                             let offset = p2i(ccx, ptr);\n-                            let field_args = vec!(this.c_uint(j),\n+                            let field_args = [this.c_uint(j),\n                                                offset,\n-                                               this.c_tydesc(*a));\n+                                               this.c_tydesc(*a)];\n                             this.visit(\"enum_variant_field\",\n-                                       field_args.as_slice());\n+                                       field_args);\n                         }\n                     })\n                 }\n@@ -393,7 +393,7 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n                                     -> &'a Block<'a> {\n     let fcx = bcx.fcx;\n     let final = fcx.new_temp_block(\"final\");\n-    let tydesc_ty = ty::get_tydesc_ty(bcx.ccx().tcx).unwrap();\n+    let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n     let mut r = Reflector {\n         visitor_val: visitor_val,"}, {"sha": "1a54c25e364080065351c57dbe33002f5b0539f0", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -38,7 +38,7 @@ use syntax::parse::token::InternedString;\n // containing an unboxed vector. This expands a boxed vector type into such an\n // expanded type. It doesn't respect mutability, but that doesn't matter at\n // this point.\n-pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+pub fn expand_boxed_vec_ty(tcx: &ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n@@ -71,7 +71,7 @@ pub fn get_dataptr(bcx: &Block, vptr: ValueRef) -> ValueRef {\n pub fn pointer_add_byte(bcx: &Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n-    let bptr = PointerCast(bcx, ptr, Type::i8p());\n+    let bptr = PointerCast(bcx, ptr, Type::i8p(bcx.ccx()));\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n@@ -154,8 +154,8 @@ impl VecTypes {\n     pub fn to_str(&self, ccx: &CrateContext) -> ~str {\n         format!(\"VecTypes \\\\{vec_ty={}, unit_ty={}, llunit_ty={}, llunit_size={}, \\\n                  llunit_alloc_size={}\\\\}\",\n-             ty_to_str(ccx.tcx, self.vec_ty),\n-             ty_to_str(ccx.tcx, self.unit_ty),\n+             ty_to_str(ccx.tcx(), self.vec_ty),\n+             ty_to_str(ccx.tcx(), self.unit_ty),\n              ccx.tn.type_to_str(self.llunit_ty),\n              ccx.tn.val_to_str(self.llunit_size),\n              self.llunit_alloc_size)\n@@ -290,7 +290,7 @@ pub fn trans_lit_str<'a>(\n                 let bytes = str_lit.get().len();\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit);\n-                let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p().to_ref());\n+                let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p(bcx.ccx()).to_ref());\n                 Store(bcx, llcstr,\n                       GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n                 Store(bcx, llbytes,\n@@ -322,7 +322,7 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n                     let llptrval = C_cstr(bcx.ccx(), (*s).clone());\n                     let llptrval = PointerCast(bcx,\n                                                llptrval,\n-                                               Type::i8p());\n+                                               Type::i8p(bcx.ccx()));\n                     let llsizeval = C_uint(bcx.ccx(), s.get().len());\n                     let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n                     let lldestval = rvalue_scratch_datum(bcx,\n@@ -441,7 +441,7 @@ pub fn write_content<'a>(\n                     return expr::trans_into(bcx, element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    let count = ty::eval_repeat_count(&bcx.tcx(), count_expr);\n+                    let count = ty::eval_repeat_count(bcx.tcx(), count_expr);\n                     if count == 0 {\n                         return bcx;\n                     }\n@@ -505,7 +505,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n         },\n         ast::ExprVec(ref es, _) => es.len(),\n         ast::ExprRepeat(_, count_expr, _) => {\n-            ty::eval_repeat_count(&bcx.tcx(), count_expr)\n+            ty::eval_repeat_count(bcx.tcx(), count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "bd1a7498d21866860fd8a445d08d3630162e6d5b", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 80, "deletions": 87, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -14,10 +14,9 @@ use lib::llvm::{llvm, TypeRef, Bool, False, True, TypeKind};\n use lib::llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use middle::trans::context::CrateContext;\n-use middle::trans::base;\n \n use syntax::ast;\n-use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n \n use std::c_str::ToCStr;\n use std::cast;\n@@ -51,100 +50,94 @@ impl Type {\n         self.rf\n     }\n \n-    pub fn void() -> Type {\n-        ty!(llvm::LLVMVoidTypeInContext(base::task_llcx()))\n+    pub fn void(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMVoidTypeInContext(ccx.llcx))\n     }\n \n-    pub fn nil() -> Type {\n-        Type::empty_struct()\n+    pub fn nil(ccx: &CrateContext) -> Type {\n+        Type::empty_struct(ccx)\n     }\n \n-    pub fn metadata() -> Type {\n-        ty!(llvm::LLVMMetadataTypeInContext(base::task_llcx()))\n+    pub fn metadata(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMMetadataTypeInContext(ccx.llcx))\n     }\n \n-    pub fn i1() -> Type {\n-        ty!(llvm::LLVMInt1TypeInContext(base::task_llcx()))\n+    pub fn i1(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt1TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i8() -> Type {\n-        ty!(llvm::LLVMInt8TypeInContext(base::task_llcx()))\n+    pub fn i8(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i16() -> Type {\n-        ty!(llvm::LLVMInt16TypeInContext(base::task_llcx()))\n+    pub fn i16(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt16TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i32() -> Type {\n-        ty!(llvm::LLVMInt32TypeInContext(base::task_llcx()))\n+    pub fn i32(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt32TypeInContext(ccx.llcx))\n     }\n \n-    pub fn i64() -> Type {\n-        ty!(llvm::LLVMInt64TypeInContext(base::task_llcx()))\n+    pub fn i64(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMInt64TypeInContext(ccx.llcx))\n     }\n \n-    pub fn f32() -> Type {\n-        ty!(llvm::LLVMFloatTypeInContext(base::task_llcx()))\n+    pub fn f32(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMFloatTypeInContext(ccx.llcx))\n     }\n \n-    pub fn f64() -> Type {\n-        ty!(llvm::LLVMDoubleTypeInContext(base::task_llcx()))\n+    pub fn f64(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMDoubleTypeInContext(ccx.llcx))\n     }\n \n-    pub fn bool() -> Type {\n-        Type::i8()\n+    pub fn bool(ccx: &CrateContext) -> Type {\n+        Type::i8(ccx)\n     }\n \n-    pub fn char() -> Type {\n-        Type::i32()\n+    pub fn char(ccx: &CrateContext) -> Type {\n+        Type::i32(ccx)\n     }\n \n-    pub fn i8p() -> Type {\n-        Type::i8().ptr_to()\n+    pub fn i8p(ccx: &CrateContext) -> Type {\n+        Type::i8(ccx).ptr_to()\n     }\n \n-    pub fn int(arch: Architecture) -> Type {\n-        match arch {\n-            X86 | Arm | Mips => Type::i32(),\n-            X86_64 => Type::i64()\n+    pub fn int(ccx: &CrateContext) -> Type {\n+        match ccx.tcx.sess.targ_cfg.arch {\n+            X86 | Arm | Mips => Type::i32(ccx),\n+            X86_64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn float(_: Architecture) -> Type {\n-        // All architectures currently just use doubles as the default\n-        // float size\n-        Type::f64()\n-    }\n-\n-    pub fn int_from_ty(ctx: &CrateContext, t: ast::IntTy) -> Type {\n+    pub fn int_from_ty(ccx: &CrateContext, t: ast::IntTy) -> Type {\n         match t {\n-            ast::TyI => ctx.int_type,\n-            ast::TyI8 => Type::i8(),\n-            ast::TyI16 => Type::i16(),\n-            ast::TyI32 => Type::i32(),\n-            ast::TyI64 => Type::i64()\n+            ast::TyI => ccx.int_type,\n+            ast::TyI8 => Type::i8(ccx),\n+            ast::TyI16 => Type::i16(ccx),\n+            ast::TyI32 => Type::i32(ccx),\n+            ast::TyI64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn uint_from_ty(ctx: &CrateContext, t: ast::UintTy) -> Type {\n+    pub fn uint_from_ty(ccx: &CrateContext, t: ast::UintTy) -> Type {\n         match t {\n-            ast::TyU => ctx.int_type,\n-            ast::TyU8 => Type::i8(),\n-            ast::TyU16 => Type::i16(),\n-            ast::TyU32 => Type::i32(),\n-            ast::TyU64 => Type::i64()\n+            ast::TyU => ccx.int_type,\n+            ast::TyU8 => Type::i8(ccx),\n+            ast::TyU16 => Type::i16(ccx),\n+            ast::TyU32 => Type::i32(ccx),\n+            ast::TyU64 => Type::i64(ccx)\n         }\n     }\n \n-    pub fn float_from_ty(t: ast::FloatTy) -> Type {\n+    pub fn float_from_ty(ccx: &CrateContext, t: ast::FloatTy) -> Type {\n         match t {\n-            ast::TyF32 => Type::f32(),\n-            ast::TyF64 => Type::f64()\n+            ast::TyF32 => Type::f32(ccx),\n+            ast::TyF64 => Type::f64(ccx)\n         }\n     }\n \n-    pub fn size_t(arch: Architecture) -> Type {\n-        Type::int(arch)\n+    pub fn size_t(ccx: &CrateContext) -> Type {\n+        Type::int(ccx)\n     }\n \n     pub fn func(args: &[Type], ret: &Type) -> Type {\n@@ -163,23 +156,23 @@ impl Type {\n         ty!(llvm::LLVMPointerType(ty.to_ref(), 0 as c_uint))\n     }\n \n-    pub fn struct_(els: &[Type], packed: bool) -> Type {\n+    pub fn struct_(ccx: &CrateContext, els: &[Type], packed: bool) -> Type {\n         let els : &[TypeRef] = unsafe { cast::transmute(els) };\n-        ty!(llvm::LLVMStructTypeInContext(base::task_llcx(), els.as_ptr(),\n-                                          els.len() as c_uint, packed as Bool))\n+        ty!(llvm::LLVMStructTypeInContext(ccx.llcx, els.as_ptr(),\n+                                          els.len() as c_uint,\n+                                          packed as Bool))\n     }\n \n-    pub fn named_struct(name: &str) -> Type {\n-        let ctx = base::task_llcx();\n-        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ctx, s)))\n+    pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n+        ty!(name.with_c_str(|s| llvm::LLVMStructCreateNamed(ccx.llcx, s)))\n     }\n \n-    pub fn empty_struct() -> Type {\n-        Type::struct_([], false)\n+    pub fn empty_struct(ccx: &CrateContext) -> Type {\n+        Type::struct_(ccx, [], false)\n     }\n \n-    pub fn vtable() -> Type {\n-        Type::array(&Type::i8p().ptr_to(), 1)\n+    pub fn vtable(ccx: &CrateContext) -> Type {\n+        Type::array(&Type::i8p(ccx).ptr_to(), 1)\n     }\n \n     pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n@@ -188,21 +181,21 @@ impl Type {\n             None => ()\n         }\n \n-        let ty = Type::glue_fn(Type::i8p());\n+        let ty = Type::glue_fn(cx, Type::i8p(cx));\n         cx.tn.associate_type(\"glue_fn\", &ty);\n \n-        return ty;\n+        ty\n     }\n \n-    pub fn glue_fn(t: Type) -> Type {\n-        Type::func([t], &Type::void())\n+    pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n+        Type::func([t], &Type::void(ccx))\n     }\n \n-    pub fn tydesc(arch: Architecture) -> Type {\n-        let mut tydesc = Type::named_struct(\"tydesc\");\n-        let glue_fn_ty = Type::glue_fn(Type::i8p()).ptr_to();\n+    pub fn tydesc(ccx: &CrateContext) -> Type {\n+        let mut tydesc = Type::named_struct(ccx, \"tydesc\");\n+        let glue_fn_ty = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to();\n \n-        let int_ty = Type::int(arch);\n+        let int_ty = Type::int(ccx);\n \n         // Must mirror:\n         //\n@@ -212,10 +205,10 @@ impl Type {\n                      int_ty,     // align\n                      glue_fn_ty, // drop\n                      glue_fn_ty, // visit\n-                     Type::struct_([Type::i8p(), Type::int(arch)], false)]; // name\n+                     Type::struct_(ccx, [Type::i8p(ccx), Type::int(ccx)], false)]; // name\n         tydesc.set_struct_body(elems, false);\n \n-        return tydesc;\n+        tydesc\n     }\n \n     pub fn array(ty: &Type, len: u64) -> Type {\n@@ -226,27 +219,27 @@ impl Type {\n         ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n     }\n \n-    pub fn vec(arch: Architecture, ty: &Type) -> Type {\n-        Type::struct_(\n-            [ Type::int(arch), Type::int(arch), Type::array(ty, 0) ],\n+    pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n+        Type::struct_(ccx,\n+            [Type::int(ccx), Type::int(ccx), Type::array(ty, 0)],\n         false)\n     }\n \n-    pub fn opaque_vec(arch: Architecture) -> Type {\n-        Type::vec(arch, &Type::i8())\n+    pub fn opaque_vec(ccx: &CrateContext) -> Type {\n+        Type::vec(ccx, &Type::i8(ccx))\n     }\n \n     // The box pointed to by @T.\n-    pub fn at_box(ctx: &CrateContext, ty: Type) -> Type {\n-        Type::struct_([\n-            ctx.int_type, Type::glue_fn(Type::i8p()).ptr_to(),\n-            Type::i8p(), Type::i8p(), ty\n+    pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n+        Type::struct_(ccx, [\n+            ccx.int_type, Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n+            Type::i8p(ccx), Type::i8p(ccx), ty\n         ], false)\n     }\n \n-    pub fn opaque_trait() -> Type {\n-        let vtable = Type::glue_fn(Type::i8p()).ptr_to().ptr_to();\n-        Type::struct_([vtable, Type::i8p()], false)\n+    pub fn opaque_trait(ccx: &CrateContext) -> Type {\n+        let vtable = Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to();\n+        Type::struct_(ccx, [vtable, Type::i8p(ccx)], false)\n     }\n \n     pub fn kind(&self) -> TypeKind {"}, {"sha": "32821f32df5c8b50dc10b5cba363407b71bc0a2b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -54,7 +54,7 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n \n     // Arg 1: Environment\n     if has_env {\n-        atys.push(Type::i8p());\n+        atys.push(Type::i8p(cx));\n     }\n \n     // ... then explicit args.\n@@ -63,7 +63,7 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n \n     // Use the output as the actual return value if it's immediate.\n     if use_out_pointer || return_type_is_void(cx, output) {\n-        Type::func(atys.as_slice(), &Type::void())\n+        Type::func(atys.as_slice(), &Type::void(cx))\n     } else {\n         Type::func(atys.as_slice(), &lloutputtype)\n     }\n@@ -86,7 +86,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n             }\n         }\n         _ => {\n-            cx.sess.bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n+            cx.sess().bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n         }\n     }\n }\n@@ -112,37 +112,36 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let llsizingty = match ty::get(t).sty {\n-        ty::ty_nil | ty::ty_bot => Type::nil(),\n-        ty::ty_bool => Type::bool(),\n-        ty::ty_char => Type::char(),\n+        ty::ty_nil | ty::ty_bot => Type::nil(cx),\n+        ty::ty_bool => Type::bool(cx),\n+        ty::ty_char => Type::char(cx),\n         ty::ty_int(t) => Type::int_from_ty(cx, t),\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-        ty::ty_float(t) => Type::float_from_ty(t),\n+        ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n         ty::ty_str(ty::vstore_uniq) |\n         ty::ty_vec(_, ty::vstore_uniq) |\n         ty::ty_box(..) |\n         ty::ty_uniq(..) |\n         ty::ty_ptr(..) |\n-        ty::ty_rptr(..) => Type::i8p(),\n+        ty::ty_rptr(..) => Type::i8p(cx),\n \n         ty::ty_str(ty::vstore_slice(..)) |\n         ty::ty_vec(_, ty::vstore_slice(..)) => {\n-            Type::struct_([Type::i8p(), Type::i8p()], false)\n+            Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n-        ty::ty_bare_fn(..) => Type::i8p(),\n-        ty::ty_closure(..) => Type::struct_([Type::i8p(), Type::i8p()], false),\n-        ty::ty_trait(..) => Type::opaque_trait(),\n+        ty::ty_bare_fn(..) => Type::i8p(cx),\n+        ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n+        ty::ty_trait(..) => Type::opaque_trait(cx),\n \n-        ty::ty_str(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n+        ty::ty_str(ty::vstore_fixed(size)) => Type::array(&Type::i8(cx), size as u64),\n         ty::ty_vec(mt, ty::vstore_fixed(size)) => {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n         ty::ty_unboxed_vec(mt) => {\n-            let sz_ty = sizing_type_of(cx, mt.ty);\n-            Type::vec(cx.sess.targ_cfg.arch, &sz_ty)\n+            Type::vec(cx, &sizing_type_of(cx, mt.ty))\n         }\n \n         ty::ty_tup(..) | ty::ty_enum(..) => {\n@@ -151,9 +150,9 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_struct(..) => {\n-            if ty::type_is_simd(cx.tcx, t) {\n-                let et = ty::simd_type(cx.tcx, t);\n-                let n = ty::simd_size(cx.tcx, t);\n+            if ty::type_is_simd(cx.tcx(), t) {\n+                let et = ty::simd_type(cx.tcx(), t);\n+                let n = ty::simd_size(cx.tcx(), t);\n                 Type::vector(&type_of(cx, et), n as u64)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n@@ -162,7 +161,8 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n-            cx.tcx.sess.bug(format!(\"fictitious type {:?} in sizing_type_of()\", ty::get(t).sty))\n+            cx.sess().bug(format!(\"fictitious type {:?} in sizing_type_of()\",\n+                                  ty::get(t).sty))\n         }\n     };\n \n@@ -182,21 +182,21 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n     }\n \n-    debug!(\"type_of {} {:?}\", t.repr(cx.tcx), t);\n+    debug!(\"type_of {} {:?}\", t.repr(cx.tcx()), t);\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n     // Rust types are defined as the same LLVM types.  If we don't do\n     // this then, e.g. `Option<{myfield: bool}>` would be a different\n     // type than `Option<myrec>`.\n-    let t_norm = ty::normalize_ty(cx.tcx, t);\n+    let t_norm = ty::normalize_ty(cx.tcx(), t);\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);\n         debug!(\"--> normalized {} {:?} to {} {:?} llty={}\",\n-                t.repr(cx.tcx),\n+                t.repr(cx.tcx()),\n                 t,\n-                t_norm.repr(cx.tcx),\n+                t_norm.repr(cx.tcx()),\n                 t_norm,\n                 cx.tn.type_to_str(llty));\n         let mut lltypes = cx.lltypes.borrow_mut();\n@@ -205,14 +205,14 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let mut llty = match ty::get(t).sty {\n-      ty::ty_nil | ty::ty_bot => Type::nil(),\n-      ty::ty_bool => Type::bool(),\n-      ty::ty_char => Type::char(),\n+      ty::ty_nil | ty::ty_bot => Type::nil(cx),\n+      ty::ty_bool => Type::bool(cx),\n+      ty::ty_char => Type::char(cx),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n-      ty::ty_float(t) => Type::float_from_ty(t),\n+      ty::ty_float(t) => Type::float_from_ty(cx, t),\n       ty::ty_str(ty::vstore_uniq) => {\n-        Type::vec(cx.sess.targ_cfg.arch, &Type::i8()).ptr_to()\n+        Type::vec(cx, &Type::i8(cx)).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We\n@@ -230,20 +230,18 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           type_of(cx, typ).ptr_to()\n       }\n       ty::ty_vec(ref mt, ty::vstore_uniq) => {\n-          let ty = type_of(cx, mt.ty);\n-          Type::vec(cx.sess.targ_cfg.arch, &ty).ptr_to()\n+          Type::vec(cx, &type_of(cx, mt.ty)).ptr_to()\n       }\n       ty::ty_unboxed_vec(ref mt) => {\n-          let ty = type_of(cx, mt.ty);\n-          Type::vec(cx.sess.targ_cfg.arch, &ty)\n+          Type::vec(cx, &type_of(cx, mt.ty))\n       }\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n       ty::ty_vec(ref mt, ty::vstore_slice(_)) => {\n           let p_ty = type_of(cx, mt.ty).ptr_to();\n           let u_ty = Type::uint_from_ty(cx, ast::TyU);\n-          Type::struct_([p_ty, u_ty], false)\n+          Type::struct_(cx, [p_ty, u_ty], false)\n       }\n \n       ty::ty_str(ty::vstore_slice(_)) => {\n@@ -252,7 +250,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n \n       ty::ty_str(ty::vstore_fixed(n)) => {\n-          Type::array(&Type::i8(), (n + 1u) as u64)\n+          Type::array(&Type::i8(cx), (n + 1u) as u64)\n       }\n \n       ty::ty_vec(ref mt, ty::vstore_fixed(n)) => {\n@@ -264,17 +262,17 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n       ty::ty_closure(_) => {\n           let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n-          Type::struct_([fn_ty, Type::i8p()], false)\n+          Type::struct_(cx, [fn_ty, Type::i8p(cx)], false)\n       }\n-      ty::ty_trait(..) => Type::opaque_trait(),\n+      ty::ty_trait(..) => Type::opaque_trait(cx),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, repr)\n       }\n       ty::ty_struct(did, ref substs) => {\n-          if ty::type_is_simd(cx.tcx, t) {\n-              let et = ty::simd_type(cx.tcx, t);\n-              let n = ty::simd_size(cx.tcx, t);\n+          if ty::type_is_simd(cx.tcx(), t) {\n+              let et = ty::simd_type(cx.tcx(), t);\n+              let n = ty::simd_size(cx.tcx(), t);\n               Type::vector(&type_of(cx, et), n as u64)\n           } else {\n               // Only create the named struct, but don't fill it in. We fill it\n@@ -288,14 +286,14 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               adt::incomplete_type_of(cx, repr, name)\n           }\n       }\n-      ty::ty_self(..) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n-      ty::ty_infer(..) => cx.tcx.sess.bug(\"type_of with ty_infer\"),\n-      ty::ty_param(..) => cx.tcx.sess.bug(\"type_of with ty_param\"),\n-      ty::ty_err(..) => cx.tcx.sess.bug(\"type_of with ty_err\")\n+      ty::ty_self(..) => cx.sess().unimpl(\"type_of: ty_self\"),\n+      ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),\n+      ty::ty_param(..) => cx.sess().bug(\"type_of with ty_param\"),\n+      ty::ty_err(..) => cx.sess().bug(\"type_of with ty_err\")\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\",\n-            t.repr(cx.tcx),\n+            t.repr(cx.tcx()),\n             t,\n             cx.tn.type_to_str(llty));\n     {\n@@ -305,7 +303,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-        ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx, t) => {\n+        ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx(), t) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, repr, &mut llty);\n         }\n@@ -326,7 +324,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n         a_struct => { \"struct\" }\n         an_enum => { \"enum\" }\n     };\n-    let tstr = ppaux::parameterized(cx.tcx, ty::item_path_str(cx.tcx, did),\n+    let tstr = ppaux::parameterized(cx.tcx(), ty::item_path_str(cx.tcx(), did),\n                                     &ty::NonerasedRegions(opt_vec::Empty),\n                                     tps, did, false);\n     if did.krate == 0 {\n@@ -338,5 +336,5 @@ pub fn llvm_type_name(cx: &CrateContext,\n \n pub fn type_of_dtor(ccx: &CrateContext, self_ty: ty::t) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n-    Type::func([self_ty], &Type::void())\n+    Type::func([self_ty], &Type::void(ccx))\n }"}, {"sha": "ae940ebeef2eb14f9c0b1511769bc552d83a37ff", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 203, "deletions": 212, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -11,9 +11,8 @@\n #[allow(non_camel_case_types)];\n \n use back::svh::Svh;\n-use driver::session;\n+use driver::session::Session;\n use metadata::csearch;\n-use metadata;\n use middle::const_eval;\n use middle::lang_items::{ExchangeHeapLangItem, OpaqueStructLangItem};\n use middle::lang_items::{TyDescStructLangItem, TyVisitorTraitLangItem};\n@@ -250,22 +249,18 @@ pub enum AutoRef {\n     AutoBorrowObj(Region, ast::Mutability),\n }\n \n-pub type ctxt = @ctxt_;\n-\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n-pub struct ctxt_ {\n-    diag: @syntax::diagnostic::SpanHandler,\n+pub struct ctxt {\n     // Specifically use a speedy hash algorithm for this hash map, it's used\n     // quite often.\n     interner: RefCell<FnvHashMap<intern_key, ~t_box_>>,\n     next_id: Cell<uint>,\n-    cstore: @metadata::cstore::CStore,\n-    sess: session::Session,\n+    sess: Session,\n     def_map: resolve::DefMap,\n \n-    named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n+    named_region_map: resolve_lifetime::NamedRegionMap,\n \n     region_maps: middle::region::RegionMaps,\n \n@@ -1081,21 +1076,19 @@ pub type type_cache = RefCell<DefIdMap<ty_param_bounds_and_ty>>;\n \n pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n-pub fn mk_ctxt(s: session::Session,\n+pub fn mk_ctxt(s: Session,\n                dm: resolve::DefMap,\n-               named_region_map: @RefCell<resolve_lifetime::NamedRegionMap>,\n+               named_region_map: resolve_lifetime::NamedRegionMap,\n                map: ast_map::Map,\n                freevars: freevars::freevar_map,\n                region_maps: middle::region::RegionMaps,\n                lang_items: @middle::lang_items::LanguageItems)\n             -> ctxt {\n-    @ctxt_ {\n+    ctxt {\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n-        diag: s.diagnostic(),\n         interner: RefCell::new(FnvHashMap::new()),\n         next_id: Cell::new(primitives::LAST_PRIMITIVE_ID),\n-        cstore: s.cstore,\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n@@ -1143,7 +1136,7 @@ pub fn mk_ctxt(s: session::Session,\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n-pub fn mk_t(cx: ctxt, st: sty) -> t {\n+pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n         ty_nil => return mk_nil(),\n@@ -1355,64 +1348,64 @@ pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n #[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_str(cx: ctxt, t: vstore) -> t {\n+pub fn mk_str(cx: &ctxt, t: vstore) -> t {\n     mk_t(cx, ty_str(t))\n }\n \n-pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n+pub fn mk_enum(cx: &ctxt, did: ast::DefId, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_enum(did, substs))\n }\n \n-pub fn mk_box(cx: ctxt, ty: t) -> t { mk_t(cx, ty_box(ty)) }\n+pub fn mk_box(cx: &ctxt, ty: t) -> t { mk_t(cx, ty_box(ty)) }\n \n-pub fn mk_uniq(cx: ctxt, ty: t) -> t { mk_t(cx, ty_uniq(ty)) }\n+pub fn mk_uniq(cx: &ctxt, ty: t) -> t { mk_t(cx, ty_uniq(ty)) }\n \n-pub fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n+pub fn mk_ptr(cx: &ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n-pub fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n+pub fn mk_rptr(cx: &ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n \n-pub fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n+pub fn mk_mut_rptr(cx: &ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n }\n-pub fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n+pub fn mk_imm_rptr(cx: &ctxt, r: Region, ty: t) -> t {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n+pub fn mk_mut_ptr(cx: &ctxt, ty: t) -> t {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutMutable})\n }\n \n-pub fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n+pub fn mk_imm_ptr(cx: &ctxt, ty: t) -> t {\n     mk_ptr(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_nil_ptr(cx: ctxt) -> t {\n+pub fn mk_nil_ptr(cx: &ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec(cx: ctxt, tm: mt, t: vstore) -> t {\n+pub fn mk_vec(cx: &ctxt, tm: mt, t: vstore) -> t {\n     mk_t(cx, ty_vec(tm, t))\n }\n \n-pub fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n+pub fn mk_unboxed_vec(cx: &ctxt, tm: mt) -> t {\n     mk_t(cx, ty_unboxed_vec(tm))\n }\n-pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n+pub fn mk_mut_unboxed_vec(cx: &ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::MutImmutable}))\n }\n \n-pub fn mk_tup(cx: ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n-pub fn mk_closure(cx: ctxt, fty: ClosureTy) -> t {\n+pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(fty))\n }\n \n-pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n+pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> t {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n-pub fn mk_ctor_fn(cx: ctxt,\n+pub fn mk_ctor_fn(cx: &ctxt,\n                   binder_id: ast::NodeId,\n                   input_tys: &[ty::t],\n                   output: ty::t) -> t {\n@@ -1431,7 +1424,7 @@ pub fn mk_ctor_fn(cx: ctxt,\n }\n \n \n-pub fn mk_trait(cx: ctxt,\n+pub fn mk_trait(cx: &ctxt,\n                 did: ast::DefId,\n                 substs: substs,\n                 store: TraitStore,\n@@ -1442,22 +1435,22 @@ pub fn mk_trait(cx: ctxt,\n     mk_t(cx, ty_trait(did, substs, store, mutability, bounds))\n }\n \n-pub fn mk_struct(cx: ctxt, struct_id: ast::DefId, substs: substs) -> t {\n+pub fn mk_struct(cx: &ctxt, struct_id: ast::DefId, substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_var(cx: ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n+pub fn mk_var(cx: &ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n \n-pub fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n+pub fn mk_int_var(cx: &ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n \n-pub fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n+pub fn mk_float_var(cx: &ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n-pub fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+pub fn mk_infer(cx: &ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n-pub fn mk_self(cx: ctxt, did: ast::DefId) -> t { mk_t(cx, ty_self(did)) }\n+pub fn mk_self(cx: &ctxt, did: ast::DefId) -> t { mk_t(cx, ty_self(did)) }\n \n-pub fn mk_param(cx: ctxt, n: uint, k: DefId) -> t {\n+pub fn mk_param(cx: &ctxt, n: uint, k: DefId) -> t {\n     mk_t(cx, ty_param(param_ty { idx: n, def_id: k }))\n }\n \n@@ -1495,35 +1488,35 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n }\n \n // Folds types from the bottom up.\n-pub fn fold_ty(cx: ctxt, t0: t, fldop: |t| -> t) -> t {\n+pub fn fold_ty(cx: &ctxt, t0: t, fldop: |t| -> t) -> t {\n     let mut f = ty_fold::BottomUpFolder {tcx: cx, fldop: fldop};\n     f.fold_ty(t0)\n }\n \n-pub fn walk_regions_and_ty(cx: ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n+pub fn walk_regions_and_ty(cx: &ctxt, ty: t, fldr: |r: Region|, fldt: |t: t|)\n                            -> t {\n     ty_fold::RegionFolder::general(cx,\n                                    |r| { fldr(r); r },\n                                    |t| { fldt(t); t }).fold_ty(ty)\n }\n \n-pub fn fold_regions(cx: ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n+pub fn fold_regions(cx: &ctxt, ty: t, fldr: |r: Region| -> Region) -> t {\n     ty_fold::RegionFolder::regions(cx, fldr).fold_ty(ty)\n }\n \n // Substitute *only* type parameters.  Used in trans where regions are erased.\n-pub fn subst_tps(tcx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n+pub fn subst_tps(tcx: &ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n     return subst.fold_ty(typ);\n \n     struct TpsSubst<'a> {\n-        tcx: ctxt,\n+        tcx: &'a ctxt,\n         self_ty_opt: Option<t>,\n         tps: &'a [t],\n     }\n \n     impl<'a> TypeFolder for TpsSubst<'a> {\n-        fn tcx(&self) -> ty::ctxt { self.tcx }\n+        fn tcx<'a>(&'a self) -> &'a ctxt { self.tcx }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             if self.tps.len() == 0u && self.self_ty_opt.is_none() {\n@@ -1566,11 +1559,11 @@ pub fn substs_is_noop(substs: &substs) -> bool {\n         substs.self_ty.is_none()\n }\n \n-pub fn substs_to_str(cx: ctxt, substs: &substs) -> ~str {\n+pub fn substs_to_str(cx: &ctxt, substs: &substs) -> ~str {\n     substs.repr(cx)\n }\n \n-pub fn subst(cx: ctxt,\n+pub fn subst(cx: &ctxt,\n              substs: &substs,\n              typ: t)\n           -> t {\n@@ -1631,7 +1624,7 @@ pub fn type_is_sequence(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_simd(cx: ctxt, ty: t) -> bool {\n+pub fn type_is_simd(cx: &ctxt, ty: t) -> bool {\n     match get(ty).sty {\n         ty_struct(did, _) => lookup_simd(cx, did),\n         _ => false\n@@ -1645,15 +1638,15 @@ pub fn type_is_str(ty: t) -> bool {\n     }\n }\n \n-pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n+pub fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n       ty_str(_) => return mk_mach_uint(ast::TyU8),\n       ty_vec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n \n-pub fn simd_type(cx: ctxt, ty: t) -> t {\n+pub fn simd_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -1663,7 +1656,7 @@ pub fn simd_type(cx: ctxt, ty: t) -> t {\n     }\n }\n \n-pub fn simd_size(cx: ctxt, ty: t) -> uint {\n+pub fn simd_size(cx: &ctxt, ty: t) -> uint {\n     match get(ty).sty {\n         ty_struct(did, _) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -1751,15 +1744,15 @@ pub fn type_is_scalar(ty: t) -> bool {\n     }\n }\n \n-pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n+pub fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).needs_drop(cx)\n }\n \n // Some things don't need cleanups during unwinding because the\n // task can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n-pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n+pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n     {\n         let needs_unwind_cleanup_cache = cx.needs_unwind_cleanup_cache\n                                            .borrow();\n@@ -1778,7 +1771,7 @@ pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n     return needs_unwind_cleanup;\n }\n \n-fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n+fn type_needs_unwind_cleanup_(cx: &ctxt, ty: t,\n                               tycache: &mut HashSet<t>,\n                               encountered_box: bool) -> bool {\n \n@@ -1925,11 +1918,11 @@ def_type_content_sets!(\n )\n \n impl TypeContents {\n-    pub fn meets_bounds(&self, cx: ctxt, bbs: BuiltinBounds) -> bool {\n+    pub fn meets_bounds(&self, cx: &ctxt, bbs: BuiltinBounds) -> bool {\n         bbs.iter().all(|bb| self.meets_bound(cx, bb))\n     }\n \n-    pub fn meets_bound(&self, cx: ctxt, bb: BuiltinBound) -> bool {\n+    pub fn meets_bound(&self, cx: &ctxt, bb: BuiltinBound) -> bool {\n         match bb {\n             BoundStatic => self.is_static(cx),\n             BoundFreeze => self.is_freezable(cx),\n@@ -1947,11 +1940,11 @@ impl TypeContents {\n         (self.bits & tc.bits) != 0\n     }\n \n-    pub fn is_static(&self, _: ctxt) -> bool {\n+    pub fn is_static(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonstatic)\n     }\n \n-    pub fn is_sendable(&self, _: ctxt) -> bool {\n+    pub fn is_sendable(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonsendable)\n     }\n \n@@ -1963,23 +1956,23 @@ impl TypeContents {\n         self.intersects(TC::OwnsOwned)\n     }\n \n-    pub fn is_freezable(&self, _: ctxt) -> bool {\n+    pub fn is_freezable(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonfreezable)\n     }\n \n-    pub fn is_sized(&self, _: ctxt) -> bool {\n+    pub fn is_sized(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonsized)\n     }\n \n-    pub fn is_pod(&self, _: ctxt) -> bool {\n+    pub fn is_pod(&self, _: &ctxt) -> bool {\n         !self.intersects(TC::Nonpod)\n     }\n \n-    pub fn moves_by_default(&self, _: ctxt) -> bool {\n+    pub fn moves_by_default(&self, _: &ctxt) -> bool {\n         self.intersects(TC::Moves)\n     }\n \n-    pub fn needs_drop(&self, _: ctxt) -> bool {\n+    pub fn needs_drop(&self, _: &ctxt) -> bool {\n         self.intersects(TC::NeedsDrop)\n     }\n \n@@ -2055,23 +2048,23 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_has_dtor(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_has_dtor(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).has_dtor()\n }\n \n-pub fn type_is_static(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_is_static(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n \n-pub fn type_is_sendable(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_is_sendable(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_sendable(cx)\n }\n \n-pub fn type_is_freezable(cx: ctxt, t: ty::t) -> bool {\n+pub fn type_is_freezable(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_freezable(cx)\n }\n \n-pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n+pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     let ty_id = type_id(ty);\n \n     {\n@@ -2089,7 +2082,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     tc_cache.get().insert(ty_id, result);\n     return result;\n \n-    fn tc_ty(cx: ctxt,\n+    fn tc_ty(cx: &ctxt,\n              ty: t,\n              cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n@@ -2255,15 +2248,15 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         return result;\n     }\n \n-    fn tc_mt(cx: ctxt,\n+    fn tc_mt(cx: &ctxt,\n              mt: mt,\n              cache: &mut HashMap<uint, TypeContents>) -> TypeContents\n     {\n         let mc = TC::ReachesMutable.when(mt.mutbl == MutMutable);\n         mc | tc_ty(cx, mt.ty, cache)\n     }\n \n-    fn apply_lang_items(cx: ctxt,\n+    fn apply_lang_items(cx: &ctxt,\n                         did: ast::DefId,\n                         tc: TypeContents)\n                         -> TypeContents {\n@@ -2295,7 +2288,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         b | (TC::ReachesBorrowed).when(region != ty::ReStatic)\n     }\n \n-    fn closure_contents(cx: ctxt, cty: &ClosureTy) -> TypeContents {\n+    fn closure_contents(cx: &ctxt, cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n         let st = match cty.sigil {\n@@ -2321,7 +2314,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         st | rt | ot\n     }\n \n-    fn object_contents(cx: ctxt,\n+    fn object_contents(cx: &ctxt,\n                        store: TraitStore,\n                        mutbl: ast::Mutability,\n                        bounds: BuiltinBounds)\n@@ -2340,7 +2333,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         }\n     }\n \n-    fn kind_bounds_to_contents(cx: ctxt,\n+    fn kind_bounds_to_contents(cx: &ctxt,\n                                bounds: BuiltinBounds,\n                                traits: &[@TraitRef])\n                                -> TypeContents {\n@@ -2359,7 +2352,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n         // Iterates over all builtin bounds on the type parameter def, including\n         // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound(cx: ctxt,\n+        fn each_inherited_builtin_bound(cx: &ctxt,\n                                         bounds: BuiltinBounds,\n                                         traits: &[@TraitRef],\n                                         f: |BuiltinBound|) {\n@@ -2378,13 +2371,13 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n     }\n }\n \n-pub fn type_moves_by_default(cx: ctxt, ty: t) -> bool {\n+pub fn type_moves_by_default(cx: &ctxt, ty: t) -> bool {\n     type_contents(cx, ty).moves_by_default(cx)\n }\n \n // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n-pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n-    fn type_requires(cx: ctxt, seen: &mut Vec<DefId> ,\n+pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n+    fn type_requires(cx: &ctxt, seen: &mut Vec<DefId>,\n                      r_ty: t, ty: t) -> bool {\n         debug!(\"type_requires({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2402,7 +2395,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n         return r;\n     }\n \n-    fn subtypes_require(cx: ctxt, seen: &mut Vec<DefId> ,\n+    fn subtypes_require(cx: &ctxt, seen: &mut Vec<DefId>,\n                         r_ty: t, ty: t) -> bool {\n         debug!(\"subtypes_require({}, {})?\",\n                ::util::ppaux::ty_to_str(cx, r_ty),\n@@ -2508,10 +2501,10 @@ pub enum Representability {\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n-pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n+pub fn is_type_representable(cx: &ctxt, ty: t) -> Representability {\n \n     // Iterate until something non-representable is found\n-    fn find_nonrepresentable<It: Iterator<t>>(cx: ctxt, seen: &mut Vec<DefId> ,\n+    fn find_nonrepresentable<It: Iterator<t>>(cx: &ctxt, seen: &mut Vec<DefId>,\n                                               mut iter: It) -> Representability {\n         for ty in iter {\n             let r = type_structurally_recursive(cx, seen, ty);\n@@ -2524,7 +2517,7 @@ pub fn is_type_representable(cx: ctxt, ty: t) -> Representability {\n \n     // Does the type `ty` directly (without indirection through a pointer)\n     // contain any types on stack `seen`?\n-    fn type_structurally_recursive(cx: ctxt, seen: &mut Vec<DefId> ,\n+    fn type_structurally_recursive(cx: &ctxt, seen: &mut Vec<DefId>,\n                                    ty: t) -> Representability {\n         debug!(\"type_structurally_recursive: {}\",\n                ::util::ppaux::ty_to_str(cx, ty));\n@@ -2656,7 +2649,7 @@ pub fn type_is_enum(ty: t) -> bool {\n }\n \n // Is the type's representation size known at compile time?\n-pub fn type_is_sized(cx: ctxt, ty: ty::t) -> bool {\n+pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n     match get(ty).sty {\n         // FIXME(#6308) add trait, vec, str, etc here.\n         ty_param(p) => {\n@@ -2673,7 +2666,7 @@ pub fn type_is_sized(cx: ctxt, ty: ty::t) -> bool {\n \n // Whether a type is enum like, that is an enum type with only nullary\n // constructors\n-pub fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n+pub fn type_is_c_like_enum(cx: &ctxt, ty: t) -> bool {\n     match get(ty).sty {\n         ty_enum(did, _) => {\n             let variants = enum_variants(cx, did);\n@@ -2720,7 +2713,7 @@ pub fn index(t: t) -> Option<mt> {\n     }\n }\n \n-pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n+pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     let trait_refs = cx.trait_refs.borrow();\n     match trait_refs.get().find(&id) {\n        Some(&t) => t,\n@@ -2730,12 +2723,12 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     }\n }\n \n-pub fn try_node_id_to_type(cx: ctxt, id: ast::NodeId) -> Option<t> {\n+pub fn try_node_id_to_type(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n     let node_types = cx.node_types.borrow();\n     node_types.get().find_copy(&(id as uint))\n }\n \n-pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n+pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n     match try_node_id_to_type(cx, id) {\n        Some(t) => t,\n        None => cx.sess.bug(\n@@ -2744,7 +2737,7 @@ pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n     }\n }\n \n-pub fn node_id_to_type_opt(cx: ctxt, id: ast::NodeId) -> Option<t> {\n+pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n     let node_types = cx.node_types.borrow();\n     debug!(\"id: {:?}, node_types: {:?}\", id, node_types);\n     match node_types.get().find(&(id as uint)) {\n@@ -2754,15 +2747,15 @@ pub fn node_id_to_type_opt(cx: ctxt, id: ast::NodeId) -> Option<t> {\n }\n \n // FIXME(pcwalton): Makes a copy, bleh. Probably better to not do that.\n-pub fn node_id_to_type_params(cx: ctxt, id: ast::NodeId) -> Vec<t> {\n+pub fn node_id_to_type_params(cx: &ctxt, id: ast::NodeId) -> Vec<t> {\n     let node_type_substs = cx.node_type_substs.borrow();\n     match node_type_substs.get().find(&id) {\n       None => return Vec::new(),\n       Some(ts) => return (*ts).clone(),\n     }\n }\n \n-fn node_id_has_type_params(cx: ctxt, id: ast::NodeId) -> bool {\n+fn node_id_has_type_params(cx: &ctxt, id: ast::NodeId) -> bool {\n     let node_type_substs = cx.node_type_substs.borrow();\n     node_type_substs.get().contains_key(&id)\n }\n@@ -2843,7 +2836,7 @@ pub fn ty_vstore(ty: t) -> vstore {\n     }\n }\n \n-pub fn ty_region(tcx: ctxt,\n+pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: t) -> Region {\n     match get(ty).sty {\n@@ -2858,7 +2851,7 @@ pub fn ty_region(tcx: ctxt,\n     }\n }\n \n-pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n+pub fn replace_fn_sig(cx: &ctxt, fsty: &sty, new_sig: FnSig) -> t {\n     match *fsty {\n         ty_bare_fn(ref f) => mk_bare_fn(cx, BareFnTy {sig: new_sig, ..*f}),\n         ty_closure(ref f) => mk_closure(cx, ClosureTy {sig: new_sig, ..*f}),\n@@ -2869,7 +2862,7 @@ pub fn replace_fn_sig(cx: ctxt, fsty: &sty, new_sig: FnSig) -> t {\n     }\n }\n \n-pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n+pub fn replace_closure_return_type(tcx: &ctxt, fn_type: t, ret_type: t) -> t {\n     /*!\n      *\n      * Returns a new function type based on `fn_type` but returning a value of\n@@ -2896,14 +2889,14 @@ pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n }\n \n // Type accessors for AST nodes\n-pub fn block_ty(cx: ctxt, b: &ast::Block) -> t {\n+pub fn block_ty(cx: &ctxt, b: &ast::Block) -> t {\n     return node_id_to_type(cx, b.id);\n }\n \n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-pub fn pat_ty(cx: ctxt, pat: &ast::Pat) -> t {\n+pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n     return node_id_to_type(cx, pat.id);\n }\n \n@@ -2919,15 +2912,15 @@ pub fn pat_ty(cx: ctxt, pat: &ast::Pat) -> t {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-pub fn expr_ty(cx: ctxt, expr: &ast::Expr) -> t {\n+pub fn expr_ty(cx: &ctxt, expr: &ast::Expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n \n-pub fn expr_ty_opt(cx: ctxt, expr: &ast::Expr) -> Option<t> {\n+pub fn expr_ty_opt(cx: &ctxt, expr: &ast::Expr) -> Option<t> {\n     return node_id_to_type_opt(cx, expr.id);\n }\n \n-pub fn expr_ty_adjusted(cx: ctxt,\n+pub fn expr_ty_adjusted(cx: &ctxt,\n                         expr: &ast::Expr,\n                         method_map: &FnvHashMap<MethodCall, MethodCallee>)\n                         -> t {\n@@ -2951,7 +2944,7 @@ pub fn expr_ty_adjusted(cx: ctxt,\n     })\n }\n \n-pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n+pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n     match cx.map.find(id) {\n         Some(ast_map::NodeExpr(e)) => {\n             e.span\n@@ -2967,7 +2960,7 @@ pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n     }\n }\n \n-pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n+pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n     match cx.map.find(id) {\n         Some(ast_map::NodeLocal(pat)) => {\n             match pat.node {\n@@ -2989,7 +2982,7 @@ pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n     }\n }\n \n-pub fn adjust_ty(cx: ctxt,\n+pub fn adjust_ty(cx: &ctxt,\n                  span: Span,\n                  expr_id: ast::NodeId,\n                  unadjusted_ty: ty::t,\n@@ -3104,7 +3097,7 @@ pub fn adjust_ty(cx: ctxt,\n         None => unadjusted_ty\n     };\n \n-    fn borrow_vec(cx: ctxt, span: Span,\n+    fn borrow_vec(cx: &ctxt, span: Span,\n                   r: Region, m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n@@ -3125,7 +3118,7 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_fn(cx: ctxt, span: Span, r: Region, ty: ty::t) -> ty::t {\n+    fn borrow_fn(cx: &ctxt, span: Span, r: Region, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_closure(ref fty) => {\n                 ty::mk_closure(cx, ClosureTy {\n@@ -3144,7 +3137,7 @@ pub fn adjust_ty(cx: ctxt,\n         }\n     }\n \n-    fn borrow_obj(cx: ctxt, span: Span, r: Region,\n+    fn borrow_obj(cx: &ctxt, span: Span, r: Region,\n                   m: ast::Mutability, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n             ty_trait(trt_did, ref trt_substs, _, _, b) => {\n@@ -3161,7 +3154,7 @@ pub fn adjust_ty(cx: ctxt,\n     }\n }\n \n-pub fn trait_adjustment_to_ty(cx: ctxt, sigil: &ast::Sigil, region: &Option<Region>,\n+pub fn trait_adjustment_to_ty(cx: &ctxt, sigil: &ast::Sigil, region: &Option<Region>,\n                               def_id: ast::DefId, substs: &substs, m: ast::Mutability,\n                               bounds: BuiltinBounds) -> t {\n \n@@ -3192,7 +3185,7 @@ pub struct ParamsTy {\n     ty: t\n }\n \n-pub fn expr_ty_params_and_ty(cx: ctxt,\n+pub fn expr_ty_params_and_ty(cx: &ctxt,\n                              expr: &ast::Expr)\n                           -> ParamsTy {\n     ParamsTy {\n@@ -3201,12 +3194,12 @@ pub fn expr_ty_params_and_ty(cx: ctxt,\n     }\n }\n \n-pub fn expr_has_ty_params(cx: ctxt, expr: &ast::Expr) -> bool {\n+pub fn expr_has_ty_params(cx: &ctxt, expr: &ast::Expr) -> bool {\n     return node_id_has_type_params(cx, expr.id);\n }\n \n-pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n-                                   -> Rc<Vec<TypeParameterDef> > {\n+pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n+                                   -> Rc<Vec<TypeParameterDef>> {\n     match origin {\n         typeck::MethodStatic(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3234,7 +3227,7 @@ pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n     }\n }\n \n-pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n+pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> ast::Def {\n     let def_map = tcx.def_map.borrow();\n     match def_map.get().find(&expr.id) {\n         Some(&def) => def,\n@@ -3245,7 +3238,7 @@ pub fn resolve_expr(tcx: ctxt, expr: &ast::Expr) -> ast::Def {\n     }\n }\n \n-pub fn expr_is_lval(tcx: ctxt,\n+pub fn expr_is_lval(tcx: &ctxt,\n                     method_map: MethodMap,\n                     e: &ast::Expr) -> bool {\n     match expr_kind(tcx, method_map, e) {\n@@ -3266,7 +3259,7 @@ pub enum ExprKind {\n     RvalueStmtExpr\n }\n \n-pub fn expr_kind(tcx: ctxt,\n+pub fn expr_kind(tcx: &ctxt,\n                  method_map: MethodMap,\n                  expr: &ast::Expr) -> ExprKind {\n     if method_map.borrow().get().contains_key(&MethodCall::expr(expr.id)) {\n@@ -3440,7 +3433,7 @@ pub fn field_idx(name: ast::Name, fields: &[field]) -> Option<uint> {\n     return None;\n }\n \n-pub fn field_idx_strict(tcx: ty::ctxt, name: ast::Name, fields: &[field])\n+pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident.name == name { return i; } i += 1u; }\n@@ -3470,7 +3463,7 @@ pub fn param_tys_in_type(ty: t) -> Vec<param_ty> {\n     rslt\n }\n \n-pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n+pub fn ty_sort_str(cx: &ctxt, t: t) -> ~str {\n     match get(t).sty {\n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str(_) => {\n@@ -3498,7 +3491,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     }\n }\n \n-pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n+pub fn type_err_to_str(cx: &ctxt, err: &type_err) -> ~str {\n     /*!\n      *\n      * Explains the source of a type err in a short,\n@@ -3644,7 +3637,7 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n     }\n }\n \n-pub fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n+pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n     match *err {\n         terr_regions_does_not_outlive(subregion, superregion) => {\n             note_and_explain_region(cx, \"\", subregion, \"...\");\n@@ -3683,12 +3676,12 @@ pub fn def_has_ty_params(def: ast::Def) -> bool {\n     }\n }\n \n-pub fn provided_source(cx: ctxt, id: ast::DefId) -> Option<ast::DefId> {\n+pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     let provided_method_sources = cx.provided_method_sources.borrow();\n     provided_method_sources.get().find(&id).map(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> Vec<@Method> {\n+pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<@Method> {\n     if is_local(id) {\n         {\n             match cx.map.find(id.node) {\n@@ -3720,7 +3713,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> Vec<@Method> {\n     }\n }\n \n-pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n+pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     // Check the cache.\n     {\n         let supertraits = cx.supertraits.borrow();\n@@ -3742,7 +3735,7 @@ pub fn trait_supertraits(cx: ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n     return result;\n }\n \n-pub fn trait_ref_supertraits(cx: ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n+pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n     supertrait_refs.map(\n         |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs))\n@@ -3776,13 +3769,13 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     v\n }\n \n-pub fn trait_method(cx: ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n+pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n     let method_def_id = *ty::trait_method_def_ids(cx, trait_did).get(idx);\n     ty::method(cx, method_def_id)\n }\n \n \n-pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n+pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n     let mut trait_methods_cache = cx.trait_methods_cache.borrow_mut();\n     match trait_methods_cache.get().find(&trait_did) {\n         Some(&methods) => methods,\n@@ -3795,24 +3788,24 @@ pub fn trait_methods(cx: ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n     }\n }\n \n-pub fn method(cx: ctxt, id: ast::DefId) -> @Method {\n+pub fn method(cx: &ctxt, id: ast::DefId) -> @Method {\n     let mut methods = cx.methods.borrow_mut();\n     lookup_locally_or_in_crate_store(\"methods\", id, methods.get(), || {\n         @csearch::get_method(cx, id)\n     })\n }\n \n-pub fn trait_method_def_ids(cx: ctxt, id: ast::DefId) -> @Vec<DefId> {\n+pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> @Vec<DefId> {\n     let mut trait_method_def_ids = cx.trait_method_def_ids.borrow_mut();\n     lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n                                      id,\n                                      trait_method_def_ids.get(),\n                                      || {\n-        @csearch::get_trait_method_def_ids(cx.cstore, id)\n+        @csearch::get_trait_method_def_ids(&cx.sess.cstore, id)\n     })\n }\n \n-pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n+pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     {\n         let mut impl_trait_cache = cx.impl_trait_cache.borrow_mut();\n         match impl_trait_cache.get().find(&id) {\n@@ -3848,15 +3841,15 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n     return ret;\n }\n \n-pub fn trait_ref_to_def_id(tcx: ctxt, tr: &ast::TraitRef) -> ast::DefId {\n+pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def_map = tcx.def_map.borrow();\n     let def = def_map.get()\n                      .find(&tr.ref_id)\n                      .expect(\"no def-map entry for trait\");\n     ast_util::def_id_of_def(*def)\n }\n \n-pub fn try_add_builtin_trait(tcx: ctxt,\n+pub fn try_add_builtin_trait(tcx: &ctxt,\n                              trait_def_id: ast::DefId,\n                              builtin_bounds: &mut BuiltinBounds) -> bool {\n     //! Checks whether `trait_ref` refers to one of the builtin\n@@ -3894,7 +3887,7 @@ impl VariantInfo {\n     /// Creates a new VariantInfo from the corresponding ast representation.\n     ///\n     /// Does not do any caching of the value in the type context.\n-    pub fn from_ast_variant(cx: ctxt,\n+    pub fn from_ast_variant(cx: &ctxt,\n                             ast_variant: &ast::Variant,\n                             discriminant: Disr) -> VariantInfo {\n         let ctor_ty = node_id_to_type(cx, ast_variant.node.id);\n@@ -3946,7 +3939,7 @@ impl VariantInfo {\n     }\n }\n \n-pub fn substd_enum_variants(cx: ctxt,\n+pub fn substd_enum_variants(cx: &ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n                          -> Vec<@VariantInfo> {\n@@ -3964,7 +3957,7 @@ pub fn substd_enum_variants(cx: ctxt,\n     }).collect()\n }\n \n-pub fn item_path_str(cx: ctxt, id: ast::DefId) -> ~str {\n+pub fn item_path_str(cx: &ctxt, id: ast::DefId) -> ~str {\n     with_path(cx, id, |path| ast_map::path_to_str(path))\n }\n \n@@ -3995,7 +3988,7 @@ impl DtorKind {\n \n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n-pub fn ty_dtor(cx: ctxt, struct_id: DefId) -> DtorKind {\n+pub fn ty_dtor(cx: &ctxt, struct_id: DefId) -> DtorKind {\n     let destructor_for_type = cx.destructor_for_type.borrow();\n     match destructor_for_type.get().find(&struct_id) {\n         Some(&method_def_id) => {\n@@ -4007,30 +4000,30 @@ pub fn ty_dtor(cx: ctxt, struct_id: DefId) -> DtorKind {\n     }\n }\n \n-pub fn has_dtor(cx: ctxt, struct_id: DefId) -> bool {\n+pub fn has_dtor(cx: &ctxt, struct_id: DefId) -> bool {\n     ty_dtor(cx, struct_id).is_present()\n }\n \n-pub fn with_path<T>(cx: ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {\n+pub fn with_path<T>(cx: &ctxt, id: ast::DefId, f: |ast_map::PathElems| -> T) -> T {\n     if id.krate == ast::LOCAL_CRATE {\n         cx.map.with_path(id.node, f)\n     } else {\n         f(ast_map::Values(csearch::get_item_path(cx, id).iter()).chain(None))\n     }\n }\n \n-pub fn enum_is_univariant(cx: ctxt, id: ast::DefId) -> bool {\n+pub fn enum_is_univariant(cx: &ctxt, id: ast::DefId) -> bool {\n     enum_variants(cx, id).len() == 1\n }\n \n-pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n+pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n     match ty::get(t).sty {\n        ty_enum(did, _) => (*enum_variants(cx, did)).is_empty(),\n        _ => false\n      }\n }\n \n-pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n+pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n     {\n         let enum_var_cache = cx.enum_var_cache.borrow();\n         match enum_var_cache.get().find(&id) {\n@@ -4061,7 +4054,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n                             };\n \n                             match variant.node.disr_expr {\n-                                Some(e) => match const_eval::eval_const_expr_partial(&cx, e) {\n+                                Some(e) => match const_eval::eval_const_expr_partial(cx, e) {\n                                     Ok(const_eval::const_int(val)) => {\n                                         discriminant = val as Disr\n                                     }\n@@ -4113,7 +4106,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n \n \n // Returns information about the enum variant with the given ID:\n-pub fn enum_variant_with_id(cx: ctxt,\n+pub fn enum_variant_with_id(cx: &ctxt,\n                             enum_id: ast::DefId,\n                             variant_id: ast::DefId)\n                          -> @VariantInfo {\n@@ -4132,7 +4125,7 @@ pub fn enum_variant_with_id(cx: ctxt,\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n-pub fn lookup_item_type(cx: ctxt,\n+pub fn lookup_item_type(cx: &ctxt,\n                         did: ast::DefId)\n                      -> ty_param_bounds_and_ty {\n     let mut tcache = cx.tcache.borrow_mut();\n@@ -4141,7 +4134,7 @@ pub fn lookup_item_type(cx: ctxt,\n         || csearch::get_type(cx, did))\n }\n \n-pub fn lookup_impl_vtables(cx: ctxt,\n+pub fn lookup_impl_vtables(cx: &ctxt,\n                            did: ast::DefId)\n                      -> typeck::impl_res {\n     let mut impl_vtables = cx.impl_vtables.borrow_mut();\n@@ -4151,7 +4144,7 @@ pub fn lookup_impl_vtables(cx: ctxt,\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n+pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> @ty::TraitDef {\n     let mut trait_defs = cx.trait_defs.borrow_mut();\n     match trait_defs.get().find(&did) {\n         Some(&trait_def) => {\n@@ -4171,13 +4164,13 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n /// Iterate over meta_items of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n+pub fn each_attr(tcx: &ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n         item.attrs.iter().advance(|attr| f(attr.node.value))\n     } else {\n         let mut cont = true;\n-        csearch::get_item_attrs(tcx.cstore, did, |meta_items| {\n+        csearch::get_item_attrs(&tcx.sess.cstore, did, |meta_items| {\n             if cont {\n                 cont = meta_items.iter().advance(|ptrptr| f(*ptrptr));\n             }\n@@ -4187,7 +4180,7 @@ pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n }\n \n /// Determine whether an item is annotated with an attribute\n-pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n+pub fn has_attr(tcx: &ctxt, did: DefId, attr: &str) -> bool {\n     let mut found = false;\n     each_attr(tcx, did, |item| {\n         if item.name().equiv(&attr) {\n@@ -4201,17 +4194,17 @@ pub fn has_attr(tcx: ctxt, did: DefId, attr: &str) -> bool {\n }\n \n /// Determine whether an item is annotated with `#[packed]`\n-pub fn lookup_packed(tcx: ctxt, did: DefId) -> bool {\n+pub fn lookup_packed(tcx: &ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"packed\")\n }\n \n /// Determine whether an item is annotated with `#[simd]`\n-pub fn lookup_simd(tcx: ctxt, did: DefId) -> bool {\n+pub fn lookup_simd(tcx: &ctxt, did: DefId) -> bool {\n     has_attr(tcx, did, \"simd\")\n }\n \n // Obtain the representation annotation for a definition.\n-pub fn lookup_repr_hint(tcx: ctxt, did: DefId) -> attr::ReprAttr {\n+pub fn lookup_repr_hint(tcx: &ctxt, did: DefId) -> attr::ReprAttr {\n     let mut acc = attr::ReprAny;\n     ty::each_attr(tcx, did, |meta| {\n         acc = attr::find_repr_attr(tcx.sess.diagnostic(), meta, acc);\n@@ -4222,7 +4215,7 @@ pub fn lookup_repr_hint(tcx: ctxt, did: DefId) -> attr::ReprAttr {\n \n // Look up a field ID, whether or not it's local\n // Takes a list of type substs in case the struct is generic\n-pub fn lookup_field_type(tcx: ctxt,\n+pub fn lookup_field_type(tcx: &ctxt,\n                          struct_id: DefId,\n                          id: DefId,\n                          substs: &substs)\n@@ -4247,42 +4240,40 @@ pub fn lookup_field_type(tcx: ctxt,\n \n // Look up the list of field names and IDs for a given struct\n // Fails if the id is not bound to a struct.\n-pub fn lookup_struct_fields(cx: ctxt, did: ast::DefId) -> Vec<field_ty> {\n-  if did.krate == ast::LOCAL_CRATE {\n-      {\n-          match cx.map.find(did.node) {\n-           Some(ast_map::NodeItem(i)) => {\n-             match i.node {\n-                ast::ItemStruct(struct_def, _) => {\n-                   struct_field_tys(struct_def.fields.as_slice())\n-                }\n-                _ => cx.sess.bug(\"struct ID bound to non-struct\")\n-             }\n-           }\n-           Some(ast_map::NodeVariant(ref variant)) => {\n-              match (*variant).node.kind {\n-                ast::StructVariantKind(struct_def) => {\n-                  struct_field_tys(struct_def.fields.as_slice())\n+pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n+    if did.krate == ast::LOCAL_CRATE {\n+        match cx.map.find(did.node) {\n+            Some(ast_map::NodeItem(i)) => {\n+                match i.node {\n+                    ast::ItemStruct(struct_def, _) => {\n+                        struct_field_tys(struct_def.fields.as_slice())\n+                    }\n+                    _ => cx.sess.bug(\"struct ID bound to non-struct\")\n                 }\n-                _ => {\n-                  cx.sess.bug(\"struct ID bound to enum variant that isn't \\\n-                               struct-like\")\n+            }\n+            Some(ast_map::NodeVariant(ref variant)) => {\n+                match (*variant).node.kind {\n+                    ast::StructVariantKind(struct_def) => {\n+                        struct_field_tys(struct_def.fields.as_slice())\n+                    }\n+                    _ => {\n+                        cx.sess.bug(\"struct ID bound to enum variant that \\\n+                                    isn't struct-like\")\n+                    }\n                 }\n-              }\n-           }\n-           _ => {\n-               cx.sess.bug(\n-                   format!(\"struct ID not bound to an item: {}\",\n+            }\n+            _ => {\n+                cx.sess.bug(\n+                    format!(\"struct ID not bound to an item: {}\",\n                         cx.map.node_to_str(did.node)));\n-           }\n-          }\n-      }\n-  } else {\n-    return csearch::get_struct_fields(cx.sess.cstore, did);\n-  }\n+            }\n+        }\n+    } else {\n+        csearch::get_struct_fields(&cx.sess.cstore, did)\n+    }\n }\n \n-pub fn lookup_struct_field(cx: ctxt,\n+pub fn lookup_struct_field(cx: &ctxt,\n                            parent: ast::DefId,\n                            field_id: ast::DefId)\n                         -> field_ty {\n@@ -4317,7 +4308,7 @@ fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n // this. Takes a list of substs with which to instantiate field types.\n-pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n+pub fn struct_fields(cx: &ctxt, did: ast::DefId, substs: &substs)\n                      -> Vec<field> {\n     lookup_struct_fields(cx, did).map(|f| {\n        field {\n@@ -4331,7 +4322,7 @@ pub fn struct_fields(cx: ctxt, did: ast::DefId, substs: &substs)\n     })\n }\n \n-pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n+pub fn is_binopable(cx: &ctxt, ty: t, op: ast::BinOp) -> bool {\n     static tycat_other: int = 0;\n     static tycat_bool: int = 1;\n     static tycat_char: int = 2;\n@@ -4372,7 +4363,7 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n         }\n     }\n \n-    fn tycat(cx: ctxt, ty: t) -> int {\n+    fn tycat(cx: &ctxt, ty: t) -> int {\n         if type_is_simd(cx, ty) {\n             return tycat(cx, simd_type(cx, ty))\n         }\n@@ -4403,22 +4394,22 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n     return tbl[tycat(cx, ty)][opcat(op)];\n }\n \n-pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> Vec<t> {\n+pub fn ty_params_to_tys(tcx: &ctxt, generics: &ast::Generics) -> Vec<t> {\n     Vec::from_fn(generics.ty_params.len(), |i| {\n         let id = generics.ty_params.get(i).id;\n         ty::mk_param(tcx, i, ast_util::local_def(id))\n     })\n }\n \n /// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty(cx: ctxt, t: t) -> t {\n+pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     let u = TypeNormalizer(cx).fold_ty(t);\n     return u;\n \n-    struct TypeNormalizer(ctxt);\n+    struct TypeNormalizer<'a>(&'a ctxt);\n \n-    impl TypeFolder for TypeNormalizer {\n-        fn tcx(&self) -> ty::ctxt { let TypeNormalizer(c) = *self; c }\n+    impl<'a> TypeFolder for TypeNormalizer<'a> {\n+        fn tcx<'a>(&'a self) -> &'a ctxt { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             let normalized_opt = {\n@@ -4476,16 +4467,16 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n \n pub trait ExprTyProvider {\n     fn expr_ty(&self, ex: &ast::Expr) -> t;\n-    fn ty_ctxt(&self) -> ctxt;\n+    fn ty_ctxt<'a>(&'a self) -> &'a ctxt;\n }\n \n impl ExprTyProvider for ctxt {\n     fn expr_ty(&self, ex: &ast::Expr) -> t {\n-        expr_ty(*self, ex)\n+        expr_ty(self, ex)\n     }\n \n-    fn ty_ctxt(&self) -> ctxt {\n-        *self\n+    fn ty_ctxt<'a>(&'a self) -> &'a ctxt {\n+        self\n     }\n }\n \n@@ -4555,7 +4546,7 @@ pub fn determine_inherited_purity(parent: (ast::Purity, ast::NodeId),\n // Here, the supertraits are the transitive closure of the supertrait\n // relation on the supertraits from each bounded trait's constraint\n // list.\n-pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n+pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n                                         bounds: &[@TraitRef],\n                                         f: |@TraitRef| -> bool)\n                                         -> bool {\n@@ -4598,7 +4589,7 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n     return true;\n }\n \n-pub fn count_traits_and_supertraits(tcx: ctxt,\n+pub fn count_traits_and_supertraits(tcx: &ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n     for type_param_def in type_param_defs.iter() {\n@@ -4611,23 +4602,23 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n     return total;\n }\n \n-pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n+pub fn get_tydesc_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(TyDescStructLangItem).map(|tydesc_lang_item| {\n         let intrinsic_defs = tcx.intrinsic_defs.borrow();\n         intrinsic_defs.get().find_copy(&tydesc_lang_item)\n             .expect(\"Failed to resolve TyDesc\")\n     })\n }\n \n-pub fn get_opaque_ty(tcx: ctxt) -> Result<t, ~str> {\n+pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, ~str> {\n     tcx.lang_items.require(OpaqueStructLangItem).map(|opaque_lang_item| {\n         let intrinsic_defs = tcx.intrinsic_defs.borrow();\n         intrinsic_defs.get().find_copy(&opaque_lang_item)\n             .expect(\"Failed to resolve Opaque\")\n     })\n }\n \n-pub fn visitor_object_ty(tcx: ctxt,\n+pub fn visitor_object_ty(tcx: &ctxt,\n                          region: ty::Region) -> Result<(@TraitRef, t), ~str> {\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n@@ -4648,15 +4639,15 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  EmptyBuiltinBounds())))\n }\n \n-pub fn item_variances(tcx: ctxt, item_id: ast::DefId) -> @ItemVariances {\n+pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n     let mut item_variance_map = tcx.item_variance_map.borrow_mut();\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, item_variance_map.get(),\n-        || @csearch::get_item_variances(tcx.cstore, item_id))\n+        || @csearch::get_item_variances(&tcx.sess.cstore, item_id))\n }\n \n /// Records a trait-to-implementation mapping.\n-fn record_trait_implementation(tcx: ctxt,\n+fn record_trait_implementation(tcx: &ctxt,\n                                trait_def_id: DefId,\n                                implementation: @Impl) {\n     let implementation_list;\n@@ -4677,7 +4668,7 @@ fn record_trait_implementation(tcx: ctxt,\n \n /// Populates the type context with all the implementations for the given type\n /// if necessary.\n-pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n+pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n                                                       type_id: ast::DefId) {\n     if type_id.krate == LOCAL_CRATE {\n         return\n@@ -4689,7 +4680,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n         }\n     }\n \n-    csearch::each_implementation_for_type(tcx.sess.cstore, type_id,\n+    csearch::each_implementation_for_type(&tcx.sess.cstore, type_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4745,7 +4736,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n /// Populates the type context with all the implementations for the given\n /// trait if necessary.\n pub fn populate_implementations_for_trait_if_necessary(\n-        tcx: ctxt,\n+        tcx: &ctxt,\n         trait_id: ast::DefId) {\n     if trait_id.krate == LOCAL_CRATE {\n         return\n@@ -4758,7 +4749,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n         }\n     }\n \n-    csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id,\n+    csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n             |implementation_def_id| {\n         let implementation = @csearch::get_impl(tcx, implementation_def_id);\n \n@@ -4787,7 +4778,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n /// Given the def_id of an impl, return the def_id of the trait it implements.\n /// If it implements no trait, return `None`.\n-pub fn trait_id_of_impl(tcx: ctxt,\n+pub fn trait_id_of_impl(tcx: &ctxt,\n                         def_id: ast::DefId) -> Option<ast::DefId> {\n     let node = match tcx.map.find(def_id.node) {\n         Some(node) => node,\n@@ -4809,10 +4800,10 @@ pub fn trait_id_of_impl(tcx: ctxt,\n /// If the given def ID describes a method belonging to a trait (either a\n /// default method or an implementation of a trait method), return the ID of\n /// the trait that the method belongs to. Otherwise, return `None`.\n-pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n+pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n                        -> Option<ast::DefId> {\n     if def_id.krate != LOCAL_CRATE {\n-        return csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n+        return csearch::get_trait_of_method(&tcx.sess.cstore, def_id, tcx);\n     }\n     let method;\n     {\n@@ -4836,7 +4827,7 @@ pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n /// is already that of the original trait method, then the return value is\n /// the same).\n /// Otherwise, return `None`.\n-pub fn trait_method_of_method(tcx: ctxt,\n+pub fn trait_method_of_method(tcx: &ctxt,\n                               def_id: ast::DefId) -> Option<ast::DefId> {\n     let method;\n     {\n@@ -4860,7 +4851,7 @@ pub fn trait_method_of_method(tcx: ctxt,\n \n /// Creates a hash of the type `t` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: ctxt, t: t, svh: &Svh) -> u64 {\n+pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n     macro_rules! byte( ($b:expr) => { ($b as u8).hash(&mut state) } );\n     macro_rules! hash( ($e:expr) => { $e.hash(&mut state) } );\n@@ -5014,7 +5005,7 @@ impl Variance {\n }\n \n pub fn construct_parameter_environment(\n-    tcx: ctxt,\n+    tcx: &ctxt,\n     self_bound: Option<@TraitRef>,\n     item_type_params: &[TypeParameterDef],\n     method_type_params: &[TypeParameterDef],"}, {"sha": "2456c6073177d89aafa962ef24ad29ed42112e29", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -16,7 +16,7 @@ use util::ppaux::Repr;\n use std::vec_ng::Vec;\n \n pub trait TypeFolder {\n-    fn tcx(&self) -> ty::ctxt;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n \n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         super_fold_ty(self, t)\n@@ -93,7 +93,8 @@ pub fn fold_ty_vec<T:TypeFolder>(this: &mut T, tys: &[ty::t]) -> Vec<ty::t> {\n pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n                                    t: ty::t)\n                                    -> ty::t {\n-    ty::mk_t(this.tcx(), this.fold_sty(&ty::get(t).sty))\n+    let sty = this.fold_sty(&ty::get(t).sty);\n+    ty::mk_t(this.tcx(), sty)\n }\n \n pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n@@ -218,12 +219,12 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n // Some sample folders\n \n pub struct BottomUpFolder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     fldop: 'a |ty::t| -> ty::t,\n }\n \n impl<'a> TypeFolder for BottomUpFolder<'a> {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         let t1 = super_fold_ty(self, ty);\n@@ -235,13 +236,13 @@ impl<'a> TypeFolder for BottomUpFolder<'a> {\n // Region folder\n \n pub struct RegionFolder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     fld_t: 'a |ty::t| -> ty::t,\n     fld_r: 'a |ty::Region| -> ty::Region,\n }\n \n impl<'a> RegionFolder<'a> {\n-    pub fn general(tcx: ty::ctxt,\n+    pub fn general(tcx: &'a ty::ctxt,\n                    fld_r: 'a |ty::Region| -> ty::Region,\n                    fld_t: 'a |ty::t| -> ty::t)\n                    -> RegionFolder<'a> {\n@@ -252,7 +253,7 @@ impl<'a> RegionFolder<'a> {\n         }\n     }\n \n-    pub fn regions(tcx: ty::ctxt, fld_r: 'a |ty::Region| -> ty::Region)\n+    pub fn regions(tcx: &'a ty::ctxt, fld_r: 'a |ty::Region| -> ty::Region)\n                    -> RegionFolder<'a> {\n         fn noop(t: ty::t) -> ty::t { t }\n \n@@ -265,7 +266,7 @@ impl<'a> RegionFolder<'a> {\n }\n \n impl<'a> TypeFolder for RegionFolder<'a> {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n         debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));"}, {"sha": "658538bcec85c2defe31ce9b733c75d0e021a4f2", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -20,7 +20,7 @@\n  * `AstConv` instance; in this phase, the `get_item_ty()` function\n  * triggers a recursive call to `ty_of_item()`  (note that\n  * `ast_ty_to_ty()` will detect recursive types and report an error).\n- * In the check phase, when the @FnCtxt is used as the `AstConv`,\n+ * In the check phase, when the FnCtxt is used as the `AstConv`,\n  * `get_item_ty()` just looks up the item type in `tcx.tcache`.\n  *\n  * The `RegionScope` trait controls what happens when the user does\n@@ -69,18 +69,17 @@ use syntax::opt_vec;\n use syntax::print::pprust::{lifetime_to_str, path_to_str};\n \n pub trait AstConv {\n-    fn tcx(&self) -> ty::ctxt;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty;\n     fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef;\n \n     // what type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> ty::t;\n }\n \n-pub fn ast_region_to_region(tcx: ty::ctxt, lifetime: &ast::Lifetime)\n+pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n                             -> ty::Region {\n-    let named_region_map = tcx.named_region_map.borrow();\n-    let r = match named_region_map.get().find(&lifetime.id) {\n+    let r = match tcx.named_region_map.find(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n             tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n@@ -304,7 +303,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>(\n pub static NO_REGIONS: uint = 1;\n pub static NO_TPS: uint = 2;\n \n-fn check_path_args(tcx: ty::ctxt,\n+fn check_path_args(tcx: &ty::ctxt,\n                    path: &ast::Path,\n                    flags: uint) {\n     if (flags & NO_TPS) != 0u {\n@@ -324,7 +323,7 @@ fn check_path_args(tcx: ty::ctxt,\n     }\n }\n \n-pub fn ast_ty_to_prim_ty(tcx: ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n+pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n             let def_map = tcx.def_map.borrow();\n@@ -393,7 +392,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         VStore(ty::vstore)\n     }\n     impl PointerTy {\n-        fn expect_vstore(&self, tcx: ty::ctxt, span: Span, ty: &str) -> ty::vstore {\n+        fn expect_vstore(&self, tcx: &ty::ctxt, span: Span, ty: &str) -> ty::vstore {\n             match *self {\n                 Box => {\n                     tcx.sess.span_err(span, format!(\"managed {} are not supported\", ty));\n@@ -614,7 +613,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 }\n             }\n             ast::TyFixedLengthVec(ty, e) => {\n-                match const_eval::eval_const_expr_partial(&tcx, e) {\n+                match const_eval::eval_const_expr_partial(tcx, e) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n@@ -818,7 +817,7 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     }\n }\n \n-fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBound>>,\n+fn conv_builtin_bounds(tcx: &ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBound>>,\n                        store: ty::TraitStore)\n                        -> ty::BuiltinBounds {\n     //! Converts a list of bounds from the AST into a `BuiltinBounds`"}, {"sha": "bfb0ab6400d38dec4dffd6329a6a8be339e4d9f6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -27,7 +27,7 @@ use syntax::parse::token;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n \n-pub fn check_match(fcx: @FnCtxt,\n+pub fn check_match(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    discrim: &ast::Expr,\n                    arms: &[ast::Arm]) {\n@@ -103,8 +103,8 @@ pub fn check_match(fcx: @FnCtxt,\n     fcx.write_ty(expr.id, result_ty);\n }\n \n-pub struct pat_ctxt {\n-    fcx: @FnCtxt,\n+pub struct pat_ctxt<'a> {\n+    fcx: &'a FnCtxt<'a>,\n     map: PatIdMap,\n }\n "}, {"sha": "dc9aa1b7e8cb23c257c46a6d3826936b7ef85069", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -46,7 +46,7 @@ pub fn suptype_with_fn(fcx: &FnCtxt,\n     }\n }\n \n-pub fn eqtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: &FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n     match infer::mk_eqty(fcx.infcx(), false, infer::Misc(sp), actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -56,7 +56,7 @@ pub fn eqtype(fcx: @FnCtxt, sp: Span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: @FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n+pub fn coerce(fcx: &FnCtxt, sp: Span, expected: ty::t, expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       result::Ok(()) => { /* ok */ }"}, {"sha": "5d232b488a6a70f46ec15a8bbd1907ba37af8fba", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 145, "deletions": 159, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -95,7 +95,6 @@ use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n-use std::cell::RefCell;\n use collections::HashSet;\n use std::result;\n use std::vec_ng::Vec;\n@@ -120,7 +119,7 @@ pub enum AutoderefReceiverFlag {\n }\n \n pub fn lookup<'a>(\n-        fcx: @FnCtxt,\n+        fcx: &'a FnCtxt<'a>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         expr: &ast::Expr,                   // The expression `a.b(...)`.\n@@ -132,15 +131,15 @@ pub fn lookup<'a>(\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n-    let lcx = LookupContext {\n+    let mut lcx = LookupContext {\n         fcx: fcx,\n         span: expr.span,\n         self_expr: Some(self_expr),\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(Vec::new()),\n-        extension_candidates: @RefCell::new(Vec::new()),\n+        impl_dups: HashSet::new(),\n+        inherent_candidates: Vec::new(),\n+        extension_candidates: Vec::new(),\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n@@ -161,11 +160,11 @@ pub fn lookup<'a>(\n     lcx.reset_candidates();\n     lcx.push_bound_candidates(self_ty, None);\n     lcx.push_extension_candidates(expr.id);\n-    return lcx.search(self_ty);\n+    lcx.search(self_ty)\n }\n \n pub fn lookup_in_trait<'a>(\n-        fcx: @FnCtxt,\n+        fcx: &'a FnCtxt<'a>,\n \n         // In a call `a.b::<X, Y, ...>(...)`:\n         span: Span,                         // The expression `a.b(...)`'s span.\n@@ -176,15 +175,15 @@ pub fn lookup_in_trait<'a>(\n         supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n-    let lcx = LookupContext {\n+    let mut lcx = LookupContext {\n         fcx: fcx,\n         span: span,\n         self_expr: self_expr,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(Vec::new()),\n-        extension_candidates: @RefCell::new(Vec::new()),\n+        impl_dups: HashSet::new(),\n+        inherent_candidates: Vec::new(),\n+        extension_candidates: Vec::new(),\n         deref_args: check::DoDerefArgs,\n         check_traits: CheckTraitsOnly,\n         autoderef_receiver: autoderef_receiver,\n@@ -198,8 +197,93 @@ pub fn lookup_in_trait<'a>(\n     lcx.search(self_ty)\n }\n \n+\n+\n+// Determine the index of a method in the list of all methods belonging\n+// to a trait and its supertraits.\n+fn get_method_index(tcx: &ty::ctxt,\n+                    trait_ref: &TraitRef,\n+                    subtrait: @TraitRef,\n+                    n_method: uint) -> uint {\n+    // We need to figure the \"real index\" of the method in a\n+    // listing of all the methods of an object. We do this by\n+    // iterating down the supertraits of the object's trait until\n+    // we find the trait the method came from, counting up the\n+    // methods from them.\n+    let mut method_count = 0;\n+    ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n+        if bound_ref.def_id == trait_ref.def_id { false }\n+            else {\n+            method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n+            true\n+        }\n+    });\n+    method_count + n_method\n+}\n+\n+fn construct_transformed_self_ty_for_object(\n+    tcx: &ty::ctxt,\n+    span: Span,\n+    trait_def_id: ast::DefId,\n+    rcvr_substs: &ty::substs,\n+    method_ty: &ty::Method)\n+    -> ty::t {\n+    /*!\n+        * This is a bit tricky. We have a match against a trait method\n+        * being invoked on an object, and we want to generate the\n+        * self-type. As an example, consider a trait\n+        *\n+        *     trait Foo {\n+        *         fn r_method<'a>(&'a self);\n+        *         fn u_method(~self);\n+        *     }\n+        *\n+        * Now, assuming that `r_method` is being called, we want the\n+        * result to be `&'a Foo`. Assuming that `u_method` is being\n+        * called, we want the result to be `~Foo`. Of course,\n+        * this transformation has already been done as part of\n+        * `method_ty.fty.sig.inputs[0]`, but there the type\n+        * is expressed in terms of `Self` (i.e., `&'a Self`, `~Self`).\n+        * Because objects are not standalone types, we can't just substitute\n+        * `s/Self/Foo/`, so we must instead perform this kind of hokey\n+        * match below.\n+        */\n+\n+    let substs = ty::substs {regions: rcvr_substs.regions.clone(),\n+                                self_ty: None,\n+                                tps: rcvr_substs.tps.clone()};\n+    match method_ty.explicit_self {\n+        ast::SelfStatic => {\n+            tcx.sess.span_bug(span, \"static method for object type receiver\");\n+        }\n+        ast::SelfValue => {\n+            ty::mk_err() // error reported in `enforce_object_limitations()`\n+        }\n+        ast::SelfRegion(..) | ast::SelfUniq => {\n+            let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n+            match ty::get(transformed_self_ty).sty {\n+                ty::ty_rptr(r, mt) => { // must be SelfRegion\n+                    ty::mk_trait(tcx, trait_def_id, substs,\n+                                 RegionTraitStore(r), mt.mutbl,\n+                                 ty::EmptyBuiltinBounds())\n+                }\n+                ty::ty_uniq(_) => { // must be SelfUniq\n+                    ty::mk_trait(tcx, trait_def_id, substs,\n+                                 UniqTraitStore, ast::MutImmutable,\n+                                 ty::EmptyBuiltinBounds())\n+                }\n+                _ => {\n+                    tcx.sess.span_bug(span,\n+                        format!(\"'impossible' transformed_self_ty: {}\",\n+                                transformed_self_ty.repr(tcx)));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n struct LookupContext<'a> {\n-    fcx: @FnCtxt,\n+    fcx: &'a FnCtxt<'a>,\n     span: Span,\n \n     // The receiver to the method call. Only `None` in the case of\n@@ -210,9 +294,9 @@ struct LookupContext<'a> {\n \n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n-    impl_dups: @RefCell<HashSet<DefId>>,\n-    inherent_candidates: @RefCell<Vec<Candidate> >,\n-    extension_candidates: @RefCell<Vec<Candidate> >,\n+    impl_dups: HashSet<DefId>,\n+    inherent_candidates: Vec<Candidate>,\n+    extension_candidates: Vec<Candidate>,\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n@@ -315,12 +399,12 @@ impl<'a> LookupContext<'a> {\n     // ______________________________________________________________________\n     // Candidate collection (see comment at start of file)\n \n-    fn reset_candidates(&self) {\n-        self.inherent_candidates.set(Vec::new());\n-        self.extension_candidates.set(Vec::new());\n+    fn reset_candidates(&mut self) {\n+        self.inherent_candidates = Vec::new();\n+        self.extension_candidates = Vec::new();\n     }\n \n-    fn push_inherent_candidates(&self, self_ty: ty::t) {\n+    fn push_inherent_candidates(&mut self, self_ty: ty::t) {\n         /*!\n          * Collect all inherent candidates into\n          * `self.inherent_candidates`.  See comment at the start of\n@@ -354,7 +438,7 @@ impl<'a> LookupContext<'a> {\n         });\n     }\n \n-    fn push_bound_candidates(&self, self_ty: ty::t, restrict_to: Option<DefId>) {\n+    fn push_bound_candidates(&mut self, self_ty: ty::t, restrict_to: Option<DefId>) {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n@@ -378,20 +462,18 @@ impl<'a> LookupContext<'a> {\n         });\n     }\n \n-    fn push_extension_candidate(&self, trait_did: DefId) {\n+    fn push_extension_candidate(&mut self, trait_did: DefId) {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n \n         // Look for explicit implementations.\n-        let trait_impls = self.tcx().trait_impls.borrow();\n-        for impl_infos in trait_impls.get().find(&trait_did).iter() {\n+        for impl_infos in self.tcx().trait_impls.borrow().get().find(&trait_did).iter() {\n             for impl_info in impl_infos.borrow().get().iter() {\n-                self.push_candidates_from_impl(\n-                    self.extension_candidates.borrow_mut().get(), *impl_info);\n+                self.push_candidates_from_impl(*impl_info, true);\n             }\n         }\n     }\n \n-    fn push_extension_candidates(&self, expr_id: ast::NodeId) {\n+    fn push_extension_candidates(&mut self, expr_id: ast::NodeId) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n@@ -403,38 +485,15 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    // Determine the index of a method in the list of all methods belonging\n-    // to a trait and its supertraits.\n-    fn get_method_index(&self,\n-                        trait_ref: @TraitRef,\n-                        subtrait: @TraitRef,\n-                        n_method: uint) -> uint {\n-        let tcx = self.tcx();\n-\n-        // We need to figure the \"real index\" of the method in a\n-        // listing of all the methods of an object. We do this by\n-        // iterating down the supertraits of the object's trait until\n-        // we find the trait the method came from, counting up the\n-        // methods from them.\n-        let mut method_count = 0;\n-        ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-            if bound_ref.def_id == trait_ref.def_id { false }\n-                else {\n-                method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n-                true\n-            }\n-        });\n-        return method_count + n_method;\n-    }\n-\n-\n-    fn push_inherent_candidates_from_object(&self,\n+    fn push_inherent_candidates_from_object(&mut self,\n                                             did: DefId,\n                                             substs: &ty::substs) {\n         debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n                substs.repr(self.tcx()));\n         let _indenter = indenter();\n+        let tcx = self.tcx();\n+        let span = self.span;\n \n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `self` type. An error will be reported by\n@@ -452,13 +511,13 @@ impl<'a> LookupContext<'a> {\n \n         self.push_inherent_candidates_from_bounds_inner(&[trait_ref],\n             |new_trait_ref, m, method_num, _bound_num| {\n-            let vtable_index =\n-                self.get_method_index(new_trait_ref, trait_ref, method_num);\n+            let vtable_index = get_method_index(tcx, new_trait_ref,\n+                                                trait_ref, method_num);\n             let mut m = (*m).clone();\n             // We need to fix up the transformed self type.\n             *m.fty.sig.inputs.get_mut(0) =\n-                self.construct_transformed_self_ty_for_object(\n-                    did, &rcvr_substs, &m);\n+                construct_transformed_self_ty_for_object(\n+                    tcx, span, did, &rcvr_substs, &m);\n \n             Some(Candidate {\n                 rcvr_match_condition: RcvrMatchesIfObject(did),\n@@ -474,7 +533,7 @@ impl<'a> LookupContext<'a> {\n         });\n     }\n \n-    fn push_inherent_candidates_from_param(&self,\n+    fn push_inherent_candidates_from_param(&mut self,\n                                            rcvr_ty: ty::t,\n                                            restrict_to: Option<DefId>,\n                                            param_ty: param_ty) {\n@@ -494,7 +553,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n \n-    fn push_inherent_candidates_from_self(&self,\n+    fn push_inherent_candidates_from_self(&mut self,\n                                           rcvr_ty: ty::t,\n                                           restrict_to: Option<DefId>) {\n         debug!(\"push_inherent_candidates_from_self()\");\n@@ -505,7 +564,7 @@ impl<'a> LookupContext<'a> {\n             param_self)\n     }\n \n-    fn push_inherent_candidates_from_bounds(&self,\n+    fn push_inherent_candidates_from_bounds(&mut self,\n                                             self_ty: ty::t,\n                                             bounds: &[@TraitRef],\n                                             restrict_to: Option<DefId>,\n@@ -536,7 +595,7 @@ impl<'a> LookupContext<'a> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn push_inherent_candidates_from_bounds_inner(&self,\n+    fn push_inherent_candidates_from_bounds_inner(&mut self,\n                                                   bounds: &[@TraitRef],\n                                                   mk_cand: |tr: @TraitRef,\n                                                             m: @ty::Method,\n@@ -561,7 +620,7 @@ impl<'a> LookupContext<'a> {\n                         Some(cand) => {\n                             debug!(\"pushing inherent candidate for param: {}\",\n                                    cand.repr(self.tcx()));\n-                            self.inherent_candidates.borrow_mut().get().push(cand);\n+                            self.inherent_candidates.push(cand);\n                         }\n                         None => {}\n                     }\n@@ -577,32 +636,23 @@ impl<'a> LookupContext<'a> {\n     }\n \n \n-    fn push_inherent_impl_candidates_for_type(&self, did: DefId) {\n+    fn push_inherent_impl_candidates_for_type(&mut self, did: DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        let inherent_impls = self.tcx().inherent_impls.borrow();\n-        let opt_impl_infos = inherent_impls.get().find(&did);\n-        for impl_infos in opt_impl_infos.iter() {\n-            let impl_infos = impl_infos.borrow();\n-            for impl_info in impl_infos.get().iter() {\n-                let mut inherent_candidates = self.inherent_candidates\n-                                                  .borrow_mut();\n-                self.push_candidates_from_impl(inherent_candidates.get(),\n-                                               *impl_info);\n+        for impl_infos in self.tcx().inherent_impls.borrow().get().find(&did).iter() {\n+            for impl_info in impl_infos.borrow().get().iter() {\n+                self.push_candidates_from_impl(*impl_info, false);\n             }\n         }\n     }\n \n-    fn push_candidates_from_impl(&self,\n-                                 candidates: &mut Vec<Candidate>,\n-                                 impl_info: &ty::Impl) {\n-        {\n-            let mut impl_dups = self.impl_dups.borrow_mut();\n-            if !impl_dups.get().insert(impl_info.did) {\n-                return; // already visited\n-            }\n+    fn push_candidates_from_impl(&mut self,\n+                                 impl_info: &ty::Impl,\n+                                 is_extension: bool) {\n+        if !self.impl_dups.insert(impl_info.did) {\n+            return; // already visited\n         }\n \n         debug!(\"push_candidates_from_impl: {} {} {}\",\n@@ -631,6 +681,12 @@ impl<'a> LookupContext<'a> {\n             ty: impl_ty\n         } = impl_self_ty(&vcx, span, impl_info.did);\n \n+        let candidates = if is_extension {\n+            &mut self.extension_candidates\n+        } else {\n+            &mut self.inherent_candidates\n+        };\n+\n         candidates.push(Candidate {\n             rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n             rcvr_substs: impl_substs,\n@@ -913,28 +969,19 @@ impl<'a> LookupContext<'a> {\n         // existing code.\n \n         debug!(\"searching inherent candidates\");\n-        let mut inherent_candidates = self.inherent_candidates.borrow_mut();\n-        match self.consider_candidates(rcvr_ty, inherent_candidates.get()) {\n+        match self.consider_candidates(rcvr_ty, self.inherent_candidates.as_slice()) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        let mut extension_candidates = self.extension_candidates.borrow_mut();\n-        match self.consider_candidates(rcvr_ty, extension_candidates.get()) {\n-            None => {\n-                return None;\n-            }\n-            Some(mme) => {\n-                return Some(mme);\n-            }\n-        }\n+        self.consider_candidates(rcvr_ty, self.extension_candidates.as_slice())\n     }\n \n     fn consider_candidates(&self, rcvr_ty: ty::t,\n-                           candidates: &mut Vec<Candidate>)\n+                           candidates: &[Candidate])\n                            -> Option<MethodCallee> {\n         // FIXME(pcwalton): Do we need to clone here?\n         let relevant_candidates: Vec<Candidate> =\n@@ -1140,66 +1187,6 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn construct_transformed_self_ty_for_object(\n-        &self,\n-        trait_def_id: ast::DefId,\n-        rcvr_substs: &ty::substs,\n-        method_ty: &ty::Method)\n-        -> ty::t {\n-        /*!\n-         * This is a bit tricky. We have a match against a trait method\n-         * being invoked on an object, and we want to generate the\n-         * self-type. As an example, consider a trait\n-         *\n-         *     trait Foo {\n-         *         fn r_method<'a>(&'a self);\n-         *         fn u_method(~self);\n-         *     }\n-         *\n-         * Now, assuming that `r_method` is being called, we want the\n-         * result to be `&'a Foo`. Assuming that `u_method` is being\n-         * called, we want the result to be `~Foo`. Of course,\n-         * this transformation has already been done as part of\n-         * `method_ty.fty.sig.inputs[0]`, but there the type\n-         * is expressed in terms of `Self` (i.e., `&'a Self`, `~Self`).\n-         * Because objects are not standalone types, we can't just substitute\n-         * `s/Self/Foo/`, so we must instead perform this kind of hokey\n-         * match below.\n-         */\n-\n-        let substs = ty::substs {regions: rcvr_substs.regions.clone(),\n-                                 self_ty: None,\n-                                 tps: rcvr_substs.tps.clone()};\n-        match method_ty.explicit_self {\n-            ast::SelfStatic => {\n-                self.bug(\"static method for object type receiver\");\n-            }\n-            ast::SelfValue => {\n-                ty::mk_err() // error reported in `enforce_object_limitations()`\n-            }\n-            ast::SelfRegion(..) | ast::SelfUniq => {\n-                let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n-                match ty::get(transformed_self_ty).sty {\n-                    ty::ty_rptr(r, mt) => { // must be SelfRegion\n-                        ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, RegionTraitStore(r), mt.mutbl,\n-                                     ty::EmptyBuiltinBounds())\n-                    }\n-                    ty::ty_uniq(_) => { // must be SelfUniq\n-                        ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, UniqTraitStore, ast::MutImmutable,\n-                                     ty::EmptyBuiltinBounds())\n-                    }\n-                    _ => {\n-                        self.bug(\n-                            format!(\"'impossible' transformed_self_ty: {}\",\n-                                 transformed_self_ty.repr(self.tcx())));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn enforce_object_limitations(&self, candidate: &Candidate) {\n         /*!\n          * There are some limitations to calling functions through an\n@@ -1351,7 +1338,7 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        fn rcvr_matches_ty(fcx: @FnCtxt,\n+        fn rcvr_matches_ty(fcx: &FnCtxt,\n                            rcvr_ty: ty::t,\n                            candidate: &Candidate) -> bool {\n             match candidate.rcvr_match_condition {\n@@ -1422,11 +1409,11 @@ impl<'a> LookupContext<'a> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&'a self) -> &'a infer::InferCtxt {\n+    fn infcx(&'a self) -> &'a infer::InferCtxt<'a> {\n         &self.fcx.inh.infcx\n     }\n \n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n \n@@ -1439,13 +1426,12 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn bug(&self, s: &str) -> ! {\n-        let span = self.self_expr.map_or(self.span, |e| e.span);\n-        self.tcx().sess.span_bug(span, s)\n+        self.tcx().sess.span_bug(self.span, s)\n     }\n }\n \n impl Repr for Candidate {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"Candidate(rcvr_ty={}, rcvr_substs={}, origin={:?})\",\n                 self.rcvr_match_condition.repr(tcx),\n                 self.rcvr_substs.repr(tcx),\n@@ -1454,7 +1440,7 @@ impl Repr for Candidate {\n }\n \n impl Repr for RcvrMatchCondition {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             RcvrMatchesIfObject(d) => {\n                 format!(\"RcvrMatchesIfObject({})\", d.repr(tcx))"}, {"sha": "205c1c106dd165d6adf7c997d7ad4923447a90d2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 138, "deletions": 132, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -155,8 +155,8 @@ pub mod method;\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct Inherited {\n-    infcx: infer::InferCtxt,\n+pub struct Inherited<'a> {\n+    infcx: infer::InferCtxt<'a>,\n     locals: @RefCell<NodeMap<ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n@@ -221,7 +221,7 @@ enum IsBinopAssignment{\n }\n \n #[deriving(Clone)]\n-pub struct FnCtxt {\n+pub struct FnCtxt<'a> {\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n@@ -251,15 +251,15 @@ pub struct FnCtxt {\n     // function return type.\n     fn_kind: FnKind,\n \n-    inh: @Inherited,\n+    inh: &'a Inherited<'a>,\n \n-    ccx: @CrateCtxt,\n+    ccx: &'a CrateCtxt<'a>,\n }\n \n-impl Inherited {\n-    fn new(tcx: ty::ctxt,\n+impl<'a> Inherited<'a> {\n+    fn new(tcx: &'a ty::ctxt,\n            param_env: ty::ParameterEnvironment)\n-           -> Inherited {\n+           -> Inherited<'a> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n             locals: @RefCell::new(NodeMap::new()),\n@@ -275,77 +275,81 @@ impl Inherited {\n }\n \n // Used by check_const and check_enum_variants\n-pub fn blank_fn_ctxt(ccx: @CrateCtxt,\n+fn blank_fn_ctxt<'a>(ccx: &'a CrateCtxt<'a>,\n+                     inh: &'a Inherited<'a>,\n                      rty: ty::t,\n                      region_bnd: ast::NodeId)\n-                     -> @FnCtxt {\n-    // It's kind of a kludge to manufacture a fake function context\n-    // and statement context, but we might as well do write the code only once\n-    let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n-                                               self_param_bound: None,\n-                                               type_param_bounds: Vec::new() };\n-    @FnCtxt {\n+                     -> FnCtxt<'a> {\n+    FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n         ps: RefCell::new(PurityState::function(ast::ImpureFn, 0)),\n         region_lb: Cell::new(region_bnd),\n         fn_kind: Vanilla,\n-        inh: @Inherited::new(ccx.tcx, param_env),\n+        inh: inh,\n         ccx: ccx\n     }\n }\n \n-impl ExprTyProvider for FnCtxt {\n+fn blank_inherited_fields<'a>(ccx: &'a CrateCtxt<'a>) -> Inherited<'a> {\n+    // It's kind of a kludge to manufacture a fake function context\n+    // and statement context, but we might as well do write the code only once\n+    let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n+                                               self_param_bound: None,\n+                                               type_param_bounds: Vec::new() };\n+    Inherited::new(ccx.tcx, param_env)\n+}\n+\n+impl<'a> ExprTyProvider for FnCtxt<'a> {\n     fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n         self.expr_ty(ex)\n     }\n \n-    fn ty_ctxt(&self) -> ty::ctxt {\n+    fn ty_ctxt<'a>(&'a self) -> &'a ty::ctxt {\n         self.ccx.tcx\n     }\n }\n \n-struct CheckItemTypesVisitor { ccx: @CrateCtxt }\n+struct CheckItemTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n \n-impl Visitor<()> for CheckItemTypesVisitor {\n+impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         check_item(self.ccx, i);\n         visit::walk_item(self, i, ());\n     }\n }\n \n-pub fn check_item_types(ccx: @CrateCtxt, krate: &ast::Crate) {\n+pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate, ());\n }\n \n-fn check_bare_fn(ccx: @CrateCtxt,\n+fn check_bare_fn(ccx: &CrateCtxt,\n                  decl: &ast::FnDecl,\n                  body: &ast::Block,\n                  id: ast::NodeId,\n                  fty: ty::t,\n                  param_env: ty::ParameterEnvironment) {\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            let fcx =\n-                check_fn(ccx, fn_ty.purity, &fn_ty.sig, decl, id, body,\n-                         Vanilla, @Inherited::new(ccx.tcx, param_env));\n+            let inh = Inherited::new(ccx.tcx, param_env);\n+            let fcx = check_fn(ccx, fn_ty.purity, &fn_ty.sig,\n+                               decl, id, body, Vanilla, &inh);\n \n-            vtable::resolve_in_block(fcx, body);\n-            regionck::regionck_fn(fcx, body);\n-            writeback::resolve_type_vars_in_fn(fcx, decl, body);\n+            vtable::resolve_in_block(&fcx, body);\n+            regionck::regionck_fn(&fcx, body);\n+            writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n     }\n }\n \n-struct GatherLocalsVisitor {\n-                     fcx: @FnCtxt,\n-                     tcx: ty::ctxt,\n+struct GatherLocalsVisitor<'a> {\n+    fcx: &'a FnCtxt<'a>\n }\n \n-impl GatherLocalsVisitor {\n+impl<'a> GatherLocalsVisitor<'a> {\n     fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n             match ty_opt {\n                 None => {\n@@ -364,7 +368,7 @@ impl GatherLocalsVisitor {\n     }\n }\n \n-impl Visitor<()> for GatherLocalsVisitor {\n+impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n         // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n             let o_ty = match local.ty.node {\n@@ -416,14 +420,14 @@ impl Visitor<()> for GatherLocalsVisitor {\n \n }\n \n-fn check_fn(ccx: @CrateCtxt,\n-            purity: ast::Purity,\n-            fn_sig: &ty::FnSig,\n-            decl: &ast::FnDecl,\n-            id: ast::NodeId,\n-            body: &ast::Block,\n-            fn_kind: FnKind,\n-            inherited: @Inherited) -> @FnCtxt\n+fn check_fn<'a>(ccx: &'a CrateCtxt<'a>,\n+                purity: ast::Purity,\n+                fn_sig: &ty::FnSig,\n+                decl: &ast::FnDecl,\n+                id: ast::NodeId,\n+                body: &ast::Block,\n+                fn_kind: FnKind,\n+                inherited: &'a Inherited<'a>) -> FnCtxt<'a>\n {\n     /*!\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n@@ -455,7 +459,7 @@ fn check_fn(ccx: @CrateCtxt,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx = @FnCtxt {\n+    let fcx = FnCtxt {\n         err_count_on_creation: err_count_on_creation,\n         ret_ty: ret_ty,\n         ps: RefCell::new(PurityState::function(purity, id)),\n@@ -467,7 +471,7 @@ fn check_fn(ccx: @CrateCtxt,\n \n     {\n \n-        let mut visit = GatherLocalsVisitor { fcx: fcx, tcx: tcx, };\n+        let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(decl.inputs.iter()) {\n             // Create type variables for each argument.\n@@ -479,7 +483,7 @@ fn check_fn(ccx: @CrateCtxt,\n \n             // Check the pattern.\n             let pcx = pat_ctxt {\n-                fcx: fcx,\n+                fcx: &fcx,\n                 map: pat_id_map(tcx.def_map, input.pat),\n             };\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n@@ -488,15 +492,15 @@ fn check_fn(ccx: @CrateCtxt,\n         visit.visit_block(body, ());\n     }\n \n-    check_block_with_expected(fcx, body, Some(ret_ty));\n+    check_block_with_expected(&fcx, body, Some(ret_ty));\n \n     // We unify the tail expr's type with the\n     // function result type, if there is a tail expr.\n     match body.expr {\n         Some(tail_expr) => {\n             // Special case: we print a special error if there appears\n             // to be do-block/for-loop confusion\n-            demand::suptype_with_fn(fcx, tail_expr.span, false,\n+            demand::suptype_with_fn(&fcx, tail_expr.span, false,\n                 fcx.ret_ty, fcx.expr_ty(tail_expr),\n                 |sp, e, a, s| {\n                     fcx.report_mismatched_return_types(sp, e, a, s);\n@@ -512,8 +516,8 @@ fn check_fn(ccx: @CrateCtxt,\n     fcx\n }\n \n-pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n-                                 fields: Vec<(ast::Ident, Span)> ) {\n+pub fn check_no_duplicate_fields(tcx: &ty::ctxt,\n+                                 fields: Vec<(ast::Ident, Span)>) {\n     let mut field_names = HashMap::new();\n \n     for p in fields.iter() {\n@@ -533,7 +537,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n+pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n     // Check that the struct is representable\n@@ -547,7 +551,7 @@ pub fn check_struct(ccx: @CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n+pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -649,7 +653,7 @@ pub fn check_item(ccx: @CrateCtxt, it: &ast::Item) {\n     }\n }\n \n-fn check_method_body(ccx: @CrateCtxt,\n+fn check_method_body(ccx: &CrateCtxt,\n                      item_generics: &ty::Generics,\n                      self_bound: Option<@ty::TraitRef>,\n                      method: &ast::Method) {\n@@ -690,7 +694,7 @@ fn check_method_body(ccx: @CrateCtxt,\n     check_bare_fn(ccx, method.decl, method.body, method.id, fty, param_env);\n }\n \n-fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n+fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n                                     impl_span: Span,\n                                     impl_generics: &ty::Generics,\n                                     ast_trait_ref: &ast::TraitRef,\n@@ -769,7 +773,7 @@ fn check_impl_methods_against_trait(ccx: @CrateCtxt,\n  * - trait_m: the method in the trait\n  * - trait_substs: the substitutions used on the type of the trait\n  */\n-fn compare_impl_method(tcx: ty::ctxt,\n+fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_generics: &ty::Generics,\n                        impl_m: @ty::Method,\n                        impl_m_span: Span,\n@@ -796,7 +800,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                 format!(\"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_str(&impl_m.explicit_self)));\n+                        pprust::explicit_self_to_str(impl_m.explicit_self)));\n             return;\n         }\n         (_, &ast::SelfStatic) => {\n@@ -805,7 +809,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                 format!(\"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_ident(trait_m.ident),\n-                        pprust::explicit_self_to_str(&trait_m.explicit_self)));\n+                        pprust::explicit_self_to_str(trait_m.explicit_self)));\n             return;\n         }\n         _ => {\n@@ -956,8 +960,8 @@ fn compare_impl_method(tcx: ty::ctxt,\n     }\n }\n \n-impl AstConv for FnCtxt {\n-    fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n+impl<'a> AstConv for FnCtxt<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.ccx.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         ty::lookup_item_type(self.tcx(), id)\n@@ -972,8 +976,8 @@ impl AstConv for FnCtxt {\n     }\n }\n \n-impl FnCtxt {\n-    pub fn infcx<'a>(&'a self) -> &'a infer::InferCtxt {\n+impl<'a> FnCtxt<'a> {\n+    pub fn infcx<'b>(&'b self) -> &'b infer::InferCtxt<'a> {\n         &self.inh.infcx\n     }\n \n@@ -989,7 +993,7 @@ impl FnCtxt {\n     }\n }\n \n-impl RegionScope for infer::InferCtxt {\n+impl<'a> RegionScope for infer::InferCtxt<'a> {\n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region> , ()> {\n         Ok(Vec::from_fn(count, |_| {\n@@ -998,7 +1002,7 @@ impl RegionScope for infer::InferCtxt {\n     }\n }\n \n-impl FnCtxt {\n+impl<'a> FnCtxt<'a> {\n     pub fn tag(&self) -> ~str {\n         format!(\"{}\", self as *FnCtxt)\n     }\n@@ -1241,7 +1245,7 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n-pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, base_ty: ty::t,\n+pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n                     expr_id: Option<ast::NodeId>,\n                     mut lvalue_pref: LvaluePreference,\n                     should_stop: |ty::t, uint| -> Option<T>)\n@@ -1292,7 +1296,7 @@ pub fn autoderef<T>(fcx: @FnCtxt, sp: Span, base_ty: ty::t,\n     (ty::mk_err(), 0, None)\n }\n \n-fn try_overloaded_deref(fcx: @FnCtxt,\n+fn try_overloaded_deref(fcx: &FnCtxt,\n                         span: Span,\n                         method_call: Option<MethodCall>,\n                         base_expr: Option<&ast::Expr>,\n@@ -1335,7 +1339,7 @@ fn try_overloaded_deref(fcx: @FnCtxt,\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n+pub fn check_lit(fcx: &FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -1363,7 +1367,7 @@ pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n     }\n }\n \n-pub fn valid_range_bounds(ccx: @CrateCtxt,\n+pub fn valid_range_bounds(ccx: &CrateCtxt,\n                           from: &ast::Expr,\n                           to: &ast::Expr)\n                        -> Option<bool> {\n@@ -1374,40 +1378,40 @@ pub fn valid_range_bounds(ccx: @CrateCtxt,\n }\n \n pub fn check_expr_has_type(\n-    fcx: @FnCtxt, expr: &ast::Expr,\n+    fcx: &FnCtxt, expr: &ast::Expr,\n     expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     });\n }\n \n-fn check_expr_coercable_to_type(fcx: @FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+fn check_expr_coercable_to_type(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n         demand::coerce(fcx, expr.span, expected, expr)\n     });\n }\n \n-fn check_expr_with_hint(fcx: @FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+fn check_expr_with_hint(fcx: &FnCtxt, expr: &ast::Expr, expected: ty::t) {\n     check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || ())\n }\n \n-fn check_expr_with_opt_hint(fcx: @FnCtxt, expr: &ast::Expr,\n+fn check_expr_with_opt_hint(fcx: &FnCtxt, expr: &ast::Expr,\n                             expected: Option<ty::t>)  {\n     check_expr_with_unifier(fcx, expr, expected, NoPreference, || ())\n }\n \n-fn check_expr_with_opt_hint_and_lvalue_pref(fcx: @FnCtxt,\n+fn check_expr_with_opt_hint_and_lvalue_pref(fcx: &FnCtxt,\n                                             expr: &ast::Expr,\n                                             expected: Option<ty::t>,\n                                             lvalue_pref: LvaluePreference) {\n     check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n \n-fn check_expr(fcx: @FnCtxt, expr: &ast::Expr)  {\n+fn check_expr(fcx: &FnCtxt, expr: &ast::Expr)  {\n     check_expr_with_unifier(fcx, expr, None, NoPreference, || ())\n }\n \n-fn check_expr_with_lvalue_pref(fcx: @FnCtxt, expr: &ast::Expr,\n+fn check_expr_with_lvalue_pref(fcx: &FnCtxt, expr: &ast::Expr,\n                                lvalue_pref: LvaluePreference)  {\n     check_expr_with_unifier(fcx, expr, None, lvalue_pref, || ())\n }\n@@ -1444,7 +1448,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n \n // Only for fields! Returns <none> for methods>\n // Indifferent to privacy flags\n-pub fn lookup_field_ty(tcx: ty::ctxt,\n+pub fn lookup_field_ty(tcx: &ty::ctxt,\n                        class_id: ast::DefId,\n                        items: &[ty::field_ty],\n                        fieldname: ast::Name,\n@@ -1463,7 +1467,7 @@ pub enum DerefArgs {\n \n // Given the provenance of a static method, returns the generics of the static\n // method's container.\n-fn generics_of_static_method_container(type_context: ty::ctxt,\n+fn generics_of_static_method_container(type_context: &ty::ctxt,\n                                        provenance: ast::MethodProvenance)\n                                        -> ty::Generics {\n     match provenance {\n@@ -1478,7 +1482,7 @@ fn generics_of_static_method_container(type_context: ty::ctxt,\n \n // Verifies that type parameters supplied in paths are in the right\n // locations.\n-fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n+fn check_type_parameter_positions_in_path(function_context: &FnCtxt,\n                                           path: &ast::Path,\n                                           def: ast::Def) {\n     // We only care about checking the case in which the path has two or\n@@ -1635,15 +1639,15 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for both `ty_err` and\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n-fn check_expr_with_unifier(fcx: @FnCtxt,\n+fn check_expr_with_unifier(fcx: &FnCtxt,\n                            expr: &ast::Expr,\n                            expected: Option<ty::t>,\n                            lvalue_pref: LvaluePreference,\n                            unifier: ||) {\n     debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n-        fcx: @FnCtxt,\n+        fcx: &FnCtxt,\n         sp: Span,\n         method_fn_ty: ty::t,\n         callee_expr: &ast::Expr,\n@@ -1674,7 +1678,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_argument_types(fcx: @FnCtxt,\n+    fn check_argument_types(fcx: &FnCtxt,\n                             sp: Span,\n                             fn_inputs: &[ty::t],\n                             callee_expr: &ast::Expr,\n@@ -1825,12 +1829,12 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         Vec::from_fn(len, |_| ty::mk_err())\n     }\n \n-    fn write_call(fcx: @FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n+    fn write_call(fcx: &FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n         fcx.write_ty(call_expr.id, output);\n     }\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: @FnCtxt,\n+    fn check_call(fcx: &FnCtxt,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n                   args: &[@ast::Expr]) {\n@@ -1879,7 +1883,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     // Checks a method call.\n-    fn check_method_call(fcx: @FnCtxt,\n+    fn check_method_call(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::Ident,\n                          args: &[@ast::Expr],\n@@ -1936,7 +1940,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: @FnCtxt,\n+    fn check_then_else(fcx: &FnCtxt,\n                        cond_expr: &ast::Expr,\n                        then_blk: &ast::Block,\n                        opt_else_expr: Option<@ast::Expr>,\n@@ -1975,7 +1979,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method(fcx: @FnCtxt,\n+    fn lookup_op_method(fcx: &FnCtxt,\n                         op_ex: &ast::Expr,\n                         self_t: ty::t,\n                         opname: ast::Name,\n@@ -2014,7 +2018,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     // could be either an expr_binop or an expr_assign_binop\n-    fn check_binop(fcx: @FnCtxt,\n+    fn check_binop(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n                    lhs: @ast::Expr,\n@@ -2092,7 +2096,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_user_binop(fcx: @FnCtxt,\n+    fn check_user_binop(fcx: &FnCtxt,\n                         ex: &ast::Expr,\n                         lhs_expr: @ast::Expr,\n                         lhs_resolved_t: ty::t,\n@@ -2131,7 +2135,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         })\n     }\n \n-    fn check_user_unop(fcx: @FnCtxt,\n+    fn check_user_unop(fcx: &FnCtxt,\n                        op_str: &str,\n                        mname: &str,\n                        trait_did: Option<ast::DefId>,\n@@ -2151,7 +2155,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n     fn unpack_expected<O>(\n-                       fcx: @FnCtxt,\n+                       fcx: &FnCtxt,\n                        expected: Option<ty::t>,\n                        unpack: |&ty::sty| -> Option<O>)\n                        -> Option<O> {\n@@ -2166,7 +2170,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_expr_fn(fcx: @FnCtxt,\n+    fn check_expr_fn(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::FnDecl,\n@@ -2272,7 +2276,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n \n     // Check field access expressions\n-    fn check_field(fcx: @FnCtxt,\n+    fn check_field(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    lvalue_pref: LvaluePreference,\n                    base: &ast::Expr,\n@@ -2341,7 +2345,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_error(expr.id);\n     }\n \n-    fn check_struct_or_variant_fields(fcx: @FnCtxt,\n+    fn check_struct_or_variant_fields(fcx: &FnCtxt,\n                                       struct_ty: ty::t,\n                                       span: Span,\n                                       class_id: ast::DefId,\n@@ -2429,7 +2433,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n     }\n \n-    fn check_struct_constructor(fcx: @FnCtxt,\n+    fn check_struct_constructor(fcx: &FnCtxt,\n                                 id: ast::NodeId,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n@@ -2485,7 +2489,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, struct_type);\n     }\n \n-    fn check_struct_enum_variant(fcx: @FnCtxt,\n+    fn check_struct_enum_variant(fcx: &FnCtxt,\n                                  id: ast::NodeId,\n                                  span: codemap::Span,\n                                  enum_id: ast::DefId,\n@@ -3021,7 +3025,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                 _ => false\n                             }\n                         }\n-                        fn types_compatible(fcx: @FnCtxt, sp: Span,\n+                        fn types_compatible(fcx: &FnCtxt, sp: Span,\n                                             t1: ty::t, t2: ty::t) -> bool {\n                             if !is_vec(t1) {\n                                 false\n@@ -3206,7 +3210,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     unifier();\n }\n \n-pub fn require_integral(fcx: @FnCtxt, sp: Span, t: ty::t) {\n+pub fn require_integral(fcx: &FnCtxt, sp: Span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n             format!(\"mismatched types: expected integral type but found `{}`\",\n@@ -3215,15 +3219,15 @@ pub fn require_integral(fcx: @FnCtxt, sp: Span, t: ty::t) {\n     }\n }\n \n-pub fn check_decl_initializer(fcx: @FnCtxt,\n+pub fn check_decl_initializer(fcx: &FnCtxt,\n                               nid: ast::NodeId,\n                               init: &ast::Expr)\n                             {\n     let local_ty = fcx.local_ty(init.span, nid);\n     check_expr_coercable_to_type(fcx, init, local_ty)\n }\n \n-pub fn check_decl_local(fcx: @FnCtxt, local: &ast::Local)  {\n+pub fn check_decl_local(fcx: &FnCtxt, local: &ast::Local)  {\n     let tcx = fcx.ccx.tcx;\n \n     let t = fcx.local_ty(local.span, local.id);\n@@ -3251,7 +3255,7 @@ pub fn check_decl_local(fcx: @FnCtxt, local: &ast::Local)  {\n     }\n }\n \n-pub fn check_stmt(fcx: @FnCtxt, stmt: &ast::Stmt)  {\n+pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n     let node_id;\n     let mut saw_bot = false;\n     let mut saw_err = false;\n@@ -3296,7 +3300,7 @@ pub fn check_stmt(fcx: @FnCtxt, stmt: &ast::Stmt)  {\n     }\n }\n \n-pub fn check_block_no_value(fcx: @FnCtxt, blk: &ast::Block)  {\n+pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx, blk, Some(ty::mk_nil()));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n@@ -3311,11 +3315,11 @@ pub fn check_block_no_value(fcx: @FnCtxt, blk: &ast::Block)  {\n     }\n }\n \n-pub fn check_block(fcx0: @FnCtxt, blk: &ast::Block)  {\n+pub fn check_block(fcx0: &FnCtxt, blk: &ast::Block)  {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n-pub fn check_block_with_expected(fcx: @FnCtxt,\n+pub fn check_block_with_expected(fcx: &FnCtxt,\n                                  blk: &ast::Block,\n                                  expected: Option<ty::t>) {\n     let prev = {\n@@ -3384,20 +3388,21 @@ pub fn check_block_with_expected(fcx: @FnCtxt,\n     fcx.ps.set(prev);\n }\n \n-pub fn check_const(ccx: @CrateCtxt,\n+pub fn check_const(ccx: &CrateCtxt,\n                    sp: Span,\n                    e: &ast::Expr,\n                    id: ast::NodeId) {\n+    let inh = blank_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n-    let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+    let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n     let declty = {\n         let tcache = fcx.ccx.tcx.tcache.borrow();\n         tcache.get().get(&local_def(id)).ty\n     };\n-    check_const_with_ty(fcx, sp, e, declty);\n+    check_const_with_ty(&fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty(fcx: @FnCtxt,\n+pub fn check_const_with_ty(fcx: &FnCtxt,\n                            _: Span,\n                            e: &ast::Expr,\n                            declty: ty::t) {\n@@ -3413,7 +3418,7 @@ pub fn check_const_with_ty(fcx: @FnCtxt,\n /// pointer, which would mean their size is unbounded. This is different from\n /// the question of whether a type can be instantiated. See the definition of\n /// `check_instantiable`.\n-pub fn check_representable(tcx: ty::ctxt,\n+pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n                            designation: &str) {\n@@ -3446,7 +3451,7 @@ pub fn check_representable(tcx: ty::ctxt,\n ///     enum foo { Some(@foo) }\n ///\n /// is representable, but not instantiable.\n-pub fn check_instantiable(tcx: ty::ctxt,\n+pub fn check_instantiable(tcx: &ty::ctxt,\n                           sp: Span,\n                           item_id: ast::NodeId) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n@@ -3458,7 +3463,7 @@ pub fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n+pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     let t = ty::node_id_to_type(tcx, id);\n     if ty::type_needs_subst(t) {\n         tcx.sess.span_err(sp, \"SIMD vector cannot be generic\");\n@@ -3487,15 +3492,15 @@ pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-pub fn check_enum_variants(ccx: @CrateCtxt,\n+pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n                            vs: &[ast::P<ast::Variant>],\n                            id: ast::NodeId) {\n \n-    fn disr_in_range(ccx: @CrateCtxt,\n+    fn disr_in_range(ccx: &CrateCtxt,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {\n-        fn uint_in_range(ccx: @CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n+        fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n             match ty {\n                 ast::TyU8 => disr as u8 as Disr == disr,\n                 ast::TyU16 => disr as u16 as Disr == disr,\n@@ -3504,7 +3509,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                 ast::TyU => uint_in_range(ccx, ccx.tcx.sess.targ_cfg.uint_type, disr)\n             }\n         }\n-        fn int_in_range(ccx: @CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n+        fn int_in_range(ccx: &CrateCtxt, ty: ast::IntTy, disr: ty::Disr) -> bool {\n             match ty {\n                 ast::TyI8 => disr as i8 as Disr == disr,\n                 ast::TyI16 => disr as i16 as Disr == disr,\n@@ -3519,7 +3524,7 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n         }\n     }\n \n-    fn do_check(ccx: @CrateCtxt,\n+    fn do_check(ccx: &CrateCtxt,\n                 vs: &[ast::P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n@@ -3543,14 +3548,15 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n                 Some(e) => {\n                     debug!(\"disr expr, checking {}\", pprust::expr_to_str(e));\n \n-                    let fcx = blank_fn_ctxt(ccx, rty, e.id);\n+                    let inh = blank_inherited_fields(ccx);\n+                    let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n                     let declty = ty::mk_int_var(ccx.tcx, fcx.infcx().next_int_var_id());\n-                    check_const_with_ty(fcx, e.span, e, declty);\n+                    check_const_with_ty(&fcx, e.span, e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in an form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(&ccx.tcx, e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, e) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n@@ -3618,12 +3624,12 @@ pub fn check_enum_variants(ccx: @CrateCtxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn ty_param_bounds_and_ty_for_def(fcx: @FnCtxt,\n+pub fn ty_param_bounds_and_ty_for_def(fcx: &FnCtxt,\n                                       sp: Span,\n                                       defn: ast::Def)\n                                    -> ty_param_bounds_and_ty {\n@@ -3673,7 +3679,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @FnCtxt,\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-pub fn instantiate_path(fcx: @FnCtxt,\n+pub fn instantiate_path(fcx: &FnCtxt,\n                         pth: &ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         def: ast::Def,\n@@ -3859,47 +3865,47 @@ pub fn structurally_resolved_type(fcx: &FnCtxt, sp: Span, tp: ty::t) -> ty::t {\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of<'a>(fcx: @FnCtxt, sp: Span, typ: ty::t)\n+pub fn structure_of<'a>(fcx: &FnCtxt, sp: Span, typ: ty::t)\n                         -> &'a ty::sty {\n     &ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_integral(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_integral(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_scalar(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);\n }\n \n-pub fn type_is_char(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_char(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_char(typ_s);\n }\n \n-pub fn type_is_bare_fn(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_bare_fn(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_bare_fn(typ_s);\n }\n \n-pub fn type_is_unsafe_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_unsafe_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_unsafe_ptr(typ_s);\n }\n \n-pub fn type_is_region_ptr(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_region_ptr(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_region_ptr(typ_s);\n }\n \n-pub fn type_is_c_like_enum(fcx: @FnCtxt, sp: Span, typ: ty::t) -> bool {\n+pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n+pub fn ast_expr_vstore_to_vstore(fcx: &FnCtxt,\n                                  e: &ast::Expr,\n                                  v: ast::ExprVstore)\n                               -> ty::vstore {\n@@ -3939,7 +3945,7 @@ pub fn ast_expr_vstore_to_vstore(fcx: @FnCtxt,\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n+pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(b, |e| {\n@@ -3963,7 +3969,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n         }}))\n }\n \n-pub fn check_bounds_are_used(ccx: @CrateCtxt,\n+pub fn check_bounds_are_used(ccx: &CrateCtxt,\n                              span: Span,\n                              tps: &OptVec<ast::TyParam>,\n                              ty: ty::t) {\n@@ -3993,8 +3999,8 @@ pub fn check_bounds_are_used(ccx: @CrateCtxt,\n     }\n }\n \n-pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n-    fn param(ccx: @CrateCtxt, n: uint) -> ty::t {\n+pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n+    fn param(ccx: &CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n "}, {"sha": "4610305a70b08f247d394b26776922892cb9bcb4", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -154,15 +154,15 @@ macro_rules! ignore_err(\n     )\n )\n \n-pub struct Rcx {\n-    fcx: @FnCtxt,\n+pub struct Rcx<'a> {\n+    fcx: &'a FnCtxt<'a>,\n     errors_reported: uint,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n }\n \n-fn region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n+fn region_of_def(fcx: &FnCtxt, def: ast::Def) -> ty::Region {\n     /*!\n      * Returns the validity region of `def` -- that is, how long\n      * is `def` valid?\n@@ -187,8 +187,8 @@ fn region_of_def(fcx: @FnCtxt, def: ast::Def) -> ty::Region {\n     }\n }\n \n-impl Rcx {\n-    pub fn tcx(&self) -> ty::ctxt {\n+impl<'a> Rcx<'a> {\n+    pub fn tcx(&self) -> &'a ty::ctxt {\n         self.fcx.ccx.tcx\n     }\n \n@@ -198,7 +198,7 @@ impl Rcx {\n         old_scope\n     }\n \n-    pub fn resolve_type(&mut self, unresolved_ty: ty::t) -> ty::t {\n+    pub fn resolve_type(&self, unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -240,7 +240,7 @@ impl Rcx {\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+    fn resolve_method_type(&self, method_call: MethodCall) -> Option<ty::t> {\n         let method_ty = self.fcx.inh.method_map.borrow().get()\n                             .find(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n@@ -260,8 +260,8 @@ impl Rcx {\n     }\n }\n \n-impl<'a> mc::Typer for &'a mut Rcx {\n-    fn tcx(&self) -> ty::ctxt {\n+impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n \n@@ -270,7 +270,7 @@ impl<'a> mc::Typer for &'a mut Rcx {\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n-    fn node_method_ty(&mut self, method_call: MethodCall) -> Option<ty::t> {\n+    fn node_method_ty(&self, method_call: MethodCall) -> Option<ty::t> {\n         self.resolve_method_type(method_call)\n     }\n \n@@ -293,7 +293,7 @@ impl<'a> mc::Typer for &'a mut Rcx {\n     }\n }\n \n-pub fn regionck_expr(fcx: @FnCtxt, e: &ast::Expr) {\n+pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n     let rcx = &mut rcx;\n@@ -304,7 +304,7 @@ pub fn regionck_expr(fcx: @FnCtxt, e: &ast::Expr) {\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @FnCtxt, blk: &ast::Block) {\n+pub fn regionck_fn(fcx: &FnCtxt, blk: &ast::Block) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: blk.id };\n     let rcx = &mut rcx;\n@@ -315,7 +315,7 @@ pub fn regionck_fn(fcx: @FnCtxt, blk: &ast::Block) {\n     fcx.infcx().resolve_regions();\n }\n \n-impl Visitor<()> for Rcx {\n+impl<'a> Visitor<()> for Rcx<'a> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the"}, {"sha": "45eab7c7e62fde5608c5673aa4c2e9945e64a51c", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -22,7 +22,7 @@ use util::ppaux;\n // Helper functions related to manipulating region types.\n \n pub fn replace_late_bound_regions_in_fn_sig(\n-        tcx: ty::ctxt,\n+        tcx: &ty::ctxt,\n         fn_sig: &ty::FnSig,\n         mapf: |ty::BoundRegion| -> ty::Region)\n         -> (HashMap<ty::BoundRegion,ty::Region>, ty::FnSig) {\n@@ -45,7 +45,7 @@ pub fn replace_late_bound_regions_in_fn_sig(\n     (map, fn_sig)\n }\n \n-pub fn relate_nested_regions(tcx: ty::ctxt,\n+pub fn relate_nested_regions(tcx: &ty::ctxt,\n                              opt_region: Option<ty::Region>,\n                              ty: ty::t,\n                              relate_op: |ty::Region, ty::Region|) {\n@@ -85,8 +85,8 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     rr.fold_ty(ty);\n \n     struct RegionRelator<'a> {\n-        tcx: ty::ctxt,\n-        stack: Vec<ty::Region> ,\n+        tcx: &'a ty::ctxt,\n+        stack: Vec<ty::Region>,\n         relate_op: 'a |ty::Region, ty::Region|,\n     }\n \n@@ -95,7 +95,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     // well.\n \n     impl<'a> TypeFolder for RegionRelator<'a> {\n-        fn tcx(&self) -> ty::ctxt {\n+        fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n             self.tcx\n         }\n \n@@ -134,7 +134,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     }\n }\n \n-pub fn relate_free_regions(tcx: ty::ctxt, fn_sig: &ty::FnSig) {\n+pub fn relate_free_regions(tcx: &ty::ctxt, fn_sig: &ty::FnSig) {\n     /*!\n      * This function populates the region map's `free_region_map`.\n      * It walks over the transformed self type and argument types"}, {"sha": "30bbdabbc718f42da9c687ed82a9cd872fa25543", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -66,12 +66,12 @@ use syntax::visit::Visitor;\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext<'a> {\n-    infcx: &'a infer::InferCtxt,\n+    infcx: &'a infer::InferCtxt<'a>,\n     param_env: &'a ty::ParameterEnvironment,\n }\n \n impl<'a> VtableContext<'a> {\n-    pub fn tcx(&self) -> ty::ctxt { self.infcx.tcx }\n+    pub fn tcx(&self) -> &'a ty::ctxt { self.infcx.tcx }\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n@@ -726,7 +726,7 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n     }\n }\n \n-pub fn resolve_impl(tcx: ty::ctxt,\n+pub fn resolve_impl(tcx: &ty::ctxt,\n                     impl_item: &ast::Item,\n                     impl_generics: &ty::Generics,\n                     impl_trait_ref: &ty::TraitRef) {\n@@ -783,7 +783,7 @@ pub fn resolve_impl(tcx: ty::ctxt,\n \n /// Resolve vtables for a method call after typeck has finished.\n /// Used by trans to monomorphize artificial method callees (e.g. drop).\n-pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n+pub fn trans_resolve_method(tcx: &ty::ctxt, id: ast::NodeId,\n                             substs: &ty::substs) -> Option<vtable_res> {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n     let type_param_defs = generics.type_param_defs.deref();\n@@ -803,7 +803,7 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n     }\n }\n \n-impl<'a> visit::Visitor<()> for &'a FnCtxt {\n+impl<'a, 'b> visit::Visitor<()> for &'a FnCtxt<'b> {\n     fn visit_expr(&mut self, ex: &ast::Expr, _: ()) {\n         early_resolve_expr(ex, *self, false);\n         visit::walk_expr(self, ex, ());"}, {"sha": "1c03328bceaf374a7f7fcfc989a3997d6a6fc44d", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -35,7 +35,7 @@ use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n+fn resolve_type_vars_in_type(fcx: &FnCtxt, sp: Span, typ: ty::t)\n                           -> Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n@@ -53,7 +53,7 @@ fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n     }\n }\n \n-fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n+fn resolve_type_vars_in_types(fcx: &FnCtxt, sp: Span, tys: &[ty::t])\n                           -> Vec<ty::t> {\n     tys.iter().map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n@@ -101,7 +101,7 @@ fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, method_call: MethodCall\n     }\n }\n \n-fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n+fn resolve_vtable_map_entry(fcx: &FnCtxt, sp: Span, id: ast::NodeId) {\n     // Resolve any vtable map entry\n     match fcx.inh.vtable_map.borrow().get().find_copy(&id) {\n         Some(origins) => {\n@@ -113,12 +113,12 @@ fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n         None => {}\n     }\n \n-    fn resolve_origins(fcx: @FnCtxt, sp: Span,\n+    fn resolve_origins(fcx: &FnCtxt, sp: Span,\n                        vtbls: vtable_res) -> vtable_res {\n         @vtbls.map(|os| @os.map(|o| resolve_origin(fcx, sp, o)))\n     }\n \n-    fn resolve_origin(fcx: @FnCtxt,\n+    fn resolve_origin(fcx: &FnCtxt,\n                       sp: Span,\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n@@ -254,8 +254,8 @@ fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n     }\n }\n \n-struct WbCtxt {\n-    fcx: @FnCtxt,\n+struct WbCtxt<'a> {\n+    fcx: &'a FnCtxt<'a>,\n \n     // As soon as we hit an error we have to stop resolving\n     // the entire function.\n@@ -338,7 +338,7 @@ fn visit_item(_item: &ast::Item, _wbcx: &mut WbCtxt) {\n     // Ignore items\n }\n \n-impl Visitor<()> for WbCtxt {\n+impl<'a> Visitor<()> for WbCtxt<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) { visit_item(i, self); }\n     fn visit_stmt(&mut self, s: &ast::Stmt, _: ()) { visit_stmt(s, self); }\n     fn visit_expr(&mut self, ex:&ast::Expr, _: ()) { visit_expr(ex, self); }\n@@ -383,15 +383,15 @@ fn resolve_upvar_borrow_map(wbcx: &mut WbCtxt) {\n     }\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: &ast::Expr) -> bool {\n+pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_expr(e, ());\n     resolve_upvar_borrow_map(wbcx);\n     return wbcx.success;\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: @FnCtxt, decl: &ast::FnDecl,\n+pub fn resolve_type_vars_in_fn(fcx: &FnCtxt, decl: &ast::FnDecl,\n                                blk: &ast::Block) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;"}, {"sha": "894c70c7b61194f2592a3cd1f55d5b63d7fe3ec8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -144,13 +144,13 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n     }\n }\n \n-struct CoherenceChecker {\n-    crate_context: @CrateCtxt,\n-    inference_context: InferCtxt,\n+struct CoherenceChecker<'a> {\n+    crate_context: &'a CrateCtxt<'a>,\n+    inference_context: InferCtxt<'a>,\n }\n \n struct CoherenceCheckVisitor<'a> {\n-    cc: &'a CoherenceChecker\n+    cc: &'a CoherenceChecker<'a>\n }\n \n impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n@@ -176,7 +176,7 @@ impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n     }\n }\n \n-struct PrivilegedScopeVisitor<'a> { cc: &'a CoherenceChecker }\n+struct PrivilegedScopeVisitor<'a> { cc: &'a CoherenceChecker<'a> }\n \n impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n@@ -189,7 +189,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n             ItemImpl(_, None, ast_ty, _) => {\n                 if !self.cc.ast_type_is_defined_in_local_crate(ast_ty) {\n                     // This is an error.\n-                    let session = self.cc.crate_context.tcx.sess;\n+                    let session = &self.cc.crate_context.tcx.sess;\n                     session.span_err(item.span,\n                                      \"cannot associate methods with a type outside the \\\n                                      crate the type is defined in; define and implement \\\n@@ -210,7 +210,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n                         self.cc.trait_ref_to_trait_def_id(trait_ref);\n \n                     if trait_def_id.krate != LOCAL_CRATE {\n-                        let session = self.cc.crate_context.tcx.sess;\n+                        let session = &self.cc.crate_context.tcx.sess;\n                         session.span_err(item.span,\n                                 \"cannot provide an extension implementation \\\n                                 where both trait and type are not defined in this crate\");\n@@ -226,14 +226,7 @@ impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n     }\n }\n \n-impl CoherenceChecker {\n-    fn new(crate_context: @CrateCtxt) -> CoherenceChecker {\n-        CoherenceChecker {\n-            crate_context: crate_context,\n-            inference_context: new_infer_ctxt(crate_context.tcx),\n-        }\n-    }\n-\n+impl<'a> CoherenceChecker<'a> {\n     fn check(&self, krate: &Crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n@@ -274,7 +267,7 @@ impl CoherenceChecker {\n                                        item.span,\n                                        self_type.ty) {\n                 None => {\n-                    let session = self.crate_context.tcx.sess;\n+                    let session = &self.crate_context.tcx.sess;\n                     session.span_err(item.span,\n                                      \"no base type found for inherent implementation; \\\n                                       implement a trait or new type instead\");\n@@ -447,7 +440,7 @@ impl CoherenceChecker {\n                             implementation_b);\n \n                     if self.polytypes_unify(polytype_a.clone(), polytype_b) {\n-                        let session = self.crate_context.tcx.sess;\n+                        let session = &self.crate_context.tcx.sess;\n                         session.span_err(\n                             self.span_of_impl(implementation_a),\n                             format!(\"conflicting implementations for trait `{}`\",\n@@ -457,7 +450,7 @@ impl CoherenceChecker {\n                             session.span_note(self.span_of_impl(implementation_b),\n                                               \"note conflicting implementation here\");\n                         } else {\n-                            let crate_store = self.crate_context.tcx.sess.cstore;\n+                            let crate_store = &self.crate_context.tcx.sess.cstore;\n                             let cdata = crate_store.get_crate_data(implementation_b.did.krate);\n                             session.note(\n                                 \"conflicting implementation in crate `\" + cdata.name + \"`\");\n@@ -475,7 +468,7 @@ impl CoherenceChecker {\n             return;\n         }\n \n-        let crate_store = self.crate_context.tcx.sess.cstore;\n+        let crate_store = &self.crate_context.tcx.sess.cstore;\n         csearch::each_implementation_for_trait(crate_store, trait_def_id, |impl_def_id| {\n             let implementation = @csearch::get_impl(self.crate_context.tcx, impl_def_id);\n             let _ = lookup_item_type(self.crate_context.tcx, implementation.did);\n@@ -689,7 +682,7 @@ impl CoherenceChecker {\n     fn add_external_crates(&self) {\n         let mut impls_seen = HashSet::new();\n \n-        let crate_store = self.crate_context.tcx.sess.cstore;\n+        let crate_store = &self.crate_context.tcx.sess.cstore;\n         crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n             each_impl(crate_store, crate_number, |def_id| {\n                 assert_eq!(crate_number, def_id.krate);\n@@ -762,7 +755,7 @@ impl CoherenceChecker {\n     }\n }\n \n-pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n+pub fn make_substs_for_receiver_types(tcx: &ty::ctxt,\n                                       impl_id: ast::DefId,\n                                       trait_ref: &ty::TraitRef,\n                                       method: &ty::Method)\n@@ -810,7 +803,7 @@ pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n     };\n }\n \n-fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n+fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n                                      impl_id: ast::DefId,\n                                      trait_ref: &ty::TraitRef,\n                                      new_def_id: ast::DefId,\n@@ -838,6 +831,9 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n     )\n }\n \n-pub fn check_coherence(crate_context: @CrateCtxt, krate: &Crate) {\n-    CoherenceChecker::new(crate_context).check(krate);\n+pub fn check_coherence(crate_context: &CrateCtxt, krate: &Crate) {\n+    CoherenceChecker {\n+        crate_context: crate_context,\n+        inference_context: new_infer_ctxt(crate_context.tcx),\n+    }.check(krate);\n }"}, {"sha": "fc6b4c91b4e8902fe41a09602f1322755e4891ee", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -61,11 +61,11 @@ use syntax::print::pprust::{path_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n \n-struct CollectItemTypesVisitor {\n-    ccx: @CrateCtxt\n+struct CollectItemTypesVisitor<'a> {\n+    ccx: &'a CrateCtxt<'a>\n }\n \n-impl visit::Visitor<()> for CollectItemTypesVisitor {\n+impl<'a> visit::Visitor<()> for CollectItemTypesVisitor<'a> {\n     fn visit_item(&mut self, i: &ast::Item, _: ()) {\n         convert(self.ccx, i);\n         visit::walk_item(self, i, ());\n@@ -76,7 +76,7 @@ impl visit::Visitor<()> for CollectItemTypesVisitor {\n     }\n }\n \n-pub fn collect_item_types(ccx: @CrateCtxt, krate: &ast::Crate) {\n+pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n         let ty::ty_param_bounds_and_ty { ty: ty, .. } =\n@@ -100,14 +100,14 @@ pub trait ToTy {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n \n-impl ToTy for CrateCtxt {\n+impl<'a> ToTy for CrateCtxt<'a> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-impl AstConv for CrateCtxt {\n-    fn tcx(&self) -> ty::ctxt { self.tcx }\n+impl<'a> AstConv for CrateCtxt<'a> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt { self.tcx }\n \n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty {\n         if id.krate != ast::LOCAL_CRATE {"}, {"sha": "f6894f44099889c66865679b5d9c3d669e0f8403", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -70,7 +70,7 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n \n pub trait Combine {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt;\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n@@ -331,7 +331,7 @@ pub trait Combine {\n }\n \n pub struct CombineFields<'a> {\n-    infcx: &'a InferCtxt,\n+    infcx: &'a InferCtxt<'a>,\n     a_is_expected: bool,\n     trace: TypeTrace,\n }"}, {"sha": "b0cd5e361e9acd8e8db7e0aa1b8544580d4bc7f3", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -150,7 +150,7 @@ trait ErrorReportingHelpers {\n                                 generics: ast::Generics);\n }\n \n-impl ErrorReporting for InferCtxt {\n+impl<'a> ErrorReporting for InferCtxt<'a> {\n     fn report_region_errors(&self,\n                             errors: &OptVec<RegionResolutionError>) {\n         let p_errors = self.process_errors(errors);\n@@ -255,7 +255,7 @@ impl ErrorReporting for InferCtxt {\n             scope_id: ast::NodeId\n         }\n \n-        fn free_regions_from_same_fn(tcx: ty::ctxt,\n+        fn free_regions_from_same_fn(tcx: &ty::ctxt,\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n@@ -672,7 +672,7 @@ impl ErrorReporting for InferCtxt {\n }\n \n struct Rebuilder<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     fn_decl: ast::P<ast::FnDecl>,\n     generics: &'a ast::Generics,\n     same_regions: &'a [SameRegions],\n@@ -682,7 +682,7 @@ struct Rebuilder<'a> {\n }\n \n impl<'a> Rebuilder<'a> {\n-    fn new(tcx: ty::ctxt,\n+    fn new(tcx: &'a ty::ctxt,\n            fn_decl: ast::P<ast::FnDecl>,\n            generics: &'a ast::Generics,\n            same_regions: &'a [SameRegions])\n@@ -1006,7 +1006,7 @@ impl<'a> Rebuilder<'a> {\n     }\n }\n \n-impl ErrorReportingHelpers for InferCtxt {\n+impl<'a> ErrorReportingHelpers for InferCtxt<'a> {\n     fn give_expl_lifetime_param(&self,\n                                 inputs: Vec<ast::Arg>,\n                                 output: ast::P<ast::Ty>,"}, {"sha": "e846e3621bd46137fee75ea740fcd9aceb0f7f75", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -35,7 +35,7 @@ impl<'f> Glb<'f> {\n }\n \n impl<'f> Combine for Glb<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }"}, {"sha": "e63ad7322b9aebfb2dd5b533fdcb47985a305602", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -38,7 +38,7 @@ impl<'f> Lub<'f> {\n }\n \n impl<'f> Combine for Lub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }"}, {"sha": "07948477800a18637bff9fb2f86bd8776e371716", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -75,8 +75,8 @@ pub type ures = cres<()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n pub type CoerceResult = cres<Option<@ty::AutoAdjustment>>;\n \n-pub struct InferCtxt {\n-    tcx: ty::ctxt,\n+pub struct InferCtxt<'a> {\n+    tcx: &'a ty::ctxt,\n \n     // We instantiate ValsAndBindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n@@ -95,7 +95,7 @@ pub struct InferCtxt {\n     float_var_counter: Cell<uint>,\n \n     // For region variables.\n-    region_vars: RegionVarBindings,\n+    region_vars: RegionVarBindings<'a>,\n }\n \n /// Why did we require that the two types be related?\n@@ -267,7 +267,7 @@ fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     }\n }\n \n-pub fn new_infer_ctxt(tcx: ty::ctxt) -> InferCtxt {\n+pub fn new_infer_ctxt<'a>(tcx: &'a ty::ctxt) -> InferCtxt<'a> {\n     InferCtxt {\n         tcx: tcx,\n \n@@ -510,7 +510,7 @@ pub struct Snapshot {\n     region_vars_snapshot: uint,\n }\n \n-impl InferCtxt {\n+impl<'a> InferCtxt<'a> {\n     pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n                               -> CombineFields<'a> {\n         CombineFields {infcx: self,\n@@ -609,7 +609,7 @@ fn next_simple_var<V:Clone,T:Clone>(counter: &mut uint,\n     return id;\n }\n \n-impl InferCtxt {\n+impl<'a> InferCtxt<'a> {\n     pub fn next_ty_var_id(&self) -> TyVid {\n         let id = self.ty_var_counter.get();\n         self.ty_var_counter.set(id + 1);\n@@ -840,7 +840,7 @@ impl InferCtxt {\n     }\n }\n \n-pub fn fold_regions_in_sig(tcx: ty::ctxt,\n+pub fn fold_regions_in_sig(tcx: &ty::ctxt,\n                            fn_sig: &ty::FnSig,\n                            fldr: |r: ty::Region| -> ty::Region)\n                            -> ty::FnSig {\n@@ -854,7 +854,7 @@ impl TypeTrace {\n }\n \n impl Repr for TypeTrace {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"TypeTrace({})\", self.origin.repr(tcx))\n     }\n }\n@@ -874,7 +874,7 @@ impl TypeOrigin {\n }\n \n impl Repr for TypeOrigin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             MethodCompatCheck(a) => format!(\"MethodCompatCheck({})\", a.repr(tcx)),\n             ExprAssignable(a) => format!(\"ExprAssignable({})\", a.repr(tcx)),\n@@ -911,7 +911,7 @@ impl SubregionOrigin {\n }\n \n impl Repr for SubregionOrigin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             Subtype(a) => format!(\"Subtype({})\", a.repr(tcx)),\n             InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n@@ -954,7 +954,7 @@ impl RegionVariableOrigin {\n }\n \n impl Repr for RegionVariableOrigin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             MiscVariable(a) => format!(\"MiscVariable({})\", a.repr(tcx)),\n             PatternRegion(a) => format!(\"PatternRegion({})\", a.repr(tcx)),"}, {"sha": "415367eea6205f83a008272db3ea1fd602ce32fb", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -123,9 +123,9 @@ impl SameRegions {\n \n pub type CombineMap = HashMap<TwoRegions, RegionVid>;\n \n-pub struct RegionVarBindings {\n-    tcx: ty::ctxt,\n-    var_origins: RefCell<Vec<RegionVariableOrigin> >,\n+pub struct RegionVarBindings<'a> {\n+    tcx: &'a ty::ctxt,\n+    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n     constraints: RefCell<HashMap<Constraint, SubregionOrigin>>,\n     lubs: RefCell<CombineMap>,\n     glbs: RefCell<CombineMap>,\n@@ -147,7 +147,7 @@ pub struct RegionVarBindings {\n     values: RefCell<Option<Vec<VarValue> >>,\n }\n \n-pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n+pub fn RegionVarBindings<'a>(tcx: &'a ty::ctxt) -> RegionVarBindings<'a> {\n     RegionVarBindings {\n         tcx: tcx,\n         var_origins: RefCell::new(Vec::new()),\n@@ -161,7 +161,7 @@ pub fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n     }\n }\n \n-impl RegionVarBindings {\n+impl<'a> RegionVarBindings<'a> {\n     pub fn in_snapshot(&self) -> bool {\n         let undo_log = self.undo_log.borrow();\n         undo_log.get().len() > 0\n@@ -572,7 +572,7 @@ impl RegionVarBindings {\n     }\n }\n \n-impl RegionVarBindings {\n+impl<'a> RegionVarBindings<'a> {\n     fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n         self.tcx.region_maps.is_subregion_of(sub, sup)\n     }\n@@ -814,7 +814,7 @@ struct RegionAndOrigin {\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n-impl RegionVarBindings {\n+impl<'a> RegionVarBindings<'a> {\n     fn infer_variable_values(&self,\n                              errors: &mut OptVec<RegionResolutionError>)\n                              -> Vec<VarValue> {\n@@ -1359,7 +1359,7 @@ impl RegionVarBindings {\n }\n \n impl Repr for Constraint {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             ConstrainVarSubVar(a, b) => format!(\"ConstrainVarSubVar({}, {})\",\n                                              a.repr(tcx), b.repr(tcx)),"}, {"sha": "f91e20a649b560acec8cb1d435711f9fd212c06a", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -81,7 +81,7 @@ pub static resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n pub struct ResolveState<'a> {\n-    infcx: &'a InferCtxt,\n+    infcx: &'a InferCtxt<'a>,\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: Vec<TyVid> ,\n@@ -99,7 +99,7 @@ pub fn resolver<'a>(infcx: &'a InferCtxt, modes: uint) -> ResolveState<'a> {\n }\n \n impl<'a> ty_fold::TypeFolder for ResolveState<'a> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.infcx.tcx\n     }\n "}, {"sha": "ef17a593654842dbc0666162bd45ba52f6685d90", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -34,7 +34,7 @@ impl<'f> Sub<'f> {\n }\n \n impl<'f> Combine for Sub<'f> {\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }"}, {"sha": "57a08d211c76c346724309bea0f7249a2c2d17f4", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -61,7 +61,7 @@ pub trait UnifyInferCtxtMethods {\n              -> (V, uint);\n }\n \n-impl UnifyInferCtxtMethods for InferCtxt {\n+impl<'a> UnifyInferCtxtMethods for InferCtxt<'a> {\n     fn get<T:Clone,\n            V:Clone + Eq + Vid + UnifyVid<T>>(\n            &self,\n@@ -80,7 +80,7 @@ impl UnifyInferCtxtMethods for InferCtxt {\n         return helper(tcx, vb.get(), vid);\n \n         fn helper<T:Clone, V:Clone+Eq+Vid>(\n-            tcx: ty::ctxt,\n+            tcx: &ty::ctxt,\n             vb: &mut ValsAndBindings<V,T>,\n             vid: V) -> Node<V, T>\n         {\n@@ -200,7 +200,7 @@ pub trait InferCtxtMethods {\n                     -> ures;\n }\n \n-impl InferCtxtMethods for InferCtxt {\n+impl<'a> InferCtxtMethods for InferCtxt<'a> {\n     fn simple_vars<T:Clone + Eq + InferStr + SimplyUnifiable,\n                    V:Clone + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n                    &self,"}, {"sha": "bf34e7c13516a4f04d968e532b7c124c4e5cfd15", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -200,7 +200,7 @@ pub enum vtable_origin {\n }\n \n impl Repr for vtable_origin {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n                 format!(\"vtable_static({:?}:{}, {}, {})\",\n@@ -232,7 +232,7 @@ pub struct impl_res {\n }\n \n impl Repr for impl_res {\n-    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+    fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         format!(\"impl_res \\\\{trait_vtables={}, self_vtables={}\\\\}\",\n              self.trait_vtables.repr(tcx),\n              self.self_vtables.repr(tcx))\n@@ -241,22 +241,22 @@ impl Repr for impl_res {\n \n pub type impl_vtable_map = RefCell<DefIdMap<impl_res>>;\n \n-pub struct CrateCtxt {\n+pub struct CrateCtxt<'a> {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: resolve::TraitMap,\n     method_map: MethodMap,\n     vtable_map: vtable_map,\n-    tcx: ty::ctxt\n+    tcx: &'a ty::ctxt\n }\n \n // Functions that write types into the node type table\n-pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n+pub fn write_ty_to_tcx(tcx: &ty::ctxt, node_id: ast::NodeId, ty: ty::t) {\n     debug!(\"write_ty_to_tcx({}, {})\", node_id, ppaux::ty_to_str(tcx, ty));\n     assert!(!ty::type_needs_infer(ty));\n     let mut node_types = tcx.node_types.borrow_mut();\n     node_types.get().insert(node_id as uint, ty);\n }\n-pub fn write_substs_to_tcx(tcx: ty::ctxt,\n+pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n                            node_id: ast::NodeId,\n                            substs: Vec<ty::t> ) {\n     if substs.len() > 0u {\n@@ -268,7 +268,7 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n         node_type_substs.get().insert(node_id, substs);\n     }\n }\n-pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n+pub fn write_tpt_to_tcx(tcx: &ty::ctxt,\n                         node_id: ast::NodeId,\n                         tpt: &ty::ty_param_substs_and_ty) {\n     write_ty_to_tcx(tcx, node_id, tpt.ty);\n@@ -277,7 +277,7 @@ pub fn write_tpt_to_tcx(tcx: ty::ctxt,\n     }\n }\n \n-pub fn lookup_def_tcx(tcx: ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n+pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> ast::Def {\n     let def_map = tcx.def_map.borrow();\n     match def_map.get().find(&id) {\n         Some(&x) => x,\n@@ -300,7 +300,7 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     }\n }\n \n-pub fn require_same_types(tcx: ty::ctxt,\n+pub fn require_same_types(tcx: &ty::ctxt,\n                           maybe_infcx: Option<&infer::InferCtxt>,\n                           t1_is_expected: bool,\n                           span: Span,\n@@ -457,20 +457,20 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt,\n+pub fn check_crate(tcx: &ty::ctxt,\n                    trait_map: resolve::TraitMap,\n                    krate: &ast::Crate)\n                 -> (MethodMap, vtable_map) {\n     let time_passes = tcx.sess.time_passes();\n-    let ccx = @CrateCtxt {\n+    let ccx = CrateCtxt {\n         trait_map: trait_map,\n         method_map: @RefCell::new(FnvHashMap::new()),\n         vtable_map: @RefCell::new(NodeMap::new()),\n         tcx: tcx\n     };\n \n     time(time_passes, \"type collecting\", (), |_|\n-        collect::collect_item_types(ccx, krate));\n+        collect::collect_item_types(&ccx, krate));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n@@ -480,12 +480,12 @@ pub fn check_crate(tcx: ty::ctxt,\n          variance::infer_variance(tcx, krate));\n \n     time(time_passes, \"coherence checking\", (), |_|\n-        coherence::check_coherence(ccx, krate));\n+        coherence::check_coherence(&ccx, krate));\n \n     time(time_passes, \"type checking\", (), |_|\n-        check::check_item_types(ccx, krate));\n+        check::check_item_types(&ccx, krate));\n \n-    check_for_entry_fn(ccx);\n+    check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n     (ccx.method_map, ccx.vtable_map)\n }"}, {"sha": "468d97a83925f20d89dd2e71d951cfde21d46e2b", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -205,7 +205,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use util::ppaux::Repr;\n \n-pub fn infer_variance(tcx: ty::ctxt,\n+pub fn infer_variance(tcx: &ty::ctxt,\n                       krate: &ast::Crate) {\n     let mut arena = arena::Arena::new();\n     let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n@@ -251,7 +251,7 @@ impl<'a> fmt::Show for VarianceTerm<'a> {\n  */\n \n struct TermsContext<'a> {\n-    tcx: ty::ctxt,\n+    tcx: &'a ty::ctxt,\n     arena: &'a Arena,\n \n     empty_variances: @ty::ItemVariances,\n@@ -274,7 +274,7 @@ struct InferredInfo<'a> {\n     term: VarianceTermPtr<'a>,\n }\n \n-fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n+fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n                                            arena: &'a mut Arena,\n                                            krate: &ast::Crate)\n                                            -> TermsContext<'a> {\n@@ -522,7 +522,7 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n }\n \n impl<'a> ConstraintContext<'a> {\n-    fn tcx(&self) -> ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt {\n         self.terms_cx.tcx\n     }\n "}, {"sha": "b3d3e59ea6b3f16afc8530ec9a202c50affad7bc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 90, "deletions": 91, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -35,15 +35,15 @@ use syntax::opt_vec::OptVec;\n \n /// Produces a string suitable for debugging output.\n pub trait Repr {\n-    fn repr(&self, tcx: ctxt) -> ~str;\n+    fn repr(&self, tcx: &ctxt) -> ~str;\n }\n \n /// Produces a string suitable for showing to the user.\n pub trait UserString {\n-    fn user_string(&self, tcx: ctxt) -> ~str;\n+    fn user_string(&self, tcx: &ctxt) -> ~str;\n }\n \n-pub fn note_and_explain_region(cx: ctxt,\n+pub fn note_and_explain_region(cx: &ctxt,\n                                prefix: &str,\n                                region: ty::Region,\n                                suffix: &str) {\n@@ -62,13 +62,13 @@ pub fn note_and_explain_region(cx: ctxt,\n \n /// Returns a string like \"the block at 27:31\" that attempts to explain a\n /// lifetime in a way it might plausibly be understood.\n-pub fn explain_region(cx: ctxt, region: ty::Region) -> ~str {\n+pub fn explain_region(cx: &ctxt, region: ty::Region) -> ~str {\n   let (res, _) = explain_region_and_span(cx, region);\n   return res;\n }\n \n \n-pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n+pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (~str, Option<Span>) {\n     return match region {\n       ReScope(node_id) => {\n@@ -138,20 +138,19 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n       }\n     };\n \n-    fn explain_span(cx: ctxt, heading: &str, span: Span)\n-        -> (~str, Option<Span>)\n-    {\n-        let lo = cx.sess.codemap.lookup_char_pos_adj(span.lo);\n+    fn explain_span(cx: &ctxt, heading: &str, span: Span)\n+        -> (~str, Option<Span>) {\n+        let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n         (format!(\"the {} at {}:{}\", heading,\n               lo.line, lo.col.to_uint()), Some(span))\n     }\n }\n \n-pub fn bound_region_ptr_to_str(cx: ctxt, br: BoundRegion) -> ~str {\n+pub fn bound_region_ptr_to_str(cx: &ctxt, br: BoundRegion) -> ~str {\n     bound_region_to_str(cx, \"&\", true, br)\n }\n \n-pub fn bound_region_to_str(cx: ctxt,\n+pub fn bound_region_to_str(cx: &ctxt,\n                            prefix: &str, space: bool,\n                            br: BoundRegion) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n@@ -168,32 +167,32 @@ pub fn bound_region_to_str(cx: ctxt,\n     }\n }\n \n-pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n+pub fn ReScope_id_to_str(cx: &ctxt, node_id: ast::NodeId) -> ~str {\n     match cx.map.find(node_id) {\n       Some(ast_map::NodeBlock(ref blk)) => {\n         format!(\"<block at {}>\",\n-             cx.sess.codemap.span_to_str(blk.span))\n+             cx.sess.codemap().span_to_str(blk.span))\n       }\n       Some(ast_map::NodeExpr(expr)) => {\n         match expr.node {\n           ast::ExprCall(..) => {\n             format!(\"<call at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n           ast::ExprMatch(..) => {\n             format!(\"<match at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n           ast::ExprAssignOp(..) |\n           ast::ExprUnary(..) |\n           ast::ExprBinary(..) |\n           ast::ExprIndex(..) => {\n             format!(\"<method at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n           _ => {\n             format!(\"<expression at {}>\",\n-                 cx.sess.codemap.span_to_str(expr.span))\n+                 cx.sess.codemap().span_to_str(expr.span))\n           }\n         }\n       }\n@@ -207,11 +206,11 @@ pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n // In general, if you are giving a region error message,\n // you should use `explain_region()` or, better yet,\n // `note_and_explain_region()`\n-pub fn region_ptr_to_str(cx: ctxt, region: Region) -> ~str {\n+pub fn region_ptr_to_str(cx: &ctxt, region: Region) -> ~str {\n     region_to_str(cx, \"&\", true, region)\n }\n \n-pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~str {\n+pub fn region_to_str(cx: &ctxt, prefix: &str, space: bool, region: Region) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n@@ -243,31 +242,31 @@ pub fn mutability_to_str(m: ast::Mutability) -> ~str {\n     }\n }\n \n-pub fn mt_to_str(cx: ctxt, m: &mt) -> ~str {\n+pub fn mt_to_str(cx: &ctxt, m: &mt) -> ~str {\n     mt_to_str_wrapped(cx, \"\", m, \"\")\n }\n \n-pub fn mt_to_str_wrapped(cx: ctxt, before: &str, m: &mt, after: &str) -> ~str {\n+pub fn mt_to_str_wrapped(cx: &ctxt, before: &str, m: &mt, after: &str) -> ~str {\n     let mstr = mutability_to_str(m.mutbl);\n     return format!(\"{}{}{}{}\", mstr, before, ty_to_str(cx, m.ty), after);\n }\n \n-pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n+pub fn vstore_to_str(cx: &ctxt, vs: ty::vstore) -> ~str {\n     match vs {\n       ty::vstore_fixed(n) => format!(\"{}\", n),\n       ty::vstore_uniq => ~\"~\",\n       ty::vstore_slice(r) => region_ptr_to_str(cx, r)\n     }\n }\n \n-pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n+pub fn trait_store_to_str(cx: &ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n       ty::UniqTraitStore => ~\"~\",\n       ty::RegionTraitStore(r) => region_ptr_to_str(cx, r)\n     }\n }\n \n-pub fn vstore_ty_to_str(cx: ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n+pub fn vstore_ty_to_str(cx: &ctxt, mt: &mt, vs: ty::vstore) -> ~str {\n     match vs {\n         ty::vstore_fixed(_) => {\n             format!(\"[{}, .. {}]\", mt_to_str(cx, mt), vstore_to_str(cx, vs))\n@@ -283,26 +282,26 @@ pub fn vec_map_to_str<T>(ts: &[T], f: |t: &T| -> ~str) -> ~str {\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n+pub fn tys_to_str(cx: &ctxt, ts: &[t]) -> ~str {\n     vec_map_to_str(ts, |t| ty_to_str(cx, *t))\n }\n \n-pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n+pub fn fn_sig_to_str(cx: &ctxt, typ: &ty::FnSig) -> ~str {\n     format!(\"fn{}{} -> {}\",\n             typ.binder_id,\n             typ.inputs.repr(cx),\n             typ.output.repr(cx))\n }\n \n-pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n+pub fn trait_ref_to_str(cx: &ctxt, trait_ref: &ty::TraitRef) -> ~str {\n     trait_ref.user_string(cx)\n }\n \n-pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n-    fn fn_input_to_str(cx: ctxt, input: ty::t) -> ~str {\n+pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n+    fn fn_input_to_str(cx: &ctxt, input: ty::t) -> ~str {\n         ty_to_str(cx, input)\n     }\n-    fn bare_fn_to_str(cx: ctxt,\n+    fn bare_fn_to_str(cx: &ctxt,\n                       purity: ast::Purity,\n                       abis: AbiSet,\n                       ident: Option<ast::Ident>,\n@@ -336,7 +335,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         return s;\n     }\n-    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str {\n+    fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> ~str {\n         let is_proc =\n             (cty.sigil, cty.onceness) == (ast::OwnedSigil, ast::Once);\n         let is_borrowed_closure = cty.sigil == ast::BorrowedSigil;\n@@ -402,7 +401,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         return s;\n     }\n-    fn push_sig_to_str(cx: ctxt,\n+    fn push_sig_to_str(cx: &ctxt,\n                        s: &mut ~str,\n                        bra: char,\n                        ket: char,\n@@ -501,7 +500,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n }\n \n-pub fn parameterized(cx: ctxt,\n+pub fn parameterized(cx: &ctxt,\n                      base: &str,\n                      regions: &ty::RegionSubsts,\n                      tps: &[ty::t],\n@@ -554,14 +553,14 @@ pub fn parameterized(cx: ctxt,\n     }\n }\n \n-pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n+pub fn ty_to_short_str(cx: &ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n     if s.len() >= 32u { s = s.slice(0u, 32u).to_owned(); }\n     return s;\n }\n \n impl<T:Repr> Repr for Option<T> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &None => ~\"None\",\n             &Some(ref t) => t.repr(tcx),\n@@ -570,7 +569,7 @@ impl<T:Repr> Repr for Option<T> {\n }\n \n impl<T:Repr,U:Repr> Repr for Result<T,U> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &Ok(ref t) => t.repr(tcx),\n             &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n@@ -579,35 +578,35 @@ impl<T:Repr,U:Repr> Repr for Result<T,U> {\n }\n \n impl Repr for () {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         ~\"()\"\n     }\n }\n \n impl<T:Repr> Repr for @T {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         (&**self).repr(tcx)\n     }\n }\n \n impl<T:Repr> Repr for ~T {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         (&**self).repr(tcx)\n     }\n }\n \n-fn repr_vec<T:Repr>(tcx: ctxt, v: &[T]) -> ~str {\n+fn repr_vec<T:Repr>(tcx: &ctxt, v: &[T]) -> ~str {\n     vec_map_to_str(v, |t| t.repr(tcx))\n }\n \n impl<'a, T:Repr> Repr for &'a [T] {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         repr_vec(tcx, *self)\n     }\n }\n \n impl<T:Repr> Repr for OptVec<T> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             opt_vec::Empty => ~\"[]\",\n             opt_vec::Vec(ref v) => repr_vec(tcx, v.as_slice())\n@@ -618,35 +617,35 @@ impl<T:Repr> Repr for OptVec<T> {\n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<T:Repr> Repr for Vec<T> {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         repr_vec(tcx, self.as_slice())\n     }\n }\n \n impl Repr for ty::TypeParameterDef {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"TypeParameterDef({:?}, {})\",\n                 self.def_id,\n                 self.bounds.repr(tcx))\n     }\n }\n \n impl Repr for ty::RegionParameterDef {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"RegionParameterDef({}, {:?})\",\n                 token::get_name(self.name),\n                 self.def_id)\n     }\n }\n \n impl Repr for ty::t {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::substs {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"substs(regions={}, self_ty={}, tps={})\",\n              self.regions.repr(tcx),\n              self.self_ty.repr(tcx),\n@@ -655,7 +654,7 @@ impl Repr for ty::substs {\n }\n \n impl Repr for ty::RegionSubsts {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::ErasedRegions => ~\"erased\",\n             ty::NonerasedRegions(ref regions) => regions.repr(tcx)\n@@ -664,7 +663,7 @@ impl Repr for ty::RegionSubsts {\n }\n \n impl Repr for ty::ParamBounds {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         let mut res = Vec::new();\n         for b in self.builtin_bounds.iter() {\n             res.push(match b {\n@@ -683,41 +682,41 @@ impl Repr for ty::ParamBounds {\n }\n \n impl Repr for ty::TraitRef {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         trait_ref_to_str(tcx, self)\n     }\n }\n \n impl Repr for ast::Expr {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_str(self))\n     }\n }\n \n impl Repr for ast::Item {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"item({})\", tcx.map.node_to_str(self.id))\n     }\n }\n \n impl Repr for ast::Stmt {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"stmt({}: {})\",\n                 ast_util::stmt_id(self),\n                 pprust::stmt_to_str(self))\n     }\n }\n \n impl Repr for ast::Pat {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"pat({}: {})\",\n              self.id,\n              pprust::pat_to_str(self))\n     }\n }\n \n impl Repr for ty::BoundRegion {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::BrAnon(id) => format!(\"BrAnon({})\", id),\n             ty::BrNamed(id, name) => format!(\"BrNamed({}, {})\",\n@@ -729,7 +728,7 @@ impl Repr for ty::BoundRegion {\n }\n \n impl Repr for ty::Region {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match *self {\n             ty::ReEarlyBound(id, index, name) => {\n                 format!(\"ReEarlyBound({}, {}, {})\",\n@@ -772,7 +771,7 @@ impl Repr for ty::Region {\n }\n \n impl Repr for ast::DefId {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         // Unfortunately, there seems to be no way to attempt to print\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n@@ -798,23 +797,23 @@ impl Repr for ast::DefId {\n }\n \n impl Repr for ty::ty_param_bounds_and_ty {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"ty_param_bounds_and_ty \\\\{generics: {}, ty: {}\\\\}\",\n              self.generics.repr(tcx),\n              self.ty.repr(tcx))\n     }\n }\n \n impl Repr for ty::Generics {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"Generics(type_param_defs: {}, region_param_defs: {})\",\n                 self.type_param_defs().repr(tcx),\n                 self.region_param_defs().repr(tcx))\n     }\n }\n \n impl Repr for ty::ItemVariances {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"IterVariances(self_param={}, type_params={}, region_params={})\",\n                 self.self_param.repr(tcx),\n                 self.type_params.repr(tcx),\n@@ -823,13 +822,13 @@ impl Repr for ty::ItemVariances {\n }\n \n impl Repr for ty::Variance {\n-    fn repr(&self, _: ctxt) -> ~str {\n+    fn repr(&self, _: &ctxt) -> ~str {\n         self.to_str().to_owned()\n     }\n }\n \n impl Repr for ty::Method {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"method(ident: {}, generics: {}, fty: {}, \\\n                 explicit_self: {}, vis: {}, def_id: {})\",\n                 self.ident.repr(tcx),\n@@ -842,31 +841,31 @@ impl Repr for ty::Method {\n }\n \n impl Repr for ast::Name {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         token::get_name(*self).get().to_str()\n     }\n }\n \n impl Repr for ast::Ident {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         token::get_ident(*self).get().to_str()\n     }\n }\n \n impl Repr for ast::ExplicitSelf_ {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ast::Visibility {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BareFnTy {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"BareFnTy \\\\{purity: {:?}, abis: {}, sig: {}\\\\}\",\n              self.purity,\n              self.abis.to_str(),\n@@ -875,13 +874,13 @@ impl Repr for ty::BareFnTy {\n }\n \n impl Repr for ty::FnSig {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         fn_sig_to_str(tcx, self)\n     }\n }\n \n impl Repr for typeck::MethodCallee {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"MethodCallee \\\\{origin: {}, ty: {}, {}\\\\}\",\n             self.origin.repr(tcx),\n             self.ty.repr(tcx),\n@@ -890,7 +889,7 @@ impl Repr for typeck::MethodCallee {\n }\n \n impl Repr for typeck::MethodOrigin {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &typeck::MethodStatic(def_id) => {\n                 format!(\"MethodStatic({})\", def_id.repr(tcx))\n@@ -906,7 +905,7 @@ impl Repr for typeck::MethodOrigin {\n }\n \n impl Repr for typeck::MethodParam {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"MethodParam({},{:?},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n@@ -916,7 +915,7 @@ impl Repr for typeck::MethodParam {\n }\n \n impl Repr for typeck::MethodObject {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"MethodObject({},{:?},{:?})\",\n              self.trait_id.repr(tcx),\n              self.method_num,\n@@ -926,13 +925,13 @@ impl Repr for typeck::MethodObject {\n \n \n impl Repr for ty::RegionVid {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::TraitStore {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         match self {\n             &ty::UniqTraitStore => ~\"~Trait\",\n             &ty::RegionTraitStore(r) => format!(\"&{} Trait\", r.repr(tcx))\n@@ -941,19 +940,19 @@ impl Repr for ty::TraitStore {\n }\n \n impl Repr for ty::vstore {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         vstore_to_str(tcx, *self)\n     }\n }\n \n impl Repr for ty::BuiltinBound {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl UserString for ty::BuiltinBound {\n-    fn user_string(&self, _tcx: ctxt) -> ~str {\n+    fn user_string(&self, _tcx: &ctxt) -> ~str {\n         match *self {\n             ty::BoundStatic => ~\"'static\",\n             ty::BoundSend => ~\"Send\",\n@@ -965,26 +964,26 @@ impl UserString for ty::BuiltinBound {\n }\n \n impl Repr for ty::BuiltinBounds {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         self.user_string(tcx)\n     }\n }\n \n impl Repr for Span {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n-        tcx.sess.codemap.span_to_str(*self)\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n+        tcx.sess.codemap().span_to_str(*self)\n     }\n }\n \n impl<A:UserString> UserString for @A {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         let this: &A = &**self;\n         this.user_string(tcx)\n     }\n }\n \n impl UserString for ty::BuiltinBounds {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         if self.is_empty() { ~\"<no-bounds>\" } else {\n             let mut result = Vec::new();\n             for bb in self.iter() {\n@@ -996,7 +995,7 @@ impl UserString for ty::BuiltinBounds {\n }\n \n impl UserString for ty::TraitRef {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         let base = ty::item_path_str(tcx, self.def_id);\n         if tcx.sess.verbose() && self.substs.self_ty.is_some() {\n             let mut all_tps = self.substs.tps.clone();\n@@ -1011,31 +1010,31 @@ impl UserString for ty::TraitRef {\n }\n \n impl UserString for ty::t {\n-    fn user_string(&self, tcx: ctxt) -> ~str {\n+    fn user_string(&self, tcx: &ctxt) -> ~str {\n         ty_to_str(tcx, *self)\n     }\n }\n \n impl UserString for ast::Ident {\n-    fn user_string(&self, _tcx: ctxt) -> ~str {\n+    fn user_string(&self, _tcx: &ctxt) -> ~str {\n         token::get_name(self.name).get().to_owned()\n     }\n }\n \n impl Repr for AbiSet {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }\n }\n \n impl UserString for AbiSet {\n-    fn user_string(&self, _tcx: ctxt) -> ~str {\n+    fn user_string(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }\n }\n \n impl Repr for ty::UpvarId {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"UpvarId({};`{}`;{})\",\n              self.var_id,\n              ty::local_var_name_str(tcx, self.var_id),\n@@ -1044,19 +1043,19 @@ impl Repr for ty::UpvarId {\n }\n \n impl Repr for ast::Mutability {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::BorrowKind {\n-    fn repr(&self, _tcx: ctxt) -> ~str {\n+    fn repr(&self, _tcx: &ctxt) -> ~str {\n         format!(\"{:?}\", *self)\n     }\n }\n \n impl Repr for ty::UpvarBorrow {\n-    fn repr(&self, tcx: ctxt) -> ~str {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n         format!(\"UpvarBorrow({}, {})\",\n              self.kind.repr(tcx),\n              self.region.repr(tcx))"}, {"sha": "2ac3834ea49d253f8099d9deadf8ec768d1c0dbd", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -26,6 +26,7 @@ use rustc::metadata::decoder;\n \n use std;\n \n+use core;\n use doctree;\n use visit_ast;\n use std::local_data;\n@@ -84,7 +85,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n \n         let mut externs = ~[];\n-        cx.sess.cstore.iter_crate_data(|n, meta| {\n+        cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean()));\n         });\n \n@@ -683,7 +684,7 @@ impl Clean<Type> for ast::Ty {\n     fn clean(&self) -> Type {\n         use syntax::ast::*;\n         debug!(\"cleaning type `{:?}`\", self);\n-        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n+        let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap();\n         debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             TyNil => Unit,\n@@ -865,7 +866,7 @@ pub struct Span {\n \n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self) -> Span {\n-        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n+        let cm = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess().codemap();\n         let filename = cm.span_to_filename(*self);\n         let lo = cm.lookup_char_pos(self.lo);\n         let hi = cm.lookup_char_pos(self.hi);\n@@ -1179,7 +1180,7 @@ trait ToSource {\n impl ToSource for syntax::codemap::Span {\n     fn to_src(&self) -> ~str {\n         debug!(\"converting span {:?} to snippet\", self.clean());\n-        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess.codemap.clone();\n+        let cm = local_data::get(super::ctxtkey, |x| x.unwrap().clone()).sess().codemap().clone();\n         let sn = match cm.span_to_snippet(*self) {\n             Some(x) => x,\n             None    => ~\"\"\n@@ -1234,10 +1235,10 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n                 id: ast::NodeId) -> Type {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n-    let tycx = match cx.tycx {\n-        Some(tycx) => tycx,\n+    let tycx = match cx.maybe_typed {\n+        core::Typed(ref tycx) => tycx,\n         // If we're extracting tests, this return value doesn't matter.\n-        None => return Bool\n+        core::NotTyped(_) => return Bool\n     };\n     debug!(\"searching for {:?} in defmap\", id);\n     let def_map = tycx.def_map.borrow();\n@@ -1289,12 +1290,12 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n-    match cx.tycx {\n-        Some(tcx) => {\n+    match cx.maybe_typed {\n+        core::Typed(ref tcx) => {\n             let def_map = tcx.def_map.borrow();\n             def_map.get().find(&id).map(|&d| ast_util::def_id_of_def(d))\n         }\n-        None => None\n+        core::NotTyped(_) => None\n     }\n }\n "}, {"sha": "91c4311ff541c4b6569b22a548fd0bc8105c5517", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -15,7 +15,6 @@ use rustc::middle::privacy;\n \n use syntax::ast;\n use syntax::parse::token;\n-use syntax::parse;\n use syntax;\n \n use std::cell::RefCell;\n@@ -27,10 +26,23 @@ use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n+pub enum MaybeTyped {\n+    Typed(middle::ty::ctxt),\n+    NotTyped(driver::session::Session)\n+}\n+\n pub struct DocContext {\n     krate: ast::Crate,\n-    tycx: Option<middle::ty::ctxt>,\n-    sess: driver::session::Session\n+    maybe_typed: MaybeTyped\n+}\n+\n+impl DocContext {\n+    pub fn sess<'a>(&'a self) -> &'a driver::session::Session {\n+        match self.maybe_typed {\n+            Typed(ref tcx) => &tcx.sess,\n+            NotTyped(ref sess) => sess\n+        }\n+    }\n }\n \n pub struct CrateAnalysis {\n@@ -47,47 +59,46 @@ fn get_ast_and_resolve(cpath: &Path,\n                                 phase_2_configure_and_expand,\n                                 phase_3_run_analysis_passes};\n \n-    let parsesess = parse::new_parse_sess();\n     let input = FileInput(cpath.clone());\n \n-    let sessopts = @driver::session::Options {\n-        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n-        addl_lib_search_paths: @RefCell::new(libs),\n+    let sessopts = driver::session::Options {\n+        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(driver::session::CrateTypeDylib),\n-        .. (*rustc::driver::session::basic_options()).clone()\n+        ..rustc::driver::session::basic_options().clone()\n     };\n \n \n+    let codemap = syntax::codemap::CodeMap::new();\n     let diagnostic_handler = syntax::diagnostic::default_handler();\n     let span_diagnostic_handler =\n-        syntax::diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+        syntax::diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = driver::driver::build_session_(sessopts,\n                                               Some(cpath.clone()),\n-                                              parsesess.cm,\n                                               span_diagnostic_handler);\n \n-    let mut cfg = build_configuration(sess);\n+    let mut cfg = build_configuration(&sess);\n     for cfg_ in cfgs.move_iter() {\n         let cfg_ = token::intern_and_get_ident(cfg_);\n         cfg.push(@dummy_spanned(ast::MetaWord(cfg_)));\n     }\n \n-    let krate = phase_1_parse_input(sess, cfg, &input);\n-    let loader = &mut Loader::new(sess);\n-    let id = from_str(\"rustdoc\").unwrap();\n-    let (krate, ast_map) = phase_2_configure_and_expand(sess, loader,\n-                                                        krate, &id);\n+    let krate = phase_1_parse_input(&sess, cfg, &input);\n+    let (krate, ast_map) = phase_2_configure_and_expand(&sess, &mut Loader::new(&sess),\n+                                                        krate, &from_str(\"rustdoc\").unwrap());\n     let driver::driver::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &krate, ast_map);\n \n     debug!(\"crate: {:?}\", krate);\n-    return (DocContext { krate: krate, tycx: Some(ty_cx), sess: sess },\n-            CrateAnalysis {\n-                exported_items: exported_items,\n-                public_items: public_items,\n-            });\n+    (DocContext {\n+        krate: krate,\n+        maybe_typed: Typed(ty_cx)\n+    }, CrateAnalysis {\n+        exported_items: exported_items,\n+        public_items: public_items,\n+    })\n }\n \n pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Crate, CrateAnalysis) {"}, {"sha": "d67c7ea6505d063bc1edd9a99df31802406005e9", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -18,7 +18,6 @@ use std::io;\n \n use syntax::parse;\n use syntax::parse::lexer;\n-use syntax::diagnostic;\n use syntax::codemap::{BytePos, Span};\n \n use html::escape::Escape;\n@@ -28,13 +27,11 @@ use t = syntax::parse::token;\n /// Highlights some source code, returning the HTML output.\n pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n     let sess = parse::new_parse_sess();\n-    let handler = diagnostic::default_handler();\n-    let span_handler = diagnostic::mk_span_handler(handler, sess.cm);\n-    let fm = parse::string_to_filemap(sess, src.to_owned(), ~\"<stdin>\");\n+    let fm = parse::string_to_filemap(&sess, src.to_owned(), ~\"<stdin>\");\n \n     let mut out = io::MemWriter::new();\n-    doit(sess,\n-         lexer::new_string_reader(span_handler, fm),\n+    doit(&sess,\n+         lexer::new_string_reader(&sess.span_diagnostic, fm),\n          class,\n          &mut out).unwrap();\n     str::from_utf8_lossy(out.unwrap()).into_owned()\n@@ -47,7 +44,7 @@ pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n /// it's used. All source code emission is done as slices from the source map,\n /// not from the tokens themselves, in order to stay true to the original\n /// source.\n-fn doit(sess: @parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>,\n+fn doit(sess: &parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>,\n         out: &mut Writer) -> io::IoResult<()> {\n     use syntax::parse::lexer::Reader;\n \n@@ -68,7 +65,7 @@ fn doit(sess: @parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>\n         // comment. This will classify some whitespace as a comment, but that\n         // doesn't matter too much for syntax highlighting purposes.\n         if test > last {\n-            let snip = sess.cm.span_to_snippet(Span {\n+            let snip = sess.span_diagnostic.cm.span_to_snippet(Span {\n                 lo: last,\n                 hi: test,\n                 expn_info: None,\n@@ -172,7 +169,7 @@ fn doit(sess: @parse::ParseSess, lexer: lexer::StringReader, class: Option<&str>\n \n         // as mentioned above, use the original source code instead of\n         // stringifying this token\n-        let snip = sess.cm.span_to_snippet(next.sp).unwrap();\n+        let snip = sess.span_diagnostic.cm.span_to_snippet(next.sp).unwrap();\n         if klass == \"\" {\n             try!(write!(out, \"{}\", Escape(snip)));\n         } else {"}, {"sha": "e64292285d00dc774fa08fcd91474084f63bff1b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -28,7 +28,6 @@ extern crate time;\n #[phase(syntax, link)]\n extern crate log;\n \n-use std::cell::RefCell;\n use std::local_data;\n use std::io;\n use std::io::{File, MemWriter};\n@@ -155,8 +154,7 @@ pub fn main_args(args: &[~str]) -> int {\n     }\n     let input = matches.free[0].as_slice();\n \n-    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n-    let libs = @RefCell::new(libs.move_iter().collect());\n+    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice())).move_iter().collect();\n \n     let test_args = matches.opt_strs(\"test-args\");\n     let test_args = test_args.iter().flat_map(|s| s.words()).map(|s| s.to_owned()).to_owned_vec();"}, {"sha": "bd15d1b13317f9c4475ff183b4611fd5964a9169", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::{str, io};\n-use std::cell::RefCell;\n use std::vec_ng::Vec;\n \n use collections::HashSet;\n@@ -160,7 +159,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n }\n \n /// Run any tests/code examples in the markdown file `input`.\n-pub fn test(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -> int {\n+pub fn test(input: &str, libs: HashSet<Path>, mut test_args: ~[~str]) -> int {\n     let input_str = load_or_return!(input, 1, 2);\n \n     let mut collector = Collector::new(input.to_owned(), libs, true, true);"}, {"sha": "0a472a0ccaf2fe88970cc0eb33e207a3bb24c483", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -23,7 +23,6 @@ use rustc::driver::driver;\n use rustc::driver::session;\n use rustc::metadata::creader::Loader;\n use syntax::diagnostic;\n-use syntax::parse;\n use syntax::codemap::CodeMap;\n \n use core;\n@@ -34,41 +33,35 @@ use html::markdown;\n use passes;\n use visit_ast::RustdocVisitor;\n \n-pub fn run(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -> int {\n+pub fn run(input: &str, libs: HashSet<Path>, mut test_args: ~[~str]) -> int {\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n \n-    let sessopts = @session::Options {\n-        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n-        addl_lib_search_paths: libs,\n+    let sessopts = session::Options {\n+        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        addl_lib_search_paths: RefCell::new(libs.clone()),\n         crate_types: vec!(session::CrateTypeDylib),\n-        .. (*session::basic_options()).clone()\n+        ..session::basic_options().clone()\n     };\n \n \n-    let cm = @CodeMap::new();\n+    let codemap = CodeMap::new();\n     let diagnostic_handler = diagnostic::default_handler();\n     let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, cm);\n-    let parsesess = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n-                                                          cm);\n+    diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = driver::build_session_(sessopts,\n                                       Some(input_path),\n-                                      parsesess.cm,\n                                       span_diagnostic_handler);\n \n-    let cfg = driver::build_configuration(sess);\n-    let krate = driver::phase_1_parse_input(sess, cfg, &input);\n-    let loader = &mut Loader::new(sess);\n-    let id = from_str(\"rustdoc-test\").unwrap();\n-    let (krate, _) = driver::phase_2_configure_and_expand(sess, loader, krate,\n-                                                          &id);\n+    let cfg = driver::build_configuration(&sess);\n+    let krate = driver::phase_1_parse_input(&sess, cfg, &input);\n+    let (krate, _) = driver::phase_2_configure_and_expand(&sess, &mut Loader::new(&sess), krate,\n+                                                          &from_str(\"rustdoc-test\").unwrap());\n \n     let ctx = @core::DocContext {\n         krate: krate,\n-        tycx: None,\n-        sess: sess,\n+        maybe_typed: core::NotTyped(sess),\n     };\n     local_data::set(super::ctxtkey, ctx);\n \n@@ -91,19 +84,18 @@ pub fn run(input: &str, libs: @RefCell<HashSet<Path>>, mut test_args: ~[~str]) -\n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n            no_run: bool, loose_feature_gating: bool) {\n     let test = maketest(test, cratename, loose_feature_gating);\n-    let parsesess = parse::new_parse_sess();\n     let input = driver::StrInput(test);\n \n-    let sessopts = @session::Options {\n-        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n-        addl_lib_search_paths: @RefCell::new(libs),\n+    let sessopts = session::Options {\n+        maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n+        addl_lib_search_paths: RefCell::new(libs),\n         crate_types: vec!(session::CrateTypeExecutable),\n         output_types: vec!(link::OutputTypeExe),\n         cg: session::CodegenOptions {\n             prefer_dynamic: true,\n             .. session::basic_codegen_options()\n         },\n-        .. (*session::basic_options()).clone()\n+        ..session::basic_options().clone()\n     };\n \n     // Shuffle around a few input and output handles here. We're going to pass\n@@ -129,18 +121,18 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let emitter = diagnostic::EmitterWriter::new(~w2);\n \n     // Compile the code\n+    let codemap = CodeMap::new();\n     let diagnostic_handler = diagnostic::mk_handler(~emitter);\n     let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+        diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n     let sess = driver::build_session_(sessopts,\n                                       None,\n-                                      parsesess.cm,\n                                       span_diagnostic_handler);\n \n     let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");\n     let out = Some(outdir.path().clone());\n-    let cfg = driver::build_configuration(sess);\n+    let cfg = driver::build_configuration(&sess);\n     driver::compile_input(sess, cfg, &input, &out, &None);\n \n     if no_run { return }\n@@ -197,7 +189,7 @@ fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n pub struct Collector {\n     tests: ~[testing::TestDescAndFn],\n     priv names: ~[~str],\n-    priv libs: @RefCell<HashSet<Path>>,\n+    priv libs: HashSet<Path>,\n     priv cnt: uint,\n     priv use_headers: bool,\n     priv current_header: Option<~str>,\n@@ -207,7 +199,7 @@ pub struct Collector {\n }\n \n impl Collector {\n-    pub fn new(cratename: ~str, libs: @RefCell<HashSet<Path>>,\n+    pub fn new(cratename: ~str, libs: HashSet<Path>,\n                use_headers: bool, loose_feature_gating: bool) -> Collector {\n         Collector {\n             tests: ~[],\n@@ -230,8 +222,7 @@ impl Collector {\n             format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n         };\n         self.cnt += 1;\n-        let libs = self.libs.borrow();\n-        let libs = (*libs.get()).clone();\n+        let libs = self.libs.clone();\n         let cratename = self.cratename.to_owned();\n         let loose_feature_gating = self.loose_feature_gating;\n         debug!(\"Creating test {}: {}\", name, test);"}, {"sha": "c0a39112b69a74dcc1e481dc41d3179dce514fa7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -183,21 +183,18 @@ impl<'a> RustdocVisitor<'a> {\n \n     fn resolve_id(&mut self, id: ast::NodeId, glob: bool,\n                   om: &mut Module) -> bool {\n-        let def = {\n-            let dm = match self.cx.tycx {\n-                Some(tcx) => tcx.def_map.borrow(),\n-                None => return false,\n-            };\n-            ast_util::def_id_of_def(*dm.get().get(&id))\n+        let tcx = match self.cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => return false\n         };\n+        let def = ast_util::def_id_of_def(*tcx.def_map.borrow().get().get(&id));\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false\n         };\n         if analysis.public_items.contains(&def.node) { return false }\n \n-        let item = self.cx.tycx.unwrap().map.get(def.node);\n-        match item {\n+        match tcx.map.get(def.node) {\n             ast_map::NodeItem(it) => {\n                 if glob {\n                     match it.node {"}, {"sha": "65a0f473db2295b1fa81974157c0f9fc7dadc910", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -375,7 +375,7 @@ pub fn find_stability<AM: AttrMetaMethods, It: Iterator<AM>>(mut metas: It)\n     None\n }\n \n-pub fn require_unique_names(diagnostic: @SpanHandler, metas: &[@MetaItem]) {\n+pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[@MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas.iter() {\n         let name = meta.name();\n@@ -400,7 +400,7 @@ pub fn require_unique_names(diagnostic: @SpanHandler, metas: &[@MetaItem]) {\n  * present (before fields, if any) with that type; reprensentation\n  * optimizations which would remove it will not be done.\n  */\n-pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n+pub fn find_repr_attr(diagnostic: &SpanHandler, attr: @ast::MetaItem, acc: ReprAttr)\n     -> ReprAttr {\n     let mut acc = acc;\n     match attr.node {\n@@ -438,7 +438,7 @@ pub fn find_repr_attr(diagnostic: @SpanHandler, attr: @ast::MetaItem, acc: ReprA\n         // Not a \"repr\" hint: ignore.\n         _ => { }\n     }\n-    return acc;\n+    acc\n }\n \n fn int_type_of_word(s: &str) -> Option<IntType> {"}, {"sha": "4bfd5391a8f10d1e1642b788cd592c85d3c4df69", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 54, "deletions": 67, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -23,6 +23,7 @@ source code snippets, etc.\n \n use std::cell::RefCell;\n use std::cmp;\n+use std::rc::Rc;\n use std::vec_ng::Vec;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n@@ -140,7 +141,7 @@ pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n /// A source code location used for error reporting\n pub struct Loc {\n     /// Information about the original source\n-    file: @FileMap,\n+    file: Rc<FileMap>,\n     /// The (1-based) line number\n     line: uint,\n     /// The (0-based) column offset\n@@ -154,12 +155,12 @@ pub struct LocWithOpt {\n     filename: FileName,\n     line: uint,\n     col: CharPos,\n-    file: Option<@FileMap>,\n+    file: Option<Rc<FileMap>>,\n }\n \n // used to be structural records. Better names, anyone?\n-pub struct FileMapAndLine {fm: @FileMap, line: uint}\n-pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n+pub struct FileMapAndLine {fm: Rc<FileMap>, line: uint}\n+pub struct FileMapAndBytePos {fm: Rc<FileMap>, pos: BytePos}\n \n #[deriving(Clone, Hash, Show)]\n pub enum MacroFormat {\n@@ -186,10 +187,10 @@ pub struct ExpnInfo {\n \n pub type FileName = ~str;\n \n-pub struct FileLines\n-{\n-    file: @FileMap,\n-    lines: Vec<uint> }\n+pub struct FileLines {\n+    file: Rc<FileMap>,\n+    lines: Vec<uint>\n+}\n \n /// Identifies an offset of a multi-byte character in a FileMap\n pub struct MultiByteChar {\n@@ -251,8 +252,7 @@ impl FileMap {\n             pos: pos,\n             bytes: bytes,\n         };\n-        let mut multibyte_chars = self.multibyte_chars.borrow_mut();\n-        multibyte_chars.get().push(mbc);\n+        self.multibyte_chars.borrow_mut().get().push(mbc);\n     }\n \n     pub fn is_real_file(&self) -> bool {\n@@ -261,7 +261,7 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    files: RefCell<Vec<@FileMap> >\n+    files: RefCell<Vec<Rc<FileMap>>>\n }\n \n impl CodeMap {\n@@ -271,11 +271,11 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn new_filemap(&self, filename: FileName, mut src: ~str) -> @FileMap {\n+    pub fn new_filemap(&self, filename: FileName, mut src: ~str) -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.get().last() {\n             None => 0,\n-            Some(last) => last.start_pos.to_uint() + last.src.len(),\n+            Some(last) => last.deref().start_pos.to_uint() + last.deref().src.len(),\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -286,46 +286,42 @@ impl CodeMap {\n             src.push_char('\\n');\n         }\n \n-        let filemap = @FileMap {\n+        let filemap = Rc::new(FileMap {\n             name: filename,\n             src: src,\n             start_pos: Pos::from_uint(start_pos),\n             lines: RefCell::new(Vec::new()),\n             multibyte_chars: RefCell::new(Vec::new()),\n-        };\n+        });\n \n-        files.get().push(filemap);\n+        files.get().push(filemap.clone());\n \n-        return filemap;\n+        filemap\n     }\n \n     pub fn mk_substr_filename(&self, sp: Span) -> ~str {\n         let pos = self.lookup_char_pos(sp.lo);\n-        return format!(\"<{}:{}:{}>\", pos.file.name,\n-                       pos.line, pos.col.to_uint() + 1)\n+        format!(\"<{}:{}:{}>\", pos.file.deref().name, pos.line, pos.col.to_uint() + 1)\n     }\n \n     /// Lookup source information about a BytePos\n     pub fn lookup_char_pos(&self, pos: BytePos) -> Loc {\n-        return self.lookup_pos(pos);\n+        self.lookup_pos(pos)\n     }\n \n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n         LocWithOpt {\n-            filename: loc.file.name.to_str(),\n+            filename: loc.file.deref().name.to_str(),\n             line: loc.line,\n             col: loc.col,\n             file: Some(loc.file)\n         }\n     }\n \n     pub fn span_to_str(&self, sp: Span) -> ~str {\n-        {\n-            let files = self.files.borrow();\n-            if files.get().len() == 0 && sp == DUMMY_SP {\n-                return ~\"no-location\";\n-            }\n+        if self.files.borrow().get().len() == 0 && sp == DUMMY_SP {\n+            return ~\"no-location\";\n         }\n \n         let lo = self.lookup_char_pos_adj(sp.lo);\n@@ -335,18 +331,17 @@ impl CodeMap {\n     }\n \n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n-        let lo = self.lookup_char_pos(sp.lo);\n-        lo.file.name.to_str()\n+        self.lookup_char_pos(sp.lo).file.deref().name.to_str()\n     }\n \n-    pub fn span_to_lines(&self, sp: Span) -> @FileLines {\n+    pub fn span_to_lines(&self, sp: Span) -> FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n         for i in range(lo.line - 1u, hi.line as uint) {\n             lines.push(i);\n         };\n-        return @FileLines {file: lo.file, lines: lines};\n+        FileLines {file: lo.file, lines: lines}\n     }\n \n     pub fn span_to_snippet(&self, sp: Span) -> Option<~str> {\n@@ -357,27 +352,22 @@ impl CodeMap {\n         // it's testing isn't true for all spans in the AST, so to allow the\n         // caller to not have to fail (and it can't catch it since the CodeMap\n         // isn't sendable), return None\n-        if begin.fm.start_pos != end.fm.start_pos {\n+        if begin.fm.deref().start_pos != end.fm.deref().start_pos {\n             None\n         } else {\n-            Some(begin.fm.src.slice( begin.pos.to_uint(), end.pos.to_uint()).to_owned())\n+            Some(begin.fm.deref().src.slice( begin.pos.to_uint(), end.pos.to_uint()).to_owned())\n         }\n     }\n \n-    pub fn get_filemap(&self, filename: &str) -> @FileMap {\n-        let files = self.files.borrow();\n-        for fm in files.get().iter() {\n-            if filename == fm.name {\n-                return *fm\n+    pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n+        for fm in self.files.borrow().get().iter() {\n+            if filename == fm.deref().name {\n+                return fm.clone();\n             }\n         }\n-        //XXjdm the following triggers a mismatched type bug\n-        //      (or expected function, found _|_)\n-        fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n+        fail!(\"asking for {} which we don't know about\", filename);\n     }\n-}\n \n-impl CodeMap {\n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = self.files.borrow();\n         let files = files.get();\n@@ -386,7 +376,7 @@ impl CodeMap {\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if files.get(m).start_pos > pos {\n+            if files.get(m).deref().start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n@@ -396,7 +386,7 @@ impl CodeMap {\n         // filemap, but are not the filemaps we want (because they are length 0, they cannot\n         // contain what we are looking for). So, rewind until we find a useful filemap.\n         loop {\n-            let lines = files.get(a).lines.borrow();\n+            let lines = files.get(a).deref().lines.borrow();\n             let lines = lines.get();\n             if lines.len() > 0 {\n                 break;\n@@ -413,49 +403,47 @@ impl CodeMap {\n         return a;\n     }\n \n-    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine\n-    {\n+    fn lookup_line(&self, pos: BytePos) -> FileMapAndLine {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n-        let f = *files.get().get(idx);\n+        let f = files.get().get(idx).clone();\n         let mut a = 0u;\n-        let mut lines = f.lines.borrow_mut();\n-        let mut b = lines.get().len();\n-        while b - a > 1u {\n-            let m = (a + b) / 2u;\n-            if *lines.get().get(m) > pos { b = m; } else { a = m; }\n+        {\n+            let mut lines = f.deref().lines.borrow_mut();\n+            let mut b = lines.get().len();\n+            while b - a > 1u {\n+                let m = (a + b) / 2u;\n+                if *lines.get().get(m) > pos { b = m; } else { a = m; }\n+            }\n         }\n-        return FileMapAndLine {fm: f, line: a};\n+        FileMapAndLine {fm: f, line: a}\n     }\n \n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n-        let lines = f.lines.borrow();\n-        let linebpos = *lines.get().get(a);\n+        let linebpos = *f.deref().lines.borrow().get().get(a);\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n         debug!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n                chpos, linechpos);\n         debug!(\"codemap: byte is on line: {:?}\", line);\n         assert!(chpos >= linechpos);\n-        return Loc {\n+        Loc {\n             file: f,\n             line: line,\n             col: chpos - linechpos\n-        };\n+        }\n     }\n \n-    fn lookup_byte_offset(&self, bpos: BytePos)\n-        -> FileMapAndBytePos {\n+    fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let files = self.files.borrow();\n-        let fm = *files.get().get(idx);\n-        let offset = bpos - fm.start_pos;\n-        return FileMapAndBytePos {fm: fm, pos: offset};\n+        let fm = self.files.borrow().get().get(idx).clone();\n+        let offset = bpos - fm.deref().start_pos;\n+        FileMapAndBytePos {fm: fm, pos: offset}\n     }\n \n     // Converts an absolute BytePos to a CharPos relative to the filemap.\n@@ -468,8 +456,7 @@ impl CodeMap {\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n-        let multibyte_chars = map.multibyte_chars.borrow();\n-        for mbc in multibyte_chars.get().iter() {\n+        for mbc in map.deref().multibyte_chars.borrow().get().iter() {\n             debug!(\"codemap: {:?}-byte char at {:?}\", mbc.bytes, mbc.pos);\n             if mbc.pos < bpos {\n                 // every character is at least one byte, so we only\n@@ -483,8 +470,8 @@ impl CodeMap {\n             }\n         }\n \n-        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n-        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n+        assert!(map.deref().start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n+        CharPos(bpos.to_uint() - map.deref().start_pos.to_uint() - total_extra_bytes)\n     }\n }\n "}, {"sha": "c88c5a3c4e6f6bb908846052ae0aab97f25233f8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -40,37 +40,37 @@ pub struct ExplicitBug;\n // accepts span information for source-location\n // reporting.\n pub struct SpanHandler {\n-    handler: @Handler,\n-    cm: @codemap::CodeMap,\n+    handler: Handler,\n+    cm: codemap::CodeMap,\n }\n \n impl SpanHandler {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Fatal);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n         fail!(FatalError);\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Error);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Error);\n         self.handler.bump_err_count();\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Warning);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Warning);\n     }\n     pub fn span_note(&self, sp: Span, msg: &str) {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Note);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Note);\n     }\n     pub fn span_end_note(&self, sp: Span, msg: &str) {\n-        self.handler.custom_emit(&*self.cm, sp, msg, Note);\n+        self.handler.custom_emit(&self.cm, sp, msg, Note);\n     }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n-        self.handler.emit(Some((&*self.cm, sp)), msg, Bug);\n+        self.handler.emit(Some((&self.cm, sp)), msg, Bug);\n         fail!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    pub fn handler(&self) -> @Handler {\n-        self.handler\n+    pub fn handler<'a>(&'a self) -> &'a Handler {\n+        &self.handler\n     }\n }\n \n@@ -137,20 +137,19 @@ impl Handler {\n     }\n }\n \n-pub fn mk_span_handler(handler: @Handler, cm: @codemap::CodeMap)\n-                       -> @SpanHandler {\n-    @SpanHandler {\n+pub fn mk_span_handler(handler: Handler, cm: codemap::CodeMap) -> SpanHandler {\n+    SpanHandler {\n         handler: handler,\n         cm: cm,\n     }\n }\n \n-pub fn default_handler() -> @Handler {\n+pub fn default_handler() -> Handler {\n     mk_handler(~EmitterWriter::stderr())\n }\n \n-pub fn mk_handler(e: ~Emitter) -> @Handler {\n-    @Handler {\n+pub fn mk_handler(e: ~Emitter) -> Handler {\n+    Handler {\n         err_count: Cell::new(0),\n         emit: RefCell::new(e),\n     }\n@@ -301,8 +300,8 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: &codemap::FileLines) -> io::IoResult<()> {\n-    let fm = lines.file;\n+                   lines: codemap::FileLines) -> io::IoResult<()> {\n+    let fm = lines.file.deref();\n \n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n@@ -374,8 +373,8 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: &codemap::FileLines) -> io::IoResult<()> {\n-    let fm = lines.file;\n+                          lines: codemap::FileLines) -> io::IoResult<()> {\n+    let fm = lines.file.deref();\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {\n@@ -420,8 +419,7 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n     Ok(())\n }\n \n-pub fn expect<T:Clone>(diag: @SpanHandler, opt: Option<T>, msg: || -> ~str)\n-              -> T {\n+pub fn expect<T:Clone>(diag: &SpanHandler, opt: Option<T>, msg: || -> ~str) -> T {\n     match opt {\n        Some(ref t) => (*t).clone(),\n        None => diag.handler().bug(msg()),"}, {"sha": "df2c265e6ebf3cd6a42a3efd879bf403e6a1446a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -289,7 +289,7 @@ pub trait CrateLoader {\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n-    parse_sess: @parse::ParseSess,\n+    parse_sess: &'a parse::ParseSess,\n     cfg: ast::CrateConfig,\n     backtrace: Option<@ExpnInfo>,\n     ecfg: expand::ExpansionConfig<'a>,\n@@ -299,7 +299,7 @@ pub struct ExtCtxt<'a> {\n }\n \n impl<'a> ExtCtxt<'a> {\n-    pub fn new<'a>(parse_sess: @parse::ParseSess, cfg: ast::CrateConfig,\n+    pub fn new<'a>(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                    ecfg: expand::ExpansionConfig<'a>) -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n@@ -326,8 +326,8 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n \n-    pub fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n-    pub fn parse_sess(&self) -> @parse::ParseSess { self.parse_sess }\n+    pub fn codemap(&self) -> &'a CodeMap { &self.parse_sess.span_diagnostic.cm }\n+    pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n         match self.backtrace {"}, {"sha": "7c42476bc01bf3111748596d04642deca3e51c3d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -633,7 +633,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             vec!(\n                 self.expr_str(span, msg),\n                 self.expr_str(span,\n-                              token::intern_and_get_ident(loc.file.name)),\n+                              token::intern_and_get_ident(loc.file.deref().name)),\n                 self.expr_uint(span, loc.line)))\n     }\n "}, {"sha": "75ade160380b2d6970d55d71cf4926b4c14722ca", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -838,12 +838,12 @@ pub fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     }\n }\n \n-pub struct MacroExpander<'a> {\n+pub struct MacroExpander<'a, 'b> {\n     extsbox: SyntaxEnv,\n-    cx: &'a mut ExtCtxt<'a>,\n+    cx: &'a mut ExtCtxt<'b>,\n }\n \n-impl<'a> Folder for MacroExpander<'a> {\n+impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     fn fold_expr(&mut self, expr: @ast::Expr) -> @ast::Expr {\n         expand_expr(expr, self)\n     }\n@@ -875,7 +875,7 @@ pub struct ExpansionConfig<'a> {\n     crate_id: CrateId,\n }\n \n-pub fn expand_crate(parse_sess: @parse::ParseSess,\n+pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n@@ -974,7 +974,7 @@ mod test {\n     use ext::mtwt;\n     use parse;\n     use parse::token;\n-    use util::parser_testing::{string_to_crate_and_sess};\n+    use util::parser_testing::{string_to_parser};\n     use util::parser_testing::{string_to_pat, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n@@ -1044,15 +1044,15 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            Vec::new(),sess);\n+            Vec::new(), &sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(sess,cfg,crate_ast);\n+        expand_crate(&sess,cfg,crate_ast);\n     }\n \n     // make sure that macros can leave scope for modules\n@@ -1064,15 +1064,15 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            Vec::new(),sess);\n+            Vec::new(), &sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(sess,cfg,crate_ast);\n+        expand_crate(&sess,cfg,crate_ast);\n     }\n \n     // macro_escape modules shouldn't cause macros to leave scope\n@@ -1083,15 +1083,15 @@ mod test {\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n-            Vec::new(), sess);\n+            Vec::new(), &sess);\n         // should fail:\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(sess, cfg, crate_ast);\n+        expand_crate(&sess, cfg, crate_ast);\n     }\n \n     #[test] fn test_contains_flatten (){\n@@ -1126,15 +1126,16 @@ mod test {\n     //}\n \n     fn expand_crate_str(crate_str: ~str) -> ast::Crate {\n-        let (crate_ast,ps) = string_to_crate_and_sess(crate_str);\n+        let ps = parse::new_parse_sess();\n+        let crate_ast = string_to_parser(&ps, crate_str).parse_crate_mod();\n         // the cfg argument actually does matter, here...\n         let mut loader = ErrLoader;\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             loader: &mut loader,\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n         };\n-        expand_crate(ps,cfg,crate_ast)\n+        expand_crate(&ps,cfg,crate_ast)\n     }\n \n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {"}, {"sha": "e79e584ed5cc7161d11c9de2525e09d7b57755d5", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -35,8 +35,8 @@ enum Position {\n     Named(~str),\n }\n \n-struct Context<'a> {\n-    ecx: &'a mut ExtCtxt<'a>,\n+struct Context<'a, 'b> {\n+    ecx: &'a mut ExtCtxt<'b>,\n     fmtsp: Span,\n \n     // Parsed argument expressions and the types that we've found so far for\n@@ -142,7 +142,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     return (extra, Some((fmtstr, args, order, names)));\n }\n \n-impl<'a> Context<'a> {\n+impl<'a, 'b> Context<'a, 'b> {\n     /// Verifies one piece of a parse string. All errors are not emitted as\n     /// fatal so we can continue giving errors about this and possibly other\n     /// format strings."}, {"sha": "d8bf726da79819b25ed9856de96c09850aa3f89b", "filename": "src/libsyntax/ext/registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -37,7 +37,7 @@ impl Visitor<()> for MacroRegistrarContext {\n     }\n }\n \n-pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n+pub fn find_macro_registrar(diagnostic: &diagnostic::SpanHandler,\n                             krate: &ast::Crate) -> Option<ast::DefId> {\n     let mut ctx = MacroRegistrarContext { registrars: Vec::new() };\n     visit::walk_crate(&mut ctx, krate, ());"}, {"sha": "137cd89bf30b7e450b8b016e2ecece8c06dbde08", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -57,7 +57,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name);\n+    let filename = token::intern_and_get_ident(loc.file.deref().name);\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n@@ -117,7 +117,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // dependency information\n             let filename = file.display().to_str();\n             let interned = token::intern_and_get_ident(src);\n-            cx.parse_sess.cm.new_filemap(filename, src);\n+            cx.codemap().new_filemap(filename, src);\n \n             base::MRExpr(cx.expr_str(sp, interned))\n         }"}, {"sha": "fa49f06e516714c613bab55632d1b7f0e68bc037", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -22,7 +22,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                         -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n+    let tt_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                None,\n                                tt.iter().map(|x| (*x).clone()).collect());\n     let mut rust_parser = Parser(sess, cfg.clone(), tt_rdr.dup());"}, {"sha": "698bde4578c8d521b23daaaa2856340d446ec2fa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -170,9 +170,9 @@ pub enum NamedMatch {\n     MatchedNonterminal(Nonterminal)\n }\n \n-pub fn nameize(p_s: @ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n+pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n             -> HashMap<Ident, @NamedMatch> {\n-    fn n_rec(p_s: @ParseSess, m: &Matcher, res: &[@NamedMatch],\n+    fn n_rec(p_s: &ParseSess, m: &Matcher, res: &[@NamedMatch],\n              ret_val: &mut HashMap<Ident, @NamedMatch>) {\n         match *m {\n           codemap::Spanned {node: MatchTok(_), .. } => (),\n@@ -205,7 +205,7 @@ pub enum ParseResult {\n     Error(codemap::Span, ~str)\n }\n \n-pub fn parse_or_else<R: Reader>(sess: @ParseSess,\n+pub fn parse_or_else<R: Reader>(sess: &ParseSess,\n                                 cfg: ast::CrateConfig,\n                                 rdr: R,\n                                 ms: Vec<Matcher> )\n@@ -227,7 +227,7 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse<R: Reader>(sess: @ParseSess,\n+pub fn parse<R: Reader>(sess: &ParseSess,\n                         cfg: ast::CrateConfig,\n                         rdr: R,\n                         ms: &[Matcher])"}, {"sha": "3f4ed0b1e8e02fcafe8fc6de468428343c9d8468", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -30,11 +30,11 @@ use util::small_vector::SmallVector;\n use std::cell::RefCell;\n use std::vec_ng::Vec;\n \n-struct ParserAnyMacro {\n-    parser: RefCell<Parser>,\n+struct ParserAnyMacro<'a> {\n+    parser: RefCell<Parser<'a>>,\n }\n \n-impl ParserAnyMacro {\n+impl<'a> ParserAnyMacro<'a> {\n     /// Make sure we don't have any tokens left to parse, so we don't\n     /// silently drop anything. `allow_semi` is so that \"optional\"\n     /// semilons at the end of normal expressions aren't complained\n@@ -57,7 +57,7 @@ impl ParserAnyMacro {\n     }\n }\n \n-impl AnyMacro for ParserAnyMacro {\n+impl<'a> AnyMacro for ParserAnyMacro<'a> {\n     fn make_expr(&self) -> @ast::Expr {\n         let ret = {\n             let mut parser = self.parser.borrow_mut();\n@@ -131,13 +131,11 @@ fn generic_extension(cx: &ExtCtxt,\n     let mut best_fail_spot = DUMMY_SP;\n     let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n-    let s_d = cx.parse_sess().span_diagnostic;\n-\n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n         match **lhs {\n           MatchedNonterminal(NtMatchers(ref mtcs)) => {\n             // `None` is because we're not interpolating\n-            let arg_rdr = new_tt_reader(s_d,\n+            let arg_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                         None,\n                                         arg.iter()\n                                            .map(|x| (*x).clone())\n@@ -162,7 +160,8 @@ fn generic_extension(cx: &ExtCtxt,\n                     _ => cx.span_bug(sp, \"bad thing in rhs\")\n                 };\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let trncbr = new_tt_reader(s_d, Some(named_matches),\n+                let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n+                                           Some(named_matches),\n                                            rhs);\n                 let p = Parser(cx.parse_sess(), cx.cfg(), ~trncbr);\n                 // Let the context choose how to interpret the result.\n@@ -218,7 +217,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n-    let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n+    let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                    None,\n                                    arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),"}, {"sha": "e120f07742e7544367080b87ecbe2ada86c99727", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -30,8 +30,8 @@ struct TtFrame {\n     up: Option<@TtFrame>,\n }\n \n-pub struct TtReader {\n-    sp_diag: @SpanHandler,\n+pub struct TtReader<'a> {\n+    sp_diag: &'a SpanHandler,\n     // the unzipped tree:\n     priv stack: RefCell<@TtFrame>,\n     /* for MBE-style macro transcription */\n@@ -46,10 +46,10 @@ pub struct TtReader {\n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `TTSeq`s and `TTNonterminal`s, `interp` can (and\n  *  should) be none. */\n-pub fn new_tt_reader(sp_diag: @SpanHandler,\n-                     interp: Option<HashMap<Ident, @NamedMatch>>,\n-                     src: Vec<ast::TokenTree> )\n-                     -> TtReader {\n+pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n+                         interp: Option<HashMap<Ident, @NamedMatch>>,\n+                         src: Vec<ast::TokenTree> )\n+                         -> TtReader<'a> {\n     let r = TtReader {\n         sp_diag: sp_diag,\n         stack: RefCell::new(@TtFrame {\n@@ -70,7 +70,7 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n         cur_span: RefCell::new(DUMMY_SP),\n     };\n     tt_next_token(&r); /* get cur_tok and cur_span set up */\n-    return r;\n+    r\n }\n \n fn dup_tt_frame(f: @TtFrame) -> @TtFrame {\n@@ -86,7 +86,7 @@ fn dup_tt_frame(f: @TtFrame) -> @TtFrame {\n     }\n }\n \n-pub fn dup_tt_reader(r: &TtReader) -> TtReader {\n+pub fn dup_tt_reader<'a>(r: &TtReader<'a>) -> TtReader<'a> {\n     TtReader {\n         sp_diag: r.sp_diag,\n         stack: RefCell::new(dup_tt_frame(r.stack.get())),"}, {"sha": "973682ea7436906280f2296eda754dfb4367d96a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -880,9 +880,9 @@ mod test {\n     use super::*;\n \n     // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: &mut pprust::State,\n-                        krate: &ast::Crate) -> io::IoResult<()> {\n-        pprust::print_mod(s, &krate.module, krate.attrs.as_slice())\n+    fn fake_print_crate<A: pprust::PpAnn>(s: &mut pprust::State<A>,\n+                                          krate: &ast::Crate) -> io::IoResult<()> {\n+        s.print_mod(&krate.module, krate.attrs.as_slice())\n     }\n \n     // change every identifier to \"zz\"\n@@ -914,9 +914,10 @@ mod test {\n         let mut zz_fold = ToZzIdentFolder;\n         let ast = string_to_crate(\n             ~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+        let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate),\n+                     pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n                      ~\"#[a]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\");\n     }\n \n@@ -926,9 +927,10 @@ mod test {\n         let ast = string_to_crate(\n             ~\"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n               (g $(d $d $e)+))} \");\n+        let folded_crate = zz_fold.fold_crate(ast);\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n-                     pprust::to_str(&mut zz_fold.fold_crate(ast),fake_print_crate),\n+                     pprust::to_str(|s| fake_print_crate(s, &folded_crate)),\n                      ~\"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\");\n     }\n }"}, {"sha": "399648ef1d8810aefa72e6bd1f1a1f07d72702ff", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -28,7 +28,7 @@ pub trait ParserAttr {\n     fn parse_optional_meta(&mut self) -> Vec<@ast::MetaItem> ;\n }\n \n-impl ParserAttr for Parser {\n+impl<'a> ParserAttr for Parser<'a> {\n     // Parse attributes that appear before an item\n     fn parse_outer_attributes(&mut self) -> Vec<ast::Attribute> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();"}, {"sha": "ed74fd416d14e75cdb0b86f41328f44c2ed7f433", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -346,10 +346,10 @@ pub struct Literal {\n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n-                                        @diagnostic::SpanHandler,\n+                                        &diagnostic::SpanHandler,\n                                     path: ~str,\n                                     srdr: &mut io::Reader)\n-                                 -> (Vec<Comment> , Vec<Literal> ) {\n+                                 -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();\n     let src = str::from_utf8_owned(src).unwrap();\n     let cm = CodeMap::new();"}, {"sha": "546aefc1297c9ae3d9cc73e8e34a2bd0cba595db", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 92, "deletions": 116, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8", "patch": "@@ -18,6 +18,7 @@ use parse::token::{str_to_ident};\n \n use std::cell::{Cell, RefCell};\n use std::char;\n+use std::rc::Rc;\n use std::mem::replace;\n use std::num::from_str_radix;\n \n@@ -27,7 +28,7 @@ pub trait Reader {\n     fn is_eof(&self) -> bool;\n     fn next_token(&self) -> TokenAndSpan;\n     fn fatal(&self, ~str) -> !;\n-    fn span_diag(&self) -> @SpanHandler;\n+    fn span_diag<'a>(&'a self) -> &'a SpanHandler;\n     fn peek(&self) -> TokenAndSpan;\n     fn dup(&self) -> ~Reader:;\n }\n@@ -38,8 +39,8 @@ pub struct TokenAndSpan {\n     sp: Span,\n }\n \n-pub struct StringReader {\n-    span_diagnostic: @SpanHandler,\n+pub struct StringReader<'a> {\n+    span_diagnostic: &'a SpanHandler,\n     // The absolute offset within the codemap of the next character to read\n     pos: Cell<BytePos>,\n     // The absolute offset within the codemap of the last character read(curr)\n@@ -48,36 +49,36 @@ pub struct StringReader {\n     col: Cell<CharPos>,\n     // The last character to be read\n     curr: Cell<Option<char>>,\n-    filemap: @codemap::FileMap,\n+    filemap: Rc<codemap::FileMap>,\n     /* cached: */\n     peek_tok: RefCell<token::Token>,\n     peek_span: RefCell<Span>,\n }\n \n-impl StringReader {\n+impl<'a> StringReader<'a> {\n     pub fn curr_is(&self, c: char) -> bool {\n         self.curr.get() == Some(c)\n     }\n }\n \n-pub fn new_string_reader(span_diagnostic: @SpanHandler,\n-                         filemap: @codemap::FileMap)\n-                      -> StringReader {\n+pub fn new_string_reader<'a>(span_diagnostic: &'a SpanHandler,\n+                             filemap: Rc<codemap::FileMap>)\n+                             -> StringReader<'a> {\n     let r = new_low_level_string_reader(span_diagnostic, filemap);\n     string_advance_token(&r); /* fill in peek_* */\n     r\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n-pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n-                                   filemap: @codemap::FileMap)\n-                                -> StringReader {\n+pub fn new_low_level_string_reader<'a>(span_diagnostic: &'a SpanHandler,\n+                                       filemap: Rc<codemap::FileMap>)\n+                                       -> StringReader<'a> {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n     let r = StringReader {\n         span_diagnostic: span_diagnostic,\n-        pos: Cell::new(filemap.start_pos),\n-        last_pos: Cell::new(filemap.start_pos),\n+        pos: Cell::new(filemap.deref().start_pos),\n+        last_pos: Cell::new(filemap.deref().start_pos),\n         col: Cell::new(CharPos(0)),\n         curr: Cell::new(Some(initial_char)),\n         filemap: filemap,\n@@ -92,20 +93,20 @@ pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n // duplicating the string reader is probably a bad idea, in\n // that using them will cause interleaved pushes of line\n // offsets to the underlying filemap...\n-fn dup_string_reader(r: &StringReader) -> StringReader {\n+fn dup_string_reader<'a>(r: &StringReader<'a>) -> StringReader<'a> {\n     StringReader {\n         span_diagnostic: r.span_diagnostic,\n         pos: Cell::new(r.pos.get()),\n         last_pos: Cell::new(r.last_pos.get()),\n         col: Cell::new(r.col.get()),\n         curr: Cell::new(r.curr.get()),\n-        filemap: r.filemap,\n+        filemap: r.filemap.clone(),\n         peek_tok: r.peek_tok.clone(),\n         peek_span: r.peek_span.clone(),\n     }\n }\n \n-impl Reader for StringReader {\n+impl<'a> Reader for StringReader<'a> {\n     fn is_eof(&self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n     fn next_token(&self) -> TokenAndSpan {\n@@ -122,7 +123,7 @@ impl Reader for StringReader {\n     fn fatal(&self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(self.peek_span.get(), m)\n     }\n-    fn span_diag(&self) -> @SpanHandler { self.span_diagnostic }\n+    fn span_diag<'a>(&'a self) -> &'a SpanHandler { self.span_diagnostic }\n     fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n         TokenAndSpan {\n@@ -133,7 +134,7 @@ impl Reader for StringReader {\n     fn dup(&self) -> ~Reader: { ~dup_string_reader(self) as ~Reader: }\n }\n \n-impl Reader for TtReader {\n+impl<'a> Reader for TtReader<'a> {\n     fn is_eof(&self) -> bool {\n         let cur_tok = self.cur_tok.borrow();\n         *cur_tok.get() == token::EOF\n@@ -146,7 +147,7 @@ impl Reader for TtReader {\n     fn fatal(&self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(self.cur_span.get(), m);\n     }\n-    fn span_diag(&self) -> @SpanHandler { self.sp_diag }\n+    fn span_diag<'a>(&'a self) -> &'a SpanHandler { self.sp_diag }\n     fn peek(&self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: self.cur_tok.get(),\n@@ -189,7 +190,7 @@ fn fatal_span_verbose(rdr: &StringReader,\n                    -> ! {\n     let mut m = m;\n     m.push_str(\": \");\n-    let s = rdr.filemap.src.slice(\n+    let s = rdr.filemap.deref().src.slice(\n                   byte_offset(rdr, from_pos).to_uint(),\n                   byte_offset(rdr, to_pos).to_uint());\n     m.push_str(s);\n@@ -218,7 +219,7 @@ fn string_advance_token(r: &StringReader) {\n }\n \n fn byte_offset(rdr: &StringReader, pos: BytePos) -> BytePos {\n-    (pos - rdr.filemap.start_pos)\n+    (pos - rdr.filemap.deref().start_pos)\n }\n \n /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -240,7 +241,7 @@ fn with_str_from_to<T>(\n                     end: BytePos,\n                     f: |s: &str| -> T)\n                     -> T {\n-    f(rdr.filemap.src.slice(\n+    f(rdr.filemap.deref().src.slice(\n             byte_offset(rdr, start).to_uint(),\n             byte_offset(rdr, end).to_uint()))\n }\n@@ -250,21 +251,21 @@ fn with_str_from_to<T>(\n pub fn bump(rdr: &StringReader) {\n     rdr.last_pos.set(rdr.pos.get());\n     let current_byte_offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if current_byte_offset < (rdr.filemap.src).len() {\n+    if current_byte_offset < rdr.filemap.deref().src.len() {\n         assert!(rdr.curr.get().is_some());\n         let last_char = rdr.curr.get().unwrap();\n-        let next = rdr.filemap.src.char_range_at(current_byte_offset);\n+        let next = rdr.filemap.deref().src.char_range_at(current_byte_offset);\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos.set(rdr.pos.get() + Pos::from_uint(byte_offset_diff));\n         rdr.curr.set(Some(next.ch));\n         rdr.col.set(rdr.col.get() + CharPos(1u));\n         if last_char == '\\n' {\n-            rdr.filemap.next_line(rdr.last_pos.get());\n+            rdr.filemap.deref().next_line(rdr.last_pos.get());\n             rdr.col.set(CharPos(0u));\n         }\n \n         if byte_offset_diff > 1 {\n-            rdr.filemap.record_multibyte_char(rdr.last_pos.get(), byte_offset_diff);\n+            rdr.filemap.deref().record_multibyte_char(rdr.last_pos.get(), byte_offset_diff);\n         }\n     } else {\n         rdr.curr.set(None);\n@@ -275,8 +276,8 @@ pub fn is_eof(rdr: &StringReader) -> bool {\n }\n pub fn nextch(rdr: &StringReader) -> Option<char> {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n-    if offset < (rdr.filemap.src).len() {\n-        Some(rdr.filemap.src.char_at(offset))\n+    if offset < rdr.filemap.deref().src.len() {\n+        Some(rdr.filemap.deref().src.char_at(offset))\n     } else {\n         None\n     }\n@@ -334,56 +335,55 @@ fn consume_any_line_comment(rdr: &StringReader)\n                          -> Option<TokenAndSpan> {\n     if rdr.curr_is('/') {\n         match nextch(rdr) {\n-          Some('/') => {\n-            bump(rdr);\n-            bump(rdr);\n-            // line comments starting with \"///\" or \"//!\" are doc-comments\n-            if rdr.curr_is('/') || rdr.curr_is('!') {\n-                let start_bpos = rdr.pos.get() - BytePos(3);\n-                while !rdr.curr_is('\\n') && !is_eof(rdr) {\n-                    bump(rdr);\n-                }\n-                let ret = with_str_from(rdr, start_bpos, |string| {\n-                    // but comments with only more \"/\"s are not\n-                    if !is_line_non_doc_comment(string) {\n-                        Some(TokenAndSpan{\n-                            tok: token::DOC_COMMENT(str_to_ident(string)),\n-                            sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n-                        })\n-                    } else {\n-                        None\n+            Some('/') => {\n+                bump(rdr);\n+                bump(rdr);\n+                // line comments starting with \"///\" or \"//!\" are doc-comments\n+                if rdr.curr_is('/') || rdr.curr_is('!') {\n+                    let start_bpos = rdr.pos.get() - BytePos(3);\n+                    while !rdr.curr_is('\\n') && !is_eof(rdr) {\n+                        bump(rdr);\n                     }\n-                });\n+                    let ret = with_str_from(rdr, start_bpos, |string| {\n+                        // but comments with only more \"/\"s are not\n+                        if !is_line_non_doc_comment(string) {\n+                            Some(TokenAndSpan{\n+                                tok: token::DOC_COMMENT(str_to_ident(string)),\n+                                sp: codemap::mk_sp(start_bpos, rdr.pos.get())\n+                            })\n+                        } else {\n+                            None\n+                        }\n+                    });\n \n-                if ret.is_some() {\n-                    return ret;\n+                    if ret.is_some() {\n+                        return ret;\n+                    }\n+                } else {\n+                    while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n                 }\n-            } else {\n-                while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n+                // Restart whitespace munch.\n+                consume_whitespace_and_comments(rdr)\n             }\n-            // Restart whitespace munch.\n-            return consume_whitespace_and_comments(rdr);\n-          }\n-          Some('*') => { bump(rdr); bump(rdr); return consume_block_comment(rdr); }\n-          _ => ()\n+            Some('*') => { bump(rdr); bump(rdr); consume_block_comment(rdr) }\n+            _ => None\n         }\n     } else if rdr.curr_is('#') {\n         if nextch_is(rdr, '!') {\n             // I guess this is the only way to figure out if\n             // we're at the beginning of the file...\n-            let cmap = @CodeMap::new();\n-            {\n-                let mut files = cmap.files.borrow_mut();\n-                files.get().push(rdr.filemap);\n-            }\n+            let cmap = CodeMap::new();\n+            cmap.files.borrow_mut().get().push(rdr.filemap.clone());\n             let loc = cmap.lookup_char_pos_adj(rdr.last_pos.get());\n             if loc.line == 1u && loc.col == CharPos(0u) {\n                 while !rdr.curr_is('\\n') && !is_eof(rdr) { bump(rdr); }\n                 return consume_whitespace_and_comments(rdr);\n             }\n         }\n+        None\n+    } else {\n+        None\n     }\n-    return None;\n }\n \n pub fn is_block_non_doc_comment(s: &str) -> bool {\n@@ -1007,28 +1007,24 @@ mod test {\n     use std::io::util;\n     use std::vec_ng::Vec;\n \n-    // represents a testing reader (incl. both reader and interner)\n-    struct Env {\n-        string_reader: StringReader\n+    fn mk_sh() -> diagnostic::SpanHandler {\n+        let emitter = diagnostic::EmitterWriter::new(~util::NullWriter);\n+        let handler = diagnostic::mk_handler(~emitter);\n+        diagnostic::mk_span_handler(handler, CodeMap::new())\n     }\n \n     // open a string reader for the given string\n-    fn setup(teststr: ~str) -> Env {\n-        let cm = CodeMap::new();\n-        let fm = cm.new_filemap(~\"zebra.rs\", teststr);\n-        let writer = ~util::NullWriter;\n-        let emitter = diagnostic::EmitterWriter::new(writer);\n-        let handler = diagnostic::mk_handler(~emitter);\n-        let span_handler = diagnostic::mk_span_handler(handler, @cm);\n-        Env {\n-            string_reader: new_string_reader(span_handler,fm)\n-        }\n+    fn setup<'a>(span_handler: &'a diagnostic::SpanHandler,\n+                 teststr: ~str) -> StringReader<'a> {\n+        let fm = span_handler.cm.new_filemap(~\"zebra.rs\", teststr);\n+        new_string_reader(span_handler, fm)\n     }\n \n     #[test] fn t1 () {\n-        let Env {string_reader} =\n-            setup(~\"/* my source file */ \\\n-                    fn main() { println!(\\\"zebra\\\"); }\\n\");\n+        let span_handler = mk_sh();\n+        let string_reader = setup(&span_handler,\n+            ~\"/* my source file */ \\\n+              fn main() { println!(\\\"zebra\\\"); }\\n\");\n         let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n@@ -1049,11 +1045,9 @@ mod test {\n \n     // check that the given reader produces the desired stream\n     // of tokens (stop checking after exhausting the expected vec)\n-    fn check_tokenization (env: Env, expected: Vec<token::Token> ) {\n+    fn check_tokenization (string_reader: StringReader, expected: Vec<token::Token> ) {\n         for expected_tok in expected.iter() {\n-            let TokenAndSpan {tok:actual_tok, sp: _} =\n-                env.string_reader.next_token();\n-            assert_eq!(&actual_tok,expected_tok);\n+            assert_eq!(&string_reader.next_token().tok, expected_tok);\n         }\n     }\n \n@@ -1063,71 +1057,55 @@ mod test {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        let env = setup (~\"a b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a b\"),\n                            vec!(mk_ident(\"a\",false),\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_2 () {\n-        let env = setup (~\"a::b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a::b\"),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_3 () {\n-        let env = setup (~\"a ::b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a ::b\"),\n                            vec!(mk_ident(\"a\",false),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn dcparsing_4 () {\n-        let env = setup (~\"a:: b\");\n-        check_tokenization (env,\n+        check_tokenization(setup(&mk_sh(), ~\"a:: b\"),\n                            vec!(mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)));\n     }\n \n     #[test] fn character_a() {\n-        let env = setup(~\"'a'\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok,token::LIT_CHAR('a' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"'a'\").next_token().tok,\n+                   token::LIT_CHAR('a' as u32));\n     }\n \n     #[test] fn character_space() {\n-        let env = setup(~\"' '\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok, token::LIT_CHAR(' ' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"' '\").next_token().tok,\n+                   token::LIT_CHAR(' ' as u32));\n     }\n \n     #[test] fn character_escaped() {\n-        let env = setup(~\"'\\\\n'\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok, token::LIT_CHAR('\\n' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"'\\\\n'\").next_token().tok,\n+                   token::LIT_CHAR('\\n' as u32));\n     }\n \n     #[test] fn lifetime_name() {\n-        let env = setup(~\"'abc\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        let id = token::str_to_ident(\"abc\");\n-        assert_eq!(tok, token::LIFETIME(id));\n+        assert_eq!(setup(&mk_sh(), ~\"'abc\").next_token().tok,\n+                   token::LIFETIME(token::str_to_ident(\"abc\")));\n     }\n \n     #[test] fn raw_string() {\n-        let env = setup(~\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        let id = token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\");\n-        assert_eq!(tok, token::LIT_STR_RAW(id, 3));\n+        assert_eq!(setup(&mk_sh(), ~\"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\").next_token().tok,\n+                   token::LIT_STR_RAW(token::str_to_ident(\"\\\"#a\\\\b\\x00c\\\"\"), 3));\n     }\n \n     #[test] fn line_doc_comments() {\n@@ -1137,10 +1115,8 @@ mod test {\n     }\n \n     #[test] fn nested_block_comments() {\n-        let env = setup(~\"/* /* */ */'a'\");\n-        let TokenAndSpan {tok, sp: _} =\n-            env.string_reader.next_token();\n-        assert_eq!(tok,token::LIT_CHAR('a' as u32));\n+        assert_eq!(setup(&mk_sh(), ~\"/* /* */ */'a'\").next_token().tok,\n+                   token::LIT_CHAR('a' as u32));\n     }\n \n }"}, {"sha": "062bc1008637a366d0ae946252830dec5eee981f", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8"}, {"sha": "1d7bf2ef6da9db85da48e80e5398b9553267dd4c", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8"}, {"sha": "27c86956499ce860498adaaba35d8529a65fc6db", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8"}, {"sha": "a35bdc307c0801d9597b98b4799f478ba2348c79", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1966, "deletions": 2110, "changes": 4076, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8"}, {"sha": "658e97097504add40a622e80b428804d0b393c50", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4c91e6c7cfc03246a422576ab41ac74125fd3b8/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=e4c91e6c7cfc03246a422576ab41ac74125fd3b8"}]}