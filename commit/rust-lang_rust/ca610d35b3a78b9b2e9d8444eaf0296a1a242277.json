{"sha": "ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNjEwZDM1YjNhNzhiOWIyZTlkODQ0NGVhZjAyOTZhMWEyNDIyNzc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-04-20T09:08:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-04-20T09:52:02Z"}, "message": "Refactor to make a sensible public API\n\n0.5 - lots of breaking changes\n\ncc #2639", "tree": {"sha": "c43e8849c22fb2274a9d4cab264683c19505516b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c43e8849c22fb2274a9d4cab264683c19505516b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "html_url": "https://github.com/rust-lang/rust/commit/ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a31741eaa638953f10352f27beba081d58e1a6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a31741eaa638953f10352f27beba081d58e1a6f", "html_url": "https://github.com/rust-lang/rust/commit/6a31741eaa638953f10352f27beba081d58e1a6f"}], "stats": {"total": 607, "additions": 313, "deletions": 294}, "files": [{"sha": "4ce2fae6a3f8aff4f87fd5bdba1b2ee80ee1f4b3", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -451,7 +451,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.4.2\"\n+version = \"0.5.0\"\n dependencies = [\n  \"assert_cli 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "bacde50ce777a0a5cbc8548ee4dbbb9455f3446e", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -1,7 +1,7 @@\n [package]\n \n name = \"rustfmt-nightly\"\n-version = \"0.4.2\"\n+version = \"0.5.0\"\n authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang-nursery/rustfmt\"\n@@ -49,8 +49,8 @@ cargo_metadata = \"0.5.1\"\n rustc-ap-syntax = \"103.0.0\"\n \n [dev-dependencies]\n-lazy_static = \"1.0.0\"\n assert_cli = \"0.5\"\n+lazy_static = \"1.0.0\"\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2.11\""}, {"sha": "453c7806d234548a7ae320a847442ef160962a5a", "filename": "src/bin/main.rs", "status": "modified", "additions": 37, "deletions": 181, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -14,23 +14,16 @@ extern crate env_logger;\n extern crate getopts;\n extern crate rustfmt_nightly as rustfmt;\n \n+use std::env;\n use std::fs::File;\n use std::io::{self, stdout, Read, Write};\n-use std::path::{Path, PathBuf};\n-use std::str::FromStr;\n-use std::{env, error};\n+use std::path::PathBuf;\n \n use getopts::{Matches, Options};\n \n-use rustfmt::checkstyle;\n-use rustfmt::config::file_lines::FileLines;\n-use rustfmt::config::{get_toml_path, Color, Config, WriteMode};\n-use rustfmt::{run, FileName, Input, Summary};\n-\n-type FmtError = Box<error::Error + Send + Sync>;\n-type FmtResult<T> = std::result::Result<T, FmtError>;\n-\n-const WRITE_MODE_LIST: &str = \"[replace|overwrite|display|plain|diff|coverage|checkstyle|check]\";\n+use rustfmt::{emit_post_matter, emit_pre_matter, load_config, CliOptions, Config, FmtResult,\n+              WriteMode, WRITE_MODE_LIST};\n+use rustfmt::{format_and_emit_report, FileName, Input, Summary};\n \n fn main() {\n     env_logger::init();\n@@ -66,7 +59,6 @@ enum Operation {\n     /// Format files and their child modules.\n     Format {\n         files: Vec<PathBuf>,\n-        config_path: Option<PathBuf>,\n         minimal_config_path: Option<String>,\n     },\n     /// Print the help message.\n@@ -82,105 +74,9 @@ enum Operation {\n     /// No file specified, read from stdin\n     Stdin {\n         input: String,\n-        config_path: Option<PathBuf>,\n     },\n }\n \n-/// Parsed command line options.\n-#[derive(Clone, Debug, Default)]\n-struct CliOptions {\n-    skip_children: Option<bool>,\n-    verbose: bool,\n-    verbose_diff: bool,\n-    write_mode: Option<WriteMode>,\n-    color: Option<Color>,\n-    file_lines: FileLines, // Default is all lines in all files.\n-    unstable_features: bool,\n-    error_on_unformatted: Option<bool>,\n-}\n-\n-impl CliOptions {\n-    fn from_matches(matches: &Matches) -> FmtResult<CliOptions> {\n-        let mut options = CliOptions::default();\n-        options.verbose = matches.opt_present(\"verbose\");\n-        options.verbose_diff = matches.opt_present(\"verbose-diff\");\n-\n-        let unstable_features = matches.opt_present(\"unstable-features\");\n-        let rust_nightly = option_env!(\"CFG_RELEASE_CHANNEL\")\n-            .map(|c| c == \"nightly\")\n-            .unwrap_or(false);\n-        if unstable_features && !rust_nightly {\n-            return Err(FmtError::from(\n-                \"Unstable features are only available on Nightly channel\",\n-            ));\n-        } else {\n-            options.unstable_features = unstable_features;\n-        }\n-\n-        if let Some(ref write_mode) = matches.opt_str(\"write-mode\") {\n-            if let Ok(write_mode) = WriteMode::from_str(write_mode) {\n-                options.write_mode = Some(write_mode);\n-            } else {\n-                return Err(FmtError::from(format!(\n-                    \"Invalid write-mode: {}, expected one of {}\",\n-                    write_mode, WRITE_MODE_LIST\n-                )));\n-            }\n-        }\n-\n-        if let Some(ref color) = matches.opt_str(\"color\") {\n-            match Color::from_str(color) {\n-                Ok(color) => options.color = Some(color),\n-                _ => return Err(FmtError::from(format!(\"Invalid color: {}\", color))),\n-            }\n-        }\n-\n-        if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n-            options.file_lines = file_lines.parse()?;\n-        }\n-\n-        if matches.opt_present(\"skip-children\") {\n-            options.skip_children = Some(true);\n-        }\n-        if matches.opt_present(\"error-on-unformatted\") {\n-            options.error_on_unformatted = Some(true);\n-        }\n-\n-        Ok(options)\n-    }\n-\n-    fn apply_to(self, config: &mut Config) {\n-        config.set().verbose(self.verbose);\n-        config.set().verbose_diff(self.verbose_diff);\n-        config.set().file_lines(self.file_lines);\n-        config.set().unstable_features(self.unstable_features);\n-        if let Some(skip_children) = self.skip_children {\n-            config.set().skip_children(skip_children);\n-        }\n-        if let Some(error_on_unformatted) = self.error_on_unformatted {\n-            config.set().error_on_unformatted(error_on_unformatted);\n-        }\n-        if let Some(write_mode) = self.write_mode {\n-            config.set().write_mode(write_mode);\n-        }\n-        if let Some(color) = self.color {\n-            config.set().color(color);\n-        }\n-    }\n-}\n-\n-/// read the given config file path recursively if present else read the project file path\n-fn match_cli_path_or_file(\n-    config_path: Option<PathBuf>,\n-    input_file: &Path,\n-) -> FmtResult<(Config, Option<PathBuf>)> {\n-    if let Some(config_file) = config_path {\n-        let toml = Config::from_toml_path(config_file.as_ref())?;\n-        return Ok((toml, Some(config_file)));\n-    }\n-    Config::from_resolved_toml_path(input_file).map_err(FmtError::from)\n-}\n-\n fn make_opts() -> Options {\n     let mut opts = Options::new();\n \n@@ -280,10 +176,10 @@ fn execute(opts: &Options) -> FmtResult<(WriteMode, Summary)> {\n             }\n             Ok((WriteMode::None, Summary::default()))\n         }\n-        Operation::Stdin { input, config_path } => {\n+        Operation::Stdin { input } => {\n             // try to read config from local directory\n-            let (mut config, _) =\n-                match_cli_path_or_file(config_path, &env::current_dir().unwrap())?;\n+            let options = CliOptions::from_matches(&matches)?;\n+            let (mut config, _) = load_config(None, Some(&options))?;\n \n             // write_mode is always Plain for Stdin.\n             config.set().write_mode(WriteMode::Plain);\n@@ -300,57 +196,40 @@ fn execute(opts: &Options) -> FmtResult<(WriteMode, Summary)> {\n             }\n \n             let mut error_summary = Summary::default();\n-            if config.version_meets_requirement(&mut error_summary) {\n-                let mut out = &mut stdout();\n-                checkstyle::output_header(&mut out, config.write_mode())?;\n-                error_summary.add(run(Input::Text(input), &config));\n-                checkstyle::output_footer(&mut out, config.write_mode())?;\n+            emit_pre_matter(&config)?;\n+            match format_and_emit_report(Input::Text(input), &config) {\n+                Ok(summary) => error_summary.add(summary),\n+                Err(_) => error_summary.add_operational_error(),\n             }\n+            emit_post_matter(&config)?;\n \n             Ok((WriteMode::Plain, error_summary))\n         }\n         Operation::Format {\n             files,\n-            config_path,\n             minimal_config_path,\n         } => {\n             let options = CliOptions::from_matches(&matches)?;\n-            format(files, config_path, minimal_config_path, options)\n+            format(files, minimal_config_path, options)\n         }\n     }\n }\n \n fn format(\n     files: Vec<PathBuf>,\n-    config_path: Option<PathBuf>,\n     minimal_config_path: Option<String>,\n     options: CliOptions,\n ) -> FmtResult<(WriteMode, Summary)> {\n-    for f in options.file_lines.files() {\n-        match *f {\n-            FileName::Real(ref f) if files.contains(f) => {}\n-            FileName::Real(_) => {\n-                eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n-            }\n-            _ => eprintln!(\"Warning: Not a file '{}'\", f),\n-        }\n-    }\n-\n-    let mut config = Config::default();\n-    // Load the config path file if provided\n-    if let Some(config_file) = config_path.as_ref() {\n-        config = Config::from_toml_path(config_file.as_ref())?;\n-    };\n+    options.verify_file_lines(&files);\n+    let (config, config_path) = load_config(None, Some(&options))?;\n \n-    if options.verbose {\n+    if config.verbose() {\n         if let Some(path) = config_path.as_ref() {\n             println!(\"Using rustfmt config file {}\", path.display());\n         }\n     }\n \n-    let write_mode = config.write_mode();\n-    let mut out = &mut stdout();\n-    checkstyle::output_header(&mut out, write_mode)?;\n+    emit_pre_matter(&config)?;\n     let mut error_summary = Summary::default();\n \n     for file in files {\n@@ -362,30 +241,33 @@ fn format(\n             error_summary.add_operational_error();\n         } else {\n             // Check the file directory if the config-path could not be read or not provided\n-            if config_path.is_none() {\n-                let (config_tmp, path_tmp) =\n-                    Config::from_resolved_toml_path(file.parent().unwrap())?;\n-                if options.verbose {\n-                    if let Some(path) = path_tmp.as_ref() {\n+            let local_config = if config_path.is_none() {\n+                let (local_config, config_path) =\n+                    load_config(Some(file.parent().unwrap()), Some(&options))?;\n+                if local_config.verbose() {\n+                    if let Some(path) = config_path {\n                         println!(\n                             \"Using rustfmt config file {} for {}\",\n                             path.display(),\n                             file.display()\n                         );\n                     }\n                 }\n-                config = config_tmp;\n-            }\n-\n-            if !config.version_meets_requirement(&mut error_summary) {\n-                break;\n+                local_config\n+            } else {\n+                config.clone()\n+            };\n+\n+            match format_and_emit_report(Input::File(file), &local_config) {\n+                Ok(summary) => error_summary.add(summary),\n+                Err(_) => {\n+                    error_summary.add_operational_error();\n+                    break;\n+                }\n             }\n-\n-            options.clone().apply_to(&mut config);\n-            error_summary.add(run(Input::File(file), &config));\n         }\n     }\n-    checkstyle::output_footer(&mut out, write_mode)?;\n+    emit_post_matter(&config)?;\n \n     // If we were given a path via dump-minimal-config, output any options\n     // that were used during formatting as TOML.\n@@ -395,7 +277,7 @@ fn format(\n         file.write_all(toml.as_bytes())?;\n     }\n \n-    Ok((write_mode, error_summary))\n+    Ok((config.write_mode(), error_summary))\n }\n \n fn print_usage_to_stdout(opts: &Options, reason: &str) {\n@@ -451,28 +333,6 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n         return Ok(Operation::Version);\n     }\n \n-    let config_path_not_found = |path: &str| -> FmtResult<Operation> {\n-        Err(FmtError::from(format!(\n-            \"Error: unable to find a config file for the given path: `{}`\",\n-            path\n-        )))\n-    };\n-\n-    // Read the config_path and convert to parent dir if a file is provided.\n-    // If a config file cannot be found from the given path, return error.\n-    let config_path: Option<PathBuf> = match matches.opt_str(\"config-path\").map(PathBuf::from) {\n-        Some(ref path) if !path.exists() => return config_path_not_found(path.to_str().unwrap()),\n-        Some(ref path) if path.is_dir() => {\n-            let config_file_path = get_toml_path(path)?;\n-            if config_file_path.is_some() {\n-                config_file_path\n-            } else {\n-                return config_path_not_found(path.to_str().unwrap());\n-            }\n-        }\n-        path => path,\n-    };\n-\n     // If no path is given, we won't output a minimal config.\n     let minimal_config_path = matches.opt_str(\"dump-minimal-config\");\n \n@@ -481,10 +341,7 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n         let mut buffer = String::new();\n         io::stdin().read_to_string(&mut buffer)?;\n \n-        return Ok(Operation::Stdin {\n-            input: buffer,\n-            config_path,\n-        });\n+        return Ok(Operation::Stdin { input: buffer });\n     }\n \n     let files: Vec<_> = matches\n@@ -500,7 +357,6 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n \n     Ok(Operation::Format {\n         files,\n-        config_path,\n         minimal_config_path,\n     })\n }"}, {"sha": "19d737cd4c2497ce89fbd878f7fb23c0d1885cec", "filename": "src/checkstyle.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fcheckstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fcheckstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcheckstyle.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -11,33 +11,26 @@\n use std::io::{self, Write};\n use std::path::Path;\n \n-use config::WriteMode;\n use rustfmt_diff::{DiffLine, Mismatch};\n \n-pub fn output_header<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n+pub fn output_header<T>(out: &mut T) -> Result<(), io::Error>\n where\n     T: Write,\n {\n-    if mode == WriteMode::Checkstyle {\n-        let mut xml_heading = String::new();\n-        xml_heading.push_str(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n-        xml_heading.push_str(\"\\n\");\n-        xml_heading.push_str(\"<checkstyle version=\\\"4.3\\\">\");\n-        write!(out, \"{}\", xml_heading)?;\n-    }\n-    Ok(())\n+    let mut xml_heading = String::new();\n+    xml_heading.push_str(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n+    xml_heading.push_str(\"\\n\");\n+    xml_heading.push_str(\"<checkstyle version=\\\"4.3\\\">\");\n+    write!(out, \"{}\", xml_heading)\n }\n \n-pub fn output_footer<T>(out: &mut T, mode: WriteMode) -> Result<(), io::Error>\n+pub fn output_footer<T>(out: &mut T) -> Result<(), io::Error>\n where\n     T: Write,\n {\n-    if mode == WriteMode::Checkstyle {\n-        let mut xml_tail = String::new();\n-        xml_tail.push_str(\"</checkstyle>\\n\");\n-        write!(out, \"{}\", xml_tail)?;\n-    }\n-    Ok(())\n+    let mut xml_tail = String::new();\n+    xml_tail.push_str(\"</checkstyle>\\n\");\n+    write!(out, \"{}\", xml_tail)\n }\n \n pub fn output_checkstyle_file<T>("}, {"sha": "3b9ca90350cfc779286d2605b85e0db841e4c488", "filename": "src/config/config_type.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -80,6 +80,7 @@ macro_rules! is_nightly_channel {\n \n macro_rules! create_config {\n     ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n+        #[cfg(test)]\n         use std::collections::HashSet;\n         use std::io::Write;\n \n@@ -150,7 +151,7 @@ macro_rules! create_config {\n         }\n \n         impl Config {\n-            pub fn version_meets_requirement(&self, error_summary: &mut Summary) -> bool {\n+            pub(crate) fn version_meets_requirement(&self) -> bool {\n                 if self.was_set().required_version() {\n                     let version = env!(\"CARGO_PKG_VERSION\");\n                     let required_version = self.required_version();\n@@ -160,7 +161,6 @@ macro_rules! create_config {\n                             version,\n                             required_version,\n                         );\n-                        error_summary.add_formatting_error();\n                         return false;\n                     }\n                 }\n@@ -207,15 +207,16 @@ macro_rules! create_config {\n             }\n \n             /// Returns a hash set initialized with every user-facing config option name.\n-            pub fn hash_set() -> HashSet<String> {\n+            #[cfg(test)]\n+            pub(crate) fn hash_set() -> HashSet<String> {\n                 let mut hash_set = HashSet::new();\n                 $(\n                     hash_set.insert(stringify!($i).to_owned());\n                 )+\n                 hash_set\n             }\n \n-            pub fn is_valid_name(name: &str) -> bool {\n+            pub(crate) fn is_valid_name(name: &str) -> bool {\n                 match name {\n                     $(\n                         stringify!($i) => true,\n@@ -224,7 +225,7 @@ macro_rules! create_config {\n                 }\n             }\n \n-            pub fn from_toml(toml: &str, dir: &Path) -> Result<Config, String> {\n+            pub(crate) fn from_toml(toml: &str, dir: &Path) -> Result<Config, String> {\n                 let parsed: ::toml::Value =\n                     toml.parse().map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n                 let mut err: String = String::new();\n@@ -304,7 +305,7 @@ macro_rules! create_config {\n             ///\n             /// Return a `Config` if the config could be read and parsed from\n             /// the file, Error otherwise.\n-            pub fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n+            pub(super) fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n                 let mut file = File::open(&file_path)?;\n                 let mut toml = String::new();\n                 file.read_to_string(&mut toml)?;\n@@ -321,7 +322,7 @@ macro_rules! create_config {\n             ///\n             /// Returns the `Config` to use, and the path of the project file if there was\n             /// one.\n-            pub fn from_resolved_toml_path(dir: &Path) -> Result<(Config, Option<PathBuf>), Error> {\n+            pub(super) fn from_resolved_toml_path(dir: &Path) -> Result<(Config, Option<PathBuf>), Error> {\n \n                 /// Try to find a project file in the given directory and its parents.\n                 /// Returns the path of a the nearest project file if one exists,"}, {"sha": "5e29e0ff965c4ba286cabb172cee147f2d950aab", "filename": "src/config/file_lines.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Ffile_lines.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -54,6 +54,7 @@ impl Range {\n         self.lo > self.hi\n     }\n \n+    #[allow(dead_code)]\n     fn contains(self, other: Range) -> bool {\n         if other.is_empty() {\n             true\n@@ -128,12 +129,12 @@ fn normalize_ranges(ranges: &mut HashMap<FileName, Vec<Range>>) {\n \n impl FileLines {\n     /// Creates a `FileLines` that contains all lines in all files.\n-    pub fn all() -> FileLines {\n+    pub(crate) fn all() -> FileLines {\n         FileLines(None)\n     }\n \n     /// Returns true if this `FileLines` contains all lines in all files.\n-    pub fn is_all(&self) -> bool {\n+    pub(crate) fn is_all(&self) -> bool {\n         self.0.is_none()\n     }\n \n@@ -166,22 +167,23 @@ impl FileLines {\n     }\n \n     /// Returns true if `range` is fully contained in `self`.\n-    pub fn contains(&self, range: &LineRange) -> bool {\n+    #[allow(dead_code)]\n+    pub(crate) fn contains(&self, range: &LineRange) -> bool {\n         self.file_range_matches(range.file_name(), |r| r.contains(Range::from(range)))\n     }\n \n     /// Returns true if any lines in `range` are in `self`.\n-    pub fn intersects(&self, range: &LineRange) -> bool {\n+    pub(crate) fn intersects(&self, range: &LineRange) -> bool {\n         self.file_range_matches(range.file_name(), |r| r.intersects(Range::from(range)))\n     }\n \n     /// Returns true if `line` from `file_name` is in `self`.\n-    pub fn contains_line(&self, file_name: &FileName, line: usize) -> bool {\n+    pub(crate) fn contains_line(&self, file_name: &FileName, line: usize) -> bool {\n         self.file_range_matches(file_name, |r| r.lo <= line && r.hi >= line)\n     }\n \n     /// Returns true if any of the lines between `lo` and `hi` from `file_name` are in `self`.\n-    pub fn intersects_range(&self, file_name: &FileName, lo: usize, hi: usize) -> bool {\n+    pub(crate) fn intersects_range(&self, file_name: &FileName, lo: usize, hi: usize) -> bool {\n         self.file_range_matches(file_name, |r| r.intersects(Range::new(lo, hi)))\n     }\n }"}, {"sha": "630399319c1b5ab97e8e5149f3964f5a03eb9e77", "filename": "src/config/license.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flicense.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -82,8 +82,7 @@ impl TemplateParser {\n     ///\n     /// # Examples\n     ///\n-    /// ```\n-    /// # use rustfmt_nightly::config::license::TemplateParser;\n+    /// ```ignore\n     /// assert_eq!(\n     ///     TemplateParser::parse(\n     ///         r\""}, {"sha": "8dde1e05c3dd36ffbdd607f962fc5eacc9907a5c", "filename": "src/config/mod.rs", "status": "modified", "additions": 64, "deletions": 13, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -8,31 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use regex::Regex;\n use std::cell::Cell;\n use std::default::Default;\n use std::fs::File;\n use std::io::{Error, ErrorKind, Read};\n use std::path::{Path, PathBuf};\n use std::{env, fs};\n \n-use regex::Regex;\n+use {FmtError, FmtResult};\n+\n+use config::config_type::ConfigType;\n+use config::file_lines::FileLines;\n+pub use config::lists::*;\n+pub use config::options::*;\n \n #[macro_use]\n-mod config_type;\n+pub mod config_type;\n #[macro_use]\n-mod options;\n+pub mod options;\n \n pub mod file_lines;\n pub mod license;\n pub mod lists;\n pub mod summary;\n \n-use config::config_type::ConfigType;\n-use config::file_lines::FileLines;\n-pub use config::lists::*;\n-pub use config::options::*;\n-use config::summary::Summary;\n-\n /// This macro defines configuration options used in rustfmt. Each option\n /// is defined as follows:\n ///\n@@ -151,10 +151,37 @@ create_config! {\n         \"'small' heuristic values\";\n }\n \n-/// Check for the presence of known config file names (`rustfmt.toml, `.rustfmt.toml`) in `dir`\n-///\n-/// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n-pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+pub fn load_config(\n+    file_path: Option<&Path>,\n+    options: Option<&CliOptions>,\n+) -> FmtResult<(Config, Option<PathBuf>)> {\n+    let over_ride = match options {\n+        Some(opts) => config_path(opts)?,\n+        None => None,\n+    };\n+\n+    let result = if let Some(over_ride) = over_ride {\n+        Config::from_toml_path(over_ride.as_ref())\n+            .map(|p| (p, Some(over_ride.to_owned())))\n+            .map_err(FmtError::from)\n+    } else if let Some(file_path) = file_path {\n+        Config::from_resolved_toml_path(file_path).map_err(FmtError::from)\n+    } else {\n+        Ok((Config::default(), None))\n+    };\n+\n+    result.map(|(mut c, p)| {\n+        if let Some(options) = options {\n+            options.clone().apply_to(&mut c);\n+        }\n+        (c, p)\n+    })\n+}\n+\n+// Check for the presence of known config file names (`rustfmt.toml, `.rustfmt.toml`) in `dir`\n+//\n+// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n+fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n     const CONFIG_FILE_NAMES: [&str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n     for config_file_name in &CONFIG_FILE_NAMES {\n         let config_file = dir.join(config_file_name);\n@@ -175,6 +202,30 @@ pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n     Ok(None)\n }\n \n+fn config_path(options: &CliOptions) -> FmtResult<Option<PathBuf>> {\n+    let config_path_not_found = |path: &str| -> FmtResult<Option<PathBuf>> {\n+        Err(FmtError::from(format!(\n+            \"Error: unable to find a config file for the given path: `{}`\",\n+            path\n+        )))\n+    };\n+\n+    // Read the config_path and convert to parent dir if a file is provided.\n+    // If a config file cannot be found from the given path, return error.\n+    match options.config_path {\n+        Some(ref path) if !path.exists() => config_path_not_found(path.to_str().unwrap()),\n+        Some(ref path) if path.is_dir() => {\n+            let config_file_path = get_toml_path(path)?;\n+            if config_file_path.is_some() {\n+                Ok(config_file_path)\n+            } else {\n+                config_path_not_found(path.to_str().unwrap())\n+            }\n+        }\n+        ref path => Ok(path.to_owned()),\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::Config;"}, {"sha": "73dbdb88663c3c6452ba1b685dca2ff33a0c58b4", "filename": "src/config/options.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -11,10 +11,15 @@\n use syntax::codemap::FileName;\n \n use config::config_type::ConfigType;\n+use config::file_lines::FileLines;\n use config::lists::*;\n+use config::Config;\n+use {FmtError, FmtResult, WRITE_MODE_LIST};\n \n+use getopts::Matches;\n use std::collections::HashSet;\n use std::path::{Path, PathBuf};\n+use std::str::FromStr;\n \n /// Macro for deriving implementations of Serialize/Deserialize for enums\n #[macro_export]\n@@ -301,3 +306,101 @@ impl ::std::str::FromStr for IgnoreList {\n         Err(\"IgnoreList is not parsable\")\n     }\n }\n+\n+/// Parsed command line options.\n+#[derive(Clone, Debug, Default)]\n+pub struct CliOptions {\n+    skip_children: Option<bool>,\n+    verbose: bool,\n+    verbose_diff: bool,\n+    pub(super) config_path: Option<PathBuf>,\n+    write_mode: Option<WriteMode>,\n+    color: Option<Color>,\n+    file_lines: FileLines, // Default is all lines in all files.\n+    unstable_features: bool,\n+    error_on_unformatted: Option<bool>,\n+}\n+\n+impl CliOptions {\n+    pub fn from_matches(matches: &Matches) -> FmtResult<CliOptions> {\n+        let mut options = CliOptions::default();\n+        options.verbose = matches.opt_present(\"verbose\");\n+        options.verbose_diff = matches.opt_present(\"verbose-diff\");\n+\n+        let unstable_features = matches.opt_present(\"unstable-features\");\n+        let rust_nightly = option_env!(\"CFG_RELEASE_CHANNEL\")\n+            .map(|c| c == \"nightly\")\n+            .unwrap_or(false);\n+        if unstable_features && !rust_nightly {\n+            return Err(FmtError::from(\n+                \"Unstable features are only available on Nightly channel\",\n+            ));\n+        } else {\n+            options.unstable_features = unstable_features;\n+        }\n+\n+        options.config_path = matches.opt_str(\"config-path\").map(PathBuf::from);\n+\n+        if let Some(ref write_mode) = matches.opt_str(\"write-mode\") {\n+            if let Ok(write_mode) = WriteMode::from_str(write_mode) {\n+                options.write_mode = Some(write_mode);\n+            } else {\n+                return Err(FmtError::from(format!(\n+                    \"Invalid write-mode: {}, expected one of {}\",\n+                    write_mode, WRITE_MODE_LIST\n+                )));\n+            }\n+        }\n+\n+        if let Some(ref color) = matches.opt_str(\"color\") {\n+            match Color::from_str(color) {\n+                Ok(color) => options.color = Some(color),\n+                _ => return Err(FmtError::from(format!(\"Invalid color: {}\", color))),\n+            }\n+        }\n+\n+        if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n+            options.file_lines = file_lines.parse()?;\n+        }\n+\n+        if matches.opt_present(\"skip-children\") {\n+            options.skip_children = Some(true);\n+        }\n+        if matches.opt_present(\"error-on-unformatted\") {\n+            options.error_on_unformatted = Some(true);\n+        }\n+\n+        Ok(options)\n+    }\n+\n+    pub fn apply_to(self, config: &mut Config) {\n+        config.set().verbose(self.verbose);\n+        config.set().verbose_diff(self.verbose_diff);\n+        config.set().file_lines(self.file_lines);\n+        config.set().unstable_features(self.unstable_features);\n+        if let Some(skip_children) = self.skip_children {\n+            config.set().skip_children(skip_children);\n+        }\n+        if let Some(error_on_unformatted) = self.error_on_unformatted {\n+            config.set().error_on_unformatted(error_on_unformatted);\n+        }\n+        if let Some(write_mode) = self.write_mode {\n+            config.set().write_mode(write_mode);\n+        }\n+        if let Some(color) = self.color {\n+            config.set().color(color);\n+        }\n+    }\n+\n+    pub fn verify_file_lines(&self, files: &[PathBuf]) {\n+        for f in self.file_lines.files() {\n+            match *f {\n+                FileName::Real(ref f) if files.contains(f) => {}\n+                FileName::Real(_) => {\n+                    eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n+                }\n+                _ => eprintln!(\"Warning: Not a file '{}'\", f),\n+            }\n+        }\n+    }\n+}"}, {"sha": "c906c77506f28653cbbbe1916b15b9ad41f4c4a9", "filename": "src/config/summary.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fconfig%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fsummary.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -31,16 +31,16 @@ pub struct Summary {\n }\n \n impl Summary {\n-    pub fn mark_parse_time(&mut self) {\n+    pub(crate) fn mark_parse_time(&mut self) {\n         self.timer = self.timer.done_parsing();\n     }\n \n-    pub fn mark_format_time(&mut self) {\n+    pub(crate) fn mark_format_time(&mut self) {\n         self.timer = self.timer.done_formatting();\n     }\n \n     /// Returns the time it took to parse the source files in nanoseconds.\n-    pub fn get_parse_time(&self) -> Option<Duration> {\n+    pub(crate) fn get_parse_time(&self) -> Option<Duration> {\n         match self.timer {\n             Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n                 // This should never underflow since `Instant::now()` guarantees monotonicity.\n@@ -52,7 +52,7 @@ impl Summary {\n \n     /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n     /// not included.\n-    pub fn get_format_time(&self) -> Option<Duration> {\n+    pub(crate) fn get_format_time(&self) -> Option<Duration> {\n         match self.timer {\n             Timer::DoneFormatting(_init, parse_time, format_time) => {\n                 Some(format_time.duration_since(parse_time))\n@@ -77,15 +77,15 @@ impl Summary {\n         self.has_operational_errors = true;\n     }\n \n-    pub fn add_parsing_error(&mut self) {\n+    pub(crate) fn add_parsing_error(&mut self) {\n         self.has_parsing_errors = true;\n     }\n \n-    pub fn add_formatting_error(&mut self) {\n+    pub(crate) fn add_formatting_error(&mut self) {\n         self.has_formatting_errors = true;\n     }\n \n-    pub fn add_diff(&mut self) {\n+    pub(crate) fn add_diff(&mut self) {\n         self.has_diff = true;\n     }\n "}, {"sha": "f749189351299f65a87560d12170ee75a1070cf0", "filename": "src/filemap.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -14,31 +14,37 @@ use std::fs::{self, File};\n use std::io::{self, BufWriter, Read, Write};\n use std::path::Path;\n \n-use checkstyle::{output_checkstyle_file, output_footer, output_header};\n+use checkstyle::output_checkstyle_file;\n use config::{Config, NewlineStyle, WriteMode};\n use rustfmt_diff::{make_diff, output_modified, print_diff, Mismatch};\n use syntax::codemap::FileName;\n \n+#[cfg(test)]\n use FileRecord;\n \n // Append a newline to the end of each file.\n pub fn append_newline(s: &mut String) {\n     s.push_str(\"\\n\");\n }\n \n-pub fn write_all_files<T>(\n+#[cfg(test)]\n+pub(crate) fn write_all_files<T>(\n     file_map: &[FileRecord],\n     out: &mut T,\n     config: &Config,\n ) -> Result<(), io::Error>\n where\n     T: Write,\n {\n-    output_header(out, config.write_mode()).ok();\n+    if config.write_mode() == WriteMode::Checkstyle {\n+        ::checkstyle::output_header(out)?;\n+    }\n     for &(ref filename, ref text) in file_map {\n         write_file(text, filename, out, config)?;\n     }\n-    output_footer(out, config.write_mode()).ok();\n+    if config.write_mode() == WriteMode::Checkstyle {\n+        ::checkstyle::output_footer(out)?;\n+    }\n \n     Ok(())\n }"}, {"sha": "390eeb4149a8a704712179e2f63d884a995982fd", "filename": "src/git-rustfmt/main.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fgit-rustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fgit-rustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgit-rustfmt%2Fmain.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -21,7 +21,7 @@ use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n-use rustfmt::{config, run, Input};\n+use rustfmt::{format_and_emit_report, load_config, Input};\n \n fn prune_files(files: Vec<&str>) -> Vec<&str> {\n     let prefixes: Vec<_> = files\n@@ -68,12 +68,11 @@ fn get_files(input: &str) -> Vec<&str> {\n }\n \n fn fmt_files(files: &[&str]) -> i32 {\n-    let (config, _) = config::Config::from_resolved_toml_path(Path::new(\".\"))\n-        .unwrap_or_else(|_| (config::Config::default(), None));\n+    let (config, _) = load_config(Some(Path::new(\".\")), None).expect(\"couldn't load config\");\n \n     let mut exit_code = 0;\n     for file in files {\n-        let summary = run(Input::File(PathBuf::from(file)), &config);\n+        let summary = format_and_emit_report(Input::File(PathBuf::from(file)), &config).unwrap();\n         if !summary.has_no_errors() {\n             exit_code = 1;\n         }"}, {"sha": "506defad30e0e87b6198285324837ad41894f738", "filename": "src/lib.rs", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -19,7 +19,11 @@\n #[macro_use]\n extern crate derive_new;\n extern crate diff;\n+extern crate getopts;\n extern crate itertools;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate lazy_static;\n #[macro_use]\n extern crate log;\n extern crate regex;\n@@ -33,6 +37,7 @@ extern crate toml;\n extern crate unicode_segmentation;\n \n use std::collections::HashMap;\n+use std::error;\n use std::fmt;\n use std::io::{self, stdout, BufRead, Write};\n use std::panic::{catch_unwind, AssertUnwindSafe};\n@@ -53,47 +58,56 @@ use shape::Indent;\n use utils::use_colored_tty;\n use visitor::{FmtVisitor, SnippetProvider};\n \n+pub use config::options::CliOptions;\n pub use config::summary::Summary;\n-pub use config::Config;\n+pub use config::{file_lines, load_config, Config, WriteMode};\n+\n+pub type FmtError = Box<error::Error + Send + Sync>;\n+pub type FmtResult<T> = std::result::Result<T, FmtError>;\n+\n+pub const WRITE_MODE_LIST: &str =\n+    \"[replace|overwrite|display|plain|diff|coverage|checkstyle|check]\";\n \n #[macro_use]\n mod utils;\n \n mod attr;\n mod chains;\n-pub mod checkstyle;\n+pub(crate) mod checkstyle;\n mod closures;\n-pub mod codemap;\n+pub(crate) mod codemap;\n mod comment;\n-pub mod config;\n+pub(crate) mod config;\n mod expr;\n-pub mod filemap;\n+pub(crate) mod filemap;\n mod imports;\n mod issues;\n mod items;\n mod lists;\n mod macros;\n mod matches;\n mod missed_spans;\n-pub mod modules;\n+pub(crate) mod modules;\n mod overflow;\n mod patterns;\n mod reorder;\n mod rewrite;\n-pub mod rustfmt_diff;\n+pub(crate) mod rustfmt_diff;\n mod shape;\n mod spanned;\n mod string;\n+#[cfg(test)]\n+mod test;\n mod types;\n mod vertical;\n-pub mod visitor;\n+pub(crate) mod visitor;\n \n const STDIN: &str = \"<stdin>\";\n \n // A map of the files of a crate, with their new content\n-pub type FileMap = Vec<FileRecord>;\n+pub(crate) type FileMap = Vec<FileRecord>;\n \n-pub type FileRecord = (FileName, String);\n+pub(crate) type FileRecord = (FileName, String);\n \n #[derive(Clone, Copy)]\n pub enum ErrorKind {\n@@ -123,7 +137,7 @@ impl fmt::Display for ErrorKind {\n }\n \n // Formatting errors that are identified *after* rustfmt has run.\n-pub struct FormattingError {\n+struct FormattingError {\n     line: usize,\n     kind: ErrorKind,\n     is_comment: bool,\n@@ -150,7 +164,7 @@ impl FormattingError {\n     }\n \n     // (space, target)\n-    pub fn format_len(&self) -> (usize, usize) {\n+    fn format_len(&self) -> (usize, usize) {\n         match self.kind {\n             ErrorKind::LineOverflow(found, max) => (max, found - max),\n             ErrorKind::TrailingWhitespace => {\n@@ -180,18 +194,18 @@ impl FormatReport {\n         }\n     }\n \n-    pub fn warning_count(&self) -> usize {\n+    fn warning_count(&self) -> usize {\n         self.file_error_map\n             .iter()\n             .map(|(_, errors)| errors.len())\n             .sum()\n     }\n \n-    pub fn has_warnings(&self) -> bool {\n+    fn has_warnings(&self) -> bool {\n         self.warning_count() > 0\n     }\n \n-    pub fn print_warnings_fancy(\n+    fn print_warnings_fancy(\n         &self,\n         mut t: Box<term::Terminal<Output = io::Stderr>>,\n     ) -> Result<(), term::Error> {\n@@ -881,7 +895,10 @@ pub enum Input {\n     Text(String),\n }\n \n-pub fn run(input: Input, config: &Config) -> Summary {\n+pub fn format_and_emit_report(input: Input, config: &Config) -> FmtResult<Summary> {\n+    if !config.version_meets_requirement() {\n+        return Err(FmtError::from(\"Version mismatch\"));\n+    }\n     let out = &mut stdout();\n     match format_input(input, config, Some(out)) {\n         Ok((summary, _, report)) => {\n@@ -896,22 +913,38 @@ pub fn run(input: Input, config: &Config) -> Summary {\n                             Err(..) => panic!(\"Unable to write to stderr: {}\", report),\n                         }\n                     }\n-                    _ => msg!(\"{}\", report),\n+                    _ => eprintln!(\"{}\", report),\n                 }\n             }\n \n-            summary\n+            Ok(summary)\n         }\n         Err((msg, mut summary)) => {\n-            msg!(\"Error writing files: {}\", msg);\n+            eprintln!(\"Error writing files: {}\", msg);\n             summary.add_operational_error();\n-            summary\n+            Ok(summary)\n         }\n     }\n }\n \n+pub fn emit_pre_matter(config: &Config) -> FmtResult<()> {\n+    if config.write_mode() == WriteMode::Checkstyle {\n+        let mut out = &mut stdout();\n+        checkstyle::output_header(&mut out)?;\n+    }\n+    Ok(())\n+}\n+\n+pub fn emit_post_matter(config: &Config) -> FmtResult<()> {\n+    if config.write_mode() == WriteMode::Checkstyle {\n+        let mut out = &mut stdout();\n+        checkstyle::output_footer(&mut out)?;\n+    }\n+    Ok(())\n+}\n+\n #[cfg(test)]\n-mod test {\n+mod unit_tests {\n     use super::{format_code_block, format_snippet, Config};\n \n     #[test]"}, {"sha": "8a17389672fc844a812f5e280cad0dbd141635a5", "filename": "src/shape.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -197,14 +197,6 @@ impl Shape {\n         }\n     }\n \n-    pub fn offset(width: usize, indent: Indent, offset: usize) -> Shape {\n-        Shape {\n-            width,\n-            indent,\n-            offset,\n-        }\n-    }\n-\n     pub fn visual_indent(&self, extra_width: usize) -> Shape {\n         let alignment = self.offset + extra_width;\n         Shape {"}, {"sha": "b0971136352a14586ed9f1415855853e846d39f8", "filename": "src/test/mod.rs", "status": "renamed", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -9,13 +9,6 @@\n // except according to those terms.\n \n extern crate assert_cli;\n-#[macro_use]\n-extern crate lazy_static;\n-#[macro_use]\n-extern crate log;\n-extern crate regex;\n-extern crate rustfmt_nightly as rustfmt;\n-extern crate term;\n \n use std::collections::{HashMap, HashSet};\n use std::fs;\n@@ -24,11 +17,11 @@ use std::iter::{Enumerate, Peekable};\n use std::path::{Path, PathBuf};\n use std::str::Chars;\n \n-use rustfmt::config::summary::Summary;\n-use rustfmt::config::{Color, Config, ReportTactic};\n-use rustfmt::filemap::write_system_newlines;\n-use rustfmt::rustfmt_diff::*;\n-use rustfmt::*;\n+use config::summary::Summary;\n+use config::{Color, Config, ReportTactic};\n+use filemap::write_system_newlines;\n+use rustfmt_diff::*;\n+use *;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";", "previous_filename": "tests/lib.rs"}, {"sha": "2ede562e79d7e8c598af5fa712afbb803b1cbb27", "filename": "src/utils.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca610d35b3a78b9b2e9d8444eaf0296a1a242277/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ca610d35b3a78b9b2e9d8444eaf0296a1a242277", "patch": "@@ -255,15 +255,6 @@ pub fn count_newlines(input: &str) -> usize {\n     input.as_bytes().iter().filter(|&&c| c == b'\\n').count()\n }\n \n-macro_rules! msg {\n-    ($($arg:tt)*) => (\n-        match writeln!(&mut ::std::io::stderr(), $($arg)* ) {\n-            Ok(_) => {},\n-            Err(x) => panic!(\"Unable to write to stderr: {}\", x),\n-        }\n-    )\n-}\n-\n // For format_missing and last_pos, need to use the source callsite (if applicable).\n // Required as generated code spans aren't guaranteed to follow on from the last span.\n macro_rules! source {"}]}