{"sha": "2c4a0a78b8bb536d62d89119187f64da92687cd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNGEwYTc4YjhiYjUzNmQ2MmQ4OTExOTE4N2Y2NGRhOTI2ODdjZDU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-11-10T09:07:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-10T09:07:04Z"}, "message": "Rollup merge of #45783 - kennytm:compiler-test-fixes, r=alexcrichton\n\nMiscellaneous changes for CI, Docker and compiletest.\n\nThis PR contains 7 independent commits that improves interaction with CI, Docker and compiletest.\n\n1. a4e5c91cb8 \u2014 Forces a newline every 100 dots when testing in quiet mode. Prevents spurious timeouts when abusing the CI to test Android jobs.\n\n2. 1b5aaf22e8 \u2014 Use vault.centos.org for dist-powerpc64le-linux, see #45744.\n\n3. 33400fbbcd \u2014 Modify `src/ci/docker/run.sh` so that the docker images can be run from Docker Toolbox for Windows on Windows 7. I haven't checked the behavior of the newer Docker for Windows on Windows 10. Also, \"can run\" does not mean all the test can pass successfully (the UDP tests failed last time I checked)\n\n4. d517668a08 \u2014 Don't emit a real warning the linker segfault, which affects UI tests like https://github.com/rust-lang/rust/pull/45489#issuecomment-340134944. Log it instead.\n\n5. 51e2247948 \u2014 During run-pass, trim the output if stdout/stderr exceeds 416 KB (top 160 KB + bottom 256 KB). This is an attempt to avoid spurious failures like https://github.com/rust-lang/rust/pull/45384#issuecomment-341755788\n\n6. 9cfdabaf3c \u2014 Force `gem update --system` before deploy. This is an attempt to prevent spurious error #44159.\n\n7. eee10cc482 \u2014 Tries to print the crash log on macOS on failure. This is an attempt to debug #45230.", "tree": {"sha": "e0be47697872d3bdf8811efe273f7d7830b4a626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0be47697872d3bdf8811efe273f7d7830b4a626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c4a0a78b8bb536d62d89119187f64da92687cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4a0a78b8bb536d62d89119187f64da92687cd5", "html_url": "https://github.com/rust-lang/rust/commit/2c4a0a78b8bb536d62d89119187f64da92687cd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c4a0a78b8bb536d62d89119187f64da92687cd5/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5ff0e6422061c390a141354af8eacd540dca10b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ff0e6422061c390a141354af8eacd540dca10b", "html_url": "https://github.com/rust-lang/rust/commit/d5ff0e6422061c390a141354af8eacd540dca10b"}, {"sha": "eee10cc48245be7b98bfec4c19aa558243e29f46", "url": "https://api.github.com/repos/rust-lang/rust/commits/eee10cc48245be7b98bfec4c19aa558243e29f46", "html_url": "https://github.com/rust-lang/rust/commit/eee10cc48245be7b98bfec4c19aa558243e29f46"}], "stats": {"total": 422, "additions": 394, "deletions": 28}, "files": [{"sha": "33982838eae32a68ce84b1b272d099d82ad65262", "filename": ".travis.yml", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -253,7 +253,14 @@ after_failure:\n \n   # Random attempt at debugging currently. Just poking around in here to see if\n   # anything shows up.\n-  - ls $HOME/Library/Logs/DiagnosticReports/\n+  - ls -lat $HOME/Library/Logs/DiagnosticReports/\n+  - find $HOME/Library/Logs/DiagnosticReports/ ! \\(\n+      -name '*.stage2-*.crash'\n+      -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n+    \\)\n+      -exec echo -e travis_fold\":start:crashlog\\n\\033[31;1m\" {} \"\\033[0m\" \\;\n+      -exec head -750 {} \\;\n+      -exec echo travis_fold\":\"end:crashlog \\;\n \n   # attempt to debug anything killed by the oom killer on linux, just to see if\n   # it happened\n@@ -286,6 +293,7 @@ before_deploy:\n           rm -rf obj/build/dist/doc &&\n           cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n       fi\n+  - travis_retry gem update --system\n \n deploy:\n   - provider: s3"}, {"sha": "ff97de681a1a3ddbb541148d78cfc2ba782122f1", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -348,7 +348,9 @@ dependencies = [\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "922deba7367e97442f491b180757caa4069dace3", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -22,6 +22,48 @@ Images will output artifacts in an `obj` dir at the root of a repository.\n - `scripts` contains files shared by docker images\n - `disabled` contains images that are not built on travis\n \n+## Docker Toolbox on Windows\n+\n+For Windows before Windows 10, the docker images can be run on Windows via\n+[Docker Toolbox]. There are several preparation needs to be made before running\n+a Docker image.\n+\n+1. Stop the virtual machine from the terminal with `docker-machine stop`\n+\n+2. If your Rust source is placed outside of `C:\\Users\\**`, e.g. if you place the\n+    repository in the `E:\\rust` folder, please add a shared folder from\n+    VirtualBox by:\n+\n+    1. Select the \"default\" virtual machine inside VirtualBox, then click\n+        \"Settings\"\n+    2. Go to \"Shared Folders\", click \"Add shared foldrer\" (the folder icon with\n+        a plus sign), fill in the following information, then click \"OK\":\n+\n+        * Folder path: `E:\\rust`\n+        * Folder name: `e/rust`\n+        * Read-only: \u2610 *unchecked*\n+        * Auto-mount: \u2611 *checked*\n+        * Make Permanant: \u2611 *checked*\n+\n+3. VirtualBox might not support creating symbolic links inside a shared folder\n+    by default. You can enable it manually by running these from `cmd.exe`:\n+\n+    ```bat\n+    cd \"C:\\Program Files\\Oracle\\VirtualBox\"\n+    VBoxManage setextradata default VBoxInternal2/SharedFoldersEnableSymlinksCreate/e/rust 1\n+    ::                                                                              ^~~~~~\n+    ::                                                                              folder name\n+    ```\n+\n+4. Restart the virtual machine from terminal with `docker-machine start`.\n+\n+To run the image,\n+\n+1. Launch the \"Docker Quickstart Terminal\".\n+2. Execute `./src/ci/docker/run.sh $image_name` as explained at the beginning.\n+\n+[Docker Toolbox]: https://www.docker.com/products/docker-toolbox\n+\n ## Cross toolchains\n \n A number of these images take quite a long time to compile as they're building\n@@ -137,7 +179,7 @@ For targets: `armv7-unknown-linux-gnueabihf`\n     libraries like jemalloc. See the mk/cfg/arm(v7)-uknown-linux-gnueabi{,hf}.mk\n     file in Rust's source code.\n \n-## `aarch64-linux-gnu.config`\n+### `aarch64-linux-gnu.config`\n \n For targets: `aarch64-unknown-linux-gnu`\n \n@@ -150,7 +192,7 @@ For targets: `aarch64-unknown-linux-gnu`\n - C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n-## `powerpc-linux-gnu.config`\n+### `powerpc-linux-gnu.config`\n \n For targets: `powerpc-unknown-linux-gnu`\n \n@@ -165,7 +207,7 @@ For targets: `powerpc-unknown-linux-gnu`\n - C compiler > gcc version = 4.9.3\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n-## `powerpc64-linux-gnu.config`\n+### `powerpc64-linux-gnu.config`\n \n For targets: `powerpc64-unknown-linux-gnu`\n \n@@ -184,7 +226,7 @@ For targets: `powerpc64-unknown-linux-gnu`\n \n (+) These CPU options match the configuration of the toolchains in RHEL6.\n \n-## `s390x-linux-gnu.config`\n+### `s390x-linux-gnu.config`\n \n For targets: `s390x-unknown-linux-gnu`\n "}, {"sha": "5f556b67081a310d148e0e0752df1c374b88d534", "filename": "src/ci/docker/dist-powerpc64le-linux/build-powerpc64le-toolchain.sh", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -23,9 +23,9 @@ SYSROOT=/usr/local/$TARGET/sysroot\n mkdir -p $SYSROOT\n pushd $SYSROOT\n \n-centos_base=http://mirror.centos.org/altarch/7/os/ppc64le/Packages\n-glibc_v=2.17-196.el7\n-kernel_v=3.10.0-693.el7\n+centos_base=http://vault.centos.org/altarch/7.3.1611/os/ppc64le/Packages/\n+glibc_v=2.17-157.el7\n+kernel_v=3.10.0-514.el7\n for package in glibc{,-devel,-headers}-$glibc_v kernel-headers-$kernel_v; do\n   curl $centos_base/$package.ppc64le.rpm | \\\n     rpm2cpio - | cpio -idm"}, {"sha": "dc02310b4f21ff102ac39550ee0f89852a68e9e0", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -11,6 +11,8 @@\n \n set -e\n \n+export MSYS_NO_PATHCONV=1\n+\n script=`cd $(dirname $0) && pwd`/`basename $0`\n image=$1\n \n@@ -25,12 +27,19 @@ travis_fold start build_docker\n travis_time_start\n \n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n+    dockerfile=\"$docker_dir/$image/Dockerfile\"\n+    if [ -x /usr/bin/cygpath ]; then\n+        context=\"`cygpath -w $docker_dir`\"\n+        dockerfile=\"`cygpath -w $dockerfile`\"\n+    else\n+        context=\"$docker_dir\"\n+    fi\n     retry docker \\\n       build \\\n       --rm \\\n       -t rust-ci \\\n-      -f \"$docker_dir/$image/Dockerfile\" \\\n-      \"$docker_dir\"\n+      -f \"$dockerfile\" \\\n+      \"$context\"\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n     if [ -n \"$TRAVIS_OS_NAME\" ]; then\n         echo Cannot run disabled images on travis!"}, {"sha": "1961acf53a695232c920fe0144fa8f198fdbc645", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -671,11 +671,12 @@ fn link_natively(sess: &Session,\n             break\n         }\n \n-        sess.struct_warn(\"looks like the linker segfaulted when we tried to \\\n-                          call it, automatically retrying again\")\n-            .note(&format!(\"{:?}\", cmd))\n-            .note(&out)\n-            .emit();\n+        warn!(\n+            \"looks like the linker segfaulted when we tried to call it, \\\n+             automatically retrying again. cmd = {:?}, out = {}.\",\n+            cmd,\n+            out,\n+        );\n     }\n \n     match prog {"}, {"sha": "76abcb83edc53665efd9706c2682a522cd823fde", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -71,6 +71,7 @@ use std::thread;\n use std::time::{Instant, Duration};\n \n const TEST_WARN_TIMEOUT_S: u64 = 60;\n+const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n@@ -614,7 +615,14 @@ impl<T: Write> ConsoleTestState<T> {\n     pub fn write_short_result(&mut self, verbose: &str, quiet: &str, color: term::color::Color)\n                               -> io::Result<()> {\n         if self.quiet {\n-            self.write_pretty(quiet, color)\n+            self.write_pretty(quiet, color)?;\n+            if self.current_test_count() % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n+                // we insert a new line every 100 dots in order to flush the\n+                // screen when dealing with line-buffered output (e.g. piping to\n+                // `stamp` in the rust CI).\n+                self.write_plain(\"\\n\")?;\n+            }\n+            Ok(())\n         } else {\n             self.write_pretty(verbose, color)?;\n             self.write_plain(\"\\n\")\n@@ -771,9 +779,12 @@ impl<T: Write> ConsoleTestState<T> {\n         Ok(())\n     }\n \n+    fn current_test_count(&self) -> usize {\n+        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n+    }\n+\n     pub fn write_run_finish(&mut self) -> io::Result<bool> {\n-        assert!(self.passed + self.failed + self.ignored + self.measured +\n-                    self.allowed_fail == self.total);\n+        assert!(self.current_test_count() == self.total);\n \n         if self.options.display_output {\n             self.write_outputs()?;"}, {"sha": "d4d567e63c017748b2c606d02d50b0e2829e830a", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -11,3 +11,7 @@ getopts = \"0.2\"\n log = \"0.3\"\n rustc-serialize = \"0.3\"\n libc = \"0.2\"\n+\n+[target.'cfg(windows)'.dependencies]\n+miow = \"0.2\"\n+winapi = \"0.2\""}, {"sha": "9fb6a3f5e07539256d110bc58aced4641fa0578a", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -11,10 +11,11 @@\n #![crate_name = \"compiletest\"]\n \n #![feature(test)]\n+#![feature(slice_rotate)]\n \n #![deny(warnings)]\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[cfg(unix)]\n extern crate libc;\n extern crate test;\n extern crate getopts;\n@@ -47,6 +48,7 @@ pub mod runtest;\n pub mod common;\n pub mod errors;\n mod raise_fd_limit;\n+mod read2;\n \n fn main() {\n     env_logger::init().unwrap();"}, {"sha": "1d8816c7db132d95d78b728e0fdccdf536aaa14c", "filename": "src/tools/compiletest/src/read2.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fread2.rs?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -0,0 +1,208 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: This is a complete copy of `cargo/src/cargo/util/read2.rs`\n+// Consider unify the read2() in libstd, cargo and this to prevent further code duplication.\n+\n+pub use self::imp::read2;\n+\n+#[cfg(not(any(unix, windows)))]\n+mod imp {\n+    use std::io::{self, Read};\n+    use std::process::{ChildStdout, ChildStderr};\n+\n+    pub fn read2(out_pipe: ChildStdout,\n+                 err_pipe: ChildStderr,\n+                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+        let mut buffer = Vec::new();\n+        out_pipe.read_to_end(&mut buffer)?;\n+        data(true, &mut buffer, true);\n+        buffer.clear();\n+        err_pipe.read_to_end(&mut buffer)?;\n+        data(false, &mut buffer, true);\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use std::io::prelude::*;\n+    use std::io;\n+    use std::mem;\n+    use std::os::unix::prelude::*;\n+    use std::process::{ChildStdout, ChildStderr};\n+    use libc;\n+\n+    pub fn read2(mut out_pipe: ChildStdout,\n+                 mut err_pipe: ChildStderr,\n+                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+        unsafe {\n+            libc::fcntl(out_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n+            libc::fcntl(err_pipe.as_raw_fd(), libc::F_SETFL, libc::O_NONBLOCK);\n+        }\n+\n+        let mut out_done = false;\n+        let mut err_done = false;\n+        let mut out = Vec::new();\n+        let mut err = Vec::new();\n+\n+        let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n+        fds[0].fd = out_pipe.as_raw_fd();\n+        fds[0].events = libc::POLLIN;\n+        fds[1].fd = err_pipe.as_raw_fd();\n+        fds[1].events = libc::POLLIN;\n+        loop {\n+            // wait for either pipe to become readable using `select`\n+            let r = unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) };\n+            if r == -1 {\n+                let err = io::Error::last_os_error();\n+                if err.kind() == io::ErrorKind::Interrupted {\n+                    continue\n+                }\n+                return Err(err)\n+            }\n+\n+            // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n+            // EAGAIN. If we hit EOF, then this will happen because the underlying\n+            // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n+            // this case we flip the other fd back into blocking mode and read\n+            // whatever's leftover on that file descriptor.\n+            let handle = |res: io::Result<_>| {\n+                match res {\n+                    Ok(_) => Ok(true),\n+                    Err(e) => {\n+                        if e.kind() == io::ErrorKind::WouldBlock {\n+                            Ok(false)\n+                        } else {\n+                            Err(e)\n+                        }\n+                    }\n+                }\n+            };\n+            if !out_done && fds[0].revents != 0 && handle(out_pipe.read_to_end(&mut out))? {\n+                out_done = true;\n+            }\n+            data(true, &mut out, out_done);\n+            if !err_done && fds[1].revents != 0 && handle(err_pipe.read_to_end(&mut err))? {\n+                err_done = true;\n+            }\n+            data(false, &mut err, err_done);\n+\n+            if out_done && err_done {\n+                return Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    extern crate miow;\n+    extern crate winapi;\n+\n+    use std::io;\n+    use std::os::windows::prelude::*;\n+    use std::process::{ChildStdout, ChildStderr};\n+    use std::slice;\n+\n+    use self::miow::iocp::{CompletionPort, CompletionStatus};\n+    use self::miow::pipe::NamedPipe;\n+    use self::miow::Overlapped;\n+    use self::winapi::ERROR_BROKEN_PIPE;\n+\n+    struct Pipe<'a> {\n+        dst: &'a mut Vec<u8>,\n+        overlapped: Overlapped,\n+        pipe: NamedPipe,\n+        done: bool,\n+    }\n+\n+    pub fn read2(out_pipe: ChildStdout,\n+                 err_pipe: ChildStderr,\n+                 data: &mut FnMut(bool, &mut Vec<u8>, bool)) -> io::Result<()> {\n+        let mut out = Vec::new();\n+        let mut err = Vec::new();\n+\n+        let port = CompletionPort::new(1)?;\n+        port.add_handle(0, &out_pipe)?;\n+        port.add_handle(1, &err_pipe)?;\n+\n+        unsafe {\n+            let mut out_pipe = Pipe::new(out_pipe, &mut out);\n+            let mut err_pipe = Pipe::new(err_pipe, &mut err);\n+\n+            out_pipe.read()?;\n+            err_pipe.read()?;\n+\n+            let mut status = [CompletionStatus::zero(), CompletionStatus::zero()];\n+\n+            while !out_pipe.done || !err_pipe.done {\n+                for status in port.get_many(&mut status, None)? {\n+                    if status.token() == 0 {\n+                        out_pipe.complete(status);\n+                        data(true, out_pipe.dst, out_pipe.done);\n+                        out_pipe.read()?;\n+                    } else {\n+                        err_pipe.complete(status);\n+                        data(false, err_pipe.dst, err_pipe.done);\n+                        err_pipe.read()?;\n+                    }\n+                }\n+            }\n+\n+            Ok(())\n+        }\n+    }\n+\n+    impl<'a> Pipe<'a> {\n+        unsafe fn new<P: IntoRawHandle>(p: P, dst: &'a mut Vec<u8>) -> Pipe<'a> {\n+            Pipe {\n+                dst: dst,\n+                pipe: NamedPipe::from_raw_handle(p.into_raw_handle()),\n+                overlapped: Overlapped::zero(),\n+                done: false,\n+            }\n+        }\n+\n+        unsafe fn read(&mut self) -> io::Result<()> {\n+            let dst = slice_to_end(self.dst);\n+            match self.pipe.read_overlapped(dst, self.overlapped.raw()) {\n+                Ok(_) => Ok(()),\n+                Err(e) => {\n+                    if e.raw_os_error() == Some(ERROR_BROKEN_PIPE as i32) {\n+                        self.done = true;\n+                        Ok(())\n+                    } else {\n+                        Err(e)\n+                    }\n+                }\n+            }\n+        }\n+\n+        unsafe fn complete(&mut self, status: &CompletionStatus) {\n+            let prev = self.dst.len();\n+            self.dst.set_len(prev + status.bytes_transferred() as usize);\n+            if status.bytes_transferred() == 0 {\n+                self.done = true;\n+            }\n+        }\n+    }\n+\n+    unsafe fn slice_to_end(v: &mut Vec<u8>) -> &mut [u8] {\n+        if v.capacity() == 0 {\n+            v.reserve(16);\n+        }\n+        if v.capacity() == v.len() {\n+            v.reserve(1);\n+        }\n+        slice::from_raw_parts_mut(v.as_mut_ptr().offset(v.len() as isize),\n+                                  v.capacity() - v.len())\n+    }\n+}"}, {"sha": "80ca0afe72b50d26c49c4f3c018de8e49dc5edb3", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 85, "deletions": 6, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -29,7 +29,7 @@ use std::fmt;\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, ExitStatus, Stdio};\n+use std::process::{Command, Output, ExitStatus, Stdio, Child};\n use std::str;\n \n use extract_gdb_version;\n@@ -1344,12 +1344,14 @@ actual:\\n\\\n         if let Some(input) = input {\n             child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n         }\n-        let Output { status, stdout, stderr } = child.wait_with_output().unwrap();\n+\n+        let Output { status, stdout, stderr } = read2_abbreviated(child)\n+            .expect(\"failed to read output\");\n \n         let result = ProcRes {\n             status,\n-            stdout: String::from_utf8(stdout).unwrap(),\n-            stderr: String::from_utf8(stderr).unwrap(),\n+            stdout: String::from_utf8_lossy(&stdout).into_owned(),\n+            stderr: String::from_utf8_lossy(&stderr).into_owned(),\n             cmdline,\n         };\n \n@@ -1635,7 +1637,9 @@ actual:\\n\\\n         cmd.arg(\"-a\").arg(\"-u\");\n         cmd.arg(filename);\n         cmd.arg(\"-nobanner\");\n-        let output = match cmd.output() {\n+        cmd.stdout(Stdio::piped());\n+        cmd.stderr(Stdio::piped());\n+        let output = match cmd.spawn().and_then(read2_abbreviated) {\n             Ok(output) => output,\n             Err(_) => return,\n         };\n@@ -2095,6 +2099,8 @@ actual:\\n\\\n \n         let mut cmd = Command::new(make);\n         cmd.current_dir(&self.testpaths.file)\n+           .stdout(Stdio::piped())\n+           .stderr(Stdio::piped())\n            .env(\"TARGET\", &self.config.target)\n            .env(\"PYTHON\", &self.config.docck_python)\n            .env(\"S\", src_root)\n@@ -2143,7 +2149,7 @@ actual:\\n\\\n             }\n         }\n \n-        let output = cmd.output().expect(\"failed to spawn `make`\");\n+        let output = cmd.spawn().and_then(read2_abbreviated).expect(\"failed to spawn `make`\");\n         if !output.status.success() {\n             let res = ProcRes {\n                 status: output.status,\n@@ -2536,3 +2542,76 @@ fn nocomment_mir_line(line: &str) -> &str {\n         line\n     }\n }\n+\n+fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n+    use std::mem::replace;\n+    use read2::read2;\n+\n+    const HEAD_LEN: usize = 160 * 1024;\n+    const TAIL_LEN: usize = 256 * 1024;\n+\n+    enum ProcOutput {\n+        Full(Vec<u8>),\n+        Abbreviated {\n+            head: Vec<u8>,\n+            skipped: usize,\n+            tail: Box<[u8]>,\n+        }\n+    }\n+\n+    impl ProcOutput {\n+        fn extend(&mut self, data: &[u8]) {\n+            let new_self = match *self {\n+                ProcOutput::Full(ref mut bytes) => {\n+                    bytes.extend_from_slice(data);\n+                    let new_len = bytes.len();\n+                    if new_len <= HEAD_LEN + TAIL_LEN {\n+                        return;\n+                    }\n+                    let tail = bytes.split_off(new_len - TAIL_LEN).into_boxed_slice();\n+                    let head = replace(bytes, Vec::new());\n+                    let skipped = new_len - HEAD_LEN - TAIL_LEN;\n+                    ProcOutput::Abbreviated { head, skipped, tail }\n+                }\n+                ProcOutput::Abbreviated { ref mut skipped, ref mut tail, .. } => {\n+                    *skipped += data.len();\n+                    if data.len() <= TAIL_LEN {\n+                        tail[..data.len()].copy_from_slice(data);\n+                        tail.rotate(data.len());\n+                    } else {\n+                        tail.copy_from_slice(&data[(data.len() - TAIL_LEN)..]);\n+                    }\n+                    return;\n+                }\n+            };\n+            *self = new_self;\n+        }\n+\n+        fn into_bytes(self) -> Vec<u8> {\n+            match self {\n+                ProcOutput::Full(bytes) => bytes,\n+                ProcOutput::Abbreviated { mut head, skipped, tail } => {\n+                    write!(&mut head, \"\\n\\n<<<<<< SKIPPED {} BYTES >>>>>>\\n\\n\", skipped).unwrap();\n+                    head.extend_from_slice(&tail);\n+                    head\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut stdout = ProcOutput::Full(Vec::new());\n+    let mut stderr = ProcOutput::Full(Vec::new());\n+\n+    drop(child.stdin.take());\n+    read2(child.stdout.take().unwrap(), child.stderr.take().unwrap(), &mut |is_stdout, data, _| {\n+        if is_stdout { &mut stdout } else { &mut stderr }.extend(data);\n+        data.clear();\n+    })?;\n+    let status = child.wait()?;\n+\n+    Ok(Output {\n+        status,\n+        stdout: stdout.into_bytes(),\n+        stderr: stderr.into_bytes(),\n+    })\n+}\n\\ No newline at end of file"}, {"sha": "f6e42c8dc17b1908a6f5787f12ce82f18baaf65c", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c4a0a78b8bb536d62d89119187f64da92687cd5/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=2c4a0a78b8bb536d62d89119187f64da92687cd5", "patch": "@@ -31,9 +31,9 @@ pub fn check(path: &Path, bad: &mut bool) {\n     if let Ok(mut file) = fs::File::open(\"/proc/version\") {\n         let mut contents = String::new();\n         file.read_to_string(&mut contents).unwrap();\n-        // Probably on Windows Linux Subsystem, all files will be marked as\n-        // executable, so skip checking.\n-        if contents.contains(\"Microsoft\") {\n+        // Probably on Windows Linux Subsystem or Docker via VirtualBox,\n+        // all files will be marked as executable, so skip checking.\n+        if contents.contains(\"Microsoft\") || contents.contains(\"boot2docker\") {\n             return;\n         }\n     }"}]}