{"sha": "ac5f595d0a863b41790442a5ae3d65528dda6ecb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNWY1OTVkMGE4NjNiNDE3OTA0NDJhNWFlM2Q2NTUyOGRkYTZlY2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-30T02:03:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-30T02:03:27Z"}, "message": "Auto merge of #24884 - michaelsproul:extended-errors, r=nrc\n\nI've been working on improving the diagnostic registration system so that it can:\r\n\r\n* Check uniqueness of error codes *across the whole compiler*. The current method using `errorck.py` is prone to failure as it relies on simple text search - I found that it breaks when referencing an error's ident within a string (e.g. `\"See also E0303\"`).\r\n* Provide JSON output of error metadata, to eventually facilitate HTML output, as well as tracking of which errors need descriptions. The current schema is:\r\n\r\n```\r\n<error code>: {\r\n    \"description\": <long description>,\r\n    \"use_site\": {\r\n        \"filename\": <filename where error is used>,\r\n        \"line\": <line in file where error is used>\r\n    }\r\n}\r\n```\r\n\r\n[Here's][metadata-dump] a pretty-printed sample dump for `librustc`.\r\n\r\nOne thing to note is that I had to move the diagnostics arrays out of the diagnostics modules. I really wanted to be able to capture error usage information, which only becomes available as a crate is compiled. Hence all invocations of `__build_diagnostics_array!` have been moved to the ends of their respective `lib.rs` files. I tried to avoid moving the array by making a plugin that expands to nothing but couldn't invoke it in item position and gave up on hackily generating a fake item. I also briefly considered using a lint, but it seemed like it would impossible to get access to the data stored in the thread-local storage.\r\n\r\nThe next step will be to generate a web page that lists each error with its rendered description and use site. Simple mapping and filtering of the metadata files also allows us to work out which error numbers are absent, which errors are unused and which need descriptions.\r\n\r\n[metadata-dump]: https://gist.github.com/michaelsproul/3246846ff1bea71bd049", "tree": {"sha": "645da77ab43be446436c743a3606cf55ba51f60d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/645da77ab43be446436c743a3606cf55ba51f60d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac5f595d0a863b41790442a5ae3d65528dda6ecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5f595d0a863b41790442a5ae3d65528dda6ecb", "html_url": "https://github.com/rust-lang/rust/commit/ac5f595d0a863b41790442a5ae3d65528dda6ecb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac5f595d0a863b41790442a5ae3d65528dda6ecb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5449f5d29e175230a1285ebe92394f50c76e1df6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5449f5d29e175230a1285ebe92394f50c76e1df6", "html_url": "https://github.com/rust-lang/rust/commit/5449f5d29e175230a1285ebe92394f50c76e1df6"}, {"sha": "d27230bb6d45eeabf13c0d9e5605636840af01c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27230bb6d45eeabf13c0d9e5605636840af01c2", "html_url": "https://github.com/rust-lang/rust/commit/d27230bb6d45eeabf13c0d9e5605636840af01c2"}], "stats": {"total": 290, "additions": 244, "deletions": 46}, "files": [{"sha": "7fbe89648d547a410c8ab99ac7d72e1572077f5c", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -550,5 +550,3 @@ register_diagnostics! {\n     E0316, // nested quantification of lifetimes\n     E0370  // discriminant overflow\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "5bd3759a6e04e5386fadf522afb4aa21a5c74077", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -161,3 +161,9 @@ pub mod lib {\n mod rustc {\n     pub use lint;\n }\n+\n+// Build the diagnostics array at the end so that the metadata includes error use sites.\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "a43268ff1a8827c1cad97eef5a5f66c481467bb8", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -13,5 +13,3 @@\n register_diagnostics! {\n     E0373 // closure may outlive current fn, but it borrows {}, which is owned by current fn\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "50dc08e299a822701eaf28c5fc87b0d223b0861a", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -46,3 +46,8 @@ pub mod diagnostics;\n mod borrowck;\n \n pub mod graphviz;\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "8dff0f1d3f41a61e78589c3027070ebd54a00ffb", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -853,9 +853,10 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n \n     let all_errors = Vec::new() +\n-        &rustc::diagnostics::DIAGNOSTICS[..] +\n-        &rustc_typeck::diagnostics::DIAGNOSTICS[..] +\n-        &rustc_resolve::diagnostics::DIAGNOSTICS[..];\n+        &rustc::DIAGNOSTICS[..] +\n+        &rustc_typeck::DIAGNOSTICS[..] +\n+        &rustc_borrowck::DIAGNOSTICS[..] +\n+        &rustc_resolve::DIAGNOSTICS[..];\n \n     Registry::new(&*all_errors)\n }"}, {"sha": "a896bd311698c3cf55fd8d9a4e146d5bab99e8c3", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -28,5 +28,3 @@ register_diagnostics! {\n     E0364, // item is private\n     E0365  // item is private\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "7abe5a84c5fff80fde3206c6e0987aa91316cb5a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -3706,3 +3706,8 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n                     },\n     }\n }\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_resolve, DIAGNOSTICS }"}, {"sha": "0af19e445f26e554eb3129950393de8ce9fb0074", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -188,5 +188,3 @@ register_diagnostics! {\n     E0371, // impl Trait for Trait is illegal\n     E0372  // impl Trait for Trait where Trait is not object safe\n }\n-\n-__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "e50693ea804b6993a852ea82bbcea5ae054dccb5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -343,3 +343,8 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n }\n+\n+#[cfg(stage0)]\n+__build_diagnostic_array! { DIAGNOSTICS }\n+#[cfg(not(stage0))]\n+__build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "6cb4f70b8607aceb3867e108f1277c6553778cfb", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains utilities for outputting metadata for diagnostic errors.\n+//!\n+//! Each set of errors is mapped to a metadata file by a name, which is\n+//! currently always a crate name.\n+\n+use std::collections::BTreeMap;\n+use std::env;\n+use std::path::PathBuf;\n+use std::fs::{read_dir, create_dir_all, OpenOptions, File};\n+use std::io::{Read, Write};\n+use std::error::Error;\n+use rustc_serialize::json::{self, as_json};\n+\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use diagnostics::plugin::{ErrorMap, ErrorInfo};\n+\n+pub use self::Uniqueness::*;\n+\n+// Default metadata directory to use for extended error JSON.\n+const ERROR_METADATA_DIR_DEFAULT: &'static str = \"tmp/extended-errors\";\n+\n+// The name of the environment variable that sets the metadata dir.\n+const ERROR_METADATA_VAR: &'static str = \"ERROR_METADATA_DIR\";\n+\n+/// JSON encodable/decodable version of `ErrorInfo`.\n+#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n+pub struct ErrorMetadata {\n+    pub description: Option<String>,\n+    pub use_site: Option<ErrorLocation>\n+}\n+\n+/// Mapping from error codes to metadata that can be (de)serialized.\n+pub type ErrorMetadataMap = BTreeMap<String, ErrorMetadata>;\n+\n+/// JSON encodable error location type with filename and line number.\n+#[derive(PartialEq, RustcDecodable, RustcEncodable)]\n+pub struct ErrorLocation {\n+    pub filename: String,\n+    pub line: usize\n+}\n+\n+impl ErrorLocation {\n+    /// Create an error location from a span.\n+    pub fn from_span(ecx: &ExtCtxt, sp: Span) -> ErrorLocation {\n+        let loc = ecx.codemap().lookup_char_pos_adj(sp.lo);\n+        ErrorLocation {\n+            filename: loc.filename,\n+            line: loc.line\n+        }\n+    }\n+}\n+\n+/// Type for describing the uniqueness of a set of error codes, as returned by `check_uniqueness`.\n+pub enum Uniqueness {\n+    /// All errors in the set checked are unique according to the metadata files checked.\n+    Unique,\n+    /// One or more errors in the set occur in another metadata file.\n+    /// This variant contains the first duplicate error code followed by the name\n+    /// of the metadata file where the duplicate appears.\n+    Duplicate(String, String)\n+}\n+\n+/// Get the directory where metadata files should be stored.\n+pub fn get_metadata_dir() -> PathBuf {\n+    match env::var(ERROR_METADATA_VAR) {\n+        Ok(v) => From::from(v),\n+        Err(_) => From::from(ERROR_METADATA_DIR_DEFAULT)\n+    }\n+}\n+\n+/// Get the path where error metadata for the set named by `name` should be stored.\n+fn get_metadata_path(name: &str) -> PathBuf {\n+    get_metadata_dir().join(format!(\"{}.json\", name))\n+}\n+\n+/// Check that the errors in `err_map` aren't present in any metadata files in the\n+/// metadata directory except the metadata file corresponding to `name`.\n+pub fn check_uniqueness(name: &str, err_map: &ErrorMap) -> Result<Uniqueness, Box<Error>> {\n+    let metadata_dir = get_metadata_dir();\n+    let metadata_path = get_metadata_path(name);\n+\n+    // Create the error directory if it does not exist.\n+    try!(create_dir_all(&metadata_dir));\n+\n+    // Check each file in the metadata directory.\n+    for entry in try!(read_dir(&metadata_dir)) {\n+        let path = try!(entry).path();\n+\n+        // Skip any existing file for this set.\n+        if path == metadata_path {\n+            continue;\n+        }\n+\n+        // Read the metadata file into a string.\n+        let mut metadata_str = String::new();\n+        try!(\n+            File::open(&path).and_then(|mut f|\n+            f.read_to_string(&mut metadata_str))\n+        );\n+\n+        // Parse the JSON contents.\n+        let metadata: ErrorMetadataMap = try!(json::decode(&metadata_str));\n+\n+        // Check for duplicates.\n+        for err in err_map.keys() {\n+            let err_code = err.as_str();\n+            if metadata.contains_key(err_code) {\n+                return Ok(Duplicate(\n+                    err_code.to_string(),\n+                    path.to_string_lossy().into_owned()\n+                ));\n+            }\n+        }\n+    }\n+\n+    Ok(Unique)\n+}\n+\n+/// Write metadata for the errors in `err_map` to disk, to a file corresponding to `name`.\n+pub fn output_metadata(ecx: &ExtCtxt, name: &str, err_map: &ErrorMap)\n+    -> Result<(), Box<Error>>\n+{\n+    let metadata_path = get_metadata_path(name);\n+\n+    // Open the dump file.\n+    let mut dump_file = try!(OpenOptions::new()\n+        .write(true)\n+        .create(true)\n+        .open(&metadata_path)\n+    );\n+\n+    // Construct a serializable map.\n+    let json_map = err_map.iter().map(|(k, &ErrorInfo { description, use_site })| {\n+        let key = k.as_str().to_string();\n+        let value = ErrorMetadata {\n+            description: description.map(|n| n.as_str().to_string()),\n+            use_site: use_site.map(|sp| ErrorLocation::from_span(ecx, sp))\n+        };\n+        (key, value)\n+    }).collect::<ErrorMetadataMap>();\n+\n+    try!(write!(&mut dump_file, \"{}\", as_json(&json_map)));\n+    Ok(())\n+}"}, {"sha": "16841bd90398147b9919e1711c9f72c223deb53f", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 62, "deletions": 34, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -14,6 +14,7 @@ use std::collections::BTreeMap;\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n+use diagnostics::metadata::{check_uniqueness, output_metadata, Duplicate};\n use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n@@ -24,32 +25,28 @@ use util::small_vector::SmallVector;\n const MAX_DESCRIPTION_WIDTH: usize = 80;\n \n thread_local! {\n-    static REGISTERED_DIAGNOSTICS: RefCell<BTreeMap<Name, Option<Name>>> = {\n+    static REGISTERED_DIAGNOSTICS: RefCell<ErrorMap> = {\n         RefCell::new(BTreeMap::new())\n     }\n }\n-thread_local! {\n-    static USED_DIAGNOSTICS: RefCell<BTreeMap<Name, Span>> = {\n-        RefCell::new(BTreeMap::new())\n-    }\n+\n+/// Error information type.\n+pub struct ErrorInfo {\n+    pub description: Option<Name>,\n+    pub use_site: Option<Span>\n }\n \n+/// Mapping from error codes to metadata.\n+pub type ErrorMap = BTreeMap<Name, ErrorInfo>;\n+\n fn with_registered_diagnostics<T, F>(f: F) -> T where\n-    F: FnOnce(&mut BTreeMap<Name, Option<Name>>) -> T,\n+    F: FnOnce(&mut ErrorMap) -> T,\n {\n     REGISTERED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n     })\n }\n \n-fn with_used_diagnostics<T, F>(f: F) -> T where\n-    F: FnOnce(&mut BTreeMap<Name, Span>) -> T,\n-{\n-    USED_DIAGNOSTICS.with(move |slot| {\n-        f(&mut *slot.borrow_mut())\n-    })\n-}\n-\n pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n@@ -58,23 +55,26 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         (1, Some(&ast::TtToken(_, token::Ident(code, _)))) => code,\n         _ => unreachable!()\n     };\n-    with_used_diagnostics(|diagnostics| {\n-        match diagnostics.insert(code.name, span) {\n-            Some(previous_span) => {\n+\n+    with_registered_diagnostics(|diagnostics| {\n+        match diagnostics.get_mut(&code.name) {\n+            // Previously used errors.\n+            Some(&mut ErrorInfo { description: _, use_site: Some(previous_span) }) => {\n                 ecx.span_warn(span, &format!(\n                     \"diagnostic code {} already used\", &token::get_ident(code)\n                 ));\n                 ecx.span_note(previous_span, \"previous invocation\");\n-            },\n-            None => ()\n-        }\n-        ()\n-    });\n-    with_registered_diagnostics(|diagnostics| {\n-        if !diagnostics.contains_key(&code.name) {\n-            ecx.span_err(span, &format!(\n-                \"used diagnostic code {} not registered\", &token::get_ident(code)\n-            ));\n+            }\n+            // Newly used errors.\n+            Some(ref mut info) => {\n+                info.use_site = Some(span);\n+            }\n+            // Unregistered errors.\n+            None => {\n+                ecx.span_err(span, &format!(\n+                    \"used diagnostic code {} not registered\", &token::get_ident(code)\n+                ));\n+            }\n         }\n     });\n     MacEager::expr(ecx.expr_tuple(span, Vec::new()))\n@@ -116,10 +116,14 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n                 token::get_ident(*code), MAX_DESCRIPTION_WIDTH\n             ));\n         }\n-        raw_msg\n     });\n+    // Add the error to the map.\n     with_registered_diagnostics(|diagnostics| {\n-        if diagnostics.insert(code.name, description).is_some() {\n+        let info = ErrorInfo {\n+            description: description,\n+            use_site: None\n+        };\n+        if diagnostics.insert(code.name, info).is_some() {\n             ecx.span_err(span, &format!(\n                 \"diagnostic code {} already registered\", &token::get_ident(*code)\n             ));\n@@ -143,19 +147,43 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           span: Span,\n                                           token_tree: &[TokenTree])\n                                           -> Box<MacResult+'cx> {\n-    let name = match (token_tree.len(), token_tree.get(0)) {\n-        (1, Some(&ast::TtToken(_, token::Ident(ref name, _)))) => name,\n+    assert_eq!(token_tree.len(), 3);\n+    let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n+        (\n+            // Crate name.\n+            &ast::TtToken(_, token::Ident(ref crate_name, _)),\n+            // DIAGNOSTICS ident.\n+            &ast::TtToken(_, token::Ident(ref name, _))\n+        ) => (crate_name.as_str(), name),\n         _ => unreachable!()\n     };\n \n+    // Check uniqueness of errors and output metadata.\n+    with_registered_diagnostics(|diagnostics| {\n+        match check_uniqueness(crate_name, &*diagnostics) {\n+            Ok(Duplicate(err, location)) => {\n+                ecx.span_err(span, &format!(\n+                    \"error {} from `{}' also found in `{}'\",\n+                    err, crate_name, location\n+                ));\n+            },\n+            Ok(_) => (),\n+            Err(e) => panic!(\"{}\", e.description())\n+        }\n+\n+        output_metadata(&*ecx, crate_name, &*diagnostics).ok().expect(\"metadata output error\");\n+    });\n+\n+    // Construct the output expression.\n     let (count, expr) =\n         with_registered_diagnostics(|diagnostics| {\n             let descriptions: Vec<P<ast::Expr>> =\n-                diagnostics.iter().filter_map(|(code, description)| {\n-                    description.map(|description| {\n+                diagnostics.iter().filter_map(|(code, info)| {\n+                    info.description.map(|description| {\n                         ecx.expr_tuple(span, vec![\n                             ecx.expr_str(span, token::get_name(*code)),\n-                            ecx.expr_str(span, token::get_name(description))])\n+                            ecx.expr_str(span, token::get_name(description))\n+                        ])\n                     })\n                 }).collect();\n             (descriptions.len(), ecx.expr_vec(span, descriptions))"}, {"sha": "275400009f5aafa4b32c72acd145b421863bd57b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -70,6 +70,7 @@ pub mod diagnostics {\n     pub mod macros;\n     pub mod plugin;\n     pub mod registry;\n+    pub mod metadata;\n }\n \n pub mod syntax {"}, {"sha": "8745cbecf913704df7cfa2c17631bb243b79a8a3", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5f595d0a863b41790442a5ae3d65528dda6ecb/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=ac5f595d0a863b41790442a5ae3d65528dda6ecb", "patch": "@@ -49,7 +49,7 @@ fn basic_sess(sysroot: PathBuf) -> Session {\n     opts.output_types = vec![OutputTypeExe];\n     opts.maybe_sysroot = Some(sysroot);\n \n-    let descriptions = Registry::new(&rustc::diagnostics::DIAGNOSTICS);\n+    let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess"}]}