{"sha": "4b94c232192b0fa0314b5afa18e366356e210c4c", "node_id": "C_kwDOAAsO6NoAKDRiOTRjMjMyMTkyYjBmYTAzMTRiNWFmYTE4ZTM2NjM1NmUyMTBjNGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-05T15:59:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-05T15:59:20Z"}, "message": "Auto merge of #111248 - Dylan-DPC:rollup-lbp0ui3, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #103056 (Fix `checked_{add,sub}_duration` incorrectly returning `None` when `other` has more than `i64::MAX` seconds)\n - #108801 (Implement RFC 3348, `c\"foo\"` literals)\n - #110773 (Reduce MIR dump file count for MIR-opt tests)\n - #110876 (Added default target cpu to `--print target-cpus` output and updated docs)\n - #111068 (Improve check-cfg implementation)\n - #111238 (btree_map: `Cursor{,Mut}::peek_prev` must agree)\n\nFailed merges:\n\n - #110694 (Implement builtin # syntax and use it for offset_of!(...))\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5e16d07c49b6de25df631d2e0a9ef9947795714c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e16d07c49b6de25df631d2e0a9ef9947795714c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b94c232192b0fa0314b5afa18e366356e210c4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b94c232192b0fa0314b5afa18e366356e210c4c", "html_url": "https://github.com/rust-lang/rust/commit/4b94c232192b0fa0314b5afa18e366356e210c4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b94c232192b0fa0314b5afa18e366356e210c4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32", "html_url": "https://github.com/rust-lang/rust/commit/4a18324a4df6bc98bec0b54d35908d7a9cdc7c32"}, {"sha": "c99ab29e6b2736006f22781802f3b5bd805139af", "url": "https://api.github.com/repos/rust-lang/rust/commits/c99ab29e6b2736006f22781802f3b5bd805139af", "html_url": "https://github.com/rust-lang/rust/commit/c99ab29e6b2736006f22781802f3b5bd805139af"}], "stats": {"total": 1688, "additions": 1164, "deletions": 524}, "files": [{"sha": "e3ac8a8784a7cd7e8b840f3a66bafb92ba9235ee", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -1821,6 +1821,8 @@ pub enum LitKind {\n     /// A byte string (`b\"foo\"`). Not stored as a symbol because it might be\n     /// non-utf8, and symbols only allow utf8 strings.\n     ByteStr(Lrc<[u8]>, StrStyle),\n+    /// A C String (`c\"foo\"`). Guaranteed to only have `\\0` at the end.\n+    CStr(Lrc<[u8]>, StrStyle),\n     /// A byte char (`b'f'`).\n     Byte(u8),\n     /// A character literal (`'a'`).\n@@ -1875,6 +1877,7 @@ impl LitKind {\n             // unsuffixed variants\n             LitKind::Str(..)\n             | LitKind::ByteStr(..)\n+            | LitKind::CStr(..)\n             | LitKind::Byte(..)\n             | LitKind::Char(..)\n             | LitKind::Int(_, LitIntType::Unsuffixed)"}, {"sha": "42b843482a32b386ff9bf374fd342360cebff71d", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -74,6 +74,8 @@ pub enum LitKind {\n     StrRaw(u8), // raw string delimited by `n` hash symbols\n     ByteStr,\n     ByteStrRaw(u8), // raw byte string delimited by `n` hash symbols\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -141,6 +143,10 @@ impl fmt::Display for Lit {\n                 delim = \"#\".repeat(n as usize),\n                 string = symbol\n             )?,\n+            CStr => write!(f, \"c\\\"{symbol}\\\"\")?,\n+            CStrRaw(n) => {\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))?\n+            }\n             Integer | Float | Bool | Err => write!(f, \"{symbol}\")?,\n         }\n \n@@ -170,6 +176,7 @@ impl LitKind {\n             Float => \"float\",\n             Str | StrRaw(..) => \"string\",\n             ByteStr | ByteStrRaw(..) => \"byte string\",\n+            CStr | CStrRaw(..) => \"C string\",\n             Err => \"error\",\n         }\n     }"}, {"sha": "15a54fe13d0b78153b915778e412b270099ee9fa", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -2,9 +2,13 @@\n \n use crate::ast::{self, LitKind, MetaItemLit, StrStyle};\n use crate::token::{self, Token};\n-use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n+use rustc_lexer::unescape::{\n+    byte_from_char, unescape_byte, unescape_c_string, unescape_char, unescape_literal, CStrUnit,\n+    Mode,\n+};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n+use std::ops::Range;\n use std::{ascii, fmt, str};\n \n // Escapes a string, represented as a symbol. Reuses the original symbol,\n@@ -35,6 +39,7 @@ pub enum LitError {\n     InvalidFloatSuffix,\n     NonDecimalFloat(u32),\n     IntTooLarge(u32),\n+    NulInCStr(Range<usize>),\n }\n \n impl LitKind {\n@@ -158,6 +163,52 @@ impl LitKind {\n \n                 LitKind::ByteStr(bytes.into(), StrStyle::Raw(n))\n             }\n+            token::CStr => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::CStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Cooked)\n+            }\n+            token::CStrRaw(n) => {\n+                let s = symbol.as_str();\n+                let mut buf = Vec::with_capacity(s.len());\n+                let mut error = Ok(());\n+                unescape_c_string(s, Mode::RawCStr, &mut |span, c| match c {\n+                    Ok(CStrUnit::Byte(0) | CStrUnit::Char('\\0')) => {\n+                        error = Err(LitError::NulInCStr(span));\n+                    }\n+                    Ok(CStrUnit::Byte(b)) => buf.push(b),\n+                    Ok(CStrUnit::Char(c)) if c.len_utf8() == 1 => buf.push(c as u8),\n+                    Ok(CStrUnit::Char(c)) => {\n+                        buf.extend_from_slice(c.encode_utf8(&mut [0; 4]).as_bytes())\n+                    }\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n+                        }\n+                    }\n+                });\n+                error?;\n+                buf.push(0);\n+                LitKind::CStr(buf.into(), StrStyle::Raw(n))\n+            }\n             token::Err => LitKind::Err,\n         })\n     }\n@@ -191,6 +242,14 @@ impl fmt::Display for LitKind {\n                     string = symbol\n                 )?;\n             }\n+            LitKind::CStr(ref bytes, StrStyle::Cooked) => {\n+                write!(f, \"c\\\"{}\\\"\", escape_byte_str_symbol(bytes))?\n+            }\n+            LitKind::CStr(ref bytes, StrStyle::Raw(n)) => {\n+                // This can only be valid UTF-8.\n+                let symbol = str::from_utf8(bytes).unwrap();\n+                write!(f, \"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize),)?;\n+            }\n             LitKind::Int(n, ty) => {\n                 write!(f, \"{n}\")?;\n                 match ty {\n@@ -237,6 +296,8 @@ impl MetaItemLit {\n             LitKind::Str(_, ast::StrStyle::Raw(n)) => token::StrRaw(n),\n             LitKind::ByteStr(_, ast::StrStyle::Cooked) => token::ByteStr,\n             LitKind::ByteStr(_, ast::StrStyle::Raw(n)) => token::ByteStrRaw(n),\n+            LitKind::CStr(_, ast::StrStyle::Cooked) => token::CStr,\n+            LitKind::CStr(_, ast::StrStyle::Raw(n)) => token::CStrRaw(n),\n             LitKind::Byte(_) => token::Byte,\n             LitKind::Char(_) => token::Char,\n             LitKind::Int(..) => token::Integer,"}, {"sha": "b960671bf6e158aa21bab70859d8d32128b288d5", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -572,6 +572,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n             }\n         };\n     }\n+    gate_all!(c_str_literals, \"`c\\\"..\\\"` literals are experimental\");\n     gate_all!(\n         if_let_guard,\n         \"`if let` guards are experimental\","}, {"sha": "3f80728a2606b64280820c1ba80b2dfe45b06a57", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -210,6 +210,10 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n         token::ByteStrRaw(n) => {\n             format!(\"br{delim}\\\"{string}\\\"{delim}\", delim = \"#\".repeat(n as usize), string = symbol)\n         }\n+        token::CStr => format!(\"c\\\"{symbol}\\\"\"),\n+        token::CStrRaw(n) => {\n+            format!(\"cr{delim}\\\"{symbol}\\\"{delim}\", delim = \"#\".repeat(n as usize))\n+        }\n         token::Integer | token::Float | token::Bool | token::Err => symbol.to_string(),\n     };\n "}, {"sha": "2a3092d3c7b348fb1c834cf0382e9e721d01d761", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedM\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::builtin::UNEXPECTED_CFGS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n@@ -581,32 +582,32 @@ pub fn cfg_matches(\n ) -> bool {\n     eval_condition(cfg, sess, features, &mut |cfg| {\n         try_gate_cfg(cfg.name, cfg.span, sess, features);\n-        if let Some(names_valid) = &sess.check_config.names_valid {\n-            if !names_valid.contains(&cfg.name) {\n+        match sess.check_config.expecteds.get(&cfg.name) {\n+            Some(ExpectedValues::Some(values)) if !values.contains(&cfg.value) => {\n                 sess.buffer_lint_with_diagnostic(\n                     UNEXPECTED_CFGS,\n                     cfg.span,\n                     lint_node_id,\n-                    \"unexpected `cfg` condition name\",\n-                    BuiltinLintDiagnostics::UnexpectedCfg((cfg.name, cfg.name_span), None),\n+                    \"unexpected `cfg` condition value\",\n+                    BuiltinLintDiagnostics::UnexpectedCfgValue(\n+                        (cfg.name, cfg.name_span),\n+                        cfg.value.map(|v| (v, cfg.value_span.unwrap())),\n+                    ),\n                 );\n             }\n-        }\n-        if let Some(value) = cfg.value {\n-            if let Some(values) = &sess.check_config.values_valid.get(&cfg.name) {\n-                if !values.contains(&value) {\n-                    sess.buffer_lint_with_diagnostic(\n-                        UNEXPECTED_CFGS,\n-                        cfg.span,\n-                        lint_node_id,\n-                        \"unexpected `cfg` condition value\",\n-                        BuiltinLintDiagnostics::UnexpectedCfg(\n-                            (cfg.name, cfg.name_span),\n-                            cfg.value_span.map(|vs| (value, vs)),\n-                        ),\n-                    );\n-                }\n+            None if sess.check_config.exhaustive_names => {\n+                sess.buffer_lint_with_diagnostic(\n+                    UNEXPECTED_CFGS,\n+                    cfg.span,\n+                    lint_node_id,\n+                    \"unexpected `cfg` condition name\",\n+                    BuiltinLintDiagnostics::UnexpectedCfgName(\n+                        (cfg.name, cfg.name_span),\n+                        cfg.value.map(|v| (v, cfg.value_span.unwrap())),\n+                    ),\n+                );\n             }\n+            _ => { /* not unexpected */ }\n         }\n         sess.config.contains(&(cfg.name, cfg.value))\n     })"}, {"sha": "50e88ae2eeeded88a87001354979231f75cc6792", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -32,6 +32,10 @@ pub fn expand_concat(\n                 Ok(ast::LitKind::Bool(b)) => {\n                     accumulator.push_str(&b.to_string());\n                 }\n+                Ok(ast::LitKind::CStr(..)) => {\n+                    cx.span_err(e.span, \"cannot concatenate a C string literal\");\n+                    has_errors = true;\n+                }\n                 Ok(ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..)) => {\n                     cx.emit_err(errors::ConcatBytestr { span: e.span });\n                     has_errors = true;"}, {"sha": "5ef35af0a059ad4cd12a7b6e71cde3dcc2bfea6f", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -18,6 +18,11 @@ fn invalid_type_err(\n     };\n     let snippet = cx.sess.source_map().span_to_snippet(span).ok();\n     match ast::LitKind::from_token_lit(token_lit) {\n+        Ok(ast::LitKind::CStr(_, _)) => {\n+            // FIXME(c_str_literals): should concatenation of C string literals\n+            // include the null bytes in the end?\n+            cx.span_err(span, \"cannot concatenate C string literals\");\n+        }\n         Ok(ast::LitKind::Char(_)) => {\n             let sugg =\n                 snippet.map(|snippet| ConcatBytesInvalidSuggestion::CharLit { span, snippet });"}, {"sha": "53d97f352010637c0b06710eb9fd6c113a530a9f", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -2249,7 +2249,7 @@ extern \"C\" {\n \n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n-    pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n+    pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine, cpu: *const c_char);\n     pub fn LLVMRustGetTargetFeaturesCount(T: &TargetMachine) -> size_t;\n     pub fn LLVMRustGetTargetFeature(\n         T: &TargetMachine,"}, {"sha": "2fbdab9f8ce03af6e514205d5651a0f76dd9b55a", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -329,7 +329,14 @@ pub(crate) fn print(req: PrintRequest, sess: &Session) {\n     require_inited();\n     let tm = create_informational_target_machine(sess);\n     match req {\n-        PrintRequest::TargetCPUs => unsafe { llvm::LLVMRustPrintTargetCPUs(tm) },\n+        PrintRequest::TargetCPUs => {\n+            // SAFETY generate a C compatible string from a byte slice to pass\n+            // the target CPU name into LLVM, the lifetime of the reference is\n+            // at least as long as the C function\n+            let cpu_cstring = CString::new(handle_native(sess.target.cpu.as_ref()))\n+                .unwrap_or_else(|e| bug!(\"failed to convert to cstring: {}\", e));\n+            unsafe { llvm::LLVMRustPrintTargetCPUs(tm, cpu_cstring.as_ptr()) };\n+        }\n         PrintRequest::TargetFeatures => print_target_features(sess, tm),\n         _ => bug!(\"rustc_codegen_llvm can't handle print request: {:?}\", req),\n     }"}, {"sha": "891e84a2f3071d8cdbf26f2425f18f19d069b5b3", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -61,6 +61,8 @@ impl FromInternal<token::LitKind> for LitKind {\n             token::StrRaw(n) => LitKind::StrRaw(n),\n             token::ByteStr => LitKind::ByteStr,\n             token::ByteStrRaw(n) => LitKind::ByteStrRaw(n),\n+            token::CStr => LitKind::CStr,\n+            token::CStrRaw(n) => LitKind::CStrRaw(n),\n             token::Err => LitKind::Err,\n             token::Bool => unreachable!(),\n         }\n@@ -78,6 +80,8 @@ impl ToInternal<token::LitKind> for LitKind {\n             LitKind::StrRaw(n) => token::StrRaw(n),\n             LitKind::ByteStr => token::ByteStr,\n             LitKind::ByteStrRaw(n) => token::ByteStrRaw(n),\n+            LitKind::CStr => token::CStr,\n+            LitKind::CStrRaw(n) => token::CStrRaw(n),\n             LitKind::Err => token::Err,\n         }\n     }\n@@ -436,6 +440,8 @@ impl server::FreeFunctions for Rustc<'_, '_> {\n                 | token::LitKind::StrRaw(_)\n                 | token::LitKind::ByteStr\n                 | token::LitKind::ByteStrRaw(_)\n+                | token::LitKind::CStr\n+                | token::LitKind::CStrRaw(_)\n                 | token::LitKind::Err => return Err(()),\n                 token::LitKind::Integer | token::LitKind::Float => {}\n             }"}, {"sha": "7e7df0e9584383edbf821c683290d4c8f366f292", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -313,6 +313,8 @@ declare_features! (\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n     /// Allows async functions to be declared, implemented, and used in traits.\n     (active, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n+    /// Allows `c\"foo\"` literals.\n+    (active, c_str_literals, \"CURRENT_RUSTC_VERSION\", Some(105723), None),\n     /// Treat `extern \"C\"` function as nounwind.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics."}, {"sha": "1f08befb180c9e0a7246f517aff913f856d47af9", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -333,6 +333,7 @@ language_item_table! {\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n \n     String,                  sym::String,              string,                     Target::Struct,         GenericRequirement::None;\n+    CStr,                    sym::CStr,                c_str,                      Target::Struct,         GenericRequirement::None;\n }\n \n pub enum GenericRequirement {"}, {"sha": "4b8fc7303a20c0bb0adaa42303f4e4fbdd8f74fb", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -1300,6 +1300,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 opt_ty.unwrap_or_else(|| self.next_float_var())\n             }\n             ast::LitKind::Bool(_) => tcx.types.bool,\n+            ast::LitKind::CStr(_, _) => tcx.mk_imm_ref(\n+                tcx.lifetimes.re_static,\n+                tcx.type_of(tcx.require_lang_item(hir::LangItem::CStr, Some(lit.span)))\n+                    .skip_binder(),\n+            ),\n             ast::LitKind::Err => tcx.ty_error_misc(),\n         }\n     }"}, {"sha": "9d9f4ee13f402dc9c6374b8ca20cbd6b65e86204", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 48, "deletions": 28, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -9,11 +9,12 @@ use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_lint::LintStore;\n-use rustc_middle::ty;\n+use rustc_middle::{bug, ty};\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_query_impl::QueryCtxt;\n use rustc_query_system::query::print_query_stack;\n-use rustc_session::config::{self, CheckCfg, ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::config::{self, ErrorOutputType, Input, OutputFilenames};\n+use rustc_session::config::{CheckCfg, ExpectedValues};\n use rustc_session::lint;\n use rustc_session::parse::{CrateConfig, ParseSess};\n use rustc_session::Session;\n@@ -121,9 +122,9 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n /// Converts strings provided as `--check-cfg [specs]` into a `CheckCfg`.\n pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n     rustc_span::create_default_session_if_not_set_then(move |_| {\n-        let mut cfg = CheckCfg::default();\n+        let mut check_cfg = CheckCfg::default();\n \n-        'specs: for s in specs {\n+        for s in specs {\n             let sess = ParseSess::with_silent_emitter(Some(format!(\n                 \"this error occurred on the command line: `--check-cfg={s}`\"\n             )));\n@@ -137,76 +138,95 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                             concat!(\"invalid `--check-cfg` argument: `{}` (\", $reason, \")\"),\n                             s\n                         ),\n-                    );\n+                    )\n                 };\n             }\n \n+            let expected_error = || {\n+                error!(\n+                    \"expected `names(name1, name2, ... nameN)` or \\\n+                        `values(name, \\\"value1\\\", \\\"value2\\\", ... \\\"valueN\\\")`\"\n+                )\n+            };\n+\n             match maybe_new_parser_from_source_str(&sess, filename, s.to_string()) {\n                 Ok(mut parser) => match parser.parse_meta_item() {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n-                                let names_valid =\n-                                    cfg.names_valid.get_or_insert_with(|| FxHashSet::default());\n+                                check_cfg.exhaustive_names = true;\n                                 for arg in args {\n                                     if arg.is_word() && arg.ident().is_some() {\n                                         let ident = arg.ident().expect(\"multi-segment cfg key\");\n-                                        names_valid.insert(ident.name.to_string());\n+                                        check_cfg\n+                                            .expecteds\n+                                            .entry(ident.name.to_string())\n+                                            .or_insert(ExpectedValues::Any);\n                                     } else {\n                                         error!(\"`names()` arguments must be simple identifiers\");\n                                     }\n                                 }\n-                                continue 'specs;\n                             } else if meta_item.has_name(sym::values) {\n                                 if let Some((name, values)) = args.split_first() {\n                                     if name.is_word() && name.ident().is_some() {\n                                         let ident = name.ident().expect(\"multi-segment cfg key\");\n-                                        let ident_values = cfg\n-                                            .values_valid\n+                                        let expected_values = check_cfg\n+                                            .expecteds\n                                             .entry(ident.name.to_string())\n-                                            .or_insert_with(|| FxHashSet::default());\n+                                            .or_insert_with(|| {\n+                                                ExpectedValues::Some(FxHashSet::default())\n+                                            });\n+\n+                                        let ExpectedValues::Some(expected_values) = expected_values else {\n+                                            bug!(\"shoudn't be possible\")\n+                                        };\n \n                                         for val in values {\n                                             if let Some(LitKind::Str(s, _)) =\n                                                 val.lit().map(|lit| &lit.kind)\n                                             {\n-                                                ident_values.insert(s.to_string());\n+                                                expected_values.insert(Some(s.to_string()));\n                                             } else {\n                                                 error!(\n                                                     \"`values()` arguments must be string literals\"\n                                                 );\n                                             }\n                                         }\n \n-                                        continue 'specs;\n+                                        if values.is_empty() {\n+                                            expected_values.insert(None);\n+                                        }\n                                     } else {\n                                         error!(\n                                             \"`values()` first argument must be a simple identifier\"\n                                         );\n                                     }\n                                 } else if args.is_empty() {\n-                                    cfg.well_known_values = true;\n-                                    continue 'specs;\n+                                    check_cfg.exhaustive_values = true;\n+                                } else {\n+                                    expected_error();\n                                 }\n+                            } else {\n+                                expected_error();\n                             }\n+                        } else {\n+                            expected_error();\n                         }\n                     }\n-                    Ok(..) => {}\n-                    Err(err) => err.cancel(),\n+                    Ok(..) => expected_error(),\n+                    Err(err) => {\n+                        err.cancel();\n+                        expected_error();\n+                    }\n                 },\n-                Err(errs) => drop(errs),\n+                Err(errs) => {\n+                    drop(errs);\n+                    expected_error();\n+                }\n             }\n-\n-            error!(\n-                \"expected `names(name1, name2, ... nameN)` or \\\n-                `values(name, \\\"value1\\\", \\\"value2\\\", ... \\\"valueN\\\")`\"\n-            );\n         }\n \n-        if let Some(names_valid) = &mut cfg.names_valid {\n-            names_valid.extend(cfg.values_valid.keys().cloned());\n-        }\n-        cfg\n+        check_cfg\n     })\n }\n "}, {"sha": "c07dc19a0ac3ac2916caa6ff8d55ba81667bd294", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -186,12 +186,16 @@ pub enum LiteralKind {\n     Str { terminated: bool },\n     /// \"b\"abc\"\", \"b\"abc\"\n     ByteStr { terminated: bool },\n+    /// `c\"abc\"`, `c\"abc`\n+    CStr { terminated: bool },\n     /// \"r\"abc\"\", \"r#\"abc\"#\", \"r####\"ab\"###\"c\"####\", \"r#\"a\". `None` indicates\n     /// an invalid literal.\n     RawStr { n_hashes: Option<u8> },\n     /// \"br\"abc\"\", \"br#\"abc\"#\", \"br####\"ab\"###\"c\"####\", \"br#\"a\". `None`\n     /// indicates an invalid literal.\n     RawByteStr { n_hashes: Option<u8> },\n+    /// `cr\"abc\"`, \"cr#\"abc\"#\", `cr#\"a`. `None` indicates an invalid literal.\n+    RawCStr { n_hashes: Option<u8> },\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n@@ -357,39 +361,18 @@ impl Cursor<'_> {\n             },\n \n             // Byte literal, byte string literal, raw byte string literal or identifier.\n-            'b' => match (self.first(), self.second()) {\n-                ('\\'', _) => {\n-                    self.bump();\n-                    let terminated = self.single_quoted_string();\n-                    let suffix_start = self.pos_within_token();\n-                    if terminated {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = Byte { terminated };\n-                    Literal { kind, suffix_start }\n-                }\n-                ('\"', _) => {\n-                    self.bump();\n-                    let terminated = self.double_quoted_string();\n-                    let suffix_start = self.pos_within_token();\n-                    if terminated {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = ByteStr { terminated };\n-                    Literal { kind, suffix_start }\n-                }\n-                ('r', '\"') | ('r', '#') => {\n-                    self.bump();\n-                    let res = self.raw_double_quoted_string(2);\n-                    let suffix_start = self.pos_within_token();\n-                    if res.is_ok() {\n-                        self.eat_literal_suffix();\n-                    }\n-                    let kind = RawByteStr { n_hashes: res.ok() };\n-                    Literal { kind, suffix_start }\n-                }\n-                _ => self.ident_or_unknown_prefix(),\n-            },\n+            'b' => self.c_or_byte_string(\n+                |terminated| ByteStr { terminated },\n+                |n_hashes| RawByteStr { n_hashes },\n+                Some(|terminated| Byte { terminated }),\n+            ),\n+\n+            // c-string literal, raw c-string literal or identifier.\n+            'c' => self.c_or_byte_string(\n+                |terminated| CStr { terminated },\n+                |n_hashes| RawCStr { n_hashes },\n+                None,\n+            ),\n \n             // Identifier (this should be checked after other variant that can\n             // start as identifier).\n@@ -553,6 +536,47 @@ impl Cursor<'_> {\n         }\n     }\n \n+    fn c_or_byte_string(\n+        &mut self,\n+        mk_kind: impl FnOnce(bool) -> LiteralKind,\n+        mk_kind_raw: impl FnOnce(Option<u8>) -> LiteralKind,\n+        single_quoted: Option<fn(bool) -> LiteralKind>,\n+    ) -> TokenKind {\n+        match (self.first(), self.second(), single_quoted) {\n+            ('\\'', _, Some(mk_kind)) => {\n+                self.bump();\n+                let terminated = self.single_quoted_string();\n+                let suffix_start = self.pos_within_token();\n+                if terminated {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind(terminated);\n+                Literal { kind, suffix_start }\n+            }\n+            ('\"', _, _) => {\n+                self.bump();\n+                let terminated = self.double_quoted_string();\n+                let suffix_start = self.pos_within_token();\n+                if terminated {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind(terminated);\n+                Literal { kind, suffix_start }\n+            }\n+            ('r', '\"', _) | ('r', '#', _) => {\n+                self.bump();\n+                let res = self.raw_double_quoted_string(2);\n+                let suffix_start = self.pos_within_token();\n+                if res.is_ok() {\n+                    self.eat_literal_suffix();\n+                }\n+                let kind = mk_kind_raw(res.ok());\n+                Literal { kind, suffix_start }\n+            }\n+            _ => self.ident_or_unknown_prefix(),\n+        }\n+    }\n+\n     fn number(&mut self, first_digit: char) -> LiteralKind {\n         debug_assert!('0' <= self.prev() && self.prev() <= '9');\n         let mut base = Base::Decimal;"}, {"sha": "c9ad54d8d980609d15416e4bdcda83df88b3b3c5", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 176, "deletions": 102, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -86,10 +86,45 @@ where\n             let res = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n             callback(0..(src.len() - chars.as_str().len()), res);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n+        Mode::Str | Mode::ByteStr => unescape_str_common(src, mode, callback),\n+\n         Mode::RawStr | Mode::RawByteStr => {\n             unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n+        Mode::CStr | Mode::RawCStr => unreachable!(),\n+    }\n+}\n+\n+/// A unit within CStr. Must not be a nul character.\n+pub enum CStrUnit {\n+    Byte(u8),\n+    Char(char),\n+}\n+\n+impl From<u8> for CStrUnit {\n+    fn from(value: u8) -> Self {\n+        CStrUnit::Byte(value)\n+    }\n+}\n+\n+impl From<char> for CStrUnit {\n+    fn from(value: char) -> Self {\n+        CStrUnit::Char(value)\n+    }\n+}\n+\n+pub fn unescape_c_string<F>(src: &str, mode: Mode, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<CStrUnit, EscapeError>),\n+{\n+    if mode == Mode::RawCStr {\n+        unescape_raw_str_or_raw_byte_str(\n+            src,\n+            mode.characters_should_be_ascii(),\n+            &mut |r, result| callback(r, result.map(CStrUnit::Char)),\n+        );\n+    } else {\n+        unescape_str_common(src, mode, callback);\n     }\n }\n \n@@ -114,34 +149,69 @@ pub enum Mode {\n     ByteStr,\n     RawStr,\n     RawByteStr,\n+    CStr,\n+    RawCStr,\n }\n \n impl Mode {\n     pub fn in_double_quotes(self) -> bool {\n         match self {\n-            Mode::Str | Mode::ByteStr | Mode::RawStr | Mode::RawByteStr => true,\n+            Mode::Str\n+            | Mode::ByteStr\n+            | Mode::RawStr\n+            | Mode::RawByteStr\n+            | Mode::CStr\n+            | Mode::RawCStr => true,\n             Mode::Char | Mode::Byte => false,\n         }\n     }\n \n-    pub fn is_byte(self) -> bool {\n+    /// Non-byte literals should have `\\xXX` escapes that are within the ASCII range.\n+    pub fn ascii_escapes_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Char | Mode::Str | Mode::RawStr => true,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Whether characters within the literal must be within the ASCII range\n+    pub fn characters_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Byte literals do not allow unicode escape.\n+    pub fn is_unicode_escape_disallowed(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n-            Mode::Char | Mode::Str | Mode::RawStr => false,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    pub fn prefix_noraw(self) -> &'static str {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => \"b\",\n+            Mode::CStr | Mode::RawCStr => \"c\",\n+            Mode::Char | Mode::Str | Mode::RawStr => \"\",\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+fn scan_escape<T: From<u8> + From<char>>(\n+    chars: &mut Chars<'_>,\n+    mode: Mode,\n+) -> Result<T, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n     let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n-        '\"' => '\"',\n-        'n' => '\\n',\n-        'r' => '\\r',\n-        't' => '\\t',\n-        '\\\\' => '\\\\',\n-        '\\'' => '\\'',\n-        '0' => '\\0',\n+        '\"' => b'\"',\n+        'n' => b'\\n',\n+        'r' => b'\\r',\n+        't' => b'\\t',\n+        '\\\\' => b'\\\\',\n+        '\\'' => b'\\'',\n+        '0' => b'\\0',\n \n         'x' => {\n             // Parse hexadecimal character code.\n@@ -154,76 +224,78 @@ fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError\n \n             let value = hi * 16 + lo;\n \n-            // For a non-byte literal verify that it is within ASCII range.\n-            if !is_byte && !is_ascii(value) {\n+            if mode.ascii_escapes_should_be_ascii() && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n-            let value = value as u8;\n \n-            value as char\n+            value as u8\n         }\n \n-        'u' => {\n-            // We've parsed '\\u', now we have to parse '{..}'.\n+        'u' => return scan_unicode(chars, mode.is_unicode_escape_disallowed()).map(Into::into),\n+        _ => return Err(EscapeError::InvalidEscape),\n+    };\n+    Ok(res.into())\n+}\n+\n+fn scan_unicode(\n+    chars: &mut Chars<'_>,\n+    is_unicode_escape_disallowed: bool,\n+) -> Result<char, EscapeError> {\n+    // We've parsed '\\u', now we have to parse '{..}'.\n \n-            if chars.next() != Some('{') {\n-                return Err(EscapeError::NoBraceInUnicodeEscape);\n-            }\n+    if chars.next() != Some('{') {\n+        return Err(EscapeError::NoBraceInUnicodeEscape);\n+    }\n \n-            // First character must be a hexadecimal digit.\n-            let mut n_digits = 1;\n-            let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n-                '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n-                '}' => return Err(EscapeError::EmptyUnicodeEscape),\n-                c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n-            };\n-\n-            // First character is valid, now parse the rest of the number\n-            // and closing brace.\n-            loop {\n-                match chars.next() {\n-                    None => return Err(EscapeError::UnclosedUnicodeEscape),\n-                    Some('_') => continue,\n-                    Some('}') => {\n-                        if n_digits > 6 {\n-                            return Err(EscapeError::OverlongUnicodeEscape);\n-                        }\n-\n-                        // Incorrect syntax has higher priority for error reporting\n-                        // than unallowed value for a literal.\n-                        if is_byte {\n-                            return Err(EscapeError::UnicodeEscapeInByte);\n-                        }\n-\n-                        break std::char::from_u32(value).ok_or_else(|| {\n-                            if value > 0x10FFFF {\n-                                EscapeError::OutOfRangeUnicodeEscape\n-                            } else {\n-                                EscapeError::LoneSurrogateUnicodeEscape\n-                            }\n-                        })?;\n-                    }\n-                    Some(c) => {\n-                        let digit: u32 =\n-                            c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n-                        n_digits += 1;\n-                        if n_digits > 6 {\n-                            // Stop updating value since we're sure that it's incorrect already.\n-                            continue;\n-                        }\n-                        value = value * 16 + digit;\n+    // First character must be a hexadecimal digit.\n+    let mut n_digits = 1;\n+    let mut value: u32 = match chars.next().ok_or(EscapeError::UnclosedUnicodeEscape)? {\n+        '_' => return Err(EscapeError::LeadingUnderscoreUnicodeEscape),\n+        '}' => return Err(EscapeError::EmptyUnicodeEscape),\n+        c => c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?,\n+    };\n+\n+    // First character is valid, now parse the rest of the number\n+    // and closing brace.\n+    loop {\n+        match chars.next() {\n+            None => return Err(EscapeError::UnclosedUnicodeEscape),\n+            Some('_') => continue,\n+            Some('}') => {\n+                if n_digits > 6 {\n+                    return Err(EscapeError::OverlongUnicodeEscape);\n+                }\n+\n+                // Incorrect syntax has higher priority for error reporting\n+                // than unallowed value for a literal.\n+                if is_unicode_escape_disallowed {\n+                    return Err(EscapeError::UnicodeEscapeInByte);\n+                }\n+\n+                break std::char::from_u32(value).ok_or_else(|| {\n+                    if value > 0x10FFFF {\n+                        EscapeError::OutOfRangeUnicodeEscape\n+                    } else {\n+                        EscapeError::LoneSurrogateUnicodeEscape\n                     }\n-                };\n+                });\n             }\n-        }\n-        _ => return Err(EscapeError::InvalidEscape),\n-    };\n-    Ok(res)\n+            Some(c) => {\n+                let digit: u32 = c.to_digit(16).ok_or(EscapeError::InvalidCharInUnicodeEscape)?;\n+                n_digits += 1;\n+                if n_digits > 6 {\n+                    // Stop updating value since we're sure that it's incorrect already.\n+                    continue;\n+                }\n+                value = value * 16 + digit;\n+            }\n+        };\n+    }\n }\n \n #[inline]\n-fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n-    if is_byte && !c.is_ascii() {\n+fn ascii_check(c: char, characters_should_be_ascii: bool) -> Result<char, EscapeError> {\n+    if characters_should_be_ascii && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n@@ -234,7 +306,7 @@ fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match c {\n-        '\\\\' => scan_escape(chars, is_byte),\n+        '\\\\' => scan_escape(chars, if is_byte { Mode::Byte } else { Mode::Char }),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n         _ => ascii_check(c, is_byte),\n@@ -247,9 +319,9 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, E\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n+fn unescape_str_common<F, T: From<u8> + From<char>>(src: &str, mode: Mode, callback: &mut F)\n where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+    F: FnMut(Range<usize>, Result<T, EscapeError>),\n {\n     let mut chars = src.chars();\n \n@@ -266,47 +338,49 @@ where\n                         // if unescaped '\\' character is followed by '\\n'.\n                         // For details see [Rust language reference]\n                         // (https://doc.rust-lang.org/reference/tokens.html#string-literals).\n-                        skip_ascii_whitespace(&mut chars, start, callback);\n+                        skip_ascii_whitespace(&mut chars, start, &mut |range, err| {\n+                            callback(range, Err(err))\n+                        });\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, is_byte),\n+                    _ => scan_escape::<T>(&mut chars, mode),\n                 }\n             }\n-            '\\n' => Ok('\\n'),\n-            '\\t' => Ok('\\t'),\n+            '\\n' => Ok(b'\\n'.into()),\n+            '\\t' => Ok(b'\\t'.into()),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(c, is_byte),\n+            _ => ascii_check(c, mode.characters_should_be_ascii()).map(Into::into),\n         };\n         let end = src.len() - chars.as_str().len();\n-        callback(start..end, res);\n+        callback(start..end, res.map(Into::into));\n     }\n+}\n \n-    fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n-    where\n-        F: FnMut(Range<usize>, Result<char, EscapeError>),\n-    {\n-        let tail = chars.as_str();\n-        let first_non_space = tail\n-            .bytes()\n-            .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n-            .unwrap_or(tail.len());\n-        if tail[1..first_non_space].contains('\\n') {\n-            // The +1 accounts for the escaping slash.\n-            let end = start + first_non_space + 1;\n-            callback(start..end, Err(EscapeError::MultipleSkippedLinesWarning));\n-        }\n-        let tail = &tail[first_non_space..];\n-        if let Some(c) = tail.chars().nth(0) {\n-            if c.is_whitespace() {\n-                // For error reporting, we would like the span to contain the character that was not\n-                // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n-                let end = start + first_non_space + c.len_utf8() + 1;\n-                callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));\n-            }\n+fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, EscapeError),\n+{\n+    let tail = chars.as_str();\n+    let first_non_space = tail\n+        .bytes()\n+        .position(|b| b != b' ' && b != b'\\t' && b != b'\\n' && b != b'\\r')\n+        .unwrap_or(tail.len());\n+    if tail[1..first_non_space].contains('\\n') {\n+        // The +1 accounts for the escaping slash.\n+        let end = start + first_non_space + 1;\n+        callback(start..end, EscapeError::MultipleSkippedLinesWarning);\n+    }\n+    let tail = &tail[first_non_space..];\n+    if let Some(c) = tail.chars().nth(0) {\n+        if c.is_whitespace() {\n+            // For error reporting, we would like the span to contain the character that was not\n+            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n+            let end = start + first_non_space + c.len_utf8() + 1;\n+            callback(start..end, EscapeError::UnskippedWhitespaceWarning);\n         }\n-        *chars = tail.chars();\n     }\n+    *chars = tail.chars();\n }\n \n /// Takes a contents of a string literal (without quotes) and produces a"}, {"sha": "010526988506d2c721f36d6993586e687d6dbb65", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -63,6 +63,7 @@ use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n@@ -3306,16 +3307,15 @@ impl EarlyLintPass for UnexpectedCfgs {\n         let cfg = &cx.sess().parse_sess.config;\n         let check_cfg = &cx.sess().parse_sess.check_config;\n         for &(name, value) in cfg {\n-            if let Some(names_valid) = &check_cfg.names_valid && !names_valid.contains(&name){\n-                cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName {\n-                    name,\n-                });\n-            }\n-            if let Some(value) = value && let Some(values) = check_cfg.values_valid.get(&name) && !values.contains(&value) {\n-                cx.emit_lint(\n-                    UNEXPECTED_CFGS,\n-                    BuiltinUnexpectedCliConfigValue { name, value },\n-                );\n+            match check_cfg.expecteds.get(&name) {\n+                Some(ExpectedValues::Some(values)) if !values.contains(&value) => {\n+                    let value = value.unwrap_or(kw::Empty);\n+                    cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigValue { name, value });\n+                }\n+                None if check_cfg.exhaustive_names => {\n+                    cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName { name });\n+                }\n+                _ => { /* expected */ }\n             }\n         }\n     }"}, {"sha": "53d7cf74cde53db24caf9e5dd05b71b97eae28f3", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -36,6 +36,7 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, print::Printer, subst::GenericArg, RegisteredTools, Ty, TyCtxt};\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintExpectationId};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n@@ -768,22 +769,52 @@ pub trait LintContext: Sized {\n                     db.help(help);\n                     db.note(\"see the asm section of Rust By Example <https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels> for more information\");\n                 },\n-                BuiltinLintDiagnostics::UnexpectedCfg((name, name_span), None) => {\n-                    let Some(names_valid) = &sess.parse_sess.check_config.names_valid else {\n-                        bug!(\"it shouldn't be possible to have a diagnostic on a name if name checking is not enabled\");\n-                    };\n-                    let possibilities: Vec<Symbol> = names_valid.iter().map(|s| *s).collect();\n+                BuiltinLintDiagnostics::UnexpectedCfgName((name, name_span), value) => {\n+                    let possibilities: Vec<Symbol> = sess.parse_sess.check_config.expecteds.keys().map(|s| *s).collect();\n \n                     // Suggest the most probable if we found one\n                     if let Some(best_match) = find_best_match_for_name(&possibilities, name, None) {\n-                        db.span_suggestion(name_span, \"did you mean\", best_match, Applicability::MaybeIncorrect);\n+                        if let Some(ExpectedValues::Some(best_match_values)) =\n+                            sess.parse_sess.check_config.expecteds.get(&best_match) {\n+                            let mut possibilities = best_match_values.iter()\n+                                .flatten()\n+                                .map(Symbol::as_str)\n+                                .collect::<Vec<_>>();\n+                            possibilities.sort();\n+\n+                            if let Some((value, value_span)) = value {\n+                                if best_match_values.contains(&Some(value)) {\n+                                    db.span_suggestion(name_span, \"there is a config with a similar name and value\", best_match, Applicability::MaybeIncorrect);\n+                                } else if best_match_values.contains(&None) {\n+                                    db.span_suggestion(name_span.to(value_span), \"there is a config with a similar name and no value\", best_match, Applicability::MaybeIncorrect);\n+                                } else if let Some(first_value) = possibilities.first() {\n+                                    db.span_suggestion(name_span.to(value_span), \"there is a config with a similar name and different values\", format!(\"{best_match} = \\\"{first_value}\\\"\"), Applicability::MaybeIncorrect);\n+                                } else {\n+                                    db.span_suggestion(name_span.to(value_span), \"there is a config with a similar name and different values\", best_match, Applicability::MaybeIncorrect);\n+                                };\n+                            } else {\n+                                db.span_suggestion(name_span, \"there is a config with a similar name\", best_match, Applicability::MaybeIncorrect);\n+                            }\n+\n+                            if !possibilities.is_empty() {\n+                                let possibilities = possibilities.join(\"`, `\");\n+                                db.help(format!(\"expected values for `{best_match}` are: `{possibilities}`\"));\n+                            }\n+                        } else {\n+                            db.span_suggestion(name_span, \"there is a config with a similar name\", best_match, Applicability::MaybeIncorrect);\n+                        }\n                     }\n                 },\n-                BuiltinLintDiagnostics::UnexpectedCfg((name, name_span), Some((value, value_span))) => {\n-                    let Some(values) = &sess.parse_sess.check_config.values_valid.get(&name) else {\n+                BuiltinLintDiagnostics::UnexpectedCfgValue((name, name_span), value) => {\n+                    let Some(ExpectedValues::Some(values)) = &sess.parse_sess.check_config.expecteds.get(&name) else {\n                         bug!(\"it shouldn't be possible to have a diagnostic on a value whose name is not in values\");\n                     };\n-                    let possibilities: Vec<Symbol> = values.iter().map(|&s| s).collect();\n+                    let mut have_none_possibility = false;\n+                    let possibilities: Vec<Symbol> = values.iter()\n+                        .inspect(|a| have_none_possibility |= a.is_none())\n+                        .copied()\n+                        .flatten()\n+                        .collect();\n \n                     // Show the full list if all possible values for a given name, but don't do it\n                     // for names as the possibilities could be very long\n@@ -792,17 +823,24 @@ pub trait LintContext: Sized {\n                             let mut possibilities = possibilities.iter().map(Symbol::as_str).collect::<Vec<_>>();\n                             possibilities.sort();\n \n-                            let possibilities = possibilities.join(\", \");\n-                            db.note(format!(\"expected values for `{name}` are: {possibilities}\"));\n+                            let possibilities = possibilities.join(\"`, `\");\n+                            let none = if have_none_possibility { \"(none), \" } else { \"\" };\n+\n+                            db.note(format!(\"expected values for `{name}` are: {none}`{possibilities}`\"));\n                         }\n \n-                        // Suggest the most probable if we found one\n-                        if let Some(best_match) = find_best_match_for_name(&possibilities, value, None) {\n-                            db.span_suggestion(value_span, \"did you mean\", format!(\"\\\"{best_match}\\\"\"), Applicability::MaybeIncorrect);\n+                        if let Some((value, value_span)) = value {\n+                            // Suggest the most probable if we found one\n+                            if let Some(best_match) = find_best_match_for_name(&possibilities, value, None) {\n+                                db.span_suggestion(value_span, \"there is a expected value with a similar name\", format!(\"\\\"{best_match}\\\"\"), Applicability::MaybeIncorrect);\n+\n+                            }\n+                        } else if let &[first_possibility] = &possibilities[..] {\n+                            db.span_suggestion(name_span.shrink_to_hi(), \"specify a config value\", format!(\" = \\\"{first_possibility}\\\"\"), Applicability::MaybeIncorrect);\n                         }\n-                    } else {\n+                    } else if have_none_possibility {\n                         db.note(format!(\"no expected value for `{name}`\"));\n-                        if name != sym::feature {\n+                        if let Some((_value, value_span)) = value {\n                             db.span_suggestion(name_span.shrink_to_hi().to(value_span), \"remove the value\", \"\", Applicability::MaybeIncorrect);\n                         }\n                     }"}, {"sha": "e27e322db88581a27bb1b917804510ed43877b5c", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -496,7 +496,8 @@ pub enum BuiltinLintDiagnostics {\n     BreakWithLabelAndLoop(Span),\n     NamedAsmLabel(String),\n     UnicodeTextFlow(Span, String),\n-    UnexpectedCfg((Symbol, Span), Option<(Symbol, Span)>),\n+    UnexpectedCfgName((Symbol, Span), Option<(Symbol, Span)>),\n+    UnexpectedCfgValue((Symbol, Span), Option<(Symbol, Span)>),\n     DeprecatedWhereclauseLocation(Span, String),\n     SingleUseLifetime {\n         /// Span of the parameter which declares this lifetime."}, {"sha": "e88a3cdf620d1a9e9ebdd64d401781de5c713e8d", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -307,7 +307,7 @@ static size_t getLongestEntryLength(ArrayRef<KV> Table) {\n   return MaxLen;\n }\n \n-extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM) {\n+extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM, const char* TargetCPU) {\n   const TargetMachine *Target = unwrap(TM);\n   const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n   const Triple::ArchType HostArch = Triple(sys::getDefaultTargetTriple()).getArch();\n@@ -323,9 +323,18 @@ extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM) {\n     printf(\"    %-*s - Select the CPU of the current host (currently %.*s).\\n\",\n       MaxCPULen, \"native\", (int)HostCPU.size(), HostCPU.data());\n   }\n-  for (auto &CPU : CPUTable)\n-    printf(\"    %-*s\\n\", MaxCPULen, CPU.Key);\n-  printf(\"\\n\");\n+  for (auto &CPU : CPUTable) {\n+    // Compare cpu against current target to label the default\n+    if (strcmp(CPU.Key, TargetCPU) == 0) {\n+      printf(\"    %-*s - This is the default target CPU\"\n+      \" for the current build target (currently %s).\",\n+        MaxCPULen, CPU.Key, Target->getTargetTriple().str().c_str());\n+    }\n+    else {\n+      printf(\"    %-*s\", MaxCPULen, CPU.Key);\n+    }\n+    printf(\"\\n\");\n+  }\n }\n \n extern \"C\" size_t LLVMRustGetTargetFeaturesCount(LLVMTargetMachineRef TM) {"}, {"sha": "59549435233c53dad8d2cc84caa85dc35ed927a3", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -146,6 +146,12 @@ pub(crate) fn lit_to_mir_constant<'tcx>(\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::from_pointer(id.into(), &tcx))\n         }\n+        (ast::LitKind::CStr(data, _), ty::Ref(_, inner_ty, _)) if matches!(inner_ty.kind(), ty::Adt(def, _) if Some(def.did()) == tcx.lang_items().c_str()) =>\n+        {\n+            let allocation = Allocation::from_bytes_byte_aligned_immutable(data as &[u8]);\n+            let allocation = tcx.mk_const_alloc(allocation);\n+            ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n+        }\n         (ast::LitKind::Byte(n), ty::Uint(ty::UintTy::U8)) => {\n             ConstValue::Scalar(Scalar::from_uint(*n, Size::from_bytes(1)))\n         }"}, {"sha": "51e904890028a0e3a2d955e586af76d0344ff6d1", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -1,3 +1,5 @@\n+use std::ops::Range;\n+\n use crate::errors;\n use crate::lexer::unicode_chars::UNICODE_ARRAY;\n use crate::make_unclosed_delims_error;\n@@ -6,7 +8,7 @@ use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n use rustc_errors::{error_code, Applicability, Diagnostic, DiagnosticBuilder, StashKey};\n-use rustc_lexer::unescape::{self, Mode};\n+use rustc_lexer::unescape::{self, EscapeError, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n use rustc_session::lint::builtin::{\n@@ -204,6 +206,9 @@ impl<'a> StringReader<'a> {\n                 rustc_lexer::TokenKind::Literal { kind, suffix_start } => {\n                     let suffix_start = start + BytePos(suffix_start);\n                     let (kind, symbol) = self.cook_lexer_literal(start, suffix_start, kind);\n+                    if let token::LitKind::CStr | token::LitKind::CStrRaw(_) = kind {\n+                        self.sess.gated_spans.gate(sym::c_str_literals, self.mk_sp(start, self.pos));\n+                    }\n                     let suffix = if suffix_start < self.pos {\n                         let string = self.str_from(suffix_start);\n                         if string == \"_\" {\n@@ -415,6 +420,16 @@ impl<'a> StringReader<'a> {\n                 }\n                 self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n+            rustc_lexer::LiteralKind::CStr { terminated } => {\n+                if !terminated {\n+                    self.sess.span_diagnostic.span_fatal_with_code(\n+                        self.mk_sp(start + BytePos(1), end),\n+                        \"unterminated C string\",\n+                        error_code!(E0767),\n+                    )\n+                }\n+                self.cook_c_string(token::CStr, Mode::CStr, start, end, 2, 1) // c\" \"\n+            }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n@@ -433,6 +448,15 @@ impl<'a> StringReader<'a> {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n+            rustc_lexer::LiteralKind::RawCStr { n_hashes } => {\n+                if let Some(n_hashes) = n_hashes {\n+                    let n = u32::from(n_hashes);\n+                    let kind = token::CStrRaw(n_hashes);\n+                    self.cook_c_string(kind, Mode::RawCStr, start, end, 3 + n, 1 + n) // cr##\" \"##\n+                } else {\n+                    self.report_raw_str_error(start, 2);\n+                }\n+            }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n                 if empty_int {\n                     let span = self.mk_sp(start, end);\n@@ -648,20 +672,21 @@ impl<'a> StringReader<'a> {\n         self.sess.emit_fatal(errors::TooManyHashes { span: self.mk_sp(start, self.pos), num });\n     }\n \n-    fn cook_quoted(\n+    fn cook_common(\n         &self,\n         kind: token::LitKind,\n         mode: Mode,\n         start: BytePos,\n         end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n+        unescape: fn(&str, Mode, &mut dyn FnMut(Range<usize>, Result<(), EscapeError>)),\n     ) -> (token::LitKind, Symbol) {\n         let mut has_fatal_err = false;\n         let content_start = start + BytePos(prefix_len);\n         let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n-        unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n+        unescape(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n                 let span_with_quotes = self.mk_sp(start, end);\n@@ -692,6 +717,38 @@ impl<'a> StringReader<'a> {\n             (token::Err, self.symbol_from_to(start, end))\n         }\n     }\n+\n+    fn cook_quoted(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_literal(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n+    }\n+\n+    fn cook_c_string(\n+        &self,\n+        kind: token::LitKind,\n+        mode: Mode,\n+        start: BytePos,\n+        end: BytePos,\n+        prefix_len: u32,\n+        postfix_len: u32,\n+    ) -> (token::LitKind, Symbol) {\n+        self.cook_common(kind, mode, start, end, prefix_len, postfix_len, |src, mode, callback| {\n+            unescape::unescape_c_string(src, mode, &mut |span, result| {\n+                callback(span, result.map(drop))\n+            })\n+        })\n+    }\n }\n \n pub fn nfc_normalize(string: &str) -> Symbol {"}, {"sha": "eb9625f923ab95e46771d7123d2f71a0c3c01476", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -78,8 +78,7 @@ pub(crate) fn emit_unescape_error(\n                 }\n             };\n             let sugg = sugg.unwrap_or_else(|| {\n-                let is_byte = mode.is_byte();\n-                let prefix = if is_byte { \"b\" } else { \"\" };\n+                let prefix = mode.prefix_noraw();\n                 let mut escaped = String::with_capacity(lit.len());\n                 let mut chrs = lit.chars().peekable();\n                 while let Some(first) = chrs.next() {\n@@ -97,7 +96,11 @@ pub(crate) fn emit_unescape_error(\n                     };\n                 }\n                 let sugg = format!(\"{prefix}\\\"{escaped}\\\"\");\n-                MoreThanOneCharSugg::Quotes { span: span_with_quotes, is_byte, sugg }\n+                MoreThanOneCharSugg::Quotes {\n+                    span: span_with_quotes,\n+                    is_byte: mode == Mode::Byte,\n+                    sugg,\n+                }\n             });\n             handler.emit_err(UnescapeError::MoreThanOneChar {\n                 span: span_with_quotes,\n@@ -112,7 +115,7 @@ pub(crate) fn emit_unescape_error(\n                 char_span,\n                 escaped_sugg: c.escape_default().to_string(),\n                 escaped_msg: escaped_char(c),\n-                byte: mode.is_byte(),\n+                byte: mode == Mode::Byte,\n             });\n         }\n         EscapeError::BareCarriageReturn => {\n@@ -126,12 +129,15 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::InvalidEscape => {\n             let (c, span) = last_char();\n \n-            let label =\n-                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+            let label = if mode == Mode::Byte || mode == Mode::ByteStr {\n+                \"unknown byte escape\"\n+            } else {\n+                \"unknown character escape\"\n+            };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_byte() {\n+            if c == '{' || c == '}' && matches!(mode, Mode::Str | Mode::RawStr) {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -141,7 +147,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_byte() {\n+                if mode == Mode::Str || mode == Mode::Char {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\","}, {"sha": "61396ee0d4aec1bc7fef1a90249f09010c482be6", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -1870,6 +1870,7 @@ impl<'a> Parser<'a> {\n         let recovered = self.recover_after_dot();\n         let token = recovered.as_ref().unwrap_or(&self.token);\n         let span = token.span;\n+\n         token::Lit::from_token(token).map(|token_lit| {\n             self.bump();\n             (token_lit, span)"}, {"sha": "a8fe560d1a760b51693f7ed8dc26089c66c476ac", "filename": "compiler/rustc_session/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_session%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_session%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fmessages.ftl?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -101,3 +101,5 @@ session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n     .help = valid widths are 8, 16, 32, 64 and 128\n \n session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}\n+\n+session_nul_in_c_str = null characters in C string literals are not supported"}, {"sha": "18917120256e0f643b9736d539ca2e14192da00c", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 125, "deletions": 108, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -1064,37 +1064,76 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> CrateConfig\n \n /// The parsed `--check-cfg` options\n pub struct CheckCfg<T = String> {\n-    /// The set of all `names()`, if None no name checking is performed\n-    pub names_valid: Option<FxHashSet<T>>,\n+    /// Is well known names activated\n+    pub exhaustive_names: bool,\n     /// Is well known values activated\n-    pub well_known_values: bool,\n-    /// The set of all `values()`\n-    pub values_valid: FxHashMap<T, FxHashSet<T>>,\n+    pub exhaustive_values: bool,\n+    /// All the expected values for a config name\n+    pub expecteds: FxHashMap<T, ExpectedValues<T>>,\n }\n \n impl<T> Default for CheckCfg<T> {\n     fn default() -> Self {\n         CheckCfg {\n-            names_valid: Default::default(),\n-            values_valid: Default::default(),\n-            well_known_values: false,\n+            exhaustive_names: false,\n+            exhaustive_values: false,\n+            expecteds: FxHashMap::default(),\n         }\n     }\n }\n \n impl<T> CheckCfg<T> {\n-    fn map_data<O: Eq + Hash>(&self, f: impl Fn(&T) -> O) -> CheckCfg<O> {\n+    fn map_data<O: Eq + Hash>(self, f: impl Fn(T) -> O) -> CheckCfg<O> {\n         CheckCfg {\n-            names_valid: self\n-                .names_valid\n-                .as_ref()\n-                .map(|names_valid| names_valid.iter().map(|a| f(a)).collect()),\n-            values_valid: self\n-                .values_valid\n-                .iter()\n-                .map(|(a, b)| (f(a), b.iter().map(|b| f(b)).collect()))\n+            exhaustive_names: self.exhaustive_names,\n+            exhaustive_values: self.exhaustive_values,\n+            expecteds: self\n+                .expecteds\n+                .into_iter()\n+                .map(|(name, values)| {\n+                    (\n+                        f(name),\n+                        match values {\n+                            ExpectedValues::Some(values) => ExpectedValues::Some(\n+                                values.into_iter().map(|b| b.map(|b| f(b))).collect(),\n+                            ),\n+                            ExpectedValues::Any => ExpectedValues::Any,\n+                        },\n+                    )\n+                })\n                 .collect(),\n-            well_known_values: self.well_known_values,\n+        }\n+    }\n+}\n+\n+pub enum ExpectedValues<T> {\n+    Some(FxHashSet<Option<T>>),\n+    Any,\n+}\n+\n+impl<T: Eq + Hash> ExpectedValues<T> {\n+    fn insert(&mut self, value: T) -> bool {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.insert(Some(value)),\n+            ExpectedValues::Any => false,\n+        }\n+    }\n+}\n+\n+impl<T: Eq + Hash> Extend<T> for ExpectedValues<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.extend(iter.into_iter().map(Some)),\n+            ExpectedValues::Any => {}\n+        }\n+    }\n+}\n+\n+impl<'a, T: Eq + Hash + Copy + 'a> Extend<&'a T> for ExpectedValues<T> {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.extend(iter.into_iter().map(|a| Some(*a))),\n+            ExpectedValues::Any => {}\n         }\n     }\n }\n@@ -1103,58 +1142,27 @@ impl<T> CheckCfg<T> {\n /// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n /// but the symbol interner is not yet set up then, so we must convert it later.\n pub fn to_crate_check_config(cfg: CheckCfg) -> CrateCheckConfig {\n-    cfg.map_data(|s| Symbol::intern(s))\n+    cfg.map_data(|s| Symbol::intern(&s))\n }\n \n impl CrateCheckConfig {\n-    /// Fills a `CrateCheckConfig` with well-known configuration names.\n-    fn fill_well_known_names(&mut self) {\n-        // NOTE: This should be kept in sync with `default_configuration` and\n-        // `fill_well_known_values`\n-        const WELL_KNOWN_NAMES: &[Symbol] = &[\n-            // rustc\n-            sym::unix,\n-            sym::windows,\n-            sym::target_os,\n-            sym::target_family,\n-            sym::target_arch,\n-            sym::target_endian,\n-            sym::target_pointer_width,\n-            sym::target_env,\n-            sym::target_abi,\n-            sym::target_vendor,\n-            sym::target_thread_local,\n-            sym::target_has_atomic_load_store,\n-            sym::target_has_atomic,\n-            sym::target_has_atomic_equal_alignment,\n-            sym::target_feature,\n-            sym::panic,\n-            sym::sanitize,\n-            sym::debug_assertions,\n-            sym::proc_macro,\n-            sym::test,\n-            sym::feature,\n-            // rustdoc\n-            sym::doc,\n-            sym::doctest,\n-            // miri\n-            sym::miri,\n-        ];\n-\n-        // We only insert well-known names if `names()` was activated\n-        if let Some(names_valid) = &mut self.names_valid {\n-            names_valid.extend(WELL_KNOWN_NAMES);\n-        }\n-    }\n-\n-    /// Fills a `CrateCheckConfig` with well-known configuration values.\n-    fn fill_well_known_values(&mut self, current_target: &Target) {\n-        if !self.well_known_values {\n+    pub fn fill_well_known(&mut self, current_target: &Target) {\n+        if !self.exhaustive_values && !self.exhaustive_names {\n             return;\n         }\n \n-        // NOTE: This should be kept in sync with `default_configuration` and\n-        // `fill_well_known_names`\n+        let no_values = || {\n+            let mut values = FxHashSet::default();\n+            values.insert(None);\n+            ExpectedValues::Some(values)\n+        };\n+\n+        let empty_values = || {\n+            let values = FxHashSet::default();\n+            ExpectedValues::Some(values)\n+        };\n+\n+        // NOTE: This should be kept in sync with `default_configuration`\n \n         let panic_values = &PanicStrategy::all();\n \n@@ -1174,6 +1182,9 @@ impl CrateCheckConfig {\n         // Unknown possible values:\n         //  - `feature`\n         //  - `target_feature`\n+        for name in [sym::feature, sym::target_feature] {\n+            self.expecteds.entry(name).or_insert(ExpectedValues::Any);\n+        }\n \n         // No-values\n         for name in [\n@@ -1187,20 +1198,23 @@ impl CrateCheckConfig {\n             sym::debug_assertions,\n             sym::target_thread_local,\n         ] {\n-            self.values_valid.entry(name).or_default();\n+            self.expecteds.entry(name).or_insert_with(no_values);\n         }\n \n         // Pre-defined values\n-        self.values_valid.entry(sym::panic).or_default().extend(panic_values);\n-        self.values_valid.entry(sym::sanitize).or_default().extend(sanitize_values);\n-        self.values_valid.entry(sym::target_has_atomic).or_default().extend(atomic_values);\n-        self.values_valid\n+        self.expecteds.entry(sym::panic).or_insert_with(empty_values).extend(panic_values);\n+        self.expecteds.entry(sym::sanitize).or_insert_with(empty_values).extend(sanitize_values);\n+        self.expecteds\n+            .entry(sym::target_has_atomic)\n+            .or_insert_with(no_values)\n+            .extend(atomic_values);\n+        self.expecteds\n             .entry(sym::target_has_atomic_load_store)\n-            .or_default()\n+            .or_insert_with(no_values)\n             .extend(atomic_values);\n-        self.values_valid\n+        self.expecteds\n             .entry(sym::target_has_atomic_equal_alignment)\n-            .or_default()\n+            .or_insert_with(no_values)\n             .extend(atomic_values);\n \n         // Target specific values\n@@ -1218,47 +1232,50 @@ impl CrateCheckConfig {\n \n             // Initialize (if not already initialized)\n             for &e in VALUES {\n-                self.values_valid.entry(e).or_default();\n+                let entry = self.expecteds.entry(e);\n+                if !self.exhaustive_values {\n+                    entry.or_insert(ExpectedValues::Any);\n+                } else {\n+                    entry.or_insert_with(empty_values);\n+                }\n             }\n \n-            // Get all values map at once otherwise it would be costly.\n-            // (8 values * 220 targets ~= 1760 times, at the time of writing this comment).\n-            let [\n-                values_target_os,\n-                values_target_family,\n-                values_target_arch,\n-                values_target_endian,\n-                values_target_env,\n-                values_target_abi,\n-                values_target_vendor,\n-                values_target_pointer_width,\n-            ] = self\n-                .values_valid\n-                .get_many_mut(VALUES)\n-                .expect(\"unable to get all the check-cfg values buckets\");\n-\n-            for target in TARGETS\n-                .iter()\n-                .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n-                .chain(iter::once(current_target.clone()))\n-            {\n-                values_target_os.insert(Symbol::intern(&target.options.os));\n-                values_target_family\n-                    .extend(target.options.families.iter().map(|family| Symbol::intern(family)));\n-                values_target_arch.insert(Symbol::intern(&target.arch));\n-                values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n-                values_target_env.insert(Symbol::intern(&target.options.env));\n-                values_target_abi.insert(Symbol::intern(&target.options.abi));\n-                values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n-                values_target_pointer_width.insert(sym::integer(target.pointer_width));\n+            if self.exhaustive_values {\n+                // Get all values map at once otherwise it would be costly.\n+                // (8 values * 220 targets ~= 1760 times, at the time of writing this comment).\n+                let [\n+                    values_target_os,\n+                    values_target_family,\n+                    values_target_arch,\n+                    values_target_endian,\n+                    values_target_env,\n+                    values_target_abi,\n+                    values_target_vendor,\n+                    values_target_pointer_width,\n+                ] = self\n+                    .expecteds\n+                    .get_many_mut(VALUES)\n+                    .expect(\"unable to get all the check-cfg values buckets\");\n+\n+                for target in TARGETS\n+                    .iter()\n+                    .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n+                    .chain(iter::once(current_target.clone()))\n+                {\n+                    values_target_os.insert(Symbol::intern(&target.options.os));\n+                    values_target_family.extend(\n+                        target.options.families.iter().map(|family| Symbol::intern(family)),\n+                    );\n+                    values_target_arch.insert(Symbol::intern(&target.arch));\n+                    values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n+                    values_target_env.insert(Symbol::intern(&target.options.env));\n+                    values_target_abi.insert(Symbol::intern(&target.options.abi));\n+                    values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n+                    values_target_pointer_width.insert(sym::integer(target.pointer_width));\n+                }\n             }\n         }\n     }\n-\n-    pub fn fill_well_known(&mut self, current_target: &Target) {\n-        self.fill_well_known_names();\n-        self.fill_well_known_values(current_target);\n-    }\n }\n \n pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateConfig {"}, {"sha": "546c0fa8e03e358484e7b59c2c9fd84fab47c37e", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::token;\n use rustc_ast::util::literal::LitError;\n use rustc_errors::{error_code, DiagnosticMessage, EmissionGuarantee, IntoDiagnostic, MultiSpan};\n use rustc_macros::Diagnostic;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{BytePos, Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n \n #[derive(Diagnostic)]\n@@ -323,6 +323,13 @@ pub(crate) struct BinaryFloatLiteralNotSupported {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(session_nul_in_c_str)]\n+pub(crate) struct NulInCStr {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span: Span) {\n     // Checks if `s` looks like i32 or u1234 etc.\n     fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n@@ -401,6 +408,12 @@ pub fn report_lit_error(sess: &ParseSess, err: LitError, lit: token::Lit, span:\n             };\n             sess.emit_err(IntLiteralTooLarge { span, limit });\n         }\n+        LitError::NulInCStr(range) => {\n+            let lo = BytePos(span.lo().0 + range.start as u32 + 2);\n+            let hi = BytePos(span.lo().0 + range.end as u32 + 2);\n+            let span = span.with_lo(lo).with_hi(hi);\n+            sess.emit_err(NulInCStr { span });\n+        }\n     }\n }\n "}, {"sha": "58015d5d5026c908dc50137da10c15fffcc6d3df", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -441,6 +441,7 @@ symbols! {\n         bridge,\n         bswap,\n         c_str,\n+        c_str_literals,\n         c_unwind,\n         c_variadic,\n         c_void,"}, {"sha": "2daef82d6f1ddcd77194dd4ebba92fe6a3cd432c", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -3079,8 +3079,8 @@ impl<'a, K, V, A> CursorMut<'a, K, V, A> {\n                 unsafe { self.root.reborrow() }\n                     .as_mut()?\n                     .borrow_mut()\n-                    .first_leaf_edge()\n-                    .next_kv()\n+                    .last_leaf_edge()\n+                    .next_back_kv()\n                     .ok()?\n                     .into_kv_valmut()\n             }"}, {"sha": "7ecffe3eef2d5ac05032713132825dcd0d1f0579", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -8,6 +8,7 @@ use crate::testing::crash_test::{CrashTestDummy, Panic};\n use crate::testing::ord_chaos::{Cyclic3, Governed, Governor};\n use crate::testing::rng::DeterministicRng;\n use crate::vec::Vec;\n+use core::assert_matches::assert_matches;\n use std::cmp::Ordering;\n use std::iter;\n use std::mem;\n@@ -2448,3 +2449,21 @@ fn test_cursor_mut_insert_after_4() {\n     let mut cur = map.upper_bound_mut(Bound::Included(&2));\n     cur.insert_after(4, 'd');\n }\n+\n+#[test]\n+fn cursor_peek_prev_agrees_with_cursor_mut() {\n+    let mut map = BTreeMap::from([(1, 1), (2, 2), (3, 3)]);\n+\n+    let cursor = map.lower_bound(Bound::Excluded(&3));\n+    assert!(cursor.key().is_none());\n+\n+    let prev = cursor.peek_prev();\n+    assert_matches!(prev, Some((&3, _)));\n+\n+    // Shadow names so the two parts of this test match.\n+    let mut cursor = map.lower_bound_mut(Bound::Excluded(&3));\n+    assert!(cursor.key().is_none());\n+\n+    let prev = cursor.peek_prev();\n+    assert_matches!(prev, Some((&3, _)));\n+}"}, {"sha": "07b11814f965f63b15f99265a37eb1000da87b51", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -79,9 +79,9 @@ use crate::str;\n ///\n /// [str]: prim@str \"str\"\n #[derive(Hash)]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n #[stable(feature = \"core_c_str\", since = \"1.64.0\")]\n #[rustc_has_incoherent_inherent_impls]\n+#[cfg_attr(not(bootstrap), lang = \"CStr\")]\n // FIXME:\n // `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n // on `CStr` being layout-compatible with `[u8]`."}, {"sha": "caecda1bc63fdcb132d4ad040dc485858dfa5487", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -337,6 +337,8 @@ pub enum LitKind {\n     StrRaw(u8),\n     ByteStr,\n     ByteStrRaw(u8),\n+    CStr,\n+    CStrRaw(u8),\n     Err,\n }\n \n@@ -350,6 +352,8 @@ rpc_encode_decode!(\n         StrRaw(n),\n         ByteStr,\n         ByteStrRaw(n),\n+        CStr,\n+        CStrRaw(n),\n         Err,\n     }\n );"}, {"sha": "5440d85df4adff59d441487998d4c2b96fdb9b8a", "filename": "library/std/src/sys/hermit/time.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -40,11 +40,7 @@ impl Timespec {\n     }\n \n     fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n+        let mut secs = self.tv_sec.checked_add_unsigned(other.as_secs())?;\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n@@ -57,11 +53,7 @@ impl Timespec {\n     }\n \n     fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n+        let mut secs = self.tv_sec.checked_sub_unsigned(other.as_secs())?;\n \n         // Similar to above, nanos can't overflow.\n         let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;"}, {"sha": "f83f1644fe854483629bde2c4fbefed46c07ec15", "filename": "library/std/src/sys/solid/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ftime.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -47,10 +47,10 @@ impl SystemTime {\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime(self.0.checked_add(other.as_secs().try_into().ok()?)?))\n+        Some(SystemTime(self.0.checked_add_unsigned(other.as_secs())?))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-        Some(SystemTime(self.0.checked_sub(other.as_secs().try_into().ok()?)?))\n+        Some(SystemTime(self.0.checked_sub_unsigned(other.as_secs())?))\n     }\n }"}, {"sha": "a9fbc7ab108a4653fa7d90a9f352d78a1b6ee983", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -113,11 +113,7 @@ impl Timespec {\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `i64`\n-            .ok()\n-            .and_then(|secs| self.tv_sec.checked_add(secs))?;\n+        let mut secs = self.tv_sec.checked_add_unsigned(other.as_secs())?;\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n@@ -126,23 +122,19 @@ impl Timespec {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec::new(secs, nsec as i64))\n+        Some(Timespec::new(secs, nsec.into()))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `i64`\n-            .ok()\n-            .and_then(|secs| self.tv_sec.checked_sub(secs))?;\n+        let mut secs = self.tv_sec.checked_sub_unsigned(other.as_secs())?;\n \n         // Similar to above, nanos can't overflow.\n         let mut nsec = self.tv_nsec.0 as i32 - other.subsec_nanos() as i32;\n         if nsec < 0 {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec::new(secs, nsec as i64))\n+        Some(Timespec::new(secs, nsec.into()))\n     }\n \n     #[allow(dead_code)]"}, {"sha": "6ed84806e6d375bab02359daee0b19bc7d8c05ae", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -1,4 +1,5 @@\n use super::{Duration, Instant, SystemTime, UNIX_EPOCH};\n+use core::fmt::Debug;\n #[cfg(not(target_arch = \"wasm32\"))]\n use test::{black_box, Bencher};\n \n@@ -201,6 +202,32 @@ fn since_epoch() {\n     assert!(a < hundred_twenty_years);\n }\n \n+#[test]\n+fn big_math() {\n+    // Check that the same result occurs when adding/subtracting each duration one at a time as when\n+    // adding/subtracting them all at once.\n+    #[track_caller]\n+    fn check<T: Eq + Copy + Debug>(start: Option<T>, op: impl Fn(&T, Duration) -> Option<T>) {\n+        const DURATIONS: [Duration; 2] =\n+            [Duration::from_secs(i64::MAX as _), Duration::from_secs(50)];\n+        if let Some(start) = start {\n+            assert_eq!(\n+                op(&start, DURATIONS.into_iter().sum()),\n+                DURATIONS.into_iter().try_fold(start, |t, d| op(&t, d))\n+            )\n+        }\n+    }\n+\n+    check(SystemTime::UNIX_EPOCH.checked_sub(Duration::from_secs(100)), SystemTime::checked_add);\n+    check(SystemTime::UNIX_EPOCH.checked_add(Duration::from_secs(100)), SystemTime::checked_sub);\n+\n+    let instant = Instant::now();\n+    check(instant.checked_sub(Duration::from_secs(100)), Instant::checked_add);\n+    check(instant.checked_sub(Duration::from_secs(i64::MAX as _)), Instant::checked_add);\n+    check(instant.checked_add(Duration::from_secs(100)), Instant::checked_sub);\n+    check(instant.checked_add(Duration::from_secs(i64::MAX as _)), Instant::checked_sub);\n+}\n+\n macro_rules! bench_instant_threaded {\n     ($bench_name:ident, $thread_count:expr) => {\n         #[bench]"}, {"sha": "e2b859e705df01e1fcbfa8b25f49717ff2ed9013", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -574,7 +574,8 @@ change in the future.\n This instructs `rustc` to generate code specifically for a particular processor.\n \n You can run `rustc --print target-cpus` to see the valid options to pass\n-here. Each target has a default base CPU. Special values include:\n+and the default target CPU for the current buid target.\n+Each target has a default base CPU. Special values include:\n \n * `native` can be passed to use the processor of the host machine.\n * `generic` refers to an LLVM target with minimal features but modern tuning."}, {"sha": "c94968b4817cbea0ecc52d857efb7fc4e567a77d", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -811,7 +811,9 @@ impl<'src> Classifier<'src> {\n                 | LiteralKind::Str { .. }\n                 | LiteralKind::ByteStr { .. }\n                 | LiteralKind::RawStr { .. }\n-                | LiteralKind::RawByteStr { .. } => Class::String,\n+                | LiteralKind::RawByteStr { .. }\n+                | LiteralKind::CStr { .. }\n+                | LiteralKind::RawCStr { .. } => Class::String,\n                 // Number literals.\n                 LiteralKind::Float { .. } | LiteralKind::Int { .. } => Class::Number,\n             },"}, {"sha": "a48f4c77f857fb5cd8119d9c5aea9d1958eca4e5", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -284,6 +284,7 @@ impl<'a> NormalizedPat<'a> {\n                     LitKind::Str(sym, _) => Self::LitStr(sym),\n                     LitKind::ByteStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::CStr(ref bytes, _) => Self::LitBytes(bytes),\n                     LitKind::Char(val) => Self::LitInt(val.into()),\n                     LitKind::Int(val, _) => Self::LitInt(val),\n                     LitKind::Bool(val) => Self::LitBool(val),"}, {"sha": "2f2e84fa35a12ce8f7dad577678e6bfdd504fefe", "filename": "src/tools/clippy/clippy_lints/src/strlen_on_c_strings.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fstrlen_on_c_strings.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use clippy_utils::visitors::is_expr_unsafe;\n use clippy_utils::{get_parent_node, match_libc_symbol};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, Node, UnsafeSource};\n+use rustc_hir::{Block, BlockCheckMode, Expr, ExprKind, LangItem, Node, UnsafeSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -67,7 +67,7 @@ impl<'tcx> LateLintPass<'tcx> for StrlenOnCStrings {\n                 let val_name = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n                 let method_name = if is_type_diagnostic_item(cx, ty, sym::cstring_type) {\n                     \"as_bytes\"\n-                } else if is_type_diagnostic_item(cx, ty, sym::CStr) {\n+                } else if is_type_lang_item(cx, ty, LangItem::CStr) {\n                     \"to_bytes\"\n                 } else {\n                     return;"}, {"sha": "f75dff46624e40cf2b4bce71df762f9c333c1a67", "filename": "src/tools/clippy/clippy_lints/src/utils/author.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -304,6 +304,11 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"ByteStr(ref {vec})\");\n                 chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n             },\n+            LitKind::CStr(ref vec, _) => {\n+                bind!(self, vec);\n+                kind!(\"CStr(ref {vec})\");\n+                chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n+            }\n             LitKind::Str(s, _) => {\n                 bind!(self, s);\n                 kind!(\"Str({s}, _)\");"}, {"sha": "7c7ec6d334d9bc7dadff7024da2a7b5395d47246", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -211,6 +211,7 @@ pub fn lit_to_mir_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n         LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n         LitKind::Byte(b) => Constant::Int(u128::from(b)),\n         LitKind::ByteStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n+        LitKind::CStr(ref s, _) => Constant::Binary(Lrc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n         LitKind::Int(n, _) => Constant::Int(n),\n         LitKind::Float(ref is, LitFloatType::Suffixed(fty)) => match fty {"}, {"sha": "841f5b4f6ee208807a04610f3c90f6807234df65", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 66, "deletions": 21, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -319,7 +319,8 @@ impl<'test> TestCx<'test> {\n \n     fn run_cfail_test(&self) {\n         let pm = self.pass_mode();\n-        let proc_res = self.compile_test(WillExecute::No, self.should_emit_metadata(pm));\n+        let proc_res =\n+            self.compile_test(WillExecute::No, self.should_emit_metadata(pm), Vec::new());\n         self.check_if_test_should_compile(&proc_res, pm);\n         self.check_no_compiler_crash(&proc_res, self.props.should_ice);\n \n@@ -347,7 +348,7 @@ impl<'test> TestCx<'test> {\n     fn run_rfail_test(&self) {\n         let pm = self.pass_mode();\n         let should_run = self.run_if_enabled();\n-        let proc_res = self.compile_test(should_run, self.should_emit_metadata(pm));\n+        let proc_res = self.compile_test(should_run, self.should_emit_metadata(pm), Vec::new());\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -395,7 +396,7 @@ impl<'test> TestCx<'test> {\n \n     fn run_cpass_test(&self) {\n         let emit_metadata = self.should_emit_metadata(self.pass_mode());\n-        let proc_res = self.compile_test(WillExecute::No, emit_metadata);\n+        let proc_res = self.compile_test(WillExecute::No, emit_metadata, Vec::new());\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -410,7 +411,7 @@ impl<'test> TestCx<'test> {\n     fn run_rpass_test(&self) {\n         let emit_metadata = self.should_emit_metadata(self.pass_mode());\n         let should_run = self.run_if_enabled();\n-        let proc_res = self.compile_test(should_run, emit_metadata);\n+        let proc_res = self.compile_test(should_run, emit_metadata, Vec::new());\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -440,7 +441,7 @@ impl<'test> TestCx<'test> {\n         }\n \n         let should_run = self.run_if_enabled();\n-        let mut proc_res = self.compile_test(should_run, Emit::None);\n+        let mut proc_res = self.compile_test(should_run, Emit::None, Vec::new());\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -686,7 +687,7 @@ impl<'test> TestCx<'test> {\n \n         // compile test file (it should have 'compile-flags:-g' in the header)\n         let should_run = self.run_if_enabled();\n-        let compile_result = self.compile_test(should_run, Emit::None);\n+        let compile_result = self.compile_test(should_run, Emit::None, Vec::new());\n         if !compile_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compile_result);\n         }\n@@ -806,7 +807,7 @@ impl<'test> TestCx<'test> {\n \n         // compile test file (it should have 'compile-flags:-g' in the header)\n         let should_run = self.run_if_enabled();\n-        let compiler_run_result = self.compile_test(should_run, Emit::None);\n+        let compiler_run_result = self.compile_test(should_run, Emit::None, Vec::new());\n         if !compiler_run_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compiler_run_result);\n         }\n@@ -1043,7 +1044,7 @@ impl<'test> TestCx<'test> {\n     fn run_debuginfo_lldb_test_no_opt(&self) {\n         // compile test file (it should have 'compile-flags:-g' in the header)\n         let should_run = self.run_if_enabled();\n-        let compile_result = self.compile_test(should_run, Emit::None);\n+        let compile_result = self.compile_test(should_run, Emit::None, Vec::new());\n         if !compile_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compile_result);\n         }\n@@ -1482,15 +1483,16 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn compile_test(&self, will_execute: WillExecute, emit: Emit) -> ProcRes {\n-        self.compile_test_general(will_execute, emit, self.props.local_pass_mode())\n+    fn compile_test(&self, will_execute: WillExecute, emit: Emit, passes: Vec<String>) -> ProcRes {\n+        self.compile_test_general(will_execute, emit, self.props.local_pass_mode(), passes)\n     }\n \n     fn compile_test_general(\n         &self,\n         will_execute: WillExecute,\n         emit: Emit,\n         local_pm: Option<PassMode>,\n+        passes: Vec<String>,\n     ) -> ProcRes {\n         // Only use `make_exe_name` when the test ends up being executed.\n         let output_file = match will_execute {\n@@ -1527,6 +1529,7 @@ impl<'test> TestCx<'test> {\n             emit,\n             allow_unused,\n             LinkToAux::Yes,\n+            passes,\n         );\n \n         self.compose_and_run_compiler(rustc, None)\n@@ -1777,6 +1780,7 @@ impl<'test> TestCx<'test> {\n             Emit::None,\n             AllowUnused::No,\n             LinkToAux::No,\n+            Vec::new(),\n         );\n \n         for key in &aux_props.unset_rustc_env {\n@@ -1908,6 +1912,7 @@ impl<'test> TestCx<'test> {\n         emit: Emit,\n         allow_unused: AllowUnused,\n         link_to_aux: LinkToAux,\n+        passes: Vec<String>, // Vec of passes under mir-opt test to be dumped\n     ) -> Command {\n         let is_aux = input_file.components().map(|c| c.as_os_str()).any(|c| c == \"auxiliary\");\n         let is_rustdoc = self.is_rustdoc() && !is_aux;\n@@ -2008,9 +2013,18 @@ impl<'test> TestCx<'test> {\n                 rustc.arg(\"-Cstrip=debuginfo\");\n             }\n             MirOpt => {\n+                // We check passes under test to minimize the mir-opt test dump\n+                // if files_for_miropt_test parses the passes, we dump only those passes\n+                // otherwise we conservatively pass -Zdump-mir=all\n+                let zdump_arg = if !passes.is_empty() {\n+                    format!(\"-Zdump-mir={}\", passes.join(\" | \"))\n+                } else {\n+                    \"-Zdump-mir=all\".to_string()\n+                };\n+\n                 rustc.args(&[\n                     \"-Copt-level=1\",\n-                    \"-Zdump-mir=all\",\n+                    &zdump_arg,\n                     \"-Zvalidate-mir\",\n                     \"-Zdump-mir-exclude-pass-number\",\n                     \"-Zmir-pretty-relative-line-numbers=yes\",\n@@ -2333,6 +2347,7 @@ impl<'test> TestCx<'test> {\n             Emit::LlvmIr,\n             AllowUnused::No,\n             LinkToAux::Yes,\n+            Vec::new(),\n         );\n \n         self.compose_and_run_compiler(rustc, None)\n@@ -2364,8 +2379,14 @@ impl<'test> TestCx<'test> {\n             None => self.fatal(\"missing 'assembly-output' header\"),\n         }\n \n-        let rustc =\n-            self.make_compile_args(input_file, output_file, emit, AllowUnused::No, LinkToAux::Yes);\n+        let rustc = self.make_compile_args(\n+            input_file,\n+            output_file,\n+            emit,\n+            AllowUnused::No,\n+            LinkToAux::Yes,\n+            Vec::new(),\n+        );\n \n         (self.compose_and_run_compiler(rustc, None), output_path)\n     }\n@@ -2496,6 +2517,7 @@ impl<'test> TestCx<'test> {\n             Emit::None,\n             AllowUnused::Yes,\n             LinkToAux::Yes,\n+            Vec::new(),\n         );\n         new_rustdoc.build_all_auxiliary(&mut rustc);\n \n@@ -2769,7 +2791,7 @@ impl<'test> TestCx<'test> {\n     fn run_codegen_units_test(&self) {\n         assert!(self.revision.is_none(), \"revisions not relevant here\");\n \n-        let proc_res = self.compile_test(WillExecute::No, Emit::None);\n+        let proc_res = self.compile_test(WillExecute::No, Emit::None, Vec::new());\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -3310,14 +3332,15 @@ impl<'test> TestCx<'test> {\n         if let Some(FailMode::Build) = self.props.fail_mode {\n             // Make sure a build-fail test cannot fail due to failing analysis (e.g. typeck).\n             let pm = Some(PassMode::Check);\n-            let proc_res = self.compile_test_general(WillExecute::No, Emit::Metadata, pm);\n+            let proc_res =\n+                self.compile_test_general(WillExecute::No, Emit::Metadata, pm, Vec::new());\n             self.check_if_test_should_compile(&proc_res, pm);\n         }\n \n         let pm = self.pass_mode();\n         let should_run = self.should_run(pm);\n         let emit_metadata = self.should_emit_metadata(pm);\n-        let proc_res = self.compile_test(should_run, emit_metadata);\n+        let proc_res = self.compile_test(should_run, emit_metadata, Vec::new());\n         self.check_if_test_should_compile(&proc_res, pm);\n \n         // if the user specified a format in the ui test\n@@ -3479,6 +3502,7 @@ impl<'test> TestCx<'test> {\n                 emit_metadata,\n                 AllowUnused::No,\n                 LinkToAux::Yes,\n+                Vec::new(),\n             );\n             let res = self.compose_and_run_compiler(rustc, None);\n             if !res.status.success() {\n@@ -3497,14 +3521,14 @@ impl<'test> TestCx<'test> {\n         let pm = self.pass_mode();\n         let should_run = self.should_run(pm);\n         let emit_metadata = self.should_emit_metadata(pm);\n-        let proc_res = self.compile_test(should_run, emit_metadata);\n+        let passes = self.get_passes();\n \n+        let proc_res = self.compile_test(should_run, emit_metadata, passes);\n+        self.check_mir_dump();\n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n-        self.check_mir_dump();\n-\n         if let WillExecute::Yes = should_run {\n             let proc_res = self.exec_compiled_test();\n \n@@ -3514,6 +3538,26 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n+    fn get_passes(&self) -> Vec<String> {\n+        let files = miropt_test_tools::files_for_miropt_test(\n+            &self.testpaths.file,\n+            self.config.get_pointer_width(),\n+        );\n+\n+        let mut out = Vec::new();\n+\n+        for miropt_test_tools::MiroptTestFiles {\n+            from_file: _,\n+            to_file: _,\n+            expected_file: _,\n+            passes,\n+        } in files\n+        {\n+            out.extend(passes);\n+        }\n+        out\n+    }\n+\n     fn check_mir_dump(&self) {\n         let test_file_contents = fs::read_to_string(&self.testpaths.file).unwrap();\n \n@@ -3543,8 +3587,9 @@ impl<'test> TestCx<'test> {\n             &self.testpaths.file,\n             self.config.get_pointer_width(),\n         );\n-\n-        for miropt_test_tools::MiroptTestFiles { from_file, to_file, expected_file } in files {\n+        for miropt_test_tools::MiroptTestFiles { from_file, to_file, expected_file, passes: _ } in\n+            files\n+        {\n             let dumped_string = if let Some(after) = to_file {\n                 self.diff_mir_files(from_file.into(), after.into())\n             } else {"}, {"sha": "f86c3ce0afeaae7868c0942398494ce070a6549f", "filename": "src/tools/miropt-test-tools/src/lib.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiropt-test-tools%2Fsrc%2Flib.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -4,6 +4,8 @@ pub struct MiroptTestFiles {\n     pub expected_file: std::path::PathBuf,\n     pub from_file: String,\n     pub to_file: Option<String>,\n+    /// Vec of passes under test to be dumped\n+    pub passes: Vec<String>,\n }\n \n pub fn files_for_miropt_test(testfile: &std::path::Path, bit_width: u32) -> Vec<MiroptTestFiles> {\n@@ -28,17 +30,26 @@ pub fn files_for_miropt_test(testfile: &std::path::Path, bit_width: u32) -> Vec<\n             let mut expected_file;\n             let from_file;\n             let to_file;\n+            let mut passes = Vec::new();\n \n             if test_name.ends_with(\".diff\") {\n                 let trimmed = test_name.trim_end_matches(\".diff\");\n+                passes.push(trimmed.split('.').last().unwrap().to_owned());\n                 let test_against = format!(\"{}.after.mir\", trimmed);\n                 from_file = format!(\"{}.before.mir\", trimmed);\n                 expected_file = format!(\"{}{}.diff\", trimmed, bit_width);\n                 assert!(test_names.next().is_none(), \"two mir pass names specified for MIR diff\");\n                 to_file = Some(test_against);\n             } else if let Some(first_pass) = test_names.next() {\n                 let second_pass = test_names.next().unwrap();\n+                if let Some((first_pass_name, _)) = first_pass.split_once('.') {\n+                    passes.push(first_pass_name.to_owned());\n+                }\n+                if let Some((second_pass_name, _)) = second_pass.split_once('.') {\n+                    passes.push(second_pass_name.to_owned());\n+                }\n                 assert!(test_names.next().is_none(), \"three mir pass names specified for MIR diff\");\n+\n                 expected_file =\n                     format!(\"{}{}.{}-{}.diff\", test_name, bit_width, first_pass, second_pass);\n                 let second_file = format!(\"{}.{}.mir\", test_name, second_pass);\n@@ -51,18 +62,24 @@ pub fn files_for_miropt_test(testfile: &std::path::Path, bit_width: u32) -> Vec<\n                     .next()\n                     .expect(\"test_name has an invalid extension\");\n                 let extension = cap.get(1).unwrap().as_str();\n+\n                 expected_file =\n                     format!(\"{}{}{}\", test_name.trim_end_matches(extension), bit_width, extension,);\n                 from_file = test_name.to_string();\n                 assert!(test_names.next().is_none(), \"two mir pass names specified for MIR dump\");\n                 to_file = None;\n+                // the pass name is the third to last string in the test name\n+                // this gets pushed into passes\n+                passes.push(\n+                    test_name.split('.').rev().nth(2).expect(\"invalid test format\").to_string(),\n+                );\n             };\n             if !expected_file.starts_with(&test_crate) {\n                 expected_file = format!(\"{}.{}\", test_crate, expected_file);\n             }\n             let expected_file = test_dir.join(expected_file);\n \n-            out.push(MiroptTestFiles { expected_file, from_file, to_file });\n+            out.push(MiroptTestFiles { expected_file, from_file, to_file, passes });\n         }\n     }\n "}, {"sha": "169e99deee755235eb4d7604d40c432cf866220f", "filename": "tests/mir-opt/const_allocation.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.32bit.mir?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -21,42 +21,42 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc18\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc19\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc18 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc5\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc13\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc19 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc6\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc5 (size: 0, align: 4) {}\n+alloc6 (size: 0, align: 4) {}\n \n-alloc8 (size: 16, align: 4) {\n-    \u257e\u2500alloc9\u2500\u2500\u257c 03 00 00 00 \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+alloc9 (size: 16, align: 4) {\n+    \u257e\u2500alloc10\u2500\u257c 03 00 00 00 \u257e\u2500alloc11\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc10 (size: 3, align: 1) {\n+alloc11 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 24, align: 4) {\n-    0x00 \u2502 \u257e\u2500alloc14\u2500\u257c 03 00 00 00 \u257e\u2500alloc15\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 \u257e\u2500alloc16\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+alloc14 (size: 24, align: 4) {\n+    0x00 \u2502 \u257e\u2500alloc15\u2500\u257c 03 00 00 00 \u257e\u2500alloc16\u2500\u257c 03 00 00 00 \u2502 \u257e\u2500\u2500\u257c....\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 \u257e\u2500alloc17\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc15 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc15 (size: 3, align: 1) {\n+alloc16 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc16 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "db1f9648843ea2f749e39f3e6a7ba252f51ddd8c", "filename": "tests/mir-opt/const_allocation.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation.main.ConstProp.after.64bit.mir?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -21,46 +21,46 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc18 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc5\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc19 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc6\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc5 (size: 0, align: 8) {}\n+alloc6 (size: 0, align: 8) {}\n \n-alloc8 (size: 32, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc9 (size: 32, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc9 (size: 3, align: 1) {\n+alloc10 (size: 3, align: 1) {\n     66 6f 6f                                        \u2502 foo\n }\n \n-alloc10 (size: 3, align: 1) {\n+alloc11 (size: 3, align: 1) {\n     62 61 72                                        \u2502 bar\n }\n \n-alloc13 (size: 48, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+alloc14 (size: 48, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc17\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc14 (size: 3, align: 1) {\n+alloc15 (size: 3, align: 1) {\n     6d 65 68                                        \u2502 meh\n }\n \n-alloc15 (size: 3, align: 1) {\n+alloc16 (size: 3, align: 1) {\n     6d 6f 70                                        \u2502 mop\n }\n \n-alloc16 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     6d c3 b6 70                                     \u2502 m..p\n }"}, {"sha": "999acb48afec33b64561796ac885fa642ac5e425", "filename": "tests/mir-opt/const_allocation2.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.32bit.mir?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -21,41 +21,41 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc22\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc23\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc22 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc14\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc20\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc23 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc10\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc15\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc21\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc9 (size: 0, align: 4) {}\n+alloc10 (size: 0, align: 4) {}\n \n-alloc14 (size: 8, align: 4) {\n-    \u257e\u2500alloc12\u2500\u257c \u257e\u2500alloc13\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc15 (size: 8, align: 4) {\n+    \u257e\u2500alloc13\u2500\u257c \u257e\u2500alloc14\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc13 (size: 1, align: 1) {\n+alloc14 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc20 (size: 12, align: 4) {\n-    \u257e\u2500a17+0x3\u2500\u257c \u257e\u2500alloc18\u2500\u257c \u257e\u2500a19+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc21 (size: 12, align: 4) {\n+    \u257e\u2500a18+0x3\u2500\u257c \u257e\u2500alloc19\u2500\u257c \u257e\u2500a20+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc17 (size: 4, align: 1) {\n+alloc18 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc18 (size: 1, align: 1) {\n+alloc19 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc19 (size: 4, align: 1) {\n+alloc20 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "30311890eeef9293fc644712bc89491e29bd70c1", "filename": "tests/mir-opt/const_allocation2.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.64bit.mir?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -21,44 +21,44 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc22\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc22 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc23 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc10\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc20\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc15\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc21\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc9 (size: 0, align: 8) {}\n+alloc10 (size: 0, align: 8) {}\n \n-alloc14 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc15 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc14\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc12 (size: 1, align: 1) {\n+alloc13 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc13 (size: 1, align: 1) {\n+alloc14 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc20 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc17+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc19+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc21 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc18+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc20+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc17 (size: 4, align: 1) {\n+alloc18 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc18 (size: 1, align: 1) {\n+alloc19 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc19 (size: 4, align: 1) {\n+alloc20 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "d592e59fafd795757aceecf691197b4df24c1cf2", "filename": "tests/mir-opt/const_allocation3.main.ConstProp.after.32bit.mir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.32bit.mir?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -21,30 +21,30 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 4, align: 4) {\n-    \u257e\u2500alloc11\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n+    \u257e\u2500alloc12\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n }\n \n-alloc11 (size: 168, align: 1) {\n+alloc12 (size: 168, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc6\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500alloc7\u2500\u2500\u257c \u2502 ............\u257e\u2500\u2500\u257c\n     0x20 \u2502 01 ef cd ab 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n-    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500alloc8\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n-    0x90 \u2502 \u257e\u2500a9+0x63\u2500\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n+    0x80 \u2502 00 00 00 00 00 00 00 00 00 00 \u257e\u2500alloc9\u2500\u2500\u257c 00 00 \u2502 ..........\u257e\u2500\u2500\u257c..\n+    0x90 \u2502 \u257ea10+0x63\u2500\u257c 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u257c............\n     0xa0 \u2502 00 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc6 (size: 4, align: 4) {\n+alloc7 (size: 4, align: 4) {\n     2a 00 00 00                                     \u2502 *...\n }\n \n-alloc8 (fn: main)\n+alloc9 (fn: main)\n \n-alloc9 (size: 100, align: 1) {\n+alloc10 (size: 100, align: 1) {\n     0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "ca53b28be7cbf4fa2c46c6fa1f23dc7b8b8494b5", "filename": "tests/mir-opt/const_allocation3.main.ConstProp.after.64bit.mir", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_allocation3.main.ConstProp.after.64bit.mir?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -21,31 +21,31 @@ fn main() -> () {\n }\n \n alloc1 (static: FOO, size: 8, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc11 (size: 180, align: 1) {\n+alloc12 (size: 180, align: 1) {\n     0x00 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab ab \u2502 ................\n-    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc6\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n+    0x10 \u2502 ab ab ab ab ab ab ab ab ab ab ab ab \u257e\u2500\u2500alloc7\u2500\u2500 \u2502 ............\u257e\u2500\u2500\u2500\n     0x20 \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 ef cd ab 00 00 00 00 00 00 00 00 \u2502 \u2500\u2500\u2500\u257c............\n     0x30 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x40 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x50 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x60 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x70 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x80 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u257e\u2500\u2500\u2500\u2500 \u2502 ..............\u257e\u2500\n-    0x90 \u2502 \u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500\u2500alloc9+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x90 \u2502 \u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u257c 00 00 \u257e\u2500\u2500\u2500\u2500alloc10+0x63\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u2500\u2500\u2500\u2500\u2500\u257c..\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0xa0 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0xb0 \u2502 00 00 00 00                                     \u2502 ....\n }\n \n-alloc6 (size: 4, align: 4) {\n+alloc7 (size: 4, align: 4) {\n     2a 00 00 00                                     \u2502 *...\n }\n \n-alloc8 (fn: main)\n+alloc9 (fn: main)\n \n-alloc9 (size: 100, align: 1) {\n+alloc10 (size: 100, align: 1) {\n     0x00 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................\n     0x20 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 \u2502 ................"}, {"sha": "03fb6f96fb5f984b900469ba968bc7132bd7c225", "filename": "tests/rustdoc-ui/check-cfg/check-cfg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Frustdoc-ui%2Fcheck-cfg%2Fcheck-cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Frustdoc-ui%2Fcheck-cfg%2Fcheck-cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fcheck-cfg%2Fcheck-cfg.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -2,7 +2,7 @@ warning: unexpected `cfg` condition name\n   --> $DIR/check-cfg.rs:5:7\n    |\n LL | #[cfg(uniz)]\n-   |       ^^^^ help: did you mean: `unix`\n+   |       ^^^^ help: there is a config with a similar name: `unix`\n    |\n    = note: `#[warn(unexpected_cfgs)]` on by default\n "}, {"sha": "f84543c20725470973bd3432dabd48b5fc008c6e", "filename": "tests/rustdoc-ui/doctest/check-cfg-test.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Frustdoc-ui%2Fdoctest%2Fcheck-cfg-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Frustdoc-ui%2Fdoctest%2Fcheck-cfg-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fdoctest%2Fcheck-cfg-test.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -4,7 +4,7 @@ warning: unexpected `cfg` condition value\n LL | #[cfg(feature = \"invalid\")]\n    |       ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: test\n+   = note: expected values for `feature` are: `test`\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n warning: 1 warning emitted"}, {"sha": "70a967c0e5f6490d038816c97ae2527dbf0ad0aa", "filename": "tests/ui/check-cfg/compact-values.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fcompact-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fcompact-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fcompact-values.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -4,7 +4,7 @@ warning: unexpected `cfg` condition value\n LL | #[cfg(target(os = \"linux\", arch = \"X\"))]\n    |                            ^^^^^^^^^^\n    |\n-   = note: expected values for `target_arch` are: aarch64, arm, avr, bpf, hexagon, loongarch64, m68k, mips, mips64, msp430, nvptx64, powerpc, powerpc64, riscv32, riscv64, s390x, sparc, sparc64, wasm32, wasm64, x86, x86_64\n+   = note: expected values for `target_arch` are: `aarch64`, `arm`, `avr`, `bpf`, `hexagon`, `loongarch64`, `m68k`, `mips`, `mips64`, `msp430`, `nvptx64`, `powerpc`, `powerpc64`, `riscv32`, `riscv64`, `s390x`, `sparc`, `sparc64`, `wasm32`, `wasm64`, `x86`, `x86_64`\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n warning: 1 warning emitted"}, {"sha": "49e127d079a79ef72cb41701beae76905c45bb2f", "filename": "tests/ui/check-cfg/diagnotics.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fdiagnotics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fdiagnotics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fdiagnotics.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+// compile-flags: --check-cfg=names() --check-cfg=values(feature,\"foo\") --check-cfg=values(no_values) -Z unstable-options\n+\n+#[cfg(featur)]\n+//~^ WARNING unexpected `cfg` condition name\n+fn feature() {}\n+\n+#[cfg(featur = \"foo\")]\n+//~^ WARNING unexpected `cfg` condition name\n+fn feature() {}\n+\n+#[cfg(featur = \"fo\")]\n+//~^ WARNING unexpected `cfg` condition name\n+fn feature() {}\n+\n+#[cfg(feature = \"foo\")]\n+fn feature() {}\n+\n+#[cfg(no_value)]\n+//~^ WARNING unexpected `cfg` condition name\n+fn no_values() {}\n+\n+#[cfg(no_value = \"foo\")]\n+//~^ WARNING unexpected `cfg` condition name\n+fn no_values() {}\n+\n+#[cfg(no_values = \"bar\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn no_values() {}\n+\n+fn main() {}"}, {"sha": "8b9fef09d09ecc97ffd82a7ec2c8ba7dce38a325", "filename": "tests/ui/check-cfg/diagnotics.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fdiagnotics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fdiagnotics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fdiagnotics.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -0,0 +1,62 @@\n+warning: unexpected `cfg` condition name\n+  --> $DIR/diagnotics.rs:4:7\n+   |\n+LL | #[cfg(featur)]\n+   |       ^^^^^^ help: there is a config with a similar name: `feature`\n+   |\n+   = help: expected values for `feature` are: `foo`\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/diagnotics.rs:8:7\n+   |\n+LL | #[cfg(featur = \"foo\")]\n+   |       ^^^^^^^^^^^^^^\n+   |\n+   = help: expected values for `feature` are: `foo`\n+help: there is a config with a similar name and value\n+   |\n+LL | #[cfg(feature = \"foo\")]\n+   |       ~~~~~~~\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/diagnotics.rs:12:7\n+   |\n+LL | #[cfg(featur = \"fo\")]\n+   |       ^^^^^^^^^^^^^\n+   |\n+   = help: expected values for `feature` are: `foo`\n+help: there is a config with a similar name and different values\n+   |\n+LL | #[cfg(feature = \"foo\")]\n+   |       ~~~~~~~~~~~~~~~\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/diagnotics.rs:19:7\n+   |\n+LL | #[cfg(no_value)]\n+   |       ^^^^^^^^ help: there is a config with a similar name: `no_values`\n+\n+warning: unexpected `cfg` condition name\n+  --> $DIR/diagnotics.rs:23:7\n+   |\n+LL | #[cfg(no_value = \"foo\")]\n+   |       ^^^^^^^^^^^^^^^^\n+   |\n+help: there is a config with a similar name and no value\n+   |\n+LL | #[cfg(no_values)]\n+   |       ~~~~~~~~~\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/diagnotics.rs:27:7\n+   |\n+LL | #[cfg(no_values = \"bar\")]\n+   |       ^^^^^^^^^--------\n+   |                |\n+   |                help: remove the value\n+   |\n+   = note: no expected value for `no_values`\n+\n+warning: 6 warnings emitted\n+"}, {"sha": "ed09f8cb66d2995fff481930aeec82dcb18ad71a", "filename": "tests/ui/check-cfg/invalid-cfg-name.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-name.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -2,7 +2,7 @@ warning: unexpected `cfg` condition name\n   --> $DIR/invalid-cfg-name.rs:7:7\n    |\n LL | #[cfg(widnows)]\n-   |       ^^^^^^^ help: did you mean: `windows`\n+   |       ^^^^^^^ help: there is a config with a similar name: `windows`\n    |\n    = note: `#[warn(unexpected_cfgs)]` on by default\n "}, {"sha": "776d264a7adcb949f04b6d9a9fddb8debeff5514", "filename": "tests/ui/check-cfg/invalid-cfg-value.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -4,9 +4,9 @@ warning: unexpected `cfg` condition value\n LL | #[cfg(feature = \"sedre\")]\n    |       ^^^^^^^^^^-------\n    |                 |\n-   |                 help: did you mean: `\"serde\"`\n+   |                 help: there is a expected value with a similar name: `\"serde\"`\n    |\n-   = note: expected values for `feature` are: full, serde\n+   = note: expected values for `feature` are: `full`, `serde`\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n warning: unexpected `cfg` condition value\n@@ -15,7 +15,7 @@ warning: unexpected `cfg` condition value\n LL | #[cfg(feature = \"rand\")]\n    |       ^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: full, serde\n+   = note: expected values for `feature` are: `full`, `serde`\n \n warning: unexpected condition value `rand` for condition name `feature`\n    |"}, {"sha": "9adf5c46e43fe8a4d069e01577d2c0ad21dcf645", "filename": "tests/ui/check-cfg/mix.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fmix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fmix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fmix.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -12,6 +12,10 @@ fn do_windows_stuff() {}\n //~^ WARNING unexpected `cfg` condition name\n fn do_windows_stuff() {}\n \n+#[cfg(feature)]\n+//~^ WARNING unexpected `cfg` condition value\n+fn no_feature() {}\n+\n #[cfg(feature = \"foo\")]\n fn use_foo() {}\n "}, {"sha": "07c514aed5242f603aa0894677ea2da67c877496", "filename": "tests/ui/check-cfg/mix.stderr", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fmix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fmix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fmix.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -2,28 +2,36 @@ warning: unexpected `cfg` condition name\n   --> $DIR/mix.rs:11:7\n    |\n LL | #[cfg(widnows)]\n-   |       ^^^^^^^ help: did you mean: `windows`\n+   |       ^^^^^^^ help: there is a config with a similar name: `windows`\n    |\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:18:7\n+  --> $DIR/mix.rs:15:7\n+   |\n+LL | #[cfg(feature)]\n+   |       ^^^^^^^- help: specify a config value: `= \"foo\"`\n+   |\n+   = note: expected values for `feature` are: `foo`\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/mix.rs:22:7\n    |\n LL | #[cfg(feature = \"bar\")]\n    |       ^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:22:7\n+  --> $DIR/mix.rs:26:7\n    |\n LL | #[cfg(feature = \"zebra\")]\n    |       ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:26:12\n+  --> $DIR/mix.rs:30:12\n    |\n LL | #[cfg_attr(uu, test)]\n    |            ^^\n@@ -37,146 +45,146 @@ warning: unexpected `unknown_name` as condition name\n    = help: was set with `--cfg` but isn't in the `--check-cfg` expected names\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:35:10\n+  --> $DIR/mix.rs:39:10\n    |\n LL |     cfg!(widnows);\n-   |          ^^^^^^^ help: did you mean: `windows`\n+   |          ^^^^^^^ help: there is a config with a similar name: `windows`\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:38:10\n+  --> $DIR/mix.rs:42:10\n    |\n LL |     cfg!(feature = \"bar\");\n    |          ^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:40:10\n+  --> $DIR/mix.rs:44:10\n    |\n LL |     cfg!(feature = \"zebra\");\n    |          ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:42:10\n+  --> $DIR/mix.rs:46:10\n    |\n LL |     cfg!(xxx = \"foo\");\n    |          ^^^^^^^^^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:44:10\n+  --> $DIR/mix.rs:48:10\n    |\n LL |     cfg!(xxx);\n    |          ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:46:14\n+  --> $DIR/mix.rs:50:14\n    |\n LL |     cfg!(any(xxx, windows));\n    |              ^^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:48:14\n+  --> $DIR/mix.rs:52:14\n    |\n LL |     cfg!(any(feature = \"bad\", windows));\n    |              ^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:50:23\n+  --> $DIR/mix.rs:54:23\n    |\n LL |     cfg!(any(windows, xxx));\n    |                       ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:52:20\n+  --> $DIR/mix.rs:56:20\n    |\n LL |     cfg!(all(unix, xxx));\n    |                    ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:54:14\n+  --> $DIR/mix.rs:58:14\n    |\n LL |     cfg!(all(aa, bb));\n    |              ^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:54:18\n+  --> $DIR/mix.rs:58:18\n    |\n LL |     cfg!(all(aa, bb));\n    |                  ^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:57:14\n+  --> $DIR/mix.rs:61:14\n    |\n LL |     cfg!(any(aa, bb));\n    |              ^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:57:18\n+  --> $DIR/mix.rs:61:18\n    |\n LL |     cfg!(any(aa, bb));\n    |                  ^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:60:20\n+  --> $DIR/mix.rs:64:20\n    |\n LL |     cfg!(any(unix, feature = \"zebra\"));\n    |                    ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:62:14\n+  --> $DIR/mix.rs:66:14\n    |\n LL |     cfg!(any(xxx, feature = \"zebra\"));\n    |              ^^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:62:19\n+  --> $DIR/mix.rs:66:19\n    |\n LL |     cfg!(any(xxx, feature = \"zebra\"));\n    |                   ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:65:14\n+  --> $DIR/mix.rs:69:14\n    |\n LL |     cfg!(any(xxx, unix, xxx));\n    |              ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:65:25\n+  --> $DIR/mix.rs:69:25\n    |\n LL |     cfg!(any(xxx, unix, xxx));\n    |                         ^^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:68:14\n+  --> $DIR/mix.rs:72:14\n    |\n LL |     cfg!(all(feature = \"zebra\", feature = \"zebra\", feature = \"zebra\"));\n    |              ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:68:33\n+  --> $DIR/mix.rs:72:33\n    |\n LL |     cfg!(all(feature = \"zebra\", feature = \"zebra\", feature = \"zebra\"));\n    |                                 ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:68:52\n+  --> $DIR/mix.rs:72:52\n    |\n LL |     cfg!(all(feature = \"zebra\", feature = \"zebra\", feature = \"zebra\"));\n    |                                                    ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: foo\n+   = note: expected values for `feature` are: `foo`\n \n-warning: 27 warnings emitted\n+warning: 28 warnings emitted\n "}, {"sha": "ffa87dc58f20393d42aa1801884c5754834bd798", "filename": "tests/ui/check-cfg/no-values.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fno-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fno-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fno-values.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -2,7 +2,9 @@ warning: unexpected `cfg` condition value\n   --> $DIR/no-values.rs:6:7\n    |\n LL | #[cfg(feature = \"foo\")]\n-   |       ^^^^^^^^^^^^^^^\n+   |       ^^^^^^^--------\n+   |              |\n+   |              help: remove the value\n    |\n    = note: no expected value for `feature`\n    = note: `#[warn(unexpected_cfgs)]` on by default"}, {"sha": "eb81535e3edb054af30f42d22470a4f117de906e", "filename": "tests/ui/check-cfg/values-target-json.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -4,9 +4,9 @@ warning: unexpected `cfg` condition value\n LL | #[cfg(target_os = \"linuz\")]\n    |       ^^^^^^^^^^^^-------\n    |                   |\n-   |                   help: did you mean: `\"linux\"`\n+   |                   help: there is a expected value with a similar name: `\"linux\"`\n    |\n-   = note: expected values for `target_os` are: aix, android, cuda, dragonfly, emscripten, ericos, espidf, freebsd, fuchsia, haiku, hermit, horizon, illumos, ios, l4re, linux, macos, netbsd, none, nto, openbsd, psp, redox, solaris, solid_asp3, tvos, uefi, unknown, vita, vxworks, wasi, watchos, windows, xous\n+   = note: expected values for `target_os` are: `aix`, `android`, `cuda`, `dragonfly`, `emscripten`, `ericos`, `espidf`, `freebsd`, `fuchsia`, `haiku`, `hermit`, `horizon`, `illumos`, `ios`, `l4re`, `linux`, `macos`, `netbsd`, `none`, `nto`, `openbsd`, `psp`, `redox`, `solaris`, `solid_asp3`, `tvos`, `uefi`, `unknown`, `vita`, `vxworks`, `wasi`, `watchos`, `windows`, `xous`\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n warning: 1 warning emitted"}, {"sha": "34c5d6172d94d68887accf9ebb59c820a9b057a3", "filename": "tests/ui/check-cfg/well-known-names.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fwell-known-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fwell-known-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fwell-known-names.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -4,7 +4,7 @@ warning: unexpected `cfg` condition name\n LL | #[cfg(target_oz = \"linux\")]\n    |       ---------^^^^^^^^^^\n    |       |\n-   |       help: did you mean: `target_os`\n+   |       help: there is a config with a similar name: `target_os`\n    |\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n@@ -14,13 +14,13 @@ warning: unexpected `cfg` condition name\n LL | #[cfg(features = \"foo\")]\n    |       --------^^^^^^^^\n    |       |\n-   |       help: did you mean: `feature`\n+   |       help: there is a config with a similar name: `feature`\n \n warning: unexpected `cfg` condition name\n   --> $DIR/well-known-names.rs:20:7\n    |\n LL | #[cfg(uniw)]\n-   |       ^^^^ help: did you mean: `unix`\n+   |       ^^^^ help: there is a config with a similar name: `unix`\n \n warning: 3 warnings emitted\n "}, {"sha": "2d18cb82e037a25cd28497d9568efc5007d28432", "filename": "tests/ui/check-cfg/well-known-values.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fwell-known-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Fcheck-cfg%2Fwell-known-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fwell-known-values.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -4,9 +4,9 @@ warning: unexpected `cfg` condition value\n LL | #[cfg(target_os = \"linuz\")]\n    |       ^^^^^^^^^^^^-------\n    |                   |\n-   |                   help: did you mean: `\"linux\"`\n+   |                   help: there is a expected value with a similar name: `\"linux\"`\n    |\n-   = note: expected values for `target_os` are: aix, android, cuda, dragonfly, emscripten, espidf, freebsd, fuchsia, haiku, hermit, horizon, illumos, ios, l4re, linux, macos, netbsd, none, nto, openbsd, psp, redox, solaris, solid_asp3, tvos, uefi, unknown, vita, vxworks, wasi, watchos, windows, xous\n+   = note: expected values for `target_os` are: `aix`, `android`, `cuda`, `dragonfly`, `emscripten`, `espidf`, `freebsd`, `fuchsia`, `haiku`, `hermit`, `horizon`, `illumos`, `ios`, `l4re`, `linux`, `macos`, `netbsd`, `none`, `nto`, `openbsd`, `psp`, `redox`, `solaris`, `solid_asp3`, `tvos`, `uefi`, `unknown`, `vita`, `vxworks`, `wasi`, `watchos`, `windows`, `xous`\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n warning: unexpected `cfg` condition value\n@@ -15,9 +15,9 @@ warning: unexpected `cfg` condition value\n LL | #[cfg(target_has_atomic = \"0\")]\n    |       ^^^^^^^^^^^^^^^^^^^^---\n    |                           |\n-   |                           help: did you mean: `\"8\"`\n+   |                           help: there is a expected value with a similar name: `\"8\"`\n    |\n-   = note: expected values for `target_has_atomic` are: 128, 16, 32, 64, 8, ptr\n+   = note: expected values for `target_has_atomic` are: (none), `128`, `16`, `32`, `64`, `8`, `ptr`\n \n warning: unexpected `cfg` condition value\n   --> $DIR/well-known-values.rs:21:7"}, {"sha": "e4b07ab8108e09f5d1a8839bf0c8f94d45d31290", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/basic.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fbasic.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -0,0 +1,7 @@\n+// run-pass\n+\n+#![feature(c_str_literals)]\n+\n+fn main() {\n+    assert_eq!(b\"test\\0\", c\"test\".to_bytes_with_nul());\n+}"}, {"sha": "b27da26ed23bbb776e79c53706ab0280ce20e1b3", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/gate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -0,0 +1,13 @@\n+// gate-test-c_str_literals\n+\n+macro_rules! m {\n+    ($t:tt) => {}\n+}\n+\n+fn main() {\n+    c\"foo\";\n+    //~^ ERROR: `c\"..\"` literals are experimental\n+\n+    m!(c\"test\");\n+    //~^ ERROR: `c\"..\"` literals are experimental\n+}"}, {"sha": "bc0c537aada839c55f02caada18e79a432af73f4", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/gate.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fgate.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: `c\"..\"` literals are experimental\n+  --> $DIR/gate.rs:8:5\n+   |\n+LL |     c\"foo\";\n+   |     ^^^^^^\n+   |\n+   = note: see issue #105723 <https://github.com/rust-lang/rust/issues/105723> for more information\n+   = help: add `#![feature(c_str_literals)]` to the crate attributes to enable\n+\n+error[E0658]: `c\"..\"` literals are experimental\n+  --> $DIR/gate.rs:11:8\n+   |\n+LL |     m!(c\"test\");\n+   |        ^^^^^^^\n+   |\n+   = note: see issue #105723 <https://github.com/rust-lang/rust/issues/105723> for more information\n+   = help: add `#![feature(c_str_literals)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "7bc6097f124aabfded4a9e9791611cfe4fbf9f78", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/no-nuls.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c"}, {"sha": "ff9006f6f97f1be7eed18d188e8c30ba2075743e", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/no-nuls.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fno-nuls.stderr?ref=4b94c232192b0fa0314b5afa18e366356e210c4c"}, {"sha": "82e8e2090d7db5ab2a25083312b18038ef9b295a", "filename": "tests/ui/rfcs/rfc-3348-c-string-literals/non-ascii.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fnon-ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b94c232192b0fa0314b5afa18e366356e210c4c/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fnon-ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-3348-c-string-literals%2Fnon-ascii.rs?ref=4b94c232192b0fa0314b5afa18e366356e210c4c", "patch": "@@ -0,0 +1,10 @@\n+// run-pass\n+\n+#![feature(c_str_literals)]\n+\n+fn main() {\n+    assert_eq!(\n+        c\"\\xEF\\x80\ud83e\udd80\\u{1F980}\".to_bytes_with_nul(),\n+        &[0xEF, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0xF0, 0x9F, 0xA6, 0x80, 0x00],\n+    );\n+}"}]}