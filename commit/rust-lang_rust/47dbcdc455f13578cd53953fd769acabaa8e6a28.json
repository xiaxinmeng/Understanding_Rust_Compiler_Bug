{"sha": "47dbcdc455f13578cd53953fd769acabaa8e6a28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZGJjZGM0NTVmMTM1NzhjZDUzOTUzZmQ3NjlhY2FiYWE4ZTZhMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-27T16:27:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-27T16:27:36Z"}, "message": "auto merge of #6064 : thestinger/rust/char, r=catamorphism", "tree": {"sha": "588c7a84ed616dc8857a8cf875926eb69dc275ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/588c7a84ed616dc8857a8cf875926eb69dc275ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47dbcdc455f13578cd53953fd769acabaa8e6a28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47dbcdc455f13578cd53953fd769acabaa8e6a28", "html_url": "https://github.com/rust-lang/rust/commit/47dbcdc455f13578cd53953fd769acabaa8e6a28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47dbcdc455f13578cd53953fd769acabaa8e6a28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46806b7ae0593154d01eab821a436ac06b1056d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/46806b7ae0593154d01eab821a436ac06b1056d0", "html_url": "https://github.com/rust-lang/rust/commit/46806b7ae0593154d01eab821a436ac06b1056d0"}, {"sha": "6d589f88f79a987de61fce00f0364b4199f50c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d589f88f79a987de61fce00f0364b4199f50c22", "html_url": "https://github.com/rust-lang/rust/commit/6d589f88f79a987de61fce00f0364b4199f50c22"}], "stats": {"total": 125, "additions": 56, "deletions": 69}, "files": [{"sha": "ef2bd91e97313d85c75c851eef784a56dc89879c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/47dbcdc455f13578cd53953fd769acabaa8e6a28/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dbcdc455f13578cd53953fd769acabaa8e6a28/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=47dbcdc455f13578cd53953fd769acabaa8e6a28", "patch": "@@ -10,6 +10,7 @@\n \n //! Utilities for manipulating the char type\n \n+use cmp::Ord;\n use option::{None, Option, Some};\n use str;\n use u32;\n@@ -243,26 +244,26 @@ pub fn len_utf8_bytes(c: char) -> uint {\n     else { fail!(~\"invalid character!\") }\n }\n \n-/**\n- * Compare two chars\n- *\n- * # Return value\n- *\n- * -1 if a < b, 0 if a == b, +1 if a > b\n- */\n-#[inline(always)]\n-pub fn cmp(a: char, b: char) -> int {\n-    return  if b > a { -1 }\n-    else if b < a { 1 }\n-    else { 0 }\n-}\n-\n #[cfg(notest)]\n impl Eq for char {\n+    #[inline(always)]\n     fn eq(&self, other: &char) -> bool { (*self) == (*other) }\n+    #[inline(always)]\n     fn ne(&self, other: &char) -> bool { (*self) != (*other) }\n }\n \n+#[cfg(notest)]\n+impl Ord for char {\n+    #[inline(always)]\n+    fn lt(&self, other: &char) -> bool { *self < *other }\n+    #[inline(always)]\n+    fn le(&self, other: &char) -> bool { *self <= *other }\n+    #[inline(always)]\n+    fn gt(&self, other: &char) -> bool { *self > *other }\n+    #[inline(always)]\n+    fn ge(&self, other: &char) -> bool { *self >= *other }\n+}\n+\n #[test]\n fn test_is_lowercase() {\n     assert!(is_lowercase('a'));"}, {"sha": "b933b60a39f1f3891b9a5f53f8a041d5f2c6cbb2", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47dbcdc455f13578cd53953fd769acabaa8e6a28/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dbcdc455f13578cd53953fd769acabaa8e6a28/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=47dbcdc455f13578cd53953fd769acabaa8e6a28", "patch": "@@ -64,6 +64,8 @@ totaleq_impl!(i64)\n totaleq_impl!(int)\n totaleq_impl!(uint)\n \n+totaleq_impl!(char)\n+\n #[deriving(Clone, Eq)]\n pub enum Ordering { Less = -1, Equal = 0, Greater = 1 }\n \n@@ -116,6 +118,8 @@ totalord_impl!(i64)\n totalord_impl!(int)\n totalord_impl!(uint)\n \n+totalord_impl!(char)\n+\n pub fn cmp2<A:TotalOrd,B:TotalOrd>(\n     a1: &A, b1: &B,\n     a2: &A, b2: &B) -> Ordering"}, {"sha": "a5793462327e21c3ef9dc814f140affd45707d77", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 37, "deletions": 55, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/47dbcdc455f13578cd53953fd769acabaa8e6a28/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47dbcdc455f13578cd53953fd769acabaa8e6a28/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=47dbcdc455f13578cd53953fd769acabaa8e6a28", "patch": "@@ -33,11 +33,7 @@\n  * * access to a character by index is logarithmic (linear in strings);\n  */\n \n-use core::option;\n use core::prelude::*;\n-use core::str;\n-use core::uint;\n-use core::vec;\n \n /// The type of ropes.\n pub type Rope = node::Root;\n@@ -215,8 +211,8 @@ pub fn bal(rope:Rope) -> Rope {\n     match (rope) {\n       node::Empty => return rope,\n       node::Content(x) => match (node::bal(x)) {\n-        option::None    => rope,\n-        option::Some(y) => node::Content(y)\n+        None    => rope,\n+        Some(y) => node::Content(y)\n       }\n     }\n }\n@@ -558,13 +554,7 @@ pub fn char_at(rope: Rope, pos: uint) -> char {\n pub mod node {\n     use rope::node;\n \n-    use core::cast;\n-    use core::char;\n-    use core::option;\n     use core::prelude::*;\n-    use core::str;\n-    use core::uint;\n-    use core::vec;\n \n     /// Implementation of type `rope`\n     pub enum Root {\n@@ -835,8 +825,8 @@ pub mod node {\n             let mut it = leaf_iterator::start(node);\n             loop {\n                 match leaf_iterator::next(&mut it) {\n-                  option::None => break,\n-                  option::Some(x) => {\n+                  None => break,\n+                  Some(x) => {\n                     //FIXME (#2744): Replace with memcpy or something similar\n                     let local_buf: ~[u8] = cast::transmute(*x.content);\n                     let mut i = x.byte_offset;\n@@ -885,24 +875,24 @@ pub mod node {\n      *\n      * # Return value\n      *\n-     * * `option::None` if no transformation happened\n-     * * `option::Some(x)` otherwise, in which case `x` has the same contents\n+     * * `None` if no transformation happened\n+     * * `Some(x)` otherwise, in which case `x` has the same contents\n      *    as `node` bot lower height and/or fragmentation.\n      */\n     pub fn bal(node: @Node) -> Option<@Node> {\n-        if height(node) < hint_max_node_height { return option::None; }\n+        if height(node) < hint_max_node_height { return None; }\n         //1. Gather all leaves as a forest\n         let mut forest = ~[];\n         let mut it = leaf_iterator::start(node);\n         loop {\n             match leaf_iterator::next(&mut it) {\n-              option::None    => break,\n-              option::Some(x) => forest.push(@Leaf(x))\n+              None    => break,\n+              Some(x) => forest.push(@Leaf(x))\n             }\n         }\n         //2. Rebuild tree from forest\n         let root = @*tree_from_forest_destructive(forest);\n-        return option::Some(root);\n+        return Some(root);\n \n     }\n \n@@ -1061,14 +1051,14 @@ pub mod node {\n         while result == 0 {\n             match (char_iterator::next(&mut ita), char_iterator::next(&mut itb))\n             {\n-              (option::None, option::None) => break,\n-              (option::Some(chara), option::Some(charb)) => {\n-                result = char::cmp(chara, charb);\n+              (None, None) => break,\n+              (Some(chara), Some(charb)) => {\n+                result = chara.cmp(&charb) as int;\n               }\n-              (option::Some(_), _) => {\n+              (Some(_), _) => {\n                 result = 1;\n               }\n-              (_, option::Some(_)) => {\n+              (_, Some(_)) => {\n                 result = -1;\n               }\n             }\n@@ -1145,9 +1135,7 @@ pub mod node {\n     pub mod leaf_iterator {\n         use rope::node::{Concat, Leaf, Node, height};\n \n-        use core::option;\n         use core::prelude::*;\n-        use core::vec;\n \n         pub struct T {\n             stack: ~[@Node],\n@@ -1168,7 +1156,7 @@ pub mod node {\n         }\n \n         pub fn next(it: &mut T) -> Option<Leaf> {\n-            if it.stackpos < 0 { return option::None; }\n+            if it.stackpos < 0 { return None; }\n             loop {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n@@ -1179,7 +1167,7 @@ pub mod node {\n                     it.stackpos += 1;\n                     it.stack[it.stackpos] = x.left;\n                   }\n-                  Leaf(x) => return option::Some(x)\n+                  Leaf(x) => return Some(x)\n                 }\n             };\n         }\n@@ -1189,9 +1177,7 @@ pub mod node {\n         use rope::node::{Leaf, Node};\n         use rope::node::leaf_iterator;\n \n-        use core::option;\n         use core::prelude::*;\n-        use core::str;\n \n         pub struct T {\n             leaf_iterator: leaf_iterator::T,\n@@ -1202,28 +1188,28 @@ pub mod node {\n         pub fn start(node: @Node) -> T {\n             T {\n                 leaf_iterator: leaf_iterator::start(node),\n-                leaf: option::None,\n+                leaf: None,\n                 leaf_byte_pos: 0u,\n             }\n         }\n \n         pub fn empty() -> T {\n             T {\n                 leaf_iterator: leaf_iterator::empty(),\n-                leaf:  option::None,\n+                leaf: None,\n                 leaf_byte_pos: 0u,\n             }\n         }\n \n         pub fn next(it: &mut T) -> Option<char> {\n             loop {\n                 match get_current_or_next_leaf(it) {\n-                  option::None => return option::None,\n-                  option::Some(_) => {\n+                  None => return None,\n+                  Some(_) => {\n                     let next_char = get_next_char_in_leaf(it);\n                     match next_char {\n-                      option::None => loop,\n-                      option::Some(_) => return next_char\n+                      None => loop,\n+                      Some(_) => return next_char\n                     }\n                   }\n                 }\n@@ -1232,12 +1218,12 @@ pub mod node {\n \n         pub fn get_current_or_next_leaf(it: &mut T) -> Option<Leaf> {\n             match it.leaf {\n-              option::Some(_) => return it.leaf,\n-              option::None => {\n+              Some(_) => return it.leaf,\n+              None => {\n                 let next = leaf_iterator::next(&mut it.leaf_iterator);\n                 match next {\n-                  option::None => return option::None,\n-                  option::Some(_) => {\n+                  None => return None,\n+                  Some(_) => {\n                     it.leaf          = next;\n                     it.leaf_byte_pos = 0u;\n                     return next;\n@@ -1249,20 +1235,20 @@ pub mod node {\n \n         pub fn get_next_char_in_leaf(it: &mut T) -> Option<char> {\n             match copy it.leaf {\n-              option::None => return option::None,\n-              option::Some(aleaf) => {\n+              None => return None,\n+              Some(aleaf) => {\n                 if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n-                    it.leaf = option::None;\n-                    return option::None\n+                    it.leaf = None;\n+                    return None\n                 } else {\n                     let range =\n                         str::char_range_at(*aleaf.content,\n                                      (*it).leaf_byte_pos + aleaf.byte_offset);\n                     let ch = range.ch;\n                     let next = range.next;\n                     (*it).leaf_byte_pos = next - aleaf.byte_offset;\n-                    return option::Some(ch)\n+                    return Some(ch)\n                 }\n               }\n             }\n@@ -1273,11 +1259,7 @@ pub mod node {\n #[cfg(test)]\n mod tests {\n     use rope::*;\n-\n-    use core::option;\n-    use core::str;\n-    use core::uint;\n-    use core::vec;\n+    use core::prelude::*;\n \n     //Utility function, used for sanity check\n     fn rope_to_string(r: Rope) -> ~str {\n@@ -1341,11 +1323,11 @@ mod tests {\n         let mut equal = true;\n         while equal {\n             match (node::char_iterator::next(&mut rope_iter)) {\n-              option::None => {\n+              None => {\n                 if string_iter < string_len {\n                     equal = false;\n                 } break; }\n-              option::Some(c) => {\n+              Some(c) => {\n                 let range = str::char_range_at(*sample, string_iter);\n                 string_iter = range.next;\n                 if range.ch != c { equal = false; break; }\n@@ -1373,8 +1355,8 @@ mod tests {\n         let mut it  = iterator::char::start(r);\n         loop {\n             match (node::char_iterator::next(&mut it)) {\n-              option::None => break,\n-              option::Some(_) => len += 1u\n+              None => break,\n+              Some(_) => len += 1u\n             }\n         }\n "}]}