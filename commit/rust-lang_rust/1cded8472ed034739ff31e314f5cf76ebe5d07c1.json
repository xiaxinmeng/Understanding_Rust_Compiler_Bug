{"sha": "1cded8472ed034739ff31e314f5cf76ebe5d07c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZGVkODQ3MmVkMDM0NzM5ZmYzMWUzMTRmNWNmNzZlYmU1ZDA3YzE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-18T02:10:13Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-05-25T05:51:12Z"}, "message": "Remove `trait_item_map`, clean up `resolver.with_type_parameter_rib()`.", "tree": {"sha": "3380526fffbbde3308fa7f370178e12b8bf3586e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3380526fffbbde3308fa7f370178e12b8bf3586e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cded8472ed034739ff31e314f5cf76ebe5d07c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cded8472ed034739ff31e314f5cf76ebe5d07c1", "html_url": "https://github.com/rust-lang/rust/commit/1cded8472ed034739ff31e314f5cf76ebe5d07c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cded8472ed034739ff31e314f5cf76ebe5d07c1/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a1d2edb821e123586049f349bb4aaee2d001cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a1d2edb821e123586049f349bb4aaee2d001cc6", "html_url": "https://github.com/rust-lang/rust/commit/2a1d2edb821e123586049f349bb4aaee2d001cc6"}], "stats": {"total": 130, "additions": 73, "deletions": 57}, "files": [{"sha": "18798962df1beabf71afd46295407f6afc207c7f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1cded8472ed034739ff31e314f5cf76ebe5d07c1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cded8472ed034739ff31e314f5cf76ebe5d07c1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1cded8472ed034739ff31e314f5cf76ebe5d07c1", "patch": "@@ -478,9 +478,10 @@ impl<'a> Resolver<'a> {\n                     self.define(module, ident, ns, (child.def, ty::Visibility::Public,\n                                                     DUMMY_SP, Mark::root()));\n \n-                    let has_self = self.session.cstore.associated_item_cloned(child.def.def_id())\n-                                       .method_has_self_argument;\n-                    self.trait_item_map.insert((def_id, child.name, ns), (child.def, has_self));\n+                    if self.session.cstore.associated_item_cloned(child.def.def_id())\n+                           .method_has_self_argument {\n+                        self.has_self.insert(child.def.def_id());\n+                    }\n                 }\n                 module.populated.set(true);\n             }\n@@ -773,7 +774,6 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_trait_item(&mut self, item: &'a TraitItem) {\n         let parent = self.resolver.current_module;\n-        let def_id = parent.def_id().unwrap();\n \n         if let TraitItemKind::Macro(_) = item.node {\n             self.visit_invoc(item.id);\n@@ -782,16 +782,18 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n         // Add the item to the trait info.\n         let item_def_id = self.resolver.definitions.local_def_id(item.id);\n-        let (def, ns, has_self) = match item.node {\n-            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS, false),\n-            TraitItemKind::Method(ref sig, _) =>\n-                (Def::Method(item_def_id), ValueNS, sig.decl.has_self()),\n-            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS, false),\n+        let (def, ns) = match item.node {\n+            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+            TraitItemKind::Method(ref sig, _) => {\n+                if sig.decl.has_self() {\n+                    self.resolver.has_self.insert(item_def_id);\n+                }\n+                (Def::Method(item_def_id), ValueNS)\n+            }\n+            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n             TraitItemKind::Macro(_) => bug!(),  // handled above\n         };\n \n-        self.resolver.trait_item_map.insert((def_id, item.ident.name, ns), (def, has_self));\n-\n         let vis = ty::Visibility::Public;\n         self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));\n "}, {"sha": "6d8ca09935cff3ae4f1139e99bda83b28316578c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1cded8472ed034739ff31e314f5cf76ebe5d07c1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cded8472ed034739ff31e314f5cf76ebe5d07c1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1cded8472ed034739ff31e314f5cf76ebe5d07c1", "patch": "@@ -1111,7 +1111,8 @@ pub struct Resolver<'a> {\n \n     prelude: Option<Module<'a>>,\n \n-    trait_item_map: FxHashMap<(DefId, Name, Namespace), (Def, bool /* has self */)>,\n+    // n.b. This is used only for better diagnostics, not name resolution itself.\n+    has_self: FxHashSet<DefId>,\n \n     // Names of fields of an item `DefId` accessible with dot syntax.\n     // Used for hints during error reporting.\n@@ -1134,7 +1135,7 @@ pub struct Resolver<'a> {\n     label_ribs: Vec<Rib<'a>>,\n \n     // The trait that the current context can refer to.\n-    current_trait_ref: Option<(DefId, TraitRef)>,\n+    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n \n     // The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n@@ -1337,7 +1338,7 @@ impl<'a> Resolver<'a> {\n             graph_root: graph_root,\n             prelude: None,\n \n-            trait_item_map: FxHashMap(),\n+            has_self: FxHashSet(),\n             field_names: FxHashMap(),\n \n             determined_imports: Vec::new(),\n@@ -1750,22 +1751,21 @@ impl<'a> Resolver<'a> {\n                 let mut function_type_rib = Rib::new(rib_kind);\n                 let mut seen_bindings = FxHashMap();\n                 for type_parameter in &generics.ty_params {\n-                    let name = type_parameter.ident.name;\n+                    let ident = type_parameter.ident.unhygienize();\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n-                    if seen_bindings.contains_key(&name) {\n-                        let span = seen_bindings.get(&name).unwrap();\n-                        resolve_error(self,\n-                                      type_parameter.span,\n-                                      ResolutionError::NameAlreadyUsedInTypeParameterList(name,\n-                                                                                          span));\n+                    if seen_bindings.contains_key(&ident) {\n+                        let span = seen_bindings.get(&ident).unwrap();\n+                        let err =\n+                            ResolutionError::NameAlreadyUsedInTypeParameterList(ident.name, span);\n+                        resolve_error(self, type_parameter.span, err);\n                     }\n-                    seen_bindings.entry(name).or_insert(type_parameter.span);\n+                    seen_bindings.entry(ident).or_insert(type_parameter.span);\n \n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(def_id);\n-                    function_type_rib.bindings.insert(Ident::with_empty_ctxt(name), def);\n+                    function_type_rib.bindings.insert(ident, def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n                 self.ribs[TypeNS].push(function_type_rib);\n@@ -1825,11 +1825,20 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            let def = self.smart_resolve_path(trait_ref.ref_id, None,\n-                                              &trait_ref.path, PathSource::Trait).base_def();\n+            let path: Vec<_> = trait_ref.path.segments.iter().map(|seg| seg.identifier).collect();\n+            let def = self.smart_resolve_path_fragment(trait_ref.ref_id,\n+                                                       None,\n+                                                       &path,\n+                                                       trait_ref.path.span,\n+                                                       trait_ref.path.segments.last().unwrap().span,\n+                                                       PathSource::Trait)\n+                .base_def();\n             if def != Def::Err {\n-                new_val = Some((def.def_id(), trait_ref.clone()));\n                 new_id = Some(def.def_id());\n+                let span = trait_ref.path.span;\n+                if let PathResult::Module(module) = self.resolve_path(&path, None, false, span) {\n+                    new_val = Some((module, trait_ref.clone()));\n+                }\n             }\n         }\n         let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n@@ -1880,7 +1889,7 @@ impl<'a> Resolver<'a> {\n                                     ImplItemKind::Const(..) => {\n                                         // If this is a trait impl, ensure the const\n                                         // exists in trait\n-                                        this.check_trait_item(impl_item.ident.name,\n+                                        this.check_trait_item(impl_item.ident,\n                                                             ValueNS,\n                                                             impl_item.span,\n                                             |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n@@ -1889,7 +1898,7 @@ impl<'a> Resolver<'a> {\n                                     ImplItemKind::Method(ref sig, _) => {\n                                         // If this is a trait impl, ensure the method\n                                         // exists in trait\n-                                        this.check_trait_item(impl_item.ident.name,\n+                                        this.check_trait_item(impl_item.ident,\n                                                             ValueNS,\n                                                             impl_item.span,\n                                             |n, s| ResolutionError::MethodNotMemberOfTrait(n, s));\n@@ -1906,7 +1915,7 @@ impl<'a> Resolver<'a> {\n                                     ImplItemKind::Type(ref ty) => {\n                                         // If this is a trait impl, ensure the type\n                                         // exists in trait\n-                                        this.check_trait_item(impl_item.ident.name,\n+                                        this.check_trait_item(impl_item.ident,\n                                                             TypeNS,\n                                                             impl_item.span,\n                                             |n, s| ResolutionError::TypeNotMemberOfTrait(n, s));\n@@ -1924,15 +1933,15 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n-    fn check_trait_item<F>(&self, name: Name, ns: Namespace, span: Span, err: F)\n+    fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n         where F: FnOnce(Name, &str) -> ResolutionError\n     {\n         // If there is a TraitRef in scope for an impl, then the method must be in the\n         // trait.\n-        if let Some((did, ref trait_ref)) = self.current_trait_ref {\n-            if !self.trait_item_map.contains_key(&(did, name, ns)) {\n-                let path_str = path_names_to_string(&trait_ref.path);\n-                resolve_error(self, span, err(name, &path_str));\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if self.resolve_ident_in_module(module, ident, ns, false, false, span).is_err() {\n+                let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n+                resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n             }\n         }\n     }\n@@ -2302,15 +2311,16 @@ impl<'a> Resolver<'a> {\n             }\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n-            let name = path.last().unwrap().name;\n-            let candidates = this.lookup_import_candidates(name, ns, is_expected);\n+            let ident = *path.last().unwrap();\n+            let candidates = this.lookup_import_candidates(ident.name, ns, is_expected);\n             if !candidates.is_empty() {\n                 let mut module_span = this.current_module.span;\n                 module_span.hi = module_span.lo;\n                 // Report import candidates as help and proceed searching for labels.\n                 show_candidates(&mut err, module_span, &candidates, def.is_some());\n             } else if is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n-                let enum_candidates = this.lookup_import_candidates(name, ns, is_enum_variant);\n+                let enum_candidates =\n+                    this.lookup_import_candidates(ident.name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n                     .map(|suggestion| import_candidate_to_paths(&suggestion)).collect::<Vec<_>>();\n                 enum_candidates.sort();\n@@ -2326,7 +2336,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             if path.len() == 1 && this.self_type_is_available(span) {\n-                if let Some(candidate) = this.lookup_assoc_candidate(name, ns, is_expected) {\n+                if let Some(candidate) = this.lookup_assoc_candidate(ident, ns, is_expected) {\n                     let self_is_available = this.self_value_is_available(path[0].ctxt, span);\n                     match candidate {\n                         AssocSuggestion::Field => {\n@@ -2440,7 +2450,7 @@ impl<'a> Resolver<'a> {\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n-                    let item_name = path.last().unwrap().name;\n+                    let item_name = *path.last().unwrap();\n                     let traits = self.get_traits_containing_item(item_name, ns);\n                     self.trait_map.insert(id, traits);\n                 }\n@@ -2819,7 +2829,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n-                                        name: Name,\n+                                        ident: Ident,\n                                         ns: Namespace,\n                                         filter_fn: FilterFn)\n                                         -> Option<AssocSuggestion>\n@@ -2845,7 +2855,7 @@ impl<'a> Resolver<'a> {\n                         Def::Struct(did) | Def::Union(did)\n                                 if resolution.unresolved_segments() == 0 => {\n                             if let Some(field_names) = self.field_names.get(&did) {\n-                                if field_names.iter().any(|&field_name| name == field_name) {\n+                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n                                     return Some(AssocSuggestion::Field);\n                                 }\n                             }\n@@ -2857,10 +2867,12 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Look for associated items in the current trait.\n-        if let Some((trait_did, _)) = self.current_trait_ref {\n-            if let Some(&(def, has_self)) = self.trait_item_map.get(&(trait_did, name, ns)) {\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if let Ok(binding) =\n+                    self.resolve_ident_in_module(module, ident, ns, false, false, module.span) {\n+                let def = binding.def();\n                 if filter_fn(def) {\n-                    return Some(if has_self {\n+                    return Some(if self.has_self.contains(&def.def_id()) {\n                         AssocSuggestion::MethodWithSelf\n                     } else {\n                         AssocSuggestion::AssocItem\n@@ -3081,13 +3093,13 @@ impl<'a> Resolver<'a> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(name.node.name, ValueNS);\n+                let traits = self.get_traits_containing_item(name.node, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(name, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\",\n                        expr.id);\n-                let traits = self.get_traits_containing_item(name.node.name, ValueNS);\n+                let traits = self.get_traits_containing_item(name.node, ValueNS);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3096,20 +3108,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn get_traits_containing_item(&mut self, name: Name, ns: Namespace) -> Vec<TraitCandidate> {\n-        debug!(\"(getting traits containing item) looking for '{}'\", name);\n+    fn get_traits_containing_item(&mut self, ident: Ident, ns: Namespace) -> Vec<TraitCandidate> {\n+        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n \n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n-        if let Some((trait_def_id, _)) = self.current_trait_ref {\n-            if self.trait_item_map.contains_key(&(trait_def_id, name, ns)) {\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: None });\n+        if let Some((module, _)) = self.current_trait_ref {\n+            if self.resolve_ident_in_module(module, ident, ns, false, false, module.span).is_ok() {\n+                let def_id = module.def_id().unwrap();\n+                found_traits.push(TraitCandidate { def_id: def_id, import_id: None });\n             }\n         }\n \n         let mut search_module = self.current_module;\n         loop {\n-            self.get_traits_in_module_containing_item(name, ns, search_module, &mut found_traits);\n+            self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n             match search_module.kind {\n                 ModuleKind::Block(..) => search_module = search_module.parent.unwrap(),\n                 _ => break,\n@@ -3118,17 +3131,17 @@ impl<'a> Resolver<'a> {\n \n         if let Some(prelude) = self.prelude {\n             if !search_module.no_implicit_prelude {\n-                self.get_traits_in_module_containing_item(name, ns, prelude, &mut found_traits);\n+                self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n             }\n         }\n \n         found_traits\n     }\n \n     fn get_traits_in_module_containing_item(&mut self,\n-                                            name: Name,\n+                                            ident: Ident,\n                                             ns: Namespace,\n-                                            module: Module,\n+                                            module: Module<'a>,\n                                             found_traits: &mut Vec<TraitCandidate>) {\n         let mut traits = module.traits.borrow_mut();\n         if traits.is_none() {\n@@ -3143,8 +3156,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            let trait_def_id = binding.def().def_id();\n-            if self.trait_item_map.contains_key(&(trait_def_id, name, ns)) {\n+            let module = binding.module().unwrap();\n+            if self.resolve_ident_in_module(module, ident, ns, false, false, module.span).is_ok() {\n                 let import_id = match binding.kind {\n                     NameBindingKind::Import { directive, .. } => {\n                         self.maybe_unused_trait_imports.insert(directive.id);\n@@ -3153,6 +3166,7 @@ impl<'a> Resolver<'a> {\n                     }\n                     _ => None,\n                 };\n+                let trait_def_id = module.def_id().unwrap();\n                 found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n             }\n         }"}]}