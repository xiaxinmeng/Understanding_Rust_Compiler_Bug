{"sha": "bf321ece1e5756493b1ac061cd87a48123cda52c", "node_id": "C_kwDOAAsO6NoAKGJmMzIxZWNlMWU1NzU2NDkzYjFhYzA2MWNkODdhNDgxMjNjZGE1MmM", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-01-27T03:57:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-27T03:57:54Z"}, "message": "Rollup merge of #106856 - vadorovsky:fix-atomic-annotations, r=joshtriplett\n\ncore: Support variety of atomic widths in width-agnostic functions\n\nBefore this change, the following functions and macros were annotated with `#[cfg(target_has_atomic = \"8\")]` or\n`#[cfg(target_has_atomic_load_store = \"8\")]`:\n\n* `atomic_int`\n* `strongest_failure_ordering`\n* `atomic_swap`\n* `atomic_add`\n* `atomic_sub`\n* `atomic_compare_exchange`\n* `atomic_compare_exchange_weak`\n* `atomic_and`\n* `atomic_nand`\n* `atomic_or`\n* `atomic_xor`\n* `atomic_max`\n* `atomic_min`\n* `atomic_umax`\n* `atomic_umin`\n\nHowever, none of those functions and macros actually depend on 8-bit width and they are needed for all atomic widths (16-bit, 32-bit, 64-bit etc.). Some targets might not support 8-bit atomics (i.e. BPF, if we would enable atomic CAS for it).\n\nThis change fixes that by removing the `\"8\"` argument from annotations, which results in accepting the whole variety of widths.\n\nFixes #106845\nFixes #106795\n\nSigned-off-by: Michal Rostecki <vadorovsky@gmail.com>", "tree": {"sha": "7d8521db9dac409e6449a8695ab43e4781d58ba3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d8521db9dac409e6449a8695ab43e4781d58ba3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf321ece1e5756493b1ac061cd87a48123cda52c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj00vCCRBK7hj4Ov3rIwAAAZMIACPNX2NjA7sF/9PbYSwMS2xv\nguKywKrg5VpIOuVufijw55is+oWgo1DGzXkLLohCBZgZOBjvwjPH2p7a7UUmb972\nCzgnmNDH9hHfQedDJ+O1Y5A6NPFhJ3gVbpkIfcwOZwKcqdQ9Mmi+v9IKo3EoZH8g\nnrFvVtl12wscCvg3zOyg8U4bry4i4tPWI+66UqXiZ/VUdn6K5uIB59/XTldeDj6I\nPCm6zbGRXEfyEHARVqde3UT4UkECA6Ef2Z7Yl/T+eCBclfP29hJLtXv2uC0LBHTJ\nTReLkS35ujOzWIOoHHuulODukkYNJcWogxnkBca7xXR0QQwJw7zhGZIfjnaV59A=\n=yjjZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 7d8521db9dac409e6449a8695ab43e4781d58ba3\nparent 4b4aeae359fae65d844d7b557f9ab262d6ae6a5e\nparent 474ea87943c3077feb7d7f2a6f295bd06654ef82\nauthor Yuki Okushi <jtitor@2k36.org> 1674791874 +0900\ncommitter GitHub <noreply@github.com> 1674791874 +0900\n\nRollup merge of #106856 - vadorovsky:fix-atomic-annotations, r=joshtriplett\n\ncore: Support variety of atomic widths in width-agnostic functions\n\nBefore this change, the following functions and macros were annotated with `#[cfg(target_has_atomic = \"8\")]` or\n`#[cfg(target_has_atomic_load_store = \"8\")]`:\n\n* `atomic_int`\n* `strongest_failure_ordering`\n* `atomic_swap`\n* `atomic_add`\n* `atomic_sub`\n* `atomic_compare_exchange`\n* `atomic_compare_exchange_weak`\n* `atomic_and`\n* `atomic_nand`\n* `atomic_or`\n* `atomic_xor`\n* `atomic_max`\n* `atomic_min`\n* `atomic_umax`\n* `atomic_umin`\n\nHowever, none of those functions and macros actually depend on 8-bit width and they are needed for all atomic widths (16-bit, 32-bit, 64-bit etc.). Some targets might not support 8-bit atomics (i.e. BPF, if we would enable atomic CAS for it).\n\nThis change fixes that by removing the `\"8\"` argument from annotations, which results in accepting the whole variety of widths.\n\nFixes #106845\nFixes #106795\n\nSigned-off-by: Michal Rostecki <vadorovsky@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf321ece1e5756493b1ac061cd87a48123cda52c", "html_url": "https://github.com/rust-lang/rust/commit/bf321ece1e5756493b1ac061cd87a48123cda52c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf321ece1e5756493b1ac061cd87a48123cda52c/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b4aeae359fae65d844d7b557f9ab262d6ae6a5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b4aeae359fae65d844d7b557f9ab262d6ae6a5e", "html_url": "https://github.com/rust-lang/rust/commit/4b4aeae359fae65d844d7b557f9ab262d6ae6a5e"}, {"sha": "474ea87943c3077feb7d7f2a6f295bd06654ef82", "url": "https://api.github.com/repos/rust-lang/rust/commits/474ea87943c3077feb7d7f2a6f295bd06654ef82", "html_url": "https://github.com/rust-lang/rust/commit/474ea87943c3077feb7d7f2a6f295bd06654ef82"}], "stats": {"total": 53, "additions": 38, "deletions": 15}, "files": [{"sha": "db95b8bca2f8ce78791f77dfd1cb801dd9151c50", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf321ece1e5756493b1ac061cd87a48123cda52c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf321ece1e5756493b1ac061cd87a48123cda52c/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=bf321ece1e5756493b1ac061cd87a48123cda52c", "patch": "@@ -945,6 +945,7 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n     if sess.target.has_thread_local {\n         ret.insert((sym::target_thread_local, None));\n     }\n+    let mut has_atomic = false;\n     for (i, align) in [\n         (8, layout.i8_align.abi),\n         (16, layout.i16_align.abi),\n@@ -953,6 +954,7 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n         (128, layout.i128_align.abi),\n     ] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n+            has_atomic = true;\n             let mut insert_atomic = |s, align: Align| {\n                 ret.insert((sym::target_has_atomic_load_store, Some(Symbol::intern(s))));\n                 if atomic_cas {\n@@ -969,6 +971,12 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n             }\n         }\n     }\n+    if sess.is_nightly_build() && has_atomic {\n+        ret.insert((sym::target_has_atomic_load_store, None));\n+        if atomic_cas {\n+            ret.insert((sym::target_has_atomic, None));\n+        }\n+    }\n \n     let panic_strategy = sess.panic_strategy();\n     ret.insert((sym::panic, Some(panic_strategy.desc_symbol())));"}, {"sha": "818721062d7f702aeba8df4096d55fbc6456427e", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bf321ece1e5756493b1ac061cd87a48123cda52c/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf321ece1e5756493b1ac061cd87a48123cda52c/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=bf321ece1e5756493b1ac061cd87a48123cda52c", "patch": "@@ -1861,7 +1861,8 @@ macro_rules! if_not_8_bit {\n     ($_:ident, $($tt:tt)*) => { $($tt)* };\n }\n \n-#[cfg(target_has_atomic_load_store = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic_load_store))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n     ($cfg_cas:meta,\n      $cfg_align:meta,\n@@ -2988,7 +2989,8 @@ atomic_int_ptr_sized! {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -3030,7 +3032,8 @@ unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n@@ -3047,7 +3050,8 @@ unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n@@ -3064,7 +3068,8 @@ unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n@@ -3080,7 +3085,8 @@ unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange<T: Copy>(\n     dst: *mut T,\n@@ -3115,7 +3121,8 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     dst: *mut T,\n@@ -3150,7 +3157,8 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_and`\n@@ -3166,7 +3174,8 @@ unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n@@ -3182,7 +3191,8 @@ unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_or`\n@@ -3198,7 +3208,8 @@ unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n@@ -3215,7 +3226,8 @@ unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_max`\n@@ -3232,7 +3244,8 @@ unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_min`\n@@ -3249,7 +3262,8 @@ unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (unsigned comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n@@ -3266,7 +3280,8 @@ unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (unsigned comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umin`"}]}