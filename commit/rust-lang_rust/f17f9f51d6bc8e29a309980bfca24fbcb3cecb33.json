{"sha": "f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxN2Y5ZjUxZDZiYzhlMjlhMzA5OTgwYmZjYTI0ZmJjYjNjZWNiMzM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-01T18:52:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-01T18:52:39Z"}, "message": "Merge #7834\n\n7834: Fix `find_path` when inner items are present r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/7750 (but adds a bunch of FIXMEs, because a lot of this code is still wrong in the presence of inner items)\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "8543c2d9e7f631b57f917f8d300db0d5bde4f2e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8543c2d9e7f631b57f917f8d300db0d5bde4f2e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgPTf3CRBK7hj4Ov3rIwAAdHIIAGMyvswJeWxQJSKw/jaiI6Wf\nQ+arI+2eFFnyuujXT0WWRxZBy7ktLh0PhbWYW4NT1hhGm+b3DB4IXv3LWuGCK1Fg\nQ8NNVcOrojl/YkQtgKp2j7MnybfktdtpPTbU0RPb5hKursh76u5nhHaXt2Q2NQI2\nvTiBjS1GPIK0zjJqsqsWzo+Tuoest5hKf2rdZdLKQCOWhRw5WQkoC/DgaXrozMQ7\nsH4f/6lIkwlt18UBL/YzwSC77LXMJWIFEc8Sb9eOxdj1zMTKZ86clGwTz8Nv02mw\n0rmiwHAR4rZA+tTih7nfqAMZSIQXnP418LOWdwko6ycVLVy2MmhDhF/HwMM00Us=\n=nRqC\n-----END PGP SIGNATURE-----\n", "payload": "tree 8543c2d9e7f631b57f917f8d300db0d5bde4f2e8\nparent 9860a396035f61a5cc9265c1104a640547bded51\nparent 0dcec31553f0fe42d7c18e6471655e8fa2258bfc\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614624759 +0000\ncommitter GitHub <noreply@github.com> 1614624759 +0000\n\nMerge #7834\n\n7834: Fix `find_path` when inner items are present r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/7750 (but adds a bunch of FIXMEs, because a lot of this code is still wrong in the presence of inner items)\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "html_url": "https://github.com/rust-lang/rust/commit/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9860a396035f61a5cc9265c1104a640547bded51", "url": "https://api.github.com/repos/rust-lang/rust/commits/9860a396035f61a5cc9265c1104a640547bded51", "html_url": "https://github.com/rust-lang/rust/commit/9860a396035f61a5cc9265c1104a640547bded51"}, {"sha": "0dcec31553f0fe42d7c18e6471655e8fa2258bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dcec31553f0fe42d7c18e6471655e8fa2258bfc", "html_url": "https://github.com/rust-lang/rust/commit/0dcec31553f0fe42d7c18e6471655e8fa2258bfc"}], "stats": {"total": 116, "additions": 88, "deletions": 28}, "files": [{"sha": "3e19a770274d7026d85930e984384168da6c4a0b", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "patch": "@@ -1,5 +1,7 @@\n //! An algorithm to find a path to refer to a certain item.\n \n+use std::iter;\n+\n use hir_expand::name::{known, AsName, Name};\n use rustc_hash::FxHashSet;\n use test_utils::mark;\n@@ -95,7 +97,7 @@ fn find_path_inner(\n     item: ItemInNs,\n     from: ModuleId,\n     max_len: usize,\n-    prefixed: Option<PrefixKind>,\n+    mut prefixed: Option<PrefixKind>,\n ) -> Option<ModPath> {\n     if max_len == 0 {\n         return None;\n@@ -114,8 +116,9 @@ fn find_path_inner(\n     }\n \n     // - if the item is the crate root, return `crate`\n-    let root = def_map.module_id(def_map.root());\n+    let root = def_map.crate_root(db);\n     if item == ItemInNs::Types(ModuleDefId::ModuleId(root)) && def_map.block_id().is_none() {\n+        // FIXME: the `block_id()` check should be unnecessary, but affects the result\n         return Some(ModPath::from_segments(PathKind::Crate, Vec::new()));\n     }\n \n@@ -165,7 +168,7 @@ fn find_path_inner(\n \n     // - otherwise, look for modules containing (reexporting) it and import it from one of those\n \n-    let crate_root = def_map.module_id(def_map.root());\n+    let crate_root = def_map.crate_root(db);\n     let crate_attrs = db.attrs(crate_root.into());\n     let prefer_no_std = crate_attrs.by_key(\"no_std\").exists();\n     let mut best_path = None;\n@@ -228,12 +231,16 @@ fn find_path_inner(\n         }\n     }\n \n-    if let Some(mut prefix) = prefixed.map(PrefixKind::prefix) {\n-        if matches!(prefix, PathKind::Crate | PathKind::Super(0)) && def_map.block_id().is_some() {\n-            // Inner items cannot be referred to via `crate::` or `self::` paths.\n-            prefix = PathKind::Plain;\n+    // If the item is declared inside a block expression, don't use a prefix, as we don't handle\n+    // that correctly (FIXME).\n+    if let Some(item_module) = item.as_module_def_id().and_then(|did| did.module(db)) {\n+        if item_module.def_map(db).block_id().is_some() && prefixed.is_some() {\n+            mark::hit!(prefixed_in_block_expression);\n+            prefixed = Some(PrefixKind::Plain);\n         }\n+    }\n \n+    if let Some(prefix) = prefixed.map(PrefixKind::prefix) {\n         best_path.or_else(|| {\n             scope_name.map(|scope_name| ModPath::from_segments(prefix, vec![scope_name]))\n         })\n@@ -285,12 +292,12 @@ fn find_local_import_locations(\n     let data = &def_map[from.local_id];\n     let mut worklist =\n         data.children.values().map(|child| def_map.module_id(*child)).collect::<Vec<_>>();\n-    let mut parent = data.parent;\n-    while let Some(p) = parent {\n-        worklist.push(def_map.module_id(p));\n-        parent = def_map[p].parent;\n+    for ancestor in iter::successors(from.containing_module(db), |m| m.containing_module(db)) {\n+        worklist.push(ancestor);\n     }\n \n+    let def_map = def_map.crate_root(db).def_map(db);\n+\n     let mut seen: FxHashSet<_> = FxHashSet::default();\n \n     let mut locations = Vec::new();\n@@ -301,7 +308,14 @@ fn find_local_import_locations(\n \n         let ext_def_map;\n         let data = if module.krate == from.krate {\n-            &def_map[module.local_id]\n+            if module.block.is_some() {\n+                // Re-query the block's DefMap\n+                ext_def_map = module.def_map(db);\n+                &ext_def_map[module.local_id]\n+            } else {\n+                // Reuse the root DefMap\n+                &def_map[module.local_id]\n+            }\n         } else {\n             // The crate might reexport a module defined in another crate.\n             ext_def_map = module.def_map(db);\n@@ -828,6 +842,7 @@ mod tests {\n \n     #[test]\n     fn inner_items_from_inner_module() {\n+        mark::check!(prefixed_in_block_expression);\n         check_found_path(\n             r#\"\n             fn main() {\n@@ -869,4 +884,24 @@ mod tests {\n             \"super::Struct\",\n         );\n     }\n+\n+    #[test]\n+    fn outer_items_with_inner_items_present() {\n+        check_found_path(\n+            r#\"\n+            mod module {\n+                pub struct CompleteMe;\n+            }\n+\n+            fn main() {\n+                fn inner() {}\n+                $0\n+            }\n+            \"#,\n+            \"module::CompleteMe\",\n+            \"module::CompleteMe\",\n+            \"crate::module::CompleteMe\",\n+            \"self::module::CompleteMe\",\n+        )\n+    }\n }"}, {"sha": "4e5daa2ffd7e132052c2565bc6a8b60af73b8ba3", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "patch": "@@ -12,8 +12,8 @@ use stdx::format_to;\n use test_utils::mark;\n \n use crate::{\n-    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, HasModule, ImplId,\n-    LocalModuleId, Lookup, MacroDefId, ModuleDefId, ModuleId, TraitId,\n+    db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ImplId,\n+    LocalModuleId, MacroDefId, ModuleDefId, ModuleId, TraitId,\n };\n \n #[derive(Copy, Clone)]\n@@ -375,19 +375,9 @@ impl ItemInNs {\n \n     /// Returns the crate defining this item (or `None` if `self` is built-in).\n     pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n-        Some(match self {\n-            ItemInNs::Types(did) | ItemInNs::Values(did) => match did {\n-                ModuleDefId::ModuleId(id) => id.krate,\n-                ModuleDefId::FunctionId(id) => id.lookup(db).module(db).krate,\n-                ModuleDefId::AdtId(id) => id.module(db).krate,\n-                ModuleDefId::EnumVariantId(id) => id.parent.lookup(db).container.module(db).krate,\n-                ModuleDefId::ConstId(id) => id.lookup(db).container.module(db).krate,\n-                ModuleDefId::StaticId(id) => id.lookup(db).container.module(db).krate,\n-                ModuleDefId::TraitId(id) => id.lookup(db).container.module(db).krate,\n-                ModuleDefId::TypeAliasId(id) => id.lookup(db).module(db).krate,\n-                ModuleDefId::BuiltinType(_) => return None,\n-            },\n-            ItemInNs::Macros(id) => return Some(id.krate),\n-        })\n+        match self {\n+            ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate),\n+            ItemInNs::Macros(id) => Some(id.krate),\n+        }\n     }\n }"}, {"sha": "4498d94bb220e58f08cadd6b51b2e5c46dfa2c86", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "patch": "@@ -97,6 +97,10 @@ impl ModuleId {\n     pub fn krate(&self) -> CrateId {\n         self.krate\n     }\n+\n+    pub fn containing_module(&self, db: &dyn db::DefDatabase) -> Option<ModuleId> {\n+        self.def_map(db).containing_module(self.local_id)\n+    }\n }\n \n /// An ID of a module, **local** to a specific crate\n@@ -529,6 +533,25 @@ impl HasModule for StaticLoc {\n     }\n }\n \n+impl ModuleDefId {\n+    /// Returns the module containing `self` (or `self`, if `self` is itself a module).\n+    ///\n+    /// Returns `None` if `self` refers to a primitive type.\n+    pub fn module(&self, db: &dyn db::DefDatabase) -> Option<ModuleId> {\n+        Some(match self {\n+            ModuleDefId::ModuleId(id) => *id,\n+            ModuleDefId::FunctionId(id) => id.lookup(db).module(db),\n+            ModuleDefId::AdtId(id) => id.module(db),\n+            ModuleDefId::EnumVariantId(id) => id.parent.lookup(db).container.module(db),\n+            ModuleDefId::ConstId(id) => id.lookup(db).container.module(db),\n+            ModuleDefId::StaticId(id) => id.lookup(db).container.module(db),\n+            ModuleDefId::TraitId(id) => id.lookup(db).container.module(db),\n+            ModuleDefId::TypeAliasId(id) => id.lookup(db).module(db),\n+            ModuleDefId::BuiltinType(_) => return None,\n+        })\n+    }\n+}\n+\n impl AttrDefId {\n     pub fn krate(&self, db: &dyn db::DefDatabase) -> CrateId {\n         match self {"}, {"sha": "003d668ca08f4e6452af669e25232e91f97f68d8", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17f9f51d6bc8e29a309980bfca24fbcb3cecb33/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=f17f9f51d6bc8e29a309980bfca24fbcb3cecb33", "patch": "@@ -343,6 +343,18 @@ impl DefMap {\n         Some(self.block?.parent)\n     }\n \n+    /// Returns the module containing `local_mod`, either the parent `mod`, or the module containing\n+    /// the block, if `self` corresponds to a block expression.\n+    pub fn containing_module(&self, local_mod: LocalModuleId) -> Option<ModuleId> {\n+        match &self[local_mod].parent {\n+            Some(parent) => Some(self.module_id(*parent)),\n+            None => match &self.block {\n+                Some(block) => Some(block.parent),\n+                None => None,\n+            },\n+        }\n+    }\n+\n     // FIXME: this can use some more human-readable format (ideally, an IR\n     // even), as this should be a great debugging aid.\n     pub fn dump(&self, db: &dyn DefDatabase) -> String {"}]}