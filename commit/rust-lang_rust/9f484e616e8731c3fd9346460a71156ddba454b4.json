{"sha": "9f484e616e8731c3fd9346460a71156ddba454b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDg0ZTYxNmU4NzMxYzNmZDkzNDY0NjBhNzExNTZkZGJhNDU0YjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T22:46:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-30T22:46:47Z"}, "message": "auto merge of #13648 : gereeter/rust/removed-rev, r=alexcrichton\n\nIn the process, `Splits` got changed to be more like `CharSplits` in `str` to present the DEI interface.\r\n\r\nNote that `treemap` still has a `rev_iter` function because it seems like it would be a significant interface change to expose a DEI - the iterator would have to gain an extra pointer, the completion checks would be more complicated, and it isn't easy to check that such an implementation is correct due to the use of unsafety to subvert the aliasing properties of `&mut`.\r\n\r\nThis fixes #9391.", "tree": {"sha": "040aacc920be7044251435cb3883e4f7a1166aa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/040aacc920be7044251435cb3883e4f7a1166aa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f484e616e8731c3fd9346460a71156ddba454b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f484e616e8731c3fd9346460a71156ddba454b4", "html_url": "https://github.com/rust-lang/rust/commit/9f484e616e8731c3fd9346460a71156ddba454b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f484e616e8731c3fd9346460a71156ddba454b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aadbed612fd877488b11347d83bfd8f6dc08fe6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aadbed612fd877488b11347d83bfd8f6dc08fe6", "html_url": "https://github.com/rust-lang/rust/commit/3aadbed612fd877488b11347d83bfd8f6dc08fe6"}, {"sha": "03609e5a5e8bdca9452327d44e25407ce888d0bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/03609e5a5e8bdca9452327d44e25407ce888d0bb", "html_url": "https://github.com/rust-lang/rust/commit/03609e5a5e8bdca9452327d44e25407ce888d0bb"}], "stats": {"total": 431, "additions": 212, "deletions": 219}, "files": [{"sha": "4fb75111f3b47e057aff68fced570abb7992c8ba", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -120,12 +120,13 @@ differently.\n Containers implement iteration over the contained elements by returning an\n iterator object. For example, vector slices several iterators available:\n \n-* `iter()` and `rev_iter()`, for immutable references to the elements\n-* `mut_iter()` and `mut_rev_iter()`, for mutable references to the elements\n-* `move_iter()` and `move_rev_iter()`, to move the elements out by-value\n+* `iter()` for immutable references to the elements\n+* `mut_iter()` for mutable references to the elements\n+* `move_iter()` to move the elements out by-value\n \n A typical mutable container will implement at least `iter()`, `mut_iter()` and\n-`move_iter()` along with the reverse variants if it maintains an order.\n+`move_iter()`. If it maintains an order, the returned iterators will be\n+`DoubleEndedIterator`s, which are described below.\n \n ### Freezing\n \n@@ -265,7 +266,7 @@ Iterators offer generic conversion to containers with the `collect` adaptor:\n \n ~~~\n let xs = [0, 1, 1, 2, 3, 5, 8];\n-let ys = xs.rev_iter().skip(1).map(|&x| x * 2).collect::<~[int]>();\n+let ys = xs.iter().rev().skip(1).map(|&x| x * 2).collect::<~[int]>();\n assert_eq!(ys, ~[10, 6, 4, 2, 2, 0]);\n ~~~\n \n@@ -358,9 +359,6 @@ for &x in it.rev() {\n }\n ~~~\n \n-The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted\n-version of the standard immutable and mutable vector iterators.\n-\n The `chain`, `map`, `filter`, `filter_map` and `inspect` adaptors are\n `DoubleEndedIterator` implementations if the underlying iterators are.\n "}, {"sha": "424eb54d8da36633ed7d10a00f5ef2a2c076dc54", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -425,6 +425,7 @@ impl Bitv {\n     }\n \n     #[inline]\n+    #[deprecated = \"replaced by .iter().rev()\"]\n     pub fn rev_iter<'a>(&'a self) -> Rev<Bits<'a>> {\n         self.iter().rev()\n     }"}, {"sha": "df1bc28508c15a445b5514a3ce00d05f4bd8978d", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -370,8 +370,8 @@ impl<T> DList<T> {\n         Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n-    /// Provide a reverse iterator\n     #[inline]\n+    #[deprecated = \"replaced by .iter().rev()\"]\n     pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> {\n         self.iter().rev()\n     }\n@@ -390,8 +390,9 @@ impl<T> DList<T> {\n             list: self\n         }\n     }\n-    /// Provide a reverse iterator with mutable references\n+\n     #[inline]\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n     pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> {\n         self.mut_iter().rev()\n     }\n@@ -403,8 +404,8 @@ impl<T> DList<T> {\n         MoveItems{list: self}\n     }\n \n-    /// Consume the list into an iterator yielding elements by value, in reverse\n     #[inline]\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n     pub fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n         self.move_iter().rev()\n     }\n@@ -849,13 +850,13 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let m = generate_test();\n-        for (i, elt) in m.rev_iter().enumerate() {\n+        for (i, elt) in m.iter().rev().enumerate() {\n             assert_eq!((6 - i) as int, *elt);\n         }\n         let mut n = DList::new();\n-        assert_eq!(n.rev_iter().next(), None);\n+        assert_eq!(n.iter().rev().next(), None);\n         n.push_front(4);\n-        let mut it = n.rev_iter();\n+        let mut it = n.iter().rev();\n         assert_eq!(it.size_hint(), (1, Some(1)));\n         assert_eq!(it.next().unwrap(), &4);\n         assert_eq!(it.size_hint(), (0, Some(0)));\n@@ -958,13 +959,13 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut m = generate_test();\n-        for (i, elt) in m.mut_rev_iter().enumerate() {\n+        for (i, elt) in m.mut_iter().rev().enumerate() {\n             assert_eq!((6-i) as int, *elt);\n         }\n         let mut n = DList::new();\n-        assert!(n.mut_rev_iter().next().is_none());\n+        assert!(n.mut_iter().rev().next().is_none());\n         n.push_front(4);\n-        let mut it = n.mut_rev_iter();\n+        let mut it = n.mut_iter().rev();\n         assert!(it.next().is_some());\n         assert!(it.next().is_none());\n     }\n@@ -1164,15 +1165,15 @@ mod tests {\n         let v = &[0, ..128];\n         let m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n-            assert!(m.rev_iter().len() == 128);\n+            assert!(m.iter().rev().len() == 128);\n         })\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::Bencher) {\n         let v = &[0, ..128];\n         let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         b.iter(|| {\n-            assert!(m.mut_rev_iter().len() == 128);\n+            assert!(m.mut_iter().rev().len() == 128);\n         })\n     }\n }"}, {"sha": "dd1db85fc20c430f149deca18bfc5c7568807409", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -382,7 +382,7 @@ mod tests {\n     fn test_from_iter() {\n         let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: PriorityQueue<uint> = xs.as_slice().rev_iter().map(|&x| x).collect();\n+        let mut q: PriorityQueue<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop(), x);"}, {"sha": "12e4fa8b51f24ed1d508be8a277fb6293b1afcb6", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -190,7 +190,7 @@ impl<T> RingBuf<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n \n-    /// Back-to-front iterator.\n+    #[deprecated = \"replaced by .iter().rev()\"]\n     pub fn rev_iter<'a>(&'a self) -> Rev<Items<'a, T>> {\n         self.iter().rev()\n     }\n@@ -221,7 +221,7 @@ impl<T> RingBuf<T> {\n         }\n     }\n \n-    /// Back-to-front iterator which returns mutable values.\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n     pub fn mut_rev_iter<'a>(&'a mut self) -> Rev<MutItems<'a, T>> {\n         self.mut_iter().rev()\n     }\n@@ -702,31 +702,31 @@ mod tests {\n     #[test]\n     fn test_rev_iter() {\n         let mut d = RingBuf::new();\n-        assert_eq!(d.rev_iter().next(), None);\n+        assert_eq!(d.iter().rev().next(), None);\n \n         for i in range(0, 5) {\n             d.push_back(i);\n         }\n-        assert_eq!(d.rev_iter().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0]);\n \n         for i in range(6, 9) {\n             d.push_front(i);\n         }\n-        assert_eq!(d.rev_iter().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), &[&4,&3,&2,&1,&0,&6,&7,&8]);\n     }\n \n     #[test]\n     fn test_mut_rev_iter_wrap() {\n         let mut d = RingBuf::with_capacity(3);\n-        assert!(d.mut_rev_iter().next().is_none());\n+        assert!(d.mut_iter().rev().next().is_none());\n \n         d.push_back(1);\n         d.push_back(2);\n         d.push_back(3);\n         assert_eq!(d.pop_front(), Some(1));\n         d.push_back(4);\n \n-        assert_eq!(d.mut_rev_iter().map(|x| *x).collect::<Vec<int>>(),\n+        assert_eq!(d.mut_iter().rev().map(|x| *x).collect::<Vec<int>>(),\n                    vec!(4, 3, 2));\n     }\n \n@@ -756,19 +756,19 @@ mod tests {\n     #[test]\n     fn test_mut_rev_iter() {\n         let mut d = RingBuf::new();\n-        assert!(d.mut_rev_iter().next().is_none());\n+        assert!(d.mut_iter().rev().next().is_none());\n \n         for i in range(0u, 3) {\n             d.push_front(i);\n         }\n \n-        for (i, elt) in d.mut_rev_iter().enumerate() {\n+        for (i, elt) in d.mut_iter().rev().enumerate() {\n             assert_eq!(*elt, i);\n             *elt = i;\n         }\n \n         {\n-            let mut it = d.mut_rev_iter();\n+            let mut it = d.mut_iter().rev();\n             assert_eq!(*it.next().unwrap(), 0);\n             assert_eq!(*it.next().unwrap(), 1);\n             assert_eq!(*it.next().unwrap(), 2);"}, {"sha": "5bfe04c7e512ccaa4f9c7b1f15ee8af6cde2f7c6", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -142,16 +142,13 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// An iterator visiting all key-value pairs in descending order by the keys.\n-    /// Iterator element type is (uint, &'r V)\n-    pub fn rev_iter<'r>(&'r self) -> RevEntries<'r, V> {\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    pub fn rev_iter<'r>(&'r self) -> Rev<Entries<'r, V>> {\n         self.iter().rev()\n     }\n \n-    /// An iterator visiting all key-value pairs in descending order by the keys,\n-    /// with mutable references to the values\n-    /// Iterator element type is (uint, &'r mut V)\n-    pub fn mut_rev_iter<'r>(&'r mut self) -> RevMutEntries <'r, V> {\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    pub fn mut_rev_iter<'r>(&'r mut self) -> Rev<MutEntries<'r, V>> {\n         self.mut_iter().rev()\n     }\n \n@@ -246,6 +243,7 @@ pub struct Entries<'a, T> {\n \n iterator!(impl Entries -> (uint, &'a T), get_ref)\n double_ended_iterator!(impl Entries -> (uint, &'a T), get_ref)\n+#[deprecated = \"replaced by Rev<Entries<'a, T>>\"]\n pub type RevEntries<'a, T> = Rev<Entries<'a, T>>;\n \n pub struct MutEntries<'a, T> {\n@@ -256,6 +254,7 @@ pub struct MutEntries<'a, T> {\n \n iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n double_ended_iterator!(impl MutEntries -> (uint, &'a mut T), get_mut_ref)\n+#[deprecated = \"replaced by Rev<MutEntries<'a, T>\"]\n pub type RevMutEntries<'a, T> = Rev<MutEntries<'a, T>>;\n \n #[cfg(test)]\n@@ -387,9 +386,9 @@ mod test_map {\n         assert!(m.insert(10, 11));\n \n         assert_eq!(m.iter().size_hint(), (0, Some(11)));\n-        assert_eq!(m.rev_iter().size_hint(), (0, Some(11)));\n+        assert_eq!(m.iter().rev().size_hint(), (0, Some(11)));\n         assert_eq!(m.mut_iter().size_hint(), (0, Some(11)));\n-        assert_eq!(m.mut_rev_iter().size_hint(), (0, Some(11)));\n+        assert_eq!(m.mut_iter().rev().size_hint(), (0, Some(11)));\n     }\n \n     #[test]\n@@ -425,7 +424,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        let mut it = m.rev_iter();\n+        let mut it = m.iter().rev();\n         assert_eq!(it.next().unwrap(), (10, &11));\n         assert_eq!(it.next().unwrap(), (6, &10));\n         assert_eq!(it.next().unwrap(), (3, &5));\n@@ -444,7 +443,7 @@ mod test_map {\n         assert!(m.insert(6, 10));\n         assert!(m.insert(10, 11));\n \n-        for (k, v) in m.mut_rev_iter() {\n+        for (k, v) in m.mut_iter().rev() {\n             *v += k as int;\n         }\n "}, {"sha": "3a0d81070fef0741016d89ddf9f534398ecbf46c", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -395,7 +395,7 @@ impl<T> TrieNode<T> {\n \n impl<T> TrieNode<T> {\n     fn each_reverse<'a>(&'a self, f: |&uint, &'a T| -> bool) -> bool {\n-        for elt in self.children.rev_iter() {\n+        for elt in self.children.iter().rev() {\n             match *elt {\n                 Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },"}, {"sha": "083fb1e794b6c09d27b96418c2ab088a4c738d79", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -439,7 +439,7 @@ impl Integer for BigUint {\n             let bn = *b.data.last().unwrap();\n             let mut d = Vec::with_capacity(an.len());\n             let mut carry = 0;\n-            for elt in an.rev_iter() {\n+            for elt in an.iter().rev() {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n@@ -668,7 +668,7 @@ impl ToStrRadix for BigUint {\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return \"0\".to_owned() }\n             let mut s = StrBuf::with_capacity(v.len() * l);\n-            for n in v.rev_iter() {\n+            for n in v.iter().rev() {\n                 let ss = (*n as uint).to_str_radix(radix);\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n@@ -2187,7 +2187,7 @@ mod bigint_tests {\n     fn test_cmp() {\n         let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n         let mut nums = Vec::new();\n-        for s in vs.rev_iter() {\n+        for s in vs.iter().rev() {\n             nums.push(BigInt::from_slice(Minus, *s));\n         }\n         nums.push(Zero::zero());"}, {"sha": "070e45d92c4de161e92bb963a330dacad9415829", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -927,7 +927,7 @@ impl<'a> Liveness<'a> {\n \n     fn propagate_through_exprs(&mut self, exprs: &[@Expr], succ: LiveNode)\n                                -> LiveNode {\n-        exprs.rev_iter().fold(succ, |succ, expr| {\n+        exprs.iter().rev().fold(succ, |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         })\n     }"}, {"sha": "8b3794aff723cd87ddaa46b9f8a8790eee60f187", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -94,7 +94,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     let mut result: Vec<vtable_param_res> =\n         substs.tps.iter()\n         .rev()\n-        .zip(type_param_defs.rev_iter())\n+        .zip(type_param_defs.iter().rev())\n         .map(|(ty, def)|\n             lookup_vtables_for_param(vcx, span, Some(substs),\n                                      &*def.bounds, *ty, is_early))"}, {"sha": "f4c21519169327a872ae3ebf65d3dfb4d1a3e32d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -304,7 +304,7 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n         None => {}\n     }\n     if default_passes {\n-        for name in DEFAULT_PASSES.rev_iter() {\n+        for name in DEFAULT_PASSES.iter().rev() {\n             passes.unshift(name.to_owned());\n         }\n     }"}, {"sha": "189b8717d491893a74d768ff66632b874d871fcd", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1931,7 +1931,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                 };\n                 match o.pop(&\"fields\".to_owned()) {\n                     Some(List(l)) => {\n-                        for field in l.move_rev_iter() {\n+                        for field in l.move_iter().rev() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n@@ -2042,7 +2042,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_seq()\");\n         let list = try!(expect!(self.pop(), List));\n         let len = list.len();\n-        for v in list.move_rev_iter() {\n+        for v in list.move_iter().rev() {\n             self.stack.push(v);\n         }\n         f(self, len)"}, {"sha": "d69e9b448beb9a9e3258efd423bdb95b9ab75dcb", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -16,11 +16,11 @@ use clone::Clone;\n use cmp::{Eq, TotalEq};\n use from_str::FromStr;\n use io::Writer;\n-use iter::{AdditiveIterator, Extendable, Iterator, Map};\n+use iter::{DoubleEndedIterator, Rev, AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str;\n use str::Str;\n-use slice::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n+use slice::{CloneableVector, Splits, Vector, VectorVector,\n             ImmutableEqVector, OwnedVector, ImmutableVector};\n use vec::Vec;\n \n@@ -29,14 +29,15 @@ use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> = Splits<'a, u8>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponents<'a> = RevSplits<'a, u8>;\n+#[deprecated = \"replaced by Rev<Components<'a>>\"]\n+pub type RevComponents<'a> = Rev<Components<'a>>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n                                        Components<'a>>;\n /// Iterator that yields components of a Path in reverse as Option<&str>\n-pub type RevStrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n-                                          RevComponents<'a>>;\n+#[deprecated = \"replaced by Rev<StrComponents<'a>>\"]\n+pub type RevStrComponents<'a> = Rev<StrComponents<'a>>;\n \n /// Represents a POSIX file path\n #[deriving(Clone)]\n@@ -308,8 +309,8 @@ impl GenericPath for Path {\n \n     fn ends_with_path(&self, child: &Path) -> bool {\n         if !child.is_relative() { return false; }\n-        let mut selfit = self.rev_components();\n-        let mut childit = child.rev_components();\n+        let mut selfit = self.components().rev();\n+        let mut childit = child.components().rev();\n         loop {\n             match (selfit.next(), childit.next()) {\n                 (Some(a), Some(b)) => if a != b { return false; },\n@@ -396,16 +397,9 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See components() for details.\n-    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n-        let v = if *self.repr.get(0) == SEP_BYTE {\n-            self.repr.slice_from(1)\n-        } else { self.repr.as_slice() };\n-        let mut ret = v.rsplit(is_sep_byte);\n-        if v.is_empty() {\n-            // consume the empty \"\" component\n-            ret.next();\n-        }\n-        ret\n+    #[deprecated = \"replaced by .components().rev()\"]\n+    pub fn rev_components<'a>(&'a self) -> Rev<Components<'a>> {\n+        self.components().rev()\n     }\n \n     /// Returns an iterator that yields each component of the path as Option<&str>.\n@@ -416,8 +410,9 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n     /// See components() for details.\n-    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n-        self.rev_components().map(str::from_utf8)\n+    #[deprecated = \"replaced by .str_components().rev()\"]\n+    pub fn rev_str_components<'a>(&'a self) -> Rev<StrComponents<'a>> {\n+        self.str_components().rev()\n     }\n }\n \n@@ -1192,7 +1187,7 @@ mod tests {\n                     let exps = exp.iter().map(|x| x.as_bytes()).collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"components: Expected {:?}, found {:?}\",\n                             comps, exps);\n-                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n+                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exps = exps.move_iter().rev().collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"rev_components: Expected {:?}, found {:?}\",\n                             comps, exps);\n@@ -1204,8 +1199,8 @@ mod tests {\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&[u8]>>();\n+                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp)\n                 }\n             )\n@@ -1236,8 +1231,8 @@ mod tests {\n                     let comps = path.str_components().collect::<Vec<Option<&str>>>();\n                     let exp: &[Option<&str>] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_str_components().collect::<Vec<Option<&str>>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<Option<&str>>>();\n+                    let comps = path.str_components().rev().collect::<Vec<Option<&str>>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<Option<&str>>>();\n                     assert_eq!(comps, exp);\n                 }\n             )"}, {"sha": "758a76167cdef961367ed20d43c43aef06b9cd8b", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -37,15 +37,15 @@ pub type StrComponents<'a> = Map<'a, &'a str, Option<&'a str>,\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type RevStrComponents<'a> = Rev<Map<'a, &'a str, Option<&'a str>,\n-                                                 CharSplits<'a, char>>>;\n+#[deprecated = \"replaced by Rev<StrComponents<'a>>\"]\n+pub type RevStrComponents<'a> = Rev<StrComponents<'a>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> = Map<'a, Option<&'a str>, &'a [u8],\n                                     StrComponents<'a>>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponents<'a> = Map<'a, Option<&'a str>, &'a [u8],\n-                                       RevStrComponents<'a>>;\n+#[deprecated = \"replaced by Rev<Components<'a>>\"]\n+pub type RevComponents<'a> = Rev<Components<'a>>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:\n@@ -633,7 +633,8 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as an Option<&str>\n     /// See str_components() for details.\n-    pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n+    #[deprecated = \"replaced by .str_components().rev()\"]\n+    pub fn rev_str_components<'a>(&'a self) -> Rev<StrComponents<'a>> {\n         self.str_components().rev()\n     }\n \n@@ -649,12 +650,9 @@ impl Path {\n \n     /// Returns an iterator that yields each component of the path in reverse as a &[u8].\n     /// See str_components() for details.\n-    pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n-        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n-            #![inline]\n-            x.unwrap().as_bytes()\n-        }\n-        self.rev_str_components().map(convert)\n+    #[deprecated = \"replaced by .components().rev()\"]\n+    pub fn rev_components<'a>(&'a self) -> Rev<Components<'a>> {\n+        self.components().rev()\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n@@ -2239,9 +2237,9 @@ mod tests {\n                                 .collect::<Vec<&str>>();\n                     let exp: &[&str] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_str_components().map(|x|x.unwrap())\n+                    let comps = path.str_components().rev().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&str>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n                     assert_eq!(comps, exp);\n                 }\n             );\n@@ -2251,9 +2249,9 @@ mod tests {\n                     let comps = path.str_components().map(|x|x.unwrap()).collect::<Vec<&str>>();\n                     let exp: &[&str] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_str_components().map(|x|x.unwrap())\n+                    let comps = path.str_components().rev().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&str>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n                     assert_eq!(comps, exp);\n                 }\n             )\n@@ -2308,8 +2306,8 @@ mod tests {\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n                     let exp: &[&[u8]] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.rev_components().collect::<Vec<&[u8]>>();\n-                    let exp = exp.rev_iter().map(|&x|x).collect::<Vec<&[u8]>>();\n+                    let comps = path.components().rev().collect::<Vec<&[u8]>>();\n+                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n                     assert_eq!(comps, exp);\n                 }\n             )"}, {"sha": "64f6b59be24d267ba7a1997ef92321b1fe9ebf4e", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -81,8 +81,6 @@ for &x in numbers.iter() {\n }\n  ```\n \n-* `.rev_iter()` returns an iterator with the same values as `.iter()`,\n-  but going in the reverse order, starting with the back element.\n * `.mut_iter()` returns an iterator that allows modifying each value.\n * `.move_iter()` converts an owned vector into an iterator that\n   moves out a value from the vector each iteration.\n@@ -119,7 +117,6 @@ use result::{Ok, Err};\n use mem;\n use mem::size_of;\n use kinds::marker;\n-use uint;\n use unstable::finally::try_finally;\n use raw::{Repr, Slice};\n use RawVec = raw::Vec;\n@@ -148,7 +145,6 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// match a predicate function.\n pub struct Splits<'a, T> {\n     v: &'a [T],\n-    n: uint,\n     pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n@@ -158,11 +154,6 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n \n-        if self.n == 0 {\n-            self.finished = true;\n-            return Some(self.v);\n-        }\n-\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n@@ -171,7 +162,6 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n             Some(idx) => {\n                 let ret = Some(self.v.slice(0, idx));\n                 self.v = self.v.slice(idx + 1, self.v.len());\n-                self.n -= 1;\n                 ret\n             }\n         }\n@@ -180,38 +170,18 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         if self.finished {\n-            return (0, Some(0))\n-        }\n-        // if the predicate doesn't match anything, we yield one slice\n-        // if it matches every element, we yield N+1 empty slices where\n-        // N is either the number of elements or the number of splits.\n-        match (self.v.len(), self.n) {\n-            (0,_) => (1, Some(1)),\n-            (_,0) => (1, Some(1)),\n-            (l,n) => (1, cmp::min(l,n).checked_add(&1u))\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.v.len() + 1))\n         }\n     }\n }\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function, from back to front.\n-pub struct RevSplits<'a, T> {\n-    v: &'a [T],\n-    n: uint,\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n \n-        if self.n == 0 {\n-            self.finished = true;\n-            return Some(self.v);\n-        }\n-\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n@@ -220,21 +190,42 @@ impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n             Some(idx) => {\n                 let ret = Some(self.v.slice(idx + 1, self.v.len()));\n                 self.v = self.v.slice(0, idx);\n-                self.n -= 1;\n                 ret\n             }\n         }\n     }\n+}\n \n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, splitting at most a fixed number of times.\n+pub struct SplitsN<'a, T> {\n+    iter: Splits<'a, T>,\n+    count: uint,\n+    invert: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            return (0, Some(0))\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.count == 0 {\n+            if self.iter.finished {\n+                None\n+            } else {\n+                self.iter.finished = true;\n+                Some(self.iter.v)\n+            }\n+        } else {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n         }\n-        match (self.v.len(), self.n) {\n-            (0,_) => (1, Some(1)),\n-            (_,0) => (1, Some(1)),\n-            (l,n) => (1, cmp::min(l,n).checked_add(&1u))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.iter.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n         }\n     }\n }\n@@ -738,7 +729,8 @@ pub trait ImmutableVector<'a, T> {\n     /// Returns an iterator over the vector\n     fn iter(self) -> Items<'a, T>;\n     /// Returns a reversed iterator over a vector\n-    fn rev_iter(self) -> RevItems<'a, T>;\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.  The matched element\n     /// is not contained in the subslices.\n@@ -747,18 +739,19 @@ pub trait ImmutableVector<'a, T> {\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.  The matched element is not contained in\n     /// the subslices.\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.  The matched element is\n     /// not contained in the subslices.\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> RevSplits<'a, T>;\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.  The matched element is not contained in the\n     /// subslices.\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> RevSplits<'a, T>;\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n \n     /**\n      * Returns an iterator over all contiguous windows of length\n@@ -930,37 +923,41 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     }\n \n     #[inline]\n-    fn rev_iter(self) -> RevItems<'a, T> {\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>> {\n         self.iter().rev()\n     }\n \n     #[inline]\n     fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n-        self.splitn(uint::MAX, pred)\n-    }\n-\n-    #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n         Splits {\n             v: self,\n-            n: n,\n             pred: pred,\n             finished: false\n         }\n     }\n \n     #[inline]\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> RevSplits<'a, T> {\n-        self.rsplitn(uint::MAX, pred)\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: false\n+        }\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> RevSplits<'a, T> {\n-        RevSplits {\n-            v: self,\n-            n: n,\n-            pred: pred,\n-            finished: false\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>> {\n+        self.split(pred).rev()\n+    }\n+\n+    #[inline]\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: true\n         }\n     }\n \n@@ -1172,7 +1169,8 @@ pub trait OwnedVector<T> {\n     fn move_iter(self) -> MoveItems<T>;\n     /// Creates a consuming iterator that moves out of the vector in\n     /// reverse order.\n-    fn move_rev_iter(self) -> RevMoveItems<T>;\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>>;\n \n     /**\n      * Partitions the vector into two vectors `(A,B)`, where all\n@@ -1192,7 +1190,8 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    fn move_rev_iter(self) -> RevMoveItems<T> {\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n         self.move_iter().rev()\n     }\n \n@@ -1447,7 +1446,8 @@ pub trait MutableVector<'a, T> {\n     fn mut_last(self) -> Option<&'a mut T>;\n \n     /// Returns a reversed iterator that allows modifying each value\n-    fn mut_rev_iter(self) -> RevMutItems<'a, T>;\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>>;\n \n     /// Returns an iterator over the mutable subslices of the vector\n     /// which are separated by elements that match `pred`.  The\n@@ -1719,7 +1719,8 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     }\n \n     #[inline]\n-    fn mut_rev_iter(self) -> RevMutItems<'a, T> {\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>> {\n         self.mut_iter().rev()\n     }\n \n@@ -2134,6 +2135,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n }\n \n iterator!{struct Items -> *T, &'a T}\n+#[deprecated = \"replaced by Rev<Items<'a, T>>\"]\n pub type RevItems<'a, T> = Rev<Items<'a, T>>;\n \n impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n@@ -2144,6 +2146,7 @@ impl<'a, T> Clone for Items<'a, T> {\n }\n \n iterator!{struct MutItems -> *mut T, &'a mut T}\n+#[deprecated = \"replaced by Rev<MutItems<'a, T>>\"]\n pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n \n /// An iterator over the subslices of the vector which are separated\n@@ -2304,6 +2307,7 @@ impl<T> Drop for MoveItems<T> {\n }\n \n /// An iterator that moves out of a vector in reverse order.\n+#[deprecated = \"replaced by Rev<MoveItems<'a, T>>\"]\n pub type RevMoveItems<T> = Rev<MoveItems<T>>;\n \n impl<A> FromIterator<A> for ~[A] {\n@@ -3233,9 +3237,7 @@ mod tests {\n         use iter::*;\n         let mut xs = [1, 2, 5, 10, 11];\n         assert_eq!(xs.iter().size_hint(), (5, Some(5)));\n-        assert_eq!(xs.rev_iter().size_hint(), (5, Some(5)));\n         assert_eq!(xs.mut_iter().size_hint(), (5, Some(5)));\n-        assert_eq!(xs.mut_rev_iter().size_hint(), (5, Some(5)));\n     }\n \n     #[test]\n@@ -3266,7 +3268,7 @@ mod tests {\n         let xs = [1, 2, 5, 10, 11];\n         let ys = [11, 10, 5, 2, 1];\n         let mut i = 0;\n-        for &x in xs.rev_iter() {\n+        for &x in xs.iter().rev() {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -3277,7 +3279,7 @@ mod tests {\n     fn test_mut_rev_iterator() {\n         use iter::*;\n         let mut xs = [1u, 2, 3, 4, 5];\n-        for (i,x) in xs.mut_rev_iter().enumerate() {\n+        for (i,x) in xs.mut_iter().rev().enumerate() {\n             *x += i;\n         }\n         assert!(xs == [5, 5, 5, 5, 5])\n@@ -3294,7 +3296,7 @@ mod tests {\n     fn test_move_rev_iterator() {\n         use iter::*;\n         let xs = ~[1u,2,3,4,5];\n-        assert_eq!(xs.move_rev_iter().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+        assert_eq!(xs.move_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n     }\n \n     #[test]\n@@ -3335,17 +3337,17 @@ mod tests {\n     fn test_rsplitator() {\n         let xs = &[1i,2,3,4,5];\n \n-        assert_eq!(xs.rsplit(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<~[&[int]]>(),\n                    ~[&[5], &[3], &[1]]);\n-        assert_eq!(xs.rsplit(|x| *x == 1).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<~[&[int]]>(),\n                    ~[&[2,3,4,5], &[]]);\n-        assert_eq!(xs.rsplit(|x| *x == 5).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(),\n                    ~[&[], &[1,2,3,4]]);\n-        assert_eq!(xs.rsplit(|x| *x == 10).collect::<~[&[int]]>(),\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<~[&[int]]>(),\n                    ~[&[1,2,3,4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplit(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(), ~[&[]]);\n     }\n \n     #[test]"}, {"sha": "bc7943dd777cabbcde30cf2fab1b24f609cd86c4", "filename": "src/libstd/str.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -343,21 +343,18 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n     }\n }\n \n-/// External iterator for a string's characters in reverse order.\n-/// Use with the `std::iter` module.\n+#[deprecated = \"replaced by Rev<Chars<'a>>\"]\n pub type RevChars<'a> = Rev<Chars<'a>>;\n \n-/// External iterator for a string's characters and their byte offsets in reverse order.\n-/// Use with the `std::iter` module.\n+#[deprecated = \"replaced by Rev<CharOffsets<'a>>\"]\n pub type RevCharOffsets<'a> = Rev<CharOffsets<'a>>;\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n pub type Bytes<'a> =\n     Map<'a, &'a u8, u8, slice::Items<'a, u8>>;\n \n-/// External iterator for a string's bytes in reverse order.\n-/// Use with the `std::iter` module.\n+#[deprecated = \"replaced by Rev<Bytes<'a>>\"]\n pub type RevBytes<'a> = Rev<Bytes<'a>>;\n \n /// An iterator over the substrings of a string, separated by `sep`.\n@@ -372,8 +369,7 @@ pub struct CharSplits<'a, Sep> {\n     finished: bool,\n }\n \n-/// An iterator over the substrings of a string, separated by `sep`,\n-/// starting from the back of the string.\n+#[deprecated = \"replaced by Rev<CharSplits<'a, Sep>>\"]\n pub type RevCharSplits<'a, Sep> = Rev<CharSplits<'a, Sep>>;\n \n /// An iterator over the substrings of a string, separated by `sep`,\n@@ -462,7 +458,7 @@ for CharSplits<'a, Sep> {\n                 }\n             }\n         } else {\n-            for (idx, ch) in self.string.char_indices_rev() {\n+            for (idx, ch) in self.string.char_indices().rev() {\n                 if self.sep.matches(ch) {\n                     next_split = Some((idx, self.string.char_range_at(idx).next));\n                     break;\n@@ -1626,21 +1622,23 @@ pub trait StrSlice<'a> {\n     /// ```\n     fn chars(&self) -> Chars<'a>;\n \n-    /// An iterator over the characters of `self`, in reverse order.\n-    fn chars_rev(&self) -> RevChars<'a>;\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> Rev<Chars<'a>>;\n \n     /// An iterator over the bytes of `self`\n     fn bytes(&self) -> Bytes<'a>;\n \n-    /// An iterator over the bytes of `self`, in reverse order\n-    fn bytes_rev(&self) -> RevBytes<'a>;\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> Rev<Bytes<'a>>;\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     fn char_indices(&self) -> CharOffsets<'a>;\n \n-    /// An iterator over the characters of `self` and their byte offsets,\n-    /// in reverse order.\n-    fn char_indices_rev(&self) -> RevCharOffsets<'a>;\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1691,25 +1689,21 @@ pub trait StrSlice<'a> {\n     ///\n     /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n-    /// ```\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n-\n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by `sep`, in reverse order.\n-    ///\n-    /// # Example\n     ///\n-    /// ```rust\n-    /// let v: ~[&str] = \"Mary had a little lamb\".rsplit(' ').collect();\n+    /// let v: ~[&str] = \"Mary had a little lamb\".split(' ').rev().collect();\n     /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n     ///\n-    /// let v: ~[&str] = \"abc1def2ghi\".rsplit(|c: char| c.is_digit()).collect();\n+    /// let v: ~[&str] = \"abc1def2ghi\".split(|c: char| c.is_digit()).rev().collect();\n     /// assert_eq!(v, ~[\"ghi\", \"def\", \"abc\"]);\n     ///\n-    /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplit('X').collect();\n+    /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep>;\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplits<'a, Sep>;\n+\n+    /// Do not use this - it is deprecated.\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n@@ -2281,7 +2275,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn chars_rev(&self) -> RevChars<'a> {\n+    #[deprecated = \"replaced by .chars().rev()\"]\n+    fn chars_rev(&self) -> Rev<Chars<'a>> {\n         self.chars().rev()\n     }\n \n@@ -2291,7 +2286,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn bytes_rev(&self) -> RevBytes<'a> {\n+    #[deprecated = \"replaced by .bytes().rev()\"]\n+    fn bytes_rev(&self) -> Rev<Bytes<'a>> {\n         self.bytes().rev()\n     }\n \n@@ -2301,7 +2297,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn char_indices_rev(&self) -> RevCharOffsets<'a> {\n+    #[deprecated = \"replaced by .char_indices().rev()\"]\n+    fn char_indices_rev(&self) -> Rev<CharOffsets<'a>> {\n         self.char_indices().rev()\n     }\n \n@@ -2336,7 +2333,8 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     #[inline]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> RevCharSplits<'a, Sep> {\n+    #[deprecated = \"replaced by .split(sep).rev()\"]\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> Rev<CharSplits<'a, Sep>> {\n         self.split(sep).rev()\n     }\n \n@@ -2656,7 +2654,7 @@ impl<'a> StrSlice<'a> for &'a str {\n         if search.only_ascii() {\n             self.bytes().rposition(|b| search.matches(b as char))\n         } else {\n-            for (index, c) in self.char_indices_rev() {\n+            for (index, c) in self.char_indices().rev() {\n                 if search.matches(c) { return Some(index); }\n             }\n             None\n@@ -3573,7 +3571,7 @@ mod tests {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n-        for ch in v.rev_iter() {\n+        for ch in v.iter().rev() {\n             assert!(s.char_at_reverse(pos) == *ch);\n             pos -= from_char(*ch).len();\n         }\n@@ -3673,7 +3671,7 @@ mod tests {\n         let v = ~['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.chars_rev();\n+        let mut it = s.chars().rev();\n \n         for c in it {\n             assert_eq!(c, v[pos]);\n@@ -3716,7 +3714,7 @@ mod tests {\n         ];\n         let mut pos = v.len();\n \n-        for b in s.bytes_rev() {\n+        for b in s.bytes().rev() {\n             pos -= 1;\n             assert_eq!(b, v[pos]);\n         }\n@@ -3748,7 +3746,7 @@ mod tests {\n         let v = ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n-        let mut it = s.char_indices_rev();\n+        let mut it = s.char_indices().rev();\n \n         for c in it {\n             assert_eq!(c, (p[pos], v[pos]));\n@@ -3765,29 +3763,29 @@ mod tests {\n         let split: ~[&str] = data.split(' ').collect();\n         assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit(' ').collect();\n+        let mut rsplit: ~[&str] = data.split(' ').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let split: ~[&str] = data.split(|c: char| c == ' ').collect();\n         assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit(|c: char| c == ' ').collect();\n+        let mut rsplit: ~[&str] = data.split(|c: char| c == ' ').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: ~[&str] = data.split('\u00e4').collect();\n         assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit('\u00e4').collect();\n+        let mut rsplit: ~[&str] = data.split('\u00e4').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let split: ~[&str] = data.split(|c: char| c == '\u00e4').collect();\n         assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-        let mut rsplit: ~[&str] = data.rsplit(|c: char| c == '\u00e4').collect();\n+        let mut rsplit: ~[&str] = data.split(|c: char| c == '\u00e4').rev().collect();\n         rsplit.reverse();\n         assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n@@ -4103,7 +4101,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        b.iter(|| assert_eq!(s.chars_rev().len(), len));\n+        b.iter(|| assert_eq!(s.chars().rev().len(), len));\n     }\n \n     #[bench]\n@@ -4119,7 +4117,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        b.iter(|| assert_eq!(s.char_indices_rev().len(), len));\n+        b.iter(|| assert_eq!(s.char_indices().rev().len(), len));\n     }\n \n     #[bench]"}, {"sha": "38cdf23b7b305ee4173593b4d4d5a698874faed5", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f484e616e8731c3fd9346460a71156ddba454b4/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=9f484e616e8731c3fd9346460a71156ddba454b4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -205,7 +205,8 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<InternedString> {\n-    items.rev_iter()\n+    items.iter()\n+         .rev()\n          .find(|mi| mi.name().equiv(&name))\n          .and_then(|i| i.value_str())\n }"}]}