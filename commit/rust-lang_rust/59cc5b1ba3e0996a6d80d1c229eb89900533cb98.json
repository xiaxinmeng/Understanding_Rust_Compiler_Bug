{"sha": "59cc5b1ba3e0996a6d80d1c229eb89900533cb98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5Y2M1YjFiYTNlMDk5NmE2ZDgwZDFjMjI5ZWI4OTkwMDUzM2NiOTg=", "commit": {"author": {"name": "Donough Liu", "email": "ldm2993593805@163.com", "date": "2020-05-07T05:11:24Z"}, "committer": {"name": "Donough Liu", "email": "ldm2993593805@163.com", "date": "2020-05-09T01:33:15Z"}, "message": "Support coercion between (FnDef | Closure) and (FnDef | Closure) when Closure is non-capturing", "tree": {"sha": "6f3b3c7624b1b5b283c4b8f65b513fe07f82bc2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f3b3c7624b1b5b283c4b8f65b513fe07f82bc2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59cc5b1ba3e0996a6d80d1c229eb89900533cb98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59cc5b1ba3e0996a6d80d1c229eb89900533cb98", "html_url": "https://github.com/rust-lang/rust/commit/59cc5b1ba3e0996a6d80d1c229eb89900533cb98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59cc5b1ba3e0996a6d80d1c229eb89900533cb98/comments", "author": {"login": "ldm0", "id": 31354274, "node_id": "MDQ6VXNlcjMxMzU0Mjc0", "avatar_url": "https://avatars.githubusercontent.com/u/31354274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ldm0", "html_url": "https://github.com/ldm0", "followers_url": "https://api.github.com/users/ldm0/followers", "following_url": "https://api.github.com/users/ldm0/following{/other_user}", "gists_url": "https://api.github.com/users/ldm0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ldm0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ldm0/subscriptions", "organizations_url": "https://api.github.com/users/ldm0/orgs", "repos_url": "https://api.github.com/users/ldm0/repos", "events_url": "https://api.github.com/users/ldm0/events{/privacy}", "received_events_url": "https://api.github.com/users/ldm0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ldm0", "id": 31354274, "node_id": "MDQ6VXNlcjMxMzU0Mjc0", "avatar_url": "https://avatars.githubusercontent.com/u/31354274?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ldm0", "html_url": "https://github.com/ldm0", "followers_url": "https://api.github.com/users/ldm0/followers", "following_url": "https://api.github.com/users/ldm0/following{/other_user}", "gists_url": "https://api.github.com/users/ldm0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ldm0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ldm0/subscriptions", "organizations_url": "https://api.github.com/users/ldm0/orgs", "repos_url": "https://api.github.com/users/ldm0/repos", "events_url": "https://api.github.com/users/ldm0/events{/privacy}", "received_events_url": "https://api.github.com/users/ldm0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee", "html_url": "https://github.com/rust-lang/rust/commit/7ebd87a7a1e0e21767422e115c9455ef6e6d4bee"}], "stats": {"total": 114, "additions": 81, "deletions": 33}, "files": [{"sha": "5f01c88d413f8cd03982ce4d7a32448c5d682554", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/59cc5b1ba3e0996a6d80d1c229eb89900533cb98/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cc5b1ba3e0996a6d80d1c229eb89900533cb98/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=59cc5b1ba3e0996a6d80d1c229eb89900533cb98", "patch": "@@ -2056,24 +2056,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }))\n     }\n \n-    /// Given a closure signature `sig`, returns an equivalent `fn`\n-    /// type with the same signature. Detuples and so forth -- so\n-    /// e.g., if we have a sig with `Fn<(u32, i32)>` then you would get\n-    /// a `fn(u32, i32)`.\n-    /// `unsafety` determines the unsafety of the `fn` type. If you pass\n+    /// Given a closure signature, returns an equivalent fn signature. Detuples\n+    /// and so forth -- so e.g., if we have a sig with `Fn<(u32, i32)>` then\n+    /// you would get a `fn(u32, i32)`.\n+    /// `unsafety` determines the unsafety of the fn signature. If you pass\n     /// `hir::Unsafety::Unsafe` in the previous example, then you would get\n     /// an `unsafe fn (u32, i32)`.\n     /// It cannot convert a closure that requires unsafe.\n-    pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>, unsafety: hir::Unsafety) -> Ty<'tcx> {\n-        let converted_sig = sig.map_bound(|s| {\n+    pub fn signature_unclosure(\n+        self,\n+        sig: PolyFnSig<'tcx>,\n+        unsafety: hir::Unsafety,\n+    ) -> PolyFnSig<'tcx> {\n+        sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].kind {\n                 ty::Tuple(params) => params.into_iter().map(|k| k.expect_ty()),\n                 _ => bug!(),\n             };\n             self.mk_fn_sig(params_iter, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)\n-        });\n-\n-        self.mk_fn_ptr(converted_sig)\n+        })\n     }\n \n     #[allow(rustc::usage_of_ty_tykind)]"}, {"sha": "edab96badc8587db0e247fda24a8bf9031f316a7", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59cc5b1ba3e0996a6d80d1c229eb89900533cb98/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cc5b1ba3e0996a6d80d1c229eb89900533cb98/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=59cc5b1ba3e0996a6d80d1c229eb89900533cb98", "patch": "@@ -2087,7 +2087,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ty::Closure(_, substs) => substs.as_closure().sig(),\n                             _ => bug!(),\n                         };\n-                        let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig, *unsafety);\n+                        let ty_fn_ptr_from = tcx.mk_fn_ptr(tcx.signature_unclosure(sig, *unsafety));\n \n                         if let Err(terr) = self.eq_types(\n                             ty_fn_ptr_from,"}, {"sha": "a8093e7638d02fc97252a4f8c5d9a593e9c62529", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 69, "deletions": 22, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/59cc5b1ba3e0996a6d80d1c229eb89900533cb98/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cc5b1ba3e0996a6d80d1c229eb89900533cb98/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=59cc5b1ba3e0996a6d80d1c229eb89900533cb98", "patch": "@@ -759,7 +759,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 //     `unsafe fn(arg0,arg1,...) -> _`\n                 let closure_sig = substs_a.as_closure().sig();\n                 let unsafety = fn_ty.unsafety();\n-                let pointer_ty = self.tcx.coerce_closure_fn_ty(closure_sig, unsafety);\n+                let pointer_ty =\n+                    self.tcx.mk_fn_ptr(self.tcx.signature_unclosure(closure_sig, unsafety));\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\", a, b, pointer_ty);\n                 self.unify_and(\n                     pointer_ty,\n@@ -875,23 +876,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n-        // Two function item types of differing IDs or InternalSubsts.\n-        if let (&ty::FnDef(..), &ty::FnDef(..)) = (&prev_ty.kind, &new_ty.kind) {\n-            // Don't reify if the function types have a LUB, i.e., they\n-            // are the same function and their parameters have a LUB.\n-            let lub_ty = self\n-                .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                .map(|ok| self.register_infer_ok_obligations(ok));\n-\n-            if lub_ty.is_ok() {\n-                // We have a LUB of prev_ty and new_ty, just return it.\n-                return lub_ty;\n+        // Function items or non-capturing closures of differing IDs or InternalSubsts.\n+        let (a_sig, b_sig) = {\n+            let is_capturing_closure = |ty| {\n+                if let &ty::Closure(_, substs) = ty {\n+                    substs.as_closure().upvar_tys().next().is_some()\n+                } else {\n+                    false\n+                }\n+            };\n+            if is_capturing_closure(&prev_ty.kind) || is_capturing_closure(&new_ty.kind) {\n+                (None, None)\n+            } else {\n+                match (&prev_ty.kind, &new_ty.kind) {\n+                    (&ty::FnDef(..), &ty::FnDef(..)) => {\n+                        // Don't reify if the function types have a LUB, i.e., they\n+                        // are the same function and their parameters have a LUB.\n+                        match self\n+                            .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n+                        {\n+                            // We have a LUB of prev_ty and new_ty, just return it.\n+                            Ok(ok) => return Ok(self.register_infer_ok_obligations(ok)),\n+                            Err(_) => {\n+                                (Some(prev_ty.fn_sig(self.tcx)), Some(new_ty.fn_sig(self.tcx)))\n+                            }\n+                        }\n+                    }\n+                    (&ty::Closure(_, substs), &ty::FnDef(..)) => {\n+                        let b_sig = new_ty.fn_sig(self.tcx);\n+                        let a_sig = self\n+                            .tcx\n+                            .signature_unclosure(substs.as_closure().sig(), b_sig.unsafety());\n+                        (Some(a_sig), Some(b_sig))\n+                    }\n+                    (&ty::FnDef(..), &ty::Closure(_, substs)) => {\n+                        let a_sig = prev_ty.fn_sig(self.tcx);\n+                        let b_sig = self\n+                            .tcx\n+                            .signature_unclosure(substs.as_closure().sig(), a_sig.unsafety());\n+                        (Some(a_sig), Some(b_sig))\n+                    }\n+                    (&ty::Closure(_, substs_a), &ty::Closure(_, substs_b)) => (\n+                        Some(self.tcx.signature_unclosure(\n+                            substs_a.as_closure().sig(),\n+                            hir::Unsafety::Normal,\n+                        )),\n+                        Some(self.tcx.signature_unclosure(\n+                            substs_b.as_closure().sig(),\n+                            hir::Unsafety::Normal,\n+                        )),\n+                    ),\n+                    _ => (None, None),\n+                }\n             }\n-\n+        };\n+        if let (Some(a_sig), Some(b_sig)) = (a_sig, b_sig) {\n             // The signature must match.\n-            let a_sig = prev_ty.fn_sig(self.tcx);\n             let a_sig = self.normalize_associated_types_in(new.span, &a_sig);\n-            let b_sig = new_ty.fn_sig(self.tcx);\n             let b_sig = self.normalize_associated_types_in(new.span, &b_sig);\n             let sig = self\n                 .at(cause, self.param_env)\n@@ -901,17 +942,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Reify both sides and return the reified fn pointer type.\n             let fn_ptr = self.tcx.mk_fn_ptr(sig);\n-            for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                // The only adjustment that can produce an fn item is\n-                // `NeverToAny`, so this should always be valid.\n+            let prev_adjustment = match prev_ty.kind {\n+                ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(a_sig.unsafety())),\n+                ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                _ => unreachable!(),\n+            };\n+            let next_adjustment = match new_ty.kind {\n+                ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(b_sig.unsafety())),\n+                ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n+                _ => unreachable!(),\n+            };\n+            for expr in exprs.iter().map(|e| e.as_coercion_site()) {\n                 self.apply_adjustments(\n                     expr,\n-                    vec![Adjustment {\n-                        kind: Adjust::Pointer(PointerCast::ReifyFnPointer),\n-                        target: fn_ptr,\n-                    }],\n+                    vec![Adjustment { kind: prev_adjustment.clone(), target: fn_ptr }],\n                 );\n             }\n+            self.apply_adjustments(new, vec![Adjustment { kind: next_adjustment, target: fn_ptr }]);\n             return Ok(fn_ptr);\n         }\n "}]}