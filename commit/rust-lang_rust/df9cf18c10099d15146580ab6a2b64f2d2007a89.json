{"sha": "df9cf18c10099d15146580ab6a2b64f2d2007a89", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmOWNmMThjMTAwOTlkMTUxNDY1ODBhYjZhMmI2NGYyZDIwMDdhODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-29T09:56:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-29T09:56:40Z"}, "message": "auto merge of #13188 : FlaPer87/rust/master, r=alexcrichton", "tree": {"sha": "259e7a17e182a4d61d68a6878242689a556bae5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/259e7a17e182a4d61d68a6878242689a556bae5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df9cf18c10099d15146580ab6a2b64f2d2007a89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df9cf18c10099d15146580ab6a2b64f2d2007a89", "html_url": "https://github.com/rust-lang/rust/commit/df9cf18c10099d15146580ab6a2b64f2d2007a89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df9cf18c10099d15146580ab6a2b64f2d2007a89/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02d186ad9ba699f7824969fb60a19042613d5d60", "url": "https://api.github.com/repos/rust-lang/rust/commits/02d186ad9ba699f7824969fb60a19042613d5d60", "html_url": "https://github.com/rust-lang/rust/commit/02d186ad9ba699f7824969fb60a19042613d5d60"}, {"sha": "a9c6061c9a542a617020073d0a6b187849d0e348", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c6061c9a542a617020073d0a6b187849d0e348", "html_url": "https://github.com/rust-lang/rust/commit/a9c6061c9a542a617020073d0a6b187849d0e348"}], "stats": {"total": 5278, "additions": 153, "deletions": 5125}, "files": [{"sha": "7e7ccb8a1c60a4d1f572cb49fd17e68ea2a9e175", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -168,17 +168,6 @@ impl Input {\n     }\n }\n \n-// FIXME: remove unwrap_ after snapshot\n-#[cfg(stage0)]\n-fn unwrap_<T>(t: T) -> T {\n-    t\n-}\n-\n-#[cfg(not(stage0))]\n-fn unwrap_<T, E>(r: Result<T, E>) -> T {\n-    r.unwrap()\n-}\n-\n \n pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     -> ast::Crate {\n@@ -200,7 +189,7 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         // unwrapping so IoError isn't ignored\n-        unwrap_(krate.encode(&mut json));\n+        krate.encode(&mut json).unwrap();\n     }\n \n     if sess.show_span() {\n@@ -276,7 +265,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         // unwrapping so IoError isn't ignored\n-        unwrap_(krate.encode(&mut json));\n+        krate.encode(&mut json).unwrap();\n     }\n \n     (krate, map)"}, {"sha": "6cc16b0bfc91bd0419ea55a69d39cc1ff02a4f93", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -47,17 +47,6 @@ use syntax::crateid::CrateId;\n \n pub type Cmd = @crate_metadata;\n \n-// FIXME: remove unwrap_ after a snapshot\n-#[cfg(stage0)]\n-fn unwrap_<T>(t: T) -> T {\n-    t\n-}\n-\n-#[cfg(not(stage0))]\n-fn unwrap_<T, E>(r: Result<T, E>) -> T {\n-    r.unwrap()\n-}\n-\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -70,15 +59,15 @@ fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n     let pos = u64_from_be_bytes(d.data, hash_pos, 4) as uint;\n-    let tagged_doc = unwrap_(reader::doc_at(d.data, pos));\n+    let tagged_doc = reader::doc_at(d.data, pos).unwrap();\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n-            ret = Some(unwrap_(reader::doc_at(d.data, pos)).doc);\n+            ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n             true\n@@ -864,7 +853,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     let item_doc = lookup_item(id, data);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder(variance_doc);\n-    unwrap_(Decodable::decode(&mut decoder))\n+    Decodable::decode(&mut decoder).unwrap()\n }\n \n pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,"}, {"sha": "e30a5247f7f67abacbc2290a75ec33d103269bc2", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -62,11 +62,6 @@ pub enum InlinedItemRef<'a> {\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n-// FIXME: remove this Encoder type after a snapshot\n-#[cfg(stage0)]\n-pub type Encoder<'a> = writer::Encoder<'a>;\n-\n-#[cfg(not(stage0))]\n pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n \n pub type EncodeInlinedItem<'a> = 'a |ecx: &EncodeContext,"}, {"sha": "bd9d206c5b38a403dfcb8bc08f13f17e3402510b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 132, "deletions": 180, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -38,8 +38,6 @@ use std::libc;\n use std::cast;\n use std::cell::RefCell;\n use std::io::Seek;\n-// FIXME: remove this attr after snapshot\n-#[cfg(not(stage0))]\n use std::io::MemWriter;\n use std::rc::Rc;\n \n@@ -81,36 +79,8 @@ trait tr_intern {\n     fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n }\n \n-// FIXME: remove this Encoder type after snapshot\n-#[cfg(stage0)]\n-pub type Encoder<'a> = writer::Encoder<'a>;\n-\n-#[cfg(not(stage0))]\n pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n \n-// FIXME: remove unwrap_ and wrap_ after snapshot\n-#[cfg(stage0)]\n-fn unwrap_<T>(t: T) -> T {\n-    t\n-}\n-\n-#[cfg(not(stage0))]\n-fn unwrap_<T, E>(r: Result<T, E>) -> T {\n-    r.unwrap()\n-}\n-\n-#[cfg(stage0)]\n-fn wrap_<T>(t: T) -> T {\n-    t\n-}\n-\n-#[cfg(not(stage0))]\n-fn wrap_<T, E>(t: T) -> Result<T, E> {\n-    Ok(t)\n-}\n-\n-\n-\n // ______________________________________________________________________\n // Top-level methods.\n \n@@ -171,7 +141,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n             path_as_str.as_ref().map(|x| x.as_slice())\n         });\n         let mut ast_dsr = reader::Decoder(ast_doc);\n-        let from_id_range = unwrap_(Decodable::decode(&mut ast_dsr));\n+        let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n         let to_id_range = reserve_id_range(&dcx.tcx.sess, from_id_range);\n         let xcx = &ExtendedDecodeContext {\n             dcx: dcx,\n@@ -307,17 +277,9 @@ trait def_id_encoder_helpers {\n     fn emit_def_id(&mut self, did: ast::DefId);\n }\n \n-#[cfg(stage0)]\n-impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n-    fn emit_def_id(&mut self, did: ast::DefId) {\n-        did.encode(self)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n     fn emit_def_id(&mut self, did: ast::DefId) {\n-        unwrap_(did.encode(self))\n+        did.encode(self).unwrap()\n     }\n }\n \n@@ -327,30 +289,15 @@ trait def_id_decoder_helpers {\n                          cdata: @cstore::crate_metadata) -> ast::DefId;\n }\n \n-#[cfg(stage0)]\n-impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n-    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n-        let did: ast::DefId = unwrap_(Decodable::decode(self));\n-        did.tr(xcx)\n-    }\n-\n-    fn read_def_id_noxcx(&mut self,\n-                         cdata: @cstore::crate_metadata) -> ast::DefId {\n-        let did: ast::DefId = unwrap_(Decodable::decode(self));\n-        decoder::translate_def_id(cdata, did)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n     fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n-        let did: ast::DefId = unwrap_(Decodable::decode(self));\n+        let did: ast::DefId = Decodable::decode(self).unwrap();\n         did.tr(xcx)\n     }\n \n     fn read_def_id_noxcx(&mut self,\n                          cdata: @cstore::crate_metadata) -> ast::DefId {\n-        let did: ast::DefId = unwrap_(Decodable::decode(self));\n+        let did: ast::DefId = Decodable::decode(self).unwrap();\n         decoder::translate_def_id(cdata, did)\n     }\n }\n@@ -430,7 +377,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n-    unwrap_(Decodable::decode(&mut d))\n+    Decodable::decode(&mut d).unwrap()\n }\n \n struct AstRenumberer<'a> {\n@@ -476,7 +423,7 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n \n fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n     let mut dsr = reader::Decoder(doc);\n-    let def: ast::Def = unwrap_(Decodable::decode(&mut dsr));\n+    let def: ast::Def = Decodable::decode(&mut dsr).unwrap();\n     def.tr(xcx)\n }\n \n@@ -584,7 +531,7 @@ impl tr for ty::BoundRegion {\n // Encoding and decoding of freevar information\n \n fn encode_freevar_entry(ebml_w: &mut Encoder, fv: @freevar_entry) {\n-    unwrap_((*fv).encode(ebml_w))\n+    (*fv).encode(ebml_w).unwrap();\n }\n \n trait ebml_decoder_helper {\n@@ -595,7 +542,7 @@ trait ebml_decoder_helper {\n impl<'a> ebml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry {\n-        let fv: freevar_entry = unwrap_(Decodable::decode(self));\n+        let fv: freevar_entry = Decodable::decode(self).unwrap();\n         fv.tr(xcx)\n     }\n }\n@@ -620,7 +567,7 @@ trait capture_var_helper {\n impl<'a> capture_var_helper for reader::Decoder<'a> {\n     fn read_capture_var(&mut self, xcx: &ExtendedDecodeContext)\n                         -> moves::CaptureVar {\n-        let cvar: moves::CaptureVar = unwrap_(Decodable::decode(self));\n+        let cvar: moves::CaptureVar = Decodable::decode(self).unwrap();\n         cvar.tr(xcx)\n     }\n }\n@@ -646,42 +593,42 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n                         ebml_w: &mut Encoder,\n                         autoderef: u32,\n                         method: &MethodCallee) {\n-    unwrap_(ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n+    ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n         ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n             autoderef.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             method.origin.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"ty\", 2u, |ebml_w| {\n-            wrap_(ebml_w.emit_ty(ecx, method.ty))\n+            Ok(ebml_w.emit_ty(ecx, method.ty))\n         });\n         ebml_w.emit_struct_field(\"substs\", 3u, |ebml_w| {\n-            wrap_(ebml_w.emit_substs(ecx, &method.substs))\n+            Ok(ebml_w.emit_substs(ecx, &method.substs))\n         })\n-    }));\n+    }).unwrap();\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n     fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee) {\n-        unwrap_(self.read_struct(\"MethodCallee\", 4, |this| {\n-            let autoderef = unwrap_(this.read_struct_field(\"autoderef\", 0, |this| {\n+        self.read_struct(\"MethodCallee\", 4, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n                 Decodable::decode(this)\n-            }));\n-            wrap_((autoderef, MethodCallee {\n-                origin: unwrap_(this.read_struct_field(\"origin\", 1, |this| {\n+            }).unwrap();\n+            Ok((autoderef, MethodCallee {\n+                origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: MethodOrigin =\n-                        unwrap_(Decodable::decode(this));\n-                    wrap_(method_origin.tr(xcx))\n-                })),\n-                ty: unwrap_(this.read_struct_field(\"ty\", 2, |this| {\n-                    wrap_(this.read_ty(xcx))\n-                })),\n-                substs: unwrap_(this.read_struct_field(\"substs\", 3, |this| {\n-                    wrap_(this.read_substs(xcx))\n-                }))\n+                        Decodable::decode(this).unwrap();\n+                    Ok(method_origin.tr(xcx))\n+                }).unwrap(),\n+                ty: this.read_struct_field(\"ty\", 2, |this| {\n+                    Ok(this.read_ty(xcx))\n+                }).unwrap(),\n+                substs: this.read_struct_field(\"substs\", 3, |this| {\n+                    Ok(this.read_substs(xcx))\n+                }).unwrap()\n             }))\n-        }))\n+        }).unwrap()\n     }\n }\n \n@@ -716,14 +663,14 @@ fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n                               ebml_w: &mut Encoder,\n                               autoderef: u32,\n                               dr: typeck::vtable_res) {\n-    unwrap_(ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n+    ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n         ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n             autoderef.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"vtable_res\", 1u, |ebml_w| {\n-            wrap_(encode_vtable_res(ecx, ebml_w, dr))\n+            Ok(encode_vtable_res(ecx, ebml_w, dr))\n         })\n-    }))\n+    }).unwrap()\n }\n \n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n@@ -733,35 +680,35 @@ pub fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    unwrap_(ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n-        wrap_(encode_vtable_param_res(ecx, ebml_w, *param_tables))\n-    }))\n+    ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n+        Ok(encode_vtable_param_res(ecx, ebml_w, *param_tables))\n+    }).unwrap()\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut Encoder,\n                      param_tables: typeck::vtable_param_res) {\n-    unwrap_(ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n-        wrap_(encode_vtable_origin(ecx, ebml_w, vtable_origin))\n-    }))\n+    ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n+        Ok(encode_vtable_origin(ecx, ebml_w, vtable_origin))\n+    }).unwrap()\n }\n \n \n pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         ebml_w: &mut Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    unwrap_(ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n+    ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n             ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n                 ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    wrap_(ebml_w.emit_def_id(def_id))\n+                    Ok(ebml_w.emit_def_id(def_id))\n                 });\n                 ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    wrap_(ebml_w.emit_tys(ecx, tys.as_slice()))\n+                    Ok(ebml_w.emit_tys(ecx, tys.as_slice()))\n                 });\n                 ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n-                    wrap_(encode_vtable_res(ecx, ebml_w, vtable_res))\n+                    Ok(encode_vtable_res(ecx, ebml_w, vtable_res))\n                 })\n             })\n           }\n@@ -776,7 +723,7 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n             })\n           }\n         }\n-    }))\n+    }).unwrap()\n }\n \n pub trait vtable_decoder_helpers {\n@@ -800,71 +747,73 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                                 tcx: &ty::ctxt,\n                                 cdata: @cstore::crate_metadata)\n                                 -> (u32, typeck::vtable_res) {\n-        unwrap_(self.read_struct(\"VtableWithKey\", 2, |this| {\n-            let autoderef = unwrap_(this.read_struct_field(\"autoderef\", 0, |this| {\n+        self.read_struct(\"VtableWithKey\", 2, |this| {\n+            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n                 Decodable::decode(this)\n-            }));\n-            wrap_((autoderef, unwrap_(this.read_struct_field(\"vtable_res\", 1, |this| {\n-                wrap_(this.read_vtable_res(tcx, cdata))\n-            }))))\n-        }))\n+            }).unwrap();\n+            Ok((autoderef, this.read_struct_field(\"vtable_res\", 1, |this| {\n+                Ok(this.read_vtable_res(tcx, cdata))\n+            }).unwrap()))\n+        }).unwrap()\n     }\n \n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n-        @unwrap_(self.read_to_vec(|this|\n-                          wrap_(this.read_vtable_param_res(tcx, cdata))))\n+        @self.read_to_vec(|this|\n+                          Ok(this.read_vtable_param_res(tcx, cdata)))\n+             .unwrap()\n              .move_iter()\n              .collect()\n     }\n \n     fn read_vtable_param_res(&mut self,\n                              tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n-        @unwrap_(self.read_to_vec(|this|\n-                          wrap_(this.read_vtable_origin(tcx, cdata))))\n+        @self.read_to_vec(|this|\n+                          Ok(this.read_vtable_origin(tcx, cdata)))\n+             .unwrap()\n              .move_iter()\n              .collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n                           tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n         -> typeck::vtable_origin {\n-        unwrap_(self.read_enum(\"vtable_origin\", |this| {\n+        self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n                                     \"vtable_param\",\n                                     \"vtable_self\"],\n                                    |this, i| {\n-                wrap_(match i {\n+                Ok(match i {\n                   0 => {\n                     typeck::vtable_static(\n-                        unwrap_(this.read_enum_variant_arg(0u, |this| {\n-                            wrap_(this.read_def_id_noxcx(cdata))\n-                        })),\n-                        unwrap_(this.read_enum_variant_arg(1u, |this| {\n-                            wrap_(this.read_tys_noxcx(tcx, cdata))\n-                        })),\n-                        unwrap_(this.read_enum_variant_arg(2u, |this| {\n-                            wrap_(this.read_vtable_res(tcx, cdata))\n-                        }))\n+                        this.read_enum_variant_arg(0u, |this| {\n+                            Ok(this.read_def_id_noxcx(cdata))\n+                        }).unwrap(),\n+                        this.read_enum_variant_arg(1u, |this| {\n+                            Ok(this.read_tys_noxcx(tcx, cdata))\n+                        }).unwrap(),\n+                        this.read_enum_variant_arg(2u, |this| {\n+                            Ok(this.read_vtable_res(tcx, cdata))\n+                        }).unwrap()\n                     )\n                   }\n                   1 => {\n                     typeck::vtable_param(\n-                        unwrap_(this.read_enum_variant_arg(0u, |this| {\n+                        this.read_enum_variant_arg(0u, |this| {\n                             Decodable::decode(this)\n-                        })),\n-                        unwrap_(this.read_enum_variant_arg(1u, |this| {\n+                        }).unwrap(),\n+                        this.read_enum_variant_arg(1u, |this| {\n                             this.read_uint()\n-                        }))\n+                        }).unwrap()\n                     )\n                   }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n                 })\n             })\n-        }))\n+        }).unwrap()\n     }\n }\n \n@@ -902,22 +851,22 @@ trait ebml_writer_helpers {\n \n impl<'a> ebml_writer_helpers for Encoder<'a> {\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n-        self.emit_opaque(|this| wrap_(e::write_type(ecx, this, ty)));\n+        self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n     }\n \n     fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore) {\n-        self.emit_opaque(|this| wrap_(e::write_vstore(ecx, this, vstore)));\n+        self.emit_opaque(|this| Ok(e::write_vstore(ecx, this, vstore)));\n     }\n \n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n-        self.emit_from_vec(tys, |this, ty| wrap_(this.emit_ty(ecx, *ty)));\n+        self.emit_from_vec(tys, |this, ty| Ok(this.emit_ty(ecx, *ty)));\n     }\n \n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n         self.emit_opaque(|this| {\n-            wrap_(tyencode::enc_type_param_def(this.writer,\n+            Ok(tyencode::enc_type_param_def(this.writer,\n                                          &ecx.ty_str_ctxt(),\n                                          type_param_def))\n         });\n@@ -932,7 +881,7 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n                     this.emit_struct_field(\"type_param_defs\", 0, |this| {\n                         this.emit_from_vec(tpbt.generics.type_param_defs(),\n                                            |this, type_param_def| {\n-                            wrap_(this.emit_type_param_def(ecx, type_param_def))\n+                            Ok(this.emit_type_param_def(ecx, type_param_def))\n                         })\n                     });\n                     this.emit_struct_field(\"region_param_defs\", 1, |this| {\n@@ -941,13 +890,13 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n                 })\n             });\n             this.emit_struct_field(\"ty\", 1, |this| {\n-                wrap_(this.emit_ty(ecx, tpbt.ty))\n+                Ok(this.emit_ty(ecx, tpbt.ty))\n             })\n         });\n     }\n \n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &ty::substs) {\n-        self.emit_opaque(|this| wrap_(tyencode::enc_substs(this.writer,\n+        self.emit_opaque(|this| Ok(tyencode::enc_substs(this.writer,\n                                                            &ecx.ty_str_ctxt(),\n                                                            substs)));\n     }\n@@ -975,7 +924,7 @@ impl<'a> ebml_writer_helpers for Encoder<'a> {\n                         this.emit_enum_variant_arg(2, |this| m.encode(this));\n                         this.emit_enum_variant_arg(3, |this| b.encode(this));\n                         this.emit_enum_variant_arg(4, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(5, |this| wrap_(this.emit_substs(ecx, substs)))\n+                        this.emit_enum_variant_arg(5, |this| Ok(this.emit_substs(ecx, substs)))\n                     })\n                 }\n             }\n@@ -1060,7 +1009,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     for def in tcx.def_map.borrow().find(&id).iter() {\n         ebml_w.tag(c::tag_table_def, |ebml_w| {\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| unwrap_((*def).encode(ebml_w)));\n+            ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w).unwrap());\n         })\n     }\n \n@@ -1087,7 +1036,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                 ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n-                    wrap_(encode_freevar_entry(ebml_w, *fv_entry))\n+                    Ok(encode_freevar_entry(ebml_w, *fv_entry))\n                 });\n             })\n         })\n@@ -1218,20 +1167,21 @@ trait ebml_decoder_decoder_helpers {\n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n                      tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n-        unwrap_(self.read_opaque(|_, doc| {\n-            wrap_(tydecode::parse_ty_data(\n+        self.read_opaque(|_, doc| {\n+            Ok(tydecode::parse_ty_data(\n                 doc.data,\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n                 |_, id| decoder::translate_def_id(cdata, id)))\n-        }))\n+        }).unwrap()\n     }\n \n     fn read_tys_noxcx(&mut self,\n                       tcx: &ty::ctxt,\n                       cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n-        unwrap_(self.read_to_vec(|this| wrap_(this.read_ty_noxcx(tcx, cdata)) ))\n+        self.read_to_vec(|this| Ok(this.read_ty_noxcx(tcx, cdata)) )\n+            .unwrap()\n             .move_iter()\n             .collect()\n     }\n@@ -1242,7 +1192,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         // context.  However, we do not bother, because region types\n         // are not used during trans.\n \n-        return unwrap_(self.read_opaque(|this, doc| {\n+        return self.read_opaque(|this, doc| {\n             debug!(\"read_ty({})\", type_string(doc));\n \n             let ty = tydecode::parse_ty_data(\n@@ -1252,8 +1202,8 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n-            wrap_(ty)\n-        }));\n+            Ok(ty)\n+        }).unwrap();\n \n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n@@ -1265,95 +1215,96 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t> {\n-        unwrap_(self.read_to_vec(|this| wrap_(this.read_ty(xcx)))).move_iter().collect()\n+        self.read_to_vec(|this| Ok(this.read_ty(xcx))).unwrap().move_iter().collect()\n     }\n \n     fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n                            -> ty::TypeParameterDef {\n-        unwrap_(self.read_opaque(|this, doc| {\n-            wrap_(tydecode::parse_type_param_def_data(\n+        self.read_opaque(|this, doc| {\n+            Ok(tydecode::parse_type_param_def_data(\n                 doc.data,\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a)))\n-        }))\n+        }).unwrap()\n     }\n \n     fn read_ty_param_bounds_and_ty(&mut self, xcx: &ExtendedDecodeContext)\n                                    -> ty::ty_param_bounds_and_ty {\n-        unwrap_(self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n-            wrap_(ty::ty_param_bounds_and_ty {\n-                generics: unwrap_(this.read_struct_field(\"generics\", 0, |this| {\n+        self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n+            Ok(ty::ty_param_bounds_and_ty {\n+                generics: this.read_struct_field(\"generics\", 0, |this| {\n                     this.read_struct(\"Generics\", 2, |this| {\n-                        wrap_(ty::Generics {\n+                        Ok(ty::Generics {\n                             type_param_defs:\n-                                unwrap_(this.read_struct_field(\"type_param_defs\",\n+                                this.read_struct_field(\"type_param_defs\",\n                                                        0,\n                                                        |this| {\n-                                    wrap_(Rc::new(unwrap_(this.read_to_vec(|this|\n-                                                             wrap_(this.read_type_param_def(xcx))))\n+                                    Ok(Rc::new(this.read_to_vec(|this|\n+                                                             Ok(this.read_type_param_def(xcx)))\n+                                                .unwrap()\n                                                 .move_iter()\n                                                 .collect()))\n-                            })),\n+                            }).unwrap(),\n                             region_param_defs:\n-                                unwrap_(this.read_struct_field(\"region_param_defs\",\n+                                this.read_struct_field(\"region_param_defs\",\n                                                        1,\n                                                        |this| {\n                                     Decodable::decode(this)\n-                                }))\n+                                }).unwrap()\n                         })\n                     })\n-                })),\n-                ty: unwrap_(this.read_struct_field(\"ty\", 1, |this| {\n-                    wrap_(this.read_ty(xcx))\n-                }))\n+                }).unwrap(),\n+                ty: this.read_struct_field(\"ty\", 1, |this| {\n+                    Ok(this.read_ty(xcx))\n+                }).unwrap()\n             })\n-        }))\n+        }).unwrap()\n     }\n \n     fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> ty::substs {\n-        unwrap_(self.read_opaque(|this, doc| {\n-            wrap_(tydecode::parse_substs_data(doc.data,\n+        self.read_opaque(|this, doc| {\n+            Ok(tydecode::parse_substs_data(doc.data,\n                                         xcx.dcx.cdata.cnum,\n                                         doc.start,\n                                         xcx.dcx.tcx,\n                                         |s, a| this.convert_def_id(xcx, s, a)))\n-        }))\n+        }).unwrap()\n     }\n \n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment {\n-        unwrap_(self.read_enum(\"AutoAdjustment\", |this| {\n+        self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\", \"AutoObject\"];\n             this.read_enum_variant(variants, |this, i| {\n-                wrap_(match i {\n+                Ok(match i {\n                     0 => {\n                         let region: ty::Region =\n-                            unwrap_(this.read_enum_variant_arg(0, |this| Decodable::decode(this)));\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n                         let sigil: ast::Sigil =\n-                            unwrap_(this.read_enum_variant_arg(1, |this| Decodable::decode(this)));\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n                         ty:: AutoAddEnv(region.tr(xcx), sigil)\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n-                            unwrap_(this.read_enum_variant_arg(0, |this| Decodable::decode(this)));\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n                         ty::AutoDerefRef(auto_deref_ref.tr(xcx))\n                     }\n                     2 => {\n                         let sigil: ast::Sigil =\n-                            unwrap_(this.read_enum_variant_arg(0, |this| Decodable::decode(this)));\n+                            this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n                         let region: Option<ty::Region> =\n-                            unwrap_(this.read_enum_variant_arg(1, |this| Decodable::decode(this)));\n+                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n                         let m: ast::Mutability =\n-                            unwrap_(this.read_enum_variant_arg(2, |this| Decodable::decode(this)));\n+                            this.read_enum_variant_arg(2, |this| Decodable::decode(this)).unwrap();\n                         let b: ty::BuiltinBounds =\n-                            unwrap_(this.read_enum_variant_arg(3, |this| Decodable::decode(this)));\n+                            this.read_enum_variant_arg(3, |this| Decodable::decode(this)).unwrap();\n                         let def_id: ast::DefId =\n-                            unwrap_(this.read_enum_variant_arg(4, |this| Decodable::decode(this)));\n-                        let substs = unwrap_(\n-                            this.read_enum_variant_arg(5, |this| wrap_(this.read_substs(xcx))));\n+                            this.read_enum_variant_arg(4, |this| Decodable::decode(this)).unwrap();\n+                        let substs = this.read_enum_variant_arg(5, |this| Ok(this.read_substs(xcx)))\n+                                    .unwrap();\n \n                         let region = match region {\n                             Some(r) => Some(r.tr(xcx)),\n@@ -1365,7 +1316,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n                 })\n             })\n-        }))\n+        }).unwrap()\n     }\n \n     fn convert_def_id(&mut self,\n@@ -1448,9 +1399,9 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.node_type_substs.borrow_mut().insert(id, tys);\n                     }\n                     c::tag_table_freevars => {\n-                        let fv_info = @unwrap_(val_dsr.read_to_vec(|val_dsr| {\n-                            wrap_(@val_dsr.read_freevar_entry(xcx))\n-                        })).move_iter().collect();\n+                        let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n+                            Ok(@val_dsr.read_freevar_entry(xcx))\n+                        }).unwrap().move_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n                     c::tag_table_tcache => {\n@@ -1486,8 +1437,9 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n-                                unwrap_(val_dsr.read_to_vec(\n-                                            |val_dsr| wrap_(val_dsr.read_capture_var(xcx))))\n+                                val_dsr.read_to_vec(\n+                                            |val_dsr| Ok(val_dsr.read_capture_var(xcx)))\n+                                       .unwrap()\n                                        .move_iter()\n                                        .collect();\n                         dcx.maps.capture_map.borrow_mut().insert(id, Rc::new(cvars));\n@@ -1519,7 +1471,7 @@ fn encode_item_ast(ebml_w: &mut Encoder, item: @ast::Item) {\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n-    @unwrap_(Decodable::decode(&mut d))\n+    @Decodable::decode(&mut d).unwrap()\n }\n \n #[cfg(test)]"}, {"sha": "d16802a23145f0acb1442d093d7ede05013c7d6b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -327,17 +327,6 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     return pm.run_plugins(krate);\n }\n \n-// FIXME: remove unwrap_ after snapshot\n-#[cfg(stage0)]\n-fn unwrap_<T>(t: T) -> T {\n-    t\n-}\n-\n-#[cfg(not(stage0))]\n-fn unwrap_<T, E>(r: Result<T, E>) -> T {\n-    r.unwrap()\n-}\n-\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n@@ -363,7 +352,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             let krate = match obj.pop(&~\"crate\") {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n-                    unwrap_(Decodable::decode(&mut d))\n+                    Decodable::decode(&mut d).unwrap()\n                 }\n                 None => return Err(~\"malformed json\"),\n             };\n@@ -395,7 +384,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n         let mut w = MemWriter::new();\n         {\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n-            unwrap_(krate.encode(&mut encoder));\n+            krate.encode(&mut encoder).unwrap();\n         }\n         str::from_utf8_owned(w.unwrap()).unwrap()\n     };"}, {"sha": "5994fbc5d10051f7e94bfe936cd381c0b5b3c289", "filename": "src/libserialize/collection_impls_old.rs", "status": "removed", "additions": 0, "deletions": 292, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Fcollection_impls_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Fcollection_impls_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls_old.rs?ref=02d186ad9ba699f7824969fb60a19042613d5d60", "patch": "@@ -1,292 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementations of serialization for structures found in libcollections\n-\n-use std::uint;\n-use std::default::Default;\n-use std::hash::{Hash, Hasher};\n-\n-use {Decodable, Encodable, Decoder, Encoder};\n-use collections::{DList, RingBuf, TreeMap, TreeSet, Deque, HashMap, HashSet,\n-                  TrieMap, TrieSet};\n-use collections::enum_set::{EnumSet, CLike};\n-\n-impl<\n-    S: Encoder,\n-    T: Encodable<S>\n-> Encodable<S> for DList<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n-    fn decode(d: &mut D) -> DList<T> {\n-        let mut list = DList::new();\n-        d.read_seq(|d, len| {\n-            for i in range(0u, len) {\n-                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-        });\n-        list\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T: Encodable<S>\n-> Encodable<S> for RingBuf<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n-    fn decode(d: &mut D) -> RingBuf<T> {\n-        let mut deque = RingBuf::new();\n-        d.read_seq(|d, len| {\n-            for i in range(0u, len) {\n-                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-        });\n-        deque\n-    }\n-}\n-\n-impl<\n-    E: Encoder,\n-    K: Encodable<E> + Eq + TotalOrd,\n-    V: Encodable<E> + Eq\n-> Encodable<E> for TreeMap<K, V> {\n-    fn encode(&self, e: &mut E) {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self.iter() {\n-                e.emit_map_elt_key(i, |e| key.encode(e));\n-                e.emit_map_elt_val(i, |e| val.encode(e));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    K: Decodable<D> + Eq + TotalOrd,\n-    V: Decodable<D> + Eq\n-> Decodable<D> for TreeMap<K, V> {\n-    fn decode(d: &mut D) -> TreeMap<K, V> {\n-        d.read_map(|d, len| {\n-            let mut map = TreeMap::new();\n-            for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T: Encodable<S> + Eq + TotalOrd\n-> Encodable<S> for TreeSet<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self.iter() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T: Decodable<D> + Eq + TotalOrd\n-> Decodable<D> for TreeSet<T> {\n-    fn decode(d: &mut D) -> TreeSet<T> {\n-        d.read_seq(|d, len| {\n-            let mut set = TreeSet::new();\n-            for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T: Encodable<S> + CLike\n-> Encodable<S> for EnumSet<T> {\n-    fn encode(&self, s: &mut S) {\n-        let mut bits = 0;\n-        for item in self.iter() {\n-            bits |= item.to_uint();\n-        }\n-        s.emit_uint(bits);\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T: Decodable<D> + CLike\n-> Decodable<D> for EnumSet<T> {\n-    fn decode(d: &mut D) -> EnumSet<T> {\n-        let bits = d.read_uint();\n-        let mut set = EnumSet::empty();\n-        for bit in range(0, uint::BITS) {\n-            if bits & (1 << bit) != 0 {\n-                set.add(CLike::from_uint(1 << bit));\n-            }\n-        }\n-        set\n-    }\n-}\n-\n-impl<\n-    E: Encoder,\n-    K: Encodable<E> + Hash<S> + TotalEq,\n-    V: Encodable<E>,\n-    S,\n-    H: Hasher<S>\n-> Encodable<E> for HashMap<K, V, H> {\n-    fn encode(&self, e: &mut E) {\n-        e.emit_map(self.len(), |e| {\n-            let mut i = 0;\n-            for (key, val) in self.iter() {\n-                e.emit_map_elt_key(i, |e| key.encode(e));\n-                e.emit_map_elt_val(i, |e| val.encode(e));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    K: Decodable<D> + Hash<S> + TotalEq,\n-    V: Decodable<D>,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable<D> for HashMap<K, V, H> {\n-    fn decode(d: &mut D) -> HashMap<K, V, H> {\n-        d.read_map(|d, len| {\n-            let hasher = Default::default();\n-            let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n-            for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n-    }\n-}\n-\n-impl<\n-    E: Encoder,\n-    T: Encodable<E> + Hash<S> + TotalEq,\n-    S,\n-    H: Hasher<S>\n-> Encodable<E> for HashSet<T, H> {\n-    fn encode(&self, s: &mut E) {\n-        s.emit_seq(self.len(), |s| {\n-            let mut i = 0;\n-            for e in self.iter() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n-                i += 1;\n-            }\n-        })\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T: Decodable<D> + Hash<S> + TotalEq,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable<D> for HashSet<T, H> {\n-    fn decode(d: &mut D) -> HashSet<T, H> {\n-        d.read_seq(|d, len| {\n-            let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n-            for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n-    }\n-}\n-\n-impl<\n-    E: Encoder,\n-    V: Encodable<E>\n-> Encodable<E> for TrieMap<V> {\n-    fn encode(&self, e: &mut E) {\n-        e.emit_map(self.len(), |e| {\n-                for (i, (key, val)) in self.iter().enumerate() {\n-                    e.emit_map_elt_key(i, |e| key.encode(e));\n-                    e.emit_map_elt_val(i, |e| val.encode(e));\n-                }\n-            });\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    V: Decodable<D>\n-> Decodable<D> for TrieMap<V> {\n-    fn decode(d: &mut D) -> TrieMap<V> {\n-        d.read_map(|d, len| {\n-            let mut map = TrieMap::new();\n-            for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n-    }\n-}\n-\n-impl<S: Encoder> Encodable<S> for TrieSet {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-                for (i, e) in self.iter().enumerate() {\n-                    s.emit_seq_elt(i, |s| e.encode(s));\n-                }\n-            })\n-    }\n-}\n-\n-impl<D: Decoder> Decodable<D> for TrieSet {\n-    fn decode(d: &mut D) -> TrieSet {\n-        d.read_seq(|d, len| {\n-            let mut set = TrieSet::new();\n-            for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n-    }\n-}\n-"}, {"sha": "1c66960672fa0d54da175bf37ed1982c08841f7d", "filename": "src/libserialize/ebml_old.rs", "status": "removed", "additions": 0, "deletions": 1120, "changes": 1120, "blob_url": "https://github.com/rust-lang/rust/blob/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Febml_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Febml_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml_old.rs?ref=02d186ad9ba699f7824969fb60a19042613d5d60", "patch": "@@ -1,1120 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::str;\n-\n-macro_rules! try( ($e:expr) => (\n-    match $e { Ok(e) => e, Err(e) => { self.last_error = Err(e); return } }\n-) )\n-\n-// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n-// cursor model. See the specification here:\n-//     http://www.matroska.org/technical/specs/rfc/index.html\n-\n-// Common data structures\n-#[deriving(Clone)]\n-pub struct Doc<'a> {\n-    data: &'a [u8],\n-    start: uint,\n-    end: uint,\n-}\n-\n-impl<'doc> Doc<'doc> {\n-    pub fn get<'a>(&'a self, tag: uint) -> Doc<'a> {\n-        reader::get_doc(*self, tag)\n-    }\n-\n-    pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n-    }\n-\n-    pub fn as_str(&self) -> ~str {\n-        self.as_str_slice().to_owned()\n-    }\n-}\n-\n-pub struct TaggedDoc<'a> {\n-    priv tag: uint,\n-    doc: Doc<'a>,\n-}\n-\n-pub enum EbmlEncoderTag {\n-    EsUint,     // 0\n-    EsU64,      // 1\n-    EsU32,      // 2\n-    EsU16,      // 3\n-    EsU8,       // 4\n-    EsInt,      // 5\n-    EsI64,      // 6\n-    EsI32,      // 7\n-    EsI16,      // 8\n-    EsI8,       // 9\n-    EsBool,     // 10\n-    EsChar,     // 11\n-    EsStr,      // 12\n-    EsF64,      // 13\n-    EsF32,      // 14\n-    EsFloat,    // 15\n-    EsEnum,     // 16\n-    EsEnumVid,  // 17\n-    EsEnumBody, // 18\n-    EsVec,      // 19\n-    EsVecLen,   // 20\n-    EsVecElt,   // 21\n-    EsMap,      // 22\n-    EsMapLen,   // 23\n-    EsMapKey,   // 24\n-    EsMapVal,   // 25\n-\n-    EsOpaque,\n-\n-    EsLabel, // Used only when debugging\n-}\n-// --------------------------------------\n-\n-pub mod reader {\n-    use std::char;\n-\n-    use std::cast::transmute;\n-    use std::int;\n-    use std::option::{None, Option, Some};\n-    use std::io::extensions::u64_from_be_bytes;\n-\n-    use serialize;\n-\n-    use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n-        EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n-        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsEnumBody, EsUint,\n-        EsOpaque, EsLabel, EbmlEncoderTag, Doc, TaggedDoc };\n-\n-    // ebml reading\n-\n-    pub struct Res {\n-        val: uint,\n-        next: uint\n-    }\n-\n-    #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: uint) -> Res {\n-        let a = data[start];\n-        if a & 0x80u8 != 0u8 {\n-            return Res {val: (a & 0x7fu8) as uint, next: start + 1u};\n-        }\n-        if a & 0x40u8 != 0u8 {\n-            return Res {val: ((a & 0x3fu8) as uint) << 8u |\n-                        (data[start + 1u] as uint),\n-                    next: start + 2u};\n-        }\n-        if a & 0x20u8 != 0u8 {\n-            return Res {val: ((a & 0x1fu8) as uint) << 16u |\n-                        (data[start + 1u] as uint) << 8u |\n-                        (data[start + 2u] as uint),\n-                    next: start + 3u};\n-        }\n-        if a & 0x10u8 != 0u8 {\n-            return Res {val: ((a & 0x0fu8) as uint) << 24u |\n-                        (data[start + 1u] as uint) << 16u |\n-                        (data[start + 2u] as uint) << 8u |\n-                        (data[start + 3u] as uint),\n-                    next: start + 4u};\n-        }\n-        fail!(\"vint too big\");\n-    }\n-\n-    pub fn vuint_at(data: &[u8], start: uint) -> Res {\n-        use std::mem::from_be32;\n-\n-        if data.len() - start < 4 {\n-            return vuint_at_slow(data, start);\n-        }\n-\n-        // Lookup table for parsing EBML Element IDs as per http://ebml.sourceforge.net/specs/\n-        // The Element IDs are parsed by reading a big endian u32 positioned at data[start].\n-        // Using the four most significant bits of the u32 we lookup in the table below how the\n-        // element ID should be derived from it.\n-        //\n-        // The table stores tuples (shift, mask) where shift is the number the u32 should be right\n-        // shifted with and mask is the value the right shifted value should be masked with.\n-        // If for example the most significant bit is set this means it's a class A ID and the u32\n-        // should be right shifted with 24 and masked with 0x7f. Therefore we store (24, 0x7f) at\n-        // index 0x8 - 0xF (four bit numbers where the most significant bit is set).\n-        //\n-        // By storing the number of shifts and masks in a table instead of checking in order if\n-        // the most significant bit is set, the second most significant bit is set etc. we can\n-        // replace up to three \"and+branch\" with a single table lookup which gives us a measured\n-        // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(u32, u32), ..16] = [\n-            (0, 0x0), (0, 0x0fffffff),\n-            (8, 0x1fffff), (8, 0x1fffff),\n-            (16, 0x3fff), (16, 0x3fff), (16, 0x3fff), (16, 0x3fff),\n-            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f),\n-            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f)\n-        ];\n-\n-        unsafe {\n-            let ptr = data.as_ptr().offset(start as int) as *i32;\n-            let val = from_be32(*ptr) as u32;\n-\n-            let i = (val >> 28u) as uint;\n-            let (shift, mask) = SHIFT_MASK_TABLE[i];\n-            Res {\n-                val: ((val >> shift) & mask) as uint,\n-                next: start + (((32 - shift) >> 3) as uint)\n-            }\n-        }\n-    }\n-\n-    pub fn Doc<'a>(data: &'a [u8]) -> Doc<'a> {\n-        Doc { data: data, start: 0u, end: data.len() }\n-    }\n-\n-    pub fn doc_at<'a>(data: &'a [u8], start: uint) -> TaggedDoc<'a> {\n-        let elt_tag = vuint_at(data, start);\n-        let elt_size = vuint_at(data, elt_tag.next);\n-        let end = elt_size.next + elt_size.val;\n-        TaggedDoc {\n-            tag: elt_tag.val,\n-            doc: Doc { data: data, start: elt_size.next, end: end }\n-        }\n-    }\n-\n-    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: uint) -> Option<Doc<'a>> {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = vuint_at(d.data, pos);\n-            let elt_size = vuint_at(d.data, elt_tag.next);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                return Some(Doc { data: d.data, start: elt_size.next,\n-                                  end: pos });\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn get_doc<'a>(d: Doc<'a>, tg: uint) -> Doc<'a> {\n-        match maybe_get_doc(d, tg) {\n-            Some(d) => d,\n-            None => {\n-                error!(\"failed to find block with tag {}\", tg);\n-                fail!();\n-            }\n-        }\n-    }\n-\n-    pub fn docs<'a>(d: Doc<'a>, it: |uint, Doc<'a>| -> bool) -> bool {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = vuint_at(d.data, pos);\n-            let elt_size = vuint_at(d.data, elt_tag.next);\n-            pos = elt_size.next + elt_size.val;\n-            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n-            if !it(elt_tag.val, doc) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    pub fn tagged_docs<'a>(d: Doc<'a>, tg: uint, it: |Doc<'a>| -> bool) -> bool {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = vuint_at(d.data, pos);\n-            let elt_size = vuint_at(d.data, elt_tag.next);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                let doc = Doc { data: d.data, start: elt_size.next,\n-                                end: pos };\n-                if !it(doc) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n-        f(d.data.slice(d.start, d.end))\n-    }\n-\n-\n-    pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert_eq!(d.end, d.start + 1u);\n-        d.data[d.start]\n-    }\n-\n-    pub fn doc_as_u16(d: Doc) -> u16 {\n-        assert_eq!(d.end, d.start + 2u);\n-        u64_from_be_bytes(d.data, d.start, 2u) as u16\n-    }\n-\n-    pub fn doc_as_u32(d: Doc) -> u32 {\n-        assert_eq!(d.end, d.start + 4u);\n-        u64_from_be_bytes(d.data, d.start, 4u) as u32\n-    }\n-\n-    pub fn doc_as_u64(d: Doc) -> u64 {\n-        assert_eq!(d.end, d.start + 8u);\n-        u64_from_be_bytes(d.data, d.start, 8u)\n-    }\n-\n-    pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-    pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-    pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-    pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n-\n-    pub struct Decoder<'a> {\n-        priv parent: Doc<'a>,\n-        priv pos: uint,\n-    }\n-\n-    pub fn Decoder<'a>(d: Doc<'a>) -> Decoder<'a> {\n-        Decoder {\n-            parent: d,\n-            pos: d.start\n-        }\n-    }\n-\n-    impl<'doc> Decoder<'doc> {\n-        fn _check_label(&mut self, lbl: &str) {\n-            if self.pos < self.parent.end {\n-                let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                    doc_at(self.parent.data, self.pos);\n-\n-                if r_tag == (EsLabel as uint) {\n-                    self.pos = r_doc.end;\n-                    let str = r_doc.as_str_slice();\n-                    if lbl != str {\n-                        fail!(\"Expected label {} but found {}\", lbl, str);\n-                    }\n-                }\n-            }\n-        }\n-\n-        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc<'doc> {\n-            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n-            if self.pos >= self.parent.end {\n-                fail!(\"no more documents in current node!\");\n-            }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n-            debug!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n-                   self.parent.start,\n-                   self.parent.end,\n-                   self.pos,\n-                   r_tag,\n-                   r_doc.start,\n-                   r_doc.end);\n-            if r_tag != (exp_tag as uint) {\n-                fail!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                       exp_tag, r_tag);\n-            }\n-            if r_doc.end > self.parent.end {\n-                fail!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n-                      r_doc.end, self.parent.end);\n-            }\n-            self.pos = r_doc.end;\n-            r_doc\n-        }\n-\n-        fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n-                       f: |&mut Decoder<'doc>| -> T) -> T {\n-            let d = self.next_doc(exp_tag);\n-            let old_parent = self.parent;\n-            let old_pos = self.pos;\n-            self.parent = d;\n-            self.pos = d.start;\n-            let r = f(self);\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            r\n-        }\n-\n-        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n-            let r = doc_as_u32(self.next_doc(exp_tag));\n-            debug!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n-            r as uint\n-        }\n-\n-        pub fn read_opaque<R>(&mut self, op: |&mut Decoder<'doc>, Doc| -> R) -> R {\n-            let doc = self.next_doc(EsOpaque);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = doc.start;\n-\n-            let result = op(self, doc);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n-        }\n-    }\n-\n-    impl<'doc> serialize::Decoder for Decoder<'doc> {\n-        fn read_nil(&mut self) -> () { () }\n-\n-        fn read_u64(&mut self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n-        fn read_u32(&mut self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n-        fn read_u16(&mut self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n-        fn read_u8 (&mut self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n-        fn read_uint(&mut self) -> uint {\n-            let v = doc_as_u64(self.next_doc(EsUint));\n-            if v > (::std::uint::MAX as u64) {\n-                fail!(\"uint {} too large for this architecture\", v);\n-            }\n-            v as uint\n-        }\n-\n-        fn read_i64(&mut self) -> i64 {\n-            doc_as_u64(self.next_doc(EsI64)) as i64\n-        }\n-        fn read_i32(&mut self) -> i32 {\n-            doc_as_u32(self.next_doc(EsI32)) as i32\n-        }\n-        fn read_i16(&mut self) -> i16 {\n-            doc_as_u16(self.next_doc(EsI16)) as i16\n-        }\n-        fn read_i8 (&mut self) -> i8 {\n-            doc_as_u8(self.next_doc(EsI8 )) as i8\n-        }\n-        fn read_int(&mut self) -> int {\n-            let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n-            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n-                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                fail!(\"int {} out of range for this architecture\", v);\n-            }\n-            v as int\n-        }\n-\n-        fn read_bool(&mut self) -> bool {\n-            doc_as_u8(self.next_doc(EsBool)) != 0\n-        }\n-\n-        fn read_f64(&mut self) -> f64 {\n-            let bits = doc_as_u64(self.next_doc(EsF64));\n-            unsafe { transmute(bits) }\n-        }\n-        fn read_f32(&mut self) -> f32 {\n-            let bits = doc_as_u32(self.next_doc(EsF32));\n-            unsafe { transmute(bits) }\n-        }\n-        fn read_char(&mut self) -> char {\n-            char::from_u32(doc_as_u32(self.next_doc(EsChar))).unwrap()\n-        }\n-        fn read_str(&mut self) -> ~str {\n-            self.next_doc(EsStr).as_str()\n-        }\n-\n-        // Compound types:\n-        fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder<'doc>| -> T) -> T {\n-            debug!(\"read_enum({})\", name);\n-            self._check_label(name);\n-\n-            let doc = self.next_doc(EsEnum);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n-        }\n-\n-        fn read_enum_variant<T>(&mut self,\n-                                _: &[&str],\n-                                f: |&mut Decoder<'doc>, uint| -> T)\n-                                -> T {\n-            debug!(\"read_enum_variant()\");\n-            let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx={}\", idx);\n-\n-            let doc = self.next_doc(EsEnumBody);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self, idx);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n-        }\n-\n-        fn read_enum_variant_arg<T>(&mut self,\n-                                    idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> T) -> T {\n-            debug!(\"read_enum_variant_arg(idx={})\", idx);\n-            f(self)\n-        }\n-\n-        fn read_enum_struct_variant<T>(&mut self,\n-                                       _: &[&str],\n-                                       f: |&mut Decoder<'doc>, uint| -> T)\n-                                       -> T {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = self._next_uint(EsEnumVid);\n-            debug!(\"  idx={}\", idx);\n-\n-            let doc = self.next_doc(EsEnumBody);\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self, idx);\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            result\n-        }\n-\n-        fn read_enum_struct_variant_field<T>(&mut self,\n-                                             name: &str,\n-                                             idx: uint,\n-                                             f: |&mut Decoder<'doc>| -> T)\n-                                             -> T {\n-            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_struct<T>(&mut self,\n-                          name: &str,\n-                          _: uint,\n-                          f: |&mut Decoder<'doc>| -> T)\n-                          -> T {\n-            debug!(\"read_struct(name={})\", name);\n-            f(self)\n-        }\n-\n-        fn read_struct_field<T>(&mut self,\n-                                name: &str,\n-                                idx: uint,\n-                                f: |&mut Decoder<'doc>| -> T)\n-                                -> T {\n-            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            self._check_label(name);\n-            f(self)\n-        }\n-\n-        fn read_tuple<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(f)\n-        }\n-\n-        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                             -> T {\n-            debug!(\"read_tuple_arg(idx={})\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T>(&mut self,\n-                                name: &str,\n-                                f: |&mut Decoder<'doc>, uint| -> T)\n-                                -> T {\n-            debug!(\"read_tuple_struct(name={})\", name);\n-            self.read_tuple(f)\n-        }\n-\n-        fn read_tuple_struct_arg<T>(&mut self,\n-                                    idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> T)\n-                                    -> T {\n-            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T>(&mut self, f: |&mut Decoder<'doc>, bool| -> T) -> T {\n-            debug!(\"read_option()\");\n-            self.read_enum(\"Option\", |this| {\n-                this.read_enum_variant([\"None\", \"Some\"], |this, idx| {\n-                    match idx {\n-                        0 => f(this, false),\n-                        1 => f(this, true),\n-                        _ => fail!(),\n-                    }\n-                })\n-            })\n-        }\n-\n-        fn read_seq<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n-            debug!(\"read_seq()\");\n-            self.push_doc(EsVec, |d| {\n-                let len = d._next_uint(EsVecLen);\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                           -> T {\n-            debug!(\"read_seq_elt(idx={})\", idx);\n-            self.push_doc(EsVecElt, f)\n-        }\n-\n-        fn read_map<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n-            debug!(\"read_map()\");\n-            self.push_doc(EsMap, |d| {\n-                let len = d._next_uint(EsMapLen);\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                               -> T {\n-            debug!(\"read_map_elt_key(idx={})\", idx);\n-            self.push_doc(EsMapKey, f)\n-        }\n-\n-        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                               -> T {\n-            debug!(\"read_map_elt_val(idx={})\", idx);\n-            self.push_doc(EsMapVal, f)\n-        }\n-    }\n-}\n-\n-pub mod writer {\n-    use std::cast;\n-    use std::clone::Clone;\n-    use std::io;\n-    use std::io::{Writer, Seek};\n-    use std::io::MemWriter;\n-    use std::io::extensions::u64_to_be_bytes;\n-\n-    use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n-        EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n-        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsEnumBody, EsUint,\n-        EsOpaque, EsLabel, EbmlEncoderTag };\n-\n-    use serialize;\n-\n-    // ebml writing\n-    pub struct Encoder<'a> {\n-        // FIXME(#5665): this should take a trait object. Note that if you\n-        //               delete this comment you should consider removing the\n-        //               unwrap()'s below of the results of the calls to\n-        //               write(). We're guaranteed that writing into a MemWriter\n-        //               won't fail, but this is not true for all I/O streams in\n-        //               general.\n-        writer: &'a mut MemWriter,\n-        priv size_positions: ~[uint],\n-        last_error: io::IoResult<()>,\n-    }\n-\n-    fn write_sized_vuint(w: &mut MemWriter, n: uint, size: uint) {\n-        match size {\n-            1u => w.write(&[0x80u8 | (n as u8)]),\n-            2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n-            3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n-                            n as u8]),\n-            4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n-                            (n >> 8_u) as u8, n as u8]),\n-            _ => fail!(\"vint to write too big: {}\", n)\n-        }.unwrap()\n-    }\n-\n-    fn write_vuint(w: &mut MemWriter, n: uint) {\n-        if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n-        if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n-        if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n-        if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-        fail!(\"vint to write too big: {}\", n);\n-    }\n-\n-    pub fn Encoder<'a>(w: &'a mut MemWriter) -> Encoder<'a> {\n-        let size_positions: ~[uint] = ~[];\n-        Encoder {\n-            writer: w,\n-            size_positions: size_positions,\n-            last_error: Ok(()),\n-        }\n-    }\n-\n-    // FIXME (#2741): Provide a function to write the standard ebml header.\n-    impl<'a> Encoder<'a> {\n-        /// FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n-        pub unsafe fn unsafe_clone(&self) -> Encoder<'a> {\n-            Encoder {\n-                writer: cast::transmute_copy(&self.writer),\n-                size_positions: self.size_positions.clone(),\n-                last_error: Ok(()),\n-            }\n-        }\n-\n-        pub fn start_tag(&mut self, tag_id: uint) {\n-            debug!(\"Start tag {}\", tag_id);\n-\n-            // Write the enum ID:\n-            write_vuint(self.writer, tag_id);\n-\n-            // Write a placeholder four-byte size.\n-            self.size_positions.push(try!(self.writer.tell()) as uint);\n-            let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            try!(self.writer.write(zeroes));\n-        }\n-\n-        pub fn end_tag(&mut self) {\n-            let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = try!(self.writer.tell());\n-            try!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n-            let size = cur_pos as uint - last_size_pos - 4;\n-            write_sized_vuint(self.writer, size, 4u);\n-            try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n-\n-            debug!(\"End tag (size = {})\", size);\n-        }\n-\n-        pub fn wr_tag(&mut self, tag_id: uint, blk: ||) {\n-            self.start_tag(tag_id);\n-            blk();\n-            self.end_tag();\n-        }\n-\n-        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n-            write_vuint(self.writer, tag_id);\n-            write_vuint(self.writer, b.len());\n-            self.writer.write(b).unwrap();\n-        }\n-\n-        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n-            u64_to_be_bytes(v, 8u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            })\n-        }\n-\n-        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n-            u64_to_be_bytes(v as u64, 4u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            })\n-        }\n-\n-        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n-            u64_to_be_bytes(v as u64, 2u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            })\n-        }\n-\n-        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n-            self.wr_tagged_bytes(tag_id, &[v]);\n-        }\n-\n-        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n-            u64_to_be_bytes(v as u64, 8u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            })\n-        }\n-\n-        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n-            u64_to_be_bytes(v as u64, 4u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            })\n-        }\n-\n-        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n-            u64_to_be_bytes(v as u64, 2u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n-            })\n-        }\n-\n-        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n-            self.wr_tagged_bytes(tag_id, &[v as u8]);\n-        }\n-\n-        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n-            self.wr_tagged_bytes(tag_id, v.as_bytes());\n-        }\n-\n-        pub fn wr_bytes(&mut self, b: &[u8]) {\n-            debug!(\"Write {} bytes\", b.len());\n-            self.writer.write(b).unwrap();\n-        }\n-\n-        pub fn wr_str(&mut self, s: &str) {\n-            debug!(\"Write str: {}\", s);\n-            self.writer.write(s.as_bytes()).unwrap();\n-        }\n-    }\n-\n-    // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n-    // efficiently encode sizes; this is a fixed point iteration\n-\n-    // Set to true to generate more debugging in EBML code.\n-    // Totally lame approach.\n-    static DEBUG: bool = true;\n-\n-    impl<'a> Encoder<'a> {\n-        // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n-            assert!(v <= 0xFFFF_FFFF_u);\n-            self.wr_tagged_u32(t as uint, v as u32);\n-        }\n-\n-        fn _emit_label(&mut self, label: &str) {\n-            // There are various strings that we have access to, such as\n-            // the name of a record field, which do not actually appear in\n-            // the encoded EBML (normally).  This is just for\n-            // efficiency.  When debugging, though, we can emit such\n-            // labels and then they will be checked by decoder to\n-            // try and check failures more quickly.\n-            if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n-        }\n-\n-        pub fn emit_opaque(&mut self, f: |&mut Encoder|) {\n-            self.start_tag(EsOpaque as uint);\n-            f(self);\n-            self.end_tag();\n-        }\n-    }\n-\n-    impl<'a> serialize::Encoder for Encoder<'a> {\n-        fn emit_nil(&mut self) {}\n-\n-        fn emit_uint(&mut self, v: uint) {\n-            self.wr_tagged_u64(EsUint as uint, v as u64);\n-        }\n-        fn emit_u64(&mut self, v: u64) {\n-            self.wr_tagged_u64(EsU64 as uint, v);\n-        }\n-        fn emit_u32(&mut self, v: u32) {\n-            self.wr_tagged_u32(EsU32 as uint, v);\n-        }\n-        fn emit_u16(&mut self, v: u16) {\n-            self.wr_tagged_u16(EsU16 as uint, v);\n-        }\n-        fn emit_u8(&mut self, v: u8) {\n-            self.wr_tagged_u8(EsU8 as uint, v);\n-        }\n-\n-        fn emit_int(&mut self, v: int) {\n-            self.wr_tagged_i64(EsInt as uint, v as i64);\n-        }\n-        fn emit_i64(&mut self, v: i64) {\n-            self.wr_tagged_i64(EsI64 as uint, v);\n-        }\n-        fn emit_i32(&mut self, v: i32) {\n-            self.wr_tagged_i32(EsI32 as uint, v);\n-        }\n-        fn emit_i16(&mut self, v: i16) {\n-            self.wr_tagged_i16(EsI16 as uint, v);\n-        }\n-        fn emit_i8(&mut self, v: i8) {\n-            self.wr_tagged_i8(EsI8 as uint, v);\n-        }\n-\n-        fn emit_bool(&mut self, v: bool) {\n-            self.wr_tagged_u8(EsBool as uint, v as u8)\n-        }\n-\n-        fn emit_f64(&mut self, v: f64) {\n-            let bits = unsafe { cast::transmute(v) };\n-            self.wr_tagged_u64(EsF64 as uint, bits);\n-        }\n-        fn emit_f32(&mut self, v: f32) {\n-            let bits = unsafe { cast::transmute(v) };\n-            self.wr_tagged_u32(EsF32 as uint, bits);\n-        }\n-        fn emit_char(&mut self, v: char) {\n-            self.wr_tagged_u32(EsChar as uint, v as u32);\n-        }\n-\n-        fn emit_str(&mut self, v: &str) {\n-            self.wr_tagged_str(EsStr as uint, v)\n-        }\n-\n-        fn emit_enum(&mut self, name: &str, f: |&mut Encoder<'a>|) {\n-            self._emit_label(name);\n-            self.start_tag(EsEnum as uint);\n-            f(self);\n-            self.end_tag();\n-        }\n-\n-        fn emit_enum_variant(&mut self,\n-                             _: &str,\n-                             v_id: uint,\n-                             _: uint,\n-                             f: |&mut Encoder<'a>|) {\n-            self._emit_tagged_uint(EsEnumVid, v_id);\n-            self.start_tag(EsEnumBody as uint);\n-            f(self);\n-            self.end_tag();\n-        }\n-\n-        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder<'a>|) {\n-            f(self)\n-        }\n-\n-        fn emit_enum_struct_variant(&mut self,\n-                                    v_name: &str,\n-                                    v_id: uint,\n-                                    cnt: uint,\n-                                    f: |&mut Encoder<'a>|) {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field(&mut self,\n-                                          _: &str,\n-                                          idx: uint,\n-                                          f: |&mut Encoder<'a>|) {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct(&mut self,\n-                       _: &str,\n-                       _len: uint,\n-                       f: |&mut Encoder<'a>|) {\n-            f(self)\n-        }\n-\n-        fn emit_struct_field(&mut self,\n-                             name: &str,\n-                             _: uint,\n-                             f: |&mut Encoder<'a>|) {\n-            self._emit_label(name);\n-            f(self)\n-        }\n-\n-        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct(&mut self,\n-                             _: &str,\n-                             len: uint,\n-                             f: |&mut Encoder<'a>|) {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg(&mut self,\n-                                 idx: uint,\n-                                 f: |&mut Encoder<'a>|) {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option(&mut self, f: |&mut Encoder<'a>|) {\n-            self.emit_enum(\"Option\", f);\n-        }\n-        fn emit_option_none(&mut self) {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| ())\n-        }\n-        fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) {\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsVec as uint);\n-            self._emit_tagged_uint(EsVecLen, len);\n-            f(self);\n-            self.end_tag();\n-        }\n-\n-        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsVecElt as uint);\n-            f(self);\n-            self.end_tag();\n-        }\n-\n-        fn emit_map(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsMap as uint);\n-            self._emit_tagged_uint(EsMapLen, len);\n-            f(self);\n-            self.end_tag();\n-        }\n-\n-        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsMapKey as uint);\n-            f(self);\n-            self.end_tag();\n-        }\n-\n-        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsMapVal as uint);\n-            f(self);\n-            self.end_tag();\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[cfg(test)]\n-mod tests {\n-    use ebml::reader;\n-    use ebml::writer;\n-    use {Encodable, Decodable};\n-\n-    use std::io::MemWriter;\n-    use std::option::{None, Option, Some};\n-\n-    #[test]\n-    fn test_vuint_at() {\n-        let data = [\n-            0x80,\n-            0xff,\n-            0x40, 0x00,\n-            0x7f, 0xff,\n-            0x20, 0x00, 0x00,\n-            0x3f, 0xff, 0xff,\n-            0x10, 0x00, 0x00, 0x00,\n-            0x1f, 0xff, 0xff, 0xff\n-        ];\n-\n-        let mut res: reader::Res;\n-\n-        // Class A\n-        res = reader::vuint_at(data, 0);\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 1);\n-        res = reader::vuint_at(data, res.next);\n-        assert_eq!(res.val, (1 << 7) - 1);\n-        assert_eq!(res.next, 2);\n-\n-        // Class B\n-        res = reader::vuint_at(data, res.next);\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 4);\n-        res = reader::vuint_at(data, res.next);\n-        assert_eq!(res.val, (1 << 14) - 1);\n-        assert_eq!(res.next, 6);\n-\n-        // Class C\n-        res = reader::vuint_at(data, res.next);\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 9);\n-        res = reader::vuint_at(data, res.next);\n-        assert_eq!(res.val, (1 << 21) - 1);\n-        assert_eq!(res.next, 12);\n-\n-        // Class D\n-        res = reader::vuint_at(data, res.next);\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 16);\n-        res = reader::vuint_at(data, res.next);\n-        assert_eq!(res.val, (1 << 28) - 1);\n-        assert_eq!(res.next, 20);\n-    }\n-\n-    #[test]\n-    fn test_option_int() {\n-        fn test_v(v: Option<int>) {\n-            debug!(\"v == {:?}\", v);\n-            let mut wr = MemWriter::new();\n-            {\n-                let mut ebml_w = writer::Encoder(&mut wr);\n-                v.encode(&mut ebml_w);\n-            }\n-            let ebml_doc = reader::Doc(wr.get_ref());\n-            let mut deser = reader::Decoder(ebml_doc);\n-            let v1 = Decodable::decode(&mut deser);\n-            debug!(\"v1 == {:?}\", v1);\n-            assert_eq!(v, v1);\n-        }\n-\n-        test_v(Some(22));\n-        test_v(None);\n-        test_v(Some(3));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::BenchHarness;\n-    use ebml::reader;\n-\n-    #[bench]\n-    pub fn vuint_at_A_aligned(bh: &mut BenchHarness) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100, |i| {\n-            match i % 2 {\n-              0 => 0x80u8,\n-              _ => i as u8,\n-            }\n-        });\n-        let mut sum = 0u;\n-        bh.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_A_unaligned(bh: &mut BenchHarness) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100+1, |i| {\n-            match i % 2 {\n-              1 => 0x80u8,\n-              _ => i as u8\n-            }\n-        });\n-        let mut sum = 0u;\n-        bh.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_aligned(bh: &mut BenchHarness) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100, |i| {\n-            match i % 4 {\n-              0 => 0x10u8,\n-              3 => i as u8,\n-              _ => 0u8\n-            }\n-        });\n-        let mut sum = 0u;\n-        bh.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_unaligned(bh: &mut BenchHarness) {\n-        use std::slice;\n-        let data = slice::from_fn(4*100+1, |i| {\n-            match i % 4 {\n-              1 => 0x10u8,\n-              0 => i as u8,\n-              _ => 0u8\n-            }\n-        });\n-        let mut sum = 0u;\n-        bh.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n-                i += 4;\n-            }\n-        });\n-    }\n-}\n-"}, {"sha": "cc4c86599fae39b623afc4627d95f09f001cd21f", "filename": "src/libserialize/json_old.rs", "status": "removed", "additions": 0, "deletions": 2606, "changes": 2606, "blob_url": "https://github.com/rust-lang/rust/blob/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Fjson_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Fjson_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson_old.rs?ref=02d186ad9ba699f7824969fb60a19042613d5d60", "patch": "@@ -1,2606 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Rust JSON serialization library\n-// Copyright (c) 2011 Google Inc.\n-\n-#[forbid(non_camel_case_types)];\n-#[allow(missing_doc)];\n-\n-/*!\n-JSON parsing and serialization\n-\n-# What is JSON?\n-\n-JSON (JavaScript Object Notation) is a way to write data in Javascript.\n-Like XML it allows one to encode structured data in a text format that can be read by humans easily.\n-Its native compatibility with JavaScript and its simple syntax make it used widely.\n-\n-Json data are encoded in a form of \"key\":\"value\".\n-Data types that can be encoded are JavaScript types :\n-boolean (`true` or `false`), number (`f64`), string, array, object, null.\n-An object is a series of string keys mapping to values, in `\"key\": value` format.\n-Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n-A simple JSON document encoding a person, his/her age, address and phone numbers could look like:\n-\n-```ignore\n-{\n-    \"FirstName\": \"John\",\n-    \"LastName\": \"Doe\",\n-    \"Age\": 43,\n-    \"Address\": {\n-        \"Street\": \"Downing Street 10\",\n-        \"City\": \"London\",\n-        \"Country\": \"Great Britain\"\n-    },\n-    \"PhoneNumbers\": [\n-        \"+44 1234567\",\n-        \"+44 2345678\"\n-    ]\n-}\n-```\n-\n-# Rust Type-based Encoding and Decoding\n-\n-Rust provides a mechanism for low boilerplate encoding & decoding\n-of values to and from JSON via the serialization API.\n-To be able to encode a piece of data, it must implement the `serialize::Encodable` trait.\n-To be able to decode a piece of data, it must implement the `serialize::Decodable` trait.\n-The Rust compiler provides an annotation to automatically generate\n-the code for these traits: `#[deriving(Decodable, Encodable)]`\n-\n-To encode using Encodable :\n-\n-```rust\n-use std::io;\n-use serialize::{json, Encodable};\n-\n- #[deriving(Encodable)]\n- pub struct TestStruct   {\n-    data_str: ~str,\n- }\n-\n-fn main() {\n-    let to_encode_object = TestStruct{data_str:~\"example of string to encode\"};\n-    let mut m = io::MemWriter::new();\n-    {\n-        let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n-        to_encode_object.encode(&mut encoder);\n-    }\n-}\n-```\n-\n-Two wrapper functions are provided to encode a Encodable object\n-into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n-\n-```rust\n-use serialize::json;\n-let to_encode_object = ~\"example of string to encode\";\n-let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n-```\n-\n-JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n-The trait `ToJson` encode object into a container `json::Json` and the API provide writer\n-to encode them into a stream or a string ...\n-\n-When using `ToJson` the `Encodable` trait implementation is not mandatory.\n-\n-A basic `ToJson` example using a TreeMap of attribute name / attribute value:\n-\n-\n-```rust\n-extern crate collections;\n-extern crate serialize;\n-\n-use serialize::json;\n-use serialize::json::ToJson;\n-use collections::TreeMap;\n-\n-pub struct MyStruct  {\n-    attr1: u8,\n-    attr2: ~str,\n-}\n-\n-impl ToJson for MyStruct {\n-    fn to_json( &self ) -> json::Json {\n-        let mut d = ~TreeMap::new();\n-        d.insert(~\"attr1\", self.attr1.to_json());\n-        d.insert(~\"attr2\", self.attr2.to_json());\n-        json::Object(d)\n-    }\n-}\n-\n-fn main() {\n-    let test2: MyStruct = MyStruct {attr1: 1, attr2:~\"test\"};\n-    let tjson: json::Json = test2.to_json();\n-    let json_str: ~str = tjson.to_str();\n-}\n-```\n-\n-To decode a JSON string using `Decodable` trait :\n-\n-```rust\n-extern crate serialize;\n-use serialize::{json, Decodable};\n-\n-#[deriving(Decodable)]\n-pub struct MyStruct  {\n-     attr1: u8,\n-     attr2: ~str,\n-}\n-\n-fn main() {\n-    let json_str_to_decode: ~str =\n-            ~\"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\";\n-    let json_object = json::from_str(json_str_to_decode);\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded_object: MyStruct = Decodable::decode(&mut decoder); // create the final object\n-}\n-```\n-\n-# Examples of use\n-\n-## Using Autoserialization\n-\n-Create a struct called TestStruct1 and serialize and deserialize it to and from JSON\n-using the serialization API, using the derived serialization code.\n-\n-```rust\n-extern crate serialize;\n-use serialize::{json, Encodable, Decodable};\n-\n- #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n- pub struct TestStruct1  {\n-    data_int: u8,\n-    data_str: ~str,\n-    data_vector: ~[u8],\n- }\n-\n-// To serialize use the `json::str_encode` to encode an object in a string.\n-// It calls the generated `Encodable` impl.\n-fn main() {\n-    let to_encode_object = TestStruct1\n-         {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n-    let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n-\n-    // To deserialize use the `json::from_str` and `json::Decoder`\n-\n-    let json_object = json::from_str(encoded_str);\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded1: TestStruct1 = Decodable::decode(&mut decoder); // create the final object\n-}\n-```\n-\n-## Using `ToJson`\n-\n-This example use the ToJson impl to deserialize the JSON string.\n-Example of `ToJson` trait implementation for TestStruct1.\n-\n-```rust\n-extern crate serialize;\n-extern crate collections;\n-\n-use serialize::json::ToJson;\n-use serialize::{json, Encodable, Decodable};\n-use collections::TreeMap;\n-\n-#[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n-pub struct TestStruct1  {\n-    data_int: u8,\n-    data_str: ~str,\n-    data_vector: ~[u8],\n-}\n-\n-impl ToJson for TestStruct1 {\n-    fn to_json( &self ) -> json::Json {\n-        let mut d = ~TreeMap::new();\n-        d.insert(~\"data_int\", self.data_int.to_json());\n-        d.insert(~\"data_str\", self.data_str.to_json());\n-        d.insert(~\"data_vector\", self.data_vector.to_json());\n-        json::Object(d)\n-    }\n-}\n-\n-fn main() {\n-    // Serialization using our impl of to_json\n-\n-    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n-    let tjson: json::Json = test2.to_json();\n-    let json_str: ~str = tjson.to_str();\n-\n-    // Deserialize like before.\n-\n-    let mut decoder = json::Decoder::new(json::from_str(json_str).unwrap());\n-    // create the final object\n-    let decoded2: TestStruct1 = Decodable::decode(&mut decoder);\n-}\n-```\n-\n-*/\n-\n-use std::char;\n-use std::f64;\n-use collections::HashMap;\n-use std::io;\n-use std::io::MemWriter;\n-use std::num;\n-use std::str;\n-use std::fmt;\n-\n-use Encodable;\n-use collections::TreeMap;\n-\n-macro_rules! try( ($e:expr) => (\n-    match $e { Ok(e) => e, Err(e) => { self.error = Err(e); return } }\n-) )\n-\n-/// Represents a json value\n-#[deriving(Clone, Eq)]\n-pub enum Json {\n-    Number(f64),\n-    String(~str),\n-    Boolean(bool),\n-    List(List),\n-    Object(~Object),\n-    Null,\n-}\n-\n-pub type List = ~[Json];\n-pub type Object = TreeMap<~str, Json>;\n-\n-#[deriving(Eq)]\n-/// If an error occurs while parsing some JSON, this is the structure which is\n-/// returned\n-pub struct Error {\n-    /// The line number at which the error occurred\n-    priv line: uint,\n-    /// The column number at which the error occurred\n-    priv col: uint,\n-    /// A message describing the type of the error\n-    priv msg: ~str,\n-}\n-\n-fn io_error_to_error(io: io::IoError) -> Error {\n-    Error {\n-        line: 0,\n-        col: 0,\n-        msg: format!(\"io error: {}\", io)\n-    }\n-}\n-\n-fn escape_str(s: &str) -> ~str {\n-    let mut escaped = ~\"\\\"\";\n-    for c in s.chars() {\n-        match c {\n-          '\"' => escaped.push_str(\"\\\\\\\"\"),\n-          '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n-          '\\x08' => escaped.push_str(\"\\\\b\"),\n-          '\\x0c' => escaped.push_str(\"\\\\f\"),\n-          '\\n' => escaped.push_str(\"\\\\n\"),\n-          '\\r' => escaped.push_str(\"\\\\r\"),\n-          '\\t' => escaped.push_str(\"\\\\t\"),\n-          _ => escaped.push_char(c),\n-        }\n-    };\n-\n-    escaped.push_char('\"');\n-\n-    escaped\n-}\n-\n-fn spaces(n: uint) -> ~str {\n-    let mut ss = ~\"\";\n-    for _ in range(0, n) { ss.push_str(\" \"); }\n-    return ss;\n-}\n-\n-/// A structure for implementing serialization to JSON.\n-pub struct Encoder<'a> {\n-    priv wr: &'a mut io::Writer,\n-    priv error: io::IoResult<()>,\n-}\n-\n-impl<'a> Encoder<'a> {\n-    /// Creates a new JSON encoder whose output will be written to the writer\n-    /// specified.\n-    pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n-        Encoder { wr: wr, error: Ok(()) }\n-    }\n-\n-    /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~[u8]  {\n-       //Serialize the object in a string using a writer\n-        let mut m = MemWriter::new();\n-        {\n-            let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n-            to_encode_object.encode(&mut encoder);\n-        }\n-        m.unwrap()\n-    }\n-\n-    /// Encode the specified struct into a json str\n-    pub fn str_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n-        let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8_owned(buff).unwrap()\n-    }\n-}\n-\n-impl<'a> ::Encoder for Encoder<'a> {\n-    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")) }\n-\n-    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n-    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n-    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n-    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n-    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n-\n-    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n-    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n-    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n-    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n-    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n-\n-    fn emit_bool(&mut self, v: bool) {\n-        if v {\n-            try!(write!(self.wr, \"true\"));\n-        } else {\n-            try!(write!(self.wr, \"false\"));\n-        }\n-    }\n-\n-    fn emit_f64(&mut self, v: f64) {\n-        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)))\n-    }\n-    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n-\n-    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) {\n-        try!(write!(self.wr, \"{}\", escape_str(v)))\n-    }\n-\n-    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>|) { f(self) }\n-\n-    fn emit_enum_variant(&mut self,\n-                         name: &str,\n-                         _id: uint,\n-                         cnt: uint,\n-                         f: |&mut Encoder<'a>|) {\n-        // enums are encoded as strings or objects\n-        // Bunny => \"Bunny\"\n-        // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n-        if cnt == 0 {\n-            try!(write!(self.wr, \"{}\", escape_str(name)));\n-        } else {\n-            try!(write!(self.wr, \"\\\\{\\\"variant\\\":\"));\n-            try!(write!(self.wr, \"{}\", escape_str(name)));\n-            try!(write!(self.wr, \",\\\"fields\\\":[\"));\n-            f(self);\n-            try!(write!(self.wr, \"]\\\\}\"));\n-        }\n-    }\n-\n-    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        if idx != 0 {\n-            try!(write!(self.wr, \",\"));\n-        }\n-        f(self);\n-    }\n-\n-    fn emit_enum_struct_variant(&mut self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: |&mut Encoder<'a>|) {\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: |&mut Encoder<'a>|) {\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'a>|) {\n-        try!(write!(self.wr, r\"\\{\"));\n-        f(self);\n-        try!(write!(self.wr, r\"\\}\"));\n-    }\n-\n-    fn emit_struct_field(&mut self,\n-                         name: &str,\n-                         idx: uint,\n-                         f: |&mut Encoder<'a>|) {\n-        if idx != 0 { try!(write!(self.wr, \",\")) }\n-        try!(write!(self.wr, \"{}:\", escape_str(name)));\n-        f(self);\n-    }\n-\n-    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_tuple_struct(&mut self,\n-                         _name: &str,\n-                         len: uint,\n-                         f: |&mut Encoder<'a>|) {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n-    fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n-\n-    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        try!(write!(self.wr, \"[\"));\n-        f(self);\n-        try!(write!(self.wr, \"]\"));\n-    }\n-\n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        if idx != 0 {\n-            try!(write!(self.wr, \",\"));\n-        }\n-        f(self)\n-    }\n-\n-    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n-        try!(write!(self.wr, r\"\\{\"));\n-        f(self);\n-        try!(write!(self.wr, r\"\\}\"));\n-    }\n-\n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n-        use std::str::from_utf8;\n-        if idx != 0 { try!(write!(self.wr, \",\")) }\n-        // ref #12967, make sure to wrap a key in double quotes,\n-        // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = MemWriter::new();\n-        let mut check_encoder = Encoder::new(&mut buf);\n-        f(&mut check_encoder);\n-        let buf = buf.unwrap();\n-        let out = from_utf8(buf).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' &&\n-            out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n-        f(self);\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n-    }\n-\n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-        try!(write!(self.wr, \":\"));\n-        f(self)\n-    }\n-}\n-\n-/// Another encoder for JSON, but prints out human-readable JSON instead of\n-/// compact data\n-pub struct PrettyEncoder<'a> {\n-    priv wr: &'a mut io::Writer,\n-    priv indent: uint,\n-    priv error: io::IoResult<()>,\n-}\n-\n-impl<'a> PrettyEncoder<'a> {\n-    /// Creates a new encoder whose output will be written to the specified writer\n-    pub fn new<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n-        PrettyEncoder {\n-            wr: wr,\n-            indent: 0,\n-            error: Ok(())\n-        }\n-    }\n-}\n-\n-impl<'a> ::Encoder for PrettyEncoder<'a> {\n-    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")); }\n-\n-    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n-    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n-    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n-    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n-    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n-\n-    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n-    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n-    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n-    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n-    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n-\n-    fn emit_bool(&mut self, v: bool) {\n-        if v {\n-            try!(write!(self.wr, \"true\"));\n-        } else {\n-            try!(write!(self.wr, \"false\"));\n-        }\n-    }\n-\n-    fn emit_f64(&mut self, v: f64) {\n-        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)));\n-    }\n-    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n-\n-    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) {\n-        try!(write!(self.wr, \"{}\", escape_str(v)));\n-    }\n-\n-    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'a>|) {\n-        f(self)\n-    }\n-\n-    fn emit_enum_variant(&mut self,\n-                         name: &str,\n-                         _: uint,\n-                         cnt: uint,\n-                         f: |&mut PrettyEncoder<'a>|) {\n-        if cnt == 0 {\n-            try!(write!(self.wr, \"{}\", escape_str(name)));\n-        } else {\n-            self.indent += 2;\n-            try!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n-                          escape_str(name)));\n-            f(self);\n-            self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n-        }\n-    }\n-\n-    fn emit_enum_variant_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut PrettyEncoder<'a>|) {\n-        if idx != 0 {\n-            try!(write!(self.wr, \",\\n\"));\n-        }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n-        f(self)\n-    }\n-\n-    fn emit_enum_struct_variant(&mut self,\n-                                name: &str,\n-                                id: uint,\n-                                cnt: uint,\n-                                f: |&mut PrettyEncoder<'a>|) {\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      _: &str,\n-                                      idx: uint,\n-                                      f: |&mut PrettyEncoder<'a>|) {\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-\n-    fn emit_struct(&mut self,\n-                   _: &str,\n-                   len: uint,\n-                   f: |&mut PrettyEncoder<'a>|) {\n-        if len == 0 {\n-            try!(write!(self.wr, \"\\\\{\\\\}\"));\n-        } else {\n-            try!(write!(self.wr, \"\\\\{\"));\n-            self.indent += 2;\n-            f(self);\n-            self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n-        }\n-    }\n-\n-    fn emit_struct_field(&mut self,\n-                         name: &str,\n-                         idx: uint,\n-                         f: |&mut PrettyEncoder<'a>|) {\n-        if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n-        } else {\n-            try!(write!(self.wr, \",\\n\"));\n-        }\n-        try!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n-        f(self);\n-    }\n-\n-    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_tuple_struct(&mut self,\n-                         _: &str,\n-                         len: uint,\n-                         f: |&mut PrettyEncoder<'a>|) {\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg(&mut self,\n-                             idx: uint,\n-                             f: |&mut PrettyEncoder<'a>|) {\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n-    fn emit_option(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n-    fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n-\n-    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n-        if len == 0 {\n-            try!(write!(self.wr, \"[]\"));\n-        } else {\n-            try!(write!(self.wr, \"[\"));\n-            self.indent += 2;\n-            f(self);\n-            self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n-        }\n-    }\n-\n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n-        if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n-        } else {\n-            try!(write!(self.wr, \",\\n\"));\n-        }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n-        f(self)\n-    }\n-\n-    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n-        if len == 0 {\n-            try!(write!(self.wr, \"\\\\{\\\\}\"));\n-        } else {\n-            try!(write!(self.wr, \"\\\\{\"));\n-            self.indent += 2;\n-            f(self);\n-            self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n-        }\n-    }\n-\n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n-        use std::str::from_utf8;\n-        if idx == 0 {\n-            try!(write!(self.wr, \"\\n\"));\n-        } else {\n-            try!(write!(self.wr, \",\\n\"));\n-        }\n-        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n-        // ref #12967, make sure to wrap a key in double quotes,\n-        // in the event that its of a type that omits them (eg numbers)\n-        let mut buf = MemWriter::new();\n-        let mut check_encoder = PrettyEncoder::new(&mut buf);\n-        f(&mut check_encoder);\n-        let buf = buf.unwrap();\n-        let out = from_utf8(buf).unwrap();\n-        let needs_wrapping = out.char_at(0) != '\"' &&\n-            out.char_at_reverse(out.len()) != '\"';\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n-        f(self);\n-        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n-    }\n-\n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n-        try!(write!(self.wr, \": \"));\n-        f(self);\n-    }\n-}\n-\n-impl<E: ::Encoder> Encodable<E> for Json {\n-    fn encode(&self, e: &mut E) {\n-        match *self {\n-            Number(v) => v.encode(e),\n-            String(ref v) => v.encode(e),\n-            Boolean(v) => v.encode(e),\n-            List(ref v) => v.encode(e),\n-            Object(ref v) => v.encode(e),\n-            Null => e.emit_nil(),\n-        }\n-    }\n-}\n-\n-impl Json {\n-    /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n-        let mut encoder = Encoder::new(wr);\n-        self.encode(&mut encoder);\n-        encoder.error\n-    }\n-\n-    /// Encodes a json value into a io::writer.\n-    /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n-        let mut encoder = PrettyEncoder::new(wr);\n-        self.encode(&mut encoder);\n-        encoder.error\n-    }\n-\n-    /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> ~str {\n-        let mut s = MemWriter::new();\n-        self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8_owned(s.unwrap()).unwrap()\n-    }\n-\n-     /// If the Json value is an Object, returns the value associated with the provided key.\n-    /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &~str) -> Option<&'a Json>{\n-        match self {\n-            &Object(ref map) => map.find(key),\n-            _ => None\n-        }\n-    }\n-\n-    /// Attempts to get a nested Json Object for each key in `keys`.\n-    /// If any key is found not to exist, find_path will return None.\n-    /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&~str]) -> Option<&'a Json>{\n-        let mut target = self;\n-        for key in keys.iter() {\n-            match target.find(*key) {\n-                Some(t) => { target = t; },\n-                None => return None\n-            }\n-        }\n-        Some(target)\n-    }\n-\n-    /// If the Json value is an Object, performs a depth-first search until\n-    /// a value associated with the provided key is found. If no value is found\n-    /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &~str) -> Option<&'a Json> {\n-        match self {\n-            &Object(ref map) => {\n-                match map.find(key) {\n-                    Some(json_value) => Some(json_value),\n-                    None => {\n-                        let mut value : Option<&'a Json> = None;\n-                        for (_, v) in map.iter() {\n-                            value = v.search(key);\n-                            if value.is_some() {\n-                                break;\n-                            }\n-                        }\n-                        value\n-                    }\n-                }\n-            },\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns true if the Json value is an Object. Returns false otherwise.\n-    pub fn is_object<'a>(&'a self) -> bool {\n-        self.as_object().is_some()\n-    }\n-\n-    /// If the Json value is an Object, returns the associated TreeMap.\n-    /// Returns None otherwise.\n-    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n-        match self {\n-            &Object(ref map) => Some(&**map),\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns true if the Json value is a List. Returns false otherwise.\n-    pub fn is_list<'a>(&'a self) -> bool {\n-        self.as_list().is_some()\n-    }\n-\n-    /// If the Json value is a List, returns the associated vector.\n-    /// Returns None otherwise.\n-    pub fn as_list<'a>(&'a self) -> Option<&'a List> {\n-        match self {\n-            &List(ref list) => Some(&*list),\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns true if the Json value is a String. Returns false otherwise.\n-    pub fn is_string<'a>(&'a self) -> bool {\n-        self.as_string().is_some()\n-    }\n-\n-    /// If the Json value is a String, returns the associated str.\n-    /// Returns None otherwise.\n-    pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n-        match *self {\n-            String(ref s) => Some(s.as_slice()),\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns true if the Json value is a Number. Returns false otherwise.\n-    pub fn is_number(&self) -> bool {\n-        self.as_number().is_some()\n-    }\n-\n-    /// If the Json value is a Number, returns the associated f64.\n-    /// Returns None otherwise.\n-    pub fn as_number(&self) -> Option<f64> {\n-        match self {\n-            &Number(n) => Some(n),\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns true if the Json value is a Boolean. Returns false otherwise.\n-    pub fn is_boolean(&self) -> bool {\n-        self.as_boolean().is_some()\n-    }\n-\n-    /// If the Json value is a Boolean, returns the associated bool.\n-    /// Returns None otherwise.\n-    pub fn as_boolean(&self) -> Option<bool> {\n-        match self {\n-            &Boolean(b) => Some(b),\n-            _ => None\n-        }\n-    }\n-\n-    /// Returns true if the Json value is a Null. Returns false otherwise.\n-    pub fn is_null(&self) -> bool {\n-        self.as_null().is_some()\n-    }\n-\n-    /// If the Json value is a Null, returns ().\n-    /// Returns None otherwise.\n-    pub fn as_null(&self) -> Option<()> {\n-        match self {\n-            &Null => Some(()),\n-            _ => None\n-        }\n-    }\n-}\n-\n-pub struct Parser<T> {\n-    priv rdr: T,\n-    priv ch: Option<char>,\n-    priv line: uint,\n-    priv col: uint,\n-}\n-\n-impl<T: Iterator<char>> Parser<T> {\n-    /// Decode a json value from an Iterator<char>\n-    pub fn new(rdr: T) -> Parser<T> {\n-        let mut p = Parser {\n-            rdr: rdr,\n-            ch: Some('\\x00'),\n-            line: 1,\n-            col: 0,\n-        };\n-        p.bump();\n-        p\n-    }\n-}\n-\n-impl<T: Iterator<char>> Parser<T> {\n-    pub fn parse(&mut self) -> Result<Json, Error> {\n-        match self.parse_value() {\n-          Ok(value) => {\n-            // Skip trailing whitespaces.\n-            self.parse_whitespace();\n-            // Make sure there is no trailing characters.\n-            if self.eof() {\n-                Ok(value)\n-            } else {\n-                self.error(~\"trailing characters\")\n-            }\n-          }\n-          Err(e) => Err(e)\n-        }\n-    }\n-}\n-\n-impl<T : Iterator<char>> Parser<T> {\n-    fn eof(&self) -> bool { self.ch.is_none() }\n-    fn ch_or_null(&self) -> char { self.ch.unwrap_or('\\x00') }\n-    fn bump(&mut self) {\n-        self.ch = self.rdr.next();\n-\n-        if self.ch_is('\\n') {\n-            self.line += 1u;\n-            self.col = 1u;\n-        } else {\n-            self.col += 1u;\n-        }\n-    }\n-\n-    fn next_char(&mut self) -> Option<char> {\n-        self.bump();\n-        self.ch\n-    }\n-    fn ch_is(&self, c: char) -> bool {\n-        self.ch == Some(c)\n-    }\n-\n-    fn error<T>(&self, msg: ~str) -> Result<T, Error> {\n-        Err(Error { line: self.line, col: self.col, msg: msg })\n-    }\n-\n-    fn parse_value(&mut self) -> Result<Json, Error> {\n-        self.parse_whitespace();\n-\n-        if self.eof() { return self.error(~\"EOF while parsing value\"); }\n-\n-        match self.ch_or_null() {\n-            'n' => self.parse_ident(\"ull\", Null),\n-            't' => self.parse_ident(\"rue\", Boolean(true)),\n-            'f' => self.parse_ident(\"alse\", Boolean(false)),\n-            '0' .. '9' | '-' => self.parse_number(),\n-            '\"' => {\n-                match self.parse_str() {\n-                    Ok(s) => Ok(String(s)),\n-                    Err(e) => Err(e),\n-                }\n-            },\n-            '[' => self.parse_list(),\n-            '{' => self.parse_object(),\n-            _ => self.error(~\"invalid syntax\"),\n-        }\n-    }\n-\n-    fn parse_whitespace(&mut self) {\n-        while self.ch_is(' ') ||\n-              self.ch_is('\\n') ||\n-              self.ch_is('\\t') ||\n-              self.ch_is('\\r') { self.bump(); }\n-    }\n-\n-    fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n-        if ident.chars().all(|c| Some(c) == self.next_char()) {\n-            self.bump();\n-            Ok(value)\n-        } else {\n-            self.error(~\"invalid syntax\")\n-        }\n-    }\n-\n-    fn parse_number(&mut self) -> Result<Json, Error> {\n-        let mut neg = 1.0;\n-\n-        if self.ch_is('-') {\n-            self.bump();\n-            neg = -1.0;\n-        }\n-\n-        let mut res = match self.parse_integer() {\n-          Ok(res) => res,\n-          Err(e) => return Err(e)\n-        };\n-\n-        if self.ch_is('.') {\n-            match self.parse_decimal(res) {\n-              Ok(r) => res = r,\n-              Err(e) => return Err(e)\n-            }\n-        }\n-\n-        if self.ch_is('e') || self.ch_is('E') {\n-            match self.parse_exponent(res) {\n-              Ok(r) => res = r,\n-              Err(e) => return Err(e)\n-            }\n-        }\n-\n-        Ok(Number(neg * res))\n-    }\n-\n-    fn parse_integer(&mut self) -> Result<f64, Error> {\n-        let mut res = 0.0;\n-\n-        match self.ch_or_null() {\n-            '0' => {\n-                self.bump();\n-\n-                // There can be only one leading '0'.\n-                match self.ch_or_null() {\n-                    '0' .. '9' => return self.error(~\"invalid number\"),\n-                    _ => ()\n-                }\n-            },\n-            '1' .. '9' => {\n-                while !self.eof() {\n-                    match self.ch_or_null() {\n-                        c @ '0' .. '9' => {\n-                            res *= 10.0;\n-                            res += ((c as int) - ('0' as int)) as f64;\n-\n-                            self.bump();\n-                        }\n-                        _ => break,\n-                    }\n-                }\n-            }\n-            _ => return self.error(~\"invalid number\"),\n-        }\n-        Ok(res)\n-    }\n-\n-    fn parse_decimal(&mut self, res: f64) -> Result<f64, Error> {\n-        self.bump();\n-\n-        // Make sure a digit follows the decimal place.\n-        match self.ch_or_null() {\n-            '0' .. '9' => (),\n-             _ => return self.error(~\"invalid number\")\n-        }\n-\n-        let mut res = res;\n-        let mut dec = 1.0;\n-        while !self.eof() {\n-            match self.ch_or_null() {\n-                c @ '0' .. '9' => {\n-                    dec /= 10.0;\n-                    res += (((c as int) - ('0' as int)) as f64) * dec;\n-\n-                    self.bump();\n-                }\n-                _ => break,\n-            }\n-        }\n-\n-        Ok(res)\n-    }\n-\n-    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, Error> {\n-        self.bump();\n-\n-        let mut exp = 0u;\n-        let mut neg_exp = false;\n-\n-        if self.ch_is('+') {\n-            self.bump();\n-        } else if self.ch_is('-') {\n-            self.bump();\n-            neg_exp = true;\n-        }\n-\n-        // Make sure a digit follows the exponent place.\n-        match self.ch_or_null() {\n-            '0' .. '9' => (),\n-            _ => return self.error(~\"invalid number\")\n-        }\n-        while !self.eof() {\n-            match self.ch_or_null() {\n-                c @ '0' .. '9' => {\n-                    exp *= 10;\n-                    exp += (c as uint) - ('0' as uint);\n-\n-                    self.bump();\n-                }\n-                _ => break\n-            }\n-        }\n-\n-        let exp: f64 = num::pow(10u as f64, exp);\n-        if neg_exp {\n-            res /= exp;\n-        } else {\n-            res *= exp;\n-        }\n-\n-        Ok(res)\n-    }\n-\n-    fn parse_str(&mut self) -> Result<~str, Error> {\n-        let mut escape = false;\n-        let mut res = ~\"\";\n-\n-        loop {\n-            self.bump();\n-            if self.eof() {\n-                return self.error(~\"EOF while parsing string\");\n-            }\n-\n-            if escape {\n-                match self.ch_or_null() {\n-                    '\"' => res.push_char('\"'),\n-                    '\\\\' => res.push_char('\\\\'),\n-                    '/' => res.push_char('/'),\n-                    'b' => res.push_char('\\x08'),\n-                    'f' => res.push_char('\\x0c'),\n-                    'n' => res.push_char('\\n'),\n-                    'r' => res.push_char('\\r'),\n-                    't' => res.push_char('\\t'),\n-                    'u' => {\n-                        // Parse \\u1234.\n-                        let mut i = 0u;\n-                        let mut n = 0u;\n-                        while i < 4u && !self.eof() {\n-                            self.bump();\n-                            n = match self.ch_or_null() {\n-                                c @ '0' .. '9' => n * 16u + (c as uint) - ('0' as uint),\n-                                'a' | 'A' => n * 16u + 10u,\n-                                'b' | 'B' => n * 16u + 11u,\n-                                'c' | 'C' => n * 16u + 12u,\n-                                'd' | 'D' => n * 16u + 13u,\n-                                'e' | 'E' => n * 16u + 14u,\n-                                'f' | 'F' => n * 16u + 15u,\n-                                _ => return self.error(\n-                                    ~\"invalid \\\\u escape (unrecognized hex)\")\n-                            };\n-\n-                            i += 1u;\n-                        }\n-\n-                        // Error out if we didn't parse 4 digits.\n-                        if i != 4u {\n-                            return self.error(\n-                                ~\"invalid \\\\u escape (not four digits)\");\n-                        }\n-\n-                        res.push_char(char::from_u32(n as u32).unwrap());\n-                    }\n-                    _ => return self.error(~\"invalid escape\"),\n-                }\n-                escape = false;\n-            } else if self.ch_is('\\\\') {\n-                escape = true;\n-            } else {\n-                match self.ch {\n-                    Some('\"') => { self.bump(); return Ok(res); },\n-                    Some(c) => res.push_char(c),\n-                    None => unreachable!()\n-                }\n-            }\n-        }\n-    }\n-\n-    fn parse_list(&mut self) -> Result<Json, Error> {\n-        self.bump();\n-        self.parse_whitespace();\n-\n-        let mut values = ~[];\n-\n-        if self.ch_is(']') {\n-            self.bump();\n-            return Ok(List(values));\n-        }\n-\n-        loop {\n-            match self.parse_value() {\n-              Ok(v) => values.push(v),\n-              Err(e) => return Err(e)\n-            }\n-\n-            self.parse_whitespace();\n-            if self.eof() {\n-                return self.error(~\"EOF while parsing list\");\n-            }\n-\n-            if self.ch_is(',') {\n-                self.bump();\n-            } else if self.ch_is(']') {\n-                self.bump();\n-                return Ok(List(values));\n-            } else {\n-                return self.error(~\"expected `,` or `]`\")\n-            }\n-        };\n-    }\n-\n-    fn parse_object(&mut self) -> Result<Json, Error> {\n-        self.bump();\n-        self.parse_whitespace();\n-\n-        let mut values = ~TreeMap::new();\n-\n-        if self.ch_is('}') {\n-          self.bump();\n-          return Ok(Object(values));\n-        }\n-\n-        while !self.eof() {\n-            self.parse_whitespace();\n-\n-            if !self.ch_is('\"') {\n-                return self.error(~\"key must be a string\");\n-            }\n-\n-            let key = match self.parse_str() {\n-              Ok(key) => key,\n-              Err(e) => return Err(e)\n-            };\n-\n-            self.parse_whitespace();\n-\n-            if !self.ch_is(':') {\n-                if self.eof() { break; }\n-                return self.error(~\"expected `:`\");\n-            }\n-            self.bump();\n-\n-            match self.parse_value() {\n-              Ok(value) => { values.insert(key, value); }\n-              Err(e) => return Err(e)\n-            }\n-            self.parse_whitespace();\n-\n-            match self.ch_or_null() {\n-                ',' => self.bump(),\n-                '}' => { self.bump(); return Ok(Object(values)); },\n-                _ => {\n-                    if self.eof() { break; }\n-                    return self.error(~\"expected `,` or `}`\");\n-                }\n-            }\n-        }\n-\n-        return self.error(~\"EOF while parsing object\");\n-    }\n-}\n-\n-/// Decodes a json value from an `&mut io::Reader`\n-pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n-    let contents = match rdr.read_to_end() {\n-        Ok(c) => c,\n-        Err(e) => return Err(io_error_to_error(e))\n-    };\n-    let s = match str::from_utf8_owned(contents) {\n-        Some(s) => s,\n-        None => return Err(Error { line: 0, col: 0, msg: ~\"contents not utf-8\" })\n-    };\n-    let mut parser = Parser::new(s.chars());\n-    parser.parse()\n-}\n-\n-/// Decodes a json value from a string\n-pub fn from_str(s: &str) -> Result<Json, Error> {\n-    let mut parser = Parser::new(s.chars());\n-    parser.parse()\n-}\n-\n-/// A structure to decode JSON to values in rust.\n-pub struct Decoder {\n-    priv stack: ~[Json],\n-}\n-\n-impl Decoder {\n-    /// Creates a new decoder instance for decoding the specified JSON value.\n-    pub fn new(json: Json) -> Decoder {\n-        Decoder {\n-            stack: ~[json]\n-        }\n-    }\n-}\n-\n-impl Decoder {\n-    fn err(&self, msg: &str) -> ! {\n-        fail!(\"JSON decode error: {}\", msg);\n-    }\n-    fn missing_field(&self, field: &str, object: ~Object) -> ! {\n-        self.err(format!(\"missing required '{}' field in object: {}\",\n-                         field, Object(object).to_str()))\n-    }\n-    fn expected(&self, expected: &str, found: &Json) -> ! {\n-        let found_s = match *found {\n-            Null => \"null\",\n-            List(..) => \"list\",\n-            Object(..) => \"object\",\n-            Number(..) => \"number\",\n-            String(..) => \"string\",\n-            Boolean(..) => \"boolean\"\n-        };\n-        self.err(format!(\"expected {expct} but found {fnd}: {val}\",\n-                         expct=expected, fnd=found_s, val=found.to_str()))\n-    }\n-}\n-\n-impl ::Decoder for Decoder {\n-    fn read_nil(&mut self) -> () {\n-        debug!(\"read_nil\");\n-        match self.stack.pop().unwrap() {\n-            Null => (),\n-            value => self.expected(\"null\", &value)\n-        }\n-    }\n-\n-    fn read_u64(&mut self)  -> u64  { self.read_f64() as u64 }\n-    fn read_u32(&mut self)  -> u32  { self.read_f64() as u32 }\n-    fn read_u16(&mut self)  -> u16  { self.read_f64() as u16 }\n-    fn read_u8 (&mut self)  -> u8   { self.read_f64() as u8 }\n-    fn read_uint(&mut self) -> uint { self.read_f64() as uint }\n-\n-    fn read_i64(&mut self) -> i64 { self.read_f64() as i64 }\n-    fn read_i32(&mut self) -> i32 { self.read_f64() as i32 }\n-    fn read_i16(&mut self) -> i16 { self.read_f64() as i16 }\n-    fn read_i8 (&mut self) -> i8  { self.read_f64() as i8 }\n-    fn read_int(&mut self) -> int { self.read_f64() as int }\n-\n-    fn read_bool(&mut self) -> bool {\n-        debug!(\"read_bool\");\n-        match self.stack.pop().unwrap() {\n-            Boolean(b) => b,\n-            value => self.expected(\"boolean\", &value)\n-        }\n-    }\n-\n-    fn read_f64(&mut self) -> f64 {\n-        use std::from_str::FromStr;\n-        debug!(\"read_f64\");\n-        match self.stack.pop().unwrap() {\n-            Number(f) => f,\n-            String(s) => {\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n-                // is going to have a string here, as per JSON spec..\n-                FromStr::from_str(s).unwrap()\n-            },\n-            value => self.expected(\"number\", &value)\n-        }\n-    }\n-\n-    fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n-\n-    fn read_char(&mut self) -> char {\n-        let s = self.read_str();\n-        {\n-            let mut it = s.chars();\n-            match (it.next(), it.next()) {\n-                // exactly one character\n-                (Some(c), None) => return c,\n-                _ => ()\n-            }\n-        }\n-        self.expected(\"single character string\", &String(s))\n-    }\n-\n-    fn read_str(&mut self) -> ~str {\n-        debug!(\"read_str\");\n-        match self.stack.pop().unwrap() {\n-            String(s) => s,\n-            value => self.expected(\"string\", &value)\n-        }\n-    }\n-\n-    fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n-        debug!(\"read_enum({})\", name);\n-        f(self)\n-    }\n-\n-    fn read_enum_variant<T>(&mut self,\n-                            names: &[&str],\n-                            f: |&mut Decoder, uint| -> T)\n-                            -> T {\n-        debug!(\"read_enum_variant(names={:?})\", names);\n-        let name = match self.stack.pop().unwrap() {\n-            String(s) => s,\n-            Object(mut o) => {\n-                let n = match o.pop(&~\"variant\") {\n-                    Some(String(s)) => s,\n-                    Some(val) => self.expected(\"string\", &val),\n-                    None => self.missing_field(\"variant\", o)\n-                };\n-                match o.pop(&~\"fields\") {\n-                    Some(List(l)) => {\n-                        for field in l.move_rev_iter() {\n-                            self.stack.push(field.clone());\n-                        }\n-                    },\n-                    Some(val) => self.expected(\"list\", &val),\n-                    None => {\n-                        // re-insert the variant field so we're\n-                        // printing the \"whole\" struct in the error\n-                        // message... ick.\n-                        o.insert(~\"variant\", String(n));\n-                        self.missing_field(\"fields\", o);\n-                    }\n-                }\n-                n\n-            }\n-            json => self.expected(\"string or object\", &json)\n-        };\n-        let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n-            Some(idx) => idx,\n-            None => self.err(format!(\"unknown variant name: {}\", name))\n-        };\n-        f(self, idx)\n-    }\n-\n-    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n-                                -> T {\n-        debug!(\"read_enum_variant_arg(idx={})\", idx);\n-        f(self)\n-    }\n-\n-    fn read_enum_struct_variant<T>(&mut self,\n-                                   names: &[&str],\n-                                   f: |&mut Decoder, uint| -> T)\n-                                   -> T {\n-        debug!(\"read_enum_struct_variant(names={:?})\", names);\n-        self.read_enum_variant(names, f)\n-    }\n-\n-\n-    fn read_enum_struct_variant_field<T>(&mut self,\n-                                         name: &str,\n-                                         idx: uint,\n-                                         f: |&mut Decoder| -> T)\n-                                         -> T {\n-        debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n-        self.read_enum_variant_arg(idx, f)\n-    }\n-\n-    fn read_struct<T>(&mut self,\n-                      name: &str,\n-                      len: uint,\n-                      f: |&mut Decoder| -> T)\n-                      -> T {\n-        debug!(\"read_struct(name={}, len={})\", name, len);\n-        let value = f(self);\n-        self.stack.pop().unwrap();\n-        value\n-    }\n-\n-    fn read_struct_field<T>(&mut self,\n-                            name: &str,\n-                            idx: uint,\n-                            f: |&mut Decoder| -> T)\n-                            -> T {\n-        debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-        match self.stack.pop().unwrap() {\n-            Object(mut obj) => {\n-                let value = match obj.pop(&name.to_owned()) {\n-                    None => self.missing_field(name, obj),\n-                    Some(json) => {\n-                        self.stack.push(json);\n-                        f(self)\n-                    }\n-                };\n-                self.stack.push(Object(obj));\n-                value\n-            }\n-            value => self.expected(\"object\", &value)\n-        }\n-    }\n-\n-    fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n-        debug!(\"read_tuple()\");\n-        self.read_seq(f)\n-    }\n-\n-    fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n-        debug!(\"read_tuple_arg(idx={})\", idx);\n-        self.read_seq_elt(idx, f)\n-    }\n-\n-    fn read_tuple_struct<T>(&mut self,\n-                            name: &str,\n-                            f: |&mut Decoder, uint| -> T)\n-                            -> T {\n-        debug!(\"read_tuple_struct(name={})\", name);\n-        self.read_tuple(f)\n-    }\n-\n-    fn read_tuple_struct_arg<T>(&mut self,\n-                                idx: uint,\n-                                f: |&mut Decoder| -> T)\n-                                -> T {\n-        debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-        self.read_tuple_arg(idx, f)\n-    }\n-\n-    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n-        match self.stack.pop().unwrap() {\n-            Null => f(self, false),\n-            value => { self.stack.push(value); f(self, true) }\n-        }\n-    }\n-\n-    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n-        debug!(\"read_seq()\");\n-        let len = match self.stack.pop().unwrap() {\n-            List(list) => {\n-                let len = list.len();\n-                for v in list.move_rev_iter() {\n-                    self.stack.push(v);\n-                }\n-                len\n-            }\n-            value => self.expected(\"list\", &value)\n-        };\n-        f(self, len)\n-    }\n-\n-    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n-        debug!(\"read_seq_elt(idx={})\", idx);\n-        f(self)\n-    }\n-\n-    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n-        debug!(\"read_map()\");\n-        let len = match self.stack.pop().unwrap() {\n-            Object(obj) => {\n-                let len = obj.len();\n-                for (key, value) in obj.move_iter() {\n-                    self.stack.push(value);\n-                    self.stack.push(String(key));\n-                }\n-                len\n-            }\n-            value => self.expected(\"object\", &value)\n-        };\n-        f(self, len)\n-    }\n-\n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n-                           -> T {\n-        debug!(\"read_map_elt_key(idx={})\", idx);\n-        f(self)\n-    }\n-\n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n-                           -> T {\n-        debug!(\"read_map_elt_val(idx={})\", idx);\n-        f(self)\n-    }\n-}\n-\n-/// Test if two json values are less than one another\n-impl Ord for Json {\n-    fn lt(&self, other: &Json) -> bool {\n-        match *self {\n-            Number(f0) => {\n-                match *other {\n-                    Number(f1) => f0 < f1,\n-                    String(_) | Boolean(_) | List(_) | Object(_) |\n-                    Null => true\n-                }\n-            }\n-\n-            String(ref s0) => {\n-                match *other {\n-                    Number(_) => false,\n-                    String(ref s1) => s0 < s1,\n-                    Boolean(_) | List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            Boolean(b0) => {\n-                match *other {\n-                    Number(_) | String(_) => false,\n-                    Boolean(b1) => b0 < b1,\n-                    List(_) | Object(_) | Null => true\n-                }\n-            }\n-\n-            List(ref l0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) => false,\n-                    List(ref l1) => (*l0) < (*l1),\n-                    Object(_) | Null => true\n-                }\n-            }\n-\n-            Object(ref d0) => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) => false,\n-                    Object(ref d1) => d0 < d1,\n-                    Null => true\n-                }\n-            }\n-\n-            Null => {\n-                match *other {\n-                    Number(_) | String(_) | Boolean(_) | List(_) |\n-                    Object(_) =>\n-                        false,\n-                    Null => true\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// A trait for converting values to JSON\n-pub trait ToJson {\n-    /// Converts the value of `self` to an instance of JSON\n-    fn to_json(&self) -> Json;\n-}\n-\n-impl ToJson for Json {\n-    fn to_json(&self) -> Json { (*self).clone() }\n-}\n-\n-impl ToJson for int {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i8 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i16 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for i64 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for uint {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u8 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u16 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for u64 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for f32 {\n-    fn to_json(&self) -> Json { Number(*self as f64) }\n-}\n-\n-impl ToJson for f64 {\n-    fn to_json(&self) -> Json { Number(*self) }\n-}\n-\n-impl ToJson for () {\n-    fn to_json(&self) -> Json { Null }\n-}\n-\n-impl ToJson for bool {\n-    fn to_json(&self) -> Json { Boolean(*self) }\n-}\n-\n-impl ToJson for ~str {\n-    fn to_json(&self) -> Json { String((*self).clone()) }\n-}\n-\n-impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n-    fn to_json(&self) -> Json {\n-        match *self {\n-          (ref a, ref b) => {\n-            List(~[a.to_json(), b.to_json()])\n-          }\n-        }\n-    }\n-}\n-\n-impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n-    fn to_json(&self) -> Json {\n-        match *self {\n-          (ref a, ref b, ref c) => {\n-            List(~[a.to_json(), b.to_json(), c.to_json()])\n-          }\n-        }\n-    }\n-}\n-\n-impl<A:ToJson> ToJson for ~[A] {\n-    fn to_json(&self) -> Json { List(self.map(|elt| elt.to_json())) }\n-}\n-\n-impl<A:ToJson> ToJson for TreeMap<~str, A> {\n-    fn to_json(&self) -> Json {\n-        let mut d = TreeMap::new();\n-        for (key, value) in self.iter() {\n-            d.insert((*key).clone(), value.to_json());\n-        }\n-        Object(~d)\n-    }\n-}\n-\n-impl<A:ToJson> ToJson for HashMap<~str, A> {\n-    fn to_json(&self) -> Json {\n-        let mut d = TreeMap::new();\n-        for (key, value) in self.iter() {\n-            d.insert((*key).clone(), value.to_json());\n-        }\n-        Object(~d)\n-    }\n-}\n-\n-impl<A:ToJson> ToJson for Option<A> {\n-    fn to_json(&self) -> Json {\n-        match *self {\n-          None => Null,\n-          Some(ref value) => value.to_json()\n-        }\n-    }\n-}\n-\n-impl fmt::Show for Json {\n-    /// Encodes a json value into a string\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.to_writer(f.buf)\n-    }\n-}\n-\n-impl fmt::Show for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}:{}: {}\", self.line, self.col, self.msg)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use {Encodable, Decodable};\n-    use super::{Encoder, Decoder, Error, Boolean, Number, List, String, Null,\n-                PrettyEncoder, Object, Json, from_str};\n-    use std::io;\n-    use collections::TreeMap;\n-\n-    #[deriving(Eq, Encodable, Decodable, Show)]\n-    enum Animal {\n-        Dog,\n-        Frog(~str, int)\n-    }\n-\n-    #[deriving(Eq, Encodable, Decodable, Show)]\n-    struct Inner {\n-        a: (),\n-        b: uint,\n-        c: ~[~str],\n-    }\n-\n-    #[deriving(Eq, Encodable, Decodable, Show)]\n-    struct Outer {\n-        inner: ~[Inner],\n-    }\n-\n-    fn mk_object(items: &[(~str, Json)]) -> Json {\n-        let mut d = ~TreeMap::new();\n-\n-        for item in items.iter() {\n-            match *item {\n-                (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n-            }\n-        };\n-\n-        Object(d)\n-    }\n-\n-    #[test]\n-    fn test_write_null() {\n-        assert_eq!(Null.to_str(), ~\"null\");\n-        assert_eq!(Null.to_pretty_str(), ~\"null\");\n-    }\n-\n-\n-    #[test]\n-    fn test_write_number() {\n-        assert_eq!(Number(3.0).to_str(), ~\"3\");\n-        assert_eq!(Number(3.0).to_pretty_str(), ~\"3\");\n-\n-        assert_eq!(Number(3.1).to_str(), ~\"3.1\");\n-        assert_eq!(Number(3.1).to_pretty_str(), ~\"3.1\");\n-\n-        assert_eq!(Number(-1.5).to_str(), ~\"-1.5\");\n-        assert_eq!(Number(-1.5).to_pretty_str(), ~\"-1.5\");\n-\n-        assert_eq!(Number(0.5).to_str(), ~\"0.5\");\n-        assert_eq!(Number(0.5).to_pretty_str(), ~\"0.5\");\n-    }\n-\n-    #[test]\n-    fn test_write_str() {\n-        assert_eq!(String(~\"\").to_str(), ~\"\\\"\\\"\");\n-        assert_eq!(String(~\"\").to_pretty_str(), ~\"\\\"\\\"\");\n-\n-        assert_eq!(String(~\"foo\").to_str(), ~\"\\\"foo\\\"\");\n-        assert_eq!(String(~\"foo\").to_pretty_str(), ~\"\\\"foo\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_bool() {\n-        assert_eq!(Boolean(true).to_str(), ~\"true\");\n-        assert_eq!(Boolean(true).to_pretty_str(), ~\"true\");\n-\n-        assert_eq!(Boolean(false).to_str(), ~\"false\");\n-        assert_eq!(Boolean(false).to_pretty_str(), ~\"false\");\n-    }\n-\n-    #[test]\n-    fn test_write_list() {\n-        assert_eq!(List(~[]).to_str(), ~\"[]\");\n-        assert_eq!(List(~[]).to_pretty_str(), ~\"[]\");\n-\n-        assert_eq!(List(~[Boolean(true)]).to_str(), ~\"[true]\");\n-        assert_eq!(\n-            List(~[Boolean(true)]).to_pretty_str(),\n-            ~\"\\\n-            [\\n  \\\n-                true\\n\\\n-            ]\"\n-        );\n-\n-        let long_test_list = List(~[\n-            Boolean(false),\n-            Null,\n-            List(~[String(~\"foo\\nbar\"), Number(3.5)])]);\n-\n-        assert_eq!(long_test_list.to_str(),\n-            ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n-        assert_eq!(\n-            long_test_list.to_pretty_str(),\n-            ~\"\\\n-            [\\n  \\\n-                false,\\n  \\\n-                null,\\n  \\\n-                [\\n    \\\n-                    \\\"foo\\\\nbar\\\",\\n    \\\n-                    3.5\\n  \\\n-                ]\\n\\\n-            ]\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_write_object() {\n-        assert_eq!(mk_object([]).to_str(), ~\"{}\");\n-        assert_eq!(mk_object([]).to_pretty_str(), ~\"{}\");\n-\n-        assert_eq!(\n-            mk_object([(~\"a\", Boolean(true))]).to_str(),\n-            ~\"{\\\"a\\\":true}\"\n-        );\n-        assert_eq!(\n-            mk_object([(~\"a\", Boolean(true))]).to_pretty_str(),\n-            ~\"\\\n-            {\\n  \\\n-                \\\"a\\\": true\\n\\\n-            }\"\n-        );\n-\n-        let complex_obj = mk_object([\n-                (~\"b\", List(~[\n-                    mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n-                    mk_object([(~\"d\", String(~\"\"))])\n-                ]))\n-            ]);\n-\n-        assert_eq!(\n-            complex_obj.to_str(),\n-            ~\"{\\\n-                \\\"b\\\":[\\\n-                    {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n-                    {\\\"d\\\":\\\"\\\"}\\\n-                ]\\\n-            }\"\n-        );\n-        assert_eq!(\n-            complex_obj.to_pretty_str(),\n-            ~\"\\\n-            {\\n  \\\n-                \\\"b\\\": [\\n    \\\n-                    {\\n      \\\n-                        \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n-                    },\\n    \\\n-                    {\\n      \\\n-                        \\\"d\\\": \\\"\\\"\\n    \\\n-                    }\\n  \\\n-                ]\\n\\\n-            }\"\n-        );\n-\n-        let a = mk_object([\n-            (~\"a\", Boolean(true)),\n-            (~\"b\", List(~[\n-                mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n-                mk_object([(~\"d\", String(~\"\"))])\n-            ]))\n-        ]);\n-\n-        // We can't compare the strings directly because the object fields be\n-        // printed in a different order.\n-        assert_eq!(a.clone(), from_str(a.to_str()).unwrap());\n-        assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n-    }\n-\n-    fn with_str_writer(f: |&mut io::Writer|) -> ~str {\n-        use std::io::MemWriter;\n-        use std::str;\n-\n-        let mut m = MemWriter::new();\n-        f(&mut m as &mut io::Writer);\n-        str::from_utf8_owned(m.unwrap()).unwrap()\n-    }\n-\n-    #[test]\n-    fn test_write_enum() {\n-        let animal = Dog;\n-        assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = Encoder::new(wr);\n-                animal.encode(&mut encoder);\n-            }),\n-            ~\"\\\"Dog\\\"\"\n-        );\n-        assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::new(wr);\n-                animal.encode(&mut encoder);\n-            }),\n-            ~\"\\\"Dog\\\"\"\n-        );\n-\n-        let animal = Frog(~\"Henry\", 349);\n-        assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = Encoder::new(wr);\n-                animal.encode(&mut encoder);\n-            }),\n-            ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n-        );\n-        assert_eq!(\n-            with_str_writer(|wr| {\n-                let mut encoder = PrettyEncoder::new(wr);\n-                animal.encode(&mut encoder);\n-            }),\n-            ~\"\\\n-            [\\n  \\\n-                \\\"Frog\\\",\\n  \\\n-                \\\"Henry\\\",\\n  \\\n-                349\\n\\\n-            ]\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_write_some() {\n-        let value = Some(~\"jodhpurs\");\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n-            value.encode(&mut encoder);\n-        });\n-        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n-\n-        let value = Some(~\"jodhpurs\");\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = PrettyEncoder::new(wr);\n-            value.encode(&mut encoder);\n-        });\n-        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n-    }\n-\n-    #[test]\n-    fn test_write_none() {\n-        let value: Option<~str> = None;\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n-            value.encode(&mut encoder);\n-        });\n-        assert_eq!(s, ~\"null\");\n-\n-        let s = with_str_writer(|wr| {\n-            let mut encoder = Encoder::new(wr);\n-            value.encode(&mut encoder);\n-        });\n-        assert_eq!(s, ~\"null\");\n-    }\n-\n-    #[test]\n-    fn test_trailing_characters() {\n-        assert_eq!(from_str(\"nulla\"),\n-            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n-        assert_eq!(from_str(\"truea\"),\n-            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n-        assert_eq!(from_str(\"falsea\"),\n-            Err(Error {line: 1u, col: 6u, msg: ~\"trailing characters\"}));\n-        assert_eq!(from_str(\"1a\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"trailing characters\"}));\n-        assert_eq!(from_str(\"[]a\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n-        assert_eq!(from_str(\"{}a\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n-    }\n-\n-    #[test]\n-    fn test_read_identifiers() {\n-        assert_eq!(from_str(\"n\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n-        assert_eq!(from_str(\"nul\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n-\n-        assert_eq!(from_str(\"t\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n-        assert_eq!(from_str(\"truz\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n-\n-        assert_eq!(from_str(\"f\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n-        assert_eq!(from_str(\"faz\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"invalid syntax\"}));\n-\n-        assert_eq!(from_str(\"null\"), Ok(Null));\n-        assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n-        assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n-        assert_eq!(from_str(\" null \"), Ok(Null));\n-        assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n-        assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n-    }\n-\n-    #[test]\n-    fn test_decode_identifiers() {\n-        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let v: () = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ());\n-\n-        let mut decoder = Decoder::new(from_str(\"true\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder);\n-        assert_eq!(v, true);\n-\n-        let mut decoder = Decoder::new(from_str(\"false\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder);\n-        assert_eq!(v, false);\n-    }\n-\n-    #[test]\n-    fn test_read_number() {\n-        assert_eq!(from_str(\"+\"),\n-            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n-        assert_eq!(from_str(\".\"),\n-            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n-\n-        assert_eq!(from_str(\"-\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n-        assert_eq!(from_str(\"00\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n-        assert_eq!(from_str(\"1.\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n-        assert_eq!(from_str(\"1e\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n-        assert_eq!(from_str(\"1e+\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid number\"}));\n-\n-        assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n-        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n-        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2)));\n-        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4)));\n-        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5)));\n-        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15)));\n-        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01)));\n-        assert_eq!(from_str(\" 3 \"), Ok(Number(3.0)));\n-    }\n-\n-    #[test]\n-    fn test_decode_numbers() {\n-        let mut decoder = Decoder::new(from_str(\"3\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 3.0);\n-\n-        let mut decoder = Decoder::new(from_str(\"3.1\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 3.1);\n-\n-        let mut decoder = Decoder::new(from_str(\"-1.2\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n-        assert_eq!(v, -1.2);\n-\n-        let mut decoder = Decoder::new(from_str(\"0.4\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4);\n-\n-        let mut decoder = Decoder::new(from_str(\"0.4e5\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4e5);\n-\n-        let mut decoder = Decoder::new(from_str(\"0.4e15\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4e15);\n-\n-        let mut decoder = Decoder::new(from_str(\"0.4e-01\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n-        assert_eq!(v, 0.4e-01);\n-    }\n-\n-    #[test]\n-    fn test_read_str() {\n-        assert_eq!(from_str(\"\\\"\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing string\"\n-        }));\n-        assert_eq!(from_str(\"\\\"lol\"),\n-            Err(Error {line: 1u, col: 5u, msg: ~\"EOF while parsing string\"\n-        }));\n-\n-        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n-        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n-        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n-        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n-        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n-        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n-        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n-        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n-    }\n-\n-    #[test]\n-    fn test_decode_str() {\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"foo\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"foo\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\\\"\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\\b\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\\x08\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\\n\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\\n\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\\r\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\\r\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\\t\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\\t\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\\u12ab\");\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~\"\\uAB12\");\n-    }\n-\n-    #[test]\n-    fn test_read_list() {\n-        assert_eq!(from_str(\"[\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(\"[1\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"EOF while parsing list\"}));\n-        assert_eq!(from_str(\"[1,\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(\"[1,]\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n-        assert_eq!(from_str(\"[6 7]\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"expected `,` or `]`\"}));\n-\n-        assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n-        assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n-        assert_eq!(from_str(\"[true]\"), Ok(List(~[Boolean(true)])));\n-        assert_eq!(from_str(\"[ false ]\"), Ok(List(~[Boolean(false)])));\n-        assert_eq!(from_str(\"[null]\"), Ok(List(~[Null])));\n-        assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(~[Number(3.0), Number(1.0)])));\n-        assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(~[Number(3.0), Number(2.0)])));\n-        assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(~[Number(2.0), List(~[Number(4.0), Number(1.0)])])));\n-    }\n-\n-    #[test]\n-    fn test_decode_list() {\n-        let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~[]);\n-\n-        let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~[()]);\n-\n-        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~[true]);\n-\n-        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~[true]);\n-\n-        let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n-        let v: ~[int] = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~[3, 1]);\n-\n-        let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n-        let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n-        assert_eq!(v, ~[~[3], ~[1, 2]]);\n-    }\n-\n-    #[test]\n-    fn test_read_object() {\n-        assert_eq!(from_str(\"{\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 2u,\n-                msg: ~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(\"{ \"),\n-            Err(Error {\n-                line: 1u,\n-                col: 3u,\n-                msg: ~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(\"{1\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 2u,\n-                msg: ~\"key must be a string\"}));\n-        assert_eq!(from_str(\"{ \\\"a\\\"\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 6u,\n-                msg: ~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(\"{\\\"a\\\"\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 5u,\n-                msg: ~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(\"{\\\"a\\\" \"),\n-            Err(Error {\n-                line: 1u,\n-                col: 6u,\n-                msg: ~\"EOF while parsing object\"}));\n-\n-        assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n-            Err(Error {line: 1u, col: 6u, msg: ~\"expected `:`\"}));\n-        assert_eq!(from_str(\"{\\\"a\\\":\"),\n-            Err(Error {line: 1u, col: 6u, msg: ~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(\"{\\\"a\\\":1\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 7u,\n-                msg: ~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n-            Err(Error {line: 1u, col: 8u, msg: ~\"expected `,` or `}`\"}));\n-        assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 8u,\n-                msg: ~\"EOF while parsing object\"}));\n-\n-        assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n-        assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(~\"a\", Number(3.0))]));\n-\n-        assert_eq!(from_str(\n-                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n-                  mk_object([\n-                      (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]));\n-        assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n-                  mk_object([\n-                      (~\"a\", Null),\n-                      (~\"b\", Boolean(true))]));\n-        assert_eq!(from_str(\n-                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n-                  mk_object([\n-                      (~\"a\", Number(1.0)),\n-                      (~\"b\", List(~[Boolean(true)]))\n-                  ]));\n-        assert_eq!(from_str(\n-                      ~\"{\" +\n-                          \"\\\"a\\\": 1.0, \" +\n-                          \"\\\"b\\\": [\" +\n-                              \"true,\" +\n-                              \"\\\"foo\\\\nbar\\\", \" +\n-                              \"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n-                          \"]\" +\n-                      \"}\").unwrap(),\n-                  mk_object([\n-                      (~\"a\", Number(1.0)),\n-                      (~\"b\", List(~[\n-                          Boolean(true),\n-                          String(~\"foo\\nbar\"),\n-                          mk_object([\n-                              (~\"c\", mk_object([(~\"d\", Null)]))\n-                          ])\n-                      ]))\n-                  ]));\n-    }\n-\n-    #[test]\n-    fn test_decode_struct() {\n-        let s = ~\"{\n-            \\\"inner\\\": [\n-                { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n-            ]\n-        }\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let v: Outer = Decodable::decode(&mut decoder);\n-        assert_eq!(\n-            v,\n-            Outer {\n-                inner: ~[\n-                    Inner { a: (), b: 2, c: ~[~\"abc\", ~\"xyz\"] }\n-                ]\n-            }\n-        );\n-    }\n-\n-    #[test]\n-    fn test_decode_option() {\n-        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder);\n-        assert_eq!(value, None);\n-\n-        let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder);\n-        assert_eq!(value, Some(~\"jodhpurs\"));\n-    }\n-\n-    #[test]\n-    fn test_decode_enum() {\n-        let mut decoder = Decoder::new(from_str(\"\\\"Dog\\\"\").unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder);\n-        assert_eq!(value, Dog);\n-\n-        let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder);\n-        assert_eq!(value, Frog(~\"Henry\", 349));\n-    }\n-\n-    #[test]\n-    fn test_decode_map() {\n-        let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n-\n-        assert_eq!(map.pop(&~\"a\"), Some(Dog));\n-        assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));\n-    }\n-\n-    #[test]\n-    fn test_multiline_errors() {\n-        assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n-            Err(Error {\n-                line: 3u,\n-                col: 8u,\n-                msg: ~\"EOF while parsing object\"}));\n-    }\n-\n-    #[deriving(Decodable)]\n-    struct DecodeStruct {\n-        x: f64,\n-        y: bool,\n-        z: ~str,\n-        w: ~[DecodeStruct]\n-    }\n-    #[deriving(Decodable)]\n-    enum DecodeEnum {\n-        A(f64),\n-        B(~str)\n-    }\n-    fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected_error: &str) {\n-        use std::any::AnyRefExt;\n-        use std::task;\n-        let res = task::try(proc() {\n-            // either fails in `decode` (which is what we want), or\n-            // returns Some(error_message)/None if the string was\n-            // invalid or valid JSON.\n-            match from_str(to_parse) {\n-                Err(e) => Some(e.to_str()),\n-                Ok(json) => {\n-                    let _: T = Decodable::decode(&mut Decoder::new(json));\n-                    None\n-                }\n-            }\n-        });\n-        match res {\n-            Ok(Some(parse_error)) => fail!(\"`{}` is not valid json: {}\",\n-                                           to_parse, parse_error),\n-            Ok(None) => fail!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n-                              to_parse, expected_error),\n-            Err(e) => {\n-                let err = e.as_ref::<~str>().unwrap();\n-                assert!(err.contains(expected_error),\n-                        \"`{}` errored incorrectly, found `{}` expecting `{}`\",\n-                        to_parse, *err, expected_error);\n-            }\n-        }\n-    }\n-    #[test]\n-    fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", \"object but found list\");\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  \"number but found boolean\");\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  \"boolean but found list\");\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  \"string but found object\");\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  \"list but found null\");\n-        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  \"'w' field in object\");\n-    }\n-    #[test]\n-    fn test_decode_errors_enum() {\n-        check_err::<DecodeEnum>(\"{}\",\n-                                \"'variant' field in object\");\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                \"string but found number\");\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                \"'fields' field in object\");\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                \"list but found null\");\n-        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                \"unknown variant name\");\n-    }\n-\n-    #[test]\n-    fn test_find(){\n-        let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n-        let found_str = json_value.find(&~\"dog\");\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == &\"cat\");\n-    }\n-\n-    #[test]\n-    fn test_find_path(){\n-        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.find_path(&[&~\"dog\", &~\"cat\", &~\"mouse\"]);\n-        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == &\"cheese\");\n-    }\n-\n-    #[test]\n-    fn test_search(){\n-        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n-        let found_str = json_value.search(&~\"mouse\").and_then(|j| j.as_string());\n-        assert!(found_str.is_some());\n-        assert!(found_str.unwrap() == &\"cheese\");\n-    }\n-\n-    #[test]\n-    fn test_is_object(){\n-        let json_value = from_str(\"{}\").unwrap();\n-        assert!(json_value.is_object());\n-    }\n-\n-    #[test]\n-    fn test_as_object(){\n-        let json_value = from_str(\"{}\").unwrap();\n-        let json_object = json_value.as_object();\n-        assert!(json_object.is_some());\n-    }\n-\n-    #[test]\n-    fn test_is_list(){\n-        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        assert!(json_value.is_list());\n-    }\n-\n-    #[test]\n-    fn test_as_list(){\n-        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n-        let json_list = json_value.as_list();\n-        let expected_length = 3;\n-        assert!(json_list.is_some() && json_list.unwrap().len() == expected_length);\n-    }\n-\n-    #[test]\n-    fn test_is_string(){\n-        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-        assert!(json_value.is_string());\n-    }\n-\n-    #[test]\n-    fn test_as_string(){\n-        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n-        let json_str = json_value.as_string();\n-        let expected_str = &\"dog\";\n-        assert_eq!(json_str, Some(expected_str));\n-    }\n-\n-    #[test]\n-    fn test_is_number(){\n-        let json_value = from_str(\"12\").unwrap();\n-        assert!(json_value.is_number());\n-    }\n-\n-    #[test]\n-    fn test_as_number(){\n-        let json_value = from_str(\"12\").unwrap();\n-        let json_num = json_value.as_number();\n-        let expected_num = 12f64;\n-        assert!(json_num.is_some() && json_num.unwrap() == expected_num);\n-    }\n-\n-    #[test]\n-    fn test_is_boolean(){\n-        let json_value = from_str(\"false\").unwrap();\n-        assert!(json_value.is_boolean());\n-    }\n-\n-    #[test]\n-    fn test_as_boolean(){\n-        let json_value = from_str(\"false\").unwrap();\n-        let json_bool = json_value.as_boolean();\n-        let expected_bool = false;\n-        assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n-    }\n-\n-    #[test]\n-    fn test_is_null(){\n-        let json_value = from_str(\"null\").unwrap();\n-        assert!(json_value.is_null());\n-    }\n-\n-    #[test]\n-    fn test_as_null(){\n-        let json_value = from_str(\"null\").unwrap();\n-        let json_null = json_value.as_null();\n-        let expected_null = ();\n-        assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n-    }\n-\n-    #[test]\n-    fn test_encode_hashmap_with_numeric_key() {\n-        use std::str::from_utf8;\n-        use std::io::Writer;\n-        use std::io::MemWriter;\n-        use collections::HashMap;\n-        let mut hm: HashMap<uint, bool> = HashMap::new();\n-        hm.insert(1, true);\n-        let mut mem_buf = MemWriter::new();\n-        {\n-            let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder)\n-        }\n-        let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes).unwrap();\n-        match from_str(json_str) {\n-            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n-            _ => {} // it parsed and we are good to go\n-        }\n-    }\n-    #[test]\n-    fn test_prettyencode_hashmap_with_numeric_key() {\n-        use std::str::from_utf8;\n-        use std::io::Writer;\n-        use std::io::MemWriter;\n-        use collections::HashMap;\n-        let mut hm: HashMap<uint, bool> = HashMap::new();\n-        hm.insert(1, true);\n-        let mut mem_buf = MemWriter::new();\n-        {\n-            let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder)\n-        }\n-        let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes).unwrap();\n-        match from_str(json_str) {\n-            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n-            _ => {} // it parsed and we are good to go\n-        }\n-    }\n-    #[test]\n-    fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n-        use collections::HashMap;\n-        use Decodable;\n-        let json_str = \"{\\\"1\\\":true}\";\n-        let json_obj = match from_str(json_str) {\n-            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n-            Ok(o) => o\n-        };\n-        let mut decoder = Decoder::new(json_obj);\n-        let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder);\n-    }\n-}\n-"}, {"sha": "b3a529601a4edbd15d4bef90f672399534f74743", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -34,31 +34,10 @@ extern crate collections;\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n                           DecoderHelpers, EncoderHelpers};\n \n-// FIXME: remove _old.rs files after snapshot\n-#[cfg(not(stage0))]\n mod serialize;\n-#[cfg(not(stage0))]\n mod collection_impls;\n \n pub mod base64;\n-#[cfg(not(stage0))]\n pub mod ebml;\n pub mod hex;\n-#[cfg(not(stage0))]\n-pub mod json;\n-\n-#[cfg(stage0)]\n-#[path=\"./serialize_old.rs\"]\n-pub mod serialize;\n-\n-#[cfg(stage0)]\n-#[path=\"./collection_impls_old.rs\"]\n-mod collection_impls;\n-\n-#[cfg(stage0)]\n-#[path=\"./ebml_old.rs\"]\n-pub mod ebml;\n-\n-#[cfg(stage0)]\n-#[path=\"./json_old.rs\"]\n pub mod json;"}, {"sha": "4043cbe65fe944ec3749ac6413f99b670df37bd4", "filename": "src/libserialize/serialize_old.rs", "status": "removed", "additions": 0, "deletions": 688, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Fserialize_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02d186ad9ba699f7824969fb60a19042613d5d60/src%2Flibserialize%2Fserialize_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_old.rs?ref=02d186ad9ba699f7824969fb60a19042613d5d60", "patch": "@@ -1,688 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Support code for encoding and decoding types.\n-\n-/*\n-Core encoding and decoding interfaces.\n-*/\n-\n-use std::path;\n-use std::rc::Rc;\n-use std::slice;\n-\n-pub trait Encoder {\n-    // Primitive types:\n-    fn emit_nil(&mut self);\n-    fn emit_uint(&mut self, v: uint);\n-    fn emit_u64(&mut self, v: u64);\n-    fn emit_u32(&mut self, v: u32);\n-    fn emit_u16(&mut self, v: u16);\n-    fn emit_u8(&mut self, v: u8);\n-    fn emit_int(&mut self, v: int);\n-    fn emit_i64(&mut self, v: i64);\n-    fn emit_i32(&mut self, v: i32);\n-    fn emit_i16(&mut self, v: i16);\n-    fn emit_i8(&mut self, v: i8);\n-    fn emit_bool(&mut self, v: bool);\n-    fn emit_f64(&mut self, v: f64);\n-    fn emit_f32(&mut self, v: f32);\n-    fn emit_char(&mut self, v: char);\n-    fn emit_str(&mut self, v: &str);\n-\n-    // Compound types:\n-    fn emit_enum(&mut self, name: &str, f: |&mut Self|);\n-\n-    fn emit_enum_variant(&mut self,\n-                         v_name: &str,\n-                         v_id: uint,\n-                         len: uint,\n-                         f: |&mut Self|);\n-    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: |&mut Self|);\n-\n-    fn emit_enum_struct_variant(&mut self,\n-                                v_name: &str,\n-                                v_id: uint,\n-                                len: uint,\n-                                f: |&mut Self|);\n-    fn emit_enum_struct_variant_field(&mut self,\n-                                      f_name: &str,\n-                                      f_idx: uint,\n-                                      f: |&mut Self|);\n-\n-    fn emit_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n-    fn emit_struct_field(&mut self,\n-                         f_name: &str,\n-                         f_idx: uint,\n-                         f: |&mut Self|);\n-\n-    fn emit_tuple(&mut self, len: uint, f: |&mut Self|);\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self|);\n-\n-    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n-    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: |&mut Self|);\n-\n-    // Specialized types:\n-    fn emit_option(&mut self, f: |&mut Self|);\n-    fn emit_option_none(&mut self);\n-    fn emit_option_some(&mut self, f: |&mut Self|);\n-\n-    fn emit_seq(&mut self, len: uint, f: |this: &mut Self|);\n-    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self|);\n-\n-    fn emit_map(&mut self, len: uint, f: |&mut Self|);\n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self|);\n-    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self|);\n-}\n-\n-pub trait Decoder {\n-    // Primitive types:\n-    fn read_nil(&mut self) -> ();\n-    fn read_uint(&mut self) -> uint;\n-    fn read_u64(&mut self) -> u64;\n-    fn read_u32(&mut self) -> u32;\n-    fn read_u16(&mut self) -> u16;\n-    fn read_u8(&mut self) -> u8;\n-    fn read_int(&mut self) -> int;\n-    fn read_i64(&mut self) -> i64;\n-    fn read_i32(&mut self) -> i32;\n-    fn read_i16(&mut self) -> i16;\n-    fn read_i8(&mut self) -> i8;\n-    fn read_bool(&mut self) -> bool;\n-    fn read_f64(&mut self) -> f64;\n-    fn read_f32(&mut self) -> f32;\n-    fn read_char(&mut self) -> char;\n-    fn read_str(&mut self) -> ~str;\n-\n-    // Compound types:\n-    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> T) -> T;\n-\n-    fn read_enum_variant<T>(&mut self,\n-                            names: &[&str],\n-                            f: |&mut Self, uint| -> T)\n-                            -> T;\n-    fn read_enum_variant_arg<T>(&mut self,\n-                                a_idx: uint,\n-                                f: |&mut Self| -> T)\n-                                -> T;\n-\n-    fn read_enum_struct_variant<T>(&mut self,\n-                                   names: &[&str],\n-                                   f: |&mut Self, uint| -> T)\n-                                   -> T;\n-    fn read_enum_struct_variant_field<T>(&mut self,\n-                                         &f_name: &str,\n-                                         f_idx: uint,\n-                                         f: |&mut Self| -> T)\n-                                         -> T;\n-\n-    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> T)\n-                      -> T;\n-    fn read_struct_field<T>(&mut self,\n-                            f_name: &str,\n-                            f_idx: uint,\n-                            f: |&mut Self| -> T)\n-                            -> T;\n-\n-    fn read_tuple<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n-    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> T) -> T;\n-\n-    fn read_tuple_struct<T>(&mut self,\n-                            s_name: &str,\n-                            f: |&mut Self, uint| -> T)\n-                            -> T;\n-    fn read_tuple_struct_arg<T>(&mut self,\n-                                a_idx: uint,\n-                                f: |&mut Self| -> T)\n-                                -> T;\n-\n-    // Specialized types:\n-    fn read_option<T>(&mut self, f: |&mut Self, bool| -> T) -> T;\n-\n-    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n-    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n-\n-    fn read_map<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n-}\n-\n-pub trait Encodable<S:Encoder> {\n-    fn encode(&self, s: &mut S);\n-}\n-\n-pub trait Decodable<D:Decoder> {\n-    fn decode(d: &mut D) -> Self;\n-}\n-\n-impl<S:Encoder> Encodable<S> for uint {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_uint(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for uint {\n-    fn decode(d: &mut D) -> uint {\n-        d.read_uint()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for u8 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_u8(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for u8 {\n-    fn decode(d: &mut D) -> u8 {\n-        d.read_u8()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for u16 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_u16(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for u16 {\n-    fn decode(d: &mut D) -> u16 {\n-        d.read_u16()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for u32 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_u32(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for u32 {\n-    fn decode(d: &mut D) -> u32 {\n-        d.read_u32()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for u64 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_u64(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for u64 {\n-    fn decode(d: &mut D) -> u64 {\n-        d.read_u64()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for int {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_int(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for int {\n-    fn decode(d: &mut D) -> int {\n-        d.read_int()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for i8 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_i8(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for i8 {\n-    fn decode(d: &mut D) -> i8 {\n-        d.read_i8()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for i16 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_i16(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for i16 {\n-    fn decode(d: &mut D) -> i16 {\n-        d.read_i16()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for i32 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_i32(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for i32 {\n-    fn decode(d: &mut D) -> i32 {\n-        d.read_i32()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for i64 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_i64(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for i64 {\n-    fn decode(d: &mut D) -> i64 {\n-        d.read_i64()\n-    }\n-}\n-\n-impl<'a, S:Encoder> Encodable<S> for &'a str {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for ~str {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_str(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for ~str {\n-    fn decode(d: &mut D) -> ~str {\n-        d.read_str()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for f32 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_f32(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for f32 {\n-    fn decode(d: &mut D) -> f32 {\n-        d.read_f32()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for f64 {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_f64(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for f64 {\n-    fn decode(d: &mut D) -> f64 {\n-        d.read_f64()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for bool {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_bool(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for bool {\n-    fn decode(d: &mut D) -> bool {\n-        d.read_bool()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for char {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_char(*self)\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for char {\n-    fn decode(d: &mut D) -> char {\n-        d.read_char()\n-    }\n-}\n-\n-impl<S:Encoder> Encodable<S> for () {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_nil()\n-    }\n-}\n-\n-impl<D:Decoder> Decodable<D> for () {\n-    fn decode(d: &mut D) -> () {\n-        d.read_nil()\n-    }\n-}\n-\n-impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a T {\n-    fn encode(&self, s: &mut S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n-    fn encode(&self, s: &mut S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n-    fn decode(d: &mut D) -> ~T {\n-        ~Decodable::decode(d)\n-    }\n-}\n-\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n-    fn encode(&self, s: &mut S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for Rc<T> {\n-    #[inline]\n-    fn encode(&self, s: &mut S) {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Rc<T> {\n-    #[inline]\n-    fn decode(d: &mut D) -> Rc<T> {\n-        Rc::new(Decodable::decode(d))\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @T {\n-    fn decode(d: &mut D) -> @T {\n-        @Decodable::decode(d)\n-    }\n-}\n-\n-impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a [T] {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n-            }\n-        })\n-    }\n-}\n-\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n-    fn decode(d: &mut D) -> ~[T] {\n-        d.read_seq(|d, len| {\n-            slice::from_fn(len, |i| {\n-                d.read_seq_elt(i, |d| Decodable::decode(d))\n-            })\n-        })\n-    }\n-}\n-\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for Vec<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Vec<T> {\n-    fn decode(d: &mut D) -> Vec<T> {\n-        d.read_seq(|d, len| {\n-            Vec::from_fn(len, |i| {\n-                d.read_seq_elt(i, |d| Decodable::decode(d))\n-            })\n-        })\n-    }\n-}\n-\n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_option(|s| {\n-            match *self {\n-                None => s.emit_option_none(),\n-                Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n-            }\n-        })\n-    }\n-}\n-\n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n-    fn decode(d: &mut D) -> Option<T> {\n-        d.read_option(|d, b| {\n-            if b {\n-                Some(Decodable::decode(d))\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-}\n-\n-impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                s.emit_seq(2, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n-    fn decode(d: &mut D) -> (T0, T1) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 2);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>\n-> Encodable<S> for (T0, T1, T2) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                s.emit_seq(3, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>\n-> Decodable<D> for (T0, T1, T2) {\n-    fn decode(d: &mut D) -> (T0, T1, T2) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 3);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                s.emit_seq(4, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                    s.emit_seq_elt(3, |s| t3.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3) {\n-    fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 4);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d)),\n-                d.read_seq_elt(3, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<\n-    S: Encoder,\n-    T0: Encodable<S>,\n-    T1: Encodable<S>,\n-    T2: Encodable<S>,\n-    T3: Encodable<S>,\n-    T4: Encodable<S>\n-> Encodable<S> for (T0, T1, T2, T3, T4) {\n-    fn encode(&self, s: &mut S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                s.emit_seq(5, |s| {\n-                    s.emit_seq_elt(0, |s| t0.encode(s));\n-                    s.emit_seq_elt(1, |s| t1.encode(s));\n-                    s.emit_seq_elt(2, |s| t2.encode(s));\n-                    s.emit_seq_elt(3, |s| t3.encode(s));\n-                    s.emit_seq_elt(4, |s| t4.encode(s));\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-impl<\n-    D: Decoder,\n-    T0: Decodable<D>,\n-    T1: Decodable<D>,\n-    T2: Decodable<D>,\n-    T3: Decodable<D>,\n-    T4: Decodable<D>\n-> Decodable<D> for (T0, T1, T2, T3, T4) {\n-    fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n-        d.read_seq(|d, len| {\n-            assert_eq!(len, 5);\n-            (\n-                d.read_seq_elt(0, |d| Decodable::decode(d)),\n-                d.read_seq_elt(1, |d| Decodable::decode(d)),\n-                d.read_seq_elt(2, |d| Decodable::decode(d)),\n-                d.read_seq_elt(3, |d| Decodable::decode(d)),\n-                d.read_seq_elt(4, |d| Decodable::decode(d))\n-            )\n-        })\n-    }\n-}\n-\n-impl<E: Encoder> Encodable<E> for path::posix::Path {\n-    fn encode(&self, e: &mut E) {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-impl<D: Decoder> Decodable<D> for path::posix::Path {\n-    fn decode(d: &mut D) -> path::posix::Path {\n-        let bytes: ~[u8] = Decodable::decode(d);\n-        path::posix::Path::new(bytes)\n-    }\n-}\n-\n-impl<E: Encoder> Encodable<E> for path::windows::Path {\n-    fn encode(&self, e: &mut E) {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-impl<D: Decoder> Decodable<D> for path::windows::Path {\n-    fn decode(d: &mut D) -> path::windows::Path {\n-        let bytes: ~[u8] = Decodable::decode(d);\n-        path::windows::Path::new(bytes)\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// In some cases, these should eventually be coded as traits.\n-\n-pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut Self, v: &T|);\n-}\n-\n-impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T|) {\n-        self.emit_seq(v.len(), |this| {\n-            for (i, e) in v.iter().enumerate() {\n-                this.emit_seq_elt(i, |this| {\n-                    f(this, e)\n-                })\n-            }\n-        })\n-    }\n-}\n-\n-pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&mut self, f: |&mut Self| -> T) -> ~[T];\n-}\n-\n-impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n-        self.read_seq(|this, len| {\n-            slice::from_fn(len, |i| {\n-                this.read_seq_elt(i, |this| f(this))\n-            })\n-        })\n-    }\n-}\n-"}, {"sha": "2fa8ff80d861384f4ef54af9c7aca37169104548", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -42,7 +42,6 @@ pub trait Eq {\n }\n \n /// Trait for equality comparisons where `a == b` and `a != b` are strict inverses.\n-#[cfg(not(stage0))]\n pub trait TotalEq: Eq {\n     // FIXME #13101: this method is used solely by #[deriving] to\n     // assert that every component of a type implements #[deriving]\n@@ -56,15 +55,6 @@ pub trait TotalEq: Eq {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n-#[cfg(stage0)]\n-pub trait TotalEq: Eq {\n-    /// This method must return the same value as `eq`. It exists to prevent\n-    /// deriving `TotalEq` from fields not implementing the `TotalEq` trait.\n-    fn equals(&self, other: &Self) -> bool {\n-        self.eq(other)\n-    }\n-}\n-\n macro_rules! totaleq_impl(\n     ($t:ty) => {\n         impl TotalEq for $t {}"}, {"sha": "76aa0d425482cc222f00fec58ac3821aa4e7bf2a", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -33,14 +33,6 @@ pub trait Sized {\n }\n \n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n-#[cfg(stage0)]\n-#[lang=\"pod\"]\n-pub trait Copy {\n-    // Empty.\n-}\n-\n-/// Types that can be copied by simply copying bits (i.e. `memcpy`).\n-#[cfg(not(stage0))]\n #[lang=\"copy\"]\n pub trait Copy {\n     // Empty.\n@@ -270,19 +262,10 @@ pub mod marker {\n     /// A type which is considered \"not POD\", meaning that it is not\n     /// implicitly copyable. This is typically embedded in other types to\n     /// ensure that they are never copied, even if they lack a destructor.\n-    #[cfg(not(stage0))]\n     #[lang=\"no_copy_bound\"]\n     #[deriving(Eq,Clone)]\n     pub struct NoCopy;\n \n-    /// A type which is considered \"not POD\", meaning that it is not\n-    /// implicitly copyable. This is typically embedded in other types to\n-    /// ensure that they are never copied, even if they lack a destructor.\n-    #[cfg(stage0)]\n-    #[lang=\"no_pod_bound\"]\n-    #[deriving(Eq,Clone)]\n-    pub struct NoCopy;\n-\n     /// A type which is considered \"not sharable\", meaning that\n     /// its contents are not threadsafe, hence they cannot be\n     /// shared between tasks."}, {"sha": "8c47e65f2348012d421d5700cd70d0de4667fad4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -98,29 +98,12 @@ pub type Name = u32;\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = u32;\n \n-// FIXME: remove stage0 Encodables after snapshot\n-#[cfg(stage0)]\n-impl<S: Encoder> Encodable<S> for Ident {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_str(token::get_ident(*self).get());\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for Ident {\n-    fn decode(d: &mut D) -> Ident {\n-        str_to_ident(d.read_str())\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S: Encoder<E>, E> Encodable<S, E> for Ident {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(token::get_ident(*self).get())\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n     fn decode(d: &mut D) -> Result<Ident, E> {\n         Ok(str_to_ident(try!(d.read_str())))\n@@ -1185,26 +1168,7 @@ mod test {\n     use super::*;\n \n     // are ASTs encodable?\n-    // FIXME: remove stage0 test after snapshot\n-    #[test]\n-    #[cfg(stage0)]\n-    fn check_asts_encodable() {\n-        let e = Crate {\n-            module: Mod {view_items: Vec::new(), items: Vec::new()},\n-            attrs: Vec::new(),\n-            config: Vec::new(),\n-            span: Span {\n-                lo: BytePos(10),\n-                hi: BytePos(20),\n-                expn_info: None,\n-            },\n-        };\n-        // doesn't matter which encoder we use....\n-        let _f = &e as &serialize::Encodable<json::Encoder>;\n-    }\n-\n     #[test]\n-    #[cfg(not(stage0))]\n     fn check_asts_encodable() {\n         use std::io;\n         let e = Crate {"}, {"sha": "974868c16109288ffc1456a7dc318deab0bdb7c4", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -110,31 +110,13 @@ impl Eq for Span {\n \n impl TotalEq for Span {}\n \n-// FIXME: remove stage0 Encodables/Decodables after snapshot\n-#[cfg(stage0)]\n-impl<S:Encoder> Encodable<S> for Span {\n-    /* Note #1972 -- spans are encoded but not decoded */\n-    fn encode(&self, s: &mut S) {\n-        s.emit_nil()\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for Span {\n-    fn decode(_d: &mut D) -> Span {\n-        DUMMY_SP\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S:Encoder<E>, E> Encodable<S, E> for Span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_nil()\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<D:Decoder<E>, E> Decodable<D, E> for Span {\n     fn decode(_d: &mut D) -> Result<Span, E> {\n         Ok(DUMMY_SP)"}, {"sha": "33829212686c7f417636001d4bcb9bbfcb3aed53", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -131,29 +131,12 @@ impl<T> FromIterator<T> for OwnedSlice<T> {\n     }\n }\n \n-// FIXME: remove stage0 Encodables/Decodables after snapshot\n-#[cfg(stage0)]\n-impl<S: Encoder, T: Encodable<S>> Encodable<S> for OwnedSlice<T> {\n-    fn encode(&self, s: &mut S) {\n-       self.as_slice().encode(s)\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<D: Decoder, T: Decodable<D>> Decodable<D> for OwnedSlice<T> {\n-    fn decode(d: &mut D) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(Decodable::decode(d))\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<S: Encoder<E>, T: Encodable<S, E>, E> Encodable<S, E> for OwnedSlice<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n        self.as_slice().encode(s)\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<D: Decoder<E>, T: Decodable<D, E>, E> Decodable<D, E> for OwnedSlice<T> {\n     fn decode(d: &mut D) -> Result<OwnedSlice<T>, E> {\n         Ok(OwnedSlice::from_vec(match Decodable::decode(d) {"}, {"sha": "36f33befb7aeb7219f950f96c079e846b814490a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -288,16 +288,6 @@ mod test {\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::string_to_stmt;\n \n-    // FIXME: remove stage0 to_json_str after snapshot\n-    #[cfg(stage0)]\n-    fn to_json_str<'a, E: Encodable<json::Encoder<'a>>>(val: &E) -> ~str {\n-        let mut writer = MemWriter::new();\n-        let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n-        val.encode(&mut encoder);\n-        str::from_utf8_owned(writer.unwrap()).unwrap()\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn to_json_str<'a, E: Encodable<json::Encoder<'a>, io::IoError>>(val: &E) -> ~str {\n         let mut writer = MemWriter::new();\n         let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);"}, {"sha": "b7586b5de1494ef7a9861d9419010491874903cc", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -604,29 +604,12 @@ impl<'a> Equiv<&'a str> for InternedString {\n     }\n }\n \n-// FIXME: remove stage0 Encodables/Decodables after snapshot\n-#[cfg(stage0)]\n-impl<D:Decoder> Decodable<D> for InternedString {\n-    fn decode(d: &mut D) -> InternedString {\n-        get_name(get_ident_interner().intern(d.read_str()))\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<E:Encoder> Encodable<E> for InternedString {\n-    fn encode(&self, e: &mut E) {\n-        e.emit_str(self.string.as_slice())\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n         Ok(get_name(get_ident_interner().intern(try!(d.read_str()))))\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<S:Encoder<E>, E> Encodable<S, E> for InternedString {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(self.string.as_slice())"}, {"sha": "1bc3e9e6ba5e419b96dd47c6088c0fb90658bdf6", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -1018,22 +1018,6 @@ impl ToJson for Metric {\n     }\n }\n \n-// FIXME: remove decode_ after snapshot\n-#[cfg(stage0)]\n-fn decode_(json: Json) -> MetricMap {\n-    let mut decoder = json::Decoder::new(json);\n-    MetricMap(Decodable::decode(&mut decoder))\n-}\n-\n-#[cfg(not(stage0))]\n-fn decode_(json: Json) -> MetricMap {\n-    let mut decoder = json::Decoder::new(json);\n-    MetricMap(match Decodable::decode(&mut decoder) {\n-        Ok(t) => t,\n-        Err(e) => fail!(\"failure decoding JSON: {}\", e)\n-    })\n-}\n-\n \n impl MetricMap {\n \n@@ -1051,7 +1035,11 @@ impl MetricMap {\n         assert!(p.exists());\n         let mut f = File::open(p).unwrap();\n         let value = json::from_reader(&mut f as &mut io::Reader).unwrap();\n-        decode_(value)\n+        let mut decoder = json::Decoder::new(value);\n+        MetricMap(match Decodable::decode(&mut decoder) {\n+            Ok(t) => t,\n+            Err(e) => fail!(\"failure decoding JSON: {}\", e)\n+        })\n     }\n \n     /// Write MetricDiff to a file."}, {"sha": "d1e4a1c0472be18f721104bbdb546f2a4a973857", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -490,32 +490,13 @@ impl Eq for Uuid {\n impl TotalEq for Uuid {}\n \n // FIXME #9845: Test these more thoroughly\n-// FIXME: remove stage0 Encodable/Decodable after snapshot\n-#[cfg(stage0)]\n-impl<T: Encoder> Encodable<T> for Uuid {\n-    /// Encode a UUID as a hypenated string\n-    fn encode(&self, e: &mut T) {\n-        e.emit_str(self.to_hyphenated_str())\n-    }\n-}\n-\n-#[cfg(stage0)]\n-impl<T: Decoder> Decodable<T> for Uuid {\n-    /// Decode a UUID from a string\n-    fn decode(d: &mut T) -> Uuid {\n-        from_str(d.read_str()).unwrap()\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n     /// Encode a UUID as a hypenated string\n     fn encode(&self, e: &mut T) -> Result<(), E> {\n         e.emit_str(self.to_hyphenated_str())\n     }\n }\n \n-#[cfg(not(stage0))]\n impl<T: Decoder<E>, E> Decodable<T, E> for Uuid {\n     /// Decode a UUID from a string\n     fn decode(d: &mut T) -> Result<Uuid, E> {\n@@ -547,17 +528,6 @@ mod test {\n     use std::str;\n     use std::io::MemWriter;\n \n-    // FIXME: remove unwrap_ after snapshot\n-    #[cfg(stage0)]\n-    fn unwrap_<T>(t: T) -> T {\n-        t\n-    }\n-\n-    #[cfg(not(stage0))]\n-    fn unwrap_<T, E>(t: Result<T, E>) -> T {\n-        t.unwrap()\n-    }\n-\n     #[test]\n     fn test_nil() {\n         let nil = Uuid::nil();\n@@ -829,7 +799,7 @@ mod test {\n         let mut wr = MemWriter::new();\n         let _ = u.encode(&mut ebml::writer::Encoder(&mut wr));\n         let doc = ebml::reader::Doc(wr.get_ref());\n-        let u2 = unwrap_(Decodable::decode(&mut ebml::reader::Decoder(doc)));\n+        let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc)).unwrap();\n         assert_eq!(u, u2);\n     }\n "}, {"sha": "59ea9834ed7e568fe9acf865eea443bb228b13ca", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/df9cf18c10099d15146580ab6a2b64f2d2007a89/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=df9cf18c10099d15146580ab6a2b64f2d2007a89", "patch": "@@ -1,3 +1,11 @@\n+S 2014-03-28 b8601a3\n+  freebsd-x86_64 c6b0651b2a90697754920ad381c13f9b7942ab47\n+  linux-i386 3bef5684fd0582fbd4ddebd4514182d4f72924f7\n+  linux-x86_64 a7b2af1076d48e4a687a71a21478293e834349bd\n+  macos-i386 41fb091c3bf5f0ebe9341f26129be82782266ddd\n+  macos-x86_64 22b884a3876cb3e40ad942ad68a496b5f239fca5\n+  winnt-i386 65174e80fbf69f92e41110b0bcc7e15704ca359b\n+\n S 2014-03-22 94e4e91\n   freebsd-x86_64 7793127e1b9ad22cb2e020f9bb01f34526cc4656\n   linux-i386 aa53699d32d7acb86a6447f988c4ac73ac310bab"}]}