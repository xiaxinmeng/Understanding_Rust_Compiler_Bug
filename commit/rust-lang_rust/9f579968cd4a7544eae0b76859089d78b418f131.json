{"sha": "9f579968cd4a7544eae0b76859089d78b418f131", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNTc5OTY4Y2Q0YTc1NDRlYWUwYjc2ODU5MDg5ZDc4YjQxOGYxMzE=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-06-24T11:01:17Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-06-25T16:52:46Z"}, "message": "Add Integer::{log,log2,log10} variants", "tree": {"sha": "e4969a1f116ec6052e59187dde12705770b58791", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4969a1f116ec6052e59187dde12705770b58791"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f579968cd4a7544eae0b76859089d78b418f131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f579968cd4a7544eae0b76859089d78b418f131", "html_url": "https://github.com/rust-lang/rust/commit/9f579968cd4a7544eae0b76859089d78b418f131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f579968cd4a7544eae0b76859089d78b418f131/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6f3cb9502b1910f6af32f426fdb78e813b390ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f3cb9502b1910f6af32f426fdb78e813b390ef", "html_url": "https://github.com/rust-lang/rust/commit/b6f3cb9502b1910f6af32f426fdb78e813b390ef"}], "stats": {"total": 478, "additions": 478, "deletions": 0}, "files": [{"sha": "a9461649d4aa17cf37c3f5182884081968703cd7", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=9f579968cd4a7544eae0b76859089d78b418f131", "patch": "@@ -1744,6 +1744,194 @@ macro_rules! int_impl {\n             }\n         }\n \n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `log2` can produce results more efficiently for base 2, and `log10`\n+        /// can produce results more efficiently for base 10.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is zero, or if the base is not at least 2; it\n+        /// panics in debug mode and the return value is wrapped to 0 in release\n+        /// mode (the only situation in which the method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".log(5), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log(self, base: Self) -> Self {\n+            match self.checked_log(base) {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is zero it panics in debug mode and the return value\n+        /// is wrapped to 0 in release mode (the only situation in which the\n+        /// method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".log2(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log2(self) -> Self {\n+            match self.checked_log2() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is zero it panics in debug mode and the return value\n+        /// is wrapped to 0 in release mode (the only situation in which the\n+        /// method can return 0).\n+        ///\n+        /// # Example\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".log10(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log10(self) -> Self {\n+            match self.checked_log10() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// Returns `None` if the number is negative or zero, or if the base is not at least 2.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `checked_log2` can produce results more efficiently for base 2, and\n+        /// `checked_log10` can produce results more efficiently for base 10.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_log(5), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log(self, base: Self) -> Option<Self> {\n+            if self <= 0 || base <= 1 {\n+                None\n+            } else {\n+                let mut n = 0;\n+                let mut r = self;\n+\n+                // Optimization for 128 bit wide integers.\n+                if Self::BITS == 128 {\n+                    let b = Self::log2(self) / (Self::log2(base) + 1);\n+                    n += b;\n+                    r /= base.pow(b as u32);\n+                }\n+\n+                while r >= base {\n+                    r /= base;\n+                    n += 1;\n+                }\n+                Some(n)\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is negative or zero.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_log2(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log2(self) -> Option<Self> {\n+            if self <= 0 {\n+                None\n+            } else {\n+                // SAFETY: We just checked that this number is positive\n+                let log = (Self::BITS - 1) as Self - unsafe { intrinsics::ctlz_nonzero(self) };\n+                Some(log)\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is negative or zero.\n+        ///\n+        /// # Example\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_log10(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log10(self) -> Option<Self> {\n+            self.checked_log(10)\n+        }\n+\n         /// Computes the absolute value of `self`.\n         ///\n         /// # Overflow behavior"}, {"sha": "bf4d2e7433e2f9a924b8a2c814b27adf126a8ab4", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=9f579968cd4a7544eae0b76859089d78b418f131", "patch": "@@ -634,6 +634,194 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `log2` can produce results more efficiently for base 2, and `log10`\n+        /// can produce results more efficiently for base 10.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is negative, zero, or if the base is not at least 2;\n+        /// it panics in debug mode and the return value is wrapped to 0 in\n+        /// release mode (the only situation in which the method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".log(5), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log(self, base: Self) -> Self {\n+            match self.checked_log(base) {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is negative or zero it panics in debug mode and\n+        /// the return value is wrapped to 0 in release mode (the only situation in\n+        /// which the method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".log2(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log2(self) -> Self {\n+            match self.checked_log2() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is negative or zero it panics in debug mode and the\n+        /// return value is wrapped to 0 in release mode (the only situation in\n+        /// which the method can return 0).\n+        ///\n+        /// # Example\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".log10(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log10(self) -> Self {\n+            match self.checked_log10() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// Returns `None` if the number is zero, or if the base is not at least 2.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `checked_log2` can produce results more efficiently for base 2, and\n+        /// `checked_log10` can produce results more efficiently for base 10.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_log(5), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log(self, base: Self) -> Option<Self> {\n+            if self <= 0 || base <= 1 {\n+                None\n+            } else {\n+                let mut n = 0;\n+                let mut r = self;\n+\n+                // Optimization for 128 bit wide integers.\n+                if Self::BITS == 128 {\n+                    let b = Self::log2(self) / (Self::log2(base) + 1);\n+                    n += b;\n+                    r /= base.pow(b as u32);\n+                }\n+\n+                while r >= base {\n+                    r /= base;\n+                    n += 1;\n+                }\n+                Some(n)\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is zero.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_log2(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log2(self) -> Option<Self> {\n+            if self <= 0 {\n+                None\n+            } else {\n+                // SAFETY: We just checked that this number is positive\n+                let log = (Self::BITS - 1) as Self - unsafe { intrinsics::ctlz_nonzero(self) };\n+                Some(log)\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is zero.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_log10(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log10(self) -> Option<Self> {\n+            self.checked_log(10)\n+        }\n+\n         /// Checked negation. Computes `-self`, returning `None` unless `self ==\n         /// 0`.\n         ///"}, {"sha": "62491cc4d929e1e8901f466e82ad1e794f9fec1f", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=9f579968cd4a7544eae0b76859089d78b418f131", "patch": "@@ -45,6 +45,7 @@\n #![feature(try_trait_v2)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n+#![feature(int_log)]\n #![feature(iter_advance_by)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_intersperse)]"}, {"sha": "99a9b17ab118369e7dcf64c495a9c0110ec784a8", "filename": "library/core/tests/num/int_log.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs?ref=9f579968cd4a7544eae0b76859089d78b418f131", "patch": "@@ -0,0 +1,99 @@\n+//! This tests the `Integer::{log,log2,log10}` methods. These tests are in a\n+//! separate file because there's both a large number of them, and not all tests\n+//! can be run on Android. This is because in Android `log2` uses an imprecise\n+//! approximation:https://github.com/rust-lang/rust/blob/4825e12fc9c79954aa0fe18f5521efa6c19c7539/src/libstd/sys/unix/android.rs#L27-L53\n+\n+#[test]\n+fn checked_log() {\n+    assert_eq!(999u32.checked_log(10), Some(2));\n+    assert_eq!(1000u32.checked_log(10), Some(3));\n+    assert_eq!(555u32.checked_log(13), Some(2));\n+    assert_eq!(63u32.checked_log(4), Some(2));\n+    assert_eq!(64u32.checked_log(4), Some(3));\n+    assert_eq!(10460353203u64.checked_log(3), Some(21));\n+    assert_eq!(10460353202u64.checked_log(3), Some(20));\n+    assert_eq!(147808829414345923316083210206383297601u128.checked_log(3), Some(80));\n+    assert_eq!(147808829414345923316083210206383297600u128.checked_log(3), Some(79));\n+    assert_eq!(22528399544939174411840147874772641u128.checked_log(19683), Some(8));\n+    assert_eq!(22528399544939174411840147874772631i128.checked_log(19683), Some(7));\n+\n+    assert_eq!(0u8.checked_log(4), None);\n+    assert_eq!(0u16.checked_log(4), None);\n+    assert_eq!(0i8.checked_log(4), None);\n+    assert_eq!(0i16.checked_log(4), None);\n+\n+    for i in i16::MIN..=0 {\n+        assert_eq!(i.checked_log(4), None);\n+    }\n+    for i in 1..=i16::MAX {\n+        assert_eq!(i.checked_log(13), Some((i as f32).log(13.0) as i16));\n+    }\n+    for i in 1..=u16::MAX {\n+        assert_eq!(i.checked_log(13), Some((i as f32).log(13.0) as u16));\n+    }\n+}\n+\n+#[test]\n+fn checked_log2() {\n+    assert_eq!(5u32.checked_log2(), Some(2));\n+    assert_eq!(0u64.checked_log2(), None);\n+    assert_eq!(128i32.checked_log2(), Some(7));\n+    assert_eq!((-55i16).checked_log2(), None);\n+\n+    assert_eq!(0u8.checked_log2(), None);\n+    assert_eq!(0u16.checked_log2(), None);\n+    assert_eq!(0i8.checked_log2(), None);\n+    assert_eq!(0i16.checked_log2(), None);\n+\n+    for i in 1..=u8::MAX {\n+        assert_eq!(i.checked_log2(), Some((i as f32).log2() as u8));\n+    }\n+    for i in 1..=u16::MAX {\n+        // Guard against Android's imprecise f32::log2 implementation.\n+        if i != 8192 && i != 32768 {\n+            assert_eq!(i.checked_log2(), Some((i as f32).log2() as u16));\n+        }\n+    }\n+    for i in i8::MIN..=0 {\n+        assert_eq!(i.checked_log2(), None);\n+    }\n+    for i in 1..=i8::MAX {\n+        assert_eq!(i.checked_log2(), Some((i as f32).log2() as i8));\n+    }\n+    for i in i16::MIN..=0 {\n+        assert_eq!(i.checked_log2(), None);\n+    }\n+    for i in 1..=i16::MAX {\n+        // Guard against Android's imprecise f32::log2 implementation.\n+        if i != 8192 {\n+            assert_eq!(i.checked_log2(), Some((i as f32).log2() as i16));\n+        }\n+    }\n+}\n+\n+// Validate cases that fail on Android's imprecise float log2 implementation.\n+#[test]\n+#[cfg(not(target_os = \"android\"))]\n+fn checked_log2_not_android() {\n+    assert_eq!(8192u16.checked_log2(), Some((8192f32).log2() as u16));\n+    assert_eq!(32768u16.checked_log2(), Some((32768f32).log2() as u16));\n+    assert_eq!(8192i16.checked_log2(), Some((8192f32).log2() as i16));\n+}\n+\n+#[test]\n+fn checked_log10() {\n+    assert_eq!(0u8.checked_log10(), None);\n+    assert_eq!(0u16.checked_log10(), None);\n+    assert_eq!(0i8.checked_log10(), None);\n+    assert_eq!(0i16.checked_log10(), None);\n+\n+    for i in i16::MIN..=0 {\n+        assert_eq!(i.checked_log10(), None);\n+    }\n+    for i in 1..=i16::MAX {\n+        assert_eq!(i.checked_log10(), Some((i as f32).log10() as i16));\n+    }\n+    for i in 1..=u16::MAX {\n+        assert_eq!(i.checked_log10(), Some((i as f32).log10() as u16));\n+    }\n+}"}, {"sha": "76e838cf6bfbd2b75983a0257a82759db353cd99", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=9f579968cd4a7544eae0b76859089d78b418f131", "patch": "@@ -29,6 +29,7 @@ mod u8;\n mod bignum;\n mod dec2flt;\n mod flt2dec;\n+mod int_log;\n mod ops;\n mod wrapping;\n "}, {"sha": "5419262b516781f4c0c49555286e720d99c0201e", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f579968cd4a7544eae0b76859089d78b418f131/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9f579968cd4a7544eae0b76859089d78b418f131", "patch": "@@ -279,6 +279,7 @@\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(integer_atomics)]\n+#![feature(int_log)]\n #![feature(into_future)]\n #![feature(intra_doc_pointers)]\n #![feature(iter_zip)]"}]}