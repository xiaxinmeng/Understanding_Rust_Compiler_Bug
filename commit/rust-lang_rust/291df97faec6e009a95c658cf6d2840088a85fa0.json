{"sha": "291df97faec6e009a95c658cf6d2840088a85fa0", "node_id": "C_kwDOAAsO6NoAKDI5MWRmOTdmYWVjNmUwMDlhOTVjNjU4Y2Y2ZDI4NDAwODhhODVmYTA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-05T10:34:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-05T10:34:32Z"}, "message": "Rollup merge of #98624 - davidtwco:translation-on-lints, r=compiler-errors\n\nlints: mostly translatable diagnostics\n\nAs lints are created slightly differently than other diagnostics, intended to try make them translatable first and then look into the applicability of diagnostic structs but ended up just making most of the diagnostics in the crate translatable (which will still be useful if I do make a lot of them structs later anyway).\n\nr? ``@compiler-errors``", "tree": {"sha": "76c3345119e3eab819b2d7220429a0520f41efd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76c3345119e3eab819b2d7220429a0520f41efd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/291df97faec6e009a95c658cf6d2840088a85fa0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJixBO5CRBK7hj4Ov3rIwAACYoIAJe8GxRC96qVJcHvv9PyXSBB\nSRInepdP6sGy/DuH4xuuqFA9Z9m6wlsQewXGszD+lcHqUfjqNTVsBV1r4oqjwrJm\nbbEDq9AOCr71LNlf55c3Ucvp+9DnFNQM1rmOVf5zT2XaDomzWOglJ2z7xC6tLmHX\nbcEqArTfUJBsZQdYmoDKNzHn7NHRb+l34zPggczfRdyH0obS6ywuk97ReHGR1Qjn\n4RCB0xuGWeDu6EnPTXqO7wPEp28nfwtgXMiOU3gnz2v6ChyzF9y6pkcopPFZ+0Ab\nxP5HP6wNtbNkSrYKObKi2J1Lqcw9T0jdqUNcKumnD3OGFUZva5NV/69yJ+9lNMc=\n=xxz3\n-----END PGP SIGNATURE-----\n", "payload": "tree 76c3345119e3eab819b2d7220429a0520f41efd2\nparent 8fa1ed8f123f2714a7796c03d7d634b046bdaed2\nparent 9ff6c77d2f65ea57bbe7d656cf81071645823b90\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657017272 +0530\ncommitter GitHub <noreply@github.com> 1657017272 +0530\n\nRollup merge of #98624 - davidtwco:translation-on-lints, r=compiler-errors\n\nlints: mostly translatable diagnostics\n\nAs lints are created slightly differently than other diagnostics, intended to try make them translatable first and then look into the applicability of diagnostic structs but ended up just making most of the diagnostics in the crate translatable (which will still be useful if I do make a lot of them structs later anyway).\n\nr? ``@compiler-errors``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/291df97faec6e009a95c658cf6d2840088a85fa0", "html_url": "https://github.com/rust-lang/rust/commit/291df97faec6e009a95c658cf6d2840088a85fa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/291df97faec6e009a95c658cf6d2840088a85fa0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa1ed8f123f2714a7796c03d7d634b046bdaed2", "html_url": "https://github.com/rust-lang/rust/commit/8fa1ed8f123f2714a7796c03d7d634b046bdaed2"}, {"sha": "9ff6c77d2f65ea57bbe7d656cf81071645823b90", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ff6c77d2f65ea57bbe7d656cf81071645823b90", "html_url": "https://github.com/rust-lang/rust/commit/9ff6c77d2f65ea57bbe7d656cf81071645823b90"}], "stats": {"total": 1822, "additions": 1114, "deletions": 708}, "files": [{"sha": "e7e07093c0324db97a2b7c247f5800a4bb9f7c09", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -0,0 +1,400 @@\n+lint-array-into-iter =\n+    this method call resolves to `<&{$target} as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <{$target} as IntoIterator>::into_iter in Rust 2021\n+    .use-iter-suggestion = use `.iter()` instead of `.into_iter()` to avoid ambiguity\n+    .remove-into-iter-suggestion = or remove `.into_iter()` to iterate by value\n+    .use-explicit-into-iter-suggestion =\n+        or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n+\n+lint-enum-intrinsics-mem-discriminant =\n+    the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+    .note = the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `{$ty_param}`, which is not an enum.\n+\n+lint-enum-intrinsics-mem-variant =\n+    the return value of `mem::variant_count` is unspecified when called with a non-enum type\n+    .note = the type parameter of `variant_count` should be an enum, but it was instantiated with the type `{$ty_param}`, which is not an enum.\n+\n+lint-expectation = this lint expectation is unfulfilled\n+    .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n+\n+lint-hidden-unicode-codepoints = unicode codepoint changing visible direction of text present in {$label}\n+    .label = this {$label} contains {$count ->\n+        [one] an invisible\n+        *[other] invisible\n+    } unicode text flow control {$count ->\n+        [one] codepoint\n+        *[other] codepoints\n+    }\n+    .note = these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+    .suggestion-remove = if their presence wasn't intentional, you can remove them\n+    .suggestion-escape = if you want to keep them but make them visible in your source code, you can escape them\n+    .no-suggestion-note-escape = if you want to keep them but make them visible in your source code, you can escape them: {$escaped}\n+\n+lint-default-hash-types = prefer `{$preferred}` over `{$used}`, it has better performance\n+    .note = a `use rustc_data_structures::fx::{$preferred}` may be necessary\n+\n+lint-query-instability = using `{$query}` can result in unstable query results\n+    .note = if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n+\n+lint-tykind-kind = usage of `ty::TyKind::<kind>`\n+    .suggestion = try using `ty::<kind>` directly\n+\n+lint-tykind = usage of `ty::TyKind`\n+    .help = try using `Ty` instead\n+\n+lint-ty-qualified = usage of qualified `ty::{$ty}`\n+    .suggestion = try importing it and using it unqualified\n+\n+lint-lintpass-by-hand = implementing `LintPass` by hand\n+    .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n+\n+lint-non-existant-doc-keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \\\"...\\\")]`\n+    .help = only existing keywords are allowed in core/std\n+\n+lint-diag-out-of-impl =\n+    diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\n+\n+lint-untranslatable-diag = diagnostics should be created using translatable messages\n+\n+lint-cstring-ptr = getting the inner pointer of a temporary `CString`\n+    .as-ptr-label = this pointer will be invalid\n+    .unwrap-label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n+    .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n+    .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n+\n+lint-identifier-non-ascii-char = identifier contains non-ASCII characters\n+\n+lint-identifier-uncommon-codepoints = identifier contains uncommon Unicode codepoints\n+\n+lint-confusable-identifier-pair = identifier pair considered confusable between `{$existing_sym}` and `{$sym}`\n+    .label = this is where the previous identifier occurred\n+\n+lint-mixed-script-confusables =\n+    the usage of Script Group `{$set}` in this crate consists solely of mixed script confusables\n+    .includes-note = the usage includes {$includes}\n+    .note = please recheck to make sure their usages are indeed what you want\n+\n+lint-non-fmt-panic = panic message is not a string literal\n+    .note = this usage of `{$name}!()` is deprecated; it will be a hard error in Rust 2021\n+    .more-info-note = for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n+    .supports-fmt-note = the `{$name}!()` macro supports formatting, so there's no need for the `format!()` macro here\n+    .supports-fmt-suggestion = remove the `format!(..)` macro call\n+    .display-suggestion = add a \"{\"{\"}{\"}\"}\" format string to `Display` the message\n+    .debug-suggestion =\n+        add a \"{\"{\"}:?{\"}\"}\" format string to use the `Debug` implementation of `{$ty}`\n+    .panic-suggestion = {$already_suggested ->\n+        [true] or use\n+        *[false] use\n+    } std::panic::panic_any instead\n+\n+lint-non-fmt-panic-unused =\n+    panic message contains {$count ->\n+        [one] an unused\n+        *[other] unused\n+    } formatting {$count ->\n+        [one] placeholder\n+        *[other] placeholders\n+    }\n+    .note = this message is not used as a format string when given without arguments, but will be in Rust 2021\n+    .add-args-suggestion = add the missing {$count ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .add-fmt-suggestion = or add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n+\n+lint-non-fmt-panic-braces =\n+    panic message contains {$count ->\n+        [one] a brace\n+        *[other] braces\n+    }\n+    .note = this message is not used as a format string, but will be in Rust 2021\n+    .suggestion = add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n+\n+lint-non-camel-case-type = {$sort} `{$name}` should have an upper camel case name\n+    .suggestion = convert the identifier to upper camel case\n+    .label = should have an UpperCamelCase name\n+\n+lint-non-snake-case = {$sort} `{$name}` should have a snake case name\n+    .rename-or-convert-suggestion = rename the identifier or convert it to a snake case raw identifier\n+    .cannot-convert-note = `{$sc}` cannot be used as a raw identifier\n+    .rename-suggestion = rename the identifier\n+    .convert-suggestion = convert the identifier to snake case\n+    .help = convert the identifier to snake case: `{$sc}`\n+    .label = should have a snake_case name\n+\n+lint-non-upper_case-global = {$sort} `{$name}` should have an upper case name\n+    .suggestion = convert the identifier to upper case\n+    .label = should have an UPPER_CASE name\n+\n+lint-noop-method-call = call to `.{$method}()` on a reference in this situation does nothing\n+    .label = unnecessary method call\n+    .note = the type `{$receiver_ty}` which `{$method}` is being called on is the same as the type returned from `{$method}`, so the method call does not do anything and can be removed\n+\n+lint-pass-by-value = passing `{$ty}` by reference\n+    .suggestion = try passing by value\n+\n+lint-redundant-semicolons =\n+    unnecessary trailing {$multiple ->\n+        [true] semicolons\n+        *[false] semicolon\n+    }\n+    .suggestion = remove {$multiple ->\n+        [true] these semicolons\n+        *[false] this semicolon\n+    }\n+\n+lint-drop-trait-constraints =\n+    bounds on `{$predicate}` are most likely incorrect, consider instead using `{$needs_drop}` to detect whether a type can be trivially dropped\n+\n+lint-drop-glue =\n+    types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n+\n+lint-range-endpoint-out-of-range = range endpoint is out of range for `{$ty}`\n+    .suggestion = use an inclusive range instead\n+\n+lint-overflowing-bin-hex = literal out of range for `{$ty}`\n+    .negative-note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n+    .negative-becomes-note = and the value `-{$lit}` will become `{$actually}{$ty}`\n+    .positive-note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n+    .suggestion = consider using the type `{$suggestion_ty}` instead\n+    .help = consider using the type `{$suggestion_ty}` instead\n+\n+lint-overflowing-int = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+    .help = consider using the type `{$suggestion_ty}` instead\n+\n+lint-only-cast-u8-to-char = only `u8` can be cast into `char`\n+    .suggestion = use a `char` literal instead\n+\n+lint-overflowing-uint = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+\n+lint-overflowing-literal = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n+\n+lint-unused-comparisons = comparison is useless due to type limits\n+\n+lint-improper-ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n+    .label = not FFI-safe\n+    .note = the type is defined here\n+\n+lint-improper-ctypes-opaque = opaque types have no C equivalent\n+\n+lint-improper-ctypes-fnptr-reason = this function pointer has Rust-specific calling convention\n+lint-improper-ctypes-fnptr-help = consider using an `extern fn(...) -> ...` function pointer instead\n+\n+lint-improper-ctypes-tuple-reason = tuples have unspecified layout\n+lint-improper-ctypes-tuple-help = consider using a struct instead\n+\n+lint-improper-ctypes-str-reason = string slices have no C equivalent\n+lint-improper-ctypes-str-help = consider using `*const u8` and a length instead\n+\n+lint-improper-ctypes-dyn = trait objects have no C equivalent\n+\n+lint-improper-ctypes-slice-reason = slices have no C equivalent\n+lint-improper-ctypes-slice-help = consider using a raw pointer instead\n+\n+lint-improper-ctypes-128bit = 128-bit integers don't currently have a known stable ABI\n+\n+lint-improper-ctypes-char-reason = the `char` type has no C equivalent\n+lint-improper-ctypes-char-help = consider using `u32` or `libc::wchar_t` instead\n+\n+lint-improper-ctypes-non-exhaustive = this enum is non-exhaustive\n+lint-improper-ctypes-non-exhaustive-variant = this enum has non-exhaustive variants\n+\n+lint-improper-ctypes-enum-repr-reason = enum has no representation hint\n+lint-improper-ctypes-enum-repr-help =\n+    consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n+\n+lint-improper-ctypes-struct-fieldless-reason = this struct has no fields\n+lint-improper-ctypes-struct-fieldless-help = consider adding a member to this struct\n+\n+lint-improper-ctypes-union-fieldless-reason = this union has no fields\n+lint-improper-ctypes-union-fieldless-help = consider adding a member to this union\n+\n+lint-improper-ctypes-struct-non-exhaustive = this struct is non-exhaustive\n+lint-improper-ctypes-union-non-exhaustive = this union is non-exhaustive\n+\n+lint-improper-ctypes-struct-layout-reason = this struct has unspecified layout\n+lint-improper-ctypes-struct-layout-help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n+\n+lint-improper-ctypes-union-layout-reason = this union has unspecified layout\n+lint-improper-ctypes-union-layout-help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n+\n+lint-improper-ctypes-box = box cannot be represented as a single pointer\n+\n+lint-improper-ctypes-enum-phantomdata = this enum contains a PhantomData field\n+\n+lint-improper-ctypes-struct-zst = this struct contains only zero-sized fields\n+\n+lint-improper-ctypes-array-reason = passing raw arrays by value is not FFI-safe\n+lint-improper-ctypes-array-help = consider passing a pointer to the array\n+\n+lint-improper-ctypes-only-phantomdata = composed only of `PhantomData`\n+\n+lint-variant-size-differences =\n+    enum variant is more than three times larger ({$largest} bytes) than the next largest\n+\n+lint-atomic-ordering-load = atomic loads cannot have `Release` or `AcqRel` ordering\n+    .help = consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n+\n+lint-atomic-ordering-store = atomic stores cannot have `Acquire` or `AcqRel` ordering\n+    .help = consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n+\n+lint-atomic-ordering-fence = memory fences cannot have `Relaxed` ordering\n+    .help = consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n+\n+lint-atomic-ordering-invalid = `{$method}`'s failure ordering may not be `Release` or `AcqRel`, since a failed `{$method}` does not result in a write\n+    .label = invalid failure ordering\n+    .help = consider using `Acquire` or `Relaxed` failure ordering instead\n+\n+lint-atomic-ordering-invalid-fail-success = `{$method}`'s success ordering must be at least as strong as its failure ordering\n+    .fail-label = `{$fail_ordering}` failure ordering\n+    .success-label = `{$success_ordering}` success ordering\n+    .suggestion = consider using `{$success_suggestion}` success ordering instead\n+\n+lint-unused-op = unused {$op} that must be used\n+    .label = the {$op} produces a value\n+    .suggestion = use `let _ = ...` to ignore the resulting value\n+\n+lint-unused-result = unused result of type `{$ty}`\n+\n+lint-unused-closure =\n+    unused {$pre}{$count ->\n+        [one] closure\n+        *[other] closures\n+    }{$post} that must be used\n+    .note = closures are lazy and do nothing unless called\n+\n+lint-unused-generator =\n+    unused {$pre}{$count ->\n+        [one] generator\n+        *[other] generator\n+    }{$post} that must be used\n+    .note = generators are lazy and do nothing unless resumed\n+\n+lint-unused-def = unused {$pre}`{$def}`{$post} that must be used\n+\n+lint-path-statement-drop = path statement drops value\n+    .suggestion = use `drop` to clarify the intent\n+\n+lint-path-statement-no-effect = path statement with no effect\n+\n+lint-unused-delim = unnecessary {$delim} around {$item}\n+    .suggestion = remove these {$delim}\n+\n+lint-unused-import-braces = braces around {$node} is unnecessary\n+\n+lint-unused-allocation = unnecessary allocation, use `&` instead\n+lint-unused-allocation-mut = unnecessary allocation, use `&mut` instead\n+\n+lint-builtin-while-true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n+    .suggestion = use `loop`\n+\n+lint-builtin-box-pointers = type uses owned (Box type) pointers: {$ty}\n+\n+lint-builtin-non-shorthand-field-patterns = the `{$ident}:` in this pattern is redundant\n+    .suggestion = use shorthand field pattern\n+\n+lint-builtin-overridden-symbol-name =\n+    the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+\n+lint-builtin-overridden-symbol-section =\n+    the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them\n+\n+lint-builtin-allow-internal-unsafe =\n+    `allow_internal_unsafe` allows defining macros using unsafe without triggering the `unsafe_code` lint at their call site\n+\n+lint-builtin-unsafe-block = usage of an `unsafe` block\n+\n+lint-builtin-unsafe-trait = declaration of an `unsafe` trait\n+\n+lint-builtin-unsafe-impl = implementation of an `unsafe` trait\n+\n+lint-builtin-no-mangle-fn = declaration of a `no_mangle` function\n+lint-builtin-export-name-fn = declaration of a function with `export_name`\n+lint-builtin-link-section-fn = declaration of a function with `link_section`\n+\n+lint-builtin-no-mangle-static = declaration of a `no_mangle` static\n+lint-builtin-export-name-static = declaration of a static with `export_name`\n+lint-builtin-link-section-static = declaration of a static with `link_section`\n+\n+lint-builtin-no-mangle-method = declaration of a `no_mangle` method\n+lint-builtin-export-name-method = declaration of a method with `export_name`\n+\n+lint-builtin-decl-unsafe-fn = declaration of an `unsafe` function\n+lint-builtin-decl-unsafe-method = declaration of an `unsafe` method\n+lint-builtin-impl-unsafe-method = implementation of an `unsafe` method\n+\n+lint-builtin-missing-doc = missing documentation for {$article} {$desc}\n+\n+lint-builtin-missing-copy-impl = type could implement `Copy`; consider adding `impl Copy`\n+\n+lint-builtin-missing-debug-impl =\n+    type does not implement `{$debug}`; consider adding `#[derive(Debug)]` or a manual implementation\n+\n+lint-builtin-anonymous-params = anonymous parameters are deprecated and will be removed in the next edition\n+    .suggestion = try naming the parameter or explicitly ignoring it\n+\n+lint-builtin-deprecated-attr-link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n+lint-builtin-deprecated-attr-used = use of deprecated attribute `{$name}`: no longer used.\n+lint-builtin-deprecated-attr-default-suggestion = remove this attribute\n+\n+lint-builtin-unused-doc-comment = unused doc comment\n+    .label = rustdoc does not generate documentation for {$kind}\n+    .plain-help = use `//` for a plain comment\n+    .block-help = use `/* */` for a plain comment\n+\n+lint-builtin-no-mangle-generic = functions generic over types or consts must be mangled\n+    .suggestion = remove this attribute\n+\n+lint-builtin-const-no-mangle = const items should never be `#[no_mangle]`\n+    .suggestion = try a static value\n+\n+lint-builtin-mutable-transmutes =\n+    transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n+\n+lint-builtin-unstable-features = unstable feature\n+\n+lint-builtin-unreachable-pub = unreachable `pub` {$what}\n+    .suggestion = consider restricting its visibility\n+    .help = or consider exporting it for use by other crates\n+\n+lint-builtin-type-alias-bounds-help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n+\n+lint-builtin-type-alias-where-clause = where clauses are not enforced in type aliases\n+    .suggestion = the clause will not be checked when the type alias is used, and should be removed\n+\n+lint-builtin-type-alias-generic-bounds = bounds on generic parameters are not enforced in type aliases\n+    .suggestion = the bound will not be checked when the type alias is used, and should be removed\n+\n+lint-builtin-trivial-bounds = {$predicate_kind_name} bound {$predicate} does not depend on any type or lifetime parameters\n+\n+lint-builtin-ellipsis-inclusive-range-patterns = `...` range patterns are deprecated\n+    .suggestion = use `..=` for an inclusive range\n+\n+lint-builtin-unnameable-test-items = cannot test inner items\n+\n+lint-builtin-keyword-idents = `{$kw}` is a keyword in the {$next} edition\n+    .suggestion = you can use a raw identifier to stay compatible\n+\n+lint-builtin-explicit-outlives = outlives requirements can be inferred\n+    .suggestion = remove {$count ->\n+        [one] this bound\n+        *[other] these bounds\n+    }\n+\n+lint-builtin-incomplete-features = the feature `{$name}` is incomplete and may not be safe to use and/or cause compiler crashes\n+    .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n+    .help = consider using `min_{$name}` instead, which is more stable and complete\n+\n+lint-builtin-clashing-extern-same-name = `{$this_fi}` redeclared with a different signature\n+    .previous-decl-label = `{$orig}` previously declared here\n+    .mismatch-label = this signature doesn't match the previous declaration\n+lint-builtin-clashing-extern-diff-name = `{$this_fi}` redeclares `{$orig}` with a different signature\n+    .previous-decl-label = `{$orig}` previously declared here\n+    .mismatch-label = this signature doesn't match the previous declaration\n+\n+lint-builtin-deref-nullptr = dereferencing a null pointer\n+    .label = this code causes undefined behavior when executed\n+\n+lint-builtin-asm-labels = avoid using named labels in inline assembly"}, {"sha": "563d0534d8f388c460daccf53783a9a631d4ad5c", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -31,11 +31,12 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    borrowck => \"../locales/en-US/borrowck.ftl\",\n+    builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n+    lint => \"../locales/en-US/lint.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n-    builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n-    borrowck => \"../locales/en-US/borrowck.ftl\",\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};"}, {"sha": "c15dc024736f3ed0a0d3b8dd0b5bec8d8d49bae1", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -8,7 +8,7 @@ use rustc_error_messages::FluentValue;\n use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n@@ -39,12 +39,94 @@ pub trait IntoDiagnosticArg {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static>;\n }\n \n+impl IntoDiagnosticArg for bool {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        if self {\n+            DiagnosticArgValue::Str(Cow::Borrowed(\"true\"))\n+        } else {\n+            DiagnosticArgValue::Str(Cow::Borrowed(\"false\"))\n+        }\n+    }\n+}\n+\n+impl IntoDiagnosticArg for i8 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u8 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for i16 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u16 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for i32 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u32 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for i64 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u64 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for i128 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for u128 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for String {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Owned(self))\n     }\n }\n \n+impl IntoDiagnosticArg for std::num::NonZeroU32 {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for Edition {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for Symbol {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         self.to_ident_string().into_diagnostic_arg()"}, {"sha": "1ad33ef25b763af5f27d12a62a25fc3cafd9c963", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -529,7 +529,7 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         applicability: Applicability,\n     ) -> &mut Self);\n \n-    forward!(pub fn set_primary_message(&mut self, msg: impl Into<String>) -> &mut Self);\n+    forward!(pub fn set_primary_message(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n     forward!(pub fn set_span(&mut self, sp: impl Into<MultiSpan>) -> &mut Self);\n     forward!(pub fn code(&mut self, s: DiagnosticId) -> &mut Self);\n     forward!(pub fn set_arg("}, {"sha": "121fefdc6207a830041ea7b2d20c5f99a19b6986", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,5 +1,5 @@\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::Applicability;\n+use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n@@ -120,31 +120,30 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                 _ => bug!(\"array type coerced to something other than array or slice\"),\n             };\n             cx.struct_span_lint(ARRAY_INTO_ITER, call.ident.span, |lint| {\n-                let mut diag = lint.build(&format!(\n-                    \"this method call resolves to `<&{} as IntoIterator>::into_iter` \\\n-                    (due to backwards compatibility), \\\n-                    but will resolve to <{} as IntoIterator>::into_iter in Rust 2021\",\n-                    target, target,\n-                ));\n+                let mut diag = lint.build(fluent::lint::array_into_iter);\n+                diag.set_arg(\"target\", target);\n                 diag.span_suggestion(\n                     call.ident.span,\n-                    \"use `.iter()` instead of `.into_iter()` to avoid ambiguity\",\n+                    fluent::lint::use_iter_suggestion,\n                     \"iter\",\n                     Applicability::MachineApplicable,\n                 );\n                 if self.for_expr_span == expr.span {\n                     diag.span_suggestion(\n                         receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                        \"or remove `.into_iter()` to iterate by value\",\n+                        fluent::lint::remove_into_iter_suggestion,\n                         \"\",\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else if receiver_ty.is_array() {\n                     diag.multipart_suggestion(\n-                        \"or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\",\n+                        fluent::lint::use_explicit_into_iter_suggestion,\n                         vec![\n                             (expr.span.shrink_to_lo(), \"IntoIterator::into_iter(\".into()),\n-                            (receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()), \")\".into()),\n+                            (\n+                                receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n+                                \")\".into(),\n+                            ),\n                         ],\n                         Applicability::MaybeIncorrect,\n                     );"}, {"sha": "2fa4d7e072fef6c851df1826a977464a747d71bd", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 151, "deletions": 181, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -31,7 +31,9 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticStyledString, MultiSpan};\n+use rustc_errors::{\n+    fluent, Applicability, Diagnostic, DiagnosticMessage, DiagnosticStyledString, MultiSpan,\n+};\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -99,13 +101,12 @@ impl EarlyLintPass for WhileTrue {\n             if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind {\n                 if let ast::LitKind::Bool(true) = lit.kind {\n                     if !lit.span.from_expansion() {\n-                        let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = e.span.with_hi(cond.span.hi());\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n-                            lint.build(msg)\n+                            lint.build(fluent::lint::builtin_while_true)\n                                 .span_suggestion_short(\n                                     condition_span,\n-                                    \"use `loop`\",\n+                                    fluent::lint::suggestion,\n                                     format!(\n                                         \"{}loop\",\n                                         label.map_or_else(String::new, |label| format!(\n@@ -156,7 +157,7 @@ impl BoxPointers {\n             if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n                 if leaf_ty.is_box() {\n                     cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n-                        lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit();\n+                        lint.build(fluent::lint::builtin_box_pointers).set_arg(\"ty\", ty).emit();\n                     });\n                 }\n             }\n@@ -257,26 +258,26 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                         == Some(cx.tcx.field_index(fieldpat.hir_id, cx.typeck_results()))\n                     {\n                         cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span, |lint| {\n-                            let mut err = lint\n-                                .build(&format!(\"the `{}:` in this pattern is redundant\", ident));\n                             let binding = match binding_annot {\n                                 hir::BindingAnnotation::Unannotated => None,\n                                 hir::BindingAnnotation::Mutable => Some(\"mut\"),\n                                 hir::BindingAnnotation::Ref => Some(\"ref\"),\n                                 hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n                             };\n-                            let ident = if let Some(binding) = binding {\n+                            let suggested_ident = if let Some(binding) = binding {\n                                 format!(\"{} {}\", binding, ident)\n                             } else {\n                                 ident.to_string()\n                             };\n-                            err.span_suggestion(\n-                                fieldpat.span,\n-                                \"use shorthand field pattern\",\n-                                ident,\n-                                Applicability::MachineApplicable,\n-                            );\n-                            err.emit();\n+                            lint.build(fluent::lint::builtin_non_shorthand_field_patterns)\n+                                .set_arg(\"ident\", ident.clone())\n+                                .span_suggestion(\n+                                    fieldpat.span,\n+                                    fluent::lint::suggestion,\n+                                    suggested_ident,\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n                         });\n                     }\n                 }\n@@ -327,26 +328,25 @@ impl UnsafeCode {\n         cx.struct_span_lint(UNSAFE_CODE, span, decorate);\n     }\n \n-    fn report_overridden_symbol_name(&self, cx: &EarlyContext<'_>, span: Span, msg: &str) {\n+    fn report_overridden_symbol_name(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    ) {\n         self.report_unsafe(cx, span, |lint| {\n-            lint.build(msg)\n-                .note(\n-                    \"the linker's behavior with multiple libraries exporting duplicate symbol \\\n-                    names is undefined and Rust cannot provide guarantees when you manually \\\n-                    override them\",\n-                )\n-                .emit();\n+            lint.build(msg).note(fluent::lint::builtin_overridden_symbol_name).emit();\n         })\n     }\n \n-    fn report_overridden_symbol_section(&self, cx: &EarlyContext<'_>, span: Span, msg: &str) {\n+    fn report_overridden_symbol_section(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    ) {\n         self.report_unsafe(cx, span, |lint| {\n-            lint.build(msg)\n-                .note(\n-                    \"the program's behavior with overridden link sections on items is unpredictable \\\n-                    and Rust cannot provide guarantees when you manually override them\",\n-                )\n-                .emit();\n+            lint.build(msg).note(fluent::lint::builtin_overridden_symbol_section).emit();\n         })\n     }\n }\n@@ -355,12 +355,7 @@ impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.has_name(sym::allow_internal_unsafe) {\n             self.report_unsafe(cx, attr.span, |lint| {\n-                lint.build(\n-                    \"`allow_internal_unsafe` allows defining \\\n-                                               macros using unsafe without triggering \\\n-                                               the `unsafe_code` lint at their call site\",\n-                )\n-                .emit();\n+                lint.build(fluent::lint::builtin_allow_internal_unsafe).emit();\n             });\n         }\n     }\n@@ -370,7 +365,7 @@ impl EarlyLintPass for UnsafeCode {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n                 self.report_unsafe(cx, blk.span, |lint| {\n-                    lint.build(\"usage of an `unsafe` block\").emit();\n+                    lint.build(fluent::lint::builtin_unsafe_block).emit();\n                 });\n             }\n         }\n@@ -380,36 +375,36 @@ impl EarlyLintPass for UnsafeCode {\n         match it.kind {\n             ast::ItemKind::Trait(box ast::Trait { unsafety: ast::Unsafe::Yes(_), .. }) => self\n                 .report_unsafe(cx, it.span, |lint| {\n-                    lint.build(\"declaration of an `unsafe` trait\").emit();\n+                    lint.build(fluent::lint::builtin_unsafe_trait).emit();\n                 }),\n \n             ast::ItemKind::Impl(box ast::Impl { unsafety: ast::Unsafe::Yes(_), .. }) => self\n                 .report_unsafe(cx, it.span, |lint| {\n-                    lint.build(\"implementation of an `unsafe` trait\").emit();\n+                    lint.build(fluent::lint::builtin_unsafe_impl).emit();\n                 }),\n \n             ast::ItemKind::Fn(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        \"declaration of a `no_mangle` function\",\n+                        fluent::lint::builtin_no_mangle_fn,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        \"declaration of a function with `export_name`\",\n+                        fluent::lint::builtin_export_name_fn,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n                     self.report_overridden_symbol_section(\n                         cx,\n                         attr.span,\n-                        \"declaration of a function with `link_section`\",\n+                        fluent::lint::builtin_link_section_fn,\n                     );\n                 }\n             }\n@@ -419,23 +414,23 @@ impl EarlyLintPass for UnsafeCode {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        \"declaration of a `no_mangle` static\",\n+                        fluent::lint::builtin_no_mangle_static,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        \"declaration of a static with `export_name`\",\n+                        fluent::lint::builtin_export_name_static,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n                     self.report_overridden_symbol_section(\n                         cx,\n                         attr.span,\n-                        \"declaration of a static with `link_section`\",\n+                        fluent::lint::builtin_link_section_static,\n                     );\n                 }\n             }\n@@ -450,14 +445,14 @@ impl EarlyLintPass for UnsafeCode {\n                 self.report_overridden_symbol_name(\n                     cx,\n                     attr.span,\n-                    \"declaration of a `no_mangle` method\",\n+                    fluent::lint::builtin_no_mangle_method,\n                 );\n             }\n             if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                 self.report_overridden_symbol_name(\n                     cx,\n                     attr.span,\n-                    \"declaration of a method with `export_name`\",\n+                    fluent::lint::builtin_export_name_method,\n                 );\n             }\n         }\n@@ -475,9 +470,9 @@ impl EarlyLintPass for UnsafeCode {\n         {\n             let msg = match ctxt {\n                 FnCtxt::Foreign => return,\n-                FnCtxt::Free => \"declaration of an `unsafe` function\",\n-                FnCtxt::Assoc(_) if body.is_none() => \"declaration of an `unsafe` method\",\n-                FnCtxt::Assoc(_) => \"implementation of an `unsafe` method\",\n+                FnCtxt::Free => fluent::lint::builtin_decl_unsafe_fn,\n+                FnCtxt::Assoc(_) if body.is_none() => fluent::lint::builtin_decl_unsafe_method,\n+                FnCtxt::Assoc(_) => fluent::lint::builtin_impl_unsafe_method,\n             };\n             self.report_unsafe(cx, span, |lint| {\n                 lint.build(msg).emit();\n@@ -587,7 +582,10 @@ impl MissingDoc {\n                 MISSING_DOCS,\n                 cx.tcx.sess.source_map().guess_head_span(sp),\n                 |lint| {\n-                    lint.build(&format!(\"missing documentation for {} {}\", article, desc)).emit();\n+                    lint.build(fluent::lint::builtin_missing_doc)\n+                        .set_arg(\"article\", article)\n+                        .set_arg(\"desc\", desc)\n+                        .emit();\n                 },\n             );\n         }\n@@ -783,11 +781,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         .is_ok()\n         {\n             cx.struct_span_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, |lint| {\n-                lint.build(\n-                    \"type could implement `Copy`; consider adding `impl \\\n-                          Copy`\",\n-                )\n-                .emit();\n+                lint.build(fluent::lint::builtin_missing_copy_impl).emit();\n             })\n         }\n     }\n@@ -863,12 +857,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.def_id) {\n             cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n-                lint.build(&format!(\n-                    \"type does not implement `{}`; consider adding `#[derive(Debug)]` \\\n-                     or a manual implementation\",\n-                    cx.tcx.def_path_str(debug)\n-                ))\n-                .emit();\n+                lint.build(fluent::lint::builtin_missing_debug_impl)\n+                    .set_arg(\"debug\", cx.tcx.def_path_str(debug))\n+                    .emit();\n             });\n         }\n     }\n@@ -946,18 +937,14 @@ impl EarlyLintPass for AnonymousParameters {\n                                 (\"<type>\", Applicability::HasPlaceholders)\n                             };\n \n-                            lint.build(\n-                                \"anonymous parameters are deprecated and will be \\\n-                                     removed in the next edition\",\n-                            )\n-                            .span_suggestion(\n-                                arg.pat.span,\n-                                \"try naming the parameter or explicitly \\\n-                                            ignoring it\",\n-                                format!(\"_: {}\", ty_snip),\n-                                appl,\n-                            )\n-                            .emit();\n+                            lint.build(fluent::lint::builtin_anonymous_params)\n+                                .span_suggestion(\n+                                    arg.pat.span,\n+                                    fluent::lint::suggestion,\n+                                    format!(\"_: {}\", ty_snip),\n+                                    appl,\n+                                )\n+                                .emit();\n                         })\n                     }\n                 }\n@@ -982,24 +969,6 @@ impl DeprecatedAttr {\n     }\n }\n \n-fn lint_deprecated_attr(\n-    cx: &EarlyContext<'_>,\n-    attr: &ast::Attribute,\n-    msg: &str,\n-    suggestion: Option<&str>,\n-) {\n-    cx.struct_span_lint(DEPRECATED, attr.span, |lint| {\n-        lint.build(msg)\n-            .span_suggestion_short(\n-                attr.span,\n-                suggestion.unwrap_or(\"remove this attribute\"),\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n-    })\n-}\n-\n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         for BuiltinAttribute { name, gate, .. } in &self.depr_attrs {\n@@ -1011,17 +980,38 @@ impl EarlyLintPass for DeprecatedAttr {\n                     _,\n                 ) = gate\n                 {\n-                    let msg =\n-                        format!(\"use of deprecated attribute `{}`: {}. See {}\", name, reason, link);\n-                    lint_deprecated_attr(cx, attr, &msg, suggestion);\n+                    cx.struct_span_lint(DEPRECATED, attr.span, |lint| {\n+                        // FIXME(davidtwco) translatable deprecated attr\n+                        lint.build(fluent::lint::builtin_deprecated_attr_link)\n+                            .set_arg(\"name\", name)\n+                            .set_arg(\"reason\", reason)\n+                            .set_arg(\"link\", link)\n+                            .span_suggestion_short(\n+                                attr.span,\n+                                suggestion.map(|s| s.into()).unwrap_or(\n+                                    fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                                ),\n+                                \"\",\n+                                Applicability::MachineApplicable,\n+                            )\n+                            .emit();\n+                    });\n                 }\n                 return;\n             }\n         }\n         if attr.has_name(sym::no_start) || attr.has_name(sym::crate_id) {\n-            let path_str = pprust::path_to_string(&attr.get_normal_item().path);\n-            let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n-            lint_deprecated_attr(cx, attr, &msg, None);\n+            cx.struct_span_lint(DEPRECATED, attr.span, |lint| {\n+                lint.build(fluent::lint::builtin_deprecated_attr_used)\n+                    .set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n+                    .span_suggestion_short(\n+                        attr.span,\n+                        fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                        \"\",\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+            });\n         }\n     }\n }\n@@ -1049,17 +1039,15 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n \n         if is_doc_comment || attr.has_name(sym::doc) {\n             cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n-                let mut err = lint.build(\"unused doc comment\");\n-                err.span_label(\n-                    node_span,\n-                    format!(\"rustdoc does not generate documentation for {}\", node_kind),\n-                );\n+                let mut err = lint.build(fluent::lint::builtin_unused_doc_comment);\n+                err.set_arg(\"kind\", node_kind);\n+                err.span_label(node_span, fluent::lint::label);\n                 match attr.kind {\n                     AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n-                        err.help(\"use `//` for a plain comment\");\n+                        err.help(fluent::lint::plain_help);\n                     }\n                     AttrKind::DocComment(CommentKind::Block, _) => {\n-                        err.help(\"use `/* */` for a plain comment\");\n+                        err.help(fluent::lint::block_help);\n                     }\n                 }\n                 err.emit();\n@@ -1178,10 +1166,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                     GenericParamKind::Lifetime { .. } => {}\n                     GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                         cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS, span, |lint| {\n-                            lint.build(\"functions generic over types or consts must be mangled\")\n+                            lint.build(fluent::lint::builtin_no_mangle_generic)\n                                 .span_suggestion_short(\n                                     no_mangle_attr.span,\n-                                    \"remove this attribute\",\n+                                    fluent::lint::suggestion,\n                                     \"\",\n                                     // Use of `#[no_mangle]` suggests FFI intent; correct\n                                     // fix may be to monomorphize source by hand\n@@ -1205,8 +1193,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n-                        let msg = \"const items should never be `#[no_mangle]`\";\n-                        let mut err = lint.build(msg);\n+                        let mut err = lint.build(fluent::lint::builtin_const_no_mangle);\n \n                         // account for \"pub const\" (#45562)\n                         let start = cx\n@@ -1220,7 +1207,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                         let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n                         err.span_suggestion(\n                             const_span,\n-                            \"try a static value\",\n+                            fluent::lint::suggestion,\n                             \"pub static\",\n                             Applicability::MachineApplicable,\n                         );\n@@ -1285,10 +1272,8 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n             if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                let msg = \"transmuting &T to &mut T is undefined behavior, \\\n-                    even if the reference is unused, consider instead using an UnsafeCell\";\n                 cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| {\n-                    lint.build(msg).emit();\n+                    lint.build(fluent::lint::builtin_mutable_transmutes).emit();\n                 });\n             }\n         }\n@@ -1338,7 +1323,7 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n                     cx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n-                        lint.build(\"unstable feature\").emit();\n+                        lint.build(fluent::lint::builtin_unstable_features).emit();\n                     });\n                 }\n             }\n@@ -1400,16 +1385,17 @@ impl UnreachablePub {\n             }\n             let def_span = cx.tcx.sess.source_map().guess_head_span(span);\n             cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n-                let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n+                let mut err = lint.build(fluent::lint::builtin_unreachable_pub);\n+                err.set_arg(\"what\", what);\n \n                 err.span_suggestion(\n                     vis_span,\n-                    \"consider restricting its visibility\",\n+                    fluent::lint::suggestion,\n                     \"pub(crate)\",\n                     applicability,\n                 );\n                 if exportable {\n-                    err.help(\"or consider exporting it for use by other crates\");\n+                    err.help(fluent::lint::help);\n                 }\n                 err.emit();\n             });\n@@ -1513,11 +1499,7 @@ impl TypeAliasBounds {\n         impl Visitor<'_> for WalkAssocTypes<'_> {\n             fn visit_qpath(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) {\n                 if TypeAliasBounds::is_type_variable_assoc(qpath) {\n-                    self.err.span_help(\n-                        span,\n-                        \"use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to \\\n-                         associated types in type aliases\",\n-                    );\n+                    self.err.span_help(span, fluent::lint::builtin_type_alias_bounds_help);\n                 }\n                 intravisit::walk_qpath(self, qpath, id, span)\n             }\n@@ -1561,11 +1543,11 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n         let mut suggested_changing_assoc_types = false;\n         if !where_spans.is_empty() {\n             cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n-                let mut err = lint.build(\"where clauses are not enforced in type aliases\");\n+                let mut err = lint.build(fluent::lint::builtin_type_alias_where_clause);\n                 err.set_span(where_spans);\n                 err.span_suggestion(\n                     type_alias_generics.where_clause_span,\n-                    \"the clause will not be checked when the type alias is used, and should be removed\",\n+                    fluent::lint::suggestion,\n                     \"\",\n                     Applicability::MachineApplicable,\n                 );\n@@ -1579,11 +1561,10 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n \n         if !inline_spans.is_empty() {\n             cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n-                let mut err =\n-                    lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n+                let mut err = lint.build(fluent::lint::builtin_type_alias_generic_bounds);\n                 err.set_span(inline_spans);\n                 err.multipart_suggestion(\n-                    \"the bound will not be checked when the type alias is used, and should be removed\",\n+                    fluent::lint::suggestion,\n                     inline_sugg,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1690,12 +1671,10 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                 };\n                 if predicate.is_global() {\n                     cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n-                        lint.build(&format!(\n-                            \"{} bound {} does not depend on any type \\\n-                                or lifetime parameters\",\n-                            predicate_kind_name, predicate\n-                        ))\n-                        .emit();\n+                        lint.build(fluent::lint::builtin_trivial_bounds)\n+                            .set_arg(\"predicate_kind_name\", predicate_kind_name)\n+                            .set_arg(\"predicate\", predicate)\n+                            .emit();\n                     });\n                 }\n             }\n@@ -1796,8 +1775,8 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         };\n \n         if let Some((start, end, join)) = endpoints {\n-            let msg = \"`...` range patterns are deprecated\";\n-            let suggestion = \"use `..=` for an inclusive range\";\n+            let msg = fluent::lint::builtin_ellipsis_inclusive_range_patterns;\n+            let suggestion = fluent::lint::suggestion;\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n                 let end = expr_to_string(&end);\n@@ -1806,8 +1785,11 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                     None => format!(\"&(..={})\", end),\n                 };\n                 if join.edition() >= Edition::Edition2021 {\n-                    let mut err =\n-                        rustc_errors::struct_span_err!(cx.sess(), pat.span, E0783, \"{}\", msg,);\n+                    let mut err = cx.sess().struct_span_err_with_code(\n+                        pat.span,\n+                        msg,\n+                        rustc_errors::error_code!(E0783),\n+                    );\n                     err.span_suggestion(\n                         pat.span,\n                         suggestion,\n@@ -1830,8 +1812,11 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n             } else {\n                 let replace = \"..=\";\n                 if join.edition() >= Edition::Edition2021 {\n-                    let mut err =\n-                        rustc_errors::struct_span_err!(cx.sess(), pat.span, E0783, \"{}\", msg,);\n+                    let mut err = cx.sess().struct_span_err_with_code(\n+                        pat.span,\n+                        msg,\n+                        rustc_errors::error_code!(E0783),\n+                    );\n                     err.span_suggestion_short(\n                         join,\n                         suggestion,\n@@ -1930,7 +1915,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n-                lint.build(\"cannot test inner items\").emit();\n+                lint.build(fluent::lint::builtin_unnameable_test_items).emit();\n             });\n         }\n     }\n@@ -2048,10 +2033,12 @@ impl KeywordIdents {\n         }\n \n         cx.struct_span_lint(KEYWORD_IDENTS, ident.span, |lint| {\n-            lint.build(&format!(\"`{}` is a keyword in the {} edition\", ident, next_edition))\n+            lint.build(fluent::lint::builtin_keyword_idents)\n+                .set_arg(\"kw\", ident.clone())\n+                .set_arg(\"next\", next_edition)\n                 .span_suggestion(\n                     ident.span,\n-                    \"you can use a raw identifier to stay compatible\",\n+                    fluent::lint::suggestion,\n                     format!(\"r#{}\", ident),\n                     Applicability::MachineApplicable,\n                 )\n@@ -2301,13 +2288,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n \n             if !lint_spans.is_empty() {\n                 cx.struct_span_lint(EXPLICIT_OUTLIVES_REQUIREMENTS, lint_spans.clone(), |lint| {\n-                    lint.build(\"outlives requirements can be inferred\")\n+                    lint.build(fluent::lint::builtin_explicit_outlives)\n+                        .set_arg(\"count\", bound_count)\n                         .multipart_suggestion(\n-                            if bound_count == 1 {\n-                                \"remove this bound\"\n-                            } else {\n-                                \"remove these bounds\"\n-                            },\n+                            fluent::lint::suggestion,\n                             lint_spans\n                                 .into_iter()\n                                 .map(|span| (span, String::new()))\n@@ -2363,23 +2347,14 @@ impl EarlyLintPass for IncompleteFeatures {\n             .filter(|(&name, _)| features.incomplete(name))\n             .for_each(|(&name, &span)| {\n                 cx.struct_span_lint(INCOMPLETE_FEATURES, span, |lint| {\n-                    let mut builder = lint.build(&format!(\n-                        \"the feature `{}` is incomplete and may not be safe to use \\\n-                         and/or cause compiler crashes\",\n-                        name,\n-                    ));\n+                    let mut builder = lint.build(fluent::lint::builtin_incomplete_features);\n+                    builder.set_arg(\"name\", name);\n                     if let Some(n) = rustc_feature::find_feature_issue(name, GateIssue::Language) {\n-                        builder.note(&format!(\n-                            \"see issue #{} <https://github.com/rust-lang/rust/issues/{}> \\\n-                             for more information\",\n-                            n, n,\n-                        ));\n+                        builder.set_arg(\"n\", n);\n+                        builder.note(fluent::lint::note);\n                     }\n                     if HAS_MIN_FEATURES.contains(&name) {\n-                        builder.help(&format!(\n-                            \"consider using `min_{}` instead, which is more stable and complete\",\n-                            name,\n-                        ));\n+                        builder.help(fluent::lint::help);\n                     }\n                     builder.emit();\n                 })\n@@ -2620,6 +2595,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             if let Some((msg, span)) =\n                 with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n             {\n+                // FIXME(davidtwco): make translatable\n                 cx.struct_span_lint(INVALID_VALUE, expr.span, |lint| {\n                     let mut err = lint.build(&format!(\n                         \"the type `{}` does not permit {}\",\n@@ -2996,23 +2972,19 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                             let mut found_str = DiagnosticStyledString::new();\n                             found_str.push(this_decl_ty.fn_sig(tcx).to_string(), true);\n \n-                            lint.build(&format!(\n-                                \"`{}` redeclare{} with a different signature\",\n-                                this_fi.ident.name,\n-                                if orig.get_name() == this_fi.ident.name {\n-                                    \"d\".to_string()\n-                                } else {\n-                                    format!(\"s `{}`\", orig.get_name())\n-                                }\n-                            ))\n+                            lint.build(if orig.get_name() == this_fi.ident.name {\n+                                fluent::lint::builtin_clashing_extern_same_name\n+                            } else {\n+                                fluent::lint::builtin_clashing_extern_diff_name\n+                            })\n+                            .set_arg(\"this_fi\", this_fi.ident.name)\n+                            .set_arg(\"orig\", orig.get_name())\n                             .span_label(\n                                 get_relevant_span(orig_fi),\n-                                &format!(\"`{}` previously declared here\", orig.get_name()),\n-                            )\n-                            .span_label(\n-                                get_relevant_span(this_fi),\n-                                \"this signature doesn't match the previous declaration\",\n+                                fluent::lint::previous_decl_label,\n                             )\n+                            .span_label(get_relevant_span(this_fi), fluent::lint::mismatch_label)\n+                            // FIXME(davidtwco): translatable expected/found\n                             .note_expected_found(&\"\", expected_str, &\"\", found_str)\n                             .emit();\n                         },\n@@ -3096,8 +3068,8 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n         if let rustc_hir::ExprKind::Unary(rustc_hir::UnOp::Deref, expr_deref) = expr.kind {\n             if is_null_ptr(cx, expr_deref) {\n                 cx.struct_span_lint(DEREF_NULLPTR, expr.span, |lint| {\n-                    let mut err = lint.build(\"dereferencing a null pointer\");\n-                    err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n+                    let mut err = lint.build(fluent::lint::builtin_deref_nullptr);\n+                    err.span_label(expr.span, fluent::lint::label);\n                     err.emit();\n                 });\n             }\n@@ -3210,9 +3182,7 @@ impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n                             NAMED_ASM_LABELS,\n                             Some(target_spans),\n                             |diag| {\n-                                let mut err =\n-                                    diag.build(\"avoid using named labels in inline assembly\");\n-                                err.emit();\n+                                diag.build(fluent::lint::builtin_asm_labels).emit();\n                             },\n                             BuiltinLintDiagnostics::NamedAsmLabel(\n                                 \"only local labels of the form `<number>:` should be used in inline asm\""}, {"sha": "5d212768d0d8bf68c867fca07b71495867891c50", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,4 +1,5 @@\n use crate::{context::LintContext, LateContext, LateLintPass};\n+use rustc_errors::fluent;\n use rustc_hir as hir;\n use rustc_middle::ty::{fold::TypeFoldable, Ty};\n use rustc_span::{symbol::sym, Span};\n@@ -51,19 +52,9 @@ fn enforce_mem_discriminant(\n     if is_non_enum(ty_param) {\n         cx.struct_span_lint(ENUM_INTRINSICS_NON_ENUMS, expr_span, |builder| {\n             builder\n-                .build(\n-                    \"the return value of `mem::discriminant` is \\\n-                        unspecified when called with a non-enum type\",\n-                )\n-                .span_note(\n-                    args_span,\n-                    &format!(\n-                        \"the argument to `discriminant` should be a \\\n-                            reference to an enum, but it was passed \\\n-                            a reference to a `{}`, which is not an enum.\",\n-                        ty_param,\n-                    ),\n-                )\n+                .build(fluent::lint::enum_intrinsics_mem_discriminant)\n+                .set_arg(\"ty_param\", ty_param)\n+                .span_note(args_span, fluent::lint::note)\n                 .emit();\n         });\n     }\n@@ -74,16 +65,9 @@ fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, sp\n     if is_non_enum(ty_param) {\n         cx.struct_span_lint(ENUM_INTRINSICS_NON_ENUMS, span, |builder| {\n             builder\n-                .build(\n-                    \"the return value of `mem::variant_count` is \\\n-                        unspecified when called with a non-enum type\",\n-                )\n-                .note(&format!(\n-                    \"the type parameter of `variant_count` should \\\n-                            be an enum, but it was instantiated with \\\n-                            the type `{}`, which is not an enum.\",\n-                    ty_param,\n-                ))\n+                .build(fluent::lint::enum_intrinsics_mem_variant)\n+                .set_arg(\"ty_param\", ty_param)\n+                .note(fluent::lint::note)\n                 .emit();\n         });\n     }"}, {"sha": "699e81543188f4f44f5c674f8c228ade46986409", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,4 +1,5 @@\n use crate::builtin;\n+use rustc_errors::fluent;\n use rustc_hir::HirId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::{lint::LintExpectation, ty::TyCtxt};\n@@ -43,13 +44,13 @@ fn emit_unfulfilled_expectation_lint(\n         hir_id,\n         expectation.emission_span,\n         |diag| {\n-            let mut diag = diag.build(\"this lint expectation is unfulfilled\");\n+            let mut diag = diag.build(fluent::lint::expectation);\n             if let Some(rationale) = expectation.reason {\n                 diag.note(rationale.as_str());\n             }\n \n             if expectation.is_unfulfilled_lint_expectations {\n-                diag.note(\"the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\");\n+                diag.note(fluent::lint::note);\n             }\n \n             diag.emit();"}, {"sha": "fe2712525eea5e2c6e3e73e487b2b2feff89ba14", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,7 +1,7 @@\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use ast::util::unicode::{contains_text_flow_control_chars, TEXT_FLOW_CONTROL_CHARS};\n use rustc_ast as ast;\n-use rustc_errors::{Applicability, SuggestionStyle};\n+use rustc_errors::{fluent, Applicability, SuggestionStyle};\n use rustc_span::{BytePos, Span, Symbol};\n \n declare_lint! {\n@@ -61,41 +61,25 @@ impl HiddenUnicodeCodepoints {\n             .collect();\n \n         cx.struct_span_lint(TEXT_DIRECTION_CODEPOINT_IN_LITERAL, span, |lint| {\n-            let mut err = lint.build(&format!(\n-                \"unicode codepoint changing visible direction of text present in {}\",\n-                label\n-            ));\n-            let (an, s) = match spans.len() {\n-                1 => (\"an \", \"\"),\n-                _ => (\"\", \"s\"),\n-            };\n-            err.span_label(\n-                span,\n-                &format!(\n-                    \"this {} contains {}invisible unicode text flow control codepoint{}\",\n-                    label, an, s,\n-                ),\n-            );\n+            let mut err = lint.build(fluent::lint::hidden_unicode_codepoints);\n+            err.set_arg(\"label\", label);\n+            err.set_arg(\"count\", spans.len());\n+            err.span_label(span, fluent::lint::label);\n+            err.note(fluent::lint::note);\n             if point_at_inner_spans {\n                 for (c, span) in &spans {\n                     err.span_label(*span, format!(\"{:?}\", c));\n                 }\n             }\n-            err.note(\n-                \"these kind of unicode codepoints change the way text flows on applications that \\\n-                 support them, but can cause confusion because they change the order of \\\n-                 characters on the screen\",\n-            );\n             if point_at_inner_spans && !spans.is_empty() {\n                 err.multipart_suggestion_with_style(\n-                    \"if their presence wasn't intentional, you can remove them\",\n+                    fluent::lint::suggestion_remove,\n                     spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n                     Applicability::MachineApplicable,\n                     SuggestionStyle::HideCodeAlways,\n                 );\n                 err.multipart_suggestion(\n-                    \"if you want to keep them but make them visible in your source code, you can \\\n-                    escape them\",\n+                    fluent::lint::suggestion_escape,\n                     spans\n                         .into_iter()\n                         .map(|(c, span)| {\n@@ -109,16 +93,16 @@ impl HiddenUnicodeCodepoints {\n                 // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n                 // should do the same here to provide the same good suggestions as we do for\n                 // literals above.\n-                err.note(\"if their presence wasn't intentional, you can remove them\");\n-                err.note(&format!(\n-                    \"if you want to keep them but make them visible in your source code, you can \\\n-                     escape them: {}\",\n+                err.set_arg(\n+                    \"escaped\",\n                     spans\n                         .into_iter()\n-                        .map(|(c, _)| { format!(\"{:?}\", c) })\n+                        .map(|(c, _)| format!(\"{:?}\", c))\n                         .collect::<Vec<String>>()\n                         .join(\", \"),\n-                ));\n+                );\n+                err.note(fluent::lint::suggestion_remove);\n+                err.note(fluent::lint::no_suggestion_note_escape);\n             }\n             err.emit();\n         });"}, {"sha": "5bcf9390c076a1adb41cf4025498a86c2d3190c6", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -3,7 +3,7 @@\n \n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_errors::Applicability;\n+use rustc_errors::{fluent, Applicability};\n use rustc_hir::def::Res;\n use rustc_hir::{def_id::DefId, Expr, ExprKind, GenericArg, PatKind, Path, PathSegment, QPath};\n use rustc_hir::{HirId, Impl, Item, ItemKind, Node, Pat, Ty, TyKind};\n@@ -36,13 +36,10 @@ impl LateLintPass<'_> for DefaultHashTypes {\n             _ => return,\n         };\n         cx.struct_span_lint(DEFAULT_HASH_TYPES, path.span, |lint| {\n-            let msg = format!(\n-                \"prefer `{}` over `{}`, it has better performance\",\n-                replace,\n-                cx.tcx.item_name(def_id)\n-            );\n-            lint.build(&msg)\n-                .note(&format!(\"a `use rustc_data_structures::fx::{}` may be necessary\", replace))\n+            lint.build(fluent::lint::default_hash_types)\n+                .set_arg(\"preferred\", replace)\n+                .set_arg(\"used\", cx.tcx.item_name(def_id))\n+                .note(fluent::lint::note)\n                 .emit();\n         });\n     }\n@@ -99,12 +96,9 @@ impl LateLintPass<'_> for QueryStability {\n             let def_id = instance.def_id();\n             if cx.tcx.has_attr(def_id, sym::rustc_lint_query_instability) {\n                 cx.struct_span_lint(POTENTIAL_QUERY_INSTABILITY, span, |lint| {\n-                    let msg = format!(\n-                        \"using `{}` can result in unstable query results\",\n-                        cx.tcx.item_name(def_id)\n-                    );\n-                    lint.build(&msg)\n-                        .note(\"if you believe this case to be fine, allow this lint and add a comment explaining your rationale\")\n+                    lint.build(fluent::lint::query_instability)\n+                        .set_arg(\"query\", cx.tcx.item_name(def_id))\n+                        .note(fluent::lint::note)\n                         .emit();\n                 })\n             }\n@@ -146,10 +140,10 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                 segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n             );\n             cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n-                lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                lint.build(fluent::lint::tykind_kind)\n                     .span_suggestion(\n                         span,\n-                        \"try using `ty::<kind>` directly\",\n+                        fluent::lint::suggestion,\n                         \"ty\",\n                         Applicability::MaybeIncorrect, // ty maybe needs an import\n                     )\n@@ -175,10 +169,10 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                                 if let QPath::TypeRelative(qpath_ty, ..) = qpath\n                                     && qpath_ty.hir_id == ty.hir_id\n                                 {\n-                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                                    lint.build(fluent::lint::tykind_kind)\n                                         .span_suggestion(\n                                             path.span,\n-                                            \"try using `ty::<kind>` directly\",\n+                                            fluent::lint::suggestion,\n                                             \"ty\",\n                                             Applicability::MaybeIncorrect, // ty maybe needs an import\n                                         )\n@@ -193,10 +187,10 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                                 if let QPath::TypeRelative(qpath_ty, ..) = qpath\n                                     && qpath_ty.hir_id == ty.hir_id\n                                 {\n-                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                                    lint.build(fluent::lint::tykind_kind)\n                                         .span_suggestion(\n                                             path.span,\n-                                            \"try using `ty::<kind>` directly\",\n+                                            fluent::lint::suggestion,\n                                             \"ty\",\n                                             Applicability::MaybeIncorrect, // ty maybe needs an import\n                                         )\n@@ -213,10 +207,10 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                                 if let QPath::TypeRelative(qpath_ty, ..) = qpath\n                                     && qpath_ty.hir_id == ty.hir_id\n                                 {\n-                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                                    lint.build(fluent::lint::tykind_kind)\n                                         .span_suggestion(\n                                             path.span,\n-                                            \"try using `ty::<kind>` directly\",\n+                                            fluent::lint::suggestion,\n                                             \"ty\",\n                                             Applicability::MaybeIncorrect, // ty maybe needs an import\n                                         )\n@@ -226,15 +220,16 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                             }\n                             _ => {}\n                         }\n-                        lint.build(\"usage of `ty::TyKind`\").help(\"try using `Ty` instead\").emit();\n+                        lint.build(fluent::lint::tykind).help(fluent::lint::help).emit();\n                     })\n                 } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n                     if path.segments.len() > 1 {\n                         cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n-                            lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                            lint.build(fluent::lint::ty_qualified)\n+                                .set_arg(\"ty\", t.clone())\n                                 .span_suggestion(\n                                     path.span,\n-                                    \"try importing it and using it unqualified\",\n+                                    fluent::lint::suggestion,\n                                     t,\n                                     // The import probably needs to be changed\n                                     Applicability::MaybeIncorrect,\n@@ -330,8 +325,8 @@ impl EarlyLintPass for LintPassImpl {\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n                             |lint| {\n-                                lint.build(\"implementing `LintPass` by hand\")\n-                                    .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                                lint.build(fluent::lint::lintpass_by_hand)\n+                                    .help(fluent::lint::help)\n                                     .emit();\n                             },\n                         )\n@@ -371,13 +366,10 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n                             return;\n                         }\n                         cx.struct_span_lint(EXISTING_DOC_KEYWORD, attr.span, |lint| {\n-                            lint.build(&format!(\n-                                \"Found non-existing keyword `{}` used in \\\n-                                     `#[doc(keyword = \\\"...\\\")]`\",\n-                                v,\n-                            ))\n-                            .help(\"only existing keywords are allowed in core/std\")\n-                            .emit();\n+                            lint.build(fluent::lint::non_existant_doc_keyword)\n+                                .set_arg(\"keyword\", v)\n+                                .help(fluent::lint::help)\n+                                .emit();\n                         });\n                     }\n                 }\n@@ -431,8 +423,7 @@ impl LateLintPass<'_> for Diagnostics {\n         debug!(?found_impl);\n         if !found_impl {\n             cx.struct_span_lint(DIAGNOSTIC_OUTSIDE_OF_IMPL, span, |lint| {\n-                lint.build(\"diagnostics should only be created in `SessionDiagnostic`/`AddSubdiagnostic` impls\")\n-                    .emit();\n+                lint.build(fluent::lint::diag_out_of_impl).emit();\n             })\n         }\n \n@@ -450,7 +441,7 @@ impl LateLintPass<'_> for Diagnostics {\n         debug!(?found_diagnostic_message);\n         if !found_diagnostic_message {\n             cx.struct_span_lint(UNTRANSLATABLE_DIAGNOSTIC, span, |lint| {\n-                lint.build(\"diagnostics should be created using translatable messages\").emit();\n+                lint.build(fluent::lint::untranslatable_diag).emit();\n             })\n         }\n     }"}, {"sha": "bf4a726b061881b86cc44147f6581241cf343734", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -521,7 +521,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                             src,\n                             Some(sp.into()),\n                             |lint| {\n-                                let mut err = lint.build(&msg);\n+                                let mut err = lint.build(msg);\n                                 if let Some(new_name) = &renamed {\n                                     err.span_suggestion(\n                                         sp,\n@@ -548,7 +548,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                             } else {\n                                 name.to_string()\n                             };\n-                            let mut db = lint.build(&format!(\"unknown lint: `{}`\", name));\n+                            let mut db = lint.build(format!(\"unknown lint: `{}`\", name));\n                             if let Some(suggestion) = suggestion {\n                                 db.span_suggestion(\n                                     sp,"}, {"sha": "ff5a01749c19e66b5246c514c6a71f2307fe8826", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,6 +1,7 @@\n use crate::LateContext;\n use crate::LateLintPass;\n use crate::LintContext;\n+use rustc_errors::fluent;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_middle::ty;\n use rustc_span::{symbol::sym, ExpnKind, Span};\n@@ -88,16 +89,12 @@ fn lint_cstring_as_ptr(\n             if let ty::Adt(adt, _) = substs.type_at(0).kind() {\n                 if cx.tcx.is_diagnostic_item(sym::cstring_type, adt.did()) {\n                     cx.struct_span_lint(TEMPORARY_CSTRING_AS_PTR, as_ptr_span, |diag| {\n-                        let mut diag = diag\n-                            .build(\"getting the inner pointer of a temporary `CString`\");\n-                        diag.span_label(as_ptr_span, \"this pointer will be invalid\");\n-                        diag.span_label(\n-                            unwrap.span,\n-                            \"this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\",\n-                        );\n-                        diag.note(\"pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\");\n-                        diag.help(\"for more information, see https://doc.rust-lang.org/reference/destructors.html\");\n-                        diag.emit();\n+                        diag.build(fluent::lint::cstring_ptr)\n+                            .span_label(as_ptr_span, fluent::lint::as_ptr_label)\n+                            .span_label(unwrap.span, fluent::lint::unwrap_label)\n+                            .note(fluent::lint::note)\n+                            .help(fluent::lint::help)\n+                            .emit();\n                     });\n                 }\n             }"}, {"sha": "764003e61a6dfb0991ee2c5c4c143417015fc0df", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,6 +1,7 @@\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::fluent;\n use rustc_span::symbol::Symbol;\n \n declare_lint! {\n@@ -180,13 +181,13 @@ impl EarlyLintPass for NonAsciiIdents {\n             }\n             has_non_ascii_idents = true;\n             cx.struct_span_lint(NON_ASCII_IDENTS, sp, |lint| {\n-                lint.build(\"identifier contains non-ASCII characters\").emit();\n+                lint.build(fluent::lint::identifier_non_ascii_char).emit();\n             });\n             if check_uncommon_codepoints\n                 && !symbol_str.chars().all(GeneralSecurityProfile::identifier_allowed)\n             {\n                 cx.struct_span_lint(UNCOMMON_CODEPOINTS, sp, |lint| {\n-                    lint.build(\"identifier contains uncommon Unicode codepoints\").emit();\n+                    lint.build(fluent::lint::identifier_uncommon_codepoints).emit();\n                 })\n             }\n         }\n@@ -216,15 +217,11 @@ impl EarlyLintPass for NonAsciiIdents {\n                     .and_modify(|(existing_symbol, existing_span, existing_is_ascii)| {\n                         if !*existing_is_ascii || !is_ascii {\n                             cx.struct_span_lint(CONFUSABLE_IDENTS, sp, |lint| {\n-                                lint.build(&format!(\n-                                    \"identifier pair considered confusable between `{}` and `{}`\",\n-                                    existing_symbol, symbol\n-                                ))\n-                                .span_label(\n-                                    *existing_span,\n-                                    \"this is where the previous identifier occurred\",\n-                                )\n-                                .emit();\n+                                lint.build(fluent::lint::confusable_identifier_pair)\n+                                    .set_arg(\"existing_sym\", *existing_symbol)\n+                                    .set_arg(\"sym\", symbol)\n+                                    .span_label(*existing_span, fluent::lint::label)\n+                                    .emit();\n                             });\n                         }\n                         if *existing_is_ascii && !is_ascii {\n@@ -326,18 +323,20 @@ impl EarlyLintPass for NonAsciiIdents {\n \n                 for ((sp, ch_list), script_set) in lint_reports {\n                     cx.struct_span_lint(MIXED_SCRIPT_CONFUSABLES, sp, |lint| {\n-                        let message = format!(\n-                            \"the usage of Script Group `{}` in this crate consists solely of mixed script confusables\",\n-                            script_set);\n-                        let mut note = \"the usage includes \".to_string();\n+                        let mut includes = String::new();\n                         for (idx, ch) in ch_list.into_iter().enumerate() {\n                             if idx != 0 {\n-                                note += \", \";\n+                                includes += \", \";\n                             }\n                             let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n-                            note += &char_info;\n+                            includes += &char_info;\n                         }\n-                        lint.build(&message).note(&note).note(\"please recheck to make sure their usages are indeed what you want\").emit();\n+                        lint.build(fluent::lint::mixed_script_confusables)\n+                            .set_arg(\"set\", script_set.to_string())\n+                            .set_arg(\"includes\", includes)\n+                            .note(fluent::lint::includes_note)\n+                            .note(fluent::lint::note)\n+                            .emit();\n                     });\n                 }\n             }"}, {"sha": "cdad2d2e8f93e0d4bb18fa0c53032ef7bb085bfb", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,6 +1,6 @@\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_errors::{pluralize, Applicability};\n+use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::lint::in_external_macro;\n@@ -120,20 +120,21 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n     }\n \n     cx.struct_span_lint(NON_FMT_PANICS, arg_span, |lint| {\n-        let mut l = lint.build(\"panic message is not a string literal\");\n-        l.note(&format!(\"this usage of {}!() is deprecated; it will be a hard error in Rust 2021\", symbol));\n-        l.note(\"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\");\n+        let mut l = lint.build(fluent::lint::non_fmt_panic);\n+        l.set_arg(\"name\", symbol);\n+        l.note(fluent::lint::note);\n+        l.note(fluent::lint::more_info_note);\n         if !is_arg_inside_call(arg_span, span) {\n             // No clue where this argument is coming from.\n             l.emit();\n             return;\n         }\n         if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n-            l.note(format!(\"the {}!() macro supports formatting, so there's no need for the format!() macro here\", symbol).as_str());\n+            l.note(fluent::lint::supports_fmt_note);\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n                 l.multipart_suggestion(\n-                    \"remove the `format!(..)` macro call\",\n+                    fluent::lint::supports_fmt_suggestion,\n                     vec![\n                         (arg_span.until(open.shrink_to_hi()), \"\".into()),\n                         (close.until(arg_span.shrink_to_hi()), \"\".into()),\n@@ -153,12 +154,18 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             );\n \n             let (suggest_display, suggest_debug) = cx.tcx.infer_ctxt().enter(|infcx| {\n-                let display = is_str || cx.tcx.get_diagnostic_item(sym::Display).map(|t| {\n-                    infcx.type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env).may_apply()\n-                }) == Some(true);\n-                let debug = !display && cx.tcx.get_diagnostic_item(sym::Debug).map(|t| {\n-                    infcx.type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env).may_apply()\n-                }) == Some(true);\n+                let display = is_str\n+                    || cx.tcx.get_diagnostic_item(sym::Display).map(|t| {\n+                        infcx\n+                            .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n+                            .may_apply()\n+                    }) == Some(true);\n+                let debug = !display\n+                    && cx.tcx.get_diagnostic_item(sym::Debug).map(|t| {\n+                        infcx\n+                            .type_implements_trait(t, ty, InternalSubsts::empty(), cx.param_env)\n+                            .may_apply()\n+                    }) == Some(true);\n                 (display, debug)\n             });\n \n@@ -175,33 +182,25 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             if suggest_display {\n                 l.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    \"add a \\\"{}\\\" format string to Display the message\",\n+                    fluent::lint::display_suggestion,\n                     \"\\\"{}\\\", \",\n                     fmt_applicability,\n                 );\n             } else if suggest_debug {\n+                l.set_arg(\"ty\", ty);\n                 l.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    &format!(\n-                        \"add a \\\"{{:?}}\\\" format string to use the Debug implementation of `{}`\",\n-                        ty,\n-                    ),\n+                    fluent::lint::debug_suggestion,\n                     \"\\\"{:?}\\\", \",\n                     fmt_applicability,\n                 );\n             }\n \n             if suggest_panic_any {\n                 if let Some((open, close, del)) = find_delimiters(cx, span) {\n+                    l.set_arg(\"already_suggested\", suggest_display || suggest_debug);\n                     l.multipart_suggestion(\n-                        &format!(\n-                            \"{}use std::panic::panic_any instead\",\n-                            if suggest_display || suggest_debug {\n-                                \"or \"\n-                            } else {\n-                                \"\"\n-                            },\n-                        ),\n+                        fluent::lint::panic_suggestion,\n                         if del == '(' {\n                             vec![(span.until(open), \"std::panic::panic_any\".into())]\n                         } else {\n@@ -260,21 +259,19 @@ fn check_panic_str<'tcx>(\n                 .collect(),\n         };\n         cx.struct_span_lint(NON_FMT_PANICS, arg_spans, |lint| {\n-            let mut l = lint.build(match n_arguments {\n-                1 => \"panic message contains an unused formatting placeholder\",\n-                _ => \"panic message contains unused formatting placeholders\",\n-            });\n-            l.note(\"this message is not used as a format string when given without arguments, but will be in Rust 2021\");\n+            let mut l = lint.build(fluent::lint::non_fmt_panic_unused);\n+            l.set_arg(\"count\", n_arguments);\n+            l.note(fluent::lint::note);\n             if is_arg_inside_call(arg.span, span) {\n                 l.span_suggestion(\n                     arg.span.shrink_to_hi(),\n-                    &format!(\"add the missing argument{}\", pluralize!(n_arguments)),\n+                    fluent::lint::add_args_suggestion,\n                     \", ...\",\n                     Applicability::HasPlaceholders,\n                 );\n                 l.span_suggestion(\n                     arg.span.shrink_to_lo(),\n-                    \"or add a \\\"{}\\\" format string to use the message literally\",\n+                    fluent::lint::add_fmt_suggestion,\n                     \"\\\"{}\\\", \",\n                     Applicability::MachineApplicable,\n                 );\n@@ -289,17 +286,15 @@ fn check_panic_str<'tcx>(\n                     .map(|(i, _)| fmt_span.from_inner(InnerSpan { start: i, end: i + 1 }))\n                     .collect()\n             });\n-        let msg = match &brace_spans {\n-            Some(v) if v.len() == 1 => \"panic message contains a brace\",\n-            _ => \"panic message contains braces\",\n-        };\n+        let count = brace_spans.as_ref().map(|v| v.len()).unwrap_or(/* any number >1 */ 2);\n         cx.struct_span_lint(NON_FMT_PANICS, brace_spans.unwrap_or_else(|| vec![span]), |lint| {\n-            let mut l = lint.build(msg);\n-            l.note(\"this message is not used as a format string, but will be in Rust 2021\");\n+            let mut l = lint.build(fluent::lint::non_fmt_panic_braces);\n+            l.set_arg(\"count\", count);\n+            l.note(fluent::lint::note);\n             if is_arg_inside_call(arg.span, span) {\n                 l.span_suggestion(\n                     arg.span.shrink_to_lo(),\n-                    \"add a \\\"{}\\\" format string to use the message literally\",\n+                    fluent::lint::suggestion,\n                     \"\\\"{}\\\", \",\n                     Applicability::MachineApplicable,\n                 );"}, {"sha": "33ac2ed02aa00c0ef89c222247d89a917f08ef18", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,7 +1,7 @@\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_errors::Applicability;\n+use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::FnKind;\n@@ -137,22 +137,23 @@ impl NonCamelCaseTypes {\n \n         if !is_camel_case(name) {\n             cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, |lint| {\n-                let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n-                let mut err = lint.build(&msg);\n+                let mut err = lint.build(fluent::lint::non_camel_case_type);\n                 let cc = to_camel_case(name);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Lowercase Letter\".\n                 if *name != cc {\n                     err.span_suggestion(\n                         ident.span,\n-                        \"convert the identifier to upper camel case\",\n+                        fluent::lint::suggestion,\n                         to_camel_case(name),\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    err.span_label(ident.span, \"should have an UpperCamelCase name\");\n+                    err.span_label(ident.span, fluent::lint::label);\n                 }\n \n+                err.set_arg(\"sort\", sort);\n+                err.set_arg(\"name\", name);\n                 err.emit();\n             })\n         }\n@@ -281,11 +282,10 @@ impl NonSnakeCase {\n         if !is_snake_case(name) {\n             cx.struct_span_lint(NON_SNAKE_CASE, ident.span, |lint| {\n                 let sc = NonSnakeCase::to_snake_case(name);\n-                let msg = format!(\"{} `{}` should have a snake case name\", sort, name);\n-                let mut err = lint.build(&msg);\n+                let mut err = lint.build(fluent::lint::non_snake_case);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Uppercase Letter\".\n-                if *name != sc {\n+                if name != sc {\n                     // We have a valid span in almost all cases, but we don't have one when linting a crate\n                     // name provided via the command line.\n                     if !ident.span.is_dummy() {\n@@ -295,13 +295,13 @@ impl NonSnakeCase {\n                             // Instead, recommend renaming the identifier entirely or, if permitted,\n                             // escaping it to create a raw identifier.\n                             if sc_ident.name.can_be_raw() {\n-                                (\"rename the identifier or convert it to a snake case raw identifier\", sc_ident.to_string())\n+                                (fluent::lint::rename_or_convert_suggestion, sc_ident.to_string())\n                             } else {\n-                                err.note(&format!(\"`{}` cannot be used as a raw identifier\", sc));\n-                                (\"rename the identifier\", String::new())\n+                                err.note(fluent::lint::cannot_convert_note);\n+                                (fluent::lint::rename_suggestion, String::new())\n                             }\n                         } else {\n-                            (\"convert the identifier to snake case\", sc)\n+                            (fluent::lint::convert_suggestion, sc.clone())\n                         };\n \n                         err.span_suggestion(\n@@ -311,12 +311,15 @@ impl NonSnakeCase {\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        err.help(&format!(\"convert the identifier to snake case: `{}`\", sc));\n+                        err.help(fluent::lint::help);\n                     }\n                 } else {\n-                    err.span_label(ident.span, \"should have a snake_case name\");\n+                    err.span_label(ident.span, fluent::lint::label);\n                 }\n \n+                err.set_arg(\"sort\", sort);\n+                err.set_arg(\"name\", name);\n+                err.set_arg(\"sc\", sc);\n                 err.emit();\n             });\n         }\n@@ -488,21 +491,22 @@ impl NonUpperCaseGlobals {\n         if name.chars().any(|c| c.is_lowercase()) {\n             cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, |lint| {\n                 let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n-                let mut err =\n-                    lint.build(&format!(\"{} `{}` should have an upper case name\", sort, name));\n+                let mut err = lint.build(fluent::lint::non_upper_case_global);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Lowercase Letter\".\n                 if *name != uc {\n                     err.span_suggestion(\n                         ident.span,\n-                        \"convert the identifier to upper case\",\n+                        fluent::lint::suggestion,\n                         uc,\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    err.span_label(ident.span, \"should have an UPPER_CASE name\");\n+                    err.span_label(ident.span, fluent::lint::label);\n                 }\n \n+                err.set_arg(\"sort\", sort);\n+                err.set_arg(\"name\", name);\n                 err.emit();\n             })\n         }"}, {"sha": "2e847c8b89c56669827e72fb5530e6422da3279d", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -2,6 +2,7 @@ use crate::context::LintContext;\n use crate::rustc_middle::ty::TypeFoldable;\n use crate::LateContext;\n use crate::LateLintPass;\n+use rustc_errors::fluent;\n use rustc_hir::def::DefKind;\n use rustc_hir::{Expr, ExprKind};\n use rustc_middle::ty;\n@@ -80,7 +81,6 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         ) {\n             return;\n         }\n-        let method = &call.ident.name;\n         let receiver = &elements[0];\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n         let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n@@ -90,19 +90,14 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n             return;\n         }\n         let expr_span = expr.span;\n-        let note = format!(\n-            \"the type `{:?}` which `{}` is being called on is the same as \\\n-             the type returned from `{}`, so the method call does not do \\\n-             anything and can be removed\",\n-            receiver_ty, method, method,\n-        );\n-\n         let span = expr_span.with_lo(receiver.span.hi());\n         cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n-            let method = &call.ident.name;\n-            let message =\n-                format!(\"call to `.{}()` on a reference in this situation does nothing\", &method,);\n-            lint.build(&message).span_label(span, \"unnecessary method call\").note(&note).emit();\n+            lint.build(fluent::lint::noop_method_call)\n+                .set_arg(\"method\", call.ident.name)\n+                .set_arg(\"receiver_ty\", receiver_ty)\n+                .span_label(span, fluent::lint::label)\n+                .note(fluent::lint::note)\n+                .emit();\n         });\n     }\n }"}, {"sha": "af5e5faf1f568aef60d44de98c57acafe0b69615", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,5 +1,5 @@\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::Applicability;\n+use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::{GenericArg, PathSegment, QPath, TyKind};\n@@ -30,10 +30,11 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n                 }\n                 if let Some(t) = path_for_pass_by_value(cx, &inner_ty) {\n                     cx.struct_span_lint(PASS_BY_VALUE, ty.span, |lint| {\n-                        lint.build(&format!(\"passing `{}` by reference\", t))\n+                        lint.build(fluent::lint::pass_by_value)\n+                            .set_arg(\"ty\", t.clone())\n                             .span_suggestion(\n                                 ty.span,\n-                                \"try passing by value\",\n+                                fluent::lint::suggestion,\n                                 t,\n                                 // Changing type of function argument\n                                 Applicability::MaybeIncorrect,"}, {"sha": "26f41345383f91bad2218eca90e7048bd5385a51", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,6 +1,6 @@\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast::{Block, StmtKind};\n-use rustc_errors::Applicability;\n+use rustc_errors::{fluent, Applicability};\n use rustc_span::Span;\n \n declare_lint! {\n@@ -49,12 +49,10 @@ fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, boo\n         }\n \n         cx.struct_span_lint(REDUNDANT_SEMICOLONS, span, |lint| {\n-            let (msg, rem) = if multiple {\n-                (\"unnecessary trailing semicolons\", \"remove these semicolons\")\n-            } else {\n-                (\"unnecessary trailing semicolon\", \"remove this semicolon\")\n-            };\n-            lint.build(msg).span_suggestion(span, rem, \"\", Applicability::MaybeIncorrect).emit();\n+            lint.build(fluent::lint::redundant_semicolons)\n+                .set_arg(\"multiple\", multiple)\n+                .span_suggestion(span, fluent::lint::suggestion, \"\", Applicability::MaybeIncorrect)\n+                .emit();\n         });\n     }\n }"}, {"sha": "df1587c5948f58d4cf984e48e852f2cb65f3bc22", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,6 +1,7 @@\n use crate::LateContext;\n use crate::LateLintPass;\n use crate::LintContext;\n+use rustc_errors::fluent;\n use rustc_hir as hir;\n use rustc_span::symbol::sym;\n \n@@ -103,13 +104,10 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                     let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n                         return\n                     };\n-                    let msg = format!(\n-                        \"bounds on `{}` are most likely incorrect, consider instead \\\n-                         using `{}` to detect whether a type can be trivially dropped\",\n-                        predicate,\n-                        cx.tcx.def_path_str(needs_drop)\n-                    );\n-                    lint.build(&msg).emit();\n+                    lint.build(fluent::lint::drop_trait_constraints)\n+                        .set_arg(\"predicate\", predicate)\n+                        .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n+                        .emit();\n                 });\n             }\n         }\n@@ -126,12 +124,9 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                     let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n                         return\n                     };\n-                    let msg = format!(\n-                        \"types that do not implement `Drop` can still have drop glue, consider \\\n-                        instead using `{}` to detect whether a type is trivially dropped\",\n-                        cx.tcx.def_path_str(needs_drop)\n-                    );\n-                    lint.build(&msg).emit();\n+                    lint.build(fluent::lint::drop_glue)\n+                        .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n+                        .emit();\n                 });\n             }\n         }"}, {"sha": "0056872ee44c30e27cebaffa46fc80a081991329", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 135, "deletions": 134, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -2,7 +2,7 @@ use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::Applicability;\n+use rustc_errors::{fluent, Applicability, DiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n@@ -139,7 +139,8 @@ fn lint_overflowing_range_endpoint<'tcx>(\n         // overflowing and only by 1.\n         if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n             cx.struct_span_lint(OVERFLOWING_LITERALS, parent_expr.span, |lint| {\n-                let mut err = lint.build(&format!(\"range endpoint is out of range for `{}`\", ty));\n+                let mut err = lint.build(fluent::lint::range_endpoint_out_of_range);\n+                err.set_arg(\"ty\", ty);\n                 if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n                     use ast::{LitIntType, LitKind};\n                     // We need to preserve the literal's suffix,\n@@ -153,7 +154,7 @@ fn lint_overflowing_range_endpoint<'tcx>(\n                     let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n                     err.span_suggestion(\n                         parent_expr.span,\n-                        \"use an inclusive range instead\",\n+                        fluent::lint::suggestion,\n                         suggestion,\n                         Applicability::MachineApplicable,\n                     );\n@@ -229,38 +230,35 @@ fn report_bin_hex_error(\n                 (t.name_str(), actually.to_string())\n             }\n         };\n-        let mut err = lint.build(&format!(\"literal out of range for `{}`\", t));\n+        let mut err = lint.build(fluent::lint::overflowing_bin_hex);\n         if negative {\n             // If the value is negative,\n             // emits a note about the value itself, apart from the literal.\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n-                 the type `{}`\",\n-                repr_str, val, t\n-            ));\n-            err.note(&format!(\"and the value `-{}` will become `{}{}`\", repr_str, actually, t));\n+            err.note(fluent::lint::negative_note);\n+            err.note(fluent::lint::negative_becomes_note);\n         } else {\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n-                 the type `{}` and will become `{}{}`\",\n-                repr_str, val, t, actually, t\n-            ));\n+            err.note(fluent::lint::positive_note);\n         }\n         if let Some(sugg_ty) =\n             get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n         {\n+            err.set_arg(\"suggestion_ty\", sugg_ty);\n             if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                 let (sans_suffix, _) = repr_str.split_at(pos);\n                 err.span_suggestion(\n                     expr.span,\n-                    &format!(\"consider using the type `{}` instead\", sugg_ty),\n+                    fluent::lint::suggestion,\n                     format!(\"{}{}\", sans_suffix, sugg_ty),\n                     Applicability::MachineApplicable,\n                 );\n             } else {\n-                err.help(&format!(\"consider using the type `{}` instead\", sugg_ty));\n+                err.help(fluent::lint::help);\n             }\n         }\n+        err.set_arg(\"ty\", t);\n+        err.set_arg(\"lit\", repr_str);\n+        err.set_arg(\"dec\", val);\n+        err.set_arg(\"actually\", actually);\n         err.emit();\n     });\n }\n@@ -353,21 +351,23 @@ fn lint_int_literal<'tcx>(\n         }\n \n         cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-            let mut err = lint.build(&format!(\"literal out of range for `{}`\", t.name_str()));\n-            err.note(&format!(\n-                \"the literal `{}` does not fit into the type `{}` whose range is `{}..={}`\",\n+            let mut err = lint.build(fluent::lint::overflowing_int);\n+            err.set_arg(\"ty\", t.name_str());\n+            err.set_arg(\n+                \"lit\",\n                 cx.sess()\n                     .source_map()\n                     .span_to_snippet(lit.span)\n                     .expect(\"must get snippet from literal\"),\n-                t.name_str(),\n-                min,\n-                max,\n-            ));\n+            );\n+            err.set_arg(\"min\", min);\n+            err.set_arg(\"max\", max);\n+            err.note(fluent::lint::note);\n             if let Some(sugg_ty) =\n                 get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n             {\n-                err.help(&format!(\"consider using the type `{}` instead\", sugg_ty));\n+                err.set_arg(\"suggestion_ty\", sugg_ty);\n+                err.help(fluent::lint::help);\n             }\n             err.emit();\n         });\n@@ -395,10 +395,10 @@ fn lint_uint_literal<'tcx>(\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.typeck_results().expr_ty(par_e).kind() {\n                         cx.struct_span_lint(OVERFLOWING_LITERALS, par_e.span, |lint| {\n-                            lint.build(\"only `u8` can be cast into `char`\")\n+                            lint.build(fluent::lint::only_cast_u8_to_char)\n                                 .span_suggestion(\n                                     par_e.span,\n-                                    \"use a `char` literal instead\",\n+                                    fluent::lint::suggestion,\n                                     format!(\"'\\\\u{{{:X}}}'\", lit_val),\n                                     Applicability::MachineApplicable,\n                                 )\n@@ -429,17 +429,18 @@ fn lint_uint_literal<'tcx>(\n             return;\n         }\n         cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-            lint.build(&format!(\"literal out of range for `{}`\", t.name_str()))\n-                .note(&format!(\n-                    \"the literal `{}` does not fit into the type `{}` whose range is `{}..={}`\",\n+            lint.build(fluent::lint::overflowing_uint)\n+                .set_arg(\"ty\", t.name_str())\n+                .set_arg(\n+                    \"lit\",\n                     cx.sess()\n                         .source_map()\n                         .span_to_snippet(lit.span)\n                         .expect(\"must get snippet from literal\"),\n-                    t.name_str(),\n-                    min,\n-                    max,\n-                ))\n+                )\n+                .set_arg(\"min\", min)\n+                .set_arg(\"max\", max)\n+                .note(fluent::lint::note)\n                 .emit();\n         });\n     }\n@@ -471,16 +472,16 @@ fn lint_literal<'tcx>(\n             };\n             if is_infinite == Ok(true) {\n                 cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n-                    lint.build(&format!(\"literal out of range for `{}`\", t.name_str()))\n-                        .note(&format!(\n-                            \"the literal `{}` does not fit into the type `{}` and will be converted to `{}::INFINITY`\",\n+                    lint.build(fluent::lint::overflowing_literal)\n+                        .set_arg(\"ty\", t.name_str())\n+                        .set_arg(\n+                            \"lit\",\n                             cx.sess()\n                                 .source_map()\n                                 .span_to_snippet(lit.span)\n                                 .expect(\"must get snippet from literal\"),\n-                            t.name_str(),\n-                            t.name_str(),\n-                        ))\n+                        )\n+                        .note(fluent::lint::note)\n                         .emit();\n                 });\n             }\n@@ -501,7 +502,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n                     cx.struct_span_lint(UNUSED_COMPARISONS, e.span, |lint| {\n-                        lint.build(\"comparison is useless due to type limits\").emit();\n+                        lint.build(fluent::lint::unused_comparisons).emit();\n                     });\n                 }\n             }\n@@ -663,7 +664,7 @@ struct ImproperCTypesVisitor<'a, 'tcx> {\n enum FfiResult<'tcx> {\n     FfiSafe,\n     FfiPhantom(Ty<'tcx>),\n-    FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n+    FfiUnsafe { ty: Ty<'tcx>, reason: DiagnosticMessage, help: Option<DiagnosticMessage> },\n }\n \n pub(crate) fn nonnull_optimization_guaranteed<'tcx>(\n@@ -823,8 +824,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             self.emit_ffi_unsafe_type_lint(\n                 ty,\n                 sp,\n-                \"passing raw arrays by value is not FFI-safe\",\n-                Some(\"consider passing a pointer to the array\"),\n+                fluent::lint::improper_ctypes_array_reason,\n+                Some(fluent::lint::improper_ctypes_array_help),\n             );\n             true\n         } else {\n@@ -867,11 +868,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             } else {\n                 // All fields are ZSTs; this means that the type should behave\n                 // like (), which is FFI-unsafe\n-                FfiUnsafe {\n-                    ty,\n-                    reason: \"this struct contains only zero-sized fields\".into(),\n-                    help: None,\n-                }\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_struct_zst, help: None }\n             }\n         } else {\n             // We can't completely trust repr(C) markings; make sure the fields are\n@@ -885,7 +882,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     FfiPhantom(..) if def.is_enum() => {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: \"this enum contains a PhantomData field\".into(),\n+                            reason: fluent::lint::improper_ctypes_enum_phantomdata,\n                             help: None,\n                         };\n                     }\n@@ -921,7 +918,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     } else {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: \"box cannot be represented as a single pointer\".to_string(),\n+                            reason: fluent::lint::improper_ctypes_box,\n                             help: None,\n                         };\n                     }\n@@ -931,17 +928,19 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n                 match def.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n-                        let kind = if def.is_struct() { \"struct\" } else { \"union\" };\n-\n                         if !def.repr().c() && !def.repr().transparent() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: format!(\"this {} has unspecified layout\", kind),\n-                                help: Some(format!(\n-                                    \"consider adding a `#[repr(C)]` or \\\n-                                             `#[repr(transparent)]` attribute to this {}\",\n-                                    kind\n-                                )),\n+                                reason: if def.is_struct() {\n+                                    fluent::lint::improper_ctypes_struct_layout_reason\n+                                } else {\n+                                    fluent::lint::improper_ctypes_union_layout_reason\n+                                },\n+                                help: if def.is_struct() {\n+                                    Some(fluent::lint::improper_ctypes_struct_layout_help)\n+                                } else {\n+                                    Some(fluent::lint::improper_ctypes_union_layout_help)\n+                                },\n                             };\n                         }\n \n@@ -950,16 +949,28 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if is_non_exhaustive && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: format!(\"this {} is non-exhaustive\", kind),\n+                                reason: if def.is_struct() {\n+                                    fluent::lint::improper_ctypes_struct_non_exhaustive\n+                                } else {\n+                                    fluent::lint::improper_ctypes_union_non_exhaustive\n+                                },\n                                 help: None,\n                             };\n                         }\n \n                         if def.non_enum_variant().fields.is_empty() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: format!(\"this {} has no fields\", kind),\n-                                help: Some(format!(\"consider adding a member to this {}\", kind)),\n+                                reason: if def.is_struct() {\n+                                    fluent::lint::improper_ctypes_struct_fieldless_reason\n+                                } else {\n+                                    fluent::lint::improper_ctypes_union_fieldless_reason\n+                                },\n+                                help: if def.is_struct() {\n+                                    Some(fluent::lint::improper_ctypes_struct_fieldless_help)\n+                                } else {\n+                                    Some(fluent::lint::improper_ctypes_union_fieldless_help)\n+                                },\n                             };\n                         }\n \n@@ -979,21 +990,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"enum has no representation hint\".into(),\n-                                    help: Some(\n-                                        \"consider adding a `#[repr(C)]`, \\\n-                                                `#[repr(transparent)]`, or integer `#[repr(...)]` \\\n-                                                attribute to this enum\"\n-                                            .into(),\n-                                    ),\n+                                    reason: fluent::lint::improper_ctypes_enum_repr_reason,\n+                                    help: Some(fluent::lint::improper_ctypes_enum_repr_help),\n                                 };\n                             }\n                         }\n \n                         if def.is_variant_list_non_exhaustive() && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: \"this enum is non-exhaustive\".into(),\n+                                reason: fluent::lint::improper_ctypes_non_exhaustive,\n                                 help: None,\n                             };\n                         }\n@@ -1004,7 +1010,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if is_non_exhaustive && !variant.def_id.is_local() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: \"this enum has non-exhaustive variants\".into(),\n+                                    reason: fluent::lint::improper_ctypes_non_exhaustive_variant,\n                                     help: None,\n                                 };\n                             }\n@@ -1022,39 +1028,37 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Char => FfiUnsafe {\n                 ty,\n-                reason: \"the `char` type has no C equivalent\".into(),\n-                help: Some(\"consider using `u32` or `libc::wchar_t` instead\".into()),\n+                reason: fluent::lint::improper_ctypes_char_reason,\n+                help: Some(fluent::lint::improper_ctypes_char_help),\n             },\n \n-            ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => FfiUnsafe {\n-                ty,\n-                reason: \"128-bit integers don't currently have a known stable ABI\".into(),\n-                help: None,\n-            },\n+            ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => {\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_128bit, help: None }\n+            }\n \n             // Primitive types with a stable representation.\n             ty::Bool | ty::Int(..) | ty::Uint(..) | ty::Float(..) | ty::Never => FfiSafe,\n \n             ty::Slice(_) => FfiUnsafe {\n                 ty,\n-                reason: \"slices have no C equivalent\".into(),\n-                help: Some(\"consider using a raw pointer instead\".into()),\n+                reason: fluent::lint::improper_ctypes_slice_reason,\n+                help: Some(fluent::lint::improper_ctypes_slice_help),\n             },\n \n             ty::Dynamic(..) => {\n-                FfiUnsafe { ty, reason: \"trait objects have no C equivalent\".into(), help: None }\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_dyn, help: None }\n             }\n \n             ty::Str => FfiUnsafe {\n                 ty,\n-                reason: \"string slices have no C equivalent\".into(),\n-                help: Some(\"consider using `*const u8` and a length instead\".into()),\n+                reason: fluent::lint::improper_ctypes_str_reason,\n+                help: Some(fluent::lint::improper_ctypes_str_help),\n             },\n \n             ty::Tuple(..) => FfiUnsafe {\n                 ty,\n-                reason: \"tuples have unspecified layout\".into(),\n-                help: Some(\"consider using a struct instead\".into()),\n+                reason: fluent::lint::improper_ctypes_tuple_reason,\n+                help: Some(fluent::lint::improper_ctypes_tuple_help),\n             },\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n@@ -1085,12 +1089,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 if self.is_internal_abi(sig.abi()) {\n                     return FfiUnsafe {\n                         ty,\n-                        reason: \"this function pointer has Rust-specific calling convention\".into(),\n-                        help: Some(\n-                            \"consider using an `extern fn(...) -> ...` \\\n-                                    function pointer instead\"\n-                                .into(),\n-                        ),\n+                        reason: fluent::lint::improper_ctypes_fnptr_reason,\n+                        help: Some(fluent::lint::improper_ctypes_fnptr_help),\n                     };\n                 }\n \n@@ -1121,7 +1121,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n             ty::Opaque(..) => {\n-                FfiUnsafe { ty, reason: \"opaque types have no C equivalent\".into(), help: None }\n+                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_opaque, help: None }\n             }\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n@@ -1147,8 +1147,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         sp: Span,\n-        note: &str,\n-        help: Option<&str>,\n+        note: DiagnosticMessage,\n+        help: Option<DiagnosticMessage>,\n     ) {\n         let lint = match self.mode {\n             CItemKind::Declaration => IMPROPER_CTYPES,\n@@ -1160,18 +1160,17 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 CItemKind::Declaration => \"block\",\n                 CItemKind::Definition => \"fn\",\n             };\n-            let mut diag = lint.build(&format!(\n-                \"`extern` {} uses type `{}`, which is not FFI-safe\",\n-                item_description, ty\n-            ));\n-            diag.span_label(sp, \"not FFI-safe\");\n+            let mut diag = lint.build(fluent::lint::improper_ctypes);\n+            diag.set_arg(\"ty\", ty);\n+            diag.set_arg(\"desc\", item_description);\n+            diag.span_label(sp, fluent::lint::label);\n             if let Some(help) = help {\n                 diag.help(help);\n             }\n             diag.note(note);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n-                    diag.span_note(sp, \"the type is defined here\");\n+                    diag.span_note(sp, fluent::lint::note);\n                 }\n             }\n             diag.emit();\n@@ -1208,7 +1207,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         if let Some(ty) = ty.visit_with(&mut ProhibitOpaqueTypes { cx: self.cx }).break_value() {\n-            self.emit_ffi_unsafe_type_lint(ty, sp, \"opaque types have no C equivalent\", None);\n+            self.emit_ffi_unsafe_type_lint(ty, sp, fluent::lint::improper_ctypes_opaque, None);\n             true\n         } else {\n             false\n@@ -1250,13 +1249,18 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         match self.check_type_for_ffi(&mut FxHashSet::default(), ty) {\n             FfiResult::FfiSafe => {}\n             FfiResult::FfiPhantom(ty) => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, \"composed only of `PhantomData`\", None);\n+                self.emit_ffi_unsafe_type_lint(\n+                    ty,\n+                    sp,\n+                    fluent::lint::improper_ctypes_only_phantomdata,\n+                    None,\n+                );\n             }\n             // If `ty` is a `repr(transparent)` newtype, and the non-zero-sized type is a generic\n             // argument, which after substitution, is `()`, then this branch can be hit.\n             FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => {}\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n-                self.emit_ffi_unsafe_type_lint(ty, sp, &reason, help.as_deref());\n+                self.emit_ffi_unsafe_type_lint(ty, sp, reason, help);\n             }\n         }\n     }\n@@ -1383,12 +1387,9 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n                     |lint| {\n-                        lint.build(&format!(\n-                            \"enum variant is more than three times \\\n-                                          larger ({} bytes) than the next largest\",\n-                            largest\n-                        ))\n-                        .emit();\n+                        lint.build(fluent::lint::variant_size_differences)\n+                            .set_arg(\"largest\", largest)\n+                            .emit();\n                     },\n                 );\n             }\n@@ -1511,13 +1512,13 @@ impl InvalidAtomicOrdering {\n         {\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, |diag| {\n                 if method == sym::load {\n-                    diag.build(\"atomic loads cannot have `Release` or `AcqRel` ordering\")\n-                        .help(\"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\")\n+                    diag.build(fluent::lint::atomic_ordering_load)\n+                        .help(fluent::lint::help)\n                         .emit()\n                 } else {\n                     debug_assert_eq!(method, sym::store);\n-                    diag.build(\"atomic stores cannot have `Acquire` or `AcqRel` ordering\")\n-                        .help(\"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\")\n+                    diag.build(fluent::lint::atomic_ordering_store)\n+                        .help(fluent::lint::help)\n                         .emit();\n                 }\n             });\n@@ -1532,8 +1533,8 @@ impl InvalidAtomicOrdering {\n             && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, |diag| {\n-                diag.build(\"memory fences cannot have `Relaxed` ordering\")\n-                    .help(\"consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\")\n+                diag.build(fluent::lint::atomic_ordering_fence)\n+                    .help(fluent::lint::help)\n                     .emit();\n             });\n         }\n@@ -1553,13 +1554,11 @@ impl InvalidAtomicOrdering {\n \n         if matches!(fail_ordering, sym::Release | sym::AcqRel) {\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, fail_order_arg.span, |diag| {\n-                diag.build(&format!(\n-                    \"`{method}`'s failure ordering may not be `Release` or `AcqRel`, \\\n-                    since a failed `{method}` does not result in a write\",\n-                ))\n-                .span_label(fail_order_arg.span, \"invalid failure ordering\")\n-                .help(\"consider using `Acquire` or `Relaxed` failure ordering instead\")\n-                .emit();\n+                diag.build(fluent::lint::atomic_ordering_invalid)\n+                    .set_arg(\"method\", method)\n+                    .span_label(fail_order_arg.span, fluent::lint::label)\n+                    .help(fluent::lint::help)\n+                    .emit();\n             });\n         }\n \n@@ -1577,18 +1576,20 @@ impl InvalidAtomicOrdering {\n                     fail_ordering\n                 };\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, success_order_arg.span, |diag| {\n-                diag.build(&format!(\n-                    \"`{method}`'s success ordering must be at least as strong as its failure ordering\"\n-                ))\n-                .span_label(fail_order_arg.span, format!(\"`{fail_ordering}` failure ordering\"))\n-                .span_label(success_order_arg.span, format!(\"`{success_ordering}` success ordering\"))\n-                .span_suggestion_short(\n-                    success_order_arg.span,\n-                    format!(\"consider using `{success_suggestion}` success ordering instead\"),\n-                    format!(\"std::sync::atomic::Ordering::{success_suggestion}\"),\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+                diag.build(fluent::lint::atomic_ordering_invalid_fail_success)\n+                    .set_arg(\"method\", method)\n+                    .set_arg(\"fail_ordering\", fail_ordering)\n+                    .set_arg(\"success_ordering\", success_ordering)\n+                    .set_arg(\"success_suggestion\", success_suggestion)\n+                    .span_label(fail_order_arg.span, fluent::lint::fail_label)\n+                    .span_label(success_order_arg.span, fluent::lint::success_label)\n+                    .span_suggestion_short(\n+                        success_order_arg.span,\n+                        fluent::lint::suggestion,\n+                        format!(\"std::sync::atomic::Ordering::{success_suggestion}\"),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n             });\n         }\n     }"}, {"sha": "53269d18527033a8fbb0eb75c0afc0a6380e61ca", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 53, "deletions": 47, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -3,7 +3,7 @@ use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext}\n use rustc_ast as ast;\n use rustc_ast::util::{classify, parser};\n use rustc_ast::{ExprKind, StmtKind};\n-use rustc_errors::{pluralize, Applicability, MultiSpan};\n+use rustc_errors::{fluent, pluralize, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -155,22 +155,23 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n \n         if let Some(must_use_op) = must_use_op {\n             cx.struct_span_lint(UNUSED_MUST_USE, expr.span, |lint| {\n-                let mut lint = lint.build(&format!(\"unused {} that must be used\", must_use_op));\n-                lint.span_label(expr.span, &format!(\"the {} produces a value\", must_use_op));\n-                lint.span_suggestion_verbose(\n-                    expr.span.shrink_to_lo(),\n-                    \"use `let _ = ...` to ignore the resulting value\",\n-                    \"let _ = \",\n-                    Applicability::MachineApplicable,\n-                );\n-                lint.emit();\n+                lint.build(fluent::lint::unused_op)\n+                    .set_arg(\"op\", must_use_op)\n+                    .span_label(expr.span, fluent::lint::label)\n+                    .span_suggestion_verbose(\n+                        expr.span.shrink_to_lo(),\n+                        fluent::lint::suggestion,\n+                        \"let _ = \",\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n             });\n             op_warned = true;\n         }\n \n         if !(type_permits_lack_of_use || fn_warned || op_warned) {\n             cx.struct_span_lint(UNUSED_RESULTS, s.span, |lint| {\n-                lint.build(&format!(\"unused result of type `{}`\", ty)).emit();\n+                lint.build(fluent::lint::unused_result).set_arg(\"ty\", ty).emit();\n             });\n         }\n \n@@ -267,23 +268,27 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 },\n                 ty::Closure(..) => {\n                     cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n-                        let mut err = lint.build(&format!(\n-                            \"unused {}closure{}{} that must be used\",\n-                            descr_pre, plural_suffix, descr_post,\n-                        ));\n-                        err.note(\"closures are lazy and do nothing unless called\");\n-                        err.emit();\n+                        // FIXME(davidtwco): this isn't properly translatable becauses of the\n+                        // pre/post strings\n+                        lint.build(fluent::lint::unused_closure)\n+                            .set_arg(\"count\", plural_len)\n+                            .set_arg(\"pre\", descr_pre)\n+                            .set_arg(\"post\", descr_post)\n+                            .note(fluent::lint::note)\n+                            .emit();\n                     });\n                     true\n                 }\n                 ty::Generator(..) => {\n                     cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n-                        let mut err = lint.build(&format!(\n-                            \"unused {}generator{}{} that must be used\",\n-                            descr_pre, plural_suffix, descr_post,\n-                        ));\n-                        err.note(\"generators are lazy and do nothing unless resumed\");\n-                        err.emit();\n+                        // FIXME(davidtwco): this isn't properly translatable becauses of the\n+                        // pre/post strings\n+                        lint.build(fluent::lint::unused_generator)\n+                            .set_arg(\"count\", plural_len)\n+                            .set_arg(\"pre\", descr_pre)\n+                            .set_arg(\"post\", descr_post)\n+                            .note(fluent::lint::note)\n+                            .emit();\n                     });\n                     true\n                 }\n@@ -305,13 +310,12 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         ) -> bool {\n             if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n                 cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n-                    let msg = format!(\n-                        \"unused {}`{}`{} that must be used\",\n-                        descr_pre_path,\n-                        cx.tcx.def_path_str(def_id),\n-                        descr_post_path\n-                    );\n-                    let mut err = lint.build(&msg);\n+                    // FIXME(davidtwco): this isn't properly translatable becauses of the pre/post\n+                    // strings\n+                    let mut err = lint.build(fluent::lint::unused_def);\n+                    err.set_arg(\"pre\", descr_pre_path);\n+                    err.set_arg(\"post\", descr_post_path);\n+                    err.set_arg(\"def\", cx.tcx.def_path_str(def_id));\n                     // check for #[must_use = \"...\"]\n                     if let Some(note) = attr.value_str() {\n                         err.note(note.as_str());\n@@ -356,20 +360,20 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n                 cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| {\n                     let ty = cx.typeck_results().expr_ty(expr);\n                     if ty.needs_drop(cx.tcx, cx.param_env) {\n-                        let mut lint = lint.build(\"path statement drops value\");\n+                        let mut lint = lint.build(fluent::lint::path_statement_drop);\n                         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n                             lint.span_suggestion(\n                                 s.span,\n-                                \"use `drop` to clarify the intent\",\n+                                fluent::lint::suggestion,\n                                 format!(\"drop({});\", snippet),\n                                 Applicability::MachineApplicable,\n                             );\n                         } else {\n-                            lint.span_help(s.span, \"use `drop` to clarify the intent\");\n+                            lint.span_help(s.span, fluent::lint::suggestion);\n                         }\n                         lint.emit();\n                     } else {\n-                        lint.build(\"path statement with no effect\").emit();\n+                        lint.build(fluent::lint::path_statement_no_effect).emit();\n                     }\n                 });\n             }\n@@ -540,15 +544,19 @@ trait UnusedDelimLint {\n         }\n \n         cx.struct_span_lint(self.lint(), MultiSpan::from(vec![spans.0, spans.1]), |lint| {\n-            let span_msg = format!(\"unnecessary {} around {}\", Self::DELIM_STR, msg);\n-            let mut err = lint.build(&span_msg);\n             let replacement = vec![\n                 (spans.0, if keep_space.0 { \" \".into() } else { \"\".into() }),\n                 (spans.1, if keep_space.1 { \" \".into() } else { \"\".into() }),\n             ];\n-            let suggestion = format!(\"remove these {}\", Self::DELIM_STR);\n-            err.multipart_suggestion(&suggestion, replacement, Applicability::MachineApplicable);\n-            err.emit();\n+            lint.build(fluent::lint::unused_delim)\n+                .set_arg(\"delim\", Self::DELIM_STR)\n+                .set_arg(\"item\", msg)\n+                .multipart_suggestion(\n+                    fluent::lint::suggestion,\n+                    replacement,\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n         });\n     }\n \n@@ -1110,7 +1118,7 @@ impl UnusedImportBraces {\n             };\n \n             cx.struct_span_lint(UNUSED_IMPORT_BRACES, item.span, |lint| {\n-                lint.build(&format!(\"braces around {} is unnecessary\", node_name)).emit();\n+                lint.build(fluent::lint::unused_import_braces).set_arg(\"node\", node_name).emit();\n             });\n         }\n     }\n@@ -1161,15 +1169,13 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n         for adj in cx.typeck_results().expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n                 cx.struct_span_lint(UNUSED_ALLOCATION, e.span, |lint| {\n-                    let msg = match m {\n-                        adjustment::AutoBorrowMutability::Not => {\n-                            \"unnecessary allocation, use `&` instead\"\n-                        }\n+                    lint.build(match m {\n+                        adjustment::AutoBorrowMutability::Not => fluent::lint::unused_allocation,\n                         adjustment::AutoBorrowMutability::Mut { .. } => {\n-                            \"unnecessary allocation, use `&mut` instead\"\n+                            fluent::lint::unused_allocation_mut\n                         }\n-                    };\n-                    lint.build(msg).emit();\n+                    })\n+                    .emit();\n                 });\n             }\n         }"}, {"sha": "32c0a7e260569986291f7b9878cf62b499d14a60", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -3,7 +3,8 @@ use std::cmp;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{\n-    Diagnostic, DiagnosticBuilder, DiagnosticId, EmissionGuarantee, ErrorGuaranteed, MultiSpan,\n+    Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, EmissionGuarantee,\n+    ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n@@ -231,7 +232,7 @@ pub struct LintDiagnosticBuilder<'a, G: EmissionGuarantee>(DiagnosticBuilder<'a,\n \n impl<'a, G: EmissionGuarantee> LintDiagnosticBuilder<'a, G> {\n     /// Return the inner `DiagnosticBuilder`, first setting the primary message to `msg`.\n-    pub fn build(mut self, msg: &str) -> DiagnosticBuilder<'a, G> {\n+    pub fn build(mut self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'a, G> {\n         self.0.set_primary_message(msg);\n         self.0.set_is_lint();\n         self.0"}, {"sha": "c71905b4aca7ff04a0ee14cfb3cb22f00d38eaf6", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -611,6 +611,12 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n     }\n }\n \n+impl rustc_errors::IntoDiagnosticArg for Predicate<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        rustc_errors::DiagnosticArgValue::Str(std::borrow::Cow::Owned(self.to_string()))\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateKind<'tcx> {"}, {"sha": "f22f3f61a01f2f18314fb13ee8cab7bef8ef4a4b", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -550,7 +550,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                         id,\n                         span,\n                         |lint| {\n-                            lint.build(&msg).emit();\n+                            lint.build(msg).emit();\n                         },\n                     );\n                 }"}, {"sha": "8c123c052e5ac4aa941a7d79adfc6ed87218d53a", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1163,7 +1163,7 @@ impl CheckAttrVisitor<'_> {\n                         hir_id,\n                         meta.span(),\n                         |lint| {\n-                            lint.build(&\"invalid `doc` attribute\").emit();\n+                            lint.build(\"invalid `doc` attribute\").emit();\n                         },\n                     );\n                     is_valid = false;"}, {"sha": "bc9fcdd7bc7a56a54014e3746a437ae3e73b3de5", "filename": "src/test/ui-fulldeps/internal-lints/existing_doc_keyword.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fexisting_doc_keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fexisting_doc_keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fexisting_doc_keyword.stderr?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,4 +1,4 @@\n-error: Found non-existing keyword `tadam` used in `#[doc(keyword = \"...\")]`\n+error: found non-existing keyword `tadam` used in `#[doc(keyword = \\\"...\\\")]`\n   --> $DIR/existing_doc_keyword.rs:10:1\n    |\n LL | #[doc(keyword = \"tadam\")]"}, {"sha": "18283c19cb42c1733e1f87abfd93e108101a263f", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,6 +1,8 @@\n // check-fail\n // Tests error conditions for specifying diagnostics using #[derive(SessionDiagnostic)]\n \n+// normalize-stderr-test \"the following other types implement trait `IntoDiagnosticArg`:(?:.*\\n){0,9}\\s+and \\d+ others\" -> \"normalized in stderr\"\n+\n // The proc_macro2 crate handles spans differently when on beta/stable release rather than nightly,\n // changing the output of this test. Since SessionDiagnostic is strictly internal to the compiler\n // the test is just ignored on stable and beta:"}, {"sha": "9e2e34e4bec81b8558f03a7e87e6f557a826c3d1", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 54, "deletions": 60, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -1,5 +1,5 @@\n error: `#[derive(SessionDiagnostic)]` can only be used on structs\n-  --> $DIR/diagnostic-derive.rs:37:1\n+  --> $DIR/diagnostic-derive.rs:39:1\n    |\n LL | / #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -10,21 +10,21 @@ LL | | }\n    | |_^\n \n error: `#[error = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:46:1\n+  --> $DIR/diagnostic-derive.rs:48:1\n    |\n LL | #[error = \"E0123\"]\n    | ^^^^^^^^^^^^^^^^^^\n \n error: `#[nonsense(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:51:1\n+  --> $DIR/diagnostic-derive.rs:53:1\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: only `error`, `warning`, `help` and `note` are valid attributes\n \n error: diagnostic kind not specified\n-  --> $DIR/diagnostic-derive.rs:51:1\n+  --> $DIR/diagnostic-derive.rs:53:1\n    |\n LL | / #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -36,15 +36,15 @@ LL | | struct InvalidStructAttr {}\n    = help: use the `#[error(...)]` attribute to create an error\n \n error: `#[error(\"...\")]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:58:9\n+  --> $DIR/diagnostic-derive.rs:60:9\n    |\n LL | #[error(\"E0123\")]\n    |         ^^^^^^^\n    |\n    = help: first argument of the attribute should be the diagnostic slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:58:1\n+  --> $DIR/diagnostic-derive.rs:60:1\n    |\n LL | / #[error(\"E0123\")]\n LL | |\n@@ -55,15 +55,15 @@ LL | | struct InvalidLitNestedAttr {}\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense(...))]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:69:9\n+  --> $DIR/diagnostic-derive.rs:71:9\n    |\n LL | #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^\n    |\n    = help: first argument of the attribute should be the diagnostic slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:69:1\n+  --> $DIR/diagnostic-derive.rs:71:1\n    |\n LL | / #[error(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -74,15 +74,15 @@ LL | | struct InvalidNestedStructAttr1 {}\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:75:9\n+  --> $DIR/diagnostic-derive.rs:77:9\n    |\n LL | #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^^^^^\n    |\n    = help: first argument of the attribute should be the diagnostic slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:75:1\n+  --> $DIR/diagnostic-derive.rs:77:1\n    |\n LL | / #[error(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -93,15 +93,15 @@ LL | | struct InvalidNestedStructAttr2 {}\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:81:9\n+  --> $DIR/diagnostic-derive.rs:83:9\n    |\n LL | #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |         ^^^^^^^^^^^^\n    |\n    = help: first argument of the attribute should be the diagnostic slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:81:1\n+  --> $DIR/diagnostic-derive.rs:83:1\n    |\n LL | / #[error(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n LL | |\n@@ -112,119 +112,119 @@ LL | | struct InvalidNestedStructAttr3 {}\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: `#[error(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:87:59\n+  --> $DIR/diagnostic-derive.rs:89:59\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n    |                                                           ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n error: `#[suggestion = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:94:5\n+  --> $DIR/diagnostic-derive.rs:96:5\n    |\n LL |     #[suggestion = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:1\n+  --> $DIR/diagnostic-derive.rs:103:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:1\n+  --> $DIR/diagnostic-derive.rs:102:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:1\n+  --> $DIR/diagnostic-derive.rs:103:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:1\n+  --> $DIR/diagnostic-derive.rs:102:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:101:50\n+  --> $DIR/diagnostic-derive.rs:103:50\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                                  ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:100:50\n+  --> $DIR/diagnostic-derive.rs:102:50\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |                                                  ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:109:1\n+  --> $DIR/diagnostic-derive.rs:111:1\n    |\n LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:108:1\n+  --> $DIR/diagnostic-derive.rs:110:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:109:1\n+  --> $DIR/diagnostic-derive.rs:111:1\n    |\n LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:108:1\n+  --> $DIR/diagnostic-derive.rs:110:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:109:52\n+  --> $DIR/diagnostic-derive.rs:111:52\n    |\n LL | #[warning(typeck::ambiguous_lifetime_bound, code = \"E0293\")]\n    |                                                    ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:108:50\n+  --> $DIR/diagnostic-derive.rs:110:50\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |                                                  ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:116:66\n+  --> $DIR/diagnostic-derive.rs:118:66\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                                  ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:116:50\n+  --> $DIR/diagnostic-derive.rs:118:50\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                  ^^^^^^^\n \n error: `#[error(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:121:43\n+  --> $DIR/diagnostic-derive.rs:123:43\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic kind not specified\n-  --> $DIR/diagnostic-derive.rs:126:1\n+  --> $DIR/diagnostic-derive.rs:128:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: use the `#[error(...)]` attribute to create an error\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:129:1\n+  --> $DIR/diagnostic-derive.rs:131:1\n    |\n LL | / #[error(code = \"E0456\")]\n LL | |\n@@ -234,33 +234,33 @@ LL | | struct SlugNotProvided {}\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:140:5\n+  --> $DIR/diagnostic-derive.rs:142:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: `#[nonsense]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:148:5\n+  --> $DIR/diagnostic-derive.rs:150:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n    |\n    = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:165:5\n+  --> $DIR/diagnostic-derive.rs:167:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:173:45\n+  --> $DIR/diagnostic-derive.rs:175:45\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"{name}\")]\n    |                                             ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/diagnostic-derive.rs:178:16\n+  --> $DIR/diagnostic-derive.rs:180:16\n    |\n LL | #[derive(SessionDiagnostic)]\n    |           -    ^ expected `'}'` in format string\n@@ -271,7 +271,7 @@ LL | #[derive(SessionDiagnostic)]\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/diagnostic-derive.rs:188:15\n+  --> $DIR/diagnostic-derive.rs:190:15\n    |\n LL | #[derive(SessionDiagnostic)]\n    |               ^ unmatched `}` in format string\n@@ -280,29 +280,29 @@ LL | #[derive(SessionDiagnostic)]\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n-  --> $DIR/diagnostic-derive.rs:208:5\n+  --> $DIR/diagnostic-derive.rs:210:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:233:18\n+  --> $DIR/diagnostic-derive.rs:235:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^^^^^^^^^\n    |\n    = help: only `message`, `code` and `applicability` are valid field attributes\n \n error: `#[suggestion(msg = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:241:18\n+  --> $DIR/diagnostic-derive.rs:243:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^^^^^^^^^\n    |\n    = help: only `message`, `code` and `applicability` are valid field attributes\n \n error: wrong field type for suggestion\n-  --> $DIR/diagnostic-derive.rs:263:5\n+  --> $DIR/diagnostic-derive.rs:265:5\n    |\n LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n@@ -312,88 +312,82 @@ LL | |     suggestion: Applicability,\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one `Span`\n-  --> $DIR/diagnostic-derive.rs:278:5\n+  --> $DIR/diagnostic-derive.rs:280:5\n    |\n LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Span, Span, Applicability),\n    | |___________________________________________^\n \n error: type of field annotated with `#[suggestion(...)]` contains more than one Applicability\n-  --> $DIR/diagnostic-derive.rs:286:5\n+  --> $DIR/diagnostic-derive.rs:288:5\n    |\n LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: (Applicability, Applicability, Span),\n    | |____________________________________________________^\n \n error: `#[label = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:294:5\n+  --> $DIR/diagnostic-derive.rs:296:5\n    |\n LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n error: applicability cannot be set in both the field and attribute\n-  --> $DIR/diagnostic-derive.rs:445:52\n+  --> $DIR/diagnostic-derive.rs:447:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:453:52\n+  --> $DIR/diagnostic-derive.rs:455:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:516:5\n+  --> $DIR/diagnostic-derive.rs:518:5\n    |\n LL |     #[label(typeck::label, foo)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:524:5\n+  --> $DIR/diagnostic-derive.rs:526:5\n    |\n LL |     #[label(typeck::label, foo = \"...\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:532:5\n+  --> $DIR/diagnostic-derive.rs:534:5\n    |\n LL |     #[label(typeck::label, foo(\"...\"))]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:51:3\n+  --> $DIR/diagnostic-derive.rs:53:3\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:148:7\n+  --> $DIR/diagnostic-derive.rs:150:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`\n-  --> $DIR/diagnostic-derive.rs:64:9\n+  --> $DIR/diagnostic-derive.rs:66:9\n    |\n LL | #[error(nonsense, code = \"E0123\")]\n    |         ^^^^^^^^ not found in `rustc_errors::fluent`\n \n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:338:10\n+  --> $DIR/diagnostic-derive.rs:340:10\n    |\n LL | #[derive(SessionDiagnostic)]\n    |          ^^^^^^^^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n    |\n-   = help: the following other types implement trait `IntoDiagnosticArg`:\n-             &'a str\n-             Ident\n-             String\n-             Symbol\n-             rustc_middle::ty::Ty<'tcx>\n-             usize\n+   = help: normalized in stderr\n note: required by a bound in `DiagnosticBuilder::<'a, G>::set_arg`\n   --> $COMPILER_DIR/rustc_errors/src/diagnostic_builder.rs:538:19\n    |"}, {"sha": "f06dedc229845bd02b500b5daa8bce0d8aa62c0c", "filename": "src/test/ui/consts/const-eval/const_panic_stability.e2018.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_stability.e2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_stability.e2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_stability.e2018.stderr?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -5,9 +5,9 @@ LL |     panic!({ \"foo\" });\n    |            ^^^^^^^^^\n    |\n    = note: `#[warn(non_fmt_panics)]` on by default\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic!(\"{}\", { \"foo\" });\n    |            +++++"}, {"sha": "6e4434e6f33723fc2fec20d72c240e6c7515bf92", "filename": "src/test/ui/non-fmt-panic.stderr", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/291df97faec6e009a95c658cf6d2840088a85fa0/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr?ref=291df97faec6e009a95c658cf6d2840088a85fa0", "patch": "@@ -73,9 +73,9 @@ warning: panic message is not a string literal\n LL |     assert!(false, S);\n    |                    ^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     assert!(false, \"{}\", S);\n    |                    +++++\n@@ -86,9 +86,9 @@ warning: panic message is not a string literal\n LL |     assert!(false, 123);\n    |                    ^^^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     assert!(false, \"{}\", 123);\n    |                    +++++\n@@ -99,9 +99,9 @@ warning: panic message is not a string literal\n LL |     assert!(false, Some(123));\n    |                    ^^^^^^^^^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{:?}\" format string to use the Debug implementation of `Option<i32>`\n+help: add a \"{:?}\" format string to use the `Debug` implementation of `Option<i32>`\n    |\n LL |     assert!(false, \"{:?}\", Some(123));\n    |                    +++++++\n@@ -124,9 +124,9 @@ warning: panic message is not a string literal\n LL |     panic!(C);\n    |            ^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic!(\"{}\", C);\n    |            +++++\n@@ -137,9 +137,9 @@ warning: panic message is not a string literal\n LL |     panic!(S);\n    |            ^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic!(\"{}\", S);\n    |            +++++\n@@ -150,9 +150,9 @@ warning: panic message is not a string literal\n LL |     unreachable!(S);\n    |                  ^\n    |\n-   = note: this usage of unreachable!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `unreachable!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     unreachable!(\"{}\", S);\n    |                  +++++\n@@ -163,9 +163,9 @@ warning: panic message is not a string literal\n LL |     unreachable!(S);\n    |                  ^\n    |\n-   = note: this usage of unreachable!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `unreachable!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     unreachable!(\"{}\", S);\n    |                  +++++\n@@ -176,9 +176,9 @@ warning: panic message is not a string literal\n LL |     std::panic!(123);\n    |                 ^^^\n    |\n-   = note: this usage of std::panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `std::panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     std::panic!(\"{}\", 123);\n    |                 +++++\n@@ -193,9 +193,9 @@ warning: panic message is not a string literal\n LL |     core::panic!(&*\"abc\");\n    |                  ^^^^^^^\n    |\n-   = note: this usage of core::panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `core::panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     core::panic!(\"{}\", &*\"abc\");\n    |                  +++++\n@@ -206,9 +206,9 @@ warning: panic message is not a string literal\n LL |     panic!(Some(123));\n    |            ^^^^^^^^^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{:?}\" format string to use the Debug implementation of `Option<i32>`\n+help: add a \"{:?}\" format string to use the `Debug` implementation of `Option<i32>`\n    |\n LL |     panic!(\"{:?}\", Some(123));\n    |            +++++++\n@@ -259,9 +259,9 @@ warning: panic message is not a string literal\n LL |     panic!(a!());\n    |            ^^^^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic!(\"{}\", a!());\n    |            +++++\n@@ -276,9 +276,9 @@ warning: panic message is not a string literal\n LL |     unreachable!(a!());\n    |                  ^^^^\n    |\n-   = note: this usage of unreachable!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `unreachable!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     unreachable!(\"{}\", a!());\n    |                  +++++\n@@ -289,9 +289,9 @@ warning: panic message is not a string literal\n LL |     panic!(format!(\"{}\", 1));\n    |            ^^^^^^^^^^^^^^^^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-   = note: the panic!() macro supports formatting, so there's no need for the format!() macro here\n+   = note: the `panic!()` macro supports formatting, so there's no need for the `format!()` macro here\n help: remove the `format!(..)` macro call\n    |\n LL -     panic!(format!(\"{}\", 1));\n@@ -304,9 +304,9 @@ warning: panic message is not a string literal\n LL |     unreachable!(format!(\"{}\", 1));\n    |                  ^^^^^^^^^^^^^^^^\n    |\n-   = note: this usage of unreachable!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `unreachable!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-   = note: the unreachable!() macro supports formatting, so there's no need for the format!() macro here\n+   = note: the `unreachable!()` macro supports formatting, so there's no need for the `format!()` macro here\n help: remove the `format!(..)` macro call\n    |\n LL -     unreachable!(format!(\"{}\", 1));\n@@ -319,9 +319,9 @@ warning: panic message is not a string literal\n LL |     assert!(false, format!(\"{}\", 1));\n    |                    ^^^^^^^^^^^^^^^^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-   = note: the assert!() macro supports formatting, so there's no need for the format!() macro here\n+   = note: the `assert!()` macro supports formatting, so there's no need for the `format!()` macro here\n help: remove the `format!(..)` macro call\n    |\n LL -     assert!(false, format!(\"{}\", 1));\n@@ -334,9 +334,9 @@ warning: panic message is not a string literal\n LL |     debug_assert!(false, format!(\"{}\", 1));\n    |                          ^^^^^^^^^^^^^^^^\n    |\n-   = note: this usage of debug_assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `debug_assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-   = note: the debug_assert!() macro supports formatting, so there's no need for the format!() macro here\n+   = note: the `debug_assert!()` macro supports formatting, so there's no need for the `format!()` macro here\n help: remove the `format!(..)` macro call\n    |\n LL -     debug_assert!(false, format!(\"{}\", 1));\n@@ -349,9 +349,9 @@ warning: panic message is not a string literal\n LL |     panic![123];\n    |            ^^^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic![\"{}\", 123];\n    |            +++++\n@@ -366,9 +366,9 @@ warning: panic message is not a string literal\n LL |     panic!{123};\n    |            ^^^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic!{\"{}\", 123};\n    |            +++++\n@@ -385,7 +385,7 @@ LL |     panic!(v);\n    |     |\n    |     help: use std::panic::panic_any instead: `std::panic::panic_any`\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n \n warning: panic message is not a string literal\n@@ -394,7 +394,7 @@ warning: panic message is not a string literal\n LL |     assert!(false, v);\n    |                    ^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n \n warning: panic message is not a string literal\n@@ -403,9 +403,9 @@ warning: panic message is not a string literal\n LL |     panic!(v);\n    |            ^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{:?}\" format string to use the Debug implementation of `T`\n+help: add a \"{:?}\" format string to use the `Debug` implementation of `T`\n    |\n LL |     panic!(\"{:?}\", v);\n    |            +++++++\n@@ -420,9 +420,9 @@ warning: panic message is not a string literal\n LL |     assert!(false, v);\n    |                    ^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{:?}\" format string to use the Debug implementation of `T`\n+help: add a \"{:?}\" format string to use the `Debug` implementation of `T`\n    |\n LL |     assert!(false, \"{:?}\", v);\n    |                    +++++++\n@@ -433,9 +433,9 @@ warning: panic message is not a string literal\n LL |     panic!(v);\n    |            ^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic!(\"{}\", v);\n    |            +++++\n@@ -450,9 +450,9 @@ warning: panic message is not a string literal\n LL |     assert!(false, v);\n    |                    ^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     assert!(false, \"{}\", v);\n    |                    +++++\n@@ -463,9 +463,9 @@ warning: panic message is not a string literal\n LL |     panic!(v);\n    |            ^\n    |\n-   = note: this usage of panic!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `panic!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     panic!(\"{}\", v);\n    |            +++++\n@@ -480,9 +480,9 @@ warning: panic message is not a string literal\n LL |     assert!(false, v);\n    |                    ^\n    |\n-   = note: this usage of assert!() is deprecated; it will be a hard error in Rust 2021\n+   = note: this usage of `assert!()` is deprecated; it will be a hard error in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-help: add a \"{}\" format string to Display the message\n+help: add a \"{}\" format string to `Display` the message\n    |\n LL |     assert!(false, \"{}\", v);\n    |                    +++++"}]}