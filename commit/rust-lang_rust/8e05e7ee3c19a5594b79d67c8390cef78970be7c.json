{"sha": "8e05e7ee3c19a5594b79d67c8390cef78970be7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMDVlN2VlM2MxOWE1NTk0Yjc5ZDY3YzgzOTBjZWY3ODk3MGJlN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-15T13:08:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-15T13:08:55Z"}, "message": "Auto merge of #37100 - dikaiosune:master, r=eddyb\n\nChange Substs to type alias for Slice<Kind> for interning\n\nThis changes the definition of `librustc::ty::subst::Substs` to be a type alias to `Slice<Kind>`. `Substs` was already interned, but can now make use of the efficient `PartialEq` and `Hash` impls on `librustc::ty::Slice`.\n\nI'm working on collecting some timing data for this, will update when it's done.\n\nI chose to leave the impls on `Substs<'tcx>` even though it's now just a type alias to `Slice<Kind<'tcx>>` because it has the smallest footprint on other portions of the compiler which depend on its API. It turns out to be a pretty huge diff if you change where Substs's methods live :smile:. That said, I'm not necessarily sure it's the *best* implementation but it's probably the easiest/smallest to review.\n\nMany thanks to @eddyb for both suggesting this as a project for learning more about the compiler, and the tireless ~~handholding~~ mentorship he provided.", "tree": {"sha": "e0615a78412f64068e45b563b9fa6f83728e723a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0615a78412f64068e45b563b9fa6f83728e723a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e05e7ee3c19a5594b79d67c8390cef78970be7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e05e7ee3c19a5594b79d67c8390cef78970be7c", "html_url": "https://github.com/rust-lang/rust/commit/8e05e7ee3c19a5594b79d67c8390cef78970be7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e05e7ee3c19a5594b79d67c8390cef78970be7c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "030bc49bb44834e691fd67452b39b438fa6d826d", "url": "https://api.github.com/repos/rust-lang/rust/commits/030bc49bb44834e691fd67452b39b438fa6d826d", "html_url": "https://github.com/rust-lang/rust/commit/030bc49bb44834e691fd67452b39b438fa6d826d"}, {"sha": "48b3dd11f59f48819031206ee2b3ab98ceae1550", "url": "https://api.github.com/repos/rust-lang/rust/commits/48b3dd11f59f48819031206ee2b3ab98ceae1550", "html_url": "https://github.com/rust-lang/rust/commit/48b3dd11f59f48819031206ee2b3ab98ceae1550"}], "stats": {"total": 170, "additions": 70, "deletions": 100}, "files": [{"sha": "20955dfa432625c1bb7bcaa2c2919677330a954e", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8e05e7ee3c19a5594b79d67c8390cef78970be7c", "patch": "@@ -25,7 +25,7 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n use mir::tcx::LvalueTy;\n-use ty::subst::{Subst, Substs};\n+use ty::subst::{Kind, Subst, Substs};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n@@ -1208,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_var_for_def(&self,\n                             span: Span,\n                             def: &ty::TypeParameterDef<'tcx>,\n-                            substs: &Substs<'tcx>)\n+                            substs: &[Kind<'tcx>])\n                             -> Ty<'tcx> {\n         let default = def.default.map(|default| {\n             type_variable::Default {"}, {"sha": "8352d6bed5073780038402825c103c947143c186", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8e05e7ee3c19a5594b79d67c8390cef78970be7c", "patch": "@@ -22,7 +22,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n-use ty::subst::Substs;\n+use ty::subst::{Kind, Substs};\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n@@ -55,7 +55,7 @@ pub struct CtxtArenas<'tcx> {\n     // internings\n     type_: TypedArena<TyS<'tcx>>,\n     type_list: TypedArena<Vec<Ty<'tcx>>>,\n-    substs: TypedArena<Substs<'tcx>>,\n+    substs: TypedArena<Vec<Kind<'tcx>>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n     stability: TypedArena<attr::Stability>,\n@@ -824,7 +824,7 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if let Some(&Interned(substs)) = tcx.interners.substs.borrow().get(*self) {\n+        if let Some(&Interned(substs)) = tcx.interners.substs.borrow().get(&self[..]) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n             }\n@@ -1097,9 +1097,9 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, Slice<Ty<'tcx>>> {\n     }\n }\n \n-impl<'tcx: 'lcx, 'lcx> Borrow<Substs<'lcx>> for Interned<'tcx, Substs<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a Substs<'lcx> {\n-        self.0\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a [Kind<'lcx>] {\n+        &self.0[..]\n     }\n }\n \n@@ -1189,9 +1189,6 @@ fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n }\n \n direct_interners!('tcx,\n-    substs: mk_substs(|substs: &Substs| {\n-        substs.params().iter().any(keep_local)\n-    }) -> Substs<'tcx>,\n     bare_fn: mk_bare_fn(|fty: &BareFnTy| {\n         keep_local(&fty.sig)\n     }) -> BareFnTy<'tcx>,\n@@ -1209,6 +1206,12 @@ intern_method!('tcx,\n     }, keep_local) -> Slice<Ty<'tcx>>\n );\n \n+intern_method!('tcx,\n+    substs: mk_substs(Vec<Kind<'tcx>>, Deref::deref, |xs: &[Kind]| -> &Slice<Kind> {\n+        unsafe { mem::transmute(xs) }\n+    }, keep_local) -> Slice<Kind<'tcx>>\n+);\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Create an unsafe fn ty based on a safe fn ty.\n     pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {"}, {"sha": "7108ac89d82bb4f849c62f76d1b67aca7a147c40", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8e05e7ee3c19a5594b79d67c8390cef78970be7c", "patch": "@@ -521,7 +521,7 @@ pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for Ty<'tcx> {}\n \n-/// A wrapper for slices with the additioanl invariant\n+/// A wrapper for slices with the additional invariant\n /// that the slice is interned and no other slice with\n /// the same contents can exist in the same context.\n /// This means we can use pointer + length for both"}, {"sha": "7d7bbd931225f5593f542bf6fec727f827a34060", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=8e05e7ee3c19a5594b79d67c8390cef78970be7c", "patch": "@@ -11,7 +11,7 @@\n // Type substitutions.\n \n use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt};\n+use ty::{self, Slice, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -161,26 +161,19 @@ impl<'tcx> Decodable for Kind<'tcx> {\n }\n \n /// A substitution mapping type/region parameters to new values.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Substs<'tcx> {\n-    params: Vec<Kind<'tcx>>\n-}\n+pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     pub fn new<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n                   -> &'tcx Substs<'tcx>\n     where I: IntoIterator<Item=Kind<'tcx>> {\n-        tcx.mk_substs(Substs {\n-            params: params.into_iter().collect()\n-        })\n+        tcx.mk_substs(params.into_iter().collect())\n     }\n \n     pub fn maybe_new<I, E>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n                            -> Result<&'tcx Substs<'tcx>, E>\n     where I: IntoIterator<Item=Result<Kind<'tcx>, E>> {\n-        Ok(tcx.mk_substs(Substs {\n-            params: params.into_iter().collect::<Result<_, _>>()?\n-        }))\n+        Ok(Substs::new(tcx, params.into_iter().collect::<Result<Vec<_>, _>>()?))\n     }\n \n     pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -193,7 +186,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n-        Substs::new(tcx, vec![])\n+        Substs::new(tcx, iter::empty())\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n@@ -206,82 +199,82 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             mut mk_region: FR,\n                             mut mk_type: FT)\n                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n         let defs = tcx.lookup_generics(def_id);\n-        let mut substs = Substs {\n-            params: Vec::with_capacity(defs.count())\n-        };\n+        let mut substs = Vec::with_capacity(defs.count());\n \n-        substs.fill_item(tcx, defs, &mut mk_region, &mut mk_type);\n+        Substs::fill_item(&mut substs, tcx, defs, &mut mk_region, &mut mk_type);\n \n-        tcx.mk_substs(substs)\n+        Substs::new(tcx, substs)\n     }\n \n-    fn fill_item<FR, FT>(&mut self,\n+    fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          defs: &ty::Generics<'tcx>,\n                          mk_region: &mut FR,\n                          mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n-          FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n+\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.lookup_generics(def_id);\n-            self.fill_item(tcx, parent_defs, mk_region, mk_type);\n+            Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n \n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n         if defs.parent.is_none() && defs.has_self {\n             let def = types.next().unwrap();\n-            let ty = mk_type(def, self);\n-            assert_eq!(def.index as usize, self.params.len());\n-            self.params.push(Kind::from(ty));\n+            let ty = mk_type(def, substs);\n+            assert_eq!(def.index as usize, substs.len());\n+            substs.push(Kind::from(ty));\n         }\n \n         for def in &defs.regions {\n-            let region = mk_region(def, self);\n-            assert_eq!(def.index as usize, self.params.len());\n-            self.params.push(Kind::from(region));\n+            let region = mk_region(def, substs);\n+            assert_eq!(def.index as usize, substs.len());\n+            substs.push(Kind::from(region));\n         }\n \n         for def in types {\n-            let ty = mk_type(def, self);\n-            assert_eq!(def.index as usize, self.params.len());\n-            self.params.push(Kind::from(ty));\n+            let ty = mk_type(def, substs);\n+            assert_eq!(def.index as usize, substs.len());\n+            substs.push(Kind::from(ty));\n         }\n     }\n \n     pub fn is_noop(&self) -> bool {\n-        self.params.is_empty()\n+        self.is_empty()\n     }\n \n     #[inline]\n     pub fn params(&self) -> &[Kind<'tcx>] {\n-        &self.params\n+        // FIXME (dikaiosune) this should be removed, and corresponding compilation errors fixed\n+        self\n     }\n \n     #[inline]\n     pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n-        self.params.iter().filter_map(|k| k.as_type())\n+        self.iter().filter_map(|k| k.as_type())\n     }\n \n     #[inline]\n     pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=&'tcx ty::Region> + 'a {\n-        self.params.iter().filter_map(|k| k.as_region())\n+        self.iter().filter_map(|k| k.as_region())\n     }\n \n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n-        self.params[i].as_type().unwrap_or_else(|| {\n-            bug!(\"expected type for param #{} in {:?}\", i, self.params);\n+        self[i].as_type().unwrap_or_else(|| {\n+            bug!(\"expected type for param #{} in {:?}\", i, self);\n         })\n     }\n \n     #[inline]\n     pub fn region_at(&self, i: usize) -> &'tcx ty::Region {\n-        self.params[i].as_region().unwrap_or_else(|| {\n-            bug!(\"expected region for param #{} in {:?}\", i, self.params);\n+        self[i].as_region().unwrap_or_else(|| {\n+            bug!(\"expected region for param #{} in {:?}\", i, self);\n         })\n     }\n \n@@ -305,27 +298,22 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.lookup_generics(source_ancestor);\n-        tcx.mk_substs(Substs {\n-            params: target_substs.params.iter()\n-                .chain(&self.params[defs.own_count()..]).cloned().collect()\n-        })\n+        Substs::new(tcx, target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let params = self.params.iter().map(|k| k.fold_with(folder)).collect();\n-        folder.tcx().mk_substs(Substs {\n-            params: params\n-        })\n+        let params = self.iter().map(|k| k.fold_with(folder)).collect();\n+        folder.tcx().mk_substs(params)\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_substs(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.params.visit_with(visitor)\n+        self.iter().any(|t| t.visit_with(visitor))\n     }\n }\n \n@@ -340,19 +328,19 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n pub trait Subst<'tcx> : Sized {\n     fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      substs: &Substs<'tcx>) -> Self {\n+                      substs: &[Kind<'tcx>]) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n     fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                               substs: &Substs<'tcx>,\n+                               substs: &[Kind<'tcx>],\n                                span: Option<Span>)\n                                -> Self;\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n     fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                               substs: &Substs<'tcx>,\n+                               substs: &[Kind<'tcx>],\n                                span: Option<Span>)\n                                -> T\n     {\n@@ -371,7 +359,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n \n struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    substs: &'a Substs<'tcx>,\n+    substs: &'a [Kind<'tcx>],\n \n     // The location for which the substitution is performed, if available.\n     span: Option<Span>,\n@@ -404,7 +392,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match *r {\n             ty::ReEarlyBound(data) => {\n-                let r = self.substs.params.get(data.index as usize)\n+                let r = self.substs.get(data.index as usize)\n                             .and_then(|k| k.as_region());\n                 match r {\n                     Some(r) => {\n@@ -461,7 +449,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.params.get(p.idx as usize)\n+        let opt_ty = self.substs.get(p.idx as usize)\n                          .and_then(|k| k.as_type());\n         let ty = match opt_ty {\n             Some(t) => t,\n@@ -475,7 +463,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n                     source_ty,\n                     p.idx,\n                     self.root_ty,\n-                    self.substs.params);\n+                    self.substs);\n             }\n         };\n \n@@ -552,7 +540,7 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        -> ty::TraitRef<'tcx> {\n         let defs = tcx.lookup_generics(trait_id);\n \n-        let params = substs.params[..defs.own_count()].iter().cloned();\n+        let params = substs[..defs.own_count()].iter().cloned();\n         ty::TraitRef {\n             def_id: trait_id,\n             substs: Substs::new(tcx, params)\n@@ -567,7 +555,7 @@ impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n         // Assert there is a Self.\n         trait_ref.substs.type_at(0);\n \n-        let params = trait_ref.substs.params[1..].iter().cloned();\n+        let params = trait_ref.substs[1..].iter().cloned();\n         ty::ExistentialTraitRef {\n             def_id: trait_ref.def_id,\n             substs: Substs::new(tcx, params)\n@@ -587,7 +575,7 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n         assert!(!self_ty.has_escaping_regions());\n \n         self.map_bound(|trait_ref| {\n-            let params = trait_ref.substs.params.iter().cloned();\n+            let params = trait_ref.substs.iter().cloned();\n             let params = iter::once(Kind::from(self_ty)).chain(params);\n             ty::TraitRef {\n                 def_id: trait_ref.def_id,"}, {"sha": "3f3268bb569a303a999616731adc0d04b6c3e1df", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=8e05e7ee3c19a5594b79d67c8390cef78970be7c", "patch": "@@ -28,41 +28,20 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n use rustc_const_eval::fatal_const_eval_err;\n-use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n use type_of;\n use glue;\n use abi::{Abi, FnType};\n use back::symbol_names;\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n     DropGlue(DropGlueKind<'tcx>),\n     Fn(Instance<'tcx>),\n     Static(NodeId)\n }\n \n-impl<'tcx> Hash for TransItem<'tcx> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        match *self {\n-            TransItem::DropGlue(t) => {\n-                0u8.hash(s);\n-                t.hash(s);\n-            },\n-            TransItem::Fn(instance) => {\n-                1u8.hash(s);\n-                instance.def.hash(s);\n-                (instance.substs as *const _ as usize).hash(s);\n-            }\n-            TransItem::Static(node_id) => {\n-                2u8.hash(s);\n-                node_id.hash(s);\n-            }\n-        };\n-    }\n-}\n-\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n@@ -359,7 +338,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             TransItem::Fn(instance) => {\n                 format!(\"Fn({:?}, {})\",\n                          instance.def,\n-                         instance.substs as *const _ as usize)\n+                         instance.substs.as_ptr() as usize)\n             }\n             TransItem::Static(id) => {\n                 format!(\"Static({:?})\", id)"}, {"sha": "d58b8f083e2488fd7e6d910c1e35a8985d05b3d6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8e05e7ee3c19a5594b79d67c8390cef78970be7c", "patch": "@@ -55,7 +55,7 @@ use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -124,7 +124,7 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Same as ty_infer, but with a known type parameter definition.\n     fn ty_infer_for_def(&self,\n                         _def: &ty::TypeParameterDef<'tcx>,\n-                        _substs: &Substs<'tcx>,\n+                        _substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n         self.ty_infer(span)\n     }\n@@ -629,7 +629,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn convert_parenthesized_parameters(&self,\n                                         rscope: &RegionScope,\n-                                        region_substs: &Substs<'tcx>,\n+                                        region_substs: &[Kind<'tcx>],\n                                         data: &hir::ParenthesizedParameterData)\n                                         -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n     {\n@@ -1441,7 +1441,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn ast_ty_arg_to_ty(&self,\n                         rscope: &RegionScope,\n                         def: Option<&ty::TypeParameterDef<'tcx>>,\n-                        region_substs: &Substs<'tcx>,\n+                        region_substs: &[Kind<'tcx>],\n                         ast_ty: &hir::Ty)\n                         -> Ty<'tcx>\n     {"}, {"sha": "95d4416ec3327272886832d64983d944987a06bc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e05e7ee3c19a5594b79d67c8390cef78970be7c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8e05e7ee3c19a5594b79d67c8390cef78970be7c", "patch": "@@ -87,7 +87,7 @@ use hir::def::{Def, CtorKind, PathResolution};\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, Reveal};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -1361,7 +1361,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::TypeParameterDef<'tcx>,\n-                        substs: &Substs<'tcx>,\n+                        substs: &[Kind<'tcx>],\n                         span: Span) -> Ty<'tcx> {\n         self.type_var_for_def(span, ty_param_def, substs)\n     }"}]}