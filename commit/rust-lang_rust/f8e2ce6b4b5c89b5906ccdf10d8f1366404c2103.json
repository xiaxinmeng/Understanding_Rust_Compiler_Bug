{"sha": "f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZTJjZTZiNGI1Yzg5YjU5MDZjY2RmMTBkOGYxMzY2NDA0YzIxMDM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-10-06T08:24:09Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-10-06T08:24:09Z"}, "message": "Implement a lot of atomic intrinsics", "tree": {"sha": "1715f5a675cc5d3db9b2e56c0e1787c2791895ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1715f5a675cc5d3db9b2e56c0e1787c2791895ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103", "html_url": "https://github.com/rust-lang/rust/commit/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42b80c21af14846ef12714448512a12bed84023b", "url": "https://api.github.com/repos/rust-lang/rust/commits/42b80c21af14846ef12714448512a12bed84023b", "html_url": "https://github.com/rust-lang/rust/commit/42b80c21af14846ef12714448512a12bed84023b"}], "stats": {"total": 139, "additions": 110, "deletions": 29}, "files": [{"sha": "e2e2406697471dc7f74e92bddda1a17a2a04ca6c", "filename": "0003-Disable-inline-assembly-in-spin_loop_hint.patch", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103/0003-Disable-inline-assembly-in-spin_loop_hint.patch", "raw_url": "https://github.com/rust-lang/rust/raw/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103/0003-Disable-inline-assembly-in-spin_loop_hint.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/0003-Disable-inline-assembly-in-spin_loop_hint.patch?ref=f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103", "patch": "@@ -0,0 +1,32 @@\n+From 6a5c292f9f9e28de4319f52b05744ed7d8863f76 Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sat, 6 Oct 2018 10:22:16 +0200\n+Subject: [PATCH] Disable inline assembly in spin_loop_hint\n+\n+---\n+ src/libcore/sync/atomic.rs | 2 ++\n+ 1 file changed, 2 insertions(+)\n+\n+diff --git a/src/libcore/sync/atomic.rs b/src/libcore/sync/atomic.rs\n+index f130dbf..31db7a2 100644\n+--- a/src/libcore/sync/atomic.rs\n++++ b/src/libcore/sync/atomic.rs\n+@@ -106,6 +106,7 @@ use fmt;\n+ #[inline]\n+ #[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n+ pub fn spin_loop_hint() {\n++    /*\n+     #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+     unsafe {\n+         asm!(\"pause\" ::: \"memory\" : \"volatile\");\n+@@ -115,6 +116,7 @@ pub fn spin_loop_hint() {\n+     unsafe {\n+         asm!(\"yield\" ::: \"memory\" : \"volatile\");\n+     }\n++    */\n+ }\n+ \n+ /// A boolean type which can be safely shared between threads.\n+-- \n+2.17.1 (Apple Git-112)\n+"}, {"sha": "5e5eaf2a4a2ac8ff66804e055688762c53e144d0", "filename": "0003-Remove-atomics-from-libcore.patch", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/42b80c21af14846ef12714448512a12bed84023b/0003-Remove-atomics-from-libcore.patch", "raw_url": "https://github.com/rust-lang/rust/raw/42b80c21af14846ef12714448512a12bed84023b/0003-Remove-atomics-from-libcore.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/0003-Remove-atomics-from-libcore.patch?ref=42b80c21af14846ef12714448512a12bed84023b", "patch": "@@ -1,23 +0,0 @@\n-From 950bfa9eb7a0eb441601cbe0adc1aefcfab8e031 Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Fri, 27 Jul 2018 19:07:01 +0200\n-Subject: [PATCH] Remove atomics from libcore\n-\n----\n- src/libcore/lib.rs         |    1 -\n- 1 files changed, 1 deletions(-)\n-\n-diff --git a/src/libcore/lib.rs b/src/libcore/lib.rs\n-index 3aa79087db..71fcff2e8b 100644\n---- a/src/libcore/lib.rs\n-+++ b/src/libcore/lib.rs\n-@@ -185,7 +185,6 @@ pub mod borrow;\n- pub mod any;\n- pub mod array;\n- pub mod ascii;\n--pub mod sync;\n- pub mod cell;\n- pub mod char;\n- pub mod panic;\n-2.11.0\n-"}, {"sha": "4f3e0c88195a277964638af79939453636a35043", "filename": "src/intrinsics.rs", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=f8e2ce6b4b5c89b5906ccdf10d8f1366404c2103", "patch": "@@ -58,6 +58,34 @@ macro_rules! intrinsic_match {\n     };\n }\n \n+macro_rules! atomic_binop_return_old {\n+    ($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) => {\n+        let clif_ty = $fx.cton_type($T).unwrap();\n+        let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n+        let new = $fx.bcx.ins().band(old, $src);\n+        $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n+        $ret.write_cvalue($fx, CValue::ByVal(old, $fx.layout_of($T)));\n+    };\n+}\n+\n+macro_rules! atomic_minmax {\n+    ($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) => {\n+        // Read old\n+        let clif_ty = $fx.cton_type($T).unwrap();\n+        let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n+\n+        // Compare\n+        let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n+        let new = $fx.bcx.ins().select(is_eq, old, $src);\n+\n+        // Write new\n+        $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n+\n+        let ret_val = CValue::ByVal(old, $ret.layout());\n+        $ret.write_cvalue($fx, ret_val);\n+    };\n+}\n+\n pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     def_id: DefId,\n@@ -317,6 +345,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             let needs_drop = CValue::const_val(fx, fx.tcx.types.bool, needs_drop);\n             ret.write_cvalue(fx, needs_drop);\n         };\n+\n         _ if intrinsic.starts_with(\"atomic_fence\"), () {};\n         _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {};\n         _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n@@ -329,19 +358,62 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             let dest = CPlace::Addr(ptr, None, val.layout());\n             dest.write_cvalue(fx, val);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, v amount) {\n+        _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n+            // Read old\n             let clif_ty = fx.cton_type(T).unwrap();\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            let new = fx.bcx.ins().iadd(old, amount);\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n             ret.write_cvalue(fx, CValue::ByVal(old, fx.layout_of(T)));\n+\n+            // Write new\n+            let dest = CPlace::Addr(ptr, None, src.layout());\n+            dest.write_cvalue(fx, src);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, v amount) {\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, v test_old, v new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            // Read old\n             let clif_ty = fx.cton_type(T).unwrap();\n             let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            let new = fx.bcx.ins().isub(old, amount);\n+\n+            // Compare\n+            let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n+            let new = fx.bcx.ins().select(is_eq, old, new); // Keep old if not equal to test_old\n+\n+            // Write new\n             fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n-            ret.write_cvalue(fx, CValue::ByVal(old, fx.layout_of(T)));\n+\n+            let ret_val = CValue::ByValPair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n+            ret.write_cvalue(fx, ret_val);\n+        };\n+\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, v amount) {\n+            atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, v amount) {\n+            atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, v src) {\n+            atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, v src) {\n+            atomic_binop_return_old! (fx, bnand<T>(ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, v src) {\n+            atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, v src) {\n+            atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n+        };\n+\n+        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, v src) {\n+            atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, v src) {\n+            atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, v src) {\n+            atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n+        };\n+        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, v src) {\n+            atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n         };\n     }\n "}]}