{"sha": "8e95b3a939d73e1bc0bd65b136dda3e5b2a23425", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOTViM2E5MzlkNzNlMWJjMGJkNjViMTM2ZGRhM2U1YjJhMjM0MjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-12T22:37:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-24T22:18:06Z"}, "message": "rustc: Capture diagnostics from all queries\n\nThis commit alters the `rustc::ty::maps` implementation to ensure that all\noutput diagnostics from the compiler are tracked for the duration of each query.\nThese are then intended to be replayed back the first time a cached value is\nloaded, and otherwise the cache should operate the same as it does today.\n\nCloses #42513", "tree": {"sha": "1e73744431d0bfce780c5d6edeede1557760511d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e73744431d0bfce780c5d6edeede1557760511d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425", "html_url": "https://github.com/rust-lang/rust/commit/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c0558f635861533e2fcb4298ea93250cdfc2c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0558f635861533e2fcb4298ea93250cdfc2c58", "html_url": "https://github.com/rust-lang/rust/commit/2c0558f635861533e2fcb4298ea93250cdfc2c58"}], "stats": {"total": 118, "additions": 90, "deletions": 28}, "files": [{"sha": "f1c624a94e307e7e52100995f591aff839468b05", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=8e95b3a939d73e1bc0bd65b136dda3e5b2a23425", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n+use errors::{Diagnostic, DiagnosticBuilder};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n@@ -32,7 +33,7 @@ use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n-use std::cell::{RefCell, RefMut};\n+use std::cell::{RefCell, RefMut, Cell};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n@@ -188,7 +189,18 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n \n struct QueryMap<D: QueryDescription> {\n     phantom: PhantomData<D>,\n-    map: FxHashMap<D::Key, (D::Value, DepNodeIndex)>,\n+    map: FxHashMap<D::Key, QueryValue<D::Value>>,\n+}\n+\n+struct QueryValue<T> {\n+    value: T,\n+    index: DepNodeIndex,\n+    diagnostics: Option<Box<QueryDiagnostics>>,\n+}\n+\n+struct QueryDiagnostics {\n+    diagnostics: Vec<Diagnostic>,\n+    emitted_diagnostics: Cell<bool>,\n }\n \n impl<M: QueryDescription> QueryMap<M> {\n@@ -618,10 +630,20 @@ macro_rules! define_maps {\n                     )\n                 );\n \n-                if let Some(&(ref result, dep_node_index)) = tcx.maps.$name.borrow().map.get(&key) {\n-                    tcx.dep_graph.read_index(dep_node_index);\n+                if let Some(value) = tcx.maps.$name.borrow().map.get(&key) {\n+                    if let Some(ref d) = value.diagnostics {\n+                        if !d.emitted_diagnostics.get() {\n+                            d.emitted_diagnostics.set(true);\n+                            let handle = tcx.sess.diagnostic();\n+                            for diagnostic in d.diagnostics.iter() {\n+                                DiagnosticBuilder::new_diagnostic(handle, diagnostic.clone())\n+                                    .emit();\n+                            }\n+                        }\n+                    }\n                     profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                    return Ok(f(result));\n+                    tcx.dep_graph.read_index(value.index);\n+                    return Ok(f(&value.value));\n                 }\n                 // else, we are going to run the provider:\n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n@@ -633,36 +655,52 @@ macro_rules! define_maps {\n                     span = key.default_span(tcx)\n                 }\n \n-                let (result, dep_node_index) = tcx.cycle_check(span, Query::$name(key), || {\n+                let res = tcx.cycle_check(span, Query::$name(key), || {\n                     let dep_node = Self::to_dep_node(tcx, &key);\n \n-                    if dep_node.kind.is_anon() {\n-                        tcx.dep_graph.with_anon_task(dep_node.kind, || {\n-                            let provider = tcx.maps.providers[key.map_crate()].$name;\n-                            provider(tcx.global_tcx(), key)\n-                        })\n-                    } else {\n-                        fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n-                                                        key: $K)\n-                                                        -> $V {\n-                            let provider = tcx.maps.providers[key.map_crate()].$name;\n-                            provider(tcx.global_tcx(), key)\n+                    tcx.sess.diagnostic().track_diagnostics(|| {\n+                        if dep_node.kind.is_anon() {\n+                            tcx.dep_graph.with_anon_task(dep_node.kind, || {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            })\n+                        } else {\n+                            fn run_provider<'a, 'tcx, 'lcx>(tcx: TyCtxt<'a, 'tcx, 'lcx>,\n+                                                            key: $K)\n+                                                            -> $V {\n+                                let provider = tcx.maps.providers[key.map_crate()].$name;\n+                                provider(tcx.global_tcx(), key)\n+                            }\n+\n+                            tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n                         }\n-\n-                        tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n-                    }\n+                    })\n                 })?;\n                 profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n+                let ((result, dep_node_index), diagnostics) = res;\n \n                 tcx.dep_graph.read_index(dep_node_index);\n \n+                let value = QueryValue {\n+                    value: result,\n+                    index: dep_node_index,\n+                    diagnostics: if diagnostics.len() == 0 {\n+                        None\n+                    } else {\n+                        Some(Box::new(QueryDiagnostics {\n+                            diagnostics,\n+                            emitted_diagnostics: Cell::new(true),\n+                        }))\n+                    },\n+                };\n+\n                 Ok(f(&tcx.maps\n                          .$name\n                          .borrow_mut()\n                          .map\n                          .entry(key)\n-                         .or_insert((result, dep_node_index))\n-                         .0))\n+                         .or_insert(value)\n+                         .value))\n             }\n \n             pub fn try_get(tcx: TyCtxt<'a, $tcx, 'lcx>, span: Span, key: $K)"}, {"sha": "0a8119893509cb841c0935f39af827ed2207bddd", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=8e95b3a939d73e1bc0bd65b136dda3e5b2a23425", "patch": "@@ -98,7 +98,7 @@ impl<'a> DiagnosticBuilder<'a> {\n             }\n         };\n \n-        self.handler.emitter.borrow_mut().emit(&self);\n+        self.handler.emit_db(&self);\n         self.cancel();\n \n         if is_error {\n@@ -178,10 +178,13 @@ impl<'a> DiagnosticBuilder<'a> {\n                          code: Option<String>,\n                          message: &str)\n                          -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder {\n-            handler,\n-            diagnostic: Diagnostic::new_with_code(level, code, message)\n-        }\n+        let diagnostic = Diagnostic::new_with_code(level, code, message);\n+        DiagnosticBuilder::new_diagnostic(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed diagnostic.\n+    pub fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder { handler, diagnostic }\n     }\n }\n "}, {"sha": "a51e6022350c17954b2e787a4070eacb2aece479", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e95b3a939d73e1bc0bd65b136dda3e5b2a23425/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=8e95b3a939d73e1bc0bd65b136dda3e5b2a23425", "patch": "@@ -35,8 +35,9 @@ use emitter::{Emitter, EmitterWriter};\n \n use std::borrow::Cow;\n use std::cell::{RefCell, Cell};\n-use std::{error, fmt};\n+use std::mem;\n use std::rc::Rc;\n+use std::{error, fmt};\n \n mod diagnostic;\n mod diagnostic_builder;\n@@ -275,6 +276,7 @@ pub struct Handler {\n     treat_err_as_bug: bool,\n     continue_after_error: Cell<bool>,\n     delayed_span_bug: RefCell<Option<(MultiSpan, String)>>,\n+    tracked_diagnostics: RefCell<Option<Vec<Diagnostic>>>,\n }\n \n impl Handler {\n@@ -298,6 +300,7 @@ impl Handler {\n             treat_err_as_bug,\n             continue_after_error: Cell::new(true),\n             delayed_span_bug: RefCell::new(None),\n+            tracked_diagnostics: RefCell::new(None),\n         }\n     }\n \n@@ -547,6 +550,24 @@ impl Handler {\n             self.abort_if_errors();\n         }\n     }\n+\n+    pub fn track_diagnostics<F, R>(&self, f: F) -> (R, Vec<Diagnostic>)\n+        where F: FnOnce() -> R\n+    {\n+        let prev = mem::replace(&mut *self.tracked_diagnostics.borrow_mut(),\n+                                Some(Vec::new()));\n+        let ret = f();\n+        let diagnostics = mem::replace(&mut *self.tracked_diagnostics.borrow_mut(), prev)\n+            .unwrap();\n+        (ret, diagnostics)\n+    }\n+\n+    fn emit_db(&self, db: &DiagnosticBuilder) {\n+        if let Some(ref mut list) = *self.tracked_diagnostics.borrow_mut() {\n+            list.push((**db).clone());\n+        }\n+        self.emitter.borrow_mut().emit(db);\n+    }\n }\n \n "}]}