{"sha": "2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYzMzN2E3ZDZmOWVlMDVjMGU1Y2Y3ZGY2ZmQyNDNhNjQ5YWViNjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-06T01:59:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-06T01:59:40Z"}, "message": "Clarify which errors are format string errors\n\nThere were a few ambiguous error messages which look like they could have\ncropped up from either the rust compiler for the format string parser. To\ndifferentiate, the prefix 'invalid format string' is now added in front of all\nformat string errors.\n\ncc #9970", "tree": {"sha": "e8e858f68a46e099d41480c0457f80d0b15a0bb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8e858f68a46e099d41480c0457f80d0b15a0bb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61", "html_url": "https://github.com/rust-lang/rust/commit/2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fb583be7b0df80c91df026c6a2bde550bc27a7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fb583be7b0df80c91df026c6a2bde550bc27a7c", "html_url": "https://github.com/rust-lang/rust/commit/7fb583be7b0df80c91df026c6a2bde550bc27a7c"}], "stats": {"total": 30, "additions": 15, "deletions": 15}, "files": [{"sha": "401ddfe67f50e67c08dee0a33546d395aba7728b", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=2fc337a7d6f9ee05c0e5cf7df6fd243a649aeb61", "patch": "@@ -180,7 +180,7 @@ impl<'self> Iterator<Piece<'self>> for Parser<'self> {\n             }\n             Some((_, '}')) if self.depth == 0 => {\n                 self.cur.next();\n-                self.err(~\"unmatched `}` found\");\n+                self.err(\"unmatched `}` found\");\n                 None\n             }\n             Some((_, '}')) | None => { None }\n@@ -204,8 +204,8 @@ impl<'self> Parser<'self> {\n     /// Notifies of an error. The message doesn't actually need to be of type\n     /// ~str, but I think it does when this eventually uses conditions so it\n     /// might as well start using it now.\n-    fn err(&self, msg: ~str) {\n-        parse_error::cond.raise(msg);\n+    fn err(&self, msg: &str) {\n+        parse_error::cond.raise(\"invalid format string: \" + msg);\n     }\n \n     /// Optionally consumes the specified character. If the character is not at\n@@ -230,11 +230,11 @@ impl<'self> Parser<'self> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                parse_error::cond.raise(\n+                self.err(\n                     format!(\"expected `{}` but found `{}`\", c, other));\n             }\n             None => {\n-                parse_error::cond.raise(\n+                self.err(\n                     format!(\"expected `{}` but string was terminated\", c));\n             }\n         }\n@@ -267,7 +267,7 @@ impl<'self> Parser<'self> {\n                 c\n             }\n             None => {\n-                self.err(~\"expected an escape sequence, but format string was \\\n+                self.err(\"expected an escape sequence, but format string was \\\n                            terminated\");\n                 ' '\n             }\n@@ -411,7 +411,7 @@ impl<'self> Parser<'self> {\n                 Some(self.plural())\n             }\n             \"\" => {\n-                self.err(~\"expected method after comma\");\n+                self.err(\"expected method after comma\");\n                 return None;\n             }\n             method => {\n@@ -430,7 +430,7 @@ impl<'self> Parser<'self> {\n             self.ws();\n             let selector = self.word();\n             if selector == \"\" {\n-                self.err(~\"cannot have an empty selector\");\n+                self.err(\"cannot have an empty selector\");\n                 break\n             }\n             self.must_consume('{');\n@@ -440,7 +440,7 @@ impl<'self> Parser<'self> {\n             self.must_consume('}');\n             if selector == \"other\" {\n                 if !other.is_none() {\n-                    self.err(~\"multiple `other` statements in `select\");\n+                    self.err(\"multiple `other` statements in `select\");\n                 }\n                 other = Some(pieces);\n             } else {\n@@ -456,7 +456,7 @@ impl<'self> Parser<'self> {\n         let other = match other {\n             Some(arm) => { arm }\n             None => {\n-                self.err(~\"`select` statement must provide an `other` case\");\n+                self.err(\"`select` statement must provide an `other` case\");\n                 ~[]\n             }\n         };\n@@ -488,7 +488,7 @@ impl<'self> Parser<'self> {\n                             match self.integer() {\n                                 Some(i) => { offset = Some(i); }\n                                 None => {\n-                                    self.err(~\"offset must be an integer\");\n+                                    self.err(\"offset must be an integer\");\n                                 }\n                             }\n                         }\n@@ -506,8 +506,8 @@ impl<'self> Parser<'self> {\n                 match self.integer() {\n                     Some(i) => Right(i),\n                     None => {\n-                        self.err(~\"plural `=` selectors must be followed by an \\\n-                                   integer\");\n+                        self.err(\"plural `=` selectors must be followed by an \\\n+                                  integer\");\n                         Right(0)\n                     }\n                 }\n@@ -538,7 +538,7 @@ impl<'self> Parser<'self> {\n             self.must_consume('}');\n             if isother {\n                 if !other.is_none() {\n-                    self.err(~\"multiple `other` statements in `select\");\n+                    self.err(\"multiple `other` statements in `select\");\n                 }\n                 other = Some(pieces);\n             } else {\n@@ -554,7 +554,7 @@ impl<'self> Parser<'self> {\n         let other = match other {\n             Some(arm) => { arm }\n             None => {\n-                self.err(~\"`plural` statement must provide an `other` case\");\n+                self.err(\"`plural` statement must provide an `other` case\");\n                 ~[]\n             }\n         };"}]}