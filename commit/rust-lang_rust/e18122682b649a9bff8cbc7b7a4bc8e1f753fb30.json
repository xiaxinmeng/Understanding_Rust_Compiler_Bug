{"sha": "e18122682b649a9bff8cbc7b7a4bc8e1f753fb30", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODEyMjY4MmI2NDlhOWJmZjhjYmM3YjdhNGJjOGUxZjc1M2ZiMzA=", "commit": {"author": {"name": "christopherdumas", "email": "christopherdumas@me.com", "date": "2015-09-10T16:48:04Z"}, "committer": {"name": "christopherdumas", "email": "christopherdumas@me.com", "date": "2015-09-10T16:48:04Z"}, "message": "Adapted @BurtSushi's blog post for the error handling chapter, rewrite the case study.", "tree": {"sha": "813d2567f29ff4338705f06548bd3a175b3a02fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/813d2567f29ff4338705f06548bd3a175b3a02fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e18122682b649a9bff8cbc7b7a4bc8e1f753fb30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e18122682b649a9bff8cbc7b7a4bc8e1f753fb30", "html_url": "https://github.com/rust-lang/rust/commit/e18122682b649a9bff8cbc7b7a4bc8e1f753fb30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e18122682b649a9bff8cbc7b7a4bc8e1f753fb30/comments", "author": null, "committer": null, "parents": [{"sha": "8115b397f6df6a9f2b109dcadb31b21535f976bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8115b397f6df6a9f2b109dcadb31b21535f976bd", "html_url": "https://github.com/rust-lang/rust/commit/8115b397f6df6a9f2b109dcadb31b21535f976bd"}], "stats": {"total": 2188, "additions": 2007, "deletions": 181}, "files": [{"sha": "51343f925c7cf776b1295f30f235145ff2b19402", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 2007, "deletions": 181, "changes": 2188, "blob_url": "https://github.com/rust-lang/rust/blob/e18122682b649a9bff8cbc7b7a4bc8e1f753fb30/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/e18122682b649a9bff8cbc7b7a4bc8e1f753fb30/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=e18122682b649a9bff8cbc7b7a4bc8e1f753fb30", "patch": "@@ -1,308 +1,2134 @@\n % Error Handling\n \n-> The best-laid plans of mice and men  \n-> Often go awry\n->\n-> \"Tae a Moose\", Robert Burns\n+Like most programming languages, Rust encourages the programmer to handle\n+errors in a particular way. Generally speaking, error handling is divided into\n+two broad categories: exceptions and return values. Rust opts for return\n+values.\n+\n+In this chapter, we intend to provide a comprehensive treatment of how to deal\n+with errors in Rust. More than that, we will attempt to introduce error handling\n+one piece at a time so that you'll come away with a solid working knowledge of\n+how everything fits together.\n+\n+When done na\u00efvely, error handling in Rust can be verbose and annoying. This\n+chapter will explore those stumbling blocks and demonstrate how to use the\n+standard library to make error handling concise and ergonomic.\n+\n+## Table of Contents\n+\n+This chapter is very long, mostly because we start at the very beginning with\n+sum types and combinators, and try to motivate the way Rust does error handling\n+incrementally. As such, programmers with experience in other expressive type\n+systems may want to jump around.\n+\n+* [The Basics](#the-basics)\n+    * [Unwrapping explained](#unwrapping-explained)\n+    * [The `Option` type](#the-option-type)\n+        * [Composing `Option<T>` values](#composing-option-t-values)\n+    * [The `Result` type](#the-result-type)\n+        * [Parsing integers](#parsing-integers)\n+        * [The `Result` type alias idiom](#the-result-type-alias-idiom)\n+    * [A brief interlude: unwrapping isn't evil](#a-brief-interlude-unwrapping-isn-t-evil)\n+* [Working with multiple error types](#working-with-multiple-error-types)\n+    * [Composing `Option` and `Result`](#composing-option-and-result)\n+    * [The limits of combinators](#the-limits-of-combinators)\n+    * [Early returns](#early-returns)\n+    * [The `try!` macro](#the-try-macro)\n+    * [Defining your own error type](#defining-your-own-error-type)\n+* [Standard library traits used for error handling](#standard-library-traits-used-for-error-handling)\n+    * [The `Error` trait](#the-error-trait)\n+    * [The `From` trait](#the-from-trait)\n+    * [The real `try!` macro](#the-real-try-macro)\n+    * [Composing custom error types](#composing-custom-error-types)\n+    * [Advice for library writers](#advice-for-library-writers)\n+* [Case study: A program to read population data](#case-study-a-program-to-read-population-data)\n+    * [It's on Github](#it-s-on-github)\n+    * [Initial setup](#initial-setup)\n+    * [Argument parsing](#argument-parsing)\n+    * [Writing the logic](#writing-the-logic)\n+    * [Error handling with `Box<Error>`](#error-handling-with-box-error)\n+    * [Reading from stdin](#reading-from-stdin)\n+    * [Error handling with a custom type](#error-handling-with-a-custom-type)\n+    * [Adding functionality](#adding-functionality)\n+* [The short story](#the-short-story)\n+\n+## The Basics\n+\n+You can think of error handling as using *case analysis* to determine whether\n+a computation was successful or not. As you will see, the key to ergonomic error\n+handling is reducing the amount of explicit case analysis the programmer has to\n+do while keeping code composable.\n+\n+Keeping code composable is important, because without that requirement, we\n+could [`panic`](../std/macro.panic!.html) whenever we\n+come across something unexpected. (`panic` causes the current task to unwind,\n+and in most cases, the entire program aborts.) Here's an example:\n+\n+```rust,should_panic\n+// Guess a number between 1 and 10.\n+// If it matches the number we had in mind, return true. Else, return false.\n+fn guess(n: i32) -> bool {\n+    if n < 1 || n > 10 {\n+        panic!(\"Invalid number: {}\", n);\n+    }\n+    n == 5\n+}\n \n-Sometimes, things just go wrong. It's important to have a plan for when the\n-inevitable happens. Rust has rich support for handling errors that may (let's\n-be honest: will) occur in your programs.\n+fn main() {\n+    guess(11);\n+}\n+```\n \n-There are two main kinds of errors that can occur in your programs: failures,\n-and panics. Let's talk about the difference between the two, and then discuss\n-how to handle each. Then, we'll discuss upgrading failures to panics.\n+If you try running this code, the program will crash with a message like this:\n \n-# Failure vs. Panic\n+```text\n+thread '<main>' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5\n+```\n \n-Rust uses two terms to differentiate between two forms of error: failure, and\n-panic. A *failure* is an error that can be recovered from in some way. A\n-*panic* is an error that cannot be recovered from.\n+Here's another example that is slightly less contrived. A program that accepts\n+an integer as an argument, doubles it and prints it.\n \n-What do we mean by \"recover\"? Well, in most cases, the possibility of an error\n-is expected. For example, consider the `parse` function:\n+```rust,should_panic\n+use std::env;\n \n-```ignore\n-\"5\".parse();\n+fn main() {\n+    let mut argv = env::args();\n+    let arg: String = argv.nth(1).unwrap(); // error 1\n+    let n: i32 = arg.parse().unwrap(); // error 2\n+    println!(\"{}\", 2 * n);\n+}\n ```\n \n-This method converts a string into another type. But because it's a string, you\n-can't be sure that the conversion actually works. For example, what should this\n-convert to?\n+If you give this program zero arguments (error 1) or if the first argument\n+isn't an integer (error 2), the program will panic just like in the first\n+example.\n+\n+You can think of this style of error handling as similar to a bull running\n+through a china shop. The bull will get to where it wants to go, but it will\n+trample everything in the process.\n+\n+### Unwrapping explained\n+\n+In the previous example, we claimed\n+that the program would simply panic if it reached one of the two error\n+conditions, yet, the program does not include an explicit call to `panic` like\n+the first example. This is because the\n+panic is embedded in the calls to `unwrap`.\n+\n+To \u201cunwrap\u201d something in Rust is to say, \u201cGive me the result of the\n+computation, and if there was an error, just panic and stop the program.\u201d\n+It would be better if we just showed the code for unwrapping because it is so\n+simple, but to do that, we will first need to explore the `Option` and `Result`\n+types. Both of these types have a method called `unwrap` defined on them.\n+\n+### The `Option` type\n \n-```ignore\n-\"hello5world\".parse();\n+The `Option` type is\n+[defined in the standard library][1]: \n+\n+```rust\n+enum Option<T> {\n+    None,\n+    Some(T),\n+}\n ```\n \n-This won't work. So we know that this function will only work properly for some\n-inputs. It's expected behavior. We call this kind of error a *failure*.\n+The `Option` type is a way to use Rust's type system to express the\n+*possibility of absence*. Encoding the possibility of absence into the type\n+system is an important concept because it will cause the compiler to force the\n+programmer to handle that absence. Let's take a look at an example that tries\n+to find a character in a string:\n \n-On the other hand, sometimes, there are errors that are unexpected, or which\n-we cannot recover from. A classic example is an `assert!`:\n+```rust\n+// Searches `haystack` for the Unicode character `needle`. If one is found, the\n+// byte offset of the character is returned. Otherwise, `None` is returned.\n+fn find(haystack: &str, needle: char) -> Option<usize> {\n+    for (offset, c) in haystack.char_indices() {\n+        if c == needle {\n+            return Some(offset);\n+        }\n+    }\n+    None\n+}\n+```\n+\n+Notice that when this function finds a matching character, it doen't just\n+return the `offset`. Instead, it returns `Some(offset)`. `Some` is a variant or\n+a *value constructor* for the `Option` type. You can think of it as a function\n+with the type `fn<T>(value: T) -> Option<T>`. Correspondingly, `None` is also a\n+value constructor, except it has no arguments. You can think of `None` as a\n+function with the type `fn<T>() -> Option<T>`.\n+\n+This might seem like much ado about nothing, but this is only half of the\n+story. The other half is *using* the `find` function we've written. Let's try\n+to use it to find the extension in a file name.\n \n ```rust\n-# let x = 5;\n-assert!(x == 5);\n+# fn find(_: &str, _: char) -> Option<usize> { None }\n+fn main() {\n+    let file_name = \"foobar.rs\";\n+    match find(file_name, '.') {\n+        None => println!(\"No file extension found.\"),\n+        Some(i) => println!(\"File extension: {}\", &file_name[i+1..]),\n+    }\n+}\n ```\n \n-We use `assert!` to declare that something is true. If it's not true, something\n-is very wrong. Wrong enough that we can't continue with things in the current\n-state. Another example is using the `unreachable!()` macro:\n+This code uses [pattern matching][1] to do *case\n+analysis* on the `Option<usize>` returned by the `find` function. In fact, case\n+analysis is the only way to get at the value stored inside an `Option<T>`. This\n+means that you, as the programmer, must handle the case when an `Option<T>` is\n+`None` instead of `Some(t)`.\n \n-```rust,ignore\n-use Event::NewRelease;\n+But wait, what about `unwrap` used in [`unwrap-double`](#code-unwrap-double)?\n+There was no case analysis there! Instead, the case analysis was put inside the\n+`unwrap` method for you. You could define it yourself if you want:\n \n-enum Event {\n-    NewRelease,\n+```rust\n+enum Option<T> {\n+    None,\n+    Some(T),\n }\n \n-fn probability(_: &Event) -> f64 {\n-    // real implementation would be more complex, of course\n-    0.95\n+impl<T> Option<T> {\n+    fn unwrap(self) -> T {\n+        match self {\n+            Option::Some(val) => val,\n+            Option::None =>\n+              panic!(\"called `Option::unwrap()` on a `None` value\"),\n+        }\n+    }\n }\n+```\n+\n+The `unwrap` method *abstracts away the case analysis*. This is precisely the thing\n+that makes `unwrap` ergonomic to use. Unfortunately, that `panic!` means that\n+`unwrap` is not composable: it is the bull in the china shop.\n+\n+#### Composing `Option<T>` values\n+\n+In [`option-ex-string-find`](#code-option-ex-string-find-2)\n+we saw how to use `find` to discover the extension in a file name. Of course,\n+not all file names have a `.` in them, so it's possible that the file name has\n+no extension. This *possibility of absence* is encoded into the types using\n+`Option<T>`. In other words, the compiler will force us to address the\n+possibility that an extension does not exist. In our case, we just print out a\n+message saying as such.\n+\n+Getting the extension of a file name is a pretty common operation, so it makes\n+sense to put it into a function:\n \n-fn descriptive_probability(event: Event) -> &'static str {\n-    match probability(&event) {\n-        1.00 => \"certain\",\n-        0.00 => \"impossible\",\n-        0.00 ... 0.25 => \"very unlikely\",\n-        0.25 ... 0.50 => \"unlikely\",\n-        0.50 ... 0.75 => \"likely\",\n-        0.75 ... 1.00 => \"very likely\",\n+```rust\n+# fn find(_: &str, _: char) -> Option<usize> { None }\n+// Returns the extension of the given file name, where the extension is defined\n+// as all characters proceding the first `.`.\n+// If `file_name` has no `.`, then `None` is returned.\n+fn extension_explicit(file_name: &str) -> Option<&str> {\n+    match find(file_name, '.') {\n+        None => None,\n+        Some(i) => Some(&file_name[i+1..]),\n     }\n }\n+```\n+\n+(Pro-tip: don't use this code. Use the\n+[`extension`](../std/path/struct.Path.html#method.extension)\n+method in the standard library instead.)\n+\n+The code stays simple, but the important thing to notice is that the type of\n+`find` forces us to consider the possibility of absence. This is a good thing\n+because it means the compiler won't let us accidentally forget about the case\n+where a file name doesn't have an extension. On the other hand, doing explicit\n+case analysis like we've done in `extension_explicit` every time can get a bit\n+tiresome.\n \n+In fact, the case analysis in `extension_explicit` follows a very common\n+pattern: *map* a function on to the value inside of an `Option<T>`, unless the\n+option is `None`, in which case, just return `None`.\n+\n+Rust has parametric polymorphism, so it is very easy to define a combinator\n+that abstracts this pattern:\n+\n+```rust\n+fn map<F, T, A>(option: Option<T>, f: F) -> Option<A> where F: FnOnce(T) -> A {\n+    match option {\n+        None => None,\n+        Some(value) => Some(f(value)),\n+    }\n+}\n+```\n+\n+Indeed, `map` is [defined as a method][2] on `Option<T>` in the standard library.\n+\n+Armed with our new combinator, we can rewrite our `extension_explicit` method\n+to get rid of the case analysis:\n+\n+```rust\n+# fn find(_: &str, _: char) -> Option<usize> { None }\n+// Returns the extension of the given file name, where the extension is defined\n+// as all characters proceding the first `.`.\n+// If `file_name` has no `.`, then `None` is returned.\n+fn extension(file_name: &str) -> Option<&str> {\n+    find(file_name, '.').map(|i| &file_name[i+1..])\n+}\n+```\n+\n+One other pattern that we find is very common is assigning a default value to\n+the case when an `Option` value is `None`. For example, maybe your program\n+assumes that the extension of a file is `rs` even if none is present. As you\n+might imagine, the case analysis for this is not specific to file\n+extensions - it can work with any `Option<T>`:\n+\n+```rust\n+fn unwrap_or<T>(option: Option<T>, default: T) -> T {\n+    match option {\n+        None => default,\n+        Some(value) => value,\n+    }\n+}\n+```\n+\n+The trick here is that the default value must have the same type as the value\n+that might be inside the `Option<T>`. Using it is dead simple in our case:\n+\n+```rust\n+# fn find(haystack: &str, needle: char) -> Option<usize> {\n+#     for (offset, c) in haystack.char_indices() {\n+#         if c == needle {\n+#             return Some(offset);\n+#         }\n+#     }\n+#     None\n+# }\n+#\n+# fn extension(file_name: &str) -> Option<&str> {\n+#     find(file_name, '.').map(|i| &file_name[i+1..])\n+# }\n fn main() {\n-    println!(\"{}\", descriptive_probability(NewRelease));\n+    assert_eq!(extension(\"foobar.csv\").unwrap_or(\"rs\"), \"csv\");\n+    assert_eq!(extension(\"foobar\").unwrap_or(\"rs\"), \"rs\");\n }\n ```\n \n-This will give us an error:\n+(Note that `unwrap_or` is [defined as a method][3] on `Option<T>` in the\n+standard library, so we use that here instead of the free-standing function we\n+defined above. Don't forget to check out the more general [`unwrap_or_else`][4]\n+method.)\n+\n+There is one more combinator that we think is worth paying special attention to:\n+`and_then`. It makes it easy to compose distinct computations that admit the\n+*possibility of absence*. For example, much of the code in this section is\n+about finding an extension given a file name. In order to do this, you first\n+need the file name which is typically extracted from a file *path*. While most\n+file paths have a file name, not *all* of them do. For example, `.`, `..` or\n+`/`.\n+\n+So, we are tasked with the challenge of finding an extension given a file\n+*path*. Let's start with explicit case analysis:\n+\n+```rust\n+# fn extension(file_name: &str) -> Option<&str> { None }\n+fn file_path_ext_explicit(file_path: &str) -> Option<&str> {\n+    match file_name(file_path) {\n+        None => None,\n+        Some(name) => match extension(name) {\n+            None => None,\n+            Some(ext) => Some(ext),\n+        }\n+    }\n+}\n+\n+fn file_name(file_path: &str) -> Option<&str> {\n+  // implementation elided\n+  unimplemented!()\n+}\n+```\n+\n+You might think that we could just use the `map` combinator to reduce the case\n+analysis, but its type doesn't quite fit. Namely, `map` takes a function that\n+does something only with the inner value. The result of that function is then\n+*always* [rewrapped with `Some`](#code-option-map). Instead, we need something\n+like `map`, but which allows the caller to return another `Option`. Its generic\n+implementation is even simpler than `map`:\n+\n+```rust\n+fn and_then<F, T, A>(option: Option<T>, f: F) -> Option<A>\n+        where F: FnOnce(T) -> Option<A> {\n+    match option {\n+        None => None,\n+        Some(value) => f(value),\n+    }\n+}\n+```\n+\n+Now we can rewrite our `file_path_ext` function without explicit case analysis:\n+\n+```rust\n+# fn extension(file_name: &str) -> Option<&str> { None }\n+# fn file_name(file_path: &str) -> Option<&str> { None }\n+fn file_path_ext(file_path: &str) -> Option<&str> {\n+    file_name(file_path).and_then(extension)\n+}\n+```\n+\n+The `Option` type has many other combinators [defined in the standard\n+library][5]. It is a good idea to skim this list and familiarize\n+yourself with what's available\u2014they can often reduce case analysis\n+for you. Familiarizing yourself with these combinators will pay\n+dividends because many of them are also defined (with similar\n+semantics) for `Result`, which we will talk about next.\n+\n+Combinators make using types like `Option` ergonomic because they reduce\n+explicit case analysis. They are also composable because they permit the caller\n+to handle the possibility of absence in their own way. Methods like `unwrap`\n+remove choices because they will panic if `Option<T>` is `None`.\n+### The `Result` type\n+\n+The `Result` type is also\n+[defined in the standard library][6]:\n+\n+```rust\n+enum Result<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+```\n+\n+The `Result` type is a richer version of `Option`. Instead of expressing the\n+possibility of *absence* like `Option` does, `Result` expresses the possibility\n+of *error*. Usually, the *error* is used to explain why the result of some\n+computation failed. This is a strictly more general form of `Option`. Consider\n+the following type alias, which is semantically equivalent to the real\n+`Option<T>` in every way:\n+\n+```rust\n+type Option<T> = Result<T, ()>;\n+```\n+\n+This fixes the second type parameter of `Result` to always be `()` (pronounced\n+\u201cunit\u201d or \u201cempty tuple\u201d). Exactly one value inhabits the `()` type: `()`. (Yup,\n+the type and value level terms have the same notation!)\n+\n+The `Result` type is a way of representing one of two possible outcomes in a\n+computation. By convention, one outcome is meant to be expected or \u201c`Ok`\u201d while\n+the other outcome is meant to be unexpected or \u201c`Err`\u201d.\n+\n+Just like `Option`, the `Result` type also has an\n+[`unwrap` method\n+defined][7]\n+in the standard library. Let's define it:\n+\n+```rust\n+# enum Result<T, E> { Ok(T), Err(E) }\n+impl<T, E: ::std::fmt::Debug> Result<T, E> {\n+    fn unwrap(self) -> T {\n+        match self {\n+            Result::Ok(val) => val,\n+            Result::Err(err) =>\n+              panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", err),\n+        }\n+    }\n+}\n+```\n+\n+This is effectively the same as our [definition for\n+`Option::unwrap`](#code-option-def-unwrap), except it includes the\n+error value in the `panic!` message. This makes debugging easier, but\n+it also requires us to add a [`Debug`][8] constraint on the `E` type\n+parameter (which represents our error type). Since the vast majority\n+of types should satisfy the `Debug` constraint, this tends to work out\n+in practice. (`Debug` on a type simply means that there's a reasonable\n+way to print a human readable description of values with that type.)\n+\n+OK, let's move on to an example.\n+\n+#### Parsing integers\n+\n+The Rust standard library makes converting strings to integers dead simple.\n+It's so easy in fact, that it is very tempting to write something like the\n+following:\n+\n+```rust\n+fn double_number(number_str: &str) -> i32 {\n+    2 * number_str.parse::<i32>().unwrap()\n+}\n+\n+fn main() {\n+    let n: i32 = double_number(\"10\");\n+    assert_eq!(n, 20);\n+}\n+```\n+\n+At this point, you should be skeptical of calling `unwrap`. For example, if\n+the string doesn't parse as a number, you'll get a panic:\n \n ```text\n-error: non-exhaustive patterns: `_` not covered [E0004]\n+thread '<main>' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729\n+```\n+\n+This is rather unsightly, and if this happened inside a library you're\n+using, you might be understandably annoyed. Instead, we should try to\n+handle the error in our function and let the caller decide what to\n+do. This means changing the return type of `double_number`. But to\n+what? Well, that requires looking at the signature of the [`parse`\n+method][9] in the standard library:\n+\n+```rust,ignore\n+impl str {\n+    fn parse<F: FromStr>(&self) -> Result<F, F::Err>;\n+}\n ```\n \n-While we know that we've covered all possible cases, Rust can't tell. It\n-doesn't know that probability is between 0.0 and 1.0. So we add another case:\n+Hmm. So we at least know that we need to use a `Result`. Certainly, it's\n+possible that this could have returned an `Option`. After all, a string either\n+parses as a number or it doesn't, right? That's certainly a reasonable way to\n+go, but the implementation internally distinguishes *why* the string didn't\n+parse as an integer. (Whether it's an empty string, an invalid digit, too big\n+or too small.) Therefore, using a `Result` makes sense because we want to\n+provide more information than simply \u201cabsence.\u201d We want to say *why* the\n+parsing failed. You should try to emulate this line of reasoning when faced\n+with a choice between `Option` and `Result`. If you can provide detailed error\n+information, then you probably should. (We'll see more on this later.)\n+\n+OK, but how do we write our return type? The `parse` method as defined\n+above is generic over all the different number types defined in the\n+standard library. We could (and probably should) also make our\n+function generic, but let's favor explicitness for the moment. We only\n+care about `i32`, so we need to [find its implementation of\n+`FromStr`](../std/primitive.i32.html) (do a `CTRL-F` in your browser\n+for \u201cFromStr\u201d) and look at its [associated type][10] `Err`. We did\n+this so we can find the concrete error type. In this case, it's\n+[`std::num::ParseIntError`](../std/num/struct.ParseIntError.html).\n+Finally, we can rewrite our function:\n \n ```rust\n-use Event::NewRelease;\n+use std::num::ParseIntError;\n \n-enum Event {\n-    NewRelease,\n+fn double_number(number_str: &str) -> Result<i32, ParseIntError> {\n+    match number_str.parse::<i32>() {\n+        Ok(n) => Ok(2 * n),\n+        Err(err) => Err(err),\n+    }\n }\n \n-fn probability(_: &Event) -> f64 {\n-    // real implementation would be more complex, of course\n-    0.95\n+fn main() {\n+    match double_number(\"10\") {\n+        Ok(n) => assert_eq!(n, 20),\n+        Err(err) => println!(\"Error: {:?}\", err),\n+    }\n }\n+```\n+\n+This is a little better, but now we've written a lot more code! The case\n+analysis has once again bitten us.\n \n-fn descriptive_probability(event: Event) -> &'static str {\n-    match probability(&event) {\n-        1.00 => \"certain\",\n-        0.00 => \"impossible\",\n-        0.00 ... 0.25 => \"very unlikely\",\n-        0.25 ... 0.50 => \"unlikely\",\n-        0.50 ... 0.75 => \"likely\",\n-        0.75 ... 1.00 => \"very likely\",\n-        _ => unreachable!()\n+Combinators to the rescue! Just like `Option`, `Result` has lots of combinators\n+defined as methods. There is a large intersection of common combinators between\n+`Result` and `Option`. In particular, `map` is part of that intersection:\n+\n+```rust\n+use std::num::ParseIntError;\n+\n+fn double_number(number_str: &str) -> Result<i32, ParseIntError> {\n+    number_str.parse::<i32>().map(|n| 2 * n)\n+}\n+\n+fn main() {\n+    match double_number(\"10\") {\n+        Ok(n) => assert_eq!(n, 20),\n+        Err(err) => println!(\"Error: {:?}\", err),\n     }\n }\n+```\n+\n+The usual suspects are all there for `Result`, including\n+[`unwrap_or`](../std/result/enum.Result.html#method.unwrap_or) and\n+[`and_then`](../std/result/enum.Result.html#method.and_then).\n+Additionally, since `Result` has a second type parameter, there are\n+combinators that affect only the error type, such as\n+[`map_err`](../std/result/enum.Result.html#method.map_err) (instead of\n+`map`) and [`or_else`](../std/result/enum.Result.html#method.or_else)\n+(instead of `and_then`). #### The `Result` type alias idiom\n+\n+In the standard library, you may frequently see types like\n+`Result<i32>`. But wait, [we defined `Result`](#code-result-def-1) to\n+have two type parameters. How can we get away with only specifying\n+one? The key is to define a `Result` type alias that *fixes* one of\n+the type parameters to a particular type. Usually the fixed type is\n+the error type. For example, our previous example parsing integers\n+could be rewritten like this:\n+\n+```rust\n+use std::num::ParseIntError;\n+use std::result;\n+\n+type Result<T> = result::Result<T, ParseIntError>;\n+\n+fn double_number(number_str: &str) -> Result<i32> {\n+    unimplemented!();\n+}\n+```\n+\n+Why would we do this? Well, if we have a lot of functions that could return\n+`ParseIntError`, then it's much more convenient to define an alias that always\n+uses `ParseIntError` so that we don't have to write it out all the time.\n+\n+The most prominent place this idiom is used in the standard library is\n+with [`io::Result`](../std/io/type.Result.html). Typically, one writes\n+`io::Result<T>`, which makes it clear that you're using the `io`\n+module's type alias instead of the plain definition from\n+`std::result`. (This idiom is also used for\n+[`fmt::Result`](../std/fmt/type.Result.html).)\n+\n+### A brief interlude:\n+\n+unwrapping isn't evil\n+\n+If you've been following along, you might have noticed that I've taken a pretty\n+hard line against calling methods like `unwrap` that could `panic` and abort\n+your program. *Generally speaking*, this is good advice.\n+\n+However, `unwrap` can still be used judiciously. What exactly justifies use of\n+`unwrap` is somewhat of a grey area and reasonable people can disagree. I'll\n+summarize some of my *opinions* on the matter.\n+\n+* **In examples and quick 'n' dirty code.** Sometimes you're writing examples\n+  or a quick program, and error handling simply isn't important. Beating the\n+  convenience of `unwrap` can be hard in such scenarios, so it is very\n+  appealing.\n+* **When panicking indicates a bug in the program.** When the invariants of\n+  your code should prevent a certain case from happening (like, say, popping\n+  from an empty stack), then panicking can be permissible. This is because it\n+  exposes a bug in your program. This can be explicit, like from an `assert!`\n+  failing, or it could be because your index into an array was out of bounds.\n+\n+This is probably not an exhaustive list. Moreover, when using an\n+`Option`, it is often better to use its\n+[`expect`](../std/option/enum.Option.html#method.expect)\n+method. `expect` does exactly the same thing as `unwrap`, except it\n+prints a message you give to `expect`. This makes the resulting panic\n+a bit nicer to deal with, since it will show your message instead of\n+\u201ccalled unwrap on a `None` value.\u201d\n+\n+My advice boils down to this: use good judgment. There's a reason why the words\n+\u201cnever do X\u201d or \u201cY is considered harmful\u201d don't appear in my writing. There are\n+trade offs to all things, and it is up to you as the programmer to determine\n+what is acceptable for your use cases. My goal is only to help you evaluate\n+trade offs as accurately as possible.\n+\n+Now that we've covered the basics of error handling in Rust, and\n+explained unwrapping, let's start exploring more of the standard\n+library.\n+\n+## Working with multiple error types\n+\n+Thus far, we've looked at error handling where everything was either an\n+`Option<T>` or a `Result<T, SomeError>`. But what happens when you have both an\n+`Option` and a `Result`? Or what if you have a `Result<T, Error1>` and a\n+`Result<T, Error2>`? Handling *composition of distinct error types* is the next\n+challenge in front of us, and it will be the major theme throughout the rest of\n+this chapter.\n+\n+### Composing `Option` and `Result`\n+\n+So far, I've talked about combinators defined for `Option` and combinators\n+defined for `Result`. We can use these combinators to compose results of\n+different computations without doing explicit case analysis.\n+\n+Of course, in real code, things aren't always as clean. Sometimes you have a\n+mix of `Option` and `Result` types. Must we resort to explicit case analysis,\n+or can we continue using combinators?\n+\n+For now, let's revisit one of the first examples in this chapter:\n+\n+```rust,should_panic\n+use std::env;\n+\n+fn main() {\n+    let mut argv = env::args();\n+    let arg: String = argv.nth(1).unwrap(); // error 1\n+    let n: i32 = arg.parse().unwrap(); // error 2\n+    println!(\"{}\", 2 * n);\n+}\n+```\n+\n+Given our new found knowledge of `Option`, `Result` and their various\n+combinators, we should try to rewrite this so that errors are handled properly\n+and the program doesn't panic if there's an error.\n+\n+The tricky aspect here is that `argv.nth(1)` produces an `Option` while\n+`arg.parse()` produces a `Result`. These aren't directly composable. When faced\n+with both an `Option` and a `Result`, the solution is *usually* to convert the\n+`Option` to a `Result`. In our case, the absence of a command line parameter\n+(from `env::args()`) means the user didn't invoke the program correctly. We\n+could just use a `String` to describe the error. Let's try:\n+\n+```rust\n+use std::env;\n+\n+fn double_arg(mut argv: env::Args) -> Result<i32, String> {\n+    argv.nth(1)\n+        .ok_or(\"Please give at least one argument\".to_owned())\n+        .and_then(|arg| arg.parse::<i32>().map_err(|err| err.to_string()))\n+}\n+\n+fn main() {\n+    match double_arg(env::args()) {\n+        Ok(n) => println!(\"{}\", n),\n+        Err(err) => println!(\"Error: {}\", err),\n+    }\n+}\n+```\n+\n+There are a couple new things in this example. The first is the use of the\n+[`Option::ok_or`](../std/option/enum.Option.html#method.ok_or)\n+combinator. This is one way to convert an `Option` into a `Result`. The\n+conversion requires you to specify what error to use if `Option` is `None`.\n+Like the other combinators we've seen, its definition is very simple:\n+\n+```rust\n+fn ok_or<T, E>(option: Option<T>, err: E) -> Result<T, E> {\n+    match option {\n+        Some(val) => Ok(val),\n+        None => Err(err),\n+    }\n+}\n+```\n+\n+The other new combinator used here is\n+[`Result::map_err`](../std/result/enum.Result.html#method.map_err).\n+This is just like `Result::map`, except it maps a function on to the *error*\n+portion of a `Result` value. If the `Result` is an `Ok(...)` value, then it is\n+returned unmodified.\n+\n+We use `map_err` here because it is necessary for the error types to remain\n+the same (because of our use of `and_then`). Since we chose to convert the\n+`Option<String>` (from `argv.nth(1)`) to a `Result<String, String>`, we must\n+also convert the `ParseIntError` from `arg.parse()` to a `String`.\n+\n+### The limits of combinators\n+\n+Doing IO and parsing input is a very common task, and it's one that I\n+personally have done a lot of in Rust. Therefore, we will use (and continue to\n+use) IO and various parsing routines to exemplify error handling.\n+\n+Let's start simple. We are tasked with opening a file, reading all of its\n+contents and converting its contents to a number. Then we multiply it by `2`\n+and print the output.\n+\n+Although I've tried to convince you not to use `unwrap`, it can be useful\n+to first write your code using `unwrap`. It allows you to focus on your problem\n+instead of the error handling, and it exposes the points where proper error\n+handling need to occur. Let's start there so we can get a handle on the code,\n+and then refactor it to use better error handling.\n+\n+```rust,should_panic\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> i32 {\n+    let mut file = File::open(file_path).unwrap(); // error 1\n+    let mut contents = String::new();\n+    file.read_to_string(&mut contents).unwrap(); // error 2\n+    let n: i32 = contents.trim().parse().unwrap(); // error 3\n+    2 * n\n+}\n \n fn main() {\n-    println!(\"{}\", descriptive_probability(NewRelease));\n+    let doubled = file_double(\"foobar\");\n+    println!(\"{}\", doubled);\n }\n ```\n \n-We shouldn't ever hit the `_` case, so we use the `unreachable!()` macro to\n-indicate this. `unreachable!()` gives a different kind of error than `Result`.\n-Rust calls these sorts of errors *panics*.\n+(N.B. The `AsRef<Path>` is used because those are the\n+[same bounds used on\n+`std::fs::File::open`](../std/fs/struct.File.html#method.open).\n+This makes it ergnomic to use any kind of string as a file path.)\n+\n+There are three different errors that can occur here:\n+\n+1. A problem opening the file.\n+2. A problem reading data from the file.\n+3. A problem parsing the data as a number.\n+\n+The first two problems are described via the\n+[`std::io::Error`](../std/io/struct.Error.html) type. We know this\n+because of the return types of\n+[`std::fs::File::open`](../std/fs/struct.File.html#method.open) and\n+[`std::io::Read::read_to_string`](../std/io/trait.Read.html#method.read_to_string).\n+(Note that they both use the [`Result` type alias\n+idiom](#the-result-type-alias-idiom) described previously. If you\n+click on the `Result` type, you'll [see the type\n+alias](../std/io/type.Result.html), and consequently, the underlying\n+`io::Error` type.)  The third problem is described by the\n+[`std::num::ParseIntError`](../std/num/struct.ParseIntError.html)\n+type. The `io::Error` type in particular is *pervasive* throughout the\n+standard library. You will see it again and again.\n+\n+Let's start the process of refactoring the `file_double` function. To make this\n+function composable with other components of the program, it should *not* panic\n+if any of the above error conditions are met. Effectively, this means that the\n+function should *return an error* if any of its operations fail. Our problem is\n+that the return type of `file_double` is `i32`, which does not give us any\n+useful way of reporting an error. Thus, we must start by changing the return\n+type from `i32` to something else.\n+\n+The first thing we need to decide: should we use `Option` or `Result`? We\n+certainly could use `Option` very easily. If any of the three errors occur, we\n+could simply return `None`. This will work *and it is better than panicking*,\n+but we can do a lot better. Instead, we should pass some detail about the error\n+that occurred. Since we want to express the *possibility of error*, we should\n+use `Result<i32, E>`. But what should `E` be? Since two *different* types of\n+errors can occur, we need to convert them to a common type. One such type is\n+`String`. Let's see how that impacts our code:\n+\n+```rust\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n+    File::open(file_path)\n+         .map_err(|err| err.to_string())\n+         .and_then(|mut file| {\n+              let mut contents = String::new();\n+              file.read_to_string(&mut contents)\n+                  .map_err(|err| err.to_string())\n+                  .map(|_| contents)\n+         })\n+         .and_then(|contents| {\n+              contents.trim().parse::<i32>()\n+                      .map_err(|err| err.to_string())\n+         })\n+         .map(|n| 2 * n)\n+}\n \n-# Handling errors with `Option` and `Result`\n+fn main() {\n+    match file_double(\"foobar\") {\n+        Ok(n) => println!(\"{}\", n),\n+        Err(err) => println!(\"Error: {}\", err),\n+    }\n+}\n+```\n \n-The simplest way to indicate that a function may fail is to use the `Option<T>`\n-type. For example, the `find` method on strings attempts to find a pattern\n-in a string, and returns an `Option`:\n+This code looks a bit hairy. It can take quite a bit of practice before code\n+like this becomes easy to write. The way we write it is by *following the\n+types*. As soon as we changed the return type of `file_double` to\n+`Result<i32, String>`, we had to start looking for the right combinators. In\n+this case, we only used three different combinators: `and_then`, `map` and\n+`map_err`.\n+\n+`and_then` is used to chain multiple computations where each computation could\n+return an error. After opening the file, there are two more computations that\n+could fail: reading from the file and parsing the contents as a number.\n+Correspondingly, there are two calls to `and_then`.\n+\n+`map` is used to apply a function to the `Ok(...)` value of a `Result`. For\n+example, the very last call to `map` multiplies the `Ok(...)` value (which is\n+an `i32`) by `2`. If an error had occurred before that point, this operation\n+would have been skipped because of how `map` is defined.\n+\n+`map_err` is the trick the makes all of this work. `map_err` is just like\n+`map`, except it applies a function to the `Err(...)` value of a `Result`. In\n+this case, we want to convert all of our errors to one type: `String`. Since\n+both `io::Error` and `num::ParseIntError` implement `ToString`, we can call the\n+`to_string()` method to convert them.\n+\n+With all of that said, the code is still hairy. Mastering use of combinators is\n+important, but they have their limits. Let's try a different approach: early\n+returns.\n+\n+### Early returns\n+\n+I'd like to take the code from the previous section and rewrite it using *early\n+returns*. Early returns let you exit the function early. We can't return early\n+in `file_double` from inside another closure, so we'll need to revert back to\n+explicit case analysis.\n \n ```rust\n-let s = \"foo\";\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n+    let mut file = match File::open(file_path) {\n+        Ok(file) => file,\n+        Err(err) => return Err(err.to_string()),\n+    };\n+    let mut contents = String::new();\n+    if let Err(err) = file.read_to_string(&mut contents) {\n+        return Err(err.to_string());\n+    }\n+    let n: i32 = match contents.trim().parse() {\n+        Ok(n) => n,\n+        Err(err) => return Err(err.to_string()),\n+    };\n+    Ok(2 * n)\n+}\n \n-assert_eq!(s.find('f'), Some(0));\n-assert_eq!(s.find('z'), None);\n+fn main() {\n+    match file_double(\"foobar\") {\n+        Ok(n) => println!(\"{}\", n),\n+        Err(err) => println!(\"Error: {}\", err),\n+    }\n+}\n ```\n \n+Reasonable people can disagree over whether this code is better that the code\n+that uses combinators, but if you aren't familiar with the combinator approach,\n+this code looks simpler to read to me. It uses explicit case analysis with\n+`match` and `if let`. If an error occurs, it simply stops executing the\n+function and returns the error (by converting it to a string).\n+\n+Isn't this a step backwards though? Previously, we said that the key to\n+ergonomic error handling is reducing explicit case analysis, yet we've reverted\n+back to explicit case analysis here. It turns out, there are *multiple* ways to\n+reduce explicit case analysis. Combinators aren't the only way.\n \n-This is appropriate for the simplest of cases, but doesn't give us a lot of\n-information in the failure case. What if we wanted to know _why_ the function\n-failed? For this, we can use the `Result<T, E>` type. It looks like this:\n+### The `try!` macro\n+\n+A cornerstone of error handling in Rust is the `try!` macro. The `try!` macro\n+abstracts case analysis just like combinators, but unlike combinators, it also\n+abstracts *control flow*. Namely, it can abstract the *early return* pattern\n+seen above.\n+\n+Here is a simplified definition of a `try!` macro:\n \n ```rust\n-enum Result<T, E> {\n-   Ok(T),\n-   Err(E)\n+macro_rules! try {\n+    ($e:expr) => (match $e {\n+        Ok(val) => val,\n+        Err(err) => return Err(err),\n+    });\n }\n ```\n \n-This enum is provided by Rust itself, so you don't need to define it to use it\n-in your code. The `Ok(T)` variant represents a success, and the `Err(E)` variant\n-represents a failure. Returning a `Result` instead of an `Option` is recommended\n-for all but the most trivial of situations.\n+(The [real definition](../std/macro.try!.html) is a bit more\n+sophisticated. We will address that later.)\n \n-Here's an example of using `Result`:\n+Using the `try!` macro makes it very easy to simplify our last example. Since\n+it does the case analysis and the early return for us, we get tighter code that\n+is easier to read:\n \n ```rust\n-#[derive(Debug)]\n-enum Version { Version1, Version2 }\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n+    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));\n+    let mut contents = String::new();\n+    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));\n+    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));\n+    Ok(2 * n)\n+}\n+\n+fn main() {\n+    match file_double(\"foobar\") {\n+        Ok(n) => println!(\"{}\", n),\n+        Err(err) => println!(\"Error: {}\", err),\n+    }\n+}\n+```\n+\n+The `map_err` calls are still necessary given\n+[our definition of `try!`](#code-try-def-simple).\n+This is because the error types still need to be converted to `String`.\n+The good news is that we will soon learn how to remove those `map_err` calls!\n+The bad news is that we will need to learn a bit more about a couple important\n+traits in the standard library before we can remove the `map_err` calls.\n+\n+### Defining your own error type\n+\n+Before we dive into some of the standard library error traits, I'd like to wrap\n+up this section by removing the use of `String` as our error type in the\n+previous examples.\n+\n+Using `String` as we did in our previous examples is convenient because it's\n+easy to convert errors to strings, or even make up your own errors as strings\n+on the spot. However, using `String` for your errors has some downsides.\n+\n+The first downside is that the error messages tend to clutter your\n+code. It's possible to define the error messages elsewhere, but unless\n+you're unusually disciplined, it is very tempting to embed the error\n+message into your code. Indeed, we did exactly this in a [previous\n+example](#code-error-double-string).\n+\n+The second and more important downside is that `String`s are *lossy*. That is,\n+if all errors are converted to strings, then the errors we pass to the caller\n+become completely opaque. The only reasonable thing the caller can do with a\n+`String` error is show it to the user. Certainly, inspecting the string to\n+determine the type of error is not robust. (Admittedly, this downside is far\n+more important inside of a library as opposed to, say, an application.)\n+\n+For example, the `io::Error` type embeds an\n+[`io::ErrorKind`](../std/io/enum.ErrorKind.html),\n+which is *structured data* that represents what went wrong during an IO\n+operation. This is important because you might want to react differently\n+depending on the error. (e.g., A `BrokenPipe` error might mean quitting your\n+program gracefully while a `NotFound` error might mean exiting with an error\n+code and showing an error to the user.) With `io::ErrorKind`, the caller can\n+examine the type of an error with case analysis, which is strictly superior\n+to trying to tease out the details of an error inside of a `String`.\n+\n+Instead of using a `String` as an error type in our previous example of reading\n+an integer from a file, we can define our own error type that represents errors\n+with *structured data*. We endeavor to not drop information from underlying\n+errors in case the caller wants to inspect the details.\n+\n+The ideal way to represent *one of many possibilities* is to define our own\n+sum type using `enum`. In our case, an error is either an `io::Error` or a\n+`num::ParseIntError`, so a natural definition arises:\n+\n+```rust\n+use std::io;\n+use std::num;\n \n+// We derive `Debug` because all types should probably derive `Debug`.\n+// This gives us a reasonable human readable description of `CliError` values.\n #[derive(Debug)]\n-enum ParseError { InvalidHeaderLength, InvalidVersion }\n+enum CliError {\n+    Io(io::Error),\n+    Parse(num::ParseIntError),\n+}\n+```\n \n-fn parse_version(header: &[u8]) -> Result<Version, ParseError> {\n-    if header.len() < 1 {\n-        return Err(ParseError::InvalidHeaderLength);\n+Tweaking our code is very easy. Instead of converting errors to strings, we\n+simply convert them to our `CliError` type using the corresponding value\n+constructor:\n+\n+```rust\n+# #[derive(Debug)]\n+# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n+    let mut file = try!(File::open(file_path).map_err(CliError::Io));\n+    let mut contents = String::new();\n+    try!(file.read_to_string(&mut contents).map_err(CliError::Io));\n+    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));\n+    Ok(2 * n)\n+}\n+\n+fn main() {\n+    match file_double(\"foobar\") {\n+        Ok(n) => println!(\"{}\", n),\n+        Err(err) => println!(\"Error: {:?}\", err),\n     }\n-    match header[0] {\n-        1 => Ok(Version::Version1),\n-        2 => Ok(Version::Version2),\n-        _ => Err(ParseError::InvalidVersion)\n+}\n+```\n+\n+The only change here is switching `map_err(|e| e.to_string())` (which converts\n+errors to strings) to `map_err(CliError::Io)` or `map_err(CliError::Parse)`.\n+The *caller* gets to decide the level of detail to report to the user. In\n+effect, using a `String` as an error type removes choices from the caller while\n+using a custom `enum` error type like `CliError` gives the caller all of the\n+conveniences as before in addition to *structured data* describing the error.\n+\n+A rule of thumb is to define your own error type, but a `String` error type\n+will do in a pinch, particularly if you're writing an application. If you're\n+writing a library, defining your own error type should be strongly preferred so\n+that you don't remove choices from the caller unnecessarily.\n+\n+## Standard library traits used for error handling\n+\n+The standard library defines two integral traits for error handling:\n+[`std::error::Error`](../std/error/trait.Error.html) and\n+[`std::convert::From`](../std/convert/trait.From.html). While `Error`\n+is designed specifically for generically describing errors, the `From`\n+trait serves a more general role for converting values between two\n+distinct types. ### The `Error` trait\n+\n+The `Error` trait is [defined in the standard\n+library](../std/error/trait.Error.html):\n+\n+```rust\n+use std::fmt::{Debug, Display};\n+\n+trait Error: Debug + Display {\n+  /// A short description of the error.\n+  fn description(&self) -> &str;\n+\n+  /// The lower level cause of this error, if any.\n+  fn cause(&self) -> Option<&Error> { None }\n+}\n+```\n+\n+This trait is super generic because it is meant to be implemented for *all*\n+types that represent errors. This will prove useful for writing composable code\n+as we'll see later. Otherwise, the trait allows you to do at least the\n+following things:\n+\n+* Obtain a `Debug` representation of the error.\n+* Obtain a user-facing `Display` representation of the error.\n+* Obtain a short description of the error (via the `description` method).\n+* Inspect the causal chain of an error, if one exists (via the `cause` method).\n+\n+The first two are a result of `Error` requiring impls for both `Debug` and\n+`Display`. The latter two are from the two methods defined on `Error`. The\n+power of `Error` comes from the fact that all error types impl `Error`, which\n+means errors can be existentially quantified as a\n+[trait object](../book/trait-objects.html).\n+This manifests as either `Box<Error>` or `&Error`. Indeed, the `cause` method\n+returns an `&Error`, which is itself a trait object. We'll revisit the\n+`Error` trait's utility as a trait object later.\n+\n+For now, it suffices to show an example implementing the `Error` trait. Let's\n+use the error type we defined in the\n+[previous section](#defining-your-own-error-type):\n+\n+```rust\n+use std::io;\n+use std::num;\n+\n+// We derive `Debug` because all types should probably derive `Debug`.\n+// This gives us a reasonable human readable description of `CliError` values.\n+#[derive(Debug)]\n+enum CliError {\n+    Io(io::Error),\n+    Parse(num::ParseIntError),\n+}\n+```\n+\n+This particular error type represents the possibility of two types of errors\n+occurring: an error dealing with I/O or an error converting a string to a\n+number. The error could represent as many error types as you want by adding new\n+variants to the `enum` definition.\n+\n+Implementing `Error` is pretty straight-forward. It's mostly going to be a lot\n+explicit case analysis.\n+\n+```rust,ignore\n+use std::error;\n+use std::fmt;\n+\n+impl fmt::Display for CliError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            // Both underlying errors already impl `Display`, so we defer to\n+            // their implementations.\n+            CliError::Io(ref err) => write!(f, \"IO error: {}\", err),\n+            CliError::Parse(ref err) => write!(f, \"Parse error: {}\", err),\n+        }\n     }\n }\n \n-let version = parse_version(&[1, 2, 3, 4]);\n-match version {\n-    Ok(v) => {\n-        println!(\"working with version: {:?}\", v);\n+impl error::Error for CliError {\n+    fn description(&self) -> &str {\n+        // Both underlying errors already impl `Error`, so we defer to their\n+        // implementations.\n+        match *self {\n+            CliError::Io(ref err) => err.description(),\n+            // Normally we can just write `err.description()`, but the error\n+            // type has a concrete method called `description`, which conflicts\n+            // with the trait method. For now, we must explicitly call\n+            // `description` through the `Error` trait.\n+            CliError::Parse(ref err) => error::Error::description(err),\n+        }\n     }\n-    Err(e) => {\n-        println!(\"error parsing header: {:?}\", e);\n+\n+    fn cause(&self) -> Option<&error::Error> {\n+        match *self {\n+            // N.B. Both of these implicitly cast `err` from their concrete\n+            // types (either `&io::Error` or `&num::ParseIntError`)\n+            // to a trait object `&Error`. This works because both error types\n+            // implement `Error`.\n+            CliError::Io(ref err) => Some(err),\n+            CliError::Parse(ref err) => Some(err),\n+        }\n     }\n }\n ```\n \n-This function makes use of an enum, `ParseError`, to enumerate the various\n-errors that can occur.\n+We note that this is a very typical implementation of `Error`: match on your\n+different error types and satisfy the contracts defined for `description` and\n+`cause`.\n+\n+### The `From` trait\n+\n+The `std::convert::From` trait is\n+[defined in the standard\n+library](../std/convert/trait.From.html):\n+\n+```rust\n+trait From<T> {\n+    fn from(T) -> Self;\n+}\n+```\n+\n+Deliciously simple, yes? `From` is very useful because it gives us a generic\n+way to talk about conversion *from* a particular type `T` to some other type\n+(in this case, \u201csome other type\u201d is the subject of the impl, or `Self`).\n+The crux of `From` is the\n+[set of implementations provided by the standard\n+library](../std/convert/trait.From.html).\n \n-The [`Debug`](../std/fmt/trait.Debug.html) trait is what lets us print the enum value using the `{:?}` format operation.\n+Here are a few simple examples demonstrating how `From` works:\n \n-# Non-recoverable errors with `panic!`\n+```rust\n+let string: String = From::from(\"foo\");\n+let bytes: Vec<u8> = From::from(\"foo\");\n+let cow: ::std::borrow::Cow<str> = From::from(\"foo\");\n+```\n \n-In the case of an error that is unexpected and not recoverable, the `panic!`\n-macro will induce a panic. This will crash the current thread, and give an error:\n+OK, so `From` is useful for converting between strings. But what about errors?\n+It turns out, there is one critical impl:\n \n ```rust,ignore\n-panic!(\"boom\");\n+impl<'a, E: Error + 'a> From<E> for Box<Error + 'a>\n ```\n \n-gives\n+This impl says that for *any* type that impls `Error`, we can convert it to a\n+trait object `Box<Error>`. This may not seem terribly surprising, but it is\n+useful in a generic context.\n \n-```text\n-thread '<main>' panicked at 'boom', hello.rs:2\n+Remember the two errors we were dealing with previously? Specifically,\n+`io::Error` and `num::ParseIntError`. Since both impl `Error`, they work with\n+`From`:\n+\n+```rust\n+use std::error::Error;\n+use std::fs;\n+use std::io;\n+use std::num;\n+\n+// We have to jump through some hoops to actually get error values.\n+let io_err: io::Error = io::Error::last_os_error();\n+let parse_err: num::ParseIntError = \"not a number\".parse::<i32>().unwrap_err();\n+\n+// OK, here are the conversions.\n+let err1: Box<Error> = From::from(io_err);\n+let err2: Box<Error> = From::from(parse_err);\n ```\n \n-when you run it.\n+There is a really important pattern to recognize here. Both `err1` and `err2`\n+have the *same type*. This is because they are existentially quantified types,\n+or trait objects. In particularly, their underlying type is *erased* from the\n+compiler's knowledge, so it truly sees `err1` and `err2` as exactly the same.\n+Additionally, we constructed `err1` and `err2` using precisely the same\n+function call: `From::from`. This is because `From::from` is overloaded on both\n+its argument and its return type.\n \n-Because these kinds of situations are relatively rare, use panics sparingly.\n+This pattern is important because it solves a problem we had earlier: it gives\n+us a way to reliably convert errors to the same type using the same function.\n \n-# Upgrading failures to panics\n+Time to revisit an old friend; the `try!` macro.\n \n-In certain circumstances, even though a function may fail, we may want to treat\n-it as a panic instead. For example, `io::stdin().read_line(&mut buffer)` returns\n-a `Result<usize>`, which can indicate an error if one occurs when reading the line.\n-This allows us to handle and possibly recover from errors.\n+### The real `try!` macro\n \n-If we don't want to handle this error, and would rather just abort the program,\n-we can use the `unwrap()` method:\n+Previously, we presented this definition of `try!`:\n \n-```rust,ignore\n-io::stdin().read_line(&mut buffer).unwrap();\n+```rust\n+macro_rules! try {\n+    ($e:expr) => (match $e {\n+        Ok(val) => val,\n+        Err(err) => return Err(err),\n+    });\n+}\n ```\n \n-`unwrap()` will `panic!` if the `Result` is `Err`. This basically says \"Give\n-me the value, and if something goes wrong, just crash.\" This is less reliable\n-than matching the error and attempting to recover, but is also significantly\n-shorter. Sometimes, just crashing is appropriate.\n+This is not it's real definition. It's real definition is\n+[in the standard library](../std/macro.try!.html):\n \n-There's another way of doing this that's a bit nicer than `unwrap()`:\n+```rust\n+macro_rules! try {\n+    ($e:expr) => (match $e {\n+        Ok(val) => val,\n+        Err(err) => return Err(::std::convert::From::from(err)),\n+    });\n+}\n+```\n \n-```rust,ignore\n-let mut buffer = String::new();\n-let num_bytes_read = io::stdin().read_line(&mut buffer)\n-                                .ok()\n-                                .expect(\"Failed to read line\");\n+There's one tiny but powerful change: the error value is passed through\n+`From::from`. This makes the `try!` macro a lot more powerful because it gives\n+you automatic type conversion for free.\n+\n+Armed with our more powerful `try!` macro, let's take a look at code we wrote\n+previously to read a file and convert its contents to an integer:\n+\n+```rust\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, String> {\n+    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));\n+    let mut contents = String::new();\n+    try!(file.read_to_string(&mut contents).map_err(|e| e.to_string()));\n+    let n = try!(contents.trim().parse::<i32>().map_err(|e| e.to_string()));\n+    Ok(2 * n)\n+}\n ```\n \n-`ok()` converts the `Result` into an `Option`, and `expect()` does the same\n-thing as `unwrap()`, but takes a message. This message is passed along to the\n-underlying `panic!`, providing a better error message if the code errors.\n+Earlier, we promised that we could get rid of the `map_err` calls. Indeed, all\n+we have to do is pick a type that `From` works with. As we saw in the previous\n+section, `From` has an impl that let's it convert any error type into a\n+`Box<Error>`:\n \n-# Using `try!`\n+```rust\n+use std::error::Error;\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, Box<Error>> {\n+    let mut file = try!(File::open(file_path));\n+    let mut contents = String::new();\n+    try!(file.read_to_string(&mut contents));\n+    let n = try!(contents.trim().parse::<i32>());\n+    Ok(2 * n)\n+}\n+```\n \n-When writing code that calls many functions that return the `Result` type, the\n-error handling can be tedious. The `try!` macro hides some of the boilerplate\n-of propagating errors up the call stack.\n+We are getting very close to ideal error handling. Our code has very little\n+overhead as a result from error handling because the `try!` macro encapsulates\n+three things simultaneously:\n \n-It replaces this:\n+1. Case analysis.\n+2. Control flow.\n+3. Error type conversion.\n+\n+When all three things are combined, we get code that is unencumbered by\n+combinators, calls to `unwrap` or case analysis.\n+\n+There's one little nit left: the `Box<Error>` type is *opaque*. If we\n+return a `Box<Error>` to the caller, the caller can't (easily) inspect\n+underlying error type. The situation is certainly better than `String`\n+because the caller can call methods like\n+[`description`](../std/error/trait.Error.html#tymethod.description)\n+and [`cause`](../std/error/trait.Error.html#method.cause), but the\n+limitation remains: `Box<Error>` is opaque. (N.B. This isn't entirely\n+true because Rust does have runtime reflection, which is useful in\n+some scenarios that are [beyond the scope of this\n+chapter](https://crates.io/crates/error).)\n+\n+It's time to revisit our custom `CliError` type and tie everything together.\n+\n+### Composing custom error types\n+\n+In the last section, we looked at the real `try!` macro and how it does\n+automatic type conversion for us by calling `From::from` on the error value.\n+In particular, we converted errors to `Box<Error>`, which works, but the type\n+is opaque to callers.\n+\n+To fix this, we use the same remedy that we're already familiar with: a custom\n+error type. Once again, here is the code that reads the contents of a file and\n+converts it to an integer:\n \n ```rust\n use std::fs::File;\n-use std::io;\n-use std::io::prelude::*;\n+use std::io::{self, Read};\n+use std::num;\n+use std::path::Path;\n \n-struct Info {\n-    name: String,\n-    age: i32,\n-    rating: i32,\n+// We derive `Debug` because all types should probably derive `Debug`.\n+// This gives us a reasonable human readable description of `CliError` values.\n+#[derive(Debug)]\n+enum CliError {\n+    Io(io::Error),\n+    Parse(num::ParseIntError),\n }\n \n-fn write_info(info: &Info) -> io::Result<()> {\n-    let mut file = File::create(\"my_best_friends.txt\").unwrap();\n+fn file_double_verbose<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n+    let mut file = try!(File::open(file_path).map_err(CliError::Io));\n+    let mut contents = String::new();\n+    try!(file.read_to_string(&mut contents).map_err(CliError::Io));\n+    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));\n+    Ok(2 * n)\n+}\n+```\n \n-    if let Err(e) = writeln!(&mut file, \"name: {}\", info.name) {\n-        return Err(e)\n-    }\n-    if let Err(e) = writeln!(&mut file, \"age: {}\", info.age) {\n-        return Err(e)\n-    }\n-    if let Err(e) = writeln!(&mut file, \"rating: {}\", info.rating) {\n-        return Err(e)\n+Notice that we still have the calls to `map_err`. Why? Well, recall the\n+definitions of [`try!`](#code-try-def) and [`From`](#code-from-def). The\n+problem is that there is no `From` impl that allows us to convert from error\n+types like `io::Error` and `num::ParseIntError` to our own custom `CliError`.\n+Of course, it is easy to fix this! Since we defined `CliError`, we can impl\n+`From` with it:\n+\n+```rust\n+# #[derive(Debug)]\n+# enum CliError { Io(io::Error), Parse(num::ParseIntError) }\n+use std::io;\n+use std::num;\n+\n+impl From<io::Error> for CliError {\n+    fn from(err: io::Error) -> CliError {\n+        CliError::Io(err)\n     }\n+}\n \n-    return Ok(());\n+impl From<num::ParseIntError> for CliError {\n+    fn from(err: num::ParseIntError) -> CliError {\n+        CliError::Parse(err)\n+    }\n }\n ```\n \n-With this:\n+All these impls are doing is teaching `From` how to create a `CliError` from\n+other error types. In our case, construction is as simple as invoking the\n+corresponding value constructor. Indeed, it is *typically* this easy.\n+\n+We can finally rewrite `file_double`:\n \n ```rust\n+# use std::io;\n+# use std::num;\n+# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }\n+# impl From<io::Error> for CliError {\n+#     fn from(err: io::Error) -> CliError { CliError::Io(err) }\n+# }\n+# impl From<num::ParseIntError> for CliError {\n+#     fn from(err: num::ParseIntError) -> CliError { CliError::Parse(err) }\n+# }\n+\n use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+\n+fn file_double<P: AsRef<Path>>(file_path: P) -> Result<i32, CliError> {\n+    let mut file = try!(File::open(file_path));\n+    let mut contents = String::new();\n+    try!(file.read_to_string(&mut contents));\n+    let n: i32 = try!(contents.trim().parse());\n+    Ok(2 * n)\n+}\n+```\n+\n+The only thing we did here was remove the calls to `map_err`. They are no\n+longer needed because the `try!` macro invokes `From::from` on the error value.\n+This works because we've provided `From` impls for all the error types that\n+could appear.\n+\n+If we modified our `file_double` function to perform some other operation, say,\n+convert a string to a float, then we'd need to add a new variant to our error\n+type:\n+\n+```rust\n use std::io;\n-use std::io::prelude::*;\n+use std::num;\n \n-struct Info {\n-    name: String,\n-    age: i32,\n-    rating: i32,\n+enum CliError {\n+    Io(io::Error),\n+    ParseInt(num::ParseIntError),\n+    ParseFloat(num::ParseFloatError),\n }\n+```\n \n-fn write_info(info: &Info) -> io::Result<()> {\n-    let mut file = File::create(\"my_best_friends.txt\").unwrap();\n+And add a new `From` impl:\n \n-    try!(writeln!(&mut file, \"name: {}\", info.name));\n-    try!(writeln!(&mut file, \"age: {}\", info.age));\n-    try!(writeln!(&mut file, \"rating: {}\", info.rating));\n+```rust\n+# enum CliError {\n+#     Io(::std::io::Error),\n+#     ParseInt(num::ParseIntError),\n+#     ParseFloat(num::ParseFloatError),\n+# }\n+\n+use std::num;\n+\n+impl From<num::ParseFloatError> for CliError {\n+    fn from(err: num::ParseFloatError) -> CliError {\n+        CliError::ParseFloat(err)\n+    }\n+}\n+```\n+\n+And that's it!\n+\n+### Advice for library writers\n+\n+If your library needs to report custom errors, then you should\n+probably define your own error type. It's up to you whether or not to\n+expose its representation (like\n+[`ErrorKind`](../std/io/enum.ErrorKind.html)) or keep it hidden (like\n+[`ParseIntError`](../std/num/struct.ParseIntError.html)). Regardless\n+of how you do it, it's usually good practice to at least provide some\n+information about the error beyond just its `String`\n+representation. But certainly, this will vary depending on use cases.\n+\n+At a minimum, you should probably implement the\n+[`Error`](../std/error/trait.Error.html)\n+trait. This will give users of your library some minimum flexibility for\n+[composing errors](#the-real-try-macro). Implementing the `Error` trait also\n+means that users are guaranteed the ability to obtain a string representation\n+of an error (because it requires impls for both `fmt::Debug` and\n+`fmt::Display`).\n+\n+Beyond that, it can also be useful to provide implementations of `From` on your\n+error types. This allows you (the library author) and your users to\n+[compose more detailed errors](#composing-custom-error-types). For example,\n+[`csv::Error`](http://burntsushi.net/rustdoc/csv/enum.Error.html)\n+provides `From` impls for both `io::Error` and `byteorder::Error`.\n+\n+Finally, depending on your tastes, you may also want to define a\n+[`Result` type alias](#the-result-type-alias-idiom), particularly if your\n+library defines a single error type. This is used in the standard library\n+for [`io::Result`](../std/io/type.Result.html)\n+and [`fmt::Result`](../std/fmt/type.Result.html).\n+\n+## Case study: A program to read population data\n+\n+This chapter was long, and depending on your background, it might be\n+rather dense. While there is plenty of example code to go along with\n+the prose, most of it was specifically designed to be pedagogical. So,\n+we're going to do something new: a case study.\n+\n+For this, we're going to build up a command line program that lets you\n+query world population data. The objective is simple: you give it a location\n+and it will tell you the population. Despite the simplicity, there is a lot\n+that can go wrong!\n+\n+The data we'll be using comes from the [Data Science\n+Toolkit][11]. I've prepared some data from it for this exercise. You\n+can either grab the [world population data][12] (41MB gzip compressed,\n+145MB uncompressed) or just the [US population data][13] (2.2MB gzip\n+compressed, 7.2MB uncompressed).\n+\n+Up until now, we've kept the code limited to Rust's standard library. For a real\n+task like this though, we'll want to at least use something to parse CSV data,\n+parse the program arguments and decode that stuff into Rust types automatically. For that, we'll use the\n+[`csv`](https://crates.io/crates/csv),\n+and [`rustc-serialize`](https://crates.io/crates/rustc-serialize) crates.\n+\n+### Initial setup\n+\n+We're not going to spend a lot of time on setting up a project with\n+Cargo because it is already covered well in [the Cargo\n+chapter](../book/hello-cargo) and [Cargo's documentation][14].\n+\n+To get started from scratch, run `cargo new --bin city-pop` and make sure your\n+`Cargo.toml` looks something like this:\n+\n+```text\n+[package]\n+name = \"city-pop\"\n+version = \"0.1.0\"\n+authors = [\"Andrew Gallant <jamslam@gmail.com>\"]\n+\n+[[bin]]\n+name = \"city-pop\"\n+\n+[dependencies]\n+csv = \"0.*\"\n+rustc-serialize = \"0.*\"\n+getopts = \"0.*\"\n+```\n+\n+You should already be able to run:\n+\n+```text\n+cargo build --release\n+./target/release/city-pop\n+# Outputs: Hello, world!\n+```\n+\n+### Argument parsing\n \n-    return Ok(());\n+Let's get argument parsing out of the way. we won't go into too much\n+detail on Getopts, but there is [some good documentation][15]\n+describing it. The short story is that Getopts generates an argument\n+parser and a help message from a vector of options (The fact that it\n+is a vector is hidden behind a struct and a set of methods). Once the\n+parsing is done, we can decode the program arguments into a Rust\n+struct. From there, we can get information about the flags, for\n+instance, wether they were passed in, and what arguments they\n+had. Here's our program with the appropriate `extern crate`\n+statements, and the basic argument setup for Getopts:\n+\n+```rust,ignore\n+extern crate getopts;\n+extern crate rustc_serialize;\n+\n+use getopts::Options;\n+use std::env;\n+\n+fn print_usage(program: &str, opts: Options) {\n+    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n+}\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    let program = args[0].clone();\n+\n+    let mut opts = Options::new();\n+    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+    \n+    let matches = match opts.parse(&args[1..]) {\n+        Ok(m)  => { m }\n+\tErr(e) => { panic!(e.to_string()) }\n+    };\n+    if matches.opt_present(\"h\") {\n+        print_usage(&program, opts);\n+\treturn;\n+    }\n+    let data_path = args[1].clone();\n+    let city = args[2].clone();\n+\t\n+\t// Do stuff with information\n }\n ```\n \n-Wrapping an expression in `try!` will result in the unwrapped success (`Ok`)\n-value, unless the result is `Err`, in which case `Err` is returned early from\n-the enclosing function.\n+First, we get a vector of the arguments passed into our program. We\n+then store the first one, knowing that it is our program's name. Once\n+that's done, we set up our argument flags, in this case a simplistic\n+help message flag. Once we have the argument flags set up, we use\n+`Options.parse` to parse the argument vector (starting from index one,\n+becouse index 0 is the program name). If this was successful, we\n+assign matches to the parsed object, if not, we panic. Once past that,\n+we test if the user passed in the help flag, and if so print the usage\n+message. The option help messages are constructed by Getopts, so all\n+we have to do to print the usage message is tell it what we want it to\n+print for the program name and template. If the user has not passed in\n+the help flag, we assign the proper variables to their corresponding\n+arguments.\n+\n+### Writing the logic\n+\n+We're all different in how we write code, but error handling is\n+usually the last thing we want to think about. This isn't very good\n+practice for good design, but it can be useful for rapidly\n+prototyping. In our case, because Rust forces us to be explicit about\n+error handling, it will also make it obvious what parts of our program\n+can cause errors. Why? Because Rust will make us call `unwrap`! This\n+can give us a nice bird's eye view of how we need to approach error\n+handling.\n+\n+In this case study, the logic is really simple. All we need to do is parse the\n+CSV data given to us and print out a field in matching rows. Let's do it. (Make\n+sure to add `extern crate csv;` to the top of your file.)\n+\n+```rust,ignore\n+// This struct represents the data in each row of the CSV file.\n+// Type based decoding absolves us of a lot of the nitty gritty error\n+// handling, like parsing strings as integers or floats.\n+#[derive(Debug, RustcDecodable)]\n+struct Row {\n+    country: String,\n+    city: String,\n+    accent_city: String,\n+    region: String,\n+\n+    // Not every row has data for the population, latitude or longitude!\n+    // So we express them as `Option` types, which admits the possibility of\n+    // absence. The CSV parser will fill in the correct value for us.\n+    population: Option<u64>,\n+    latitude: Option<f64>,\n+    longitude: Option<f64>,\n+}\n \n-It's worth noting that you can only use `try!` from a function that returns a\n-`Result`, which means that you cannot use `try!` inside of `main()`, because\n-`main()` doesn't return anything.\n+fn print_usage(program: &str, opts: Options) {\n+    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n+}\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    let program = args[0].clone();\n+\n+    let mut opts = Options::new();\n+    opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+    \n+    let matches = match opts.parse(&args[1..]) {\n+        Ok(m)  => { m }\n+\t\tErr(e) => { panic!(e.to_string()) }\n+    };\n+\t\n+    if matches.opt_present(\"h\") {\n+        print_usage(&program, opts);\n+\t\treturn;\n+\t}\n+\t\t\n+\tlet data_file = args[1].clone();\n+\tlet data_path = Path::new(&data_file);\n+\tlet city = args[2].clone();\n+\t\n+\tlet file = fs::File::open(data_path).unwrap();\n+\tlet mut rdr = csv::Reader::from_reader(file);\n+\t\n+\tfor row in rdr.decode::<Row>() {\n+\t\tlet row = row.unwrap();\n+\t\n+\t\tif row.city == city {\n+\t\t\tprintln!(\"{}, {}: {:?}\",\n+\t\t\t\trow.city, row.country,\n+\t\t\t\trow.population.expect(\"population count\"));\n+\t\t}\n+\t}\n+}\n+```\n+\n+Let's outline the errors. We can start with the obvious: the three places that\n+`unwrap` is called:\n+\n+1. [`fs::File::open`](../std/fs/struct.File.html#method.open)\n+   can return an\n+   [`io::Error`](../std/io/struct.Error.html).\n+2. [`csv::Reader::decode`](http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode)\n+   decodes one record at a time, and\n+   [decoding a\n+   record](http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html)\n+   (look at the `Item` associated type on the `Iterator` impl)\n+   can produce a\n+   [`csv::Error`](http://burntsushi.net/rustdoc/csv/enum.Error.html).\n+3. If `row.population` is `None`, then calling `expect` will panic.\n+\n+Are there any others? What if we can't find a matching city? Tools like `grep`\n+will return an error code, so we probably should too. So we have logic errors\n+specific to our problem, IO errors and CSV parsing errors. We're going to\n+explore two different ways to approach handling these errors.\n+\n+I'd like to start with `Box<Error>`. Later, we'll see how defining our own\n+error type can be useful.\n+\n+### Error handling with `Box<Error>`\n+\n+`Box<Error>` is nice because it *just works*. You don't need to define your own\n+error types and you don't need any `From` implementations. The downside is that\n+since `Box<Error>` is a trait object, it *erases the type*, which means the\n+compiler can no longer reason about its underlying type.\n+\n+[Previously](#the-limits-of-combinators) we started refactoring our code by\n+changing the type of our function from `T` to `Result<T, OurErrorType>`. In\n+this case, `OurErrorType` is just `Box<Error>`. But what's `T`? And can we add\n+a return type to `main`?\n+\n+The answer to the second question is no, we can't. That means we'll need to\n+write a new function. But what is `T`? The simplest thing we can do is to\n+return a list of matching `Row` values as a `Vec<Row>`. (Better code would\n+return an iterator, but that is left as an exercise to the reader.)\n+\n+Let's refactor our code into its own function, but keep the calls to `unwrap`.\n+Note that we opt to handle the possibility of a missing population count by\n+simply ignoring that row.\n+\n+```rust,ignore\n+struct Row {\n+    // unchanged\n+}\n+\n+struct PopulationCount {\n+    city: String,\n+    country: String,\n+    // This is no longer an `Option` because values of this type are only\n+    // constructed if they have a population count.\n+    count: u64,\n+}\n+\n+fn print_usage(program: &str, opts: Options) {\n+    println!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <data-path> <city>\", program)));\n+}\n+\n+fn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {\n+    let mut found = vec![];\n+    let file = fs::File::open(file_path).unwrap();\n+    let mut rdr = csv::Reader::from_reader(file);\n+    for row in rdr.decode::<Row>() {\n+        let row = row.unwrap();\n+        match row.population {\n+            None => { } // skip it\n+            Some(count) => if row.city == city {\n+                found.push(PopulationCount {\n+                    city: row.city,\n+                    country: row.country,\n+                    count: count,\n+                });\n+            },\n+        }\n+    }\n+    found\n+}\n+\n+fn main() {\n+\tlet args: Vec<String> = env::args().collect();\n+\tlet program = args[0].clone();\n+\n+\tlet mut opts = Options::new();\n+\topts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+\n+\tlet matches = match opts.parse(&args[1..]) {\n+\t\tOk(m)  => { m }\n+\t\tErr(e) => { panic!(e.to_string()) }\n+\t};\n+\tif matches.opt_present(\"h\") {\n+\t\tprint_usage(&program, opts);\n+\t\treturn;\n+\t}\n+\t\t\n+\tlet data_file = args[1].clone();\n+\tlet data_path = Path::new(&data_file);\n+\tlet city = args[2].clone();\n+\tfor pop in search(&data_path, &city) {\n+\t\tprintln!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+\t}\n+}\n+\n+```\n+\n+While we got rid of one use of `expect` (which is a nicer variant of `unwrap`),\n+we still should handle the absence of any search results.\n+\n+To convert this to proper error handling, we need to do the following:\n+\n+1. Change the return type of `search` to be `Result<Vec<PopulationCount>,\n+   Box<Error>>`.\n+2. Use the [`try!` macro](#code-try-def) so that errors are returned to the\n+   caller instead of panicking the program.\n+3. Handle the error in `main`.\n+\n+Let's try it:\n+\n+```rust,ignore\n+fn search<P: AsRef<Path>>\n+         (file_path: P, city: &str)\n+         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {\n+    let mut found = vec![];\n+    let file = try!(fs::File::open(file_path));\n+    let mut rdr = csv::Reader::from_reader(file);\n+    for row in rdr.decode::<Row>() {\n+        let row = try!(row);\n+        match row.population {\n+            None => { } // skip it\n+            Some(count) => if row.city == city {\n+                found.push(PopulationCount {\n+                    city: row.city,\n+                    country: row.country,\n+                    count: count,\n+                });\n+            },\n+        }\n+    }\n+    if found.is_empty() {\n+        Err(From::from(\"No matching cities with a population were found.\"))\n+    } else {\n+        Ok(found)\n+    }\n+}\n+```\n+\n+Instead of `x.unwrap()`, we now have `try!(x)`. Since our function returns a\n+`Result<T, E>`, the `try!` macro will return early from the function if an\n+error occurs.\n+\n+There is one big gotcha in this code: we used `Box<Error + Send + Sync>`\n+instead of `Box<Error>`. We did this so we could convert a plain string to an\n+error type. We need these extra bounds so that we can use the\n+[corresponding `From`\n+impls](../std/convert/trait.From.html):\n+\n+```rust,ignore\n+// We are making use of this impl in the code above, since we call `From::from`\n+// on a `&'static str`.\n+impl<'a, 'b> From<&'b str> for Box<Error + Send + Sync + 'a>\n+\n+// But this is also useful when you need to allocate a new string for an\n+// error message, usually with `format!`.\n+impl From<String> for Box<Error + Send + Sync>\n+```\n+\n+Now that we've seen how to do proper error handling with `Box<Error>`, let's\n+try a different approach with our own custom error type. But first, let's take\n+a quick break from error handling and add support for reading from `stdin`.\n+\n+### Reading from stdin\n+\n+In our program, we accept a single file for input and do one pass over the\n+data. This means we probably should be able to accept input on stdin. But maybe\n+we like the current format too\u2014so let's have both!\n+\n+Adding support for stdin is actually quite easy. There are only two things we\n+have to do:\n+\n+1. Tweak the program arguments so that a single parameter\u2014the\n+   city\u2014can be accepted while the population data is read from stdin.\n+2. Modify the program so that an option `-f` can take the file, if it\n+    is not passed into stdin.\n+3. Modify the `search` function to take an *optional* file path. When `None`,\n+   it should know to read from stdin.\n+\n+First, here's the new usage:\n+\n+```rust,ignore\n+fn print_usage(program: &str, opts: Options) {\n+\tprintln!(\"{}\", opts.usage(&format!(\"Usage: {} [options] <city>\", program)));\n+}\n+```\n+The next part is going to be only a little harder:\n+\n+```rust,ignore\n+...\n+let mut opts = Options::new();\n+opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n+opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+...\n+let file = matches.opt_str(\"f\");\n+let data_file = file.as_ref().map(Path::new);\n+\t\n+let city = if !matches.free.is_empty() {\n+\tmatches.free[0].clone()\n+} else {\n+\tprint_usage(&program, opts);\n+\treturn;\n+};\n+\n+for pop in search(&data_file, &city) {\n+\tprintln!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+}\n+...\n+```\n+\n+In this peice of code, we take `file` (which has the type\n+`Option<String>`), and convert it to a type that `search` can use, in\n+this case, `&Option<AsRef<Path>>`. Do do this, we take a reference of\n+file, and map `Path::new` onto it. In this case, `as_ref()` converts\n+the `Option<String>` into an `Option<&str>`, and from there, we can\n+execute `Path::new` to the content of the optional, and return the\n+optional of the new value. Once we have that, it is a simple matter of\n+getting the `city` argument and executing `search`.\n+\n+Modifying `search` is slightly trickier. The `csv` crate can build a\n+parser out of\n+[any type that implements `io::Read`](http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader).\n+But how can we use the same code over both types? There's actually a\n+couple ways we could go about this. One way is to write `search` such\n+that it is generic on some type parameter `R` that satisfies\n+`io::Read`. Another way is to just use trait objects:\n+\n+```rust,ignore\n+fn search<P: AsRef<Path>>\n+         (file_path: &Option<P>, city: &str)\n+         -> Result<Vec<PopulationCount>, Box<Error+Send+Sync>> {\n+    let mut found = vec![];\n+    let input: Box<io::Read> = match *file_path {\n+        None => Box::new(io::stdin()),\n+        Some(ref file_path) => Box::new(try!(fs::File::open(file_path))),\n+    };\n+    let mut rdr = csv::Reader::from_reader(input);\n+    // The rest remains unchanged!\n+}\n+```\n+### Error handling with a custom type\n+\n+Previously, we learned how to\n+[compose errors using a custom error type](#composing-custom-error-types).\n+We did this by defining our error type as an `enum` and implementing `Error`\n+and `From`.\n+\n+Since we have three distinct errors (IO, CSV parsing and not found), let's\n+define an `enum` with three variants:\n+\n+```rust,ignore\n+#[derive(Debug)]\n+enum CliError {\n+    Io(io::Error),\n+    Csv(csv::Error),\n+    NotFound,\n+}\n+```\n+\n+And now for impls on `Display` and `Error`:\n+\n+```rust,ignore\n+impl fmt::Display for CliError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            CliError::Io(ref err) => err.fmt(f),\n+            CliError::Csv(ref err) => err.fmt(f),\n+            CliError::NotFound => write!(f, \"No matching cities with a \\\n+                                             population were found.\"),\n+        }\n+    }\n+}\n+\n+impl Error for CliError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            CliError::Io(ref err) => err.description(),\n+            CliError::Csv(ref err) => err.description(),\n+            CliError::NotFound => \"not found\",\n+        }\n+    }\n+}\n+```\n+\n+Before we can use our `CliError` type in our `search` function, we need to\n+provide a couple `From` impls. How do we know which impls to provide? Well,\n+we'll need to convert from both `io::Error` and `csv::Error` to `CliError`.\n+Those are the only external errors, so we'll only need two `From` impls for\n+now:\n+\n+```rust,ignore\n+impl From<io::Error> for CliError {\n+    fn from(err: io::Error) -> CliError {\n+        CliError::Io(err)\n+    }\n+}\n+\n+impl From<csv::Error> for CliError {\n+    fn from(err: csv::Error) -> CliError {\n+        CliError::Csv(err)\n+    }\n+}\n+```\n+\n+The `From` impls are important because of how\n+[`try!` is defined](#code-try-def). In particular, if an error occurs,\n+`From::from` is called on the error, which in this case, will convert it to our\n+own error type `CliError`.\n+\n+With the `From` impls done, we only need to make two small tweaks to our\n+`search` function: the return type and the \u201cnot found\u201d error. Here it is in\n+full:\n+\n+```rust,ignore\n+fn search<P: AsRef<Path>>\n+         (file_path: &Option<P>, city: &str)\n+         -> Result<Vec<PopulationCount>, CliError> {\n+    let mut found = vec![];\n+    let input: Box<io::Read> = match *file_path {\n+        None => Box::new(io::stdin()),\n+        Some(ref file_path) => Box::new(try!(fs::File::open(file_path))),\n+    };\n+    let mut rdr = csv::Reader::from_reader(input);\n+    for row in rdr.decode::<Row>() {\n+        let row = try!(row);\n+        match row.population {\n+            None => { } // skip it\n+            Some(count) => if row.city == city {\n+                found.push(PopulationCount {\n+                    city: row.city,\n+                    country: row.country,\n+                    count: count,\n+                });\n+            },\n+        }\n+    }\n+    if found.is_empty() {\n+        Err(CliError::NotFound)\n+    } else {\n+        Ok(found)\n+    }\n+}\n+```\n+\n+No other changes are necessary.\n+\n+### Adding functionality\n+\n+Writing generic code is great, because generalizing stuff is cool, and\n+it can then be useful later. But sometimes, the juice isn't worth the\n+squeeze. Look at what we just did in the previous step:\n+\n+1. Defined a new error type.\n+2. Added impls for `Error`, `Display` and two for `From`.\n+\n+The big downside here is that our program didn't improve a whole lot.\n+There is quite a bit of overhead to representing errors with `enum`s,\n+especially in short programs like this.\n+\n+*One* useful aspect of using a custom error type like we've done here is that\n+the `main` function can now choose to handle errors differently. Previously,\n+with `Box<Error>`, it didn't have much of a choice: just print the message.\n+We're still doing that here, but what if we wanted to, say, add a `--quiet`\n+flag? The `--quiet` flag should silence any verbose output.\n+\n+Right now, if the program doesn't find a match, it will output a message saying\n+so. This can be a little clumsy, especially if you intend for the program to\n+be used in shell scripts.\n+\n+So let's start by adding the flags. Like before, we need to tweak the usage\n+string and add a flag to the Option variable. Once were done that, Getopts does the rest:\n+\n+```rust,ignore\n+...\n+let mut opts = Options::new();\n+opts.optopt(\"f\", \"file\", \"Choose an input file, instead of using STDIN.\", \"NAME\");\n+opts.optflag(\"h\", \"help\", \"Show this usage message.\");\n+opts.optflag(\"q\", \"quit\", \"Silences errors and warnings.\");\n+...\n+```\n+\n+Now we just need to implement our \u201cquiet\u201d functionality. This requires us to\n+tweak the case analysis in `main`:\n+\n+```rust,ignore\n+match search(&args.arg_data_path, &args.arg_city) {\n+    Err(CliError::NotFound) if args.flag_quiet => process::exit(1),\n+    Err(err) => fatal!(\"{}\", err),\n+    Ok(pops) => for pop in pops {\n+        println!(\"{}, {}: {:?}\", pop.city, pop.country, pop.count);\n+    }\n+}\n+```\n \n-`try!` makes use of [`From<Error>`](../std/convert/trait.From.html) to determine\n-what to return in the error case.\n+Certainly, we don't want to be quiet if there was an IO error or if the data\n+failed to parse. Therefore, we use case analysis to check if the error type is\n+`NotFound` *and* if `--quiet` has been enabled. If the search failed, we still\n+quit with an exit code (following `grep`'s convention).\n+\n+If we had stuck with `Box<Error>`, then it would be pretty tricky to implement\n+the `--quiet` functionality.\n+\n+This pretty much sums up our case study. From here, you should be ready to go\n+out into the world and write your own programs and libraries with proper error\n+handling.\n+\n+## The Short Story\n+\n+Since this chapter is long, it is useful to have a quick summary for error\n+handling in Rust. These are some good \u201crules of thumb.\" They are emphatically\n+*not* commandments. There are probably good reasons to break every one of these\n+heuristics!\n+\n+* If you're writing short example code that would be overburdened by error\n+  handling, it's probably just fine to use `unwrap` (whether that's\n+  [`Result::unwrap`](../std/result/enum.Result.html#method.unwrap),\n+  [`Option::unwrap`](../std/option/enum.Option.html#method.unwrap)\n+  or preferably\n+  [`Option::expect`](../std/option/enum.Option.html#method.expect)).\n+  Consumers of your code should know to use proper error handling. (If they\n+  don't, send them here!)\n+* If you're writing a quick 'n' dirty program, don't feel ashamed if you use\n+  `unwrap`. Be warned: if it winds up in someone else's hands, don't be\n+  surprised if they are agitated by poor error messages!\n+* If you're writing a quick 'n' dirty program and feel ashamed about panicking\n+  anyway, then using either a `String` or a `Box<Error + Send + Sync>` for your\n+  error type (the `Box<Error + Send + Sync>` type is because of the\n+  [available `From` impls](../std/convert/trait.From.html)).\n+* Otherwise, in a program, define your own error types with appropriate\n+  [`From`](../std/convert/trait.From.html)\n+  and\n+  [`Error`](../std/error/trait.Error.html)\n+  impls to make the [`try!`](../std/macro.try!.html)\n+  macro more ergnomic.\n+* If you're writing a library and your code can produce errors, define your own\n+  error type and implement the\n+  [`std::error::Error`](../std/error/trait.Error.html)\n+  trait. Where appropriate, implement\n+  [`From`](../std/convert/trait.From.html) to make both\n+  your library code and the caller's code easier to write. (Because of Rust's\n+  coherence rules, callers will not be able to impl `From` on your error type,\n+  so your library should do it.)\n+* Learn the combinators defined on\n+  [`Option`](../std/option/enum.Option.html)\n+  and\n+  [`Result`](../std/result/enum.Result.html).\n+  Using them exclusively can be a bit tiring at times, but I've personally\n+  found a healthy mix of `try!` and combinators to be quite appealing.\n+  `and_then`, `map` and `unwrap_or` are my favorites.\n+\n+[1]: ../book/patterns.html\n+[2]: ../std/option/enum.Option.html#method.map\n+[3]: ../std/option/enum.Option.html#method.unwrap_or\n+[4]: ../std/option/enum.Option.html#method.unwrap_or_else\n+[5]: ../std/option/enum.Option.html\n+[6]: ../std/result/\n+[7]: ../std/result/enum.Result.html#method.unwrap\n+[8]: ../std/fmt/trait.Debug.html\n+[9]: ../std/primitive.str.html#method.parse\n+[10]: ../book/associated-types.html\n+[11]: https://github.com/petewarden/dstkdata\n+[12]: http://burntsushi.net/stuff/worldcitiespop.csv.gz\n+[13]: http://burntsushi.net/stuff/uscitiespop.csv.gz\n+[14]: http://doc.crates.io/guide.html\n+[15]: http://doc.rust-lang.org/getopts/getopts/index.html"}]}