{"sha": "466345ca81c9f8a17347671ca27856eb963858f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NjM0NWNhODFjOWY4YTE3MzQ3NjcxY2EyNzg1NmViOTYzODU4ZjQ=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-10T11:55:00Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:08:27Z"}, "message": "Clean up, more docs.", "tree": {"sha": "8327771c3d67f7c4509b373e8ad7075f5cfd5ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8327771c3d67f7c4509b373e8ad7075f5cfd5ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/466345ca81c9f8a17347671ca27856eb963858f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/466345ca81c9f8a17347671ca27856eb963858f4", "html_url": "https://github.com/rust-lang/rust/commit/466345ca81c9f8a17347671ca27856eb963858f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/466345ca81c9f8a17347671ca27856eb963858f4/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49e016169fc8413e2734a655cbd55ebba2907b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/49e016169fc8413e2734a655cbd55ebba2907b76", "html_url": "https://github.com/rust-lang/rust/commit/49e016169fc8413e2734a655cbd55ebba2907b76"}], "stats": {"total": 489, "additions": 384, "deletions": 105}, "files": [{"sha": "f98622faac88688cdf7af0e78b85f42dc2202ad8", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=466345ca81c9f8a17347671ca27856eb963858f4", "patch": "@@ -166,10 +166,7 @@ impl Path {\n     }\n \n     /// Converts a known mod path to `Path`.\n-    pub fn from_known_path(\n-        path: ModPath,\n-        generic_args: Vec<Option<Interned<GenericArgs>>>,\n-    ) -> Path {\n+    pub fn from_known_path(path: ModPath, generic_args: Vec<Option<Interned<GenericArgs>>>) -> Path {\n         Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n     }\n "}, {"sha": "b321004acfd6d24d804519bfdad3ca7a5f925049", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=466345ca81c9f8a17347671ca27856eb963858f4", "patch": "@@ -437,7 +437,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         let cx = usefulness::MatchCheckCtx {\n             module: self.owner.module(db.upcast()),\n             match_expr,\n-            body,\n             infer: &infer,\n             db,\n             pattern_arena: &pattern_arena,"}, {"sha": "85c01b17868c4091f1ee0d7a5dc98a69fd3d2b3a", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=466345ca81c9f8a17347671ca27856eb963858f4", "patch": "@@ -1,15 +1,18 @@\n-#![deny(elided_lifetimes_in_paths)]\n-#![allow(unused)] // todo remove\n+//! Validation of matches.\n+//!\n+//! This module provides lowering from [hir_def::expr::Pat] to [self::Pat] and match\n+//! checking algorithm.\n+//!\n+//! It is a loose port of `rustc_mir_build::thir::pattern` module.\n \n mod deconstruct_pat;\n-// TODO: find a better place for this?\n mod pat_util;\n pub(crate) mod usefulness;\n \n use hir_def::{body::Body, EnumVariantId, LocalFieldId, VariantId};\n use la_arena::Idx;\n \n-use crate::{db::HirDatabase, AdtId, InferenceResult, Interner, Substitution, Ty, TyKind};\n+use crate::{db::HirDatabase, InferenceResult, Interner, Substitution, Ty, TyKind};\n \n use self::pat_util::EnumerateAndAdjustIterator;\n \n@@ -38,6 +41,7 @@ impl Pat {\n     }\n }\n \n+/// Close relative to `rustc_mir_build::thir::pattern::PatKind`\n #[derive(Clone, Debug, PartialEq)]\n pub(crate) enum PatKind {\n     Wild,\n@@ -66,7 +70,7 @@ pub(crate) enum PatKind {\n         subpattern: Pat,\n     },\n \n-    // only bool for now\n+    // FIXME: for now, only bool literals are implemented\n     LiteralBool {\n         value: bool,\n     },\n@@ -91,7 +95,7 @@ impl<'a> PatCtxt<'a> {\n     }\n \n     pub(crate) fn lower_pattern(&mut self, pat: hir_def::expr::PatId) -> Pat {\n-        // TODO: pattern adjustments (implicit dereference)\n+        // FIXME: implement pattern adjustments (implicit pattern dereference; \"RFC 2005-match-ergonomics\")\n         // More info https://github.com/rust-lang/rust/issues/42640#issuecomment-313535089\n         let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n         unadjusted_pat\n@@ -141,7 +145,7 @@ impl<'a> PatCtxt<'a> {\n                     .iter()\n                     .map(|field| FieldPat {\n                         // XXX(iDawer): field lookup is inefficient\n-                        field: variant_data.field(&field.name).unwrap_or_else(|| todo!()),\n+                        field: variant_data.field(&field.name).unwrap(),\n                         pattern: self.lower_pattern(field.pat),\n                     })\n                     .collect();\n@@ -208,11 +212,10 @@ impl<'a> PatCtxt<'a> {\n                 PatKind::Wild\n             }\n         };\n-        // TODO: do we need PatKind::AscribeUserType ?\n         kind\n     }\n \n-    fn lower_path(&mut self, pat: hir_def::expr::PatId, path: &hir_def::path::Path) -> Pat {\n+    fn lower_path(&mut self, pat: hir_def::expr::PatId, _path: &hir_def::path::Path) -> Pat {\n         let ty = &self.infer[pat];\n \n         let pat_from_kind = |kind| Pat { ty: ty.clone(), kind: Box::new(kind) };\n@@ -338,8 +341,6 @@ impl PatternFoldable for PatKind {\n mod tests {\n     use crate::diagnostics::tests::check_diagnostics;\n \n-    use super::*;\n-\n     #[test]\n     fn unit() {\n         check_diagnostics(\n@@ -372,8 +373,6 @@ fn main() {\n \n     #[test]\n     fn tuple_with_ellipsis() {\n-        // TODO: test non-exhaustive match with ellipsis in the middle\n-        // of a pattern, check reported witness\n         check_diagnostics(\n             r#\"\n struct A; struct B;"}, {"sha": "9fa82a952ac078152d44a3216284026ac41a4de1", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "modified", "additions": 87, "deletions": 58, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=466345ca81c9f8a17347671ca27856eb963858f4", "patch": "@@ -1,14 +1,54 @@\n+//! [`super::usefulness`] explains most of what is happening in this file. As explained there,\n+//! values and patterns are made from constructors applied to fields. This file defines a\n+//! `Constructor` enum, a `Fields` struct, and various operations to manipulate them and convert\n+//! them from/to patterns.\n+//!\n+//! There's one idea that is not detailed in [`super::usefulness`] because the details are not\n+//! needed there: _constructor splitting_.\n+//!\n+//! # Constructor splitting\n+//!\n+//! The idea is as follows: given a constructor `c` and a matrix, we want to specialize in turn\n+//! with all the value constructors that are covered by `c`, and compute usefulness for each.\n+//! Instead of listing all those constructors (which is intractable), we group those value\n+//! constructors together as much as possible. Example:\n+//!\n+//! ```\n+//! match (0, false) {\n+//!     (0 ..=100, true) => {} // `p_1`\n+//!     (50..=150, false) => {} // `p_2`\n+//!     (0 ..=200, _) => {} // `q`\n+//! }\n+//! ```\n+//!\n+//! The naive approach would try all numbers in the range `0..=200`. But we can be a lot more\n+//! clever: `0` and `1` for example will match the exact same rows, and return equivalent\n+//! witnesses. In fact all of `0..50` would. We can thus restrict our exploration to 4\n+//! constructors: `0..50`, `50..=100`, `101..=150` and `151..=200`. That is enough and infinitely\n+//! more tractable.\n+//!\n+//! We capture this idea in a function `split(p_1 ... p_n, c)` which returns a list of constructors\n+//! `c'` covered by `c`. Given such a `c'`, we require that all value ctors `c''` covered by `c'`\n+//! return an equivalent set of witnesses after specializing and computing usefulness.\n+//! In the example above, witnesses for specializing by `c''` covered by `0..50` will only differ\n+//! in their first element.\n+//!\n+//! We usually also ask that the `c'` together cover all of the original `c`. However we allow\n+//! skipping some constructors as long as it doesn't change whether the resulting list of witnesses\n+//! is empty of not. We use this in the wildcard `_` case.\n+//!\n+//! Splitting is implemented in the [`Constructor::split`] function. We don't do splitting for\n+//! or-patterns; instead we just try the alternatives one-by-one. For details on splitting\n+//! wildcards, see [`SplitWildcard`]; for integer ranges, see [`SplitIntRange`]; for slices, see\n+//! [`SplitVarLenSlice`].\n+\n use std::{\n     cmp::{max, min},\n     iter::once,\n     ops::RangeInclusive,\n };\n \n-use hir_def::{\n-    expr::{Expr, Literal, RecordFieldPat},\n-    type_ref::Mutability,\n-    AttrDefId, EnumVariantId, HasModule, LocalFieldId, VariantId,\n-};\n+use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n use smallvec::{smallvec, SmallVec};\n \n use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n@@ -20,9 +60,21 @@ use super::{\n \n use self::Constructor::*;\n \n+/// [Constructor] uses this in umimplemented variants.\n+/// It allows porting match expressions from upstream algorithm without losing semantics.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(super) enum ToDo {}\n-\n+pub(super) enum Void {}\n+\n+/// An inclusive interval, used for precise integer exhaustiveness checking.\n+/// `IntRange`s always store a contiguous range. This means that values are\n+/// encoded such that `0` encodes the minimum value for the integer,\n+/// regardless of the signedness.\n+/// For example, the pattern `-128..=127i8` is encoded as `0..=255`.\n+/// This makes comparisons and arithmetic on interval endpoints much more\n+/// straightforward. See `signed_bias` for details.\n+///\n+/// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n+/// around the (offset) space: i.e., `range.lo <= range.hi`.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(super) struct IntRange {\n     range: RangeInclusive<u128>,\n@@ -55,11 +107,11 @@ impl IntRange {\n     }\n \n     #[inline]\n-    fn from_range(cx: &MatchCheckCtx<'_>, lo: u128, hi: u128, scalar_ty: Scalar) -> IntRange {\n+    fn from_range(lo: u128, hi: u128, scalar_ty: Scalar) -> IntRange {\n         if let Scalar::Bool = scalar_ty {\n             IntRange { range: lo..=hi }\n         } else {\n-            todo!()\n+            unimplemented!()\n         }\n     }\n \n@@ -188,13 +240,13 @@ impl SplitIntRange {\n /// A constructor for array and slice patterns.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(super) struct Slice {\n-    todo: ToDo,\n+    _unimplemented: Void,\n }\n \n impl Slice {\n     /// See `Constructor::is_covered_by`\n-    fn is_covered_by(self, other: Self) -> bool {\n-        todo!()\n+    fn is_covered_by(self, _other: Self) -> bool {\n+        unimplemented!() // never called as Slice contains Void\n     }\n }\n \n@@ -205,6 +257,7 @@ impl Slice {\n /// `specialize_constructor` returns the list of fields corresponding to a pattern, given a\n /// constructor. `Constructor::apply` reconstructs the pattern from a pair of `Constructor` and\n /// `Fields`.\n+#[allow(dead_code)]\n #[derive(Clone, Debug, PartialEq)]\n pub(super) enum Constructor {\n     /// The constructor for patterns that have a single constructor, like tuples, struct patterns\n@@ -215,9 +268,9 @@ pub(super) enum Constructor {\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n-    FloatRange(ToDo),\n+    FloatRange(Void),\n     /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n-    Str(ToDo),\n+    Str(Void),\n     /// Array and slice patterns.\n     Slice(Slice),\n     /// Constants that must not be matched structurally. They are treated as black\n@@ -253,7 +306,7 @@ impl Constructor {\n         }\n     }\n \n-    fn variant_id_for_adt(&self, adt: hir_def::AdtId, cx: &MatchCheckCtx<'_>) -> VariantId {\n+    fn variant_id_for_adt(&self, adt: hir_def::AdtId) -> VariantId {\n         match *self {\n             Variant(id) => id.into(),\n             Single => {\n@@ -270,7 +323,6 @@ impl Constructor {\n \n     /// Determines the constructor that the given pattern can be specialized to.\n     pub(super) fn from_pat(cx: &MatchCheckCtx<'_>, pat: PatId) -> Self {\n-        let ty = cx.type_of(pat);\n         match cx.pattern_arena.borrow()[pat].kind.as_ref() {\n             PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n             PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n@@ -312,7 +364,7 @@ impl Constructor {\n                 split_range.split(int_ranges.cloned());\n                 split_range.iter().map(IntRange).collect()\n             }\n-            Slice(_) => todo!(\"Constructor::split Slice\"),\n+            Slice(_) => unimplemented!(),\n             // Any other constructor can be used unchanged.\n             _ => smallvec![self.clone()],\n         }\n@@ -323,7 +375,7 @@ impl Constructor {\n     /// this checks for inclusion.\n     // We inline because this has a single call site in `Matrix::specialize_constructor`.\n     #[inline]\n-    pub(super) fn is_covered_by(&self, pcx: PatCtxt<'_>, other: &Self) -> bool {\n+    pub(super) fn is_covered_by(&self, _pcx: PatCtxt<'_>, other: &Self) -> bool {\n         // This must be kept in sync with `is_covered_by_any`.\n         match (self, other) {\n             // Wildcards cover anything\n@@ -336,10 +388,10 @@ impl Constructor {\n \n             (IntRange(self_range), IntRange(other_range)) => self_range.is_covered_by(other_range),\n             (FloatRange(..), FloatRange(..)) => {\n-                todo!()\n+                unimplemented!()\n             }\n-            (Str(self_val), Str(other_val)) => {\n-                todo!()\n+            (Str(..), Str(..)) => {\n+                unimplemented!()\n             }\n             (Slice(self_slice), Slice(other_slice)) => self_slice.is_covered_by(*other_slice),\n \n@@ -358,7 +410,7 @@ impl Constructor {\n     /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n     /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n     /// assumed to have been split from a wildcard.\n-    fn is_covered_by_any(&self, pcx: PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n+    fn is_covered_by_any(&self, _pcx: PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n         if used_ctors.is_empty() {\n             return false;\n         }\n@@ -411,9 +463,10 @@ pub(super) struct SplitWildcard {\n impl SplitWildcard {\n     pub(super) fn new(pcx: PatCtxt<'_>) -> Self {\n         let cx = pcx.cx;\n-        let make_range =\n-            |start, end, scalar| IntRange(IntRange::from_range(cx, start, end, scalar));\n-        // FIXME(iDawer) using NonExhaustive ctor for unhandled types\n+        let make_range = |start, end, scalar| IntRange(IntRange::from_range(start, end, scalar));\n+\n+        // Unhandled types are treated as non-exhaustive. Being explicit here instead of falling\n+        // to catchall arm to ease further implementation.\n         let unhandled = || smallvec![NonExhaustive];\n \n         // This determines the set of all possible constructors for the type `pcx.ty`. For numbers,\n@@ -426,7 +479,7 @@ impl SplitWildcard {\n         // `cx.is_uninhabited()`).\n         let all_ctors = match pcx.ty.kind(&Interner) {\n             TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n-            // TyKind::Array(..) if ... => todo!(),\n+            // TyKind::Array(..) if ... => unhandled(),\n             TyKind::Array(..) | TyKind::Slice(..) => unhandled(),\n             &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref _substs) => {\n                 let enum_data = cx.db.enum_data(enum_id);\n@@ -556,26 +609,6 @@ impl SplitWildcard {\n     }\n }\n \n-#[test]\n-fn it_works2() {}\n-\n-/// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n-/// `Fields` struct. This struct represents such a potentially-hidden field.\n-#[derive(Debug, Copy, Clone)]\n-pub(super) enum FilteredField {\n-    Kept(PatId),\n-    Hidden,\n-}\n-\n-impl FilteredField {\n-    fn kept(self) -> Option<PatId> {\n-        match self {\n-            FilteredField::Kept(p) => Some(p),\n-            FilteredField::Hidden => None,\n-        }\n-    }\n-}\n-\n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// those fields, generalized to allow patterns in each field. See also `Constructor`.\n /// This is constructed from a constructor using [`Fields::wildcards()`].\n@@ -623,14 +656,13 @@ impl Fields {\n                 }\n                 TyKind::Ref(.., rty) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n                 TyKind::Adt(AdtId(adt), substs) => {\n-                    let adt_is_box = false; // TODO(iDawer): handle box patterns\n+                    let adt_is_box = false; // TODO(iDawer): implement this\n                     if adt_is_box {\n                         // Use T as the sub pattern type of Box<T>.\n-                        let ty = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n-                        Fields::from_single_pattern(wildcard_from_ty(ty))\n+                        let subst_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n+                        Fields::from_single_pattern(wildcard_from_ty(subst_ty))\n                     } else {\n-                        let variant_id = constructor.variant_id_for_adt(*adt, cx);\n-                        let variant = variant_id.variant_data(cx.db.upcast());\n+                        let variant_id = constructor.variant_id_for_adt(*adt);\n                         let adt_is_local =\n                             variant_id.module(cx.db.upcast()).krate() == cx.module.krate();\n                         // Whether we must not match the fields of this variant exhaustively.\n@@ -655,8 +687,8 @@ impl Fields {\n                 }\n                 _ => panic!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n             },\n-            Slice(slice) => {\n-                todo!()\n+            Slice(..) => {\n+                unimplemented!()\n             }\n             Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Missing\n             | Wildcard => Fields::Vec(Default::default()),\n@@ -722,7 +754,7 @@ impl Fields {\n                 }\n                 _ => PatKind::Wild,\n             },\n-            Constructor::Slice(slice) => UNHANDLED,\n+            Constructor::Slice(_) => UNHANDLED,\n             Str(_) => UNHANDLED,\n             FloatRange(..) => UNHANDLED,\n             Constructor::IntRange(_) => UNHANDLED,\n@@ -828,7 +860,7 @@ impl Fields {\n         pat: PatId,\n         cx: &MatchCheckCtx<'_>,\n     ) -> Self {\n-        // TODO: these alocations and clones are so unfortunate (+1 for switching to references)\n+        // FIXME(iDawer): these alocations and clones are so unfortunate (+1 for switching to references)\n         let mut arena = cx.pattern_arena.borrow_mut();\n         match arena[pat].kind.as_ref() {\n             PatKind::Deref { subpattern } => {\n@@ -860,6 +892,3 @@ fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_>) -\n     };\n     cx.db.attrs(attr_def_id).by_key(\"non_exhaustive\").exists()\n }\n-\n-#[test]\n-fn it_works() {}"}, {"sha": "b01e3557cac066eb47b1f026f2003bad2b16bfd7", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 284, "deletions": 29, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/466345ca81c9f8a17347671ca27856eb963858f4/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=466345ca81c9f8a17347671ca27856eb963858f4", "patch": "@@ -1,9 +1,279 @@\n-// Based on rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\n-// https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\n-\n-use std::{cell::RefCell, iter::FromIterator, ops::Index, sync::Arc};\n-\n-use hir_def::{body::Body, expr::ExprId, HasModule, ModuleId};\n+//! Based on rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\n+//! https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\n+//!\n+//! -----\n+//!\n+//! This file includes the logic for exhaustiveness and reachability checking for pattern-matching.\n+//! Specifically, given a list of patterns for a type, we can tell whether:\n+//! (a) each pattern is reachable (reachability)\n+//! (b) the patterns cover every possible value for the type (exhaustiveness)\n+//!\n+//! The algorithm implemented here is a modified version of the one described in [this\n+//! paper](http://moscova.inria.fr/~maranget/papers/warn/index.html). We have however generalized\n+//! it to accommodate the variety of patterns that Rust supports. We thus explain our version here,\n+//! without being as rigorous.\n+//!\n+//!\n+//! # Summary\n+//!\n+//! The core of the algorithm is the notion of \"usefulness\". A pattern `q` is said to be *useful*\n+//! relative to another pattern `p` of the same type if there is a value that is matched by `q` and\n+//! not matched by `p`. This generalizes to many `p`s: `q` is useful w.r.t. a list of patterns\n+//! `p_1 .. p_n` if there is a value that is matched by `q` and by none of the `p_i`. We write\n+//! `usefulness(p_1 .. p_n, q)` for a function that returns a list of such values. The aim of this\n+//! file is to compute it efficiently.\n+//!\n+//! This is enough to compute reachability: a pattern in a `match` expression is reachable iff it\n+//! is useful w.r.t. the patterns above it:\n+//! ```rust\n+//! match x {\n+//!     Some(_) => ...,\n+//!     None => ..., // reachable: `None` is matched by this but not the branch above\n+//!     Some(0) => ..., // unreachable: all the values this matches are already matched by\n+//!                     // `Some(_)` above\n+//! }\n+//! ```\n+//!\n+//! This is also enough to compute exhaustiveness: a match is exhaustive iff the wildcard `_`\n+//! pattern is _not_ useful w.r.t. the patterns in the match. The values returned by `usefulness`\n+//! are used to tell the user which values are missing.\n+//! ```rust\n+//! match x {\n+//!     Some(0) => ...,\n+//!     None => ...,\n+//!     // not exhaustive: `_` is useful because it matches `Some(1)`\n+//! }\n+//! ```\n+//!\n+//! The entrypoint of this file is the [`compute_match_usefulness`] function, which computes\n+//! reachability for each match branch and exhaustiveness for the whole match.\n+//!\n+//!\n+//! # Constructors and fields\n+//!\n+//! Note: we will often abbreviate \"constructor\" as \"ctor\".\n+//!\n+//! The idea that powers everything that is done in this file is the following: a (matcheable)\n+//! value is made from a constructor applied to a number of subvalues. Examples of constructors are\n+//! `Some`, `None`, `(,)` (the 2-tuple constructor), `Foo {..}` (the constructor for a struct\n+//! `Foo`), and `2` (the constructor for the number `2`). This is natural when we think of\n+//! pattern-matching, and this is the basis for what follows.\n+//!\n+//! Some of the ctors listed above might feel weird: `None` and `2` don't take any arguments.\n+//! That's ok: those are ctors that take a list of 0 arguments; they are the simplest case of\n+//! ctors. We treat `2` as a ctor because `u64` and other number types behave exactly like a huge\n+//! `enum`, with one variant for each number. This allows us to see any matcheable value as made up\n+//! from a tree of ctors, each having a set number of children. For example: `Foo { bar: None,\n+//! baz: Ok(0) }` is made from 4 different ctors, namely `Foo{..}`, `None`, `Ok` and `0`.\n+//!\n+//! This idea can be extended to patterns: they are also made from constructors applied to fields.\n+//! A pattern for a given type is allowed to use all the ctors for values of that type (which we\n+//! call \"value constructors\"), but there are also pattern-only ctors. The most important one is\n+//! the wildcard (`_`), and the others are integer ranges (`0..=10`), variable-length slices (`[x,\n+//! ..]`), and or-patterns (`Ok(0) | Err(_)`). Examples of valid patterns are `42`, `Some(_)`, `Foo\n+//! { bar: Some(0) | None, baz: _ }`. Note that a binder in a pattern (e.g. `Some(x)`) matches the\n+//! same values as a wildcard (e.g. `Some(_)`), so we treat both as wildcards.\n+//!\n+//! From this deconstruction we can compute whether a given value matches a given pattern; we\n+//! simply look at ctors one at a time. Given a pattern `p` and a value `v`, we want to compute\n+//! `matches!(v, p)`. It's mostly straightforward: we compare the head ctors and when they match\n+//! we compare their fields recursively. A few representative examples:\n+//!\n+//! - `matches!(v, _) := true`\n+//! - `matches!((v0,  v1), (p0,  p1)) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Foo { bar: v0, baz: v1 }, Foo { bar: p0, baz: p1 }) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Ok(v0), Ok(p0)) := matches!(v0, p0)`\n+//! - `matches!(Ok(v0), Err(p0)) := false` (incompatible variants)\n+//! - `matches!(v, 1..=100) := matches!(v, 1) || ... || matches!(v, 100)`\n+//! - `matches!([v0], [p0, .., p1]) := false` (incompatible lengths)\n+//! - `matches!([v0, v1, v2], [p0, .., p1]) := matches!(v0, p0) && matches!(v2, p1)`\n+//! - `matches!(v, p0 | p1) := matches!(v, p0) || matches!(v, p1)`\n+//!\n+//! Constructors, fields and relevant operations are defined in the [`super::deconstruct_pat`] module.\n+//!\n+//! Note: this constructors/fields distinction may not straightforwardly apply to every Rust type.\n+//! For example a value of type `Rc<u64>` can't be deconstructed that way, and `&str` has an\n+//! infinitude of constructors. There are also subtleties with visibility of fields and\n+//! uninhabitedness and various other things. The constructors idea can be extended to handle most\n+//! of these subtleties though; caveats are documented where relevant throughout the code.\n+//!\n+//! Whether constructors cover each other is computed by [`Constructor::is_covered_by`].\n+//!\n+//!\n+//! # Specialization\n+//!\n+//! Recall that we wish to compute `usefulness(p_1 .. p_n, q)`: given a list of patterns `p_1 ..\n+//! p_n` and a pattern `q`, all of the same type, we want to find a list of values (called\n+//! \"witnesses\") that are matched by `q` and by none of the `p_i`. We obviously don't just\n+//! enumerate all possible values. From the discussion above we see that we can proceed\n+//! ctor-by-ctor: for each value ctor of the given type, we ask \"is there a value that starts with\n+//! this constructor and matches `q` and none of the `p_i`?\". As we saw above, there's a lot we can\n+//! say from knowing only the first constructor of our candidate value.\n+//!\n+//! Let's take the following example:\n+//! ```\n+//! match x {\n+//!     Enum::Variant1(_) => {} // `p1`\n+//!     Enum::Variant2(None, 0) => {} // `p2`\n+//!     Enum::Variant2(Some(_), 0) => {} // `q`\n+//! }\n+//! ```\n+//!\n+//! We can easily see that if our candidate value `v` starts with `Variant1` it will not match `q`.\n+//! If `v = Variant2(v0, v1)` however, whether or not it matches `p2` and `q` will depend on `v0`\n+//! and `v1`. In fact, such a `v` will be a witness of usefulness of `q` exactly when the tuple\n+//! `(v0, v1)` is a witness of usefulness of `q'` in the following reduced match:\n+//!\n+//! ```\n+//! match x {\n+//!     (None, 0) => {} // `p2'`\n+//!     (Some(_), 0) => {} // `q'`\n+//! }\n+//! ```\n+//!\n+//! This motivates a new step in computing usefulness, that we call _specialization_.\n+//! Specialization consist of filtering a list of patterns for those that match a constructor, and\n+//! then looking into the constructor's fields. This enables usefulness to be computed recursively.\n+//!\n+//! Instead of acting on a single pattern in each row, we will consider a list of patterns for each\n+//! row, and we call such a list a _pattern-stack_. The idea is that we will specialize the\n+//! leftmost pattern, which amounts to popping the constructor and pushing its fields, which feels\n+//! like a stack. We note a pattern-stack simply with `[p_1 ... p_n]`.\n+//! Here's a sequence of specializations of a list of pattern-stacks, to illustrate what's\n+//! happening:\n+//! ```\n+//! [Enum::Variant1(_)]\n+//! [Enum::Variant2(None, 0)]\n+//! [Enum::Variant2(Some(_), 0)]\n+//! //==>> specialize with `Variant2`\n+//! [None, 0]\n+//! [Some(_), 0]\n+//! //==>> specialize with `Some`\n+//! [_, 0]\n+//! //==>> specialize with `true` (say the type was `bool`)\n+//! [0]\n+//! //==>> specialize with `0`\n+//! []\n+//! ```\n+//!\n+//! The function `specialize(c, p)` takes a value constructor `c` and a pattern `p`, and returns 0\n+//! or more pattern-stacks. If `c` does not match the head constructor of `p`, it returns nothing;\n+//! otherwise if returns the fields of the constructor. This only returns more than one\n+//! pattern-stack if `p` has a pattern-only constructor.\n+//!\n+//! - Specializing for the wrong constructor returns nothing\n+//!\n+//!   `specialize(None, Some(p0)) := []`\n+//!\n+//! - Specializing for the correct constructor returns a single row with the fields\n+//!\n+//!   `specialize(Variant1, Variant1(p0, p1, p2)) := [[p0, p1, p2]]`\n+//!\n+//!   `specialize(Foo{..}, Foo { bar: p0, baz: p1 }) := [[p0, p1]]`\n+//!\n+//! - For or-patterns, we specialize each branch and concatenate the results\n+//!\n+//!   `specialize(c, p0 | p1) := specialize(c, p0) ++ specialize(c, p1)`\n+//!\n+//! - We treat the other pattern constructors as if they were a large or-pattern of all the\n+//!   possibilities:\n+//!\n+//!   `specialize(c, _) := specialize(c, Variant1(_) | Variant2(_, _) | ...)`\n+//!\n+//!   `specialize(c, 1..=100) := specialize(c, 1 | ... | 100)`\n+//!\n+//!   `specialize(c, [p0, .., p1]) := specialize(c, [p0, p1] | [p0, _, p1] | [p0, _, _, p1] | ...)`\n+//!\n+//! - If `c` is a pattern-only constructor, `specialize` is defined on a case-by-case basis. See\n+//!   the discussion about constructor splitting in [`super::deconstruct_pat`].\n+//!\n+//!\n+//! We then extend this function to work with pattern-stacks as input, by acting on the first\n+//! column and keeping the other columns untouched.\n+//!\n+//! Specialization for the whole matrix is done in [`Matrix::specialize_constructor`]. Note that\n+//! or-patterns in the first column are expanded before being stored in the matrix. Specialization\n+//! for a single patstack is done from a combination of [`Constructor::is_covered_by`] and\n+//! [`PatStack::pop_head_constructor`]. The internals of how it's done mostly live in the\n+//! [`Fields`] struct.\n+//!\n+//!\n+//! # Computing usefulness\n+//!\n+//! We now have all we need to compute usefulness. The inputs to usefulness are a list of\n+//! pattern-stacks `p_1 ... p_n` (one per row), and a new pattern_stack `q`. The paper and this\n+//! file calls the list of patstacks a _matrix_. They must all have the same number of columns and\n+//! the patterns in a given column must all have the same type. `usefulness` returns a (possibly\n+//! empty) list of witnesses of usefulness. These witnesses will also be pattern-stacks.\n+//!\n+//! - base case: `n_columns == 0`.\n+//!     Since a pattern-stack functions like a tuple of patterns, an empty one functions like the\n+//!     unit type. Thus `q` is useful iff there are no rows above it, i.e. if `n == 0`.\n+//!\n+//! - inductive case: `n_columns > 0`.\n+//!     We need a way to list the constructors we want to try. We will be more clever in the next\n+//!     section but for now assume we list all value constructors for the type of the first column.\n+//!\n+//!     - for each such ctor `c`:\n+//!\n+//!         - for each `q'` returned by `specialize(c, q)`:\n+//!\n+//!             - we compute `usefulness(specialize(c, p_1) ... specialize(c, p_n), q')`\n+//!\n+//!         - for each witness found, we revert specialization by pushing the constructor `c` on top.\n+//!\n+//!     - We return the concatenation of all the witnesses found, if any.\n+//!\n+//! Example:\n+//! ```\n+//! [Some(true)] // p_1\n+//! [None] // p_2\n+//! [Some(_)] // q\n+//! //==>> try `None`: `specialize(None, q)` returns nothing\n+//! //==>> try `Some`: `specialize(Some, q)` returns a single row\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `true`: `specialize(true, q')` returns a single row\n+//! [] // p_1''\n+//! [] // q''\n+//! //==>> base case; `n != 0` so `q''` is not useful.\n+//! //==>> go back up a step\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `false`: `specialize(false, q')` returns a single row\n+//! [] // q''\n+//! //==>> base case; `n == 0` so `q''` is useful. We return the single witness `[]`\n+//! witnesses:\n+//! []\n+//! //==>> undo the specialization with `false`\n+//! witnesses:\n+//! [false]\n+//! //==>> undo the specialization with `Some`\n+//! witnesses:\n+//! [Some(false)]\n+//! //==>> we have tried all the constructors. The output is the single witness `[Some(false)]`.\n+//! ```\n+//!\n+//! This computation is done in [`is_useful`]. In practice we don't care about the list of\n+//! witnesses when computing reachability; we only need to know whether any exist. We do keep the\n+//! witnesses when computing exhaustiveness to report them to the user.\n+//!\n+//!\n+//! # Making usefulness tractable: constructor splitting\n+//!\n+//! We're missing one last detail: which constructors do we list? Naively listing all value\n+//! constructors cannot work for types like `u64` or `&str`, so we need to be more clever. The\n+//! first obvious insight is that we only want to list constructors that are covered by the head\n+//! constructor of `q`. If it's a value constructor, we only try that one. If it's a pattern-only\n+//! constructor, we use the final clever idea for this algorithm: _constructor splitting_, where we\n+//! group together constructors that behave the same.\n+//!\n+//! The details are not necessary to understand this file, so we explain them in\n+//! [`super::deconstruct_pat`]. Splitting is done by the [`Constructor::split`] function.\n+\n+use std::{cell::RefCell, iter::FromIterator};\n+\n+use hir_def::{expr::ExprId, HasModule, ModuleId};\n use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use rustc_hash::FxHashMap;\n@@ -16,24 +286,19 @@ use super::{\n     Pat, PatId, PatKind, PatternFoldable, PatternFolder,\n };\n \n-use self::{\n-    helper::{Captures, PatIdExt},\n-    Usefulness::*,\n-    WitnessPreference::*,\n-};\n+use self::{helper::PatIdExt, Usefulness::*, WitnessPreference::*};\n \n pub(crate) struct MatchCheckCtx<'a> {\n     pub(crate) module: ModuleId,\n     pub(crate) match_expr: ExprId,\n-    pub(crate) body: Arc<Body>,\n     pub(crate) infer: &'a InferenceResult,\n     pub(crate) db: &'a dyn HirDatabase,\n     /// Lowered patterns from self.body.pats plus generated by the check.\n     pub(crate) pattern_arena: &'a RefCell<PatternArena>,\n }\n \n impl<'a> MatchCheckCtx<'a> {\n-    pub(super) fn is_uninhabited(&self, ty: &Ty) -> bool {\n+    pub(super) fn is_uninhabited(&self, _ty: &Ty) -> bool {\n         // FIXME(iDawer) implement exhaustive_patterns feature. More info in:\n         // Tracking issue for RFC 1872: exhaustive_patterns feature https://github.com/rust-lang/rust/issues/51085\n         false\n@@ -90,7 +355,7 @@ impl PatternFolder for LiteralExpander {\n }\n \n impl Pat {\n-    fn is_wildcard(&self) -> bool {\n+    fn _is_wildcard(&self) -> bool {\n         matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n     }\n }\n@@ -102,11 +367,11 @@ impl PatIdExt for PatId {\n \n     /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n     fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self> {\n-        fn expand(pat: PatId, vec: &mut Vec<PatId>, mut pat_arena: &mut PatternArena) {\n+        fn expand(pat: PatId, vec: &mut Vec<PatId>, pat_arena: &mut PatternArena) {\n             if let PatKind::Or { pats } = pat_arena[pat].kind.as_ref() {\n                 let pats = pats.clone();\n                 for pat in pats {\n-                    // TODO(iDawer): Ugh, I want to go back to references (PatId -> &Pat)\n+                    // FIXME(iDawer): Ugh, I want to go back to references (PatId -> &Pat)\n                     let pat = pat_arena.alloc(pat.clone());\n                     expand(pat, vec, pat_arena);\n                 }\n@@ -157,10 +422,6 @@ impl PatStack {\n         self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n     }\n \n-    fn iter(&self) -> impl Iterator<Item = PatId> + '_ {\n-        self.pats.iter().copied()\n-    }\n-\n     // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n     // or-pattern. Panics if `self` is empty.\n     fn expand_or_pat(&self, cx: &MatchCheckCtx<'_>) -> impl Iterator<Item = PatStack> + '_ {\n@@ -224,7 +485,7 @@ impl Matrix {\n     }\n \n     /// Number of columns of this matrix. `None` is the matrix is empty.\n-    pub(super) fn column_count(&self) -> Option<usize> {\n+    pub(super) fn _column_count(&self) -> Option<usize> {\n         self.patterns.get(0).map(|r| r.len())\n     }\n \n@@ -770,7 +1031,6 @@ fn is_useful(\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see rust-lang/rust#72476).\n-    // TODO(iDawer): ty.strip_references()  ?\n     let ty = matrix.heads().next().map_or(cx.type_of(v.head()), |r| cx.type_of(r));\n     let pcx = PatCtxt { cx, ty: &ty, is_top_level };\n \n@@ -848,7 +1108,7 @@ pub(crate) enum Reachability {\n /// The output of checking a match for exhaustiveness and arm reachability.\n pub(crate) struct UsefulnessReport {\n     /// For each arm of the input, whether that arm is reachable after the arms above it.\n-    pub(crate) arm_usefulness: Vec<(MatchArm, Reachability)>,\n+    pub(crate) _arm_usefulness: Vec<(MatchArm, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n     pub(crate) non_exhaustiveness_witnesses: Vec<Pat>,\n@@ -892,14 +1152,12 @@ pub(crate) fn compute_match_usefulness(\n         WithWitnesses(pats) => pats.into_iter().map(Witness::single_pattern).collect(),\n         NoWitnesses(_) => panic!(\"bug\"),\n     };\n-    UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n+    UsefulnessReport { _arm_usefulness: arm_usefulness, non_exhaustiveness_witnesses }\n }\n \n pub(crate) type PatternArena = Arena<Pat>;\n \n mod helper {\n-    use hir_def::expr::{Pat, PatId};\n-\n     use super::MatchCheckCtx;\n \n     pub(super) trait PatIdExt: Sized {\n@@ -920,6 +1178,3 @@ mod helper {\n \n     impl<'a, T: ?Sized> Captures<'a> for T {}\n }\n-\n-#[test]\n-fn it_works() {}"}]}