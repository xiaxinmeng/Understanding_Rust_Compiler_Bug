{"sha": "6dbd2509f0470b1e46b631c3410915d1b3a69051", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYmQyNTA5ZjA0NzBiMWU0NmI2MzFjMzQxMDkxNWQxYjNhNjkwNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T22:57:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-06T22:57:37Z"}, "message": "Auto merge of #29462 - alexcrichton:refactor-process-ret, r=aturon\n\n* Store the native representation directly in the `ExitStatus` structure instead\n  of a \"parsed version\" (mostly for Unix).\n* On Windows, be more robust against processes exiting with the status of 259.\n  Unfortunately this exit code corresponds to `STILL_ACTIVE`, causing libstd to\n  think the process was still alive, causing an infinite loop. Instead the loop\n  is removed altogether and `WaitForSingleObject` is used to wait for the\n  process to exit.", "tree": {"sha": "a7a482fe428ef95003f4066b184d41892e6f41b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7a482fe428ef95003f4066b184d41892e6f41b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dbd2509f0470b1e46b631c3410915d1b3a69051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dbd2509f0470b1e46b631c3410915d1b3a69051", "html_url": "https://github.com/rust-lang/rust/commit/6dbd2509f0470b1e46b631c3410915d1b3a69051", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dbd2509f0470b1e46b631c3410915d1b3a69051/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "475f91f46eecc7411311106e5c45f7e4781fb5e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/475f91f46eecc7411311106e5c45f7e4781fb5e1", "html_url": "https://github.com/rust-lang/rust/commit/475f91f46eecc7411311106e5c45f7e4781fb5e1"}, {"sha": "94aee5b7e6d1eda4c872133787ba238cbe29ecb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/94aee5b7e6d1eda4c872133787ba238cbe29ecb4", "html_url": "https://github.com/rust-lang/rust/commit/94aee5b7e6d1eda4c872133787ba238cbe29ecb4"}], "stats": {"total": 158, "additions": 94, "deletions": 64}, "files": [{"sha": "3e7260f07571da21da525c3622c44a28fcc16266", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=6dbd2509f0470b1e46b631c3410915d1b3a69051", "patch": "@@ -75,10 +75,7 @@ pub trait ExitStatusExt {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ExitStatusExt for process::ExitStatus {\n     fn signal(&self) -> Option<i32> {\n-        match *self.as_inner() {\n-            sys::process::ExitStatus::Signal(s) => Some(s),\n-            _ => None\n-        }\n+        self.as_inner().signal()\n     }\n }\n "}, {"sha": "7e37238c23b56cc8dbc4be3b303f0396deda5741", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=6dbd2509f0470b1e46b631c3410915d1b3a69051", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(non_snake_case)]\n+\n use prelude::v1::*;\n use os::unix::prelude::*;\n \n@@ -84,33 +86,62 @@ impl Command {\n \n /// Unix exit statuses\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub enum ExitStatus {\n-    /// Normal termination with an exit code.\n-    Code(i32),\n-\n-    /// Termination by signal, with the signal number.\n-    ///\n-    /// Never generated on Windows.\n-    Signal(i32),\n+pub struct ExitStatus(c_int);\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\",\n+          target_os = \"nacl\"))]\n+mod status_imp {\n+    pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+    pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+    pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n+}\n+\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"ios\",\n+          target_os = \"freebsd\",\n+          target_os = \"dragonfly\",\n+          target_os = \"bitrig\",\n+          target_os = \"netbsd\",\n+          target_os = \"openbsd\"))]\n+mod status_imp {\n+    pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+    pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+    pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n }\n \n impl ExitStatus {\n+    fn exited(&self) -> bool {\n+        status_imp::WIFEXITED(self.0)\n+    }\n+\n     pub fn success(&self) -> bool {\n-        *self == ExitStatus::Code(0)\n+        self.code() == Some(0)\n     }\n+\n     pub fn code(&self) -> Option<i32> {\n-        match *self {\n-            ExitStatus::Code(c) => Some(c),\n-            _ => None\n+        if self.exited() {\n+            Some(status_imp::WEXITSTATUS(self.0))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() {\n+            Some(status_imp::WTERMSIG(self.0))\n+        } else {\n+            None\n         }\n     }\n }\n \n impl fmt::Display for ExitStatus {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ExitStatus::Code(code) =>  write!(f, \"exit code: {}\", code),\n-            ExitStatus::Signal(code) =>  write!(f, \"signal: {}\", code),\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n         }\n     }\n }\n@@ -351,7 +382,7 @@ impl Process {\n     pub fn wait(&self) -> io::Result<ExitStatus> {\n         let mut status = 0 as c_int;\n         try!(cvt_r(|| unsafe { c::waitpid(self.pid, &mut status, 0) }));\n-        Ok(translate_status(status))\n+        Ok(ExitStatus(status))\n     }\n \n     pub fn try_wait(&self) -> Option<ExitStatus> {\n@@ -360,7 +391,7 @@ impl Process {\n             c::waitpid(self.pid, &mut status, c::WNOHANG)\n         }) {\n             Ok(0) => None,\n-            Ok(n) if n == self.pid => Some(translate_status(status)),\n+            Ok(n) if n == self.pid => Some(ExitStatus(status)),\n             Ok(n) => panic!(\"unknown pid: {}\", n),\n             Err(e) => panic!(\"unknown waitpid error: {}\", e),\n         }\n@@ -418,36 +449,6 @@ fn make_envp(env: Option<&HashMap<OsString, OsString>>)\n     }\n }\n \n-fn translate_status(status: c_int) -> ExitStatus {\n-    #![allow(non_snake_case)]\n-    #[cfg(any(target_os = \"linux\", target_os = \"android\",\n-              target_os = \"nacl\"))]\n-    mod imp {\n-        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n-        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n-        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n-    }\n-\n-    #[cfg(any(target_os = \"macos\",\n-              target_os = \"ios\",\n-              target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\",\n-              target_os = \"openbsd\"))]\n-    mod imp {\n-        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n-        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n-        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n-    }\n-\n-    if imp::WIFEXITED(status) {\n-        ExitStatus::Code(imp::WEXITSTATUS(status))\n-    } else {\n-        ExitStatus::Signal(imp::WTERMSIG(status))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "e8cc160fde77b6cd1a30ffc5a0126ee718f86486", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=6dbd2509f0470b1e46b631c3410915d1b3a69051", "patch": "@@ -201,21 +201,16 @@ impl Process {\n     }\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n-        use libc::{STILL_ACTIVE, INFINITE, WAIT_OBJECT_0};\n+        use libc::{INFINITE, WAIT_OBJECT_0};\n         use libc::{GetExitCodeProcess, WaitForSingleObject};\n \n         unsafe {\n-            loop {\n-                let mut status = 0;\n-                try!(cvt(GetExitCodeProcess(self.handle.raw(), &mut status)));\n-                if status != STILL_ACTIVE {\n-                    return Ok(ExitStatus(status as i32));\n-                }\n-                match WaitForSingleObject(self.handle.raw(), INFINITE) {\n-                    WAIT_OBJECT_0 => {}\n-                    _ => return Err(Error::last_os_error()),\n-                }\n+            if WaitForSingleObject(self.handle.raw(), INFINITE) != WAIT_OBJECT_0 {\n+                return Err(Error::last_os_error())\n             }\n+            let mut status = 0;\n+            try!(cvt(GetExitCodeProcess(self.handle.raw(), &mut status)));\n+            Ok(ExitStatus(status))\n         }\n     }\n \n@@ -225,14 +220,14 @@ impl Process {\n }\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(i32);\n+pub struct ExitStatus(libc::DWORD);\n \n impl ExitStatus {\n     pub fn success(&self) -> bool {\n         self.0 == 0\n     }\n     pub fn code(&self) -> Option<i32> {\n-        Some(self.0)\n+        Some(self.0 as i32)\n     }\n }\n "}, {"sha": "27c7f9bef15ccd9b4840ecee46aa4bc22ed8d580", "filename": "src/test/run-pass/weird-exit-code.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Ftest%2Frun-pass%2Fweird-exit-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dbd2509f0470b1e46b631c3410915d1b3a69051/src%2Ftest%2Frun-pass%2Fweird-exit-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exit-code.rs?ref=6dbd2509f0470b1e46b631c3410915d1b3a69051", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// On Windows the GetExitCodeProcess API is used to get the exit code of a\n+// process, but it's easy to mistake a process exiting with the code 259 as\n+// \"still running\" because this is the value of the STILL_ACTIVE constant. Make\n+// sure we handle this case in the standard library and correctly report the\n+// status.\n+//\n+// Note that this is disabled on unix as processes exiting with 259 will have\n+// their exit status truncated to 3 (only the lower 8 bits are used).\n+\n+use std::process::{self, Command};\n+use std::env;\n+\n+fn main() {\n+    if !cfg!(windows) {\n+        return\n+    }\n+\n+    if env::args().len() == 1 {\n+        let status = Command::new(env::current_exe().unwrap())\n+                             .arg(\"foo\")\n+                             .status()\n+                             .unwrap();\n+        assert_eq!(status.code(), Some(259));\n+    } else {\n+        process::exit(259);\n+    }\n+}"}]}