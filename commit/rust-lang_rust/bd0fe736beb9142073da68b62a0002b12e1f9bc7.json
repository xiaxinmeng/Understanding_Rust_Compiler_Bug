{"sha": "bd0fe736beb9142073da68b62a0002b12e1f9bc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMGZlNzM2YmViOTE0MjA3M2RhNjhiNjJhMDAwMmIxMmUxZjliYzc=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-07-03T09:31:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-03T09:31:01Z"}, "message": "Rollup merge of #51958 - euclio:attr-refactor, r=petrochenkov\n\nShow known meta items in unknown meta items error\n\nThis PR adds a label to E0541. It also factors built-in attribute parsing into a submodule of `attr` for ease of future refactoring.\n\nFixes #51469.", "tree": {"sha": "68f1c297ed0119f1c11b3a808035e6715353295d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68f1c297ed0119f1c11b3a808035e6715353295d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd0fe736beb9142073da68b62a0002b12e1f9bc7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbO0JVCRBK7hj4Ov3rIwAAdHIIADmcpE7YLMfs4JLxOKU0KKDN\n7Xb9VKROMwc/13qUI7ryY//cXUqnGJkdDCAGUbxA3snHTbmty0hwVCwQ77tdO/mY\nWkjNFMDLJVs+gazR59scHwuF0xnDwkAhi1NuzEwO20pPhJp68B8mWl9z+Sy5Mqhn\nzuzDhnKdc5zOZ/4TZ086T9qoE+kPuE9sU1H/yHzdxMZG8W9fp7XG5HRRQ4ndSKUW\nVeqrPzAggDGLi9btwPeOkT09udPpSzMuPgHPK5bVm454YOwH+jHHpYJLp3Mq3YjM\nnvwEYWWGR8SZMHsdwAwaIND2AocHbe0KY2UQAZmCZqnGjLtbDdoJhO1tTMLu6qw=\n=6odV\n-----END PGP SIGNATURE-----\n", "payload": "tree 68f1c297ed0119f1c11b3a808035e6715353295d\nparent 451560e96c165bde1e76f727221b4499a8822e03\nparent 5468e12ca056a6ac46b36e244d235b9a0c987c58\nauthor Pietro Albini <pietro@pietroalbini.org> 1530610261 +0200\ncommitter GitHub <noreply@github.com> 1530610261 +0200\n\nRollup merge of #51958 - euclio:attr-refactor, r=petrochenkov\n\nShow known meta items in unknown meta items error\n\nThis PR adds a label to E0541. It also factors built-in attribute parsing into a submodule of `attr` for ease of future refactoring.\n\nFixes #51469.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0fe736beb9142073da68b62a0002b12e1f9bc7", "html_url": "https://github.com/rust-lang/rust/commit/bd0fe736beb9142073da68b62a0002b12e1f9bc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd0fe736beb9142073da68b62a0002b12e1f9bc7/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "451560e96c165bde1e76f727221b4499a8822e03", "url": "https://api.github.com/repos/rust-lang/rust/commits/451560e96c165bde1e76f727221b4499a8822e03", "html_url": "https://github.com/rust-lang/rust/commit/451560e96c165bde1e76f727221b4499a8822e03"}, {"sha": "5468e12ca056a6ac46b36e244d235b9a0c987c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/5468e12ca056a6ac46b36e244d235b9a0c987c58", "html_url": "https://github.com/rust-lang/rust/commit/5468e12ca056a6ac46b36e244d235b9a0c987c58"}], "stats": {"total": 1464, "additions": 786, "deletions": 678}, "files": [{"sha": "ecd52a62eab2692601254ed5d9b17ce30593b293", "filename": "src/libsyntax/attr/builtin.rs", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=bd0fe736beb9142073da68b62a0002b12e1f9bc7", "patch": "@@ -0,0 +1,730 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Parsing and validation of builtin attributes\n+\n+use ast::{self, Attribute, MetaItem, Name, NestedMetaItemKind};\n+use errors::{Applicability, Handler};\n+use feature_gate::{Features, GatedCfg};\n+use parse::ParseSess;\n+use syntax_pos::{symbol::Symbol, Span};\n+\n+use super::{list_contains_name, mark_used, MetaItemKind};\n+\n+enum AttrError {\n+    MultipleItem(Name),\n+    UnknownMetaItem(Name, &'static [&'static str]),\n+    MissingSince,\n+    MissingFeature,\n+    MultipleStabilityLevels,\n+    UnsupportedLiteral\n+}\n+\n+fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n+    match error {\n+        AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n+                                                   \"multiple '{}' items\", item),\n+        AttrError::UnknownMetaItem(item, expected) => {\n+            let expected = expected\n+                .iter()\n+                .map(|name| format!(\"`{}`\", name))\n+                .collect::<Vec<_>>();\n+            struct_span_err!(diag, span, E0541, \"unknown meta item '{}'\", item)\n+                .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n+                .emit();\n+        }\n+        AttrError::MissingSince => span_err!(diag, span, E0542, \"missing 'since'\"),\n+        AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n+        AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n+                                                        \"multiple stability levels\"),\n+        AttrError::UnsupportedLiteral => span_err!(diag, span, E0565, \"unsupported literal\"),\n+    }\n+}\n+\n+#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum InlineAttr {\n+    None,\n+    Hint,\n+    Always,\n+    Never,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum UnwindAttr {\n+    Allowed,\n+    Aborts,\n+}\n+\n+/// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n+pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n+    let syntax_error = |attr: &Attribute| {\n+        mark_used(attr);\n+        diagnostic.map(|d| {\n+            span_err!(d, attr.span, E0633, \"malformed `#[unwind]` attribute\");\n+        });\n+        None\n+    };\n+\n+    attrs.iter().fold(None, |ia, attr| {\n+        if attr.path != \"unwind\" {\n+            return ia;\n+        }\n+        let meta = match attr.meta() {\n+            Some(meta) => meta.node,\n+            None => return ia,\n+        };\n+        match meta {\n+            MetaItemKind::Word => {\n+                syntax_error(attr)\n+            }\n+            MetaItemKind::List(ref items) => {\n+                mark_used(attr);\n+                if items.len() != 1 {\n+                    syntax_error(attr)\n+                } else if list_contains_name(&items[..], \"allowed\") {\n+                    Some(UnwindAttr::Allowed)\n+                } else if list_contains_name(&items[..], \"aborts\") {\n+                    Some(UnwindAttr::Aborts)\n+                } else {\n+                    syntax_error(attr)\n+                }\n+            }\n+            _ => ia,\n+        }\n+    })\n+}\n+\n+/// Represents the #[stable], #[unstable], #[rustc_{deprecated,const_unstable}] attributes.\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Stability {\n+    pub level: StabilityLevel,\n+    pub feature: Symbol,\n+    pub rustc_depr: Option<RustcDeprecation>,\n+    pub rustc_const_unstable: Option<RustcConstUnstable>,\n+}\n+\n+/// The available stability levels.\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub enum StabilityLevel {\n+    // Reason for the current stability level and the relevant rust-lang issue\n+    Unstable { reason: Option<Symbol>, issue: u32 },\n+    Stable { since: Symbol },\n+}\n+\n+impl StabilityLevel {\n+    pub fn is_unstable(&self) -> bool {\n+        if let StabilityLevel::Unstable {..} = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    pub fn is_stable(&self) -> bool {\n+        if let StabilityLevel::Stable {..} = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct RustcDeprecation {\n+    pub since: Symbol,\n+    pub reason: Symbol,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct RustcConstUnstable {\n+    pub feature: Symbol,\n+}\n+\n+/// Check if `attrs` contains an attribute like `#![feature(feature_name)]`.\n+/// This will not perform any \"sanity checks\" on the form of the attributes.\n+pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n+    attrs.iter().any(|item| {\n+        item.check_name(\"feature\") &&\n+        item.meta_item_list().map(|list| {\n+            list.iter().any(|mi| {\n+                mi.word().map(|w| w.name() == feature_name)\n+                         .unwrap_or(false)\n+            })\n+        }).unwrap_or(false)\n+    })\n+}\n+\n+/// Find the first stability attribute. `None` if none exists.\n+pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n+                      item_sp: Span) -> Option<Stability> {\n+    find_stability_generic(diagnostic, attrs.iter(), item_sp)\n+}\n+\n+fn find_stability_generic<'a, I>(diagnostic: &Handler,\n+                                 attrs_iter: I,\n+                                 item_sp: Span)\n+                                 -> Option<Stability>\n+    where I: Iterator<Item = &'a Attribute>\n+{\n+    use self::StabilityLevel::*;\n+\n+    let mut stab: Option<Stability> = None;\n+    let mut rustc_depr: Option<RustcDeprecation> = None;\n+    let mut rustc_const_unstable: Option<RustcConstUnstable> = None;\n+\n+    'outer: for attr in attrs_iter {\n+        if ![\n+            \"rustc_deprecated\",\n+            \"rustc_const_unstable\",\n+            \"unstable\",\n+            \"stable\",\n+        ].iter().any(|&s| attr.path == s) {\n+            continue // not a stability level\n+        }\n+\n+        mark_used(attr);\n+\n+        let meta = attr.meta();\n+        if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n+            let meta = meta.as_ref().unwrap();\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+                if item.is_some() {\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    return false\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\");\n+                    false\n+                }\n+            };\n+\n+            macro_rules! get_meta {\n+                ($($name:ident),+) => {\n+                    $(\n+                        let mut $name = None;\n+                    )+\n+                    for meta in metas {\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name().as_str() {\n+                                $(\n+                                    stringify!($name)\n+                                        => if !get(mi, &mut $name) { continue 'outer },\n+                                )+\n+                                _ => {\n+                                    let expected = &[ $( stringify!($name) ),+ ];\n+                                    handle_errors(\n+                                        diagnostic,\n+                                        mi.span,\n+                                        AttrError::UnknownMetaItem(mi.name(), expected));\n+                                    continue 'outer\n+                                }\n+                            }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n+                        }\n+                    }\n+                }\n+            }\n+\n+            match &*meta.name().as_str() {\n+                \"rustc_deprecated\" => {\n+                    if rustc_depr.is_some() {\n+                        span_err!(diagnostic, item_sp, E0540,\n+                                  \"multiple rustc_deprecated attributes\");\n+                        continue 'outer\n+                    }\n+\n+                    get_meta!(since, reason);\n+\n+                    match (since, reason) {\n+                        (Some(since), Some(reason)) => {\n+                            rustc_depr = Some(RustcDeprecation {\n+                                since,\n+                                reason,\n+                            })\n+                        }\n+                        (None, _) => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n+                            continue\n+                        }\n+                        _ => {\n+                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n+                            continue\n+                        }\n+                    }\n+                }\n+                \"rustc_const_unstable\" => {\n+                    if rustc_const_unstable.is_some() {\n+                        span_err!(diagnostic, item_sp, E0553,\n+                                  \"multiple rustc_const_unstable attributes\");\n+                        continue 'outer\n+                    }\n+\n+                    get_meta!(feature);\n+                    if let Some(feature) = feature {\n+                        rustc_const_unstable = Some(RustcConstUnstable {\n+                            feature\n+                        });\n+                    } else {\n+                        span_err!(diagnostic, attr.span(), E0629, \"missing 'feature'\");\n+                        continue\n+                    }\n+                }\n+                \"unstable\" => {\n+                    if stab.is_some() {\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n+                        break\n+                    }\n+\n+                    let mut feature = None;\n+                    let mut reason = None;\n+                    let mut issue = None;\n+                    for meta in metas {\n+                        if let Some(mi) = meta.meta_item() {\n+                            match &*mi.name().as_str() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n+                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(\n+                                        diagnostic,\n+                                        meta.span,\n+                                        AttrError::UnknownMetaItem(\n+                                            mi.name(),\n+                                            &[\"feature\", \"reason\", \"issue\"]\n+                                        ),\n+                                    );\n+                                    continue 'outer\n+                                }\n+                            }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n+                        }\n+                    }\n+\n+                    match (feature, reason, issue) {\n+                        (Some(feature), reason, Some(issue)) => {\n+                            stab = Some(Stability {\n+                                level: Unstable {\n+                                    reason,\n+                                    issue: {\n+                                        if let Ok(issue) = issue.as_str().parse() {\n+                                            issue\n+                                        } else {\n+                                            span_err!(diagnostic, attr.span(), E0545,\n+                                                      \"incorrect 'issue'\");\n+                                            continue\n+                                        }\n+                                    }\n+                                },\n+                                feature,\n+                                rustc_depr: None,\n+                                rustc_const_unstable: None,\n+                            })\n+                        }\n+                        (None, _, _) => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n+                            continue\n+                        }\n+                        _ => {\n+                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n+                            continue\n+                        }\n+                    }\n+                }\n+                \"stable\" => {\n+                    if stab.is_some() {\n+                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n+                        break\n+                    }\n+\n+                    let mut feature = None;\n+                    let mut since = None;\n+                    for meta in metas {\n+                        if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                            match &*mi.name().as_str() {\n+                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n+                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                                _ => {\n+                                    handle_errors(\n+                                        diagnostic,\n+                                        meta.span,\n+                                        AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n+                                    );\n+                                    continue 'outer\n+                                }\n+                            }\n+                        } else {\n+                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                            continue 'outer\n+                        }\n+                    }\n+\n+                    match (feature, since) {\n+                        (Some(feature), Some(since)) => {\n+                            stab = Some(Stability {\n+                                level: Stable {\n+                                    since,\n+                                },\n+                                feature,\n+                                rustc_depr: None,\n+                                rustc_const_unstable: None,\n+                            })\n+                        }\n+                        (None, _) => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n+                            continue\n+                        }\n+                        _ => {\n+                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n+                            continue\n+                        }\n+                    }\n+                }\n+                _ => unreachable!()\n+            }\n+        } else {\n+            span_err!(diagnostic, attr.span(), E0548, \"incorrect stability attribute type\");\n+            continue\n+        }\n+    }\n+\n+    // Merge the deprecation info into the stability info\n+    if let Some(rustc_depr) = rustc_depr {\n+        if let Some(ref mut stab) = stab {\n+            stab.rustc_depr = Some(rustc_depr);\n+        } else {\n+            span_err!(diagnostic, item_sp, E0549,\n+                      \"rustc_deprecated attribute must be paired with \\\n+                       either stable or unstable attribute\");\n+        }\n+    }\n+\n+    // Merge the const-unstable info into the stability info\n+    if let Some(rustc_const_unstable) = rustc_const_unstable {\n+        if let Some(ref mut stab) = stab {\n+            stab.rustc_const_unstable = Some(rustc_const_unstable);\n+        } else {\n+            span_err!(diagnostic, item_sp, E0630,\n+                      \"rustc_const_unstable attribute must be paired with \\\n+                       either stable or unstable attribute\");\n+        }\n+    }\n+\n+    stab\n+}\n+\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n+    super::first_attr_value_str_by_name(attrs, \"crate_name\")\n+}\n+\n+/// Tests if a cfg-pattern matches the cfg set\n+pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n+    eval_condition(cfg, sess, &mut |cfg| {\n+        if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n+            gated_cfg.check_and_emit(sess, feats);\n+        }\n+        sess.config.contains(&(cfg.name(), cfg.value_str()))\n+    })\n+}\n+\n+/// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n+/// evaluate individual items.\n+pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n+                         -> bool\n+    where F: FnMut(&ast::MetaItem) -> bool\n+{\n+    match cfg.node {\n+        ast::MetaItemKind::List(ref mis) => {\n+            for mi in mis.iter() {\n+                if !mi.is_meta_item() {\n+                    handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n+                    return false;\n+                }\n+            }\n+\n+            // The unwraps below may look dangerous, but we've already asserted\n+            // that they won't fail with the loop above.\n+            match &*cfg.name().as_str() {\n+                \"any\" => mis.iter().any(|mi| {\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n+                }),\n+                \"all\" => mis.iter().all(|mi| {\n+                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n+                }),\n+                \"not\" => {\n+                    if mis.len() != 1 {\n+                        span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n+                        return false;\n+                    }\n+\n+                    !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n+                },\n+                p => {\n+                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n+                    false\n+                }\n+            }\n+        },\n+        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n+            eval(cfg)\n+        }\n+    }\n+}\n+\n+\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n+pub struct Deprecation {\n+    pub since: Option<Symbol>,\n+    pub note: Option<Symbol>,\n+}\n+\n+/// Find the deprecation attribute. `None` if none exists.\n+pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n+                        item_sp: Span) -> Option<Deprecation> {\n+    find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n+}\n+\n+fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n+                                   attrs_iter: I,\n+                                   item_sp: Span)\n+                                   -> Option<Deprecation>\n+    where I: Iterator<Item = &'a Attribute>\n+{\n+    let mut depr: Option<Deprecation> = None;\n+\n+    'outer: for attr in attrs_iter {\n+        if attr.path != \"deprecated\" {\n+            continue\n+        }\n+\n+        mark_used(attr);\n+\n+        if depr.is_some() {\n+            span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\");\n+            break\n+        }\n+\n+        depr = if let Some(metas) = attr.meta_item_list() {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+                if item.is_some() {\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    return false\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\");\n+                    false\n+                }\n+            };\n+\n+            let mut since = None;\n+            let mut note = None;\n+            for meta in metas {\n+                if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n+                    match &*mi.name().as_str() {\n+                        \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                        \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                        _ => {\n+                            handle_errors(\n+                                diagnostic,\n+                                meta.span,\n+                                AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n+                            );\n+                            continue 'outer\n+                        }\n+                    }\n+                } else {\n+                    handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n+                    continue 'outer\n+                }\n+            }\n+\n+            Some(Deprecation {since: since, note: note})\n+        } else {\n+            Some(Deprecation{since: None, note: None})\n+        }\n+    }\n+\n+    depr\n+}\n+\n+#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+pub enum ReprAttr {\n+    ReprInt(IntType),\n+    ReprC,\n+    ReprPacked(u32),\n+    ReprSimd,\n+    ReprTransparent,\n+    ReprAlign(u32),\n+}\n+\n+#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+pub enum IntType {\n+    SignedInt(ast::IntTy),\n+    UnsignedInt(ast::UintTy)\n+}\n+\n+impl IntType {\n+    #[inline]\n+    pub fn is_signed(self) -> bool {\n+        use self::IntType::*;\n+\n+        match self {\n+            SignedInt(..) => true,\n+            UnsignedInt(..) => false\n+        }\n+    }\n+}\n+\n+/// Parse #[repr(...)] forms.\n+///\n+/// Valid repr contents: any of the primitive integral type names (see\n+/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n+/// the same discriminant size that the corresponding C enum would or C\n+/// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n+/// concerns to the only non-ZST field.\n+pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n+    use self::ReprAttr::*;\n+\n+    let mut acc = Vec::new();\n+    if attr.path == \"repr\" {\n+        if let Some(items) = attr.meta_item_list() {\n+            mark_used(attr);\n+            for item in items {\n+                if !item.is_meta_item() {\n+                    handle_errors(diagnostic, item.span, AttrError::UnsupportedLiteral);\n+                    continue\n+                }\n+\n+                let mut recognised = false;\n+                if let Some(mi) = item.word() {\n+                    let word = &*mi.name().as_str();\n+                    let hint = match word {\n+                        \"C\" => Some(ReprC),\n+                        \"packed\" => Some(ReprPacked(1)),\n+                        \"simd\" => Some(ReprSimd),\n+                        \"transparent\" => Some(ReprTransparent),\n+                        _ => match int_type_of_word(word) {\n+                            Some(ity) => Some(ReprInt(ity)),\n+                            None => {\n+                                None\n+                            }\n+                        }\n+                    };\n+\n+                    if let Some(h) = hint {\n+                        recognised = true;\n+                        acc.push(h);\n+                    }\n+                } else if let Some((name, value)) = item.name_value_literal() {\n+                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n+                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n+                            if literal.is_power_of_two() {\n+                                // rustc::ty::layout::Align restricts align to <= 2^29\n+                                if *literal <= 1 << 29 {\n+                                    Ok(*literal as u32)\n+                                } else {\n+                                    Err(\"larger than 2^29\")\n+                                }\n+                            } else {\n+                                Err(\"not a power of two\")\n+                            }\n+                        } else {\n+                            Err(\"not an unsuffixed integer\")\n+                        }\n+                    };\n+\n+                    let mut literal_error = None;\n+                    if name == \"align\" {\n+                        recognised = true;\n+                        match parse_alignment(&value.node) {\n+                            Ok(literal) => acc.push(ReprAlign(literal)),\n+                            Err(message) => literal_error = Some(message)\n+                        };\n+                    }\n+                    else if name == \"packed\" {\n+                        recognised = true;\n+                        match parse_alignment(&value.node) {\n+                            Ok(literal) => acc.push(ReprPacked(literal)),\n+                            Err(message) => literal_error = Some(message)\n+                        };\n+                    }\n+                    if let Some(literal_error) = literal_error {\n+                        span_err!(diagnostic, item.span, E0589,\n+                                  \"invalid `repr(align)` attribute: {}\", literal_error);\n+                    }\n+                } else {\n+                    if let Some(meta_item) = item.meta_item() {\n+                        if meta_item.name() == \"align\" {\n+                            if let MetaItemKind::NameValue(ref value) = meta_item.node {\n+                                recognised = true;\n+                                let mut err = struct_span_err!(diagnostic, item.span, E0693,\n+                                    \"incorrect `repr(align)` attribute format\");\n+                                match value.node {\n+                                    ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                                        err.span_suggestion_with_applicability(\n+                                            item.span,\n+                                            \"use parentheses instead\",\n+                                            format!(\"align({})\", int),\n+                                            Applicability::MachineApplicable\n+                                        );\n+                                    }\n+                                    ast::LitKind::Str(s, _) => {\n+                                        err.span_suggestion_with_applicability(\n+                                            item.span,\n+                                            \"use parentheses instead\",\n+                                            format!(\"align({})\", s),\n+                                            Applicability::MachineApplicable\n+                                        );\n+                                    }\n+                                    _ => {}\n+                                }\n+                                err.emit();\n+                            }\n+                        }\n+                    }\n+                }\n+                if !recognised {\n+                    // Not a word we recognize\n+                    span_err!(diagnostic, item.span, E0552,\n+                              \"unrecognized representation hint\");\n+                }\n+            }\n+        }\n+    }\n+    acc\n+}\n+\n+fn int_type_of_word(s: &str) -> Option<IntType> {\n+    use self::IntType::*;\n+\n+    match s {\n+        \"i8\" => Some(SignedInt(ast::IntTy::I8)),\n+        \"u8\" => Some(UnsignedInt(ast::UintTy::U8)),\n+        \"i16\" => Some(SignedInt(ast::IntTy::I16)),\n+        \"u16\" => Some(UnsignedInt(ast::UintTy::U16)),\n+        \"i32\" => Some(SignedInt(ast::IntTy::I32)),\n+        \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n+        \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n+        \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n+        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n+        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n+        \"isize\" => Some(SignedInt(ast::IntTy::Isize)),\n+        \"usize\" => Some(UnsignedInt(ast::UintTy::Usize)),\n+        _ => None\n+    }\n+}"}, {"sha": "4e27d6c15258bedef5e7e59e773f36533eac7ce4", "filename": "src/libsyntax/attr/mod.rs", "status": "renamed", "additions": 10, "deletions": 678, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=bd0fe736beb9142073da68b62a0002b12e1f9bc7", "patch": "@@ -8,20 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Functions dealing with attributes and meta items\n+//! Functions dealing with attributes and meta items\n \n-pub use self::StabilityLevel::*;\n-pub use self::ReprAttr::*;\n+mod builtin;\n+\n+pub use self::builtin::{\n+    cfg_matches, contains_feature_attr, eval_condition, find_crate_name, find_deprecation,\n+    find_repr_attrs, find_stability, find_unwind_attr, Deprecation, InlineAttr, IntType, ReprAttr,\n+    RustcConstUnstable, RustcDeprecation, Stability, StabilityLevel, UnwindAttr,\n+};\n pub use self::IntType::*;\n+pub use self::ReprAttr::*;\n+pub use self::StabilityLevel::*;\n \n use ast;\n use ast::{AttrId, Attribute, Name, Ident, Path, PathSegment};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind, GenericParam};\n use codemap::{BytePos, Spanned, respan, dummy_spanned};\n use syntax_pos::Span;\n-use errors::{Applicability, Handler};\n-use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::parser::Parser;\n use parse::{self, ParseSess, PResult};\n@@ -34,29 +39,6 @@ use GLOBALS;\n \n use std::iter;\n \n-enum AttrError {\n-    MultipleItem(Name),\n-    UnknownMetaItem(Name),\n-    MissingSince,\n-    MissingFeature,\n-    MultipleStabilityLevels,\n-    UnsupportedLiteral\n-}\n-\n-fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n-    match error {\n-        AttrError::MultipleItem(item) => span_err!(diag, span, E0538,\n-                                                   \"multiple '{}' items\", item),\n-        AttrError::UnknownMetaItem(item) => span_err!(diag, span, E0541,\n-                                                      \"unknown meta item '{}'\", item),\n-        AttrError::MissingSince => span_err!(diag, span, E0542, \"missing 'since'\"),\n-        AttrError::MissingFeature => span_err!(diag, span, E0546, \"missing 'feature'\"),\n-        AttrError::MultipleStabilityLevels => span_err!(diag, span, E0544,\n-                                                        \"multiple stability levels\"),\n-        AttrError::UnsupportedLiteral => span_err!(diag, span, E0565, \"unsupported literal\"),\n-    }\n-}\n-\n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n     let AttrId(id) = attr.id;\n@@ -442,7 +424,6 @@ pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     }\n }\n \n-\n /// Returns an outer attribute with the given value.\n pub fn mk_attr_outer(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_outer(span, id, item)\n@@ -495,655 +476,6 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<S\n         .and_then(|at| at.value_str())\n }\n \n-/// Check if `attrs` contains an attribute like `#![feature(feature_name)]`.\n-/// This will not perform any \"sanity checks\" on the form of the attributes.\n-pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n-    attrs.iter().any(|item| {\n-        item.check_name(\"feature\") &&\n-        item.meta_item_list().map(|list| {\n-            list.iter().any(|mi| {\n-                mi.word().map(|w| w.name() == feature_name)\n-                         .unwrap_or(false)\n-            })\n-        }).unwrap_or(false)\n-    })\n-}\n-\n-/* Higher-level applications */\n-\n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n-    first_attr_value_str_by_name(attrs, \"crate_name\")\n-}\n-\n-#[derive(Copy, Clone, Hash, PartialEq, RustcEncodable, RustcDecodable)]\n-pub enum InlineAttr {\n-    None,\n-    Hint,\n-    Always,\n-    Never,\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum UnwindAttr {\n-    Allowed,\n-    Aborts,\n-}\n-\n-/// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n-pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n-    let syntax_error = |attr: &Attribute| {\n-        mark_used(attr);\n-        diagnostic.map(|d| {\n-            span_err!(d, attr.span, E0633, \"malformed `#[unwind]` attribute\");\n-        });\n-        None\n-    };\n-\n-    attrs.iter().fold(None, |ia, attr| {\n-        if attr.path != \"unwind\" {\n-            return ia;\n-        }\n-        let meta = match attr.meta() {\n-            Some(meta) => meta.node,\n-            None => return ia,\n-        };\n-        match meta {\n-            MetaItemKind::Word => {\n-                syntax_error(attr)\n-            }\n-            MetaItemKind::List(ref items) => {\n-                mark_used(attr);\n-                if items.len() != 1 {\n-                    syntax_error(attr)\n-                } else if list_contains_name(&items[..], \"allowed\") {\n-                    Some(UnwindAttr::Allowed)\n-                } else if list_contains_name(&items[..], \"aborts\") {\n-                    Some(UnwindAttr::Aborts)\n-                } else {\n-                    syntax_error(attr)\n-                }\n-            }\n-            _ => ia,\n-        }\n-    })\n-}\n-\n-\n-/// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n-    eval_condition(cfg, sess, &mut |cfg| {\n-        if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n-            gated_cfg.check_and_emit(sess, feats);\n-        }\n-        sess.config.contains(&(cfg.name(), cfg.value_str()))\n-    })\n-}\n-\n-/// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n-/// evaluate individual items.\n-pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n-                         -> bool\n-    where F: FnMut(&ast::MetaItem) -> bool\n-{\n-    match cfg.node {\n-        ast::MetaItemKind::List(ref mis) => {\n-            for mi in mis.iter() {\n-                if !mi.is_meta_item() {\n-                    handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n-                    return false;\n-                }\n-            }\n-\n-            // The unwraps below may look dangerous, but we've already asserted\n-            // that they won't fail with the loop above.\n-            match &*cfg.name().as_str() {\n-                \"any\" => mis.iter().any(|mi| {\n-                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n-                }),\n-                \"all\" => mis.iter().all(|mi| {\n-                    eval_condition(mi.meta_item().unwrap(), sess, eval)\n-                }),\n-                \"not\" => {\n-                    if mis.len() != 1 {\n-                        span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n-                        return false;\n-                    }\n-\n-                    !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n-                },\n-                p => {\n-                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n-                    false\n-                }\n-            }\n-        },\n-        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n-            eval(cfg)\n-        }\n-    }\n-}\n-\n-/// Represents the #[stable], #[unstable], #[rustc_{deprecated,const_unstable}] attributes.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct Stability {\n-    pub level: StabilityLevel,\n-    pub feature: Symbol,\n-    pub rustc_depr: Option<RustcDeprecation>,\n-    pub rustc_const_unstable: Option<RustcConstUnstable>,\n-}\n-\n-/// The available stability levels.\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub enum StabilityLevel {\n-    // Reason for the current stability level and the relevant rust-lang issue\n-    Unstable { reason: Option<Symbol>, issue: u32 },\n-    Stable { since: Symbol },\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct RustcDeprecation {\n-    pub since: Symbol,\n-    pub reason: Symbol,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct RustcConstUnstable {\n-    pub feature: Symbol,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n-pub struct Deprecation {\n-    pub since: Option<Symbol>,\n-    pub note: Option<Symbol>,\n-}\n-\n-impl StabilityLevel {\n-    pub fn is_unstable(&self) -> bool { if let Unstable {..} = *self { true } else { false }}\n-    pub fn is_stable(&self) -> bool { if let Stable {..} = *self { true } else { false }}\n-}\n-\n-fn find_stability_generic<'a, I>(diagnostic: &Handler,\n-                                 attrs_iter: I,\n-                                 item_sp: Span)\n-                                 -> Option<Stability>\n-    where I: Iterator<Item = &'a Attribute>\n-{\n-    let mut stab: Option<Stability> = None;\n-    let mut rustc_depr: Option<RustcDeprecation> = None;\n-    let mut rustc_const_unstable: Option<RustcConstUnstable> = None;\n-\n-    'outer: for attr in attrs_iter {\n-        if ![\n-            \"rustc_deprecated\",\n-            \"rustc_const_unstable\",\n-            \"unstable\",\n-            \"stable\",\n-        ].iter().any(|&s| attr.path == s) {\n-            continue // not a stability level\n-        }\n-\n-        mark_used(attr);\n-\n-        let meta = attr.meta();\n-        if let Some(MetaItem { node: MetaItemKind::List(ref metas), .. }) = meta {\n-            let meta = meta.as_ref().unwrap();\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n-                    return false\n-                }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\");\n-                    false\n-                }\n-            };\n-\n-            macro_rules! get_meta {\n-                ($($name:ident),+) => {\n-                    $(\n-                        let mut $name = None;\n-                    )+\n-                    for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n-                                $(\n-                                    stringify!($name)\n-                                        => if !get(mi, &mut $name) { continue 'outer },\n-                                )+\n-                                _ => {\n-                                    handle_errors(diagnostic, mi.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                            continue 'outer\n-                        }\n-                    }\n-                }\n-            }\n-\n-            match &*meta.name().as_str() {\n-                \"rustc_deprecated\" => {\n-                    if rustc_depr.is_some() {\n-                        span_err!(diagnostic, item_sp, E0540,\n-                                  \"multiple rustc_deprecated attributes\");\n-                        continue 'outer\n-                    }\n-\n-                    get_meta!(since, reason);\n-\n-                    match (since, reason) {\n-                        (Some(since), Some(reason)) => {\n-                            rustc_depr = Some(RustcDeprecation {\n-                                since,\n-                                reason,\n-                            })\n-                        }\n-                        (None, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n-                            continue\n-                        }\n-                        _ => {\n-                            span_err!(diagnostic, attr.span(), E0543, \"missing 'reason'\");\n-                            continue\n-                        }\n-                    }\n-                }\n-                \"rustc_const_unstable\" => {\n-                    if rustc_const_unstable.is_some() {\n-                        span_err!(diagnostic, item_sp, E0553,\n-                                  \"multiple rustc_const_unstable attributes\");\n-                        continue 'outer\n-                    }\n-\n-                    get_meta!(feature);\n-                    if let Some(feature) = feature {\n-                        rustc_const_unstable = Some(RustcConstUnstable {\n-                            feature\n-                        });\n-                    } else {\n-                        span_err!(diagnostic, attr.span(), E0629, \"missing 'feature'\");\n-                        continue\n-                    }\n-                }\n-                \"unstable\" => {\n-                    if stab.is_some() {\n-                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n-                        break\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut reason = None;\n-                    let mut issue = None;\n-                    for meta in metas {\n-                        if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n-                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n-                                _ => {\n-                                    handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                            continue 'outer\n-                        }\n-                    }\n-\n-                    match (feature, reason, issue) {\n-                        (Some(feature), reason, Some(issue)) => {\n-                            stab = Some(Stability {\n-                                level: Unstable {\n-                                    reason,\n-                                    issue: {\n-                                        if let Ok(issue) = issue.as_str().parse() {\n-                                            issue\n-                                        } else {\n-                                            span_err!(diagnostic, attr.span(), E0545,\n-                                                      \"incorrect 'issue'\");\n-                                            continue\n-                                        }\n-                                    }\n-                                },\n-                                feature,\n-                                rustc_depr: None,\n-                                rustc_const_unstable: None,\n-                            })\n-                        }\n-                        (None, _, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n-                            continue\n-                        }\n-                        _ => {\n-                            span_err!(diagnostic, attr.span(), E0547, \"missing 'issue'\");\n-                            continue\n-                        }\n-                    }\n-                }\n-                \"stable\" => {\n-                    if stab.is_some() {\n-                        handle_errors(diagnostic, attr.span(), AttrError::MultipleStabilityLevels);\n-                        break\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut since = None;\n-                    for meta in metas {\n-                        if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.name().as_str() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                                _ => {\n-                                    handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n-                                    continue 'outer\n-                                }\n-                            }\n-                        } else {\n-                            handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                            continue 'outer\n-                        }\n-                    }\n-\n-                    match (feature, since) {\n-                        (Some(feature), Some(since)) => {\n-                            stab = Some(Stability {\n-                                level: Stable {\n-                                    since,\n-                                },\n-                                feature,\n-                                rustc_depr: None,\n-                                rustc_const_unstable: None,\n-                            })\n-                        }\n-                        (None, _) => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingFeature);\n-                            continue\n-                        }\n-                        _ => {\n-                            handle_errors(diagnostic, attr.span(), AttrError::MissingSince);\n-                            continue\n-                        }\n-                    }\n-                }\n-                _ => unreachable!()\n-            }\n-        } else {\n-            span_err!(diagnostic, attr.span(), E0548, \"incorrect stability attribute type\");\n-            continue\n-        }\n-    }\n-\n-    // Merge the deprecation info into the stability info\n-    if let Some(rustc_depr) = rustc_depr {\n-        if let Some(ref mut stab) = stab {\n-            stab.rustc_depr = Some(rustc_depr);\n-        } else {\n-            span_err!(diagnostic, item_sp, E0549,\n-                      \"rustc_deprecated attribute must be paired with \\\n-                       either stable or unstable attribute\");\n-        }\n-    }\n-\n-    // Merge the const-unstable info into the stability info\n-    if let Some(rustc_const_unstable) = rustc_const_unstable {\n-        if let Some(ref mut stab) = stab {\n-            stab.rustc_const_unstable = Some(rustc_const_unstable);\n-        } else {\n-            span_err!(diagnostic, item_sp, E0630,\n-                      \"rustc_const_unstable attribute must be paired with \\\n-                       either stable or unstable attribute\");\n-        }\n-    }\n-\n-    stab\n-}\n-\n-fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n-                                   attrs_iter: I,\n-                                   item_sp: Span)\n-                                   -> Option<Deprecation>\n-    where I: Iterator<Item = &'a Attribute>\n-{\n-    let mut depr: Option<Deprecation> = None;\n-\n-    'outer: for attr in attrs_iter {\n-        if attr.path != \"deprecated\" {\n-            continue\n-        }\n-\n-        mark_used(attr);\n-\n-        if depr.is_some() {\n-            span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\");\n-            break\n-        }\n-\n-        depr = if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n-                    return false\n-                }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\");\n-                    false\n-                }\n-            };\n-\n-            let mut since = None;\n-            let mut note = None;\n-            for meta in metas {\n-                if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.name().as_str() {\n-                        \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                        \"note\" => if !get(mi, &mut note) { continue 'outer },\n-                        _ => {\n-                            handle_errors(diagnostic, meta.span,\n-                                          AttrError::UnknownMetaItem(mi.name()));\n-                            continue 'outer\n-                        }\n-                    }\n-                } else {\n-                    handle_errors(diagnostic, meta.span, AttrError::UnsupportedLiteral);\n-                    continue 'outer\n-                }\n-            }\n-\n-            Some(Deprecation {since: since, note: note})\n-        } else {\n-            Some(Deprecation{since: None, note: None})\n-        }\n-    }\n-\n-    depr\n-}\n-\n-/// Find the first stability attribute. `None` if none exists.\n-pub fn find_stability(diagnostic: &Handler, attrs: &[Attribute],\n-                      item_sp: Span) -> Option<Stability> {\n-    find_stability_generic(diagnostic, attrs.iter(), item_sp)\n-}\n-\n-/// Find the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n-                        item_sp: Span) -> Option<Deprecation> {\n-    find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n-}\n-\n-\n-/// Parse #[repr(...)] forms.\n-///\n-/// Valid repr contents: any of the primitive integral type names (see\n-/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n-/// the same discriminant size that the corresponding C enum would or C\n-/// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n-/// concerns to the only non-ZST field.\n-pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n-    let mut acc = Vec::new();\n-    if attr.path == \"repr\" {\n-        if let Some(items) = attr.meta_item_list() {\n-            mark_used(attr);\n-            for item in items {\n-                if !item.is_meta_item() {\n-                    handle_errors(diagnostic, item.span, AttrError::UnsupportedLiteral);\n-                    continue\n-                }\n-\n-                let mut recognised = false;\n-                if let Some(mi) = item.word() {\n-                    let word = &*mi.name().as_str();\n-                    let hint = match word {\n-                        \"C\" => Some(ReprC),\n-                        \"packed\" => Some(ReprPacked(1)),\n-                        \"simd\" => Some(ReprSimd),\n-                        \"transparent\" => Some(ReprTransparent),\n-                        _ => match int_type_of_word(word) {\n-                            Some(ity) => Some(ReprInt(ity)),\n-                            None => {\n-                                None\n-                            }\n-                        }\n-                    };\n-\n-                    if let Some(h) = hint {\n-                        recognised = true;\n-                        acc.push(h);\n-                    }\n-                } else if let Some((name, value)) = item.name_value_literal() {\n-                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n-                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n-                            if literal.is_power_of_two() {\n-                                // rustc::ty::layout::Align restricts align to <= 2^29\n-                                if *literal <= 1 << 29 {\n-                                    Ok(*literal as u32)\n-                                } else {\n-                                    Err(\"larger than 2^29\")\n-                                }\n-                            } else {\n-                                Err(\"not a power of two\")\n-                            }\n-                        } else {\n-                            Err(\"not an unsuffixed integer\")\n-                        }\n-                    };\n-\n-                    let mut literal_error = None;\n-                    if name == \"align\" {\n-                        recognised = true;\n-                        match parse_alignment(&value.node) {\n-                            Ok(literal) => acc.push(ReprAlign(literal)),\n-                            Err(message) => literal_error = Some(message)\n-                        };\n-                    }\n-                    else if name == \"packed\" {\n-                        recognised = true;\n-                        match parse_alignment(&value.node) {\n-                            Ok(literal) => acc.push(ReprPacked(literal)),\n-                            Err(message) => literal_error = Some(message)\n-                        };\n-                    }\n-                    if let Some(literal_error) = literal_error {\n-                        span_err!(diagnostic, item.span, E0589,\n-                                  \"invalid `repr(align)` attribute: {}\", literal_error);\n-                    }\n-                } else {\n-                    if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.name() == \"align\" {\n-                            if let MetaItemKind::NameValue(ref value) = meta_item.node {\n-                                recognised = true;\n-                                let mut err = struct_span_err!(diagnostic, item.span, E0693,\n-                                    \"incorrect `repr(align)` attribute format\");\n-                                match value.node {\n-                                    ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n-                                        err.span_suggestion_with_applicability(\n-                                            item.span,\n-                                            \"use parentheses instead\",\n-                                            format!(\"align({})\", int),\n-                                            Applicability::MachineApplicable\n-                                        );\n-                                    }\n-                                    ast::LitKind::Str(s, _) => {\n-                                        err.span_suggestion_with_applicability(\n-                                            item.span,\n-                                            \"use parentheses instead\",\n-                                            format!(\"align({})\", s),\n-                                            Applicability::MachineApplicable\n-                                        );\n-                                    }\n-                                    _ => {}\n-                                }\n-                                err.emit();\n-                            }\n-                        }\n-                    }\n-                }\n-                if !recognised {\n-                    // Not a word we recognize\n-                    span_err!(diagnostic, item.span, E0552,\n-                              \"unrecognized representation hint\");\n-                }\n-            }\n-        }\n-    }\n-    acc\n-}\n-\n-fn int_type_of_word(s: &str) -> Option<IntType> {\n-    match s {\n-        \"i8\" => Some(SignedInt(ast::IntTy::I8)),\n-        \"u8\" => Some(UnsignedInt(ast::UintTy::U8)),\n-        \"i16\" => Some(SignedInt(ast::IntTy::I16)),\n-        \"u16\" => Some(UnsignedInt(ast::UintTy::U16)),\n-        \"i32\" => Some(SignedInt(ast::IntTy::I32)),\n-        \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n-        \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n-        \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n-        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n-        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n-        \"isize\" => Some(SignedInt(ast::IntTy::Isize)),\n-        \"usize\" => Some(UnsignedInt(ast::UintTy::Usize)),\n-        _ => None\n-    }\n-}\n-\n-#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n-pub enum ReprAttr {\n-    ReprInt(IntType),\n-    ReprC,\n-    ReprPacked(u32),\n-    ReprSimd,\n-    ReprTransparent,\n-    ReprAlign(u32),\n-}\n-\n-#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n-pub enum IntType {\n-    SignedInt(ast::IntTy),\n-    UnsignedInt(ast::UintTy)\n-}\n-\n-impl IntType {\n-    #[inline]\n-    pub fn is_signed(self) -> bool {\n-        match self {\n-            SignedInt(..) => true,\n-            UnsignedInt(..) => false\n-        }\n-    }\n-}\n-\n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n         let mut idents = vec![];", "previous_filename": "src/libsyntax/attr.rs"}, {"sha": "af2ac79ea80721808bcc49e694f9ba8e6c9f52a0", "filename": "src/test/ui/deprecation-sanity.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Ftest%2Fui%2Fdeprecation-sanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Ftest%2Fui%2Fdeprecation-sanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation-sanity.rs?ref=bd0fe736beb9142073da68b62a0002b12e1f9bc7", "previous_filename": "src/test/compile-fail/deprecation-sanity.rs"}, {"sha": "967eb6e23a379721c5c3e901e73c094b1400d8c7", "filename": "src/test/ui/deprecation-sanity.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Ftest%2Fui%2Fdeprecation-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd0fe736beb9142073da68b62a0002b12e1f9bc7/src%2Ftest%2Fui%2Fdeprecation-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation-sanity.stderr?ref=bd0fe736beb9142073da68b62a0002b12e1f9bc7", "patch": "@@ -0,0 +1,46 @@\n+error[E0541]: unknown meta item 'reason'\n+  --> $DIR/deprecation-sanity.rs:14:43\n+   |\n+LL |     #[deprecated(since = \"a\", note = \"a\", reason)] //~ ERROR unknown meta item 'reason'\n+   |                                           ^^^^^^ expected one of `since`, `note`\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:17:31\n+   |\n+LL |     #[deprecated(since = \"a\", note)] //~ ERROR incorrect meta item\n+   |                               ^^^^\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:20:18\n+   |\n+LL |     #[deprecated(since, note = \"a\")] //~ ERROR incorrect meta item\n+   |                  ^^^^^\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:23:31\n+   |\n+LL |     #[deprecated(since = \"a\", note(b))] //~ ERROR incorrect meta item\n+   |                               ^^^^^^^\n+\n+error[E0551]: incorrect meta item\n+  --> $DIR/deprecation-sanity.rs:26:18\n+   |\n+LL |     #[deprecated(since(b), note = \"a\")] //~ ERROR incorrect meta item\n+   |                  ^^^^^^^^\n+\n+error[E0550]: multiple deprecated attributes\n+  --> $DIR/deprecation-sanity.rs:32:1\n+   |\n+LL | fn multiple1() { } //~ ERROR multiple deprecated attributes\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error[E0538]: multiple 'since' items\n+  --> $DIR/deprecation-sanity.rs:34:27\n+   |\n+LL | #[deprecated(since = \"a\", since = \"b\", note = \"c\")] //~ ERROR multiple 'since' items\n+   |                           ^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors occurred: E0538, E0541, E0550, E0551.\n+For more information about an error, try `rustc --explain E0538`."}]}