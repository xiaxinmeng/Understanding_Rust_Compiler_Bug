{"sha": "7782f5d6926be7970ec474b74302f2298ceccd13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ODJmNWQ2OTI2YmU3OTcwZWM0NzRiNzQzMDJmMjI5OGNlY2NkMTM=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-23T09:44:04Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-23T16:00:19Z"}, "message": "(core::str) remove len_bytes alias", "tree": {"sha": "c05d8ace8e1398de239c130643d18c1bc5e77d81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c05d8ace8e1398de239c130643d18c1bc5e77d81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7782f5d6926be7970ec474b74302f2298ceccd13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7782f5d6926be7970ec474b74302f2298ceccd13", "html_url": "https://github.com/rust-lang/rust/commit/7782f5d6926be7970ec474b74302f2298ceccd13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7782f5d6926be7970ec474b74302f2298ceccd13/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b957c0942007e60ec9ea6773c964ea7bdc199af", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b957c0942007e60ec9ea6773c964ea7bdc199af", "html_url": "https://github.com/rust-lang/rust/commit/1b957c0942007e60ec9ea6773c964ea7bdc199af"}], "stats": {"total": 280, "additions": 135, "deletions": 145}, "files": [{"sha": "4d67877afd8acd07a20fbc995df38a23dae2fd0f", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -174,10 +174,10 @@ fn print(s: str) {\n }\n \n fn rest(s: str, start: uint) -> str {\n-    if (start >= str::len_bytes(s)) {\n+    if (start >= str::len(s)) {\n         \"\"\n     } else {\n-        str::slice(s, start, str::len_bytes(s))\n+        str::slice(s, start, str::len(s))\n     }\n }\n \n@@ -689,7 +689,7 @@ fn cmd_install(c: cargo) unsafe {\n         alt str::index(uuid, '/') {\n             option::some(idx) {\n                let source = str::slice(uuid, 0u, idx);\n-               uuid = str::slice(uuid, idx + 1u, str::len_bytes(uuid));\n+               uuid = str::slice(uuid, idx + 1u, str::len(uuid));\n                install_uuid_specific(c, wd, source, uuid);\n             }\n             option::none {\n@@ -701,7 +701,7 @@ fn cmd_install(c: cargo) unsafe {\n         alt str::index(name, '/') {\n             option::some(idx) {\n                let source = str::slice(name, 0u, idx);\n-               name = str::slice(name, idx + 1u, str::len_bytes(name));\n+               name = str::slice(name, idx + 1u, str::len(name));\n                install_named_specific(c, wd, source, name);\n             }\n             option::none {"}, {"sha": "23ddb56c8f0680ca189d4e8e0be9fe8efd984134", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -395,7 +395,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                               metas: provided_metas,\n                               dep_hashes: [str]) -> str {\n         fn len_and_str(s: str) -> str {\n-            ret #fmt[\"%u_%s\", str::len_bytes(s), s];\n+            ret #fmt[\"%u_%s\", str::len(s), s];\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> str {\n@@ -520,7 +520,7 @@ fn mangle(ss: path) -> str {\n \n     for s in ss {\n         alt s { path_name(s) | path_mod(s) {\n-          n += #fmt[\"%u%s\", str::len_bytes(s), s];\n+          n += #fmt[\"%u%s\", str::len(s), s];\n         } }\n     }\n     n += \"E\"; // End name-sequence.\n@@ -572,8 +572,7 @@ fn link_binary(sess: session,\n                 (config.os == session::os_linux ||\n                  config.os == session::os_freebsd) &&\n                 option::is_some(found) && option::get(found) == 0u {\n-                ret str::slice(filename, 3u,\n-                               str::len_bytes(filename));\n+                ret str::slice(filename, 3u, str::len(filename));\n             } else { ret filename; }\n         };\n         fn rmext(filename: str) -> str {"}, {"sha": "8f0570a434959fc600de840fc6f151014efe36b9", "filename": "src/comp/driver/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdiagnostic.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -210,7 +210,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     if elided {\n         let last_line = display_lines[vec::len(display_lines) - 1u];\n         let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n-        let indent = str::len_bytes(s);\n+        let indent = str::len(s);\n         let out = \"\";\n         while indent > 0u { out += \" \"; indent -= 1u; }\n         out += \"...\\n\";\n@@ -228,7 +228,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = str::len_bytes(fm.name) + digits + lo.col + 3u;\n+        let left = str::len(fm.name) + digits + lo.col + 3u;\n         let s = \"\";\n         while left > 0u { str::push_char(s, ' '); left -= 1u; }\n "}, {"sha": "8d0b8549062305aeb72a557b1e75298f3f19745a", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -13,7 +13,7 @@ import rustc::driver::diagnostic;\n fn version(argv0: str) {\n     let vers = \"unknown version\";\n     let env_vers = #env[\"CFG_VERSION\"];\n-    if str::len_bytes(env_vers) != 0u { vers = env_vers; }\n+    if str::len(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(#fmt[\"%s %s\\n\", argv0, vers]);\n     io::stdout().write_str(#fmt[\"host: %s\\n\", host_triple()]);\n }"}, {"sha": "1c04bc8c4c69ad1f3ea551d6edbac0f3837ffca5", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -777,7 +777,7 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: crate_ctxt, s: str) -> ValueRef {\n     let sc = str::as_buf(s) {|buf|\n-        llvm::LLVMConstString(buf, str::len_bytes(s) as unsigned, False)\n+        llvm::LLVMConstString(buf, str::len(s) as unsigned, False)\n     };\n     let g =\n         str::as_buf(cx.names(\"str\"),\n@@ -791,7 +791,7 @@ fn C_cstr(cx: crate_ctxt, s: str) -> ValueRef {\n // Returns a Plain Old LLVM String:\n fn C_postr(s: str) -> ValueRef {\n     ret str::as_buf(s) {|buf|\n-        llvm::LLVMConstString(buf, str::len_bytes(s) as unsigned, False)\n+        llvm::LLVMConstString(buf, str::len(s) as unsigned, False)\n     };\n }\n "}, {"sha": "47024432b4e126dd8f278c160e96a8162be315e4", "filename": "src/comp/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -48,7 +48,7 @@ const DW_ATE_unsigned_char: int = 0x08;\n \n fn llstr(s: str) -> ValueRef {\n     str::as_buf(s, {|sbuf|\n-        llvm::LLVMMDString(sbuf, str::len_bytes(s) as ctypes::c_uint)\n+        llvm::LLVMMDString(sbuf, str::len(s) as ctypes::c_uint)\n     })\n }\n fn lltag(lltag: int) -> ValueRef {\n@@ -167,8 +167,7 @@ fn create_compile_unit(cx: crate_ctxt, full_path: str)\n \n     let work_dir = cx.sess.working_dir;\n     let file_path = if str::starts_with(full_path, work_dir) {\n-        str::slice(full_path, str::len_bytes(work_dir),\n-                   str::len_bytes(full_path))\n+        str::slice(full_path, str::len(work_dir), str::len(full_path))\n     } else {\n         full_path\n     };"}, {"sha": "aeaf65db7f4c06414d05b8830e47ae8104a6e913", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -126,7 +126,7 @@ fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n }\n \n fn trans_str(bcx: block, s: str, dest: dest) -> block {\n-    let veclen = str::len_bytes(s) + 1u; // +1 for \\0\n+    let veclen = str::len(s) + 1u; // +1 for \\0\n     let {bcx: bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_str(bcx.tcx()), veclen);\n "}, {"sha": "c8b33687abe5e6afd828591fb168771f7a417ead", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -157,10 +157,9 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n \n fn get_line(fm: filemap, line: int) -> str unsafe {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n-    let end = alt str::index_from(*fm.src, '\\n', begin,\n-                                  str::len_bytes(*fm.src)) {\n+    let end = alt str::index_from(*fm.src, '\\n', begin, str::len(*fm.src)) {\n       some(e) { e }\n-      none { str::len_bytes(*fm.src) }\n+      none { str::len(*fm.src) }\n     };\n     str::slice(*fm.src, begin, end)\n }"}, {"sha": "86d925e87e65f9521f4bb054fa7c905eb2747239", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -64,7 +64,7 @@ fn new_reader(cm: codemap::codemap,\n               itr: @interner::interner<str>) -> reader {\n     let r = @{cm: cm,\n               span_diagnostic: span_diagnostic,\n-              src: filemap.src, len: str::len_bytes(*filemap.src),\n+              src: filemap.src, len: str::len(*filemap.src),\n               mutable col: 0u, mutable pos: 0u, mutable curr: -1 as char,\n               mutable chpos: filemap.start_pos.ch, mutable strs: [],\n               filemap: filemap, interner: itr};\n@@ -163,7 +163,7 @@ fn scan_exponent(rdr: reader) -> option<str> {\n             rdr.bump();\n         }\n         let exponent = scan_digits(rdr, 10u);\n-        if str::len_bytes(exponent) > 0u {\n+        if str::len(exponent) > 0u {\n             ret some(rslt + exponent);\n         } else { rdr.fatal(\"scan_exponent: bad fp literal\"); }\n     } else { ret none::<str>; }\n@@ -226,7 +226,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n             tp = if signed { either::left(ast::ty_i64) }\n                       else { either::right(ast::ty_u64) };\n         }\n-        if str::len_bytes(num_str) == 0u {\n+        if str::len(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n         let parsed = option::get(u64::from_str(num_str, base as u64));\n@@ -273,7 +273,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         ret token::LIT_FLOAT(interner::intern(*rdr.interner, num_str),\n                              ast::ty_f);\n     } else {\n-        if str::len_bytes(num_str) == 0u {\n+        if str::len(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n         let parsed = option::get(u64::from_str(num_str, base as u64));\n@@ -610,8 +610,8 @@ fn trim_whitespace_prefix_and_push_line(&lines: [str],\n                                         s: str, col: uint) unsafe {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n-        if col < str::len_bytes(s) {\n-            s1 = str::slice(s, col, str::len_bytes(s));\n+        if col < str::len(s) {\n+            s1 = str::slice(s, col, str::len(s));\n         } else { s1 = \"\"; }\n     } else { s1 = s; }\n     log(debug, \"pushing line: \" + s1);\n@@ -651,7 +651,7 @@ fn read_block_comment(rdr: reader, code_to_the_left: bool) -> cmnt {\n             }\n         }\n     }\n-    if str::len_bytes(curr_line) != 0u {\n+    if str::len(curr_line) != 0u {\n         trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n     }\n     let style = if code_to_the_left { trailing } else { isolated };"}, {"sha": "3ee31314299291cf31542cb6c0261ca033e91d5a", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -491,7 +491,7 @@ fn end(p: printer) { p.pretty_print(END); }\n fn eof(p: printer) { p.pretty_print(EOF); }\n \n fn word(p: printer, wrd: str) {\n-    p.pretty_print(STRING(wrd, str::len_bytes(wrd) as int));\n+    p.pretty_print(STRING(wrd, str::len(wrd) as int));\n }\n \n fn huge_word(p: printer, wrd: str) {"}, {"sha": "76ab2b4ecb542305df4a9bcc7a34d1045aa0359b", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -204,7 +204,7 @@ fn head(s: ps, w: str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s, str::len_bytes(w) + 1u);\n+    ibox(s, str::len(w) + 1u);\n     // keyword that starts the head\n     word_nbsp(s, w);\n }\n@@ -1465,7 +1465,7 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n     popen(s);\n     fn print_arg(s: ps, input: ast::arg) {\n         print_arg_mode(s, input.mode);\n-        if str::len_bytes(input.ident) > 0u {\n+        if str::len(input.ident) > 0u {\n             word_space(s, input.ident + \":\");\n         }\n         print_type(s, input.ty);\n@@ -1647,7 +1647,7 @@ fn print_string(s: ps, st: str) {\n \n fn escape_str(st: str, to_escape: char) -> str {\n     let out: str = \"\";\n-    let len = str::len_bytes(st);\n+    let len = str::len(st);\n     let i = 0u;\n     while i < len {\n         alt st[i] as char {"}, {"sha": "0ed630629b7193adba0392cdcf9b38d0a522fe79", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -129,9 +129,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n }\n \n-fn ty_to_short_str(cx: ctxt, typ: t) -> str unsafe {\n+fn ty_to_short_str(cx: ctxt, typ: t) -> str {\n     let s = encoder::encoded_ty(cx, typ);\n-    if str::len_bytes(s) >= 32u { s = str::slice(s, 0u, 32u); }\n+    if str::len(s) >= 32u { s = str::slice(s, 0u, 32u); }\n     ret s;\n }\n "}, {"sha": "90b0c7d34e5f415e70d06db5fb2dc9464a485065", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -27,13 +27,13 @@ fn parse_expected(line_num: uint, line: str) -> [expected_error] unsafe {\n     let idx;\n     alt str::find(line, error_tag) {\n          option::none { ret []; }\n-         option::some(nn) { idx = (nn as uint) + str::len_bytes(error_tag); }\n+         option::some(nn) { idx = (nn as uint) + str::len(error_tag); }\n     }\n \n     // \"//!^^^ kind msg\" denotes a message expected\n     // three lines above current line:\n     let adjust_line = 0u;\n-    let len = str::len_bytes(line);\n+    let len = str::len(line);\n     while idx < len && line[idx] == ('^' as u8) {\n         adjust_line += 1u;\n         idx += 1u;"}, {"sha": "099598d7fdb5281930e56a67291b728b0b5dcdee", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -108,10 +108,8 @@ fn parse_name_value_directive(line: str,\n     let keycolon = directive + \":\";\n     alt str::find(line, keycolon) {\n         option::some(colon) {\n-            let value =\n-                str::slice(line,\n-                                         colon + str::len_bytes(keycolon),\n-                                         str::len_bytes(line));\n+            let value = str::slice(line, colon + str::len(keycolon),\n+                                   str::len(line));\n             #debug(\"%s: %s\", directive,  value);\n             option::some(value)\n         }"}, {"sha": "4b614d1f08b6ab90e3fc46c4bfb3cbc705a17227", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -287,7 +287,7 @@ fn check_variants_T<T: copy>(\n \n fn last_part(filename: str) -> str {\n   let ix = option::get(str::rindex(filename, '/'));\n-  str::slice(filename, ix + 1u, str::len_bytes(filename) - 3u)\n+  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n }\n \n enum happiness { passed, cleanly_rejected(str), known_bug(str), failed(str), }\n@@ -335,7 +335,7 @@ fn removeDirIfExists(filename: str) {\n fn check_running(exe_filename: str) -> happiness {\n     let p = std::run::program_output(\"/Users/jruderman/scripts/timed_run_rust_program.py\", [exe_filename]);\n     let comb = p.out + \"\\n\" + p.err;\n-    if str::len_bytes(comb) > 1u {\n+    if str::len(comb) > 1u {\n         log(error, \"comb comb comb: \" + comb);\n     }\n "}, {"sha": "b5e2eade244cbcd7d307ea85918207d625b272e5", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -82,10 +82,10 @@ mod ct {\n \n     fn parse_fmt_string(s: str, error: error_fn) -> [piece] unsafe {\n         let pieces: [piece] = [];\n-        let lim = str::len_bytes(s);\n+        let lim = str::len(s);\n         let buf = \"\";\n         fn flush_buf(buf: str, &pieces: [piece]) -> str {\n-            if str::len_bytes(buf) > 0u {\n+            if str::len(buf) > 0u {\n                 let piece = piece_string(buf);\n                 pieces += [piece];\n             }\n@@ -433,12 +433,12 @@ mod rt {\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n-        if signed && zero_padding && str::len_bytes(s) > 0u {\n+        if signed && zero_padding && str::len(s) > 0u {\n             let head = s[0];\n             if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n                 let headstr = str::from_bytes([head]);\n                 // FIXME: not UTF-8 safe\n-                let bytelen = str::len_bytes(s);\n+                let bytelen = str::len(s);\n                 let numpart = str::slice(s, 1u, bytelen);\n                 ret headstr + padstr + numpart;\n             }"}, {"sha": "cea46dedf44d6af94d1cdff620289947a6976b35", "filename": "src/libcore/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -133,7 +133,7 @@ number represented by [num].\n fn from_str(num: str) -> option<float> {\n    let pos = 0u;                  //Current byte position in the string.\n                                   //Used to walk the string in O(n).\n-   let len = str::len_bytes(num);  //Length of the string, in bytes.\n+   let len = str::len(num);  //Length of the string, in bytes.\n \n    if len == 0u { ret none; }\n    let total = 0f;                //Accumulated result"}, {"sha": "c199ead460f560a9098e00f8402c01b40330ed7f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -87,7 +87,7 @@ export\n    is_empty,\n    is_not_empty,\n    is_whitespace,\n-   len, len_bytes,\n+   len,\n    len_chars,\n \n    // Misc\n@@ -277,7 +277,7 @@ Failure:\n If the string does not contain any characters.\n */\n fn pop_char(&s: str) -> char unsafe {\n-    let end = len_bytes(s);\n+    let end = len(s);\n     let {ch:ch, prev:end} = char_range_at_reverse(s, end);\n     s = unsafe::slice_bytes(s, 0u, end);\n     ret ch;\n@@ -294,7 +294,7 @@ If the string does not contain any characters.\n */\n fn shift_char(&s: str) -> char unsafe {\n     let r = char_range_at(s, 0u);\n-    s = unsafe::slice_bytes(s, r.next, len_bytes(s));\n+    s = unsafe::slice_bytes(s, r.next, len(s));\n     ret r.ch;\n }\n \n@@ -373,7 +373,7 @@ Convert a string to a vector of characters\n fn chars(s: str) -> [char] {\n     let buf: [char] = [];\n     let i = 0u;\n-    let len = len_bytes(s);\n+    let len = len(s);\n     while i < len {\n         let cur = char_range_at(s, i);\n         buf += [cur.ch];\n@@ -474,7 +474,7 @@ fn splitn_byte(ss: str, sep: u8, count: uint) -> [str] unsafe {\n     assert u8::is_ascii(sep);\n \n     let vv = [];\n-    let start = 0u, current = 0u, len = len_bytes(ss);\n+    let start = 0u, current = 0u, len = len(ss);\n     let splits_done = 0u;\n \n     while splits_done < count && current < len {\n@@ -504,7 +504,7 @@ fn split_str(ss: str, sep: str) -> [str] unsafe {\n     // unsafe is justified: we are splitting\n     // UTF-8 with UTF-8, so the results will be OK\n \n-    let sep_len = len_bytes(sep);\n+    let sep_len = len(sep);\n     assert sep_len > 0u;\n     let vv = [];\n     let start = 0u, start_match = 0u, current = 0u, matching = 0u;\n@@ -581,7 +581,7 @@ up to `count` times\n fn splitn_char(ss: str, sep: char, count: uint) -> [str] unsafe {\n \n    let vv = [];\n-   let start = 0u, current = 0u, len = len_bytes(ss);\n+   let start = 0u, current = 0u, len = len(ss);\n    let splits_done = 0u;\n \n    while splits_done < count && current < len {\n@@ -688,11 +688,11 @@ The original string with all occurances of `from` replaced with `to`\n */\n fn replace(s: str, from: str, to: str) -> str unsafe {\n     assert is_not_empty(from);\n-    if len_bytes(s) == 0u {\n+    if len(s) == 0u {\n         ret \"\";\n     } else if starts_with(s, from) {\n         ret to + replace(\n-                     unsafe::slice_bytes(s, len_bytes(from), len_bytes(s)),\n+                     unsafe::slice_bytes(s, len(from), len(s)),\n                                        from, to);\n     } else {\n         let idx;\n@@ -701,8 +701,8 @@ fn replace(s: str, from: str, to: str) -> str unsafe {\n             none { ret s; }\n         }\n         let before = unsafe::slice_bytes(s, 0u, idx as uint);\n-        let after  = unsafe::slice_bytes(s, idx as uint + len_bytes(from),\n-                                         len_bytes(s));\n+        let after  = unsafe::slice_bytes(s, idx as uint + len(from),\n+                                         len(s));\n         ret before + to + replace(after, from, to);\n     }\n }\n@@ -761,7 +761,7 @@ Return true if a predicate matches all characters or\n if the string contains no characters\n */\n fn all(s: str, it: fn(char) -> bool) -> bool{\n-    ret substr_all(s, 0u, len_bytes(s), it);\n+    ret substr_all(s, 0u, len(s), it);\n }\n \n /*\n@@ -781,7 +781,7 @@ Apply a function to each character\n */\n fn map(ss: str, ff: fn(char) -> char) -> str {\n     let result = \"\";\n-    reserve(result, len_bytes(ss));\n+    reserve(result, len(ss));\n \n     chars_iter(ss, {|cc|\n         str::push_char(result, ff(cc));\n@@ -797,7 +797,7 @@ Iterate over the bytes in a string\n */\n fn bytes_iter(ss: str, it: fn(u8)) {\n     let pos = 0u;\n-    let len = len_bytes(ss);\n+    let len = len(ss);\n \n     while (pos < len) {\n         it(ss[pos]);\n@@ -811,7 +811,7 @@ Function: chars_iter\n Iterate over the characters in a string\n */\n fn chars_iter(s: str, it: fn(char)) {\n-    let pos = 0u, len = len_bytes(s);\n+    let pos = 0u, len = len(s);\n     while (pos < len) {\n         let {ch, next} = char_range_at(s, pos);\n         pos = next;\n@@ -866,7 +866,7 @@ Section: Searching\n // Returns the byte index of the first matching char\n // (as option some/none)\n fn index(ss: str, cc: char) -> option<uint> {\n-    index_from(ss, cc, 0u, len_bytes(ss))\n+    index_from(ss, cc, 0u, len(ss))\n }\n \n // Function: index_from\n@@ -897,7 +897,7 @@ fn index_from(ss: str, cc: char, start: uint, end: uint) -> option<uint> {\n fn index_chars(ss: str, cc: char) -> option<uint> {\n     let bii = 0u;\n     let cii = 0u;\n-    let len = len_bytes(ss);\n+    let len = len(ss);\n     while bii < len {\n         let {ch, next} = char_range_at(ss, bii);\n \n@@ -920,7 +920,7 @@ fn index_chars(ss: str, cc: char) -> option<uint> {\n // (as option some/none)\n // FIXME: delete\n fn byte_index(s: str, b: u8) -> option<uint> {\n-    byte_index_from(s, b, 0u, len_bytes(s))\n+    byte_index_from(s, b, 0u, len(s))\n }\n \n // Function: byte_index_from\n@@ -930,7 +930,7 @@ fn byte_index(s: str, b: u8) -> option<uint> {\n // (as option some/none)\n // FIXME: delete\n fn byte_index_from(s: str, b: u8, start: uint, end: uint) -> option<uint> {\n-    assert end <= len_bytes(s);\n+    assert end <= len(s);\n \n     str::as_bytes(s) { |v| vec::position_from(v, start, end) { |x| x == b } }\n }\n@@ -940,7 +940,7 @@ fn byte_index_from(s: str, b: u8, start: uint, end: uint) -> option<uint> {\n // Returns the byte index of the first matching char\n // (as option some/none)\n fn rindex(ss: str, cc: char) -> option<uint> {\n-    let bii = len_bytes(ss);\n+    let bii = len(ss);\n     while bii > 0u {\n         let {ch, prev} = char_range_at_reverse(ss, bii);\n         bii = prev;\n@@ -960,7 +960,7 @@ fn rindex(ss: str, cc: char) -> option<uint> {\n // Returns the char index of the first matching char\n // (as option some/none)\n fn rindex_chars(ss: str, cc: char) -> option<uint> {\n-    let bii = len_bytes(ss);\n+    let bii = len(ss);\n     let cii = len_chars(ss);\n     while bii > 0u {\n         let {ch, prev} = char_range_at_reverse(ss, bii);\n@@ -982,7 +982,7 @@ fn rindex_chars(ss: str, cc: char) -> option<uint> {\n // Find the byte position of the first instance of one string\n // within another, or return option::none\n fn find(haystack: str, needle: str) -> option<uint> {\n-    find_from(haystack, needle, 0u, len_bytes(haystack))\n+    find_from(haystack, needle, 0u, len(haystack))\n }\n \n //Function: find_from\n@@ -993,9 +993,9 @@ fn find(haystack: str, needle: str) -> option<uint> {\n // FIXME: Boyer-Moore should be significantly faster\n fn find_from(haystack: str, needle: str, start: uint, end:uint)\n   -> option<uint> {\n-    assert end <= len_bytes(haystack);\n+    assert end <= len(haystack);\n \n-    let needle_len = len_bytes(needle);\n+    let needle_len = len(needle);\n \n     if needle_len == 0u { ret some(start); }\n     if needle_len > end { ret none; }\n@@ -1031,7 +1031,7 @@ fn find_chars(haystack: str, needle: str) -> option<uint> {\n // Convert a byte position into a char position\n // within a given string\n fn b2c_pos(ss: str, bpos: uint) -> uint {\n-   assert bpos == 0u || bpos < len_bytes(ss);\n+   assert bpos == 0u || bpos < len(ss);\n \n    let ii = 0u;\n    let cpos = 0u;\n@@ -1070,8 +1070,8 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn starts_with(haystack: str, needle: str) -> bool unsafe {\n-    let haystack_len: uint = len_bytes(haystack);\n-    let needle_len: uint = len_bytes(needle);\n+    let haystack_len: uint = len(haystack);\n+    let needle_len: uint = len(needle);\n     if needle_len == 0u { ret true; }\n     if needle_len > haystack_len { ret false; }\n     ret eq(unsafe::slice_bytes(haystack, 0u, needle_len), needle);\n@@ -1108,7 +1108,7 @@ Function: is_ascii\n Determines if a string contains only ASCII characters\n */\n fn is_ascii(s: str) -> bool {\n-    let i: uint = len_bytes(s);\n+    let i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n@@ -1137,10 +1137,11 @@ fn is_whitespace(s: str) -> bool {\n }\n \n \n-// Function: len_bytes\n+// Function: len\n //\n-// Returns the string length in bytes\n-pure fn len_bytes(s: str) -> uint unsafe {\n+// Returns the string length/size in bytes\n+// not counting the null terminator\n+pure fn len(s: str) -> uint unsafe {\n     as_bytes(s) { |v|\n         let vlen = vec::len(v);\n         // There should always be a null terminator\n@@ -1149,14 +1150,8 @@ pure fn len_bytes(s: str) -> uint unsafe {\n     }\n }\n \n-// Function: len\n-//\n-// String length or size in characters.\n-// (Synonym: len_bytes)\n-fn len(s: str) -> uint { len_bytes(s) }\n-\n fn len_chars(s: str) -> uint {\n-    substr_len_chars(s, 0u, len_bytes(s))\n+    substr_len_chars(s, 0u, len(s))\n }\n \n /*\n@@ -1277,7 +1272,7 @@ This function can be used to iterate over the unicode characters of a string.\n Example:\n > let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n > let i = 0u;\n-> while i < str::len_bytes(s) {\n+> while i < str::len(s) {\n >    let {ch, next} = str::char_range_at(s, i);\n >    std::io::println(#fmt(\"%u: %c\",i,ch));\n >    i = next;\n@@ -1517,7 +1512,7 @@ mod unsafe {\n    unsafe fn slice_bytes(s: str, begin: uint, end: uint) -> str unsafe {\n        // FIXME: Typestate precondition\n        assert (begin <= end);\n-       assert (end <= len_bytes(s));\n+       assert (end <= len(s));\n \n        let v = as_bytes(s) { |v| vec::slice(v, begin, end) };\n        v += [0u8];\n@@ -1534,7 +1529,7 @@ mod unsafe {\n    unsafe fn slice_bytes_safe_range(s: str, begin: uint, end: uint)\n        : uint::le(begin, end) -> str {\n        // would need some magic to make this a precondition\n-       assert (end <= len_bytes(s));\n+       assert (end <= len(s));\n        ret slice_bytes(s, begin, end);\n    }\n \n@@ -1556,7 +1551,7 @@ mod unsafe {\n    //\n    // Removes the last byte from a string and returns it.  (Not UTF-8 safe).\n    unsafe fn pop_byte(&s: str) -> u8 unsafe {\n-       let len = len_bytes(s);\n+       let len = len(s);\n        assert (len > 0u);\n        let b = s[len - 1u];\n        s = unsafe::slice_bytes(s, 0u, len - 1u);\n@@ -1567,7 +1562,7 @@ mod unsafe {\n    //\n    // Removes the first byte from a string and returns it. (Not UTF-8 safe).\n    unsafe fn shift_byte(&s: str) -> u8 unsafe {\n-       let len = len_bytes(s);\n+       let len = len(s);\n        assert (len > 0u);\n        let b = s[0];\n        s = unsafe::slice_bytes(s, 1u, len);\n@@ -1597,13 +1592,13 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        assert (len_bytes(\"\") == 0u);\n-        assert (len_bytes(\"hello world\") == 11u);\n-        assert (len_bytes(\"\\x63\") == 1u);\n-        assert (len_bytes(\"\\xa2\") == 2u);\n-        assert (len_bytes(\"\\u03c0\") == 2u);\n-        assert (len_bytes(\"\\u2620\") == 3u);\n-        assert (len_bytes(\"\\U0001d11e\") == 4u);\n+        assert (len(\"\") == 0u);\n+        assert (len(\"hello world\") == 11u);\n+        assert (len(\"\\x63\") == 1u);\n+        assert (len(\"\\xa2\") == 2u);\n+        assert (len(\"\\u03c0\") == 2u);\n+        assert (len(\"\\u2620\") == 3u);\n+        assert (len(\"\\U0001d11e\") == 4u);\n \n         assert (len_chars(\"\") == 0u);\n         assert (len_chars(\"hello world\") == 11u);\n@@ -1906,7 +1901,7 @@ mod tests {\n     #[test]\n     fn test_substr() {\n         fn t(a: str, b: str, start: int) {\n-            assert (eq(substr(a, start as uint, len_bytes(b)), b));\n+            assert (eq(substr(a, start as uint, len(b)), b));\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n@@ -2285,7 +2280,7 @@ mod tests {\n         let v: [u8] = bytes(s1);\n         let s2: str = from_bytes(v);\n         let i: uint = 0u;\n-        let n1: uint = len_bytes(s1);\n+        let n1: uint = len(s1);\n         let n2: uint = vec::len::<u8>(v);\n         assert (n1 == n2);\n         while i < n1 {"}, {"sha": "77b658f0662349768e2e3b98f82355257f6a8d7a", "filename": "src/libcore/u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -118,8 +118,8 @@ Function: from_str\n Parse a string as an unsigned integer.\n */\n fn from_str(buf: str, radix: u64) -> option<u64> {\n-    if str::len_bytes(buf) == 0u { ret none; }\n-    let i = str::len_bytes(buf) - 1u;\n+    if str::len(buf) == 0u { ret none; }\n+    let i = str::len(buf) - 1u;\n     let power = 1u64, n = 0u64;\n     while true {\n         alt char::to_digit(buf[i] as char, radix as uint) {"}, {"sha": "230c6a2e90c550746d5b15832024cbebe3f0e90c", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -248,7 +248,7 @@ fn to_str(num: uint, radix: uint) -> str {\n         n /= radix;\n     }\n     let s1: str = \"\";\n-    let len: uint = str::len_bytes(s);\n+    let len: uint = str::len(s);\n     while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n     ret s1;\n }"}, {"sha": "3ba2f8b105ad0918ca9c7a2897eb2434a47e726e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -45,7 +45,7 @@ fn splitDirnameBasename (pp: path) -> {dirname: str, basename: str} {\n     }\n \n     ret {dirname: str::slice(pp, 0u, ii),\n-         basename: str::slice(pp, ii + 1u, str::len_bytes(pp))};\n+         basename: str::slice(pp, ii + 1u, str::len(pp))};\n }\n \n /*\n@@ -93,8 +93,8 @@ fn connect(pre: path, post: path) -> path unsafe {\n     let pre_ = pre;\n     let post_ = post;\n     let sep = os_fs::path_sep as u8;\n-    let pre_len = str::len_bytes(pre);\n-    let post_len = str::len_bytes(post);\n+    let pre_len  = str::len(pre);\n+    let post_len = str::len(post);\n     if pre_len > 1u && pre[pre_len-1u] == sep { str::unsafe::pop_byte(pre_); }\n     if post_len > 1u && post[0] == sep { str::unsafe::shift_byte(post_); }\n     ret pre_ + path_sep() + post_;\n@@ -170,7 +170,7 @@ Lists the contents of a directory.\n */\n fn list_dir(p: path) -> [str] {\n     let p = p;\n-    let pl = str::len_bytes(p);\n+    let pl = str::len(p);\n     if pl == 0u || p[pl - 1u] as char != os_fs::path_sep { p += path_sep(); }\n     let full_paths: [str] = [];\n     for filename: str in os_fs::list_dir(p) {\n@@ -336,7 +336,7 @@ fn normalize(p: path) -> path {\n     let s = reabsolute(p, s);\n     let s = reterminate(p, s);\n \n-    let s = if str::len_bytes(s) == 0u {\n+    let s = if str::len(s) == 0u {\n         \".\"\n     } else {\n         s\n@@ -403,7 +403,7 @@ fn normalize(p: path) -> path {\n     }\n \n     fn reterminate(orig: path, new: path) -> path {\n-        let last = orig[str::len_bytes(orig) - 1u];\n+        let last = orig[str::len(orig) - 1u];\n         if last == os_fs::path_sep as u8\n             || last == os_fs::path_sep as u8 {\n             ret new + path_sep();"}, {"sha": "7b409053cb0b16e0889ce45f0691433a4cbe390e", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -79,7 +79,7 @@ A description of a possible option\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n fn mkname(nm: str) -> name {\n-    ret if str::len_bytes(nm) == 1u {\n+    ret if str::len(nm) == 1u {\n             short(str::char_at(nm, 0u))\n         } else { long(nm) };\n }\n@@ -141,7 +141,7 @@ of matches and a vector of free strings.\n type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n \n fn is_arg(arg: str) -> bool {\n-    ret str::len_bytes(arg) > 1u && arg[0] == '-' as u8;\n+    ret str::len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: name) -> str {\n@@ -218,7 +218,7 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n     let i = 0u;\n     while i < l {\n         let cur = args[i];\n-        let curlen = str::len_bytes(cur);\n+        let curlen = str::len(cur);\n         if !is_arg(cur) {\n             free += [cur];\n         } else if str::eq(cur, \"--\") {"}, {"sha": "7a888f250eda3ec0f83e3482869f42ad0fd04b3e", "filename": "src/libstd/json.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -70,13 +70,13 @@ fn to_str(j: json) -> str {\n }\n \n fn rest(s: str) -> str {\n-    assert(str::len_bytes(s) >= 1u);\n-    str::slice(s, 1u, str::len_bytes(s))\n+    assert(str::len(s) >= 1u);\n+    str::slice(s, 1u, str::len(s))\n }\n \n fn from_str_str(s: str) -> (option<json>, str) {\n     let pos = 0u;\n-    let len = str::len_bytes(s);\n+    let len = str::len(s);\n     let escape = false;\n     let res = \"\";\n \n@@ -99,7 +99,7 @@ fn from_str_str(s: str) -> (option<json>, str) {\n             cont;\n         } else if (c == '\"') {\n             ret (some(string(res)),\n-                 str::slice(s, pos, str::len_bytes(s)));\n+                 str::slice(s, pos, str::len(s)));\n         }\n         res = res + str::from_char(c);\n     }\n@@ -172,7 +172,7 @@ fn from_str_dict(s: str) -> (option<json>, str) {\n \n fn from_str_float(s: str) -> (option<json>, str) {\n     let pos = 0u;\n-    let len = str::len_bytes(s);\n+    let len = str::len(s);\n     let res = 0f;\n     let neg = 1f;\n \n@@ -200,13 +200,13 @@ fn from_str_float(s: str) -> (option<json>, str) {\n             }\n             '.' { break; }\n             _ { ret (some(num(neg * res)),\n-                     str::slice(s, opos, str::len_bytes(s))); }\n+                     str::slice(s, opos, str::len(s))); }\n         }\n     }\n \n     if pos == len {\n         ret (some(num(neg * res)),\n-             str::slice(s, pos, str::len_bytes(s)));\n+             str::slice(s, pos, str::len(s)));\n     }\n \n     let dec = 1f;\n@@ -221,25 +221,25 @@ fn from_str_float(s: str) -> (option<json>, str) {\n                 res += (((c as int) - ('0' as int)) as float) * dec;\n             }\n             _ { ret (some(num(neg * res)),\n-                     str::slice(s, opos, str::len_bytes(s))); }\n+                     str::slice(s, opos, str::len(s))); }\n         }\n     }\n-    ret (some(num(neg * res)), str::slice(s, pos, str::len_bytes(s)));\n+    ret (some(num(neg * res)), str::slice(s, pos, str::len(s)));\n }\n \n fn from_str_bool(s: str) -> (option<json>, str) {\n     if (str::starts_with(s, \"true\")) {\n-        (some(boolean(true)), str::slice(s, 4u, str::len_bytes(s)))\n+        (some(boolean(true)), str::slice(s, 4u, str::len(s)))\n     } else if (str::starts_with(s, \"false\")) {\n-        (some(boolean(false)), str::slice(s, 5u, str::len_bytes(s)))\n+        (some(boolean(false)), str::slice(s, 5u, str::len(s)))\n     } else {\n         (none, s)\n     }\n }\n \n fn from_str_null(s: str) -> (option<json>, str) {\n     if (str::starts_with(s, \"null\")) {\n-        (some(null), str::slice(s, 4u, str::len_bytes(s)))\n+        (some(null), str::slice(s, 4u, str::len(s)))\n     } else {\n         (none, s)\n     }"}, {"sha": "35525b70710ac4f6a6cb0514758e041a1c3064f2", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -77,7 +77,7 @@ fn mk_rng() -> rng {\n             let i = 0u;\n             while (i < len) {\n                 let n = rustrt::rand_next(**self) as uint %\n-                    str::len_bytes(charset);\n+                    str::len(charset);\n                 s = s + str::from_char(str::char_at(charset, n));\n                 i += 1u;\n             }\n@@ -130,8 +130,8 @@ mod tests {\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n-        assert(str::len_bytes(r.gen_str(10u)) == 10u);\n-        assert(str::len_bytes(r.gen_str(16u)) == 16u);\n+        assert(str::len(r.gen_str(10u)) == 10u);\n+        assert(str::len(r.gen_str(16u)) == 16u);\n     }\n }\n "}, {"sha": "81800afffa5eb8bb191dad395b9b8eca3e40e71a", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -65,7 +65,7 @@ Performance notes:\n - the function runs in linear time.\n  */\n fn of_str(str: @str) -> rope {\n-    ret of_substr(str, 0u, str::len_bytes(*str));\n+    ret of_substr(str, 0u, str::len(*str));\n }\n \n /*\n@@ -93,7 +93,7 @@ Safety notes:\n  */\n fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n-    if byte_offset + byte_len  > str::len_bytes(*str) { fail; }\n+    if byte_offset + byte_len  > str::len(*str) { fail; }\n     ret node::content(node::of_substr(str, byte_offset, byte_len));\n }\n \n@@ -721,7 +721,7 @@ mod node {\n     the length of `str`.\n      */\n     fn of_str(str: @str) -> @node {\n-        ret of_substr(str, 0u, str::len_bytes(*str));\n+        ret of_substr(str, 0u, str::len(*str));\n     }\n \n     /*\n@@ -768,7 +768,7 @@ mod node {\n     */\n     fn of_substr_unsafer(str: @str, byte_start: uint, byte_len: uint,\n                           char_len: uint) -> @node {\n-        assert(byte_start + byte_len <= str::len_bytes(*str));\n+        assert(byte_start + byte_len <= str::len(*str));\n         let candidate = @leaf({\n                 byte_offset: byte_start,\n                 byte_len:    byte_len,\n@@ -1388,7 +1388,7 @@ mod tests {\n         assert rope_to_string(r) == *sample;\n \n         let string_iter = 0u;\n-        let string_len  = str::len_bytes(*sample);\n+        let string_len  = str::len(*sample);\n         let rope_iter   = iterator::char::start(r);\n         let equal       = true;\n         let pos         = 0u;"}, {"sha": "9360a84fb97af76d3c57b1ee2a7d6bf36d986d67", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -368,7 +368,7 @@ mod tests {\n \n         // Test that it works when accepting the message in pieces\n         for t: test in tests {\n-            let len = str::len_bytes(t.input);\n+            let len = str::len(t.input);\n             let left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;"}, {"sha": "b506f502933750ec2e9f41ee4a1bfd23e7bd687e", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -175,7 +175,7 @@ fn parse_desc(desc: str) -> (option<str>, option<str>) {\n \n     if check vec::is_not_empty(paras) {\n         let maybe_brief = vec::head(paras);\n-        if str::len_bytes(maybe_brief) <= max_brief_len {\n+        if str::len(maybe_brief) <= max_brief_len {\n             let desc_paras = vec::tail(paras);\n             let desc = if vec::is_not_empty(desc_paras) {\n                 some(str::connect(desc_paras, \"\\n\\n\"))"}, {"sha": "59005d8266b1e50a5f55413a1d167af9213608a1", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -67,8 +67,8 @@ fn unindent(s: str) -> str {\n             if str::is_whitespace(line) {\n                 line\n             } else {\n-                assert str::len_bytes(line) >= min_indent;\n-                str::slice_chars(line, min_indent, str::len_chars(line))\n+                assert str::len(line) >= min_indent;\n+                str::slice(line, min_indent, str::len(line))\n             }\n         };\n         str::connect(unindented, \"\\n\")"}, {"sha": "6abeb63471fd078e7cf512a16fe4e15a19127d70", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -31,7 +31,7 @@ fn sub(t: str, n: int) -> str unsafe {\n       1 { ns = \"1 bottle\"; }\n       _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n-    while i < str::len_bytes(t) {\n+    while i < str::len(t) {\n         if t[i] == '#' as u8 { b += ns; }\n         else { str::unsafe::push_byte(b, t[i]); }\n         i += 1u;"}, {"sha": "3fcf6abebb193a58b0aaf287ffe3d2dda6ba0773", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -31,7 +31,7 @@ fn sub(t: str, n: int) -> str unsafe {\n       1 { ns = \"1 bottle\"; }\n       _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n-    while i < str::len_bytes(t) {\n+    while i < str::len(t) {\n         if t[i] == '#' as u8 { b += ns; }\n         else { str::unsafe::push_byte(b, t[i]); }\n         i += 1u;"}, {"sha": "28431d3353f7e82e65d7d97e20ca0d6cc6950cc7", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -49,26 +49,26 @@ fn make_random_fasta(id: str, desc: str, genelist: [aminoacids], n: int) {\n     uint::range(0u, n as uint) {|_i|\n         str::push_char(op, select_random(myrandom_next(rng, 100u32),\n                                          genelist));\n-        if str::len_bytes(op) >= LINE_LENGTH() {\n+        if str::len(op) >= LINE_LENGTH() {\n             log(debug, op);\n             op = \"\";\n         }\n     }\n-    if str::len_bytes(op) > 0u { log(debug, op); }\n+    if str::len(op) > 0u { log(debug, op); }\n }\n \n fn make_repeat_fasta(id: str, desc: str, s: str, n: int) unsafe {\n     log(debug, \">\" + id + \" \" + desc);\n     let op: str = \"\";\n-    let sl: uint = str::len_bytes(s);\n+    let sl: uint = str::len(s);\n     uint::range(0u, n as uint) {|i|\n         str::unsafe::push_byte(op, s[i % sl]);\n-        if str::len_bytes(op) >= LINE_LENGTH() {\n+        if str::len(op) >= LINE_LENGTH() {\n             log(debug, op);\n             op = \"\";\n         }\n     }\n-    if str::len_bytes(op) > 0u { log(debug, op); }\n+    if str::len(op) > 0u { log(debug, op); }\n }\n \n fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }"}, {"sha": "0d839d02200a75210cd6a9c7e4bf21b75b43a21d", "filename": "src/test/run-pass/bind-native-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -13,7 +13,7 @@ native mod libc {\n fn main() {\n     let s = \"hello world\\n\";\n     let b = str::bytes(s);\n-    let l = str::len_bytes(s);\n+    let l = str::len(s);\n     let b8 = unsafe { vec::unsafe::to_ptr(b) };\n     libc::write(0i32, b8, l);\n     let a = bind libc::write(0i32, _, _);"}, {"sha": "c09d6c7cb56bccbaded2150e9ece38492335816f", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -7,8 +7,8 @@ fn main() {\n     let i = 20;\n     let expected_len = 1u;\n     while i > 0 {\n-        log(error, str::len_bytes(a));\n-        assert (str::len_bytes(a) == expected_len);\n+        log(error, str::len(a));\n+        assert (str::len(a) == expected_len);\n         a += a;\n         i -= 1;\n         expected_len *= 2u;"}, {"sha": "2d38b9dd24584386ab47461b3cd4ccb962fe39be", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7782f5d6926be7970ec474b74302f2298ceccd13/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=7782f5d6926be7970ec474b74302f2298ceccd13", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let chs: [char] = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n     let s: str = str::from_chars(chs);\n \n-    assert (str::len_bytes(s) == 10u);\n+    assert (str::len(s) == 10u);\n     assert (str::len_chars(s) == 4u);\n     assert (vec::len::<char>(str::chars(s)) == 4u);\n     assert (str::eq(str::from_chars(str::chars(s)), s));"}]}