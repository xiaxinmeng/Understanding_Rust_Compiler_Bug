{"sha": "9bbc470e9779436d787ccda9924826176030b714", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYmM0NzBlOTc3OTQzNmQ3ODdjY2RhOTkyNDgyNjE3NjAzMGI3MTQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-07T03:17:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-07T03:17:32Z"}, "message": "Rollup merge of #80918 - yoshuawuyts:int-log2, r=m-ou-se\n\nAdd Integer::log variants\n\n_This is another attempt at landing https://github.com/rust-lang/rust/pull/70835, which was approved by the libs team but failed on Android tests through Bors. The text copied here is from the original issue. The only change made so far is the addition of non-`checked_` variants of the log methods._\n\n_Tracking issue: #70887_\n\n---\n\nThis implements `{log,log2,log10}` methods for all integer types. The implementation was provided by `@substack` for use in the stdlib.\n\n_Note: I'm not big on math, so this PR is a best effort written with limited knowledge. It's likely I'll be getting things wrong, but happy to learn and correct. Please bare with me._\n\n## Motivation\nCalculating the logarithm of a number is a generally useful operation. Currently the stdlib only provides implementations for floats, which means that if we want to calculate the logarithm for an integer we have to cast it to a float and then back to an int.\n\n> would be nice if there was an integer log2 instead of having to either use the f32 version or leading_zeros() which i have to verify the results of every time to be sure\n\n_\u2014 [`@substack,` 2020-03-08](https://twitter.com/substack/status/1236445105197727744)_\n\nAt higher numbers converting from an integer to a float we also risk overflows. This means that Rust currently only provides log operations for a limited set of integers.\n\nThe process of doing log operations by converting between floats and integers is also prone to rounding errors. In the following example we're trying to calculate `base10` for an integer. We might try and calculate the `base2` for the values, and attempt [a base swap](https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules) to arrive at `base10`. However because we're performing intermediate rounding we arrive at the wrong result:\n\n```rust\n// log10(900) = ~2.95 = 2\ndbg!(900f32.log10() as u64);\n\n// log base change rule: logb(x) = logc(x) / logc(b)\n// log2(900) / log2(10) = 9/3 = 3\ndbg!((900f32.log2() as u64) / (10f32.log2() as u64));\n```\n_[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6bd6c68b3539e400f9ca4fdc6fc2eed0)_\n\nThis is somewhat nuanced as a lot of the time it'll work well, but in real world code this could lead to some hard to track bugs. By providing correct log implementations directly on integers we can help prevent errors around this.\n\n## Implementation notes\n\nI checked whether LLVM intrinsics existed before implementing this, and none exist yet. ~~Also I couldn't really find a better way to write the `ilog` function. One option would be to make it a private method on the number, but I didn't see any precedent for that. I also didn't know where to best place the tests, so I added them to the bottom of the file. Even though they might seem like quite a lot they take no time to execute.~~\n\n## References\n\n- [Log rules](https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules)\n- [Rounding error playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6bd6c68b3539e400f9ca4fdc6fc2eed0)\n- [substack's tweet asking about integer log2 in the stdlib](https://twitter.com/substack/status/1236445105197727744)\n- [Integer Logarithm, A. Jaffer 2008](https://people.csail.mit.edu/jaffer/III/ilog.pdf)", "tree": {"sha": "b5b3799fc45aac2092fb5449f10f38e304b3de5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5b3799fc45aac2092fb5449f10f38e304b3de5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bbc470e9779436d787ccda9924826176030b714", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg5RzNCRBK7hj4Ov3rIwAAp+wIAAynCMaaQbe4tAwTdHGbV2e5\net9yOQxAxL2Jkdo6JhrFCYW9xnuwIF5batbVg8zIK1b4kBUEkD2jRU3Mlh8H/kFB\njiSFzSTv473kTZntRFVuMGaCeC0tT9bFOAil/0Sxjt3ziXcfQ0mBDHx4jf2/Blk/\nC3DcFECSW4ACZTm4Fg99tlHpBMDks1HTelfzLof64sXrOjuBwWN4NQo5C6pfOFtE\nQCgksEih2NCgz3QyqFigsQAtrdnXYkpedNndlRJqRtChUlPEqlj9Yija10wJ4hxm\nF75XUK1zEKvGxwV7NlwuiYqY84CwYROzn89+yrtgzBtdlSVQNdc7VcJNE+f1UjY=\n=IvcM\n-----END PGP SIGNATURE-----\n", "payload": "tree b5b3799fc45aac2092fb5449f10f38e304b3de5a\nparent b20e3ff2af39e1de6280d52aea2e87585e98056d\nparent 9f579968cd4a7544eae0b76859089d78b418f131\nauthor Yuki Okushi <jtitor@2k36.org> 1625627852 +0900\ncommitter GitHub <noreply@github.com> 1625627852 +0900\n\nRollup merge of #80918 - yoshuawuyts:int-log2, r=m-ou-se\n\nAdd Integer::log variants\n\n_This is another attempt at landing https://github.com/rust-lang/rust/pull/70835, which was approved by the libs team but failed on Android tests through Bors. The text copied here is from the original issue. The only change made so far is the addition of non-`checked_` variants of the log methods._\n\n_Tracking issue: #70887_\n\n---\n\nThis implements `{log,log2,log10}` methods for all integer types. The implementation was provided by `@substack` for use in the stdlib.\n\n_Note: I'm not big on math, so this PR is a best effort written with limited knowledge. It's likely I'll be getting things wrong, but happy to learn and correct. Please bare with me._\n\n## Motivation\nCalculating the logarithm of a number is a generally useful operation. Currently the stdlib only provides implementations for floats, which means that if we want to calculate the logarithm for an integer we have to cast it to a float and then back to an int.\n\n> would be nice if there was an integer log2 instead of having to either use the f32 version or leading_zeros() which i have to verify the results of every time to be sure\n\n_\u2014 [`@substack,` 2020-03-08](https://twitter.com/substack/status/1236445105197727744)_\n\nAt higher numbers converting from an integer to a float we also risk overflows. This means that Rust currently only provides log operations for a limited set of integers.\n\nThe process of doing log operations by converting between floats and integers is also prone to rounding errors. In the following example we're trying to calculate `base10` for an integer. We might try and calculate the `base2` for the values, and attempt [a base swap](https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules) to arrive at `base10`. However because we're performing intermediate rounding we arrive at the wrong result:\n\n```rust\n// log10(900) = ~2.95 = 2\ndbg!(900f32.log10() as u64);\n\n// log base change rule: logb(x) = logc(x) / logc(b)\n// log2(900) / log2(10) = 9/3 = 3\ndbg!((900f32.log2() as u64) / (10f32.log2() as u64));\n```\n_[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6bd6c68b3539e400f9ca4fdc6fc2eed0)_\n\nThis is somewhat nuanced as a lot of the time it'll work well, but in real world code this could lead to some hard to track bugs. By providing correct log implementations directly on integers we can help prevent errors around this.\n\n## Implementation notes\n\nI checked whether LLVM intrinsics existed before implementing this, and none exist yet. ~~Also I couldn't really find a better way to write the `ilog` function. One option would be to make it a private method on the number, but I didn't see any precedent for that. I also didn't know where to best place the tests, so I added them to the bottom of the file. Even though they might seem like quite a lot they take no time to execute.~~\n\n## References\n\n- [Log rules](https://www.rapidtables.com/math/algebra/Logarithm.html#log-rules)\n- [Rounding error playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6bd6c68b3539e400f9ca4fdc6fc2eed0)\n- [substack's tweet asking about integer log2 in the stdlib](https://twitter.com/substack/status/1236445105197727744)\n- [Integer Logarithm, A. Jaffer 2008](https://people.csail.mit.edu/jaffer/III/ilog.pdf)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bbc470e9779436d787ccda9924826176030b714", "html_url": "https://github.com/rust-lang/rust/commit/9bbc470e9779436d787ccda9924826176030b714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bbc470e9779436d787ccda9924826176030b714/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b20e3ff2af39e1de6280d52aea2e87585e98056d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b20e3ff2af39e1de6280d52aea2e87585e98056d", "html_url": "https://github.com/rust-lang/rust/commit/b20e3ff2af39e1de6280d52aea2e87585e98056d"}, {"sha": "9f579968cd4a7544eae0b76859089d78b418f131", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f579968cd4a7544eae0b76859089d78b418f131", "html_url": "https://github.com/rust-lang/rust/commit/9f579968cd4a7544eae0b76859089d78b418f131"}], "stats": {"total": 478, "additions": 478, "deletions": 0}, "files": [{"sha": "a9461649d4aa17cf37c3f5182884081968703cd7", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=9bbc470e9779436d787ccda9924826176030b714", "patch": "@@ -1744,6 +1744,194 @@ macro_rules! int_impl {\n             }\n         }\n \n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `log2` can produce results more efficiently for base 2, and `log10`\n+        /// can produce results more efficiently for base 10.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is zero, or if the base is not at least 2; it\n+        /// panics in debug mode and the return value is wrapped to 0 in release\n+        /// mode (the only situation in which the method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".log(5), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log(self, base: Self) -> Self {\n+            match self.checked_log(base) {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is zero it panics in debug mode and the return value\n+        /// is wrapped to 0 in release mode (the only situation in which the\n+        /// method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".log2(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log2(self) -> Self {\n+            match self.checked_log2() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is zero it panics in debug mode and the return value\n+        /// is wrapped to 0 in release mode (the only situation in which the\n+        /// method can return 0).\n+        ///\n+        /// # Example\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".log10(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log10(self) -> Self {\n+            match self.checked_log10() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// Returns `None` if the number is negative or zero, or if the base is not at least 2.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `checked_log2` can produce results more efficiently for base 2, and\n+        /// `checked_log10` can produce results more efficiently for base 10.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_log(5), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log(self, base: Self) -> Option<Self> {\n+            if self <= 0 || base <= 1 {\n+                None\n+            } else {\n+                let mut n = 0;\n+                let mut r = self;\n+\n+                // Optimization for 128 bit wide integers.\n+                if Self::BITS == 128 {\n+                    let b = Self::log2(self) / (Self::log2(base) + 1);\n+                    n += b;\n+                    r /= base.pow(b as u32);\n+                }\n+\n+                while r >= base {\n+                    r /= base;\n+                    n += 1;\n+                }\n+                Some(n)\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is negative or zero.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_log2(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log2(self) -> Option<Self> {\n+            if self <= 0 {\n+                None\n+            } else {\n+                // SAFETY: We just checked that this number is positive\n+                let log = (Self::BITS - 1) as Self - unsafe { intrinsics::ctlz_nonzero(self) };\n+                Some(log)\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is negative or zero.\n+        ///\n+        /// # Example\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_log10(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log10(self) -> Option<Self> {\n+            self.checked_log(10)\n+        }\n+\n         /// Computes the absolute value of `self`.\n         ///\n         /// # Overflow behavior"}, {"sha": "bf4d2e7433e2f9a924b8a2c814b27adf126a8ab4", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=9bbc470e9779436d787ccda9924826176030b714", "patch": "@@ -634,6 +634,194 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `log2` can produce results more efficiently for base 2, and `log10`\n+        /// can produce results more efficiently for base 10.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is negative, zero, or if the base is not at least 2;\n+        /// it panics in debug mode and the return value is wrapped to 0 in\n+        /// release mode (the only situation in which the method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".log(5), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log(self, base: Self) -> Self {\n+            match self.checked_log(base) {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is negative or zero it panics in debug mode and\n+        /// the return value is wrapped to 0 in release mode (the only situation in\n+        /// which the method can return 0).\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".log2(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log2(self) -> Self {\n+            match self.checked_log2() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// # Panics\n+        ///\n+        /// When the number is negative or zero it panics in debug mode and the\n+        /// return value is wrapped to 0 in release mode (the only situation in\n+        /// which the method can return 0).\n+        ///\n+        /// # Example\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".log10(), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        #[track_caller]\n+        #[rustc_inherit_overflow_checks]\n+        #[allow(arithmetic_overflow)]\n+        pub const fn log10(self) -> Self {\n+            match self.checked_log10() {\n+                Some(n) => n,\n+                None => {\n+                    // In debug builds, trigger a panic on None.\n+                    // This should optimize completely out in release builds.\n+                    let _ = Self::MAX + 1;\n+\n+                    0\n+                },\n+            }\n+        }\n+\n+        /// Returns the logarithm of the number with respect to an arbitrary base.\n+        ///\n+        /// Returns `None` if the number is zero, or if the base is not at least 2.\n+        ///\n+        /// This method may not be optimized owing to implementation details;\n+        /// `checked_log2` can produce results more efficiently for base 2, and\n+        /// `checked_log10` can produce results more efficiently for base 10.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_log(5), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log(self, base: Self) -> Option<Self> {\n+            if self <= 0 || base <= 1 {\n+                None\n+            } else {\n+                let mut n = 0;\n+                let mut r = self;\n+\n+                // Optimization for 128 bit wide integers.\n+                if Self::BITS == 128 {\n+                    let b = Self::log2(self) / (Self::log2(base) + 1);\n+                    n += b;\n+                    r /= base.pow(b as u32);\n+                }\n+\n+                while r >= base {\n+                    r /= base;\n+                    n += 1;\n+                }\n+                Some(n)\n+            }\n+        }\n+\n+        /// Returns the base 2 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is zero.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_log2(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log2(self) -> Option<Self> {\n+            if self <= 0 {\n+                None\n+            } else {\n+                // SAFETY: We just checked that this number is positive\n+                let log = (Self::BITS - 1) as Self - unsafe { intrinsics::ctlz_nonzero(self) };\n+                Some(log)\n+            }\n+        }\n+\n+        /// Returns the base 10 logarithm of the number.\n+        ///\n+        /// Returns `None` if the number is zero.\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// #![feature(int_log)]\n+        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_log10(), Some(1));\")]\n+        /// ```\n+        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                        without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_log10(self) -> Option<Self> {\n+            self.checked_log(10)\n+        }\n+\n         /// Checked negation. Computes `-self`, returning `None` unless `self ==\n         /// 0`.\n         ///"}, {"sha": "cc4ff1be563140d2b6d038ead4e0ecd07f2b499b", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=9bbc470e9779436d787ccda9924826176030b714", "patch": "@@ -44,6 +44,7 @@\n #![feature(try_trait_v2)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n+#![feature(int_log)]\n #![feature(iter_advance_by)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_intersperse)]"}, {"sha": "99a9b17ab118369e7dcf64c495a9c0110ec784a8", "filename": "library/core/tests/num/int_log.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_log.rs?ref=9bbc470e9779436d787ccda9924826176030b714", "patch": "@@ -0,0 +1,99 @@\n+//! This tests the `Integer::{log,log2,log10}` methods. These tests are in a\n+//! separate file because there's both a large number of them, and not all tests\n+//! can be run on Android. This is because in Android `log2` uses an imprecise\n+//! approximation:https://github.com/rust-lang/rust/blob/4825e12fc9c79954aa0fe18f5521efa6c19c7539/src/libstd/sys/unix/android.rs#L27-L53\n+\n+#[test]\n+fn checked_log() {\n+    assert_eq!(999u32.checked_log(10), Some(2));\n+    assert_eq!(1000u32.checked_log(10), Some(3));\n+    assert_eq!(555u32.checked_log(13), Some(2));\n+    assert_eq!(63u32.checked_log(4), Some(2));\n+    assert_eq!(64u32.checked_log(4), Some(3));\n+    assert_eq!(10460353203u64.checked_log(3), Some(21));\n+    assert_eq!(10460353202u64.checked_log(3), Some(20));\n+    assert_eq!(147808829414345923316083210206383297601u128.checked_log(3), Some(80));\n+    assert_eq!(147808829414345923316083210206383297600u128.checked_log(3), Some(79));\n+    assert_eq!(22528399544939174411840147874772641u128.checked_log(19683), Some(8));\n+    assert_eq!(22528399544939174411840147874772631i128.checked_log(19683), Some(7));\n+\n+    assert_eq!(0u8.checked_log(4), None);\n+    assert_eq!(0u16.checked_log(4), None);\n+    assert_eq!(0i8.checked_log(4), None);\n+    assert_eq!(0i16.checked_log(4), None);\n+\n+    for i in i16::MIN..=0 {\n+        assert_eq!(i.checked_log(4), None);\n+    }\n+    for i in 1..=i16::MAX {\n+        assert_eq!(i.checked_log(13), Some((i as f32).log(13.0) as i16));\n+    }\n+    for i in 1..=u16::MAX {\n+        assert_eq!(i.checked_log(13), Some((i as f32).log(13.0) as u16));\n+    }\n+}\n+\n+#[test]\n+fn checked_log2() {\n+    assert_eq!(5u32.checked_log2(), Some(2));\n+    assert_eq!(0u64.checked_log2(), None);\n+    assert_eq!(128i32.checked_log2(), Some(7));\n+    assert_eq!((-55i16).checked_log2(), None);\n+\n+    assert_eq!(0u8.checked_log2(), None);\n+    assert_eq!(0u16.checked_log2(), None);\n+    assert_eq!(0i8.checked_log2(), None);\n+    assert_eq!(0i16.checked_log2(), None);\n+\n+    for i in 1..=u8::MAX {\n+        assert_eq!(i.checked_log2(), Some((i as f32).log2() as u8));\n+    }\n+    for i in 1..=u16::MAX {\n+        // Guard against Android's imprecise f32::log2 implementation.\n+        if i != 8192 && i != 32768 {\n+            assert_eq!(i.checked_log2(), Some((i as f32).log2() as u16));\n+        }\n+    }\n+    for i in i8::MIN..=0 {\n+        assert_eq!(i.checked_log2(), None);\n+    }\n+    for i in 1..=i8::MAX {\n+        assert_eq!(i.checked_log2(), Some((i as f32).log2() as i8));\n+    }\n+    for i in i16::MIN..=0 {\n+        assert_eq!(i.checked_log2(), None);\n+    }\n+    for i in 1..=i16::MAX {\n+        // Guard against Android's imprecise f32::log2 implementation.\n+        if i != 8192 {\n+            assert_eq!(i.checked_log2(), Some((i as f32).log2() as i16));\n+        }\n+    }\n+}\n+\n+// Validate cases that fail on Android's imprecise float log2 implementation.\n+#[test]\n+#[cfg(not(target_os = \"android\"))]\n+fn checked_log2_not_android() {\n+    assert_eq!(8192u16.checked_log2(), Some((8192f32).log2() as u16));\n+    assert_eq!(32768u16.checked_log2(), Some((32768f32).log2() as u16));\n+    assert_eq!(8192i16.checked_log2(), Some((8192f32).log2() as i16));\n+}\n+\n+#[test]\n+fn checked_log10() {\n+    assert_eq!(0u8.checked_log10(), None);\n+    assert_eq!(0u16.checked_log10(), None);\n+    assert_eq!(0i8.checked_log10(), None);\n+    assert_eq!(0i16.checked_log10(), None);\n+\n+    for i in i16::MIN..=0 {\n+        assert_eq!(i.checked_log10(), None);\n+    }\n+    for i in 1..=i16::MAX {\n+        assert_eq!(i.checked_log10(), Some((i as f32).log10() as i16));\n+    }\n+    for i in 1..=u16::MAX {\n+        assert_eq!(i.checked_log10(), Some((i as f32).log10() as u16));\n+    }\n+}"}, {"sha": "76e838cf6bfbd2b75983a0257a82759db353cd99", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbc470e9779436d787ccda9924826176030b714/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=9bbc470e9779436d787ccda9924826176030b714", "patch": "@@ -29,6 +29,7 @@ mod u8;\n mod bignum;\n mod dec2flt;\n mod flt2dec;\n+mod int_log;\n mod ops;\n mod wrapping;\n "}, {"sha": "8c120f4af288d0d0fb542515d210ffc0673964df", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9bbc470e9779436d787ccda9924826176030b714/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bbc470e9779436d787ccda9924826176030b714/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9bbc470e9779436d787ccda9924826176030b714", "patch": "@@ -278,6 +278,7 @@\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(integer_atomics)]\n+#![feature(int_log)]\n #![feature(into_future)]\n #![feature(intra_doc_pointers)]\n #![feature(iter_zip)]"}]}