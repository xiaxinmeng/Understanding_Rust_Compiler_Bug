{"sha": "9d739ca12d88c3985cd78d4af027d48ce2254e18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNzM5Y2ExMmQ4OGMzOTg1Y2Q3OGQ0YWYwMjdkNDhjZTIyNTRlMTg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T12:16:57Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T18:24:42Z"}, "message": "lowering: extract lower_expr_for", "tree": {"sha": "0492ba033137e27699b8adc7e28763a1785c6856", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0492ba033137e27699b8adc7e28763a1785c6856"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d739ca12d88c3985cd78d4af027d48ce2254e18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d739ca12d88c3985cd78d4af027d48ce2254e18", "html_url": "https://github.com/rust-lang/rust/commit/9d739ca12d88c3985cd78d4af027d48ce2254e18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d739ca12d88c3985cd78d4af027d48ce2254e18/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c817596c694579667d3e2ee207064ae273e84940", "url": "https://api.github.com/repos/rust-lang/rust/commits/c817596c694579667d3e2ee207064ae273e84940", "html_url": "https://github.com/rust-lang/rust/commit/c817596c694579667d3e2ee207064ae273e84940"}], "stats": {"total": 316, "additions": 163, "deletions": 153}, "files": [{"sha": "0c626d6b15f819c0f6692440b3061fec197d5f07", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 163, "deletions": 153, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/9d739ca12d88c3985cd78d4af027d48ce2254e18/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d739ca12d88c3985cd78d4af027d48ce2254e18/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=9d739ca12d88c3985cd78d4af027d48ce2254e18", "patch": "@@ -533,174 +533,184 @@ impl LoweringContext<'_> {\n             // Desugar `ExprForLoop`\n             // from: `[opt_ident]: for <pat> in <head> <body>`\n             ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n-                // to:\n-                //\n-                //   {\n-                //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n-                //       mut iter => {\n-                //         [opt_ident]: loop {\n-                //           let mut __next;\n-                //           match ::std::iter::Iterator::next(&mut iter) {\n-                //             ::std::option::Option::Some(val) => __next = val,\n-                //             ::std::option::Option::None => break\n-                //           };\n-                //           let <pat> = __next;\n-                //           StmtKind::Expr(<body>);\n-                //         }\n-                //       }\n-                //     };\n-                //     result\n-                //   }\n-\n-                // expand <head>\n-                let mut head = self.lower_expr(head);\n-                let head_sp = head.span;\n-                let desugared_span = self.mark_span_with_reason(\n-                    DesugaringKind::ForLoop,\n-                    head_sp,\n-                    None,\n-                );\n-                head.span = desugared_span;\n-\n-                let iter = Ident::with_empty_ctxt(sym::iter);\n-\n-                let next_ident = Ident::with_empty_ctxt(sym::__next);\n-                let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n-                    desugared_span,\n-                    next_ident,\n-                    hir::BindingAnnotation::Mutable,\n-                );\n-\n-                // `::std::option::Option::Some(val) => __next = val`\n-                let pat_arm = {\n-                    let val_ident = Ident::with_empty_ctxt(sym::val);\n-                    let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n-                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n-                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n-                    let assign = P(self.expr(\n-                        pat.span,\n-                        hir::ExprKind::Assign(next_expr, val_expr),\n-                        ThinVec::new(),\n-                    ));\n-                    let some_pat = self.pat_some(pat.span, val_pat);\n-                    self.arm(hir_vec![some_pat], assign)\n-                };\n+                return self.lower_expr_for(e, pat, head, body, opt_label);\n+            }\n+            ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n+            ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n \n-                // `::std::option::Option::None => break`\n-                let break_arm = {\n-                    let break_expr =\n-                        self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n-                    let pat = self.pat_none(e.span);\n-                    self.arm(hir_vec![pat], break_expr)\n-                };\n+        hir::Expr {\n+            hir_id: self.lower_node_id(e.id),\n+            node: kind,\n+            span: e.span,\n+            attrs: e.attrs.clone(),\n+        }\n+    }\n \n-                // `mut iter`\n-                let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n-                    desugared_span,\n-                    iter,\n-                    hir::BindingAnnotation::Mutable\n-                );\n+    /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n+    /// ```rust\n+    /// {\n+    ///     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+    ///         mut iter => {\n+    ///             [opt_ident]: loop {\n+    ///                 let mut __next;\n+    ///                 match ::std::iter::Iterator::next(&mut iter) {\n+    ///                     ::std::option::Option::Some(val) => __next = val,\n+    ///                     ::std::option::Option::None => break\n+    ///                 };\n+    ///                 let <pat> = __next;\n+    ///                 StmtKind::Expr(<body>);\n+    ///             }\n+    ///         }\n+    ///     };\n+    ///     result\n+    /// }\n+    /// ```\n+    fn lower_expr_for(\n+        &mut self,\n+        e: &Expr,\n+        pat: &Pat,\n+        head: &Expr,\n+        body: &Block,\n+        opt_label: Option<Label>,\n+    ) -> hir::Expr {\n+        // expand <head>\n+        let mut head = self.lower_expr(head);\n+        let head_sp = head.span;\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop,\n+            head_sp,\n+            None,\n+        );\n+        head.span = desugared_span;\n \n-                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-                let match_expr = {\n-                    let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n-                    let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n-                    let next_path = &[sym::iter, sym::Iterator, sym::next];\n-                    let next_expr = P(self.expr_call_std_path(\n-                        head_sp,\n-                        next_path,\n-                        hir_vec![ref_mut_iter],\n-                    ));\n-                    let arms = hir_vec![pat_arm, break_arm];\n-\n-                    self.expr_match(head_sp, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n-                };\n-                let match_stmt = self.stmt_expr(head_sp, match_expr);\n+        let iter = Ident::with_empty_ctxt(sym::iter);\n \n-                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n+        let next_ident = Ident::with_empty_ctxt(sym::__next);\n+        let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n+            desugared_span,\n+            next_ident,\n+            hir::BindingAnnotation::Mutable,\n+        );\n \n-                // `let mut __next`\n-                let next_let = self.stmt_let_pat(\n-                    ThinVec::new(),\n-                    desugared_span,\n-                    None,\n-                    next_pat,\n-                    hir::LocalSource::ForLoopDesugar,\n-                );\n+        // `::std::option::Option::Some(val) => __next = val`\n+        let pat_arm = {\n+            let val_ident = Ident::with_empty_ctxt(sym::val);\n+            let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n+            let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n+            let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n+            let assign = P(self.expr(\n+                pat.span,\n+                hir::ExprKind::Assign(next_expr, val_expr),\n+                ThinVec::new(),\n+            ));\n+            let some_pat = self.pat_some(pat.span, val_pat);\n+            self.arm(hir_vec![some_pat], assign)\n+        };\n \n-                // `let <pat> = __next`\n-                let pat = self.lower_pat(pat);\n-                let pat_let = self.stmt_let_pat(\n-                    ThinVec::new(),\n-                    head_sp,\n-                    Some(next_expr),\n-                    pat,\n-                    hir::LocalSource::ForLoopDesugar,\n-                );\n+        // `::std::option::Option::None => break`\n+        let break_arm = {\n+            let break_expr =\n+                self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n+            let pat = self.pat_none(e.span);\n+            self.arm(hir_vec![pat], break_expr)\n+        };\n \n-                let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-                let body_expr = self.expr_block(body_block, ThinVec::new());\n-                let body_stmt = self.stmt_expr(body.span, body_expr);\n+        // `mut iter`\n+        let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n+            desugared_span,\n+            iter,\n+            hir::BindingAnnotation::Mutable\n+        );\n \n-                let loop_block = P(self.block_all(\n-                    e.span,\n-                    hir_vec![next_let, match_stmt, pat_let, body_stmt],\n-                    None,\n-                ));\n+        // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+        let match_expr = {\n+            let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n+            let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n+            let next_path = &[sym::iter, sym::Iterator, sym::next];\n+            let next_expr = P(self.expr_call_std_path(\n+                head_sp,\n+                next_path,\n+                hir_vec![ref_mut_iter],\n+            ));\n+            let arms = hir_vec![pat_arm, break_arm];\n \n-                // `[opt_ident]: loop { ... }`\n-                let loop_expr = hir::ExprKind::Loop(\n-                    loop_block,\n-                    self.lower_label(opt_label),\n-                    hir::LoopSource::ForLoop,\n-                );\n-                let loop_expr = P(hir::Expr {\n-                    hir_id: self.lower_node_id(e.id),\n-                    node: loop_expr,\n-                    span: e.span,\n-                    attrs: ThinVec::new(),\n-                });\n-\n-                // `mut iter => { ... }`\n-                let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n-\n-                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-                let into_iter_expr = {\n-                    let into_iter_path =\n-                        &[sym::iter, sym::IntoIterator, sym::into_iter];\n-                    P(self.expr_call_std_path(\n-                        head_sp,\n-                        into_iter_path,\n-                        hir_vec![head],\n-                    ))\n-                };\n+            self.expr_match(head_sp, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n+        };\n+        let match_stmt = self.stmt_expr(head_sp, match_expr);\n \n-                let match_expr = P(self.expr_match(\n-                    head_sp,\n-                    into_iter_expr,\n-                    hir_vec![iter_arm],\n-                    hir::MatchSource::ForLoopDesugar,\n-                ));\n+        let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n \n-                // This is effectively `{ let _result = ...; _result }`.\n-                // The construct was introduced in #21984 and is necessary to make sure that\n-                // temporaries in the `head` expression are dropped and do not leak to the\n-                // surrounding scope of the `match` since the `match` is not a terminating scope.\n-                //\n-                // Also, add the attributes to the outer returned expr node.\n-                return self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n-            }\n+        // `let mut __next`\n+        let next_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            desugared_span,\n+            None,\n+            next_pat,\n+            hir::LocalSource::ForLoopDesugar,\n+        );\n \n-            ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-            ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-        };\n+        // `let <pat> = __next`\n+        let pat = self.lower_pat(pat);\n+        let pat_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            head_sp,\n+            Some(next_expr),\n+            pat,\n+            hir::LocalSource::ForLoopDesugar,\n+        );\n \n-        hir::Expr {\n+        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n+        let body_expr = self.expr_block(body_block, ThinVec::new());\n+        let body_stmt = self.stmt_expr(body.span, body_expr);\n+\n+        let loop_block = P(self.block_all(\n+            e.span,\n+            hir_vec![next_let, match_stmt, pat_let, body_stmt],\n+            None,\n+        ));\n+\n+        // `[opt_ident]: loop { ... }`\n+        let loop_expr = hir::ExprKind::Loop(\n+            loop_block,\n+            self.lower_label(opt_label),\n+            hir::LoopSource::ForLoop,\n+        );\n+        let loop_expr = P(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n-            node: kind,\n+            node: loop_expr,\n             span: e.span,\n-            attrs: e.attrs.clone(),\n-        }\n+            attrs: ThinVec::new(),\n+        });\n+\n+        // `mut iter => { ... }`\n+        let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n+\n+        // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+        let into_iter_expr = {\n+            let into_iter_path =\n+                &[sym::iter, sym::IntoIterator, sym::into_iter];\n+            P(self.expr_call_std_path(\n+                head_sp,\n+                into_iter_path,\n+                hir_vec![head],\n+            ))\n+        };\n+\n+        let match_expr = P(self.expr_match(\n+            head_sp,\n+            into_iter_expr,\n+            hir_vec![iter_arm],\n+            hir::MatchSource::ForLoopDesugar,\n+        ));\n+\n+        // This is effectively `{ let _result = ...; _result }`.\n+        // The construct was introduced in #21984 and is necessary to make sure that\n+        // temporaries in the `head` expression are dropped and do not leak to the\n+        // surrounding scope of the `match` since the `match` is not a terminating scope.\n+        //\n+        // Also, add the attributes to the outer returned expr node.\n+        self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:"}]}