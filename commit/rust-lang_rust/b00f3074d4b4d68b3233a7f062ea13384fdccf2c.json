{"sha": "b00f3074d4b4d68b3233a7f062ea13384fdccf2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMGYzMDc0ZDRiNGQ2OGIzMjMzYTdmMDYyZWExMzM4NGZkY2NmMmM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-09T21:17:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-09T21:17:45Z"}, "message": "Remove boxes from token.t.", "tree": {"sha": "efefd439bdbf379f3854b851485b0eed98656a27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efefd439bdbf379f3854b851485b0eed98656a27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b00f3074d4b4d68b3233a7f062ea13384fdccf2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b00f3074d4b4d68b3233a7f062ea13384fdccf2c", "html_url": "https://github.com/rust-lang/rust/commit/b00f3074d4b4d68b3233a7f062ea13384fdccf2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b00f3074d4b4d68b3233a7f062ea13384fdccf2c/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70c759030ccf27222a04f918e235bc9dbcf88c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/70c759030ccf27222a04f918e235bc9dbcf88c94", "html_url": "https://github.com/rust-lang/rust/commit/70c759030ccf27222a04f918e235bc9dbcf88c94"}], "stats": {"total": 121, "additions": 79, "deletions": 42}, "files": [{"sha": "2e5304e72a2a8edcb9787c8701e1dad200065549", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b00f3074d4b4d68b3233a7f062ea13384fdccf2c/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00f3074d4b4d68b3233a7f062ea13384fdccf2c/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=b00f3074d4b4d68b3233a7f062ea13384fdccf2c", "patch": "@@ -18,6 +18,8 @@ state type reader = state obj {\n     fn bump();\n     fn mark();\n     fn get_mark_chpos() -> uint;\n+    fn add_str(str) -> token.str_num;\n+    fn get_str(token.str_num) -> str;\n     fn get_chpos() -> uint;\n     fn get_keywords() -> hashmap[str,token.token];\n     fn get_reserved() -> hashmap[str,()];\n@@ -32,6 +34,7 @@ fn new_reader(IO.reader rdr, str filename, codemap.filemap filemap)\n                      mutable char ch,\n                      mutable uint mark_chpos,\n                      mutable uint chpos,\n+                     mutable vec[str] strs,\n                      hashmap[str,token.token] keywords,\n                      hashmap[str,()] reserved,\n                      codemap.filemap fm) {\n@@ -79,6 +82,15 @@ fn new_reader(IO.reader rdr, str filename, codemap.filemap filemap)\n             ret keywords;\n         }\n \n+        fn add_str(str s) -> token.str_num {\n+            strs += vec(s);\n+            ret Vec.len[str](strs) - 1u;\n+        }\n+\n+        fn get_str(token.str_num i) -> str {\n+            ret strs.(i);\n+        }\n+\n         fn get_reserved() -> hashmap[str,()] {\n             ret reserved;\n         }\n@@ -88,9 +100,10 @@ fn new_reader(IO.reader rdr, str filename, codemap.filemap filemap)\n         }\n     }\n     auto file = Str.unsafe_from_bytes(rdr.read_whole_stream());\n+    let vec[str] strs = vec();\n     auto rd = reader(file, Str.byte_len(file), 0u, -1 as char,\n                      filemap.start_pos, filemap.start_pos,\n-                     keyword_table(),\n+                     strs, keyword_table(),\n                      reserved_word_table(),\n                      filemap);\n     rd.init();\n@@ -500,25 +513,25 @@ fn scan_number(char c, reader rdr) -> token.token {\n             if (c == '3' && n == '2') {\n                 rdr.bump(); rdr.bump();\n                 ret token.LIT_MACH_FLOAT(util.common.ty_f32,\n-                                         float_str);\n+                                         rdr.add_str(float_str));\n             }\n             else if (c == '6' && n == '4') {\n                 rdr.bump(); rdr.bump();\n                 ret token.LIT_MACH_FLOAT(util.common.ty_f64,\n-                                         float_str);\n+                                         rdr.add_str(float_str));\n                 /* FIXME: if this is out of range for either a 32-bit or\n                    64-bit float, it won't be noticed till the back-end */\n             }\n         }\n         else {\n-            ret token.LIT_FLOAT(float_str);\n+            ret token.LIT_FLOAT(rdr.add_str(float_str));\n         }\n     }\n \n     auto maybe_exponent = scan_exponent(rdr);\n     alt(maybe_exponent) {\n         case(some[str](?s)) {\n-            ret token.LIT_FLOAT(dec_str + s);\n+            ret token.LIT_FLOAT(rdr.add_str(dec_str + s));\n         }\n         case(none[str]) {\n                 ret token.LIT_INT(accum_int);\n@@ -594,7 +607,7 @@ fn next_token(reader rdr) -> token.token {\n             fail;\n         }\n \n-        ret token.IDENT(accum_str);\n+        ret token.IDENT(rdr.add_str(accum_str));\n     }\n \n     if (is_dec_digit(c)) {\n@@ -786,7 +799,7 @@ fn next_token(reader rdr) -> token.token {\n                 rdr.bump();\n             }\n             rdr.bump();\n-            ret token.LIT_STR(accum_str);\n+            ret token.LIT_STR(rdr.add_str(accum_str));\n         }\n \n         case ('-') {"}, {"sha": "570b09896ff7c1efe432ef56feff1267eaa78e4f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b00f3074d4b4d68b3233a7f062ea13384fdccf2c/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00f3074d4b4d68b3233a7f062ea13384fdccf2c/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b00f3074d4b4d68b3233a7f062ea13384fdccf2c", "patch": "@@ -38,6 +38,8 @@ state type parser =\n           fn next_def_id() -> ast.def_id;\n           fn set_def(ast.def_num);\n           fn get_prec_table() -> vec[op_spec];\n+          fn get_str(token.str_num) -> str;\n+          fn get_reader() -> lexer.reader;\n           fn get_filemap() -> codemap.filemap;\n           fn get_chpos() -> uint;\n     };\n@@ -111,6 +113,14 @@ fn new_parser(session.session sess,\n                 ret precs;\n             }\n \n+            fn get_str(token.str_num i) -> str {\n+                ret rdr.get_str(i);\n+            }\n+\n+            fn get_reader() -> lexer.reader {\n+                ret rdr;\n+            }\n+\n             fn get_filemap() -> codemap.filemap {\n                 ret rdr.get_filemap();\n             }\n@@ -135,7 +145,7 @@ fn new_parser(session.session sess,\n \n fn unexpected(parser p, token.token t) {\n     let str s = \"unexpected token: \";\n-    s += token.to_str(t);\n+    s += token.to_str(p.get_reader(), t);\n     p.err(s);\n }\n \n@@ -144,9 +154,9 @@ fn expect(parser p, token.token t) {\n         p.bump();\n     } else {\n         let str s = \"expecting \";\n-        s += token.to_str(t);\n+        s += token.to_str(p.get_reader(), t);\n         s += \", found \";\n-        s += token.to_str(p.peek());\n+        s += token.to_str(p.get_reader(), p.peek());\n         p.err(s);\n     }\n }\n@@ -157,7 +167,7 @@ fn spanned[T](uint lo, uint hi, &T node) -> ast.spanned[T] {\n \n fn parse_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n-        case (token.IDENT(?i)) { p.bump(); ret i; }\n+        case (token.IDENT(?i)) { p.bump(); ret p.get_str(i); }\n         case (_) {\n             p.err(\"expecting ident\");\n             fail;\n@@ -173,10 +183,10 @@ fn parse_ident(parser p) -> ast.ident {\n  */\n fn parse_str_lit_or_env_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n-        case (token.LIT_STR(?s)) { p.bump(); ret s; }\n+        case (token.LIT_STR(?s)) { p.bump(); ret p.get_str(s); }\n         case (token.IDENT(?i)) {\n             auto v = eval.lookup(p.get_session(), p.get_env(),\n-                                 p.get_span(), i);\n+                                 p.get_span(), p.get_str(i));\n             if (!eval.val_is_str(v)) {\n                 p.err(\"expecting string-valued variable\");\n             }\n@@ -549,15 +559,15 @@ fn parse_lit(parser p) -> ast.lit {\n         }\n         case (token.LIT_FLOAT(?s)) {\n             p.bump();\n-            lit = ast.lit_float(s);\n+            lit = ast.lit_float(p.get_str(s));\n         }\n         case (token.LIT_MACH_INT(?tm, ?i)) {\n             p.bump();\n             lit = ast.lit_mach_int(tm, i);\n         }\n         case (token.LIT_MACH_FLOAT(?tm, ?s)) {\n             p.bump();\n-            lit = ast.lit_mach_float(tm, s);\n+            lit = ast.lit_mach_float(tm, p.get_str(s));\n         }\n         case (token.LIT_CHAR(?c)) {\n             p.bump();\n@@ -569,7 +579,7 @@ fn parse_lit(parser p) -> ast.lit {\n         }\n         case (token.LIT_STR(?s)) {\n             p.bump();\n-            lit = ast.lit_str(s);\n+            lit = ast.lit_str(p.get_str(s));\n         }\n         case (?t) {\n             unexpected(p, t);\n@@ -617,7 +627,7 @@ fn parse_path(parser p, greed g) -> ast.path {\n         alt (p.peek()) {\n             case (token.IDENT(?i)) {\n                 hi = p.get_hi_pos();\n-                ids += vec(i);\n+                ids += vec(p.get_str(i));\n                 p.bump();\n                 if (p.peek() == token.DOT) {\n                     if (g == GREEDY) {\n@@ -1025,7 +1035,7 @@ fn parse_dot_or_call_expr(parser p) -> @ast.expr {\n                     case (token.IDENT(?i)) {\n                         hi = p.get_hi_pos();\n                         p.bump();\n-                        e = extend_expr_by_ident(p, lo, hi, e, i);\n+                        e = extend_expr_by_ident(p, lo, hi, e, p.get_str(i));\n                     }\n \n                     case (token.LPAREN) {\n@@ -1373,7 +1383,7 @@ fn parse_alt_expr(parser p) -> @ast.expr {\n             case (token.RBRACE) { /* empty */ }\n             case (?tok) {\n                 p.err(\"expected 'case' or '}' when parsing 'alt' statement \" +\n-                      \"but found \" + token.to_str(tok));\n+                      \"but found \" + token.to_str(p.get_reader(), tok));\n             }\n         }\n     }\n@@ -1483,16 +1493,17 @@ fn parse_pat(parser p) -> @ast.pat {\n                 case (token.IDENT(?id)) {\n                     hi = p.get_hi_pos();\n                     p.bump();\n-                    pat = ast.pat_bind(id, p.next_def_id(), ast.ann_none);\n+                    pat = ast.pat_bind(p.get_str(id), p.next_def_id(),\n+                                       ast.ann_none);\n                 }\n                 case (?tok) {\n                     p.err(\"expected identifier after '?' in pattern but \" +\n-                          \"found \" + token.to_str(tok));\n+                          \"found \" + token.to_str(p.get_reader(), tok));\n                     fail;\n                 }\n             }\n         }\n-        case (token.IDENT(?id)) {\n+        case (token.IDENT(_)) {\n             auto tag_path = parse_path(p, GREEDY);\n             hi = tag_path.span.hi;\n \n@@ -1723,7 +1734,7 @@ fn parse_block(parser p) -> ast.block {\n                                 if (stmt_ends_with_semi(stmt)) {\n                                     p.err(\"expected ';' or '}' after \" +\n                                           \"expression but found \" +\n-                                          token.to_str(t));\n+                                          token.to_str(p.get_reader(), t));\n                                     fail;\n                                 }\n                                 stmts += vec(stmt);\n@@ -2102,13 +2113,14 @@ fn parse_item_tag(parser p) -> @ast.item {\n                 expect(p, token.SEMI);\n \n                 auto id = p.next_def_id();\n-                auto vr = rec(name=name, args=args, id=id, ann=ast.ann_none);\n+                auto vr = rec(name=p.get_str(name), args=args,\n+                              id=id, ann=ast.ann_none);\n                 variants += vec(spanned[ast.variant_](vlo, vhi, vr));\n             }\n             case (token.RBRACE) { /* empty */ }\n             case (_) {\n                 p.err(\"expected name of variant or '}' but found \" +\n-                      token.to_str(tok));\n+                      token.to_str(p.get_reader(), tok));\n             }\n         }\n     }\n@@ -2210,7 +2222,8 @@ fn parse_item(parser p) -> @ast.item {\n             ret parse_item_obj(p, lyr);\n         }\n         case (?t) {\n-            p.err(\"expected item but found \" + token.to_str(t));\n+            p.err(\"expected item but found \" +\n+                  token.to_str(p.get_reader(), t));\n         }\n     }\n     fail;\n@@ -2224,7 +2237,8 @@ fn parse_meta_item(parser p) -> @ast.meta_item {\n         case (token.LIT_STR(?s)) {\n             auto hi = p.get_hi_pos();\n             p.bump();\n-            ret @spanned(lo, hi, rec(name = ident, value = s));\n+            ret @spanned(lo, hi, rec(name = ident,\n+                                     value = p.get_str(s)));\n         }\n         case (_) {\n             p.err(\"Metadata items must be string literals\");\n@@ -2294,9 +2308,9 @@ fn parse_rest_import_name(parser p, ast.ident first,\n fn parse_full_import_name(parser p, ast.ident def_ident)\n        -> @ast.view_item {\n     alt (p.peek()) {\n-        case (token.IDENT(?ident)) {\n+        case (token.IDENT(?i)) {\n             p.bump();\n-            ret parse_rest_import_name(p, ident, some(def_ident));\n+            ret parse_rest_import_name(p, p.get_str(i), some(def_ident));\n         }\n         case (_) {\n             p.err(\"expecting an identifier\");\n@@ -2308,15 +2322,16 @@ fn parse_full_import_name(parser p, ast.ident def_ident)\n fn parse_import(parser p) -> @ast.view_item {\n     expect(p, token.IMPORT);\n     alt (p.peek()) {\n-        case (token.IDENT(?ident)) {\n+        case (token.IDENT(?i)) {\n             p.bump();\n             alt (p.peek()) {\n                 case (token.EQ) {\n                     p.bump();\n-                    ret parse_full_import_name(p, ident);\n+                    ret parse_full_import_name(p, p.get_str(i));\n                 }\n                 case (_) {\n-                    ret parse_rest_import_name(p, ident, none[ast.ident]);\n+                    ret parse_rest_import_name(p, p.get_str(i),\n+                                               none[ast.ident]);\n                 }\n             }\n         }"}, {"sha": "4c2891f3263b092e800de9798dea12fbb088d4ed", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b00f3074d4b4d68b3233a7f062ea13384fdccf2c/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b00f3074d4b4d68b3233a7f062ea13384fdccf2c/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=b00f3074d4b4d68b3233a7f062ea13384fdccf2c", "patch": "@@ -5,6 +5,8 @@ import std.Int;\n import std.UInt;\n import std.Str;\n \n+type str_num = uint;\n+\n tag binop {\n     PLUS;\n     MINUS;\n@@ -127,14 +129,14 @@ tag token {\n     LIT_INT(int);\n     LIT_UINT(uint);\n     LIT_MACH_INT(ty_mach, int);\n-    LIT_FLOAT(str);\n-    LIT_MACH_FLOAT(ty_mach, str);\n-    LIT_STR(str);\n+    LIT_FLOAT(str_num);\n+    LIT_MACH_FLOAT(ty_mach, str_num);\n+    LIT_STR(str_num);\n     LIT_CHAR(char);\n     LIT_BOOL(bool);\n \n     /* Name components */\n-    IDENT(str);\n+    IDENT(str_num);\n     IDX(int);\n     UNDERSCORE;\n \n@@ -168,7 +170,7 @@ tag token {\n     PORT;\n     TASK;\n \n-    BRACEQUOTE(str);\n+    BRACEQUOTE(str_num);\n     EOF;\n }\n \n@@ -188,7 +190,7 @@ fn binop_to_str(binop o) -> str {\n     }\n }\n \n-fn to_str(token t) -> str {\n+fn to_str(lexer.reader r, token t) -> str {\n     alt (t) {\n \n         case (EQ) { ret \"=\"; }\n@@ -301,10 +303,14 @@ fn to_str(token t) -> str {\n             ret  Int.to_str(i, 10u)\n                 + \"_\" + ty_mach_to_str(tm);\n         }\n-        case (LIT_FLOAT(?s)) { ret s; }\n+        case (LIT_MACH_FLOAT(?tm, ?s)) {\n+            ret r.get_str(s) + \"_\" + ty_mach_to_str(tm);\n+        }\n+\n+        case (LIT_FLOAT(?s)) { ret r.get_str(s); }\n         case (LIT_STR(?s)) {\n             // FIXME: escape.\n-            ret \"\\\"\" + s + \"\\\"\";\n+            ret \"\\\"\" + r.get_str(s) + \"\\\"\";\n         }\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape.\n@@ -319,7 +325,11 @@ fn to_str(token t) -> str {\n         }\n \n         /* Name components */\n-        case (IDENT(?s)) { auto si = \"ident:\"; si += s; ret si; }\n+        case (IDENT(?s)) {\n+            auto si = \"ident:\";\n+            si += r.get_str(s);\n+            ret si;\n+        }\n         case (IDX(?i)) { ret \"_\" + Int.to_str(i, 10u); }\n         case (UNDERSCORE) { ret \"_\"; }\n \n@@ -360,7 +370,6 @@ fn to_str(token t) -> str {\n }\n \n \n-\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}]}