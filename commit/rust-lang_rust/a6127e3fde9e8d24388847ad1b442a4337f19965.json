{"sha": "a6127e3fde9e8d24388847ad1b442a4337f19965", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTI3ZTNmZGU5ZThkMjQzODg4NDdhZDFiNDQyYTQzMzdmMTk5NjU=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-05-22T01:10:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-22T01:10:21Z"}, "message": "Merge pull request #1 from rust-lang/master\n\nupdate from upstream", "tree": {"sha": "120fa2fbc4061f1a5b4fe22c8169b7a9882f6909", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/120fa2fbc4061f1a5b4fe22c8169b7a9882f6909"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6127e3fde9e8d24388847ad1b442a4337f19965", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJexyZ9CRBK7hj4Ov3rIwAAdHIIAAK5lL0gyu+0ff2yiQvTLRjj\nXAy2Xqdy/85a67AwKOVJ/67AFNU2ENDxG6V5UaEDUQq14uzX+BbJYXY48AZVTMJW\ntzApjDpKlgmT/oFW4sHC6AKIzNUD291pZvTFmZHs0eCqTU6jS+ViJ7SpwGoibnf9\ndJ3L6Pa5tHc3DHfmSiNwpOCaCd8s87Bf1j71hXcJ+igBHrwoYVnpNjseOkZiQCm4\nXa6frstawUT5iie5K2/Lk3S3gswG4istr9ER7q1lLdEgPcxzORSxUBmvIL18oamu\nAMza2cLgYdjcycq1NRJpTdbzH7m7Yit/cBhXiQn82UAsPArv3ebEkVOmWwcntFE=\n=DGvu\n-----END PGP SIGNATURE-----\n", "payload": "tree 120fa2fbc4061f1a5b4fe22c8169b7a9882f6909\nparent 374ab25585f0a817fe7bd6986737f12347b12d0b\nparent 9310e3bd4f425f84fc27878ebf2bda1f30935a63\nauthor Rich Kadel <richkadel@google.com> 1590109821 -0700\ncommitter GitHub <noreply@github.com> 1590109821 -0700\n\nMerge pull request #1 from rust-lang/master\n\nupdate from upstream"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6127e3fde9e8d24388847ad1b442a4337f19965", "html_url": "https://github.com/rust-lang/rust/commit/a6127e3fde9e8d24388847ad1b442a4337f19965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6127e3fde9e8d24388847ad1b442a4337f19965/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "374ab25585f0a817fe7bd6986737f12347b12d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/374ab25585f0a817fe7bd6986737f12347b12d0b", "html_url": "https://github.com/rust-lang/rust/commit/374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "9310e3bd4f425f84fc27878ebf2bda1f30935a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/9310e3bd4f425f84fc27878ebf2bda1f30935a63", "html_url": "https://github.com/rust-lang/rust/commit/9310e3bd4f425f84fc27878ebf2bda1f30935a63"}], "stats": {"total": 303023, "additions": 233314, "deletions": 69709}, "files": [{"sha": "03bc4bab45137c76d85bdd644f76d8640a614ab3", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -14,7 +14,7 @@ http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n \n ### Code\n \n-```\n+```Rust\n <code>\n ```\n "}, {"sha": "51bf0c3ee673652e64d8770d189b2454f38277d3", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,6 +1,6 @@\n ---\n name: Tracking Issue\n-about: A tracking issue for a feature in Rust.\n+about: A tracking issue for an accepted feature or RFC in Rust.\n title: Tracking Issue for XXX\n labels: C-tracking-issue\n ---"}, {"sha": "291dbf603612a71441121ec13d1e601b06242158", "filename": ".github/workflows/ci.yml", "status": "added", "additions": 663, "deletions": 0, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,663 @@\n+#############################################################\n+#   WARNING: automatically generated file, DO NOT CHANGE!   #\n+#############################################################\n+\n+# This file was automatically generated by the expand-yaml-anchors tool. The\n+# source file that generated this one is:\n+#\n+#   src/ci/github-actions/ci.yml\n+#\n+# Once you make changes to that file you need to run:\n+#\n+#   ./x.py run src/tools/expand-yaml-anchors/\n+#\n+# The CI build will fail if the tool is not run after changes to this file.\n+\n+---\n+name: CI\n+\"on\":\n+  push:\n+    branches:\n+      - auto\n+      - try\n+      - master\n+  pull_request:\n+    branches:\n+      - \"**\"\n+defaults:\n+  run:\n+    shell: \"python src/ci/exec-with-shell.py {0}\"\n+jobs:\n+  pr:\n+    name: PR\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'pull_request'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: mingw-check\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-llvm-8\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-tools\n+            env:\n+              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n+            os: ubuntu-latest-xl\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2 packages\n+        run: src/ci/scripts/install-msys2-packages.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  try:\n+    name: try\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-linux-alt\n+            env:\n+              IMAGE: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2 packages\n+        run: src/ci/scripts/install-msys2-packages.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  auto:\n+    name: auto\n+    env:\n+      CI_JOB_NAME: \"${{ matrix.name }}\"\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    strategy:\n+      matrix:\n+        include:\n+          - name: arm-android\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: armhf-gnu\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-aarch64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-android\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-arm-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-armhf-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-armv7-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-i586-gnu-i586-i686-musl\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-i686-freebsd\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-i686-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mips-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mips64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mips64el-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-mipsel-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-powerpc-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-powerpc64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-powerpc64le-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-s390x-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-various-1\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-various-2\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-freebsd\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-linux-alt\n+            env:\n+              IMAGE: dist-x86_64-linux\n+            os: ubuntu-latest-xl\n+          - name: dist-x86_64-musl\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: dist-x86_64-netbsd\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: i686-gnu\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: i686-gnu-nopt\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: mingw-check\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: test-various\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: wasm32\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-aux\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-debug\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-distcheck\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-full-bootstrap\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-llvm-8\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-latest-xl\n+          - name: x86_64-gnu-nopt\n+            os: ubuntu-latest-xl\n+            env: {}\n+          - name: x86_64-gnu-tools\n+            env:\n+              DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n+            os: ubuntu-latest-xl\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: macos-latest\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: \"./x.py dist\"\n+              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: \"./x.py test\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            os: macos-latest\n+          - name: x86_64-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n+              SCRIPT: make ci-subset-1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n+              SCRIPT: make ci-subset-2\n+            os: windows-latest-xl\n+          - name: i686-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n+              SCRIPT: make ci-subset-1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: i686-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n+              SCRIPT: make ci-subset-2\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-msvc-aux\n+            env:\n+              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc\"\n+            os: windows-latest-xl\n+          - name: x86_64-msvc-cargo\n+            env:\n+              SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc\"\n+              VCVARS_BAT: vcvars64.bat\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-msvc-tools\n+            env:\n+              SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\"\n+            os: windows-latest-xl\n+          - name: i686-mingw-1\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n+              SCRIPT: make ci-mingw-subset-1\n+              CUSTOM_MINGW: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: i686-mingw-2\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n+              SCRIPT: make ci-mingw-subset-2\n+              CUSTOM_MINGW: 1\n+            os: windows-latest-xl\n+          - name: x86_64-mingw-1\n+            env:\n+              SCRIPT: make ci-mingw-subset-1\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu\"\n+              CUSTOM_MINGW: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            os: windows-latest-xl\n+          - name: x86_64-mingw-2\n+            env:\n+              SCRIPT: make ci-mingw-subset-2\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu\"\n+              CUSTOM_MINGW: 1\n+            os: windows-latest-xl\n+          - name: dist-x86_64-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-i686-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --target=i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-i686-mingw\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\"\n+              SCRIPT: python x.py dist\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-x86_64-mingw\n+            env:\n+              SCRIPT: python x.py dist\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\"\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            os: windows-latest-xl\n+          - name: dist-x86_64-msvc-alt\n+            env:\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\"\n+              SCRIPT: python x.py dist\n+            os: windows-latest-xl\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          EXTRA_VARIABLES: \"${{ toJson(matrix.env) }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MSYS2 packages\n+        run: src/ci/scripts/install-msys2-packages.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        if: success() && !env.SKIP_JOB\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.CACHES_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\"\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: \"${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\"\n+          AWS_SECRET_ACCESS_KEY: \"${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\"\n+        if: \"success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\"\n+  master:\n+    name: master\n+    runs-on: ubuntu-latest\n+    env:\n+      SCCACHE_BUCKET: rust-lang-gha-caches\n+      DEPLOY_BUCKET: rust-lang-gha\n+      TOOLSTATE_REPO: \"https://github.com/pietroalbini/rust-toolstate\"\n+      TOOLSTATE_ISSUES_API_URL: \"https://api.github.com/repos/pietroalbini/rust-toolstate/issues\"\n+      TOOLSTATE_PUBLISH: 1\n+      CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+      ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+      CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+    if: \"github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+      - name: publish toolstate\n+        run: src/ci/publish_toolstate.sh\n+        env:\n+          TOOLSTATE_REPO_ACCESS_TOKEN: \"${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\"\n+        if: success() && !env.SKIP_JOB\n+  try-success:\n+    needs:\n+      - try\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a success\n+        run: exit 0\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+  try-failure:\n+    needs:\n+      - try\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a failure\n+        run: exit 1\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+  auto-success:\n+    needs:\n+      - auto\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a success\n+        run: exit 0\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+  auto-failure:\n+    needs:\n+      - auto\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    steps:\n+      - name: mark the job as a failure\n+        run: exit 1\n+        shell: bash\n+    name: bors build finished\n+    runs-on: ubuntu-latest"}, {"sha": "856ff7dbb0f33cef38a9a680945d1eb27f5cc370", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -35,7 +35,7 @@ __pycache__/\n /obj/\n /rustllvm/\n /unicode-downloads\n-/target/\n+/target\n # Generated by compiletest for incremental:\n /tmp/\n tags"}, {"sha": "a9210cfc69ec5f9fab0650dc3354d626335bb8c6", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -16,9 +16,6 @@\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n \turl = https://github.com/rust-lang/rls.git\n-[submodule \"src/tools/clippy\"]\n-\tpath = src/tools/clippy\n-\turl = https://github.com/rust-lang/rust-clippy.git\n [submodule \"src/tools/rustfmt\"]\n \tpath = src/tools/rustfmt\n \turl = https://github.com/rust-lang/rustfmt.git\n@@ -31,16 +28,16 @@\n [submodule \"src/stdarch\"]\n \tpath = src/stdarch\n \turl = https://github.com/rust-lang/stdarch.git\n-[submodule \"src/doc/rustc-guide\"]\n-\tpath = src/doc/rustc-guide\n-\turl = https://github.com/rust-lang/rustc-guide.git\n+[submodule \"src/doc/rustc-dev-guide\"]\n+\tpath = src/doc/rustc-dev-guide\n+\turl = https://github.com/rust-lang/rustc-dev-guide.git\n [submodule \"src/doc/edition-guide\"]\n \tpath = src/doc/edition-guide\n \turl = https://github.com/rust-lang/edition-guide.git\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/9.0-2019-12-19\n+\tbranch = rustc/10.0-2020-05-05\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "680aa04078f97f1fa8e853c81833ee899f9dc550", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -49,6 +49,7 @@ Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@user\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n Carol Willing <carolcode@willingconsulting.com>\n+Charles Lew <crlf0710@gmail.com> CrLF0710 <crlf0710@gmail.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n@@ -133,7 +134,7 @@ Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n Johann Hofmann <git@johann-hofmann.com> Johann <git@johann-hofmann.com>\n John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n John Hodge <acessdev@gmail.com> John Hodge <tpg@mutabah.net>\n-John Ka\u030are Alsaker <john.kare.alsaker@gmail.com>\n+John K\u00e5re Alsaker <john.kare.alsaker@gmail.com>\n John Talling <inrustwetrust@users.noreply.github.com>\n Jonathan Bailey <jbailey@mozilla.com> <jbailey@jbailey-20809.local>\n Jonathan S <gereeter@gmail.com> Jonathan S <gereeter+code@gmail.com>\n@@ -153,7 +154,7 @@ Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>\n-Le\u0301o Testard <leo.testard@gmail.com>\n+L\u00e9o Testard <leo.testard@gmail.com>\n Lindsey Kuper <lindsey@composition.al> <lindsey@rockstargirl.org>\n Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n Luke Metz <luke.metz@students.olin.edu>"}, {"sha": "9c4afcefa1f220a1754cddcc82d838e6102bff83", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 77, "deletions": 8, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -188,11 +188,73 @@ with one another are rolled up.\n Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found [here][rctd].\n \n-### External Dependencies\n+### External Dependencies (subtree)\n+\n+As a developer to this repository, you don't have to treat the following external projects\n+differently from other crates that are directly in this repo:\n+\n+* Clippy\n+\n+They are just regular files and directories. This is in contrast to `submodule` dependencies\n+(see below for those). Only tool authors will actually use any operations here.\n+\n+#### Synchronizing a subtree\n+\n+There are two synchronization directions: `subtree push` and `subtree pull`.\n+\n+```\n+git subtree push -P src/tools/clippy git@github.com:your-github-name/rust-clippy sync-from-rust\n+```\n+\n+takes all the changes that\n+happened to the copy in this repo and creates commits on the remote repo that match the local\n+changes. Every local commit that touched the subtree causes a commit on the remote repo, but is\n+modified to move the files from the specified directory to the tool repo root.\n+\n+Make sure to not pick the `master` branch on the tool repo, so you can open a normal PR to the tool\n+to merge that subrepo push.\n+\n+```\n+git subtree pull -P src/tools/clippy https://github.com/rust-lang/rust-clippy master\n+```\n+\n+takes all changes since the last `subtree pull` from the tool repo\n+repo and adds these commits to the rustc repo + a merge commit that moves the tool changes into\n+the specified directory in the rust repository.\n+\n+It is recommended that you always do a push first and get that merged to the tool master branch.\n+Then, when you do a pull, the merge works without conflicts.\n+While it's definitely possible to resolve conflicts during a pull, you may have to redo the conflict\n+resolution if your PR doesn't get merged fast enough and there are new conflicts. Do not try to\n+rebase the result of a `git subtree pull`, rebasing merge commits is a bad idea in general.\n+\n+You always need to specify the `-P` prefix to the subtree directory and the corresponding remote\n+repository. If you specify the wrong directory or repository\n+you'll get very fun merges that try to push the wrong directory to the wrong remote repository.\n+Luckily you can just abort this without any consequences by throwing away either the pulled commits\n+in rustc or the pushed branch on the remote and try again. It is usually fairly obvious\n+that this is happening because you suddenly get thousands of commits that want to be synchronized.\n+\n+#### Creating a new subtree dependency\n+\n+If you want to create a new subtree dependency from an existing repository, call (from this\n+repository's root directory!)\n+\n+```\n+git subtree add -P src/tools/clippy https://github.com/rust-lang/rust-clippy.git master\n+```\n+\n+This will create a new commit, which you may not rebase under any circumstances! Delete the commit\n+and redo the operation if you need to rebase.\n+\n+Now you're done, the `src/tools/clippy` directory behaves as if Clippy were part of the rustc\n+monorepo, so no one but you (or others that synchronize subtrees) actually needs to use `git subtree`.\n+\n+\n+### External Dependencies (submodules)\n \n Currently building Rust will also build the following external projects:\n \n-* [clippy](https://github.com/rust-lang/rust-clippy)\n * [miri](https://github.com/rust-lang/miri)\n * [rustfmt](https://github.com/rust-lang/rustfmt)\n * [rls](https://github.com/rust-lang/rls/)\n@@ -221,7 +283,6 @@ before the PR is merged.\n \n Rust's build system builds a number of tools that make use of the\n internals of the compiler. This includes\n-[Clippy](https://github.com/rust-lang/rust-clippy),\n [RLS](https://github.com/rust-lang/rls) and\n [rustfmt](https://github.com/rust-lang/rustfmt). If these tools\n break because of your changes, you may run into a sort of \"chicken and egg\"\n@@ -331,10 +392,18 @@ You can find documentation style guidelines in [RFC 1574][rfc1574].\n \n [rfc1574]: https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md#appendix-a-full-conventions-text\n \n-In many cases, you don't need a full `./x.py doc`. You can use `rustdoc` directly\n-to check small fixes. For example, `rustdoc src/doc/reference.md` will render\n-reference to `doc/reference.html`. The CSS might be messed up, but you can\n-verify that the HTML is right.\n+In many cases, you don't need a full `./x.py doc`, which will build the entire\n+stage 2 compiler and compile the various books published on\n+[doc.rust-lang.org]. When updating documentation for the standard library,\n+first try `./x.py doc --stage 0 src/libstd`. If that fails, or if you need to\n+see the output from the latest version of `rustdoc`, use `--stage 1` instead of\n+`--stage 0`. Results should appear in `build/$TARGET/crate-docs`.\n+\n+[doc.rust-lang.org]: htts://doc.rust-lang.org\n+\n+You can also use `rustdoc` directly to check small fixes. For example,\n+`rustdoc src/doc/reference.md` will render reference to `doc/reference.html`.\n+The CSS might be messed up, but you can verify that the HTML is right.\n \n Additionally, contributions to the [rustc-dev-guide] are always welcome. Contributions\n can be made directly at [the\n@@ -449,7 +518,7 @@ are:\n * Don't be afraid to ask! The Rust community is friendly and helpful.\n \n [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[gdfrustc]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n+[gdfrustc]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org\n [rr]: https://doc.rust-lang.org/book/README.html"}, {"sha": "d81fd6e8d3afd6fd7ac275674f9cce6d474fad4a", "filename": "Cargo.lock", "status": "modified", "additions": 576, "deletions": 340, "changes": 916, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -74,7 +74,7 @@ name = \"arena\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc_data_structures\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -87,12 +87,6 @@ dependencies = [\n  \"scoped_threadpool\",\n ]\n \n-[[package]]\n-name = \"arrayref\"\n-version = \"0.3.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d382e583f07208808f6b1249e60848879ba3543f57c32277bf52d69c2f0f0ee\"\n-\n [[package]]\n name = \"arrayvec\"\n version = \"0.4.7\"\n@@ -119,11 +113,17 @@ version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n+\n [[package]]\n name = \"backtrace\"\n-version = \"0.3.45\"\n+version = \"0.3.46\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ad235dabf00f36301792cfe82499880ba54c6486be094d1047b02bacb67c14e8\"\n+checksum = \"b1e692897359247cc6bb902933361652380af0f1b7651ae5c5013407f30e109e\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\",\n@@ -135,9 +135,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace-sys\"\n-version = \"0.1.34\"\n+version = \"0.1.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ca797db0057bae1a7aa2eef3283a874695455cecf08a43bfb8507ee0ebc1ed69\"\n+checksum = \"18fbebbe1c9d1f383a9cc7e8ccdb471b91c8d024ee9c2ca5b5346121fe8b4399\"\n dependencies = [\n  \"cc\",\n  \"compiler_builtins\",\n@@ -181,11 +181,22 @@ dependencies = [\n \n [[package]]\n name = \"block-buffer\"\n-version = \"0.3.3\"\n+version = \"0.7.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c0940dc441f31689269e10ac70eb1002a3a1d3ad1390e030043662eb7fe4688b\"\n+dependencies = [\n+ \"block-padding\",\n+ \"byte-tools\",\n+ \"byteorder\",\n+ \"generic-array\",\n+]\n+\n+[[package]]\n+name = \"block-padding\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a076c298b9ecdb530ed9d967e74a6027d6a7478924520acddcddc24c1c8ab3ab\"\n+checksum = \"fa79dedbb091f449f1f39e53edf88d5dbe95f895dae6135a8d7b881fb5af73f5\"\n dependencies = [\n- \"arrayref\",\n  \"byte-tools\",\n ]\n \n@@ -234,9 +245,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"byte-tools\"\n-version = \"0.2.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n+checksum = \"e3b5ca7a04898ad4bcd41c90c5285445ff5b791899bb1b0abdd2a2aa791211d7\"\n \n [[package]]\n name = \"bytecount\"\n@@ -281,7 +292,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.45.0\"\n+version = \"0.46.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -292,14 +303,13 @@ dependencies = [\n  \"clap\",\n  \"core-foundation 0.7.0\",\n  \"crates-io\",\n- \"crossbeam-utils 0.7.0\",\n+ \"crossbeam-utils 0.7.2\",\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n  \"env_logger 0.7.1\",\n  \"filetime\",\n  \"flate2\",\n- \"fs2\",\n  \"fwdansi\",\n  \"git2\",\n  \"git2-curl\",\n@@ -324,7 +334,7 @@ dependencies = [\n  \"pretty_env_logger\",\n  \"remove_dir_all\",\n  \"rustc-workspace-hack\",\n- \"rustfix 0.5.0\",\n+ \"rustfix\",\n  \"same-file\",\n  \"semver\",\n  \"serde\",\n@@ -402,9 +412,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.50\"\n+version = \"1.0.52\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95e28fa049fda1c330bcf9d723be7663a899c4679724b34c81e9f5a326aab8cd\"\n+checksum = \"c3d87b23d6a92cd03af510a5ade527033f6aa6fa92161e2d5863a907d4c5e31d\"\n dependencies = [\n  \"jobserver\",\n ]\n@@ -419,6 +429,77 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"chalk-derive\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8d4620afad4d4d9e63f915cfa10c930b7a3c9c3ca5cd88dd771ff8e5bf04ea10\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+ \"synstructure\",\n+]\n+\n+[[package]]\n+name = \"chalk-engine\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6ca6e5cef10197789da0b4ec310eda58da4c55530613b2323432642a97372735\"\n+dependencies = [\n+ \"chalk-macros\",\n+ \"rustc-hash\",\n+]\n+\n+[[package]]\n+name = \"chalk-ir\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d45df5fb6328527f976e8a32c9e1c9970084d937ebe93d0d34f5bbf4231cb956\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-macros\",\n+]\n+\n+[[package]]\n+name = \"chalk-macros\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e4782d108e420a1fcf94d8a919cf248db33c5071678e87d9c2d4f20ed1feb32\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+]\n+\n+[[package]]\n+name = \"chalk-rust-ir\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a0ec96dbe0ab5fdbadfca4179ec2e1d35f0439c3b53a74988b1aec239c63eb08\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-ir\",\n+ \"chalk-macros\",\n+]\n+\n+[[package]]\n+name = \"chalk-solve\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dfb99fa9530f0e101475fb60adc931f51bdea05b4642a48928b814d7f0141a6b\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-engine\",\n+ \"chalk-ir\",\n+ \"chalk-macros\",\n+ \"chalk-rust-ir\",\n+ \"ena 0.13.1\",\n+ \"itertools 0.9.0\",\n+ \"petgraph\",\n+ \"rustc-hash\",\n+]\n+\n [[package]]\n name = \"chrono\"\n version = \"0.4.6\"\n@@ -443,7 +524,7 @@ dependencies = [\n  \"textwrap\",\n  \"unicode-width\",\n  \"vec_map\",\n- \"yaml-rust\",\n+ \"yaml-rust 0.3.5\",\n ]\n \n [[package]]\n@@ -456,7 +537,6 @@ dependencies = [\n  \"compiletest_rs\",\n  \"derive-new\",\n  \"lazy_static 1.4.0\",\n- \"regex\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n  \"semver\",\n@@ -477,13 +557,12 @@ dependencies = [\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"lazy_static 1.4.0\",\n- \"matches\",\n- \"pulldown-cmark 0.7.0\",\n+ \"pulldown-cmark 0.7.1\",\n  \"quine-mc_cluskey\",\n  \"regex-syntax\",\n  \"semver\",\n  \"serde\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n@@ -556,9 +635,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.25\"\n+version = \"0.1.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"438ac08ddc5efe81452f984a9e33ba425b00b31d1f48e6acd9e2210aa28cc52e\"\n+checksum = \"439a6fab343b1dab347823537734a5cd4ae6ae2000b465ab886f64cdb723bd14\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -576,7 +655,7 @@ dependencies = [\n  \"log\",\n  \"miow 0.3.3\",\n  \"regex\",\n- \"rustfix 0.5.0\",\n+ \"rustfix\",\n  \"serde\",\n  \"serde_json\",\n  \"walkdir\",\n@@ -585,9 +664,9 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7b678957210a00ba0fbeacc23d38cbfbf29895564da1616564634351e1dac5e\"\n+checksum = \"9f737835bfbbe29ed1ff82d5137520338d7ed5bf1a1d4b9c1c7c58bb45b8fa29\"\n dependencies = [\n  \"diff\",\n  \"filetime\",\n@@ -596,7 +675,7 @@ dependencies = [\n  \"log\",\n  \"miow 0.3.3\",\n  \"regex\",\n- \"rustfix 0.4.6\",\n+ \"rustfix\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n@@ -680,7 +759,7 @@ checksum = \"b3a71ab494c0b5b860bdc8407ae08978052417070c2ced38573a9157ad75b8ac\"\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.31.0\"\n+version = \"0.31.1\"\n dependencies = [\n  \"anyhow\",\n  \"curl\",\n@@ -706,7 +785,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"acec9a3b0b3559f15aee4f90746c4e5e293b701c0f7d3925d24e01645267b68c\"\n dependencies = [\n- \"crossbeam-utils 0.7.0\",\n+ \"crossbeam-utils 0.7.2\",\n ]\n \n [[package]]\n@@ -754,11 +833,11 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.7.0\"\n+version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ce446db02cdc3165b94ae73111e570793400d0794e46125cc4056c81cbb039f4\"\n+checksum = \"c3c7c73a2d1e9fc0886a08b93e98eb643461230d5f1925e4036204d5f2e261a8\"\n dependencies = [\n- \"autocfg\",\n+ \"autocfg 1.0.0\",\n  \"cfg-if\",\n  \"lazy_static 1.4.0\",\n ]\n@@ -775,6 +854,16 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"ctor\"\n+version = \"0.1.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"47c5e5ac752e18207b12e16b10631ae5f7f68f8805f335f9b817ead83d9ffce1\"\n+dependencies = [\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+]\n+\n [[package]]\n name = \"curl\"\n version = \"0.4.25\"\n@@ -848,13 +937,13 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"derive-new\"\n-version = \"0.5.6\"\n+version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6ca414e896ae072546f4d789f452daaecf60ddee4c9df5dc6d5936d769e3d87c\"\n+checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -882,9 +971,9 @@ checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \n [[package]]\n name = \"digest\"\n-version = \"0.7.6\"\n+version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"03b072242a8cbaf9c145665af9d250c59af3b958f83ed6824e13533cf76d5b90\"\n+checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n dependencies = [\n  \"generic-array\",\n ]\n@@ -923,9 +1012,9 @@ dependencies = [\n \n [[package]]\n name = \"dlmalloc\"\n-version = \"0.1.3\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f283302e035e61c23f2b86b3093e8c6273a4c3125742d6087e96ade001ca5e63\"\n+checksum = \"35055b1021724f4eb5262eb49130eebff23fc59fc5a14160e05faad8eeb36673\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -974,6 +1063,15 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n+dependencies = [\n+ \"log\",\n+]\n+\n [[package]]\n name = \"encoding_rs\"\n version = \"0.8.17\"\n@@ -1026,6 +1124,14 @@ dependencies = [\n  \"walkdir\",\n ]\n \n+[[package]]\n+name = \"expand-yaml-anchors\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"yaml-merge-keys\",\n+ \"yaml-rust 0.4.3\",\n+]\n+\n [[package]]\n name = \"failure\"\n version = \"0.1.5\"\n@@ -1038,14 +1144,14 @@ dependencies = [\n \n [[package]]\n name = \"failure_derive\"\n-version = \"0.1.5\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n+checksum = \"aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"synstructure 0.10.2\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+ \"synstructure\",\n ]\n \n [[package]]\n@@ -1056,16 +1162,22 @@ checksum = \"e88a8acf291dafb59c2d96e8f59828f3838bb1a70398823ade51a84de6a6deed\"\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.8\"\n+version = \"0.2.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ff6d4dab0aa0c8e6346d46052e93b13a16cf847b54ed357087c35011048cc7d\"\n+checksum = \"f59efc38004c988e4201d11d263b8171f49a2e7ec0bdbb71773433f271504a5e\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"fixedbitset\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n+\n [[package]]\n name = \"flate2\"\n version = \"1.0.12\"\n@@ -1118,16 +1230,6 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"fs2\"\n-version = \"0.4.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213\"\n-dependencies = [\n- \"libc\",\n- \"winapi 0.3.8\",\n-]\n-\n [[package]]\n name = \"fs_extra\"\n version = \"1.1.0\"\n@@ -1203,9 +1305,9 @@ dependencies = [\n \n [[package]]\n name = \"generic-array\"\n-version = \"0.9.0\"\n+version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ef25c5683767570c2bbd7deba372926a55eaae9982d7726ee2a1050239d45b9d\"\n+checksum = \"c68f0274ae0e023facc3c97b2e00f076be70e254bc851d972503b328db79b2ec\"\n dependencies = [\n  \"typenum\",\n ]\n@@ -1234,9 +1336,9 @@ dependencies = [\n \n [[package]]\n name = \"git2\"\n-version = \"0.13.0\"\n+version = \"0.13.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b7da16ceafe24cedd9ba02c4463a2b506b6493baf4317c79c5acb553134a3c15\"\n+checksum = \"e1e02a51cd90229028c9bd8be0a0364f85b6b3199cccaa0ef39005ddbd5ac165\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1302,37 +1404,25 @@ dependencies = [\n \n [[package]]\n name = \"handlebars\"\n-version = \"2.0.1\"\n+version = \"3.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df044dd42cdb7e32f28557b661406fc0f2494be75199779998810dbc35030e0d\"\n+checksum = \"ba758d094d31274eb49d15da6f326b96bf3185239a6359bf684f3d5321148900\"\n dependencies = [\n- \"hashbrown 0.5.0\",\n- \"lazy_static 1.4.0\",\n  \"log\",\n  \"pest\",\n  \"pest_derive\",\n  \"quick-error\",\n- \"regex\",\n  \"serde\",\n  \"serde_json\",\n ]\n \n-[[package]]\n-name = \"hashbrown\"\n-version = \"0.5.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e1de41fb8dba9714efd92241565cdff73f78508c95697dd56787d3cba27e2353\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"hashbrown\"\n version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3cd9867f119b19fecb08cd5c326ad4488d7a1da4bf75b4d95d71db742525aaab\"\n dependencies = [\n- \"autocfg\",\n+ \"autocfg 0.1.7\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -1349,9 +1439,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.1\"\n+version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f22b8f315b98f415780ddbe9163c7dbbc5a07225b6d102ace1d8aeef85775140\"\n+checksum = \"91780f809e750b0a89f5544be56617ff6b1227ee485bcb06ebe10cdf89bd3b71\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -1535,9 +1625,9 @@ dependencies = [\n \n [[package]]\n name = \"im-rc\"\n-version = \"14.0.0\"\n+version = \"15.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e9ad726dce25993be6352b0bff048e4d2647440c0a673d32257c4fac49356d18\"\n+checksum = \"3ca8957e71f04a205cb162508f9326aea04676c8dfd0711220190d6b83664f3f\"\n dependencies = [\n  \"bitmaps\",\n  \"rand_core 0.5.1\",\n@@ -1719,7 +1809,7 @@ checksum = \"5b31c9b90731276fdd24d896f31bb10aecf2e5151733364ae81123186643d939\"\n dependencies = [\n  \"jsonrpc-core\",\n  \"log\",\n- \"parking_lot 0.10.0\",\n+ \"parking_lot 0.10.2\",\n  \"serde\",\n ]\n \n@@ -1769,18 +1859,18 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.66\"\n+version = \"0.2.69\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d515b1f41455adea1313a4a2ac8a8a477634fbae63cc6100e3aebb207ce61558\"\n+checksum = \"99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.12.0+0.99.0\"\n+version = \"0.12.5+1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"05dff41ac39e7b653f5f1550886cf00ba52f8e7f57210b633cdeedb3de5b236c\"\n+checksum = \"3eadeec65514971355bf7134967a543f71372f35b53ac6c7143e7bd157f07535\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1830,11 +1920,17 @@ dependencies = [\n name = \"linkchecker\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"linked-hash-map\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ae91b68aebc4ddb91978b11a1b02ddd8602a05ec19002801c5666000e05e0f83\"\n+\n [[package]]\n name = \"lock_api\"\n-version = \"0.3.1\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f8912e782533a93a167888781b836336a6ca5da6175c05944c86cf28c31104dc\"\n+checksum = \"c4da24a77a3d8a6d4862d95f72e6fdb9c09a643ecdb402d754004a557f2bec75\"\n dependencies = [\n  \"scopeguard\",\n ]\n@@ -1933,11 +2029,22 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \n+[[package]]\n+name = \"md-5\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a18af3dcaf2b0219366cdb4e2af65a6101457b415c3d1a5c71dd9c2b7c77b9c8\"\n+dependencies = [\n+ \"block-buffer\",\n+ \"digest\",\n+ \"opaque-debug\",\n+]\n+\n [[package]]\n name = \"mdbook\"\n-version = \"0.3.5\"\n+version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"031bdd9d4893c983e2f69ebc4b59070feee8276a584c4aabdcb351235ea28016\"\n+checksum = \"e7ec525f7ebccc2dd935c263717250cd37f9a4b264a77c5dbc950ea2734d8159\"\n dependencies = [\n  \"ammonia\",\n  \"chrono\",\n@@ -2221,6 +2328,12 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d6a04cb71e910d0034815600180f62a95bf6e67942d7ab52a166a68c7d7e9cd0\"\n \n+[[package]]\n+name = \"opaque-debug\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c\"\n+\n [[package]]\n name = \"open\"\n version = \"1.2.1\"\n@@ -2258,33 +2371,48 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.6.1+1.1.1d\"\n+version = \"111.9.0+1.1.1g\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c91b04cb43c1a8a90e934e0cd612e2a5715d976d2d6cff4490278a0cddf35005\"\n+checksum = \"a2dbe10ddd1eb335aba3780eb2eaa13e1b7b441d2562fd962398740927f39ec4\"\n dependencies = [\n  \"cc\",\n ]\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.53\"\n+version = \"0.9.54\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"465d16ae7fc0e313318f7de5cecf57b2fbe7511fd213978b457e1c96ff46736f\"\n+checksum = \"1024c0a59774200a555087a6da3f253a9095a5f344e353b212ac4c8b8e450986\"\n dependencies = [\n- \"autocfg\",\n+ \"autocfg 1.0.0\",\n  \"cc\",\n  \"libc\",\n  \"openssl-src\",\n  \"pkg-config\",\n  \"vcpkg\",\n ]\n \n+[[package]]\n+name = \"ordermap\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n+\n [[package]]\n name = \"ordslice\"\n version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dd20eec3dbe4376829cb7d80ae6ac45e0a766831dca50202ff2d40db46a8a024\"\n \n+[[package]]\n+name = \"output_vt100\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"53cdc5b785b7a58c5aad8216b3dfa114df64b0b06ae6e1501cef91df2fbdf8f9\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"packed_simd\"\n version = \"0.3.1\"\n@@ -2346,12 +2474,12 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot\"\n-version = \"0.10.0\"\n+version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"92e98c49ab0b7ce5b222f2cc9193fc4efe11c6d0bd4f648e374684a6857b1cfc\"\n+checksum = \"d3a704eb390aafdc107b0e392f56a82b668e3a71366993b5340f5833fd62505e\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core 0.7.0\",\n+ \"parking_lot_core 0.7.1\",\n ]\n \n [[package]]\n@@ -2371,15 +2499,15 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.7.0\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7582838484df45743c8434fbff785e8edf260c28748353d44bc0da32e0ceabf1\"\n+checksum = \"0e136c1904604defe99ce5fd71a28d473fa60a12255d511aa78a9ddf11237aeb\"\n dependencies = [\n  \"cfg-if\",\n  \"cloudabi\",\n  \"libc\",\n  \"redox_syscall\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -2416,28 +2544,38 @@ dependencies = [\n \n [[package]]\n name = \"pest_generator\"\n-version = \"2.1.0\"\n+version = \"2.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n+checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n name = \"pest_meta\"\n-version = \"2.1.0\"\n+version = \"2.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f5a3492a4ed208ffc247adcdcc7ba2a95be3104f58877d0d02f0df39bf3efb5e\"\n+checksum = \"54be6e404f5317079812fc8f9f5279de376d8856929e21c184ecf6bbd692a11d\"\n dependencies = [\n  \"maplit\",\n  \"pest\",\n  \"sha-1\",\n ]\n \n+[[package]]\n+name = \"petgraph\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c3659d1ee90221741f65dd128d9998311b0e40c5d3c23a62445938214abce4f\"\n+dependencies = [\n+ \"fixedbitset\",\n+ \"ordermap\",\n+]\n+\n [[package]]\n name = \"phf\"\n version = \"0.7.24\"\n@@ -2484,9 +2622,9 @@ checksum = \"05da548ad6865900e60eaba7f589cc0783590a92e940c26953ff81ddbab2d677\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04d8ef65e3f89ecaec9ca7cb0e0911b4617352d4494018bcf934992f03f2024c\"\n+checksum = \"ef2558a4b464e185b36ee08a2937ebb62ea5464c38856cfb1465c97cb38db52d\"\n dependencies = [\n  \"datafrog\",\n  \"log\",\n@@ -2507,12 +2645,14 @@ checksum = \"925383efa346730478fb4838dbe9137d2a47675ad789c546d150a6e1dd4ab31c\"\n \n [[package]]\n name = \"pretty_assertions\"\n-version = \"0.5.1\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a029430f0d744bc3d15dd474d591bed2402b645d024583082b9f63bb936dac6\"\n+checksum = \"3f81e1644e1b54f5a68959a29aa86cde704219254669da328ecfdf6a1f09d427\"\n dependencies = [\n  \"ansi_term\",\n+ \"ctor\",\n  \"difference\",\n+ \"output_vt100\",\n ]\n \n [[package]]\n@@ -2579,6 +2719,15 @@ dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"psm\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"659ecfea2142a458893bb7673134bad50b752fea932349c213d6a23874ce3aa7\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n [[package]]\n name = \"publicsuffix\"\n version = \"1.5.3\"\n@@ -2606,9 +2755,9 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.7.0\"\n+version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2c2d7fd131800e0d63df52aff46201acaab70b431a4a1ec6f0343fe8e64f35a4\"\n+checksum = \"3e142c3b8f49d2200605ee6ba0b1d757310e9e7a72afe78c36ee2ef67300ee00\"\n dependencies = [\n  \"bitflags\",\n  \"memchr\",\n@@ -2623,9 +2772,9 @@ checksum = \"6ddd112cca70a4d30883b2d21568a1d376ff8be4758649f64f973c6845128ad3\"\n \n [[package]]\n name = \"quick-error\"\n-version = \"1.2.2\"\n+version = \"1.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n+checksum = \"a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0\"\n \n [[package]]\n name = \"quine-mc_cluskey\"\n@@ -2653,9 +2802,9 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.31\"\n+version = \"2.1.33\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0ff33fa15ac0384376741d16ddb05a65263dde4e2c5d0f7a9f3747db788764aa\"\n+checksum = \"54322b696f7df20e0d79d0244a1088f387b7164a5f17987c4ab984dec1a23e42\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n@@ -2665,13 +2814,13 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"rls-span\",\n+ \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_parse\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"rustc-ap-syntax\",\n ]\n \n [[package]]\n@@ -3093,72 +3242,76 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"rustc\"\n-version = \"0.0.0\"\n+name = \"rustc-ap-arena\"\n+version = \"654.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"81dfcfbb0ddfd533abf8c076e3b49d1e5042d1962526a12ce2c66d514b24cca3\"\n dependencies = [\n- \"arena\",\n- \"backtrace\",\n- \"bitflags\",\n- \"byteorder\",\n- \"jobserver\",\n- \"log\",\n- \"measureme\",\n- \"parking_lot 0.9.0\",\n- \"polonius-engine\",\n- \"rustc-rayon\",\n- \"rustc-rayon-core\",\n- \"rustc_apfloat\",\n- \"rustc_ast\",\n- \"rustc_attr\",\n- \"rustc_data_structures\",\n- \"rustc_errors\",\n- \"rustc_feature\",\n- \"rustc_hir\",\n- \"rustc_index\",\n- \"rustc_macros\",\n- \"rustc_query_system\",\n- \"rustc_session\",\n- \"rustc_span\",\n- \"rustc_target\",\n- \"scoped-tls\",\n- \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n-name = \"rustc-ap-arena\"\n-version = \"642.0.0\"\n+name = \"rustc-ap-graphviz\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea82fa3d9a8add7422228ca1a2cbba0784fa8861f56148ff64da08b3c7921b03\"\n+checksum = \"7490bb07b014a7f9531bde33c905a805e08095dbefdb4c9988a1b19fe6d019fd\"\n+\n+[[package]]\n+name = \"rustc-ap-rustc_ast\"\n+version = \"654.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"189f16dbb8dd11089274c9ced58b0cae9e1ea3e434a58f3db683817eda849e58\"\n dependencies = [\n+ \"log\",\n  \"rustc-ap-rustc_data_structures\",\n- \"smallvec 1.0.0\",\n+ \"rustc-ap-rustc_index\",\n+ \"rustc-ap-rustc_lexer\",\n+ \"rustc-ap-rustc_macros\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-serialize\",\n+ \"scoped-tls\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n-name = \"rustc-ap-graphviz\"\n-version = \"642.0.0\"\n+name = \"rustc-ap-rustc_ast_passes\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"638d0b2b3bcf99824e0cb5a25dbc547b61dc20942e11daf6a97e981918aa18e5\"\n+checksum = \"bbe619609b56a617fa986332b066d53270093c816d8ff8281fc90e1dbe74c1cc\"\n+dependencies = [\n+ \"itertools 0.8.0\",\n+ \"log\",\n+ \"rustc-ap-rustc_ast\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_attr\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_parse\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n+]\n \n [[package]]\n name = \"rustc-ap-rustc_ast_pretty\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d38bab04dd676dee6d2f9670506a18c31bfce38bf7f8420aa83eb1140ecde049\"\n+checksum = \"26ab1495f7b420e937688749c1da5763aaabd6ebe8cacb758665a0b8481da094\"\n dependencies = [\n  \"log\",\n+ \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_span\",\n- \"rustc-ap-syntax\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_attr\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"10b843ba8b1ed43739133047673b9f6a54d3b3b4d328d69c6ea89ff971395f35\"\n+checksum = \"2e057495724c60729c1d1d9d49374e0b3ebd6d3481cd161b2871f52fe017b7b5\"\n dependencies = [\n+ \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n@@ -3167,42 +3320,42 @@ dependencies = [\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dc3d1c6d0a80ab0c1df76405377cec0f3d5423fb5b0953a8eac70a2ad6c44df2\"\n+checksum = \"d2130997667833692f4bec4681d0e73b066d5a01dac1d8a68f22068b82bf173a\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n- \"crossbeam-utils 0.6.5\",\n- \"ena\",\n+ \"crossbeam-utils 0.7.2\",\n+ \"ena 0.13.1\",\n  \"indexmap\",\n  \"jobserver\",\n  \"lazy_static 1.4.0\",\n+ \"libc\",\n  \"log\",\n  \"measureme\",\n- \"parking_lot 0.9.0\",\n+ \"parking_lot 0.10.2\",\n  \"rustc-ap-graphviz\",\n  \"rustc-ap-rustc_index\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n  \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4909a1eca29331332257230f29120a8ff68c9e37d868c564fcd599e430cf8914\"\n+checksum = \"908e1ea187c6bb368af4ba6db980001e920515e67371ddc4086e749baabe6080\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n@@ -3216,11 +3369,33 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"rustc-ap-rustc_expand\"\n+version = \"654.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"50066a75bca872ff933b0ee8a582d18ef1876c8054a392f60c39e538446bfb00\"\n+dependencies = [\n+ \"log\",\n+ \"rustc-ap-rustc_ast\",\n+ \"rustc-ap-rustc_ast_passes\",\n+ \"rustc-ap-rustc_ast_pretty\",\n+ \"rustc-ap-rustc_attr\",\n+ \"rustc-ap-rustc_data_structures\",\n+ \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_feature\",\n+ \"rustc-ap-rustc_lexer\",\n+ \"rustc-ap-rustc_parse\",\n+ \"rustc-ap-rustc_session\",\n+ \"rustc-ap-rustc_span\",\n+ \"rustc-ap-serialize\",\n+ \"smallvec 1.4.0\",\n+]\n+\n [[package]]\n name = \"rustc-ap-rustc_feature\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"63ab887a181d795cf5fd3edadf367760deafb90aefb844f168ab5255266e3478\"\n+checksum = \"96fb53e1710e6de7c2e371ca56c857b79f9b399aba58aa6b6fbed6e2f677d3f6\"\n dependencies = [\n  \"lazy_static 1.4.0\",\n  \"rustc-ap-rustc_data_structures\",\n@@ -3229,71 +3404,71 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_fs_util\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"70814116df3c5fbec8f06f6a1d013ca481f620fd22a9475754e9bf3ee9ba70d8\"\n+checksum = \"e3f91357e5e468fc2729211571d769723c728a34e200d90a70164e945f881e09\"\n \n [[package]]\n name = \"rustc-ap-rustc_index\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ac1bf1d3cf3d119d41353d6fd229ef7272d5097bc0924de021c0294bf86d48bf\"\n+checksum = \"32220c3e6cdf226f38e4474b747dca15f3106bb680c74f10b299af3f6cdb1663\"\n dependencies = [\n  \"rustc-ap-serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4cda21a32cebdc11ec4f5393aa2fcde5ed1b2f673a8571e5a4dcdf07e4ae9cac\"\n+checksum = \"3b324d2a2bacad344e53e182e5ca04ffb74745b932849aa074f8f7fec8177da5\"\n dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"75c47b48ea51910ecfd853c9248a9bf4c767bc823449ab6a1d864dff65fbae16\"\n+checksum = \"59686c56d5f1b3ed47d0f070c257ed35caf24ecf2d744dd11fe44b1014baee0f\"\n dependencies = [\n- \"itertools 0.8.0\",\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_parse\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"abd88e89cd5b5d28dcd3a347a3d534c08627d9455570dc1a2d402cb8437b9d30\"\n+checksum = \"2dfb0c11c591ec5f87bbadb10819795abc9035ff79a26703c1b6c9487ac51f49\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n+ \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n- \"rustc-ap-rustc_attr\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_feature\",\n  \"rustc-ap-rustc_lexer\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"rustc-ap-syntax\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"unicode-normalization\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_session\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b8487b4575fbb2d1fc6f1cd61225efd108a4d36817e6fb9b643d57fcae9cb12\"\n+checksum = \"3d1a194b1a81d7233ee492847638dc9ebdb7d084300e5ade8dea0ceaa98f95b9\"\n dependencies = [\n+ \"getopts\",\n  \"log\",\n  \"num_cpus\",\n+ \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n  \"rustc-ap-rustc_feature\",\n@@ -3302,31 +3477,32 @@ dependencies = [\n  \"rustc-ap-rustc_span\",\n  \"rustc-ap-rustc_target\",\n  \"rustc-ap-serialize\",\n- \"rustc-ap-syntax\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_span\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f69746c0d4c21bf20a5bb2bd247261a1aa8631f04202d7303352942dde70d987\"\n+checksum = \"a648146050fed6b58e681ec22488e728f60e16036bb7497c9815e3debd1e4242\"\n dependencies = [\n  \"cfg-if\",\n  \"log\",\n+ \"md-5\",\n  \"rustc-ap-arena\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_index\",\n  \"rustc-ap-rustc_macros\",\n  \"rustc-ap-serialize\",\n  \"scoped-tls\",\n+ \"sha-1\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8bbc6ae09b5d42ec66edd520e8412e0615c53a7c93607fe33dc4abab60ba7c8b\"\n+checksum = \"28cf28798f0988b808e3616713630e4098d68c6f1f41052a2f7e922e094da744\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -3339,29 +3515,12 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"642.0.0\"\n+version = \"654.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e13a1ead0252fc3d96da4c336a95950be6795f2b00c84a67ccadf26142f8cb41\"\n+checksum = \"756e8f526ec7906e132188bf25e3c10a6ee42ab77294ecb3b3602647f0508eef\"\n dependencies = [\n  \"indexmap\",\n- \"smallvec 1.0.0\",\n-]\n-\n-[[package]]\n-name = \"rustc-ap-syntax\"\n-version = \"642.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e1f59f48ca3a2ec16a7e82e718ed5aadf9c9e08cf63015d28b4e774767524a6a\"\n-dependencies = [\n- \"log\",\n- \"rustc-ap-rustc_data_structures\",\n- \"rustc-ap-rustc_index\",\n- \"rustc-ap-rustc_lexer\",\n- \"rustc-ap-rustc_macros\",\n- \"rustc-ap-rustc_span\",\n- \"rustc-ap-serialize\",\n- \"scoped-tls\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3441,12 +3600,15 @@ dependencies = [\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n- \"crossbeam-utils 0.6.5\",\n+ \"crossbeam-utils 0.7.2\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec 0.6.10\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"syn 0.15.35\",\n+ \"syn 1.0.11\",\n  \"url 2.1.0\",\n  \"winapi 0.3.8\",\n ]\n@@ -3456,13 +3618,14 @@ name = \"rustc_apfloat\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_ast\"\n version = \"0.0.0\"\n dependencies = [\n+ \"bitflags\",\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n@@ -3471,7 +3634,7 @@ dependencies = [\n  \"rustc_span\",\n  \"scoped-tls\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3489,13 +3652,14 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_ast_passes\"\n version = \"0.0.0\"\n dependencies = [\n+ \"itertools 0.8.0\",\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n@@ -3514,8 +3678,8 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"rustc_ast\",\n- \"rustc_data_structures\",\n  \"rustc_span\",\n+ \"rustc_target\",\n ]\n \n [[package]]\n@@ -3531,7 +3695,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"version_check\",\n ]\n \n [[package]]\n@@ -3551,7 +3715,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3563,7 +3727,6 @@ dependencies = [\n  \"libc\",\n  \"log\",\n  \"measureme\",\n- \"rustc\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3576,11 +3739,12 @@ dependencies = [\n  \"rustc_incremental\",\n  \"rustc_index\",\n  \"rustc_llvm\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3594,7 +3758,6 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"num_cpus\",\n- \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3604,7 +3767,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_incremental\",\n  \"rustc_index\",\n- \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n@@ -3619,22 +3782,24 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"cfg-if\",\n- \"crossbeam-utils 0.6.5\",\n- \"ena\",\n+ \"crossbeam-utils 0.7.2\",\n+ \"ena 0.14.0\",\n  \"graphviz\",\n  \"indexmap\",\n  \"jobserver\",\n  \"lazy_static 1.4.0\",\n+ \"libc\",\n  \"log\",\n  \"measureme\",\n- \"parking_lot 0.9.0\",\n+ \"parking_lot 0.10.2\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_index\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n+ \"stacker\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -3644,8 +3809,8 @@ version = \"0.0.0\"\n dependencies = [\n  \"env_logger 0.7.1\",\n  \"lazy_static 1.4.0\",\n+ \"libc\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_codegen_ssa\",\n@@ -3654,9 +3819,11 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_mir\",\n  \"rustc_parse\",\n  \"rustc_plugin_impl\",\n@@ -3705,7 +3872,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3728,15 +3895,24 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"rustc_ast\",\n- \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n- \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_hir_pretty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_ast\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_hir\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n ]\n \n [[package]]\n@@ -3746,11 +3922,11 @@ dependencies = [\n  \"graphviz\",\n  \"log\",\n  \"rand 0.7.3\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n  \"rustc_hir\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serialize\",\n@@ -3761,7 +3937,7 @@ name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3770,26 +3946,27 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.0.0\",\n+ \"serialize\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n+ \"libc\",\n  \"log\",\n  \"once_cell\",\n- \"rustc\",\n  \"rustc-rayon\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n@@ -3803,9 +3980,9 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_incremental\",\n- \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_mir\",\n  \"rustc_mir_build\",\n  \"rustc_parse\",\n@@ -3822,7 +3999,7 @@ dependencies = [\n  \"rustc_ty\",\n  \"rustc_typeck\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"tempfile\",\n  \"winapi 0.3.8\",\n ]\n@@ -3839,7 +4016,6 @@ name = \"rustc_lint\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n@@ -3848,7 +4024,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n- \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3872,33 +4048,65 @@ dependencies = [\n  \"proc-macro2 1.0.3\",\n  \"quote 1.0.2\",\n  \"syn 1.0.11\",\n- \"synstructure 0.12.1\",\n+ \"synstructure\",\n ]\n \n [[package]]\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n  \"flate2\",\n+ \"libc\",\n  \"log\",\n  \"memmap\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_index\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"rustc_middle\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena\",\n+ \"bitflags\",\n+ \"byteorder\",\n+ \"chalk-ir\",\n+ \"log\",\n+ \"measureme\",\n+ \"polonius-engine\",\n+ \"rustc-rayon-core\",\n+ \"rustc_apfloat\",\n+ \"rustc_ast\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_query_system\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"scoped-tls\",\n+ \"serialize\",\n+ \"smallvec 1.4.0\",\n+]\n+\n [[package]]\n name = \"rustc_mir\"\n version = \"0.0.0\"\n@@ -3909,10 +4117,8 @@ dependencies = [\n  \"log\",\n  \"log_settings\",\n  \"polonius-engine\",\n- \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n- \"rustc_ast_pretty\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3921,12 +4127,13 @@ dependencies = [\n  \"rustc_infer\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3935,7 +4142,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n  \"log\",\n- \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3944,13 +4150,13 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n- \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3961,14 +4167,12 @@ dependencies = [\n  \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n- \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.0.0\",\n  \"unicode-normalization\",\n ]\n \n@@ -3977,15 +4181,13 @@ name = \"rustc_passes\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n- \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n- \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3996,12 +4198,12 @@ dependencies = [\n name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n ]\n@@ -4011,12 +4213,11 @@ name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n- \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_typeck\",\n@@ -4026,16 +4227,16 @@ dependencies = [\n name = \"rustc_query_system\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arena\",\n  \"log\",\n- \"parking_lot 0.9.0\",\n- \"rustc_ast\",\n+ \"parking_lot 0.10.2\",\n+ \"rustc-rayon-core\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n- \"rustc_hir\",\n  \"rustc_index\",\n- \"rustc_macros\",\n+ \"rustc_span\",\n  \"serialize\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -4045,7 +4246,6 @@ dependencies = [\n  \"arena\",\n  \"bitflags\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n  \"rustc_ast_pretty\",\n@@ -4056,9 +4256,10 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -4068,11 +4269,12 @@ dependencies = [\n  \"log\",\n  \"rls-data\",\n  \"rls-span\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n+ \"rustc_middle\",\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4083,14 +4285,14 @@ dependencies = [\n name = \"rustc_session\"\n version = \"0.0.0\"\n dependencies = [\n+ \"getopts\",\n  \"log\",\n  \"num_cpus\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n- \"rustc_index\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"serialize\",\n@@ -4103,11 +4305,13 @@ dependencies = [\n  \"arena\",\n  \"cfg-if\",\n  \"log\",\n+ \"md-5\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"scoped-tls\",\n  \"serialize\",\n+ \"sha-1\",\n  \"unicode-width\",\n ]\n \n@@ -4117,12 +4321,11 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"punycode\",\n- \"rustc\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n- \"rustc_metadata\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4157,7 +4360,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -4166,38 +4368,42 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n+ \"chalk-ir\",\n+ \"chalk-rust-ir\",\n+ \"chalk-solve\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_index\",\n  \"rustc_infer\",\n- \"rustc_macros\",\n+ \"rustc_middle\",\n  \"rustc_span\",\n- \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"rustc_ty\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n- \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4210,19 +4416,19 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena\",\n  \"log\",\n- \"rustc\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_infer\",\n+ \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -4240,7 +4446,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"minifier\",\n- \"pulldown-cmark 0.7.0\",\n+ \"pulldown-cmark 0.7.1\",\n  \"rustc-rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -4258,18 +4464,6 @@ dependencies = [\n  \"rustdoc\",\n ]\n \n-[[package]]\n-name = \"rustfix\"\n-version = \"0.4.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7150ac777a2931a53489f5a41eb0937b84e3092a20cd0e73ad436b65b507f607\"\n-dependencies = [\n- \"failure\",\n- \"log\",\n- \"serde\",\n- \"serde_json\",\n-]\n-\n [[package]]\n name = \"rustfix\"\n version = \"0.5.0\"\n@@ -4294,7 +4488,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.12\"\n+version = \"1.4.14\"\n dependencies = [\n  \"annotate-snippets\",\n  \"bytecount\",\n@@ -4310,14 +4504,14 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"regex\",\n+ \"rustc-ap-rustc_ast\",\n  \"rustc-ap-rustc_ast_pretty\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-rustc_errors\",\n+ \"rustc-ap-rustc_expand\",\n  \"rustc-ap-rustc_parse\",\n  \"rustc-ap-rustc_session\",\n  \"rustc-ap-rustc_span\",\n- \"rustc-ap-rustc_target\",\n- \"rustc-ap-syntax\",\n  \"rustc-workspace-hack\",\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n@@ -4421,13 +4615,13 @@ dependencies = [\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.81\"\n+version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"477b13b646f5b5b56fc95bedfc3b550d12141ce84f466f6c44b9a17589923885\"\n+checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n ]\n \n [[package]]\n@@ -4478,19 +4672,19 @@ name = \"serialize\"\n version = \"0.0.0\"\n dependencies = [\n  \"indexmap\",\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n name = \"sha-1\"\n-version = \"0.7.0\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51b9d1f3b5de8a167ab06834a7c883bd197f2191e1dda1a22d9ccfeedbf9aded\"\n+checksum = \"f7d94d0bede923b3cea61f3f1ff57ff8cdfd77b400fb8f9998949e0cf04163df\"\n dependencies = [\n  \"block-buffer\",\n- \"byte-tools\",\n  \"digest\",\n  \"fake-simd\",\n+ \"opaque-debug\",\n ]\n \n [[package]]\n@@ -4523,9 +4717,9 @@ checksum = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n \n [[package]]\n name = \"sized-chunks\"\n-version = \"0.5.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"62db64dd92b3b54314b1e216c274634ca2b3fe8da8b3873be670cb1ac4dad30f\"\n+checksum = \"1ec31ceca5644fa6d444cc77548b88b67f46db6f7c71683b0f9336e671830d2f\"\n dependencies = [\n  \"bitmaps\",\n  \"typenum\",\n@@ -4545,15 +4739,15 @@ checksum = \"ab606a9c5e214920bb66c458cd7be8ef094f813f20fe77a54cc7dbfff220d4b7\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.0.0\"\n+version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4ecf3b85f68e8abaa7555aa5abdb1153079387e60b718283d732f03897fcfc86\"\n+checksum = \"c7cb5678e1615754284ec264d9bb5b4c27d2018577fd90ac0ceb578591ed5ee4\"\n \n [[package]]\n name = \"socket2\"\n-version = \"0.3.11\"\n+version = \"0.3.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e8b74de517221a2cb01a53349cf54182acdc31a074727d3079068448c0676d85\"\n+checksum = \"03088793f677dce356f3ccc2edb1b314ad191ab702a5de3faf49304f7e104918\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -4567,6 +4761,19 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ffbc596e092fe5f598b12ef46cc03754085ac2f4d8c739ad61c4ae266cc3b3fa\"\n \n+[[package]]\n+name = \"stacker\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"72dd941b456e1c006d6b9f27c526d5b69281288aeea8cba82c19d3843d8ccdd2\"\n+dependencies = [\n+ \"cc\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"psm\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"std\"\n version = \"0.0.0\"\n@@ -4578,7 +4785,7 @@ dependencies = [\n  \"core\",\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n- \"hashbrown 0.6.2\",\n+ \"hashbrown\",\n  \"hermit-abi\",\n  \"libc\",\n  \"panic_abort\",\n@@ -4710,18 +4917,6 @@ dependencies = [\n  \"unicode-xid 0.2.0\",\n ]\n \n-[[package]]\n-name = \"synstructure\"\n-version = \"0.10.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n- \"unicode-xid 0.1.0\",\n-]\n-\n [[package]]\n name = \"synstructure\"\n version = \"0.12.1\"\n@@ -4854,6 +5049,26 @@ dependencies = [\n  \"unicode-width\",\n ]\n \n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f9fb62ff737e573b1e677459bea6fd023cd5d6e868c3242d3cdf3ef2f0554824\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24069c0ba08aab54289d6a25f5036d94afc61e1538bbc42ae5501df141c9027d\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.11\",\n+]\n+\n [[package]]\n name = \"thread_local\"\n version = \"0.3.6\"\n@@ -5196,9 +5411,9 @@ dependencies = [\n \n [[package]]\n name = \"typenum\"\n-version = \"1.10.0\"\n+version = \"1.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"612d636f949607bdf9b123b4a6f6d966dedf3ff669f7f045890d3a4a73948169\"\n+checksum = \"373c8a200f9e67a0c95e62a4f52fbf80c23b4381c05a17845531982fa99e6b33\"\n \n [[package]]\n name = \"ucd-parse\"\n@@ -5249,11 +5464,11 @@ dependencies = [\n \n [[package]]\n name = \"unicode-normalization\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b561e267b2326bb4cebfc0ef9e68355c7abe6c6f522aeac2f5bf95d56c59bdcf\"\n+checksum = \"5479532badd04e128284890390c1e876ef7a993d0570b3597ae43dfa1d59afa4\"\n dependencies = [\n- \"smallvec 1.0.0\",\n+ \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -5264,10 +5479,11 @@ checksum = \"5b2c5c29e805da6817f5af6a627d65adb045cebf05cccd5a3493d6109454391c\"\n \n [[package]]\n name = \"unicode-security\"\n-version = \"0.0.2\"\n+version = \"0.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c49d35967fa037b881acc34ef717c38c4b5560eba10e3685271b3f530bb19634\"\n+checksum = \"a5f9011bbed9c13372bc8df618b55a38138445199caf3b61d432c6859c36dee0\"\n dependencies = [\n+ \"unicode-normalization\",\n  \"unicode-script\",\n ]\n \n@@ -5536,8 +5752,28 @@ dependencies = [\n  \"lzma-sys\",\n ]\n \n+[[package]]\n+name = \"yaml-merge-keys\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"59893318ba3ad2b704498c7761214a10eaf42c5f838bce9fc0145bf2ba658cfa\"\n+dependencies = [\n+ \"lazy_static 1.4.0\",\n+ \"thiserror\",\n+ \"yaml-rust 0.4.3\",\n+]\n+\n [[package]]\n name = \"yaml-rust\"\n version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e66366e18dc58b46801afbf2ca7661a9f59cc8c5962c29892b6039b4f86fa992\"\n+\n+[[package]]\n+name = \"yaml-rust\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"65923dd1784f44da1d2c3dbbc5e822045628c590ba72123e1c73d3c230c4434d\"\n+dependencies = [\n+ \"linked-hash-map\",\n+]"}, {"sha": "7b5e0fa1c281787b2d2cff8aa6dd737fab06c228", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -24,6 +24,7 @@ members = [\n   \"src/tools/miri\",\n   \"src/tools/rustdoc-themes\",\n   \"src/tools/unicode-table-generator\",\n+  \"src/tools/expand-yaml-anchors\",\n ]\n exclude = [\n   \"build\","}, {"sha": "00bb501941dd76c5845cd04476c405801855d7fe", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -27,7 +27,7 @@ or reading the [rustc dev guide][rustcguidebuild].\n 1. Make sure you have installed the dependencies:\n \n    * `g++` 5.1 or later or `clang++` 3.5 or later\n-   * `python` 2.7 (but not 3.x)\n+   * `python` 3 or 2.7\n    * GNU `make` 3.81 or later\n    * `cmake` 3.4.3 or later\n    * `curl`\n@@ -113,7 +113,7 @@ build.\n                make \\\n                diffutils \\\n                tar \\\n-               mingw-w64-x86_64-python2 \\\n+               mingw-w64-x86_64-python \\\n                mingw-w64-x86_64-cmake \\\n                mingw-w64-x86_64-gcc\n    ```\n@@ -256,7 +256,7 @@ Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n \n [rust-discord]: https://discord.gg/rust-lang\n [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n+[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n \n ## License\n "}, {"sha": "8ea481f7e18cdc78714aaba8d13dbe4ef4aa6b30", "filename": "RELEASES.md", "status": "modified", "additions": 163, "deletions": 2, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,164 @@\n+Version 1.43.1 (2020-05-07)\n+===========================\n+\n+* [Updated openssl-src to 1.1.1g for CVE-2020-1967.][71430]\n+* [Fixed the stabilization of AVX-512 features.][71473]\n+* [Fixed `cargo package --list` not working with unpublished dependencies.][cargo/8151]\n+\n+[71430]: https://github.com/rust-lang/rust/pull/71430\n+[71473]: https://github.com/rust-lang/rust/issues/71473\n+[cargo/8151]: https://github.com/rust-lang/cargo/issues/8151\n+\n+\n+Version 1.43.0 (2020-04-23)\n+==========================\n+\n+Language\n+--------\n+- [Fixed using binary operations with `&{number}` (e.g. `&1.0`) not having\n+  the type inferred correctly.][68129]\n+- [Attributes such as `#[cfg()]` can now be used on `if` expressions.][69201]\n+\n+**Syntax only changes**\n+- [Allow `type Foo: Ord` syntactically.][69361]\n+- [Fuse associated and extern items up to defaultness.][69194]\n+- [Syntactically allow `self` in all `fn` contexts.][68764]\n+- [Merge `fn` syntax + cleanup item parsing.][68728]\n+- [`item` macro fragments can be interpolated into `trait`s, `impl`s, and `extern` blocks.][69366]\n+  For example, you may now write:\n+  ```rust\n+  macro_rules! mac_trait {\n+      ($i:item) => {\n+          trait T { $i }\n+      }\n+  }\n+  mac_trait! {\n+      fn foo() {}\n+  }\n+  ```\n+\n+These are still rejected *semantically*, so you will likely receive an error but\n+these changes can be seen and parsed by macros and\n+conditional compilation.\n+\n+\n+Compiler\n+--------\n+- [You can now pass multiple lint flags to rustc to override the previous\n+  flags.][67885] For example; `rustc -D unused -A unused-variables` denies\n+  everything in the `unused` lint group except `unused-variables` which\n+  is explicitly allowed. However, passing `rustc -A unused-variables -D unused` denies\n+  everything in the `unused` lint group **including** `unused-variables` since\n+  the allow flag is specified before the deny flag (and therefore overridden).\n+- [rustc will now prefer your system MinGW libraries over its bundled libraries\n+  if they are available on `windows-gnu`.][67429]\n+- [rustc now buffers errors/warnings printed in JSON.][69227]\n+\n+Libraries\n+---------\n+- [`Arc<[T; N]>`, `Box<[T; N]>`, and `Rc<[T; N]>`, now implement\n+  `TryFrom<Arc<[T]>>`,`TryFrom<Box<[T]>>`, and `TryFrom<Rc<[T]>>`\n+  respectively.][69538] **Note** These conversions are only available when `N`\n+  is `0..=32`.\n+- [You can now use associated constants on floats and integers directly, rather\n+  than having to import the module.][68952] e.g. You can now write `u32::MAX` or\n+  `f32::NAN` with no imports.\n+- [`u8::is_ascii` is now `const`.][68984]\n+- [`String` now implements `AsMut<str>`.][68742]\n+- [Added the `primitive` module to `std` and `core`.][67637] This module\n+  reexports Rust's primitive types. This is mainly useful in macros\n+  where you want avoid these types being shadowed.\n+- [Relaxed some of the trait bounds on `HashMap` and `HashSet`.][67642]\n+- [`string::FromUtf8Error` now implements `Clone + Eq`.][68738]\n+\n+Stabilized APIs\n+---------------\n+- [`Once::is_completed`]\n+- [`f32::LOG10_2`]\n+- [`f32::LOG2_10`]\n+- [`f64::LOG10_2`]\n+- [`f64::LOG2_10`]\n+- [`iter::once_with`]\n+\n+Cargo\n+-----\n+- [You can now set config `[profile]`s in your `.cargo/config`, or through\n+  your environment.][cargo/7823]\n+- [Cargo will now set `CARGO_BIN_EXE_<name>` pointing to a binary's\n+  executable path when running integration tests or benchmarks.][cargo/7697]\n+  `<name>` is the name of your binary as-is e.g. If you wanted the executable\n+  path for a binary named `my-program`you would use `env!(\"CARGO_BIN_EXE_my-program\")`.\n+\n+Misc\n+----\n+- [Certain checks in the `const_err` lint were deemed unrelated to const\n+  evaluation][69185], and have been moved to the `unconditional_panic` and\n+  `arithmetic_overflow` lints.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Having trailing syntax in the `assert!` macro is now a hard error.][69548] This\n+  has been a warning since 1.36.0.\n+- [Fixed `Self` not having the correctly inferred type.][69340] This incorrectly\n+  led to some instances being accepted, and now correctly emits a hard error.\n+\n+[69340]: https://github.com/rust-lang/rust/pull/69340\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of `rustc` and\n+related tools.\n+\n+- [All components are now built with `opt-level=3` instead of `2`.][67878]\n+- [Improved how rustc generates drop code.][67332]\n+- [Improved performance from `#[inline]`-ing certain hot functions.][69256]\n+- [traits: preallocate 2 Vecs of known initial size][69022]\n+- [Avoid exponential behaviour when relating types][68772]\n+- [Skip `Drop` terminators for enum variants without drop glue][68943]\n+- [Improve performance of coherence checks][68966]\n+- [Deduplicate types in the generator witness][68672]\n+- [Invert control in struct_lint_level.][68725]\n+\n+[67332]: https://github.com/rust-lang/rust/pull/67332/\n+[67429]: https://github.com/rust-lang/rust/pull/67429/\n+[67637]: https://github.com/rust-lang/rust/pull/67637/\n+[67642]: https://github.com/rust-lang/rust/pull/67642/\n+[67878]: https://github.com/rust-lang/rust/pull/67878/\n+[67885]: https://github.com/rust-lang/rust/pull/67885/\n+[68129]: https://github.com/rust-lang/rust/pull/68129/\n+[68672]: https://github.com/rust-lang/rust/pull/68672/\n+[68725]: https://github.com/rust-lang/rust/pull/68725/\n+[68728]: https://github.com/rust-lang/rust/pull/68728/\n+[68738]: https://github.com/rust-lang/rust/pull/68738/\n+[68742]: https://github.com/rust-lang/rust/pull/68742/\n+[68764]: https://github.com/rust-lang/rust/pull/68764/\n+[68772]: https://github.com/rust-lang/rust/pull/68772/\n+[68943]: https://github.com/rust-lang/rust/pull/68943/\n+[68952]: https://github.com/rust-lang/rust/pull/68952/\n+[68966]: https://github.com/rust-lang/rust/pull/68966/\n+[68984]: https://github.com/rust-lang/rust/pull/68984/\n+[69022]: https://github.com/rust-lang/rust/pull/69022/\n+[69185]: https://github.com/rust-lang/rust/pull/69185/\n+[69194]: https://github.com/rust-lang/rust/pull/69194/\n+[69201]: https://github.com/rust-lang/rust/pull/69201/\n+[69227]: https://github.com/rust-lang/rust/pull/69227/\n+[69548]: https://github.com/rust-lang/rust/pull/69548/\n+[69256]: https://github.com/rust-lang/rust/pull/69256/\n+[69361]: https://github.com/rust-lang/rust/pull/69361/\n+[69366]: https://github.com/rust-lang/rust/pull/69366/\n+[69538]: https://github.com/rust-lang/rust/pull/69538/\n+[cargo/7823]: https://github.com/rust-lang/cargo/pull/7823\n+[cargo/7697]: https://github.com/rust-lang/cargo/pull/7697\n+[`Once::is_completed`]: https://doc.rust-lang.org/std/sync/struct.Once.html#method.is_completed\n+[`f32::LOG10_2`]: https://doc.rust-lang.org/std/f32/consts/constant.LOG10_2.html\n+[`f32::LOG2_10`]: https://doc.rust-lang.org/std/f32/consts/constant.LOG2_10.html\n+[`f64::LOG10_2`]: https://doc.rust-lang.org/std/f64/consts/constant.LOG10_2.html\n+[`f64::LOG2_10`]: https://doc.rust-lang.org/std/f64/consts/constant.LOG2_10.html\n+[`iter::once_with`]: https://doc.rust-lang.org/std/iter/fn.once_with.html\n+\n+\n Version 1.42.0 (2020-03-12)\n ==========================\n \n@@ -24,7 +185,7 @@ Language\n      (e.g. `type Foo: Ord;`).\n    - `...` (the C-variadic type) may occur syntactically directly as the type of\n       any function parameter.\n-  \n+\n   These are still rejected *semantically*, so you will likely receive an error\n   but these changes can be seen and parsed by procedural macros and\n   conditional compilation.\n@@ -316,7 +477,7 @@ Compatibility Notes\n - [Using `#[inline]` on function prototypes and consts now emits a warning under\n   `unused_attribute` lint.][65294] Using `#[inline]` anywhere else inside traits\n   or `extern` blocks now correctly emits a hard error.\n-  \n+\n [65294]: https://github.com/rust-lang/rust/pull/65294/\n [66103]: https://github.com/rust-lang/rust/pull/66103/\n [65843]: https://github.com/rust-lang/rust/pull/65843/"}, {"sha": "ffe907c9da97c97e7b046346de54c1c26ac70f40", "filename": "config.toml.example", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -84,8 +84,9 @@\n #link-shared = false\n \n # When building llvm, this configures what is being appended to the version.\n-# If absent, we let the version as-is.\n-#version-suffix = \"-rust\"\n+# The default is \"-rust-$version-$channel\", except for dev channel where rustc\n+# version number is omitted. To use LLVM version as is, provide an empty string.\n+#version-suffix = \"-rust-dev\"\n \n # On MSVC you can compile LLVM with clang-cl, but the test suite doesn't pass\n # with clang-cl, so this is special in that it only compiles LLVM with clang-cl\n@@ -130,6 +131,10 @@\n # for each target triple.\n #target = [\"x86_64-unknown-linux-gnu\"] # defaults to just the build triple\n \n+# Use this directory to store build artifacts.\n+# You can use \"$ROOT\" to indicate the root of the git repository.\n+#build-dir = \"build\"\n+\n # Instead of downloading the src/stage0.txt version of Cargo specified, use\n # this Cargo binary instead to build all Rust code\n #cargo = \"/path/to/bin/cargo\"\n@@ -168,11 +173,9 @@\n \n # Python interpreter to use for various tasks throughout the build, notably\n # rustdoc tests, the lldb python interpreter, and some dist bits and pieces.\n-# Note that Python 2 is currently required.\n #\n-# Defaults to python2.7, then python2. If neither executable can be found, then\n-# it defaults to the Python interpreter used to execute x.py.\n-#python = \"python2.7\"\n+# Defaults to the Python interpreter used to execute x.py.\n+#python = \"python\"\n \n # Force Cargo to check that Cargo.lock describes the precise dependency\n # set that all the Cargo.toml files create, instead of updating it.\n@@ -311,6 +314,10 @@\n # library.\n #debug-assertions = false\n \n+# Whether or not debug assertions are enabled for the standard library.\n+# Overrides the `debug-assertions` option, if defined.\n+#debug-assertions-std = false\n+\n # Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n # `0` - no debug info\n # `1` - line tables only\n@@ -408,10 +415,6 @@\n # sysroot.\n #llvm-tools = false\n \n-# Indicates whether LLDB will be made available in the sysroot.\n-# This is only built if LLVM is also being built.\n-#lldb = false\n-\n # Whether to deny warnings in crates\n #deny-warnings = true\n "}, {"sha": "81e2001e4a583ef1f117a46593acd1705995ed85", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/configure", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -11,6 +11,7 @@ try() {\n     fi\n }\n \n+try python3 \"$@\"\n try python2.7 \"$@\"\n try python27 \"$@\"\n try python2 \"$@\""}, {"sha": "9b2c08200362effffe481cc9b8afc1a12e925428", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -20,7 +20,7 @@ ignore = [\n     \"src/doc/nomicon\",\n     \"src/doc/reference\",\n     \"src/doc/rust-by-example\",\n-    \"src/doc/rustc-guide\",\n+    \"src/doc/rustc-dev-guide\",\n     \"src/llvm-project\",\n     \"src/stdarch\",\n     \"src/tools/cargo\","}, {"sha": "f7856f6a7fcb1a1aff7fda031eda5cb07ce361c3", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -54,4 +54,4 @@ version = \"0.3\"\n features = [\"fileapi\", \"ioapiset\", \"jobapi2\", \"handleapi\", \"winioctl\"]\n \n [dev-dependencies]\n-pretty_assertions = \"0.5\"\n+pretty_assertions = \"0.6\""}, {"sha": "89984bb55dfd82380ade435c25e362176592a593", "filename": "src/bootstrap/bin/llvm-config-wrapper.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -10,7 +10,14 @@ fn main() {\n     let mut cmd = Command::new(real_llvm_config);\n     cmd.args(env::args().skip(1)).stderr(Stdio::piped());\n     let output = cmd.output().expect(\"failed to spawn llvm-config\");\n-    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let mut stdout = String::from_utf8_lossy(&output.stdout);\n+\n+    if let Ok(to_replace) = env::var(\"LLVM_CONFIG_SHIM_REPLACE\") {\n+        if let Ok(replace_with) = env::var(\"LLVM_CONFIG_SHIM_REPLACE_WITH\") {\n+            stdout = stdout.replace(&to_replace, &replace_with).into();\n+        }\n+    }\n+\n     print!(\"{}\", stdout.replace(\"\\\\\", \"/\"));\n     io::stdout().flush().unwrap();\n     process::exit(output.status.code().unwrap_or(1));"}, {"sha": "a8c00c8c3ca88368764e4d5cb22068f9057671fc", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -134,11 +134,6 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", host_linker));\n         }\n \n-        // Override linker flavor if necessary.\n-        if let Ok(host_linker_flavor) = env::var(\"RUSTC_HOST_LINKER_FLAVOR\") {\n-            cmd.arg(format!(\"-Clinker-flavor={}\", host_linker_flavor));\n-        }\n-\n         if let Ok(s) = env::var(\"RUSTC_HOST_CRT_STATIC\") {\n             if s == \"true\" {\n                 cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");"}, {"sha": "b7d0fac5be31fdca554d690289ce8756c0df6fac", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -2,6 +2,7 @@\n import argparse\n import contextlib\n import datetime\n+import distutils.version\n import hashlib\n import os\n import re\n@@ -78,6 +79,7 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-#\"\n         else:\n             option = \"-s\"\n+        require([\"curl\", \"--version\"])\n         run([\"curl\", option,\n              \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n              \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n@@ -142,6 +144,21 @@ def run(args, verbose=False, exception=False, **kwargs):\n         sys.exit(err)\n \n \n+def require(cmd, exit=True):\n+    '''Run a command, returning its output.\n+    On error,\n+        If `exit` is `True`, exit the process.\n+        Otherwise, return None.'''\n+    try:\n+        return subprocess.check_output(cmd).strip()\n+    except (subprocess.CalledProcessError, OSError) as exc:\n+        if not exit:\n+            return None\n+        print(\"error: unable to run `{}`: {}\".format(' '.join(cmd), exc))\n+        print(\"Please make sure it's installed and in the path.\")\n+        sys.exit(1)\n+\n+\n def stage0_data(rust_root):\n     \"\"\"Build a dictionary from stage0.txt\"\"\"\n     nightlies = os.path.join(rust_root, \"src/stage0.txt\")\n@@ -163,16 +180,15 @@ def format_build_time(duration):\n def default_build_triple():\n     \"\"\"Build triple as in LLVM\"\"\"\n     default_encoding = sys.getdefaultencoding()\n-    try:\n-        ostype = subprocess.check_output(\n-            ['uname', '-s']).strip().decode(default_encoding)\n-        cputype = subprocess.check_output(\n-            ['uname', '-m']).strip().decode(default_encoding)\n-    except (subprocess.CalledProcessError, OSError):\n-        if sys.platform == 'win32':\n-            return 'x86_64-pc-windows-msvc'\n-        err = \"uname not found\"\n-        sys.exit(err)\n+    required = sys.platform != 'win32'\n+    ostype = require([\"uname\", \"-s\"], exit=required)\n+    cputype = require(['uname', '-m'], exit=required)\n+\n+    if ostype is None or cputype is None:\n+        return 'x86_64-pc-windows-msvc'\n+\n+    ostype = ostype.decode(default_encoding)\n+    cputype = cputype.decode(default_encoding)\n \n     # The goal here is to come up with the same triple as LLVM would,\n     # at least for the subset of platforms we're willing to target.\n@@ -202,12 +218,7 @@ def default_build_triple():\n         # output from that option is too generic for our purposes (it will\n         # always emit 'i386' on x86/amd64 systems).  As such, isainfo -k\n         # must be used instead.\n-        try:\n-            cputype = subprocess.check_output(\n-                ['isainfo', '-k']).strip().decode(default_encoding)\n-        except (subprocess.CalledProcessError, OSError):\n-            err = \"isainfo not found\"\n-            sys.exit(err)\n+        cputype = require(['isainfo', '-k']).decode(default_encoding)\n     elif ostype.startswith('MINGW'):\n         # msys' `uname` does not print gcc configuration, but prints msys\n         # configuration. so we cannot believe `uname -m`:\n@@ -324,13 +335,14 @@ def __init__(self):\n         self.rustc_channel = ''\n         self.rustfmt_channel = ''\n         self.build = ''\n-        self.build_dir = os.path.join(os.getcwd(), \"build\")\n+        self.build_dir = ''\n         self.clean = False\n         self.config_toml = ''\n         self.rust_root = ''\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n+        self.git_version = None\n \n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -743,15 +755,13 @@ def update_submodule(self, module, checked_out, recorded_submodules):\n \n         run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n             cwd=self.rust_root, verbose=self.verbose)\n-        try:\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", \"--progress\", module],\n-                cwd=self.rust_root, verbose=self.verbose, exception=True)\n-        except RuntimeError:\n-            # Some versions of git don't support --progress.\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", module],\n-                cwd=self.rust_root, verbose=self.verbose)\n+\n+        update_args = [\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"]\n+        if self.git_version >= distutils.version.LooseVersion(\"2.11.0\"):\n+            update_args.append(\"--progress\")\n+        update_args.append(module)\n+        run(update_args, cwd=self.rust_root, verbose=self.verbose, exception=True)\n+\n         run([\"git\", \"reset\", \"-q\", \"--hard\"],\n             cwd=module_path, verbose=self.verbose)\n         run([\"git\", \"clean\", \"-qdfx\"],\n@@ -763,12 +773,11 @@ def update_submodules(self):\n                 self.get_toml('submodules') == \"false\":\n             return\n \n-        # check the existence of 'git' command\n-        try:\n-            subprocess.check_output(['git', '--version'])\n-        except (subprocess.CalledProcessError, OSError):\n-            print(\"error: `git` is not found, please make sure it's installed and in the path.\")\n-            sys.exit(1)\n+        default_encoding = sys.getdefaultencoding()\n+\n+        # check the existence and version of 'git' command\n+        git_version_str = require(['git', '--version']).split()[2].decode(default_encoding)\n+        self.git_version = distutils.version.LooseVersion(git_version_str)\n \n         slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n@@ -885,7 +894,11 @@ def bootstrap(help_triggered):\n     build.clean = args.clean\n \n     try:\n-        with open(args.config or 'config.toml') as config:\n+        toml_path = args.config or 'config.toml'\n+        if not os.path.exists(toml_path):\n+            toml_path = os.path.join(build.rust_root, toml_path)\n+\n+        with open(toml_path) as config:\n             build.config_toml = config.read()\n     except (OSError, IOError):\n         pass\n@@ -900,6 +913,9 @@ def bootstrap(help_triggered):\n \n     build.check_vendored_status()\n \n+    build_dir = build.get_toml('build-dir', 'build') or 'build'\n+    build.build_dir = os.path.abspath(build_dir.replace(\"$ROOT\", build.rust_root))\n+\n     data = stage0_data(build.rust_root)\n     build.date = data['date']\n     build.rustc_channel = data['rustc']"}, {"sha": "4bc81a7b42dc00089a95cc6e715604ecc93453cf", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 55, "deletions": 27, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -21,6 +21,7 @@ use crate::doc;\n use crate::flags::Subcommand;\n use crate::install;\n use crate::native;\n+use crate::run;\n use crate::test;\n use crate::tool;\n use crate::util::{self, add_dylib_path, add_link_lib_path, exe, libdir};\n@@ -313,6 +314,7 @@ pub enum Kind {\n     Dist,\n     Doc,\n     Install,\n+    Run,\n }\n \n impl<'a> Builder<'a> {\n@@ -349,14 +351,14 @@ impl<'a> Builder<'a> {\n                 native::Lld\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => {\n-                describe!(check::Std, check::Rustc, check::Rustdoc)\n+                describe!(check::Std, check::Rustc, check::Rustdoc, check::Clippy)\n             }\n             Kind::Test => describe!(\n                 crate::toolstate::ToolStateCheck,\n+                test::ExpandYamlAnchors,\n                 test::Tidy,\n                 test::Ui,\n                 test::CompileFail,\n-                test::RunFail,\n                 test::RunPassValgrind,\n                 test::MirOpt,\n                 test::Codegen,\n@@ -367,7 +369,6 @@ impl<'a> Builder<'a> {\n                 test::UiFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunFailPretty,\n                 test::RunPassValgrindPretty,\n                 test::Crate,\n                 test::CrateLibrustc,\n@@ -438,7 +439,6 @@ impl<'a> Builder<'a> {\n                 dist::Clippy,\n                 dist::Miri,\n                 dist::LlvmTools,\n-                dist::Lldb,\n                 dist::Extended,\n                 dist::HashSign\n             ),\n@@ -454,6 +454,7 @@ impl<'a> Builder<'a> {\n                 install::Src,\n                 install::Rustc\n             ),\n+            Kind::Run => describe!(run::ExpandYamlAnchors,),\n         }\n     }\n \n@@ -507,6 +508,7 @@ impl<'a> Builder<'a> {\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n             Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n             Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n+            Subcommand::Run { ref paths } => (Kind::Run, &paths[..]),\n             Subcommand::Format { .. } | Subcommand::Clean { .. } => panic!(),\n         };\n \n@@ -760,9 +762,17 @@ impl<'a> Builder<'a> {\n         }\n \n         // Set a flag for `check`/`clippy`/`fix`, so that certain build\n-        // scripts can do less work (e.g. not building/requiring LLVM).\n+        // scripts can do less work (i.e. not building/requiring LLVM).\n         if cmd == \"check\" || cmd == \"clippy\" || cmd == \"fix\" {\n-            cargo.env(\"RUST_CHECK\", \"1\");\n+            // If we've not yet built LLVM, or it's stale, then bust\n+            // the librustc_llvm cache. That will always work, even though it\n+            // may mean that on the next non-check build we'll need to rebuild\n+            // librustc_llvm. But if LLVM is stale, that'll be a tiny amount\n+            // of work comparitively, and we'd likely need to rebuild it anyway,\n+            // so that's okay.\n+            if crate::native::prebuilt_llvm_config(self, target).is_err() {\n+                cargo.env(\"RUST_CHECK\", \"1\");\n+            }\n         }\n \n         let stage = if compiler.stage == 0 && self.local_rebuild {\n@@ -786,6 +796,11 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"--cfg=bootstrap\");\n         }\n \n+        // FIXME: It might be better to use the same value for both `RUSTFLAGS` and `RUSTDOCFLAGS`,\n+        // but this breaks CI. At the very least, stage0 `rustdoc` needs `--cfg bootstrap`. See\n+        // #71458.\n+        let rustdocflags = rustflags.clone();\n+\n         if let Ok(s) = env::var(\"CARGOFLAGS\") {\n             cargo.args(s.split_whitespace());\n         }\n@@ -900,7 +915,14 @@ impl<'a> Builder<'a> {\n             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n             .env(\"RUSTC_REAL\", self.rustc(compiler))\n             .env(\"RUSTC_STAGE\", stage.to_string())\n-            .env(\"RUSTC_DEBUG_ASSERTIONS\", self.config.rust_debug_assertions.to_string())\n+            .env(\n+                \"RUSTC_DEBUG_ASSERTIONS\",\n+                if mode == Mode::Std {\n+                    self.config.rust_debug_assertions_std.to_string()\n+                } else {\n+                    self.config.rust_debug_assertions.to_string()\n+                },\n+            )\n             .env(\"RUSTC_SYSROOT\", &sysroot)\n             .env(\"RUSTC_LIBDIR\", &libdir)\n             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n@@ -964,27 +986,11 @@ impl<'a> Builder<'a> {\n         // See https://github.com/rust-lang/rust/issues/68647.\n         let can_use_lld = mode != Mode::Std;\n \n-        // FIXME: The beta compiler doesn't pick the `lld-link` flavor for `*-pc-windows-msvc`\n-        // Remove `RUSTC_HOST_LINKER_FLAVOR` when this is fixed\n-        let lld_linker_flavor = |linker: &Path, target: Interned<String>| {\n-            compiler.stage == 0\n-                && linker.file_name() == Some(OsStr::new(\"rust-lld\"))\n-                && target.contains(\"pc-windows-msvc\")\n-        };\n-\n         if let Some(host_linker) = self.linker(compiler.host, can_use_lld) {\n-            if lld_linker_flavor(host_linker, compiler.host) {\n-                cargo.env(\"RUSTC_HOST_LINKER_FLAVOR\", \"lld-link\");\n-            }\n-\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n \n         if let Some(target_linker) = self.linker(target, can_use_lld) {\n-            if lld_linker_flavor(target_linker, target) {\n-                rustflags.arg(\"-Clinker-flavor=lld-link\");\n-            }\n-\n             let target = crate::envify(&target);\n             cargo.env(&format!(\"CARGO_TARGET_{}_LINKER\", target), target_linker);\n         }\n@@ -1017,8 +1023,13 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_HOST_CRT_STATIC\", x.to_string());\n         }\n \n-        if let Some(map) = self.build.debuginfo_map(GitRepo::Rustc) {\n+        if let Some(map_to) = self.build.debuginfo_map_to(GitRepo::Rustc) {\n+            let map = format!(\"{}={}\", self.build.src.display(), map_to);\n             cargo.env(\"RUSTC_DEBUGINFO_MAP\", map);\n+\n+            // `rustc` needs to know the virtual `/rustc/$hash` we're mapping to,\n+            // in order to opportunistically reverse it later.\n+            cargo.env(\"CFG_VIRTUAL_RUST_SOURCE_BASE_DIR\", map_to);\n         }\n \n         // Enable usage of unstable features\n@@ -1090,6 +1101,13 @@ impl<'a> Builder<'a> {\n             if self.config.deny_warnings {\n                 rustflags.arg(\"-Dwarnings\");\n             }\n+\n+            // FIXME(#58633) hide \"unused attribute\" errors in incremental\n+            // builds of the standard library, as the underlying checks are\n+            // not yet properly integrated with incremental recompilation.\n+            if mode == Mode::Std && compiler.stage == 0 && self.config.incremental {\n+                rustflags.arg(\"-Aunused-attributes\");\n+            }\n         }\n \n         if let Mode::Rustc | Mode::Codegen = mode {\n@@ -1268,7 +1286,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        Cargo { command: cargo, rustflags }\n+        Cargo { command: cargo, rustflags, rustdocflags }\n     }\n \n     /// Ensure that a given step is built, returning its output. This will\n@@ -1326,7 +1344,7 @@ impl<'a> Builder<'a> {\n #[cfg(test)]\n mod tests;\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n struct Rustflags(String);\n \n impl Rustflags {\n@@ -1366,6 +1384,7 @@ impl Rustflags {\n pub struct Cargo {\n     command: Command,\n     rustflags: Rustflags,\n+    rustdocflags: Rustflags,\n }\n \n impl Cargo {\n@@ -1398,7 +1417,16 @@ impl Cargo {\n \n impl From<Cargo> for Command {\n     fn from(mut cargo: Cargo) -> Command {\n-        cargo.command.env(\"RUSTFLAGS\", &cargo.rustflags.0);\n+        let rustflags = &cargo.rustflags.0;\n+        if !rustflags.is_empty() {\n+            cargo.command.env(\"RUSTFLAGS\", rustflags);\n+        }\n+\n+        let rustdocflags = &cargo.rustdocflags.0;\n+        if !rustdocflags.is_empty() {\n+            cargo.command.env(\"RUSTDOCFLAGS\", rustdocflags);\n+        }\n+\n         cargo.command\n     }\n }"}, {"sha": "f9d3b454246b11a4a6918c783fc949cf7b8fb5dd", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.44.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.45.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "7a8bfb2d5d877190661a8a83973a679e3e94709c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -45,7 +45,7 @@ impl Step for Std {\n         let compiler = builder.compiler(0, builder.config.build);\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, cargo_subcommand(builder.kind));\n-        std_cargo(builder, target, &mut cargo);\n+        std_cargo(builder, target, compiler.stage, &mut cargo);\n \n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(\n@@ -112,83 +112,89 @@ impl Step for Rustc {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n-    pub target: Interned<String>,\n+macro_rules! tool_check_step {\n+    ($name:ident, $path:expr) => {\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            pub target: Interned<String>,\n+        }\n+\n+        impl Step for $name {\n+            type Output = ();\n+            const ONLY_HOSTS: bool = true;\n+            const DEFAULT: bool = true;\n+\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+                run.path($path)\n+            }\n+\n+            fn make_run(run: RunConfig<'_>) {\n+                run.builder.ensure($name { target: run.target });\n+            }\n+\n+            fn run(self, builder: &Builder<'_>) {\n+                let compiler = builder.compiler(0, builder.config.build);\n+                let target = self.target;\n+\n+                builder.ensure(Rustc { target });\n+\n+                let cargo = prepare_tool_cargo(\n+                    builder,\n+                    compiler,\n+                    Mode::ToolRustc,\n+                    target,\n+                    cargo_subcommand(builder.kind),\n+                    $path,\n+                    SourceType::InTree,\n+                    &[],\n+                );\n+\n+                println!(\n+                    \"Checking {} artifacts ({} -> {})\",\n+                    stringify!($name).to_lowercase(),\n+                    &compiler.host,\n+                    target\n+                );\n+                run_cargo(\n+                    builder,\n+                    cargo,\n+                    args(builder.kind),\n+                    &stamp(builder, compiler, target),\n+                    vec![],\n+                    true,\n+                );\n+\n+                let libdir = builder.sysroot_libdir(compiler, target);\n+                let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+                add_to_sysroot(&builder, &libdir, &hostdir, &stamp(builder, compiler, target));\n+\n+                /// Cargo's output path in a given stage, compiled by a particular\n+                /// compiler for the specified target.\n+                fn stamp(\n+                    builder: &Builder<'_>,\n+                    compiler: Compiler,\n+                    target: Interned<String>,\n+                ) -> PathBuf {\n+                    builder\n+                        .cargo_out(compiler, Mode::ToolRustc, target)\n+                        .join(format!(\".{}-check.stamp\", stringify!($name).to_lowercase()))\n+                }\n+            }\n+        }\n+    };\n }\n \n-impl Step for Rustdoc {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/tools/rustdoc\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Rustdoc { target: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n-        let target = self.target;\n-\n-        builder.ensure(Rustc { target });\n-\n-        let cargo = prepare_tool_cargo(\n-            builder,\n-            compiler,\n-            Mode::ToolRustc,\n-            target,\n-            cargo_subcommand(builder.kind),\n-            \"src/tools/rustdoc\",\n-            SourceType::InTree,\n-            &[],\n-        );\n-\n-        println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n-        run_cargo(\n-            builder,\n-            cargo,\n-            args(builder.kind),\n-            &rustdoc_stamp(builder, compiler, target),\n-            vec![],\n-            true,\n-        );\n-\n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n-    }\n-}\n+tool_check_step!(Rustdoc, \"src/tools/rustdoc\");\n+tool_check_step!(Clippy, \"src/tools/clippy\");\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n+fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n-\n-/// Cargo's output path for rustdoc in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn rustdoc_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::ToolRustc, target).join(\".rustdoc-check.stamp\")\n-}"}, {"sha": "c56114f14caa9744da7b48530ca0a49ac687121a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -22,7 +22,7 @@ use serde::Deserialize;\n use crate::builder::Cargo;\n use crate::dist;\n use crate::native;\n-use crate::util::{exe, is_dylib};\n+use crate::util::{exe, is_dylib, symlink_dir};\n use crate::{Compiler, GitRepo, Mode};\n \n use crate::builder::{Builder, Kind, RunConfig, ShouldRun, Step};\n@@ -86,7 +86,7 @@ impl Step for Std {\n         target_deps.extend(copy_third_party_objects(builder, &compiler, target).into_iter());\n \n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n-        std_cargo(builder, target, &mut cargo);\n+        std_cargo(builder, target, compiler.stage, &mut cargo);\n \n         builder.info(&format!(\n             \"Building stage{} std artifacts ({} -> {})\",\n@@ -125,15 +125,16 @@ fn copy_third_party_objects(\n         target_deps.push(target);\n     };\n \n-    // Copies the crt(1,i,n).o startup objects\n+    // Copies the CRT objects.\n     //\n-    // Since musl supports fully static linking, we can cross link for it even\n-    // with a glibc-targeting toolchain, given we have the appropriate startup\n-    // files. As those shipped with glibc won't work, copy the ones provided by\n-    // musl so we have them on linux-gnu hosts.\n+    // rustc historically provides a more self-contained installation for musl targets\n+    // not requiring the presence of a native musl toolchain. For example, it can fall back\n+    // to using gcc from a glibc-targeting toolchain for linking.\n+    // To do that we have to distribute musl startup objects as a part of Rust toolchain\n+    // and link with them manually in the self-contained mode.\n     if target.contains(\"musl\") {\n         let srcdir = builder.musl_root(target).unwrap().join(\"lib\");\n-        for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n+        for &obj in &[\"crt1.o\", \"Scrt1.o\", \"rcrt1.o\", \"crti.o\", \"crtn.o\"] {\n             copy_and_stamp(&srcdir, obj);\n         }\n     } else if target.ends_with(\"-wasi\") {\n@@ -164,7 +165,7 @@ fn copy_third_party_objects(\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Cargo) {\n+pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, stage: u32, cargo: &mut Cargo) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n@@ -186,6 +187,8 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Ca\n     // `compiler-rt` is located.\n     let compiler_builtins_root = builder.src.join(\"src/llvm-project/compiler-rt\");\n     let compiler_builtins_c_feature = if compiler_builtins_root.exists() {\n+        // Note that `libprofiler_builtins/build.rs` also computes this so if\n+        // you're changing something here please also change that.\n         cargo.env(\"RUST_COMPILER_RT_ROOT\", &compiler_builtins_root);\n         \" compiler-builtins-c\".to_string()\n     } else {\n@@ -229,6 +232,18 @@ pub fn std_cargo(builder: &Builder<'_>, target: Interned<String>, cargo: &mut Ca\n             }\n         }\n     }\n+\n+    // By default, rustc uses `-Cembed-bitcode=yes`, and Cargo overrides that\n+    // with `-Cembed-bitcode=no` for non-LTO builds. However, libstd must be\n+    // built with bitcode so that the produced rlibs can be used for both LTO\n+    // builds (which use bitcode) and non-LTO builds (which use object code).\n+    // So we override the override here!\n+    //\n+    // But we don't bother for the stage 0 compiler because it's never used\n+    // with LTO.\n+    if stage >= 1 {\n+        cargo.rustflag(\"-Cembed-bitcode=yes\");\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -503,9 +518,13 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: Interne\n     // librustc_llvm and librustc_codegen_llvm.\n     //\n     // Note that this is disabled if LLVM itself is disabled or we're in a check\n-    // build, where if we're in a check build there's no need to build all of\n-    // LLVM and such.\n-    if builder.config.llvm_enabled() && builder.kind != Kind::Check {\n+    // build. If we are in a check build we still go ahead here presuming we've\n+    // detected that LLVM is alreay built and good to go which helps prevent\n+    // busting caches (e.g. like #71152).\n+    if builder.config.llvm_enabled()\n+        && (builder.kind != Kind::Check\n+            || crate::native::prebuilt_llvm_config(builder, target).is_ok())\n+    {\n         if builder.is_rust_llvm(target) {\n             cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n         }\n@@ -633,6 +652,30 @@ impl Step for Sysroot {\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n+\n+        // Symlink the source root into the same location inside the sysroot,\n+        // where `rust-src` component would go (`$sysroot/lib/rustlib/src/rust`),\n+        // so that any tools relying on `rust-src` also work for local builds,\n+        // and also for translating the virtual `/rustc/$hash` back to the real\n+        // directory (for running tests with `rust.remap-debuginfo = true`).\n+        let sysroot_lib_rustlib_src = sysroot.join(\"lib/rustlib/src\");\n+        t!(fs::create_dir_all(&sysroot_lib_rustlib_src));\n+        let sysroot_lib_rustlib_src_rust = sysroot_lib_rustlib_src.join(\"rust\");\n+        if let Err(e) = symlink_dir(&builder.config, &builder.src, &sysroot_lib_rustlib_src_rust) {\n+            eprintln!(\n+                \"warning: creating symbolic link `{}` to `{}` failed with {}\",\n+                sysroot_lib_rustlib_src_rust.display(),\n+                builder.src.display(),\n+                e,\n+            );\n+            if builder.config.rust_remap_debuginfo {\n+                eprintln!(\n+                    \"warning: some `src/test/ui` tests will fail when lacking `{}`\",\n+                    sysroot_lib_rustlib_src_rust.display(),\n+                );\n+            }\n+        }\n+\n         INTERNER.intern_path(sysroot)\n     }\n }\n@@ -911,7 +954,11 @@ pub fn stream_cargo(\n     }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n-    let mut message_format = String::from(\"json-render-diagnostics\");\n+    let mut message_format = if builder.config.json_output {\n+        String::from(\"json\")\n+    } else {\n+        String::from(\"json-render-diagnostics\")\n+    };\n     if let Some(s) = &builder.config.rustc_error_format {\n         message_format.push_str(\",json-diagnostic-\");\n         message_format.push_str(s);\n@@ -970,4 +1017,7 @@ pub enum CargoMessage<'a> {\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,\n     },\n+    BuildFinished {\n+        success: bool,\n+    },\n }"}, {"sha": "771f952abc013b4827ce51c25241e5eb159a19c2", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -48,6 +48,7 @@ pub struct Config {\n     pub ignore_git: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub json_output: bool,\n     pub test_compare_mode: bool,\n     pub llvm_libunwind: bool,\n \n@@ -84,7 +85,6 @@ pub struct Config {\n \n     pub use_lld: bool,\n     pub lld_enabled: bool,\n-    pub lldb_enabled: bool,\n     pub llvm_tools_enabled: bool,\n \n     pub llvm_cflags: Option<String>,\n@@ -97,6 +97,7 @@ pub struct Config {\n     pub rust_codegen_units: Option<u32>,\n     pub rust_codegen_units_std: Option<u32>,\n     pub rust_debug_assertions: bool,\n+    pub rust_debug_assertions_std: bool,\n     pub rust_debuginfo_level_rustc: u32,\n     pub rust_debuginfo_level_std: u32,\n     pub rust_debuginfo_level_tools: u32,\n@@ -211,6 +212,8 @@ struct Build {\n     host: Vec<String>,\n     #[serde(default)]\n     target: Vec<String>,\n+    // This is ignored, the rust code always gets the build directory from the `BUILD_DIR` env variable\n+    build_dir: Option<String>,\n     cargo: Option<String>,\n     rustc: Option<String>,\n     rustfmt: Option<String>, /* allow bootstrap.py to use rustfmt key */\n@@ -312,6 +315,7 @@ struct Rust {\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n+    debug_assertions_std: Option<bool>,\n     debuginfo_level: Option<u32>,\n     debuginfo_level_rustc: Option<u32>,\n     debuginfo_level_std: Option<u32>,\n@@ -334,7 +338,6 @@ struct Rust {\n     lld: Option<bool>,\n     use_lld: Option<bool>,\n     llvm_tools: Option<bool>,\n-    lldb: Option<bool>,\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n     verify_llvm_ir: Option<bool>,\n@@ -415,6 +418,7 @@ impl Config {\n         let mut config = Config::default_opts();\n         config.exclude = flags.exclude;\n         config.rustc_error_format = flags.rustc_error_format;\n+        config.json_output = flags.json_output;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n         config.jobs = flags.jobs.map(threads_from_config);\n@@ -516,6 +520,7 @@ impl Config {\n         let mut llvm_assertions = None;\n         let mut debug = None;\n         let mut debug_assertions = None;\n+        let mut debug_assertions_std = None;\n         let mut debuginfo_level = None;\n         let mut debuginfo_level_rustc = None;\n         let mut debuginfo_level_std = None;\n@@ -558,6 +563,7 @@ impl Config {\n         if let Some(ref rust) = toml.rust {\n             debug = rust.debug;\n             debug_assertions = rust.debug_assertions;\n+            debug_assertions_std = rust.debug_assertions_std;\n             debuginfo_level = rust.debuginfo_level;\n             debuginfo_level_rustc = rust.debuginfo_level_rustc;\n             debuginfo_level_std = rust.debuginfo_level_std;\n@@ -581,7 +587,6 @@ impl Config {\n             }\n             set(&mut config.use_lld, rust.use_lld);\n             set(&mut config.lld_enabled, rust.lld);\n-            set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n             config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n@@ -657,6 +662,8 @@ impl Config {\n \n         let default = debug == Some(true);\n         config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n+        config.rust_debug_assertions_std =\n+            debug_assertions_std.unwrap_or(config.rust_debug_assertions);\n \n         let with_defaults = |debuginfo_level_specific: Option<u32>| {\n             debuginfo_level_specific.or(debuginfo_level).unwrap_or(if debug == Some(true) {"}, {"sha": "d1e53db573e4cbd8366902f8e49a7a861ff61b73", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -57,7 +57,6 @@ def v(*args):\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n o(\"full-tools\", None, \"enable all tools\")\n o(\"lld\", \"rust.lld\", \"build lld\")\n-o(\"lldb\", \"rust.lldb\", \"build lldb\")\n o(\"missing-tools\", \"dist.missing-tools\", \"allow failures when building tools\")\n o(\"use-libcxx\", \"llvm.use-libcxx\", \"build LLVM with libc++\")\n o(\"control-flow-guard\", \"rust.control-flow-guard\", \"Enable Control Flow Guard\")"}, {"sha": "c4bca4a00408912a9758142df685a0c2617ac824", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 28, "deletions": 170, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -38,8 +38,6 @@ pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n         format!(\"{}-{}\", component, builder.rustfmt_package_vers())\n     } else if component == \"llvm-tools\" {\n         format!(\"{}-{}\", component, builder.llvm_tools_package_vers())\n-    } else if component == \"lldb\" {\n-        format!(\"{}-{}\", component, builder.lldb_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n         format!(\"{}-{}\", component, builder.rust_package_vers())\n@@ -1330,7 +1328,7 @@ pub struct Clippy {\n }\n \n impl Step for Clippy {\n-    type Output = Option<PathBuf>;\n+    type Output = PathBuf;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -1348,7 +1346,7 @@ impl Step for Clippy {\n         });\n     }\n \n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1368,16 +1366,10 @@ impl Step for Clippy {\n         // state for clippy isn't testing.\n         let clippy = builder\n             .ensure(tool::Clippy { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"clippy\", builder.build.config.missing_tools);\n-                None\n-            })?;\n+            .expect(\"clippy expected to build - essential tool\");\n         let cargoclippy = builder\n             .ensure(tool::CargoClippy { compiler, target, extra_features: Vec::new() })\n-            .or_else(|| {\n-                missing_tool(\"cargo clippy\", builder.build.config.missing_tools);\n-                None\n-            })?;\n+            .expect(\"clippy expected to build - essential tool\");\n \n         builder.install(&clippy, &image.join(\"bin\"), 0o755);\n         builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n@@ -1416,7 +1408,7 @@ impl Step for Clippy {\n         builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let _time = timeit(builder);\n         builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -1651,7 +1643,6 @@ impl Step for Extended {\n         let llvm_tools_installer = builder.ensure(LlvmTools { target });\n         let clippy_installer = builder.ensure(Clippy { compiler, target });\n         let miri_installer = builder.ensure(Miri { compiler, target });\n-        let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n@@ -1683,11 +1674,10 @@ impl Step for Extended {\n         tarballs.push(rustc_installer);\n         tarballs.push(cargo_installer);\n         tarballs.extend(rls_installer.clone());\n-        tarballs.extend(clippy_installer.clone());\n+        tarballs.push(clippy_installer);\n         tarballs.extend(miri_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n         tarballs.extend(llvm_tools_installer);\n-        tarballs.extend(lldb_installer);\n         tarballs.push(analysis_installer);\n         tarballs.push(std_installer);\n         if builder.config.docs {\n@@ -1761,9 +1751,6 @@ impl Step for Extended {\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n-            if clippy_installer.is_none() {\n-                contents = filter(&contents, \"clippy\");\n-            }\n             if miri_installer.is_none() {\n                 contents = filter(&contents, \"miri\");\n             }\n@@ -1805,13 +1792,11 @@ impl Step for Extended {\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n             prepare(\"rust-analysis\");\n+            prepare(\"clippy\");\n \n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            if clippy_installer.is_some() {\n-                prepare(\"clippy\");\n-            }\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n@@ -1863,12 +1848,10 @@ impl Step for Extended {\n             prepare(\"rust-analysis\");\n             prepare(\"rust-docs\");\n             prepare(\"rust-std\");\n+            prepare(\"clippy\");\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n-            if clippy_installer.is_some() {\n-                prepare(\"clippy\");\n-            }\n             if miri_installer.is_some() {\n                 prepare(\"miri\");\n             }\n@@ -1989,25 +1972,23 @@ impl Step for Extended {\n                         .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n                 );\n             }\n-            if clippy_installer.is_some() {\n-                builder.run(\n-                    Command::new(&heat)\n-                        .current_dir(&exe)\n-                        .arg(\"dir\")\n-                        .arg(\"clippy\")\n-                        .args(&heat_flags)\n-                        .arg(\"-cg\")\n-                        .arg(\"ClippyGroup\")\n-                        .arg(\"-dr\")\n-                        .arg(\"Clippy\")\n-                        .arg(\"-var\")\n-                        .arg(\"var.ClippyDir\")\n-                        .arg(\"-out\")\n-                        .arg(exe.join(\"ClippyGroup.wxs\"))\n-                        .arg(\"-t\")\n-                        .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n-                );\n-            }\n+            builder.run(\n+                Command::new(&heat)\n+                    .current_dir(&exe)\n+                    .arg(\"dir\")\n+                    .arg(\"clippy\")\n+                    .args(&heat_flags)\n+                    .arg(\"-cg\")\n+                    .arg(\"ClippyGroup\")\n+                    .arg(\"-dr\")\n+                    .arg(\"Clippy\")\n+                    .arg(\"-var\")\n+                    .arg(\"var.ClippyDir\")\n+                    .arg(\"-out\")\n+                    .arg(exe.join(\"ClippyGroup.wxs\"))\n+                    .arg(\"-t\")\n+                    .arg(etc.join(\"msi/remove-duplicates.xsl\")),\n+            );\n             if miri_installer.is_some() {\n                 builder.run(\n                     Command::new(&heat)\n@@ -2073,6 +2054,7 @@ impl Step for Extended {\n                     .arg(\"-dCargoDir=cargo\")\n                     .arg(\"-dStdDir=rust-std\")\n                     .arg(\"-dAnalysisDir=rust-analysis\")\n+                    .arg(\"-dClippyDir=clippy\")\n                     .arg(\"-arch\")\n                     .arg(&arch)\n                     .arg(\"-out\")\n@@ -2083,9 +2065,6 @@ impl Step for Extended {\n                 if rls_installer.is_some() {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n-                if clippy_installer.is_some() {\n-                    cmd.arg(\"-dClippyDir=clippy\");\n-                }\n                 if miri_installer.is_some() {\n                     cmd.arg(\"-dMiriDir=miri\");\n                 }\n@@ -2101,12 +2080,10 @@ impl Step for Extended {\n             candle(\"DocsGroup.wxs\".as_ref());\n             candle(\"CargoGroup.wxs\".as_ref());\n             candle(\"StdGroup.wxs\".as_ref());\n+            candle(\"ClippyGroup.wxs\".as_ref());\n             if rls_installer.is_some() {\n                 candle(\"RlsGroup.wxs\".as_ref());\n             }\n-            if clippy_installer.is_some() {\n-                candle(\"ClippyGroup.wxs\".as_ref());\n-            }\n             if miri_installer.is_some() {\n                 candle(\"MiriGroup.wxs\".as_ref());\n             }\n@@ -2138,14 +2115,12 @@ impl Step for Extended {\n                 .arg(\"CargoGroup.wixobj\")\n                 .arg(\"StdGroup.wixobj\")\n                 .arg(\"AnalysisGroup.wixobj\")\n+                .arg(\"ClippyGroup.wixobj\")\n                 .current_dir(&exe);\n \n             if rls_installer.is_some() {\n                 cmd.arg(\"RlsGroup.wixobj\");\n             }\n-            if clippy_installer.is_some() {\n-                cmd.arg(\"ClippyGroup.wixobj\");\n-            }\n             if miri_installer.is_some() {\n                 cmd.arg(\"MiriGroup.wixobj\");\n             }\n@@ -2243,7 +2218,6 @@ impl Step for HashSign {\n         cmd.arg(builder.package_vers(&builder.release_num(\"miri\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n         cmd.arg(builder.llvm_tools_package_vers());\n-        cmd.arg(builder.lldb_package_vers());\n \n         builder.create_dir(&distdir(builder));\n \n@@ -2370,119 +2344,3 @@ impl Step for LlvmTools {\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n-\n-#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n-pub struct Lldb {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Lldb {\n-    type Output = Option<PathBuf>;\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/llvm-project/lldb\").path(\"src/tools/lldb\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Lldb { target: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let target = self.target;\n-\n-        if builder.config.dry_run {\n-            return None;\n-        }\n-\n-        let bindir = builder.llvm_out(target).join(\"bin\");\n-        let lldb_exe = bindir.join(exe(\"lldb\", &target));\n-        if !lldb_exe.exists() {\n-            return None;\n-        }\n-\n-        builder.info(&format!(\"Dist Lldb ({})\", target));\n-        let src = builder.src.join(\"src/llvm-project/lldb\");\n-        let name = pkgname(builder, \"lldb\");\n-\n-        let tmp = tmpdir(builder);\n-        let image = tmp.join(\"lldb-image\");\n-        drop(fs::remove_dir_all(&image));\n-\n-        // Prepare the image directory\n-        let root = image.join(\"lib/rustlib\").join(&*target);\n-        let dst = root.join(\"bin\");\n-        t!(fs::create_dir_all(&dst));\n-        for program in &[\"lldb\", \"lldb-argdumper\", \"lldb-mi\", \"lldb-server\"] {\n-            let exe = bindir.join(exe(program, &target));\n-            builder.install(&exe, &dst, 0o755);\n-        }\n-\n-        // The libraries.\n-        let libdir = builder.llvm_out(target).join(\"lib\");\n-        let dst = root.join(\"lib\");\n-        t!(fs::create_dir_all(&dst));\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = entry.unwrap();\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"liblldb.\") && !name.ends_with(\".a\") {\n-                    if t!(entry.file_type()).is_symlink() {\n-                        builder.copy_to_folder(&entry.path(), &dst);\n-                    } else {\n-                        builder.install(&entry.path(), &dst, 0o755);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // The lldb scripts might be installed in lib/python$version\n-        // or in lib64/python$version.  If lib64 exists, use it;\n-        // otherwise lib.\n-        let libdir = builder.llvm_out(target).join(\"lib64\");\n-        let (libdir, libdir_name) = if libdir.exists() {\n-            (libdir, \"lib64\")\n-        } else {\n-            (builder.llvm_out(target).join(\"lib\"), \"lib\")\n-        };\n-        for entry in t!(fs::read_dir(&libdir)) {\n-            let entry = t!(entry);\n-            if let Ok(name) = entry.file_name().into_string() {\n-                if name.starts_with(\"python\") {\n-                    let dst = root.join(libdir_name).join(entry.file_name());\n-                    t!(fs::create_dir_all(&dst));\n-                    builder.cp_r(&entry.path(), &dst);\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // Prepare the overlay\n-        let overlay = tmp.join(\"lldb-overlay\");\n-        drop(fs::remove_dir_all(&overlay));\n-        builder.create_dir(&overlay);\n-        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n-        builder.create(&overlay.join(\"version\"), &builder.lldb_vers());\n-\n-        // Generate the installer tarball\n-        let mut cmd = rust_installer(builder);\n-        cmd.arg(\"generate\")\n-            .arg(\"--product-name=Rust\")\n-            .arg(\"--rel-manifest-dir=rustlib\")\n-            .arg(\"--success-message=lldb-installed.\")\n-            .arg(\"--image-dir\")\n-            .arg(&image)\n-            .arg(\"--work-dir\")\n-            .arg(&tmpdir(builder))\n-            .arg(\"--output-dir\")\n-            .arg(&distdir(builder))\n-            .arg(\"--non-installed-overlay\")\n-            .arg(&overlay)\n-            .arg(format!(\"--package-name={}-{}\", name, target))\n-            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--component-name=lldb-preview\");\n-\n-        builder.run(&mut cmd);\n-        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n-    }\n-}"}, {"sha": "7eab92ddc92a95a9ba7b6bc639832633b82f26ee", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -394,7 +394,7 @@ impl Step for Std {\n \n         let run_cargo_rustdoc_for = |package: &str| {\n             let mut cargo = builder.cargo(compiler, Mode::Std, target, \"rustdoc\");\n-            compile::std_cargo(builder, target, &mut cargo);\n+            compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n \n             // Keep a whitelist so we do not build internal stdlib crates, these will be\n             // build by the rustc step later if enabled.\n@@ -478,7 +478,11 @@ impl Step for Rustc {\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        cargo.env(\n+            \"RUSTDOCFLAGS\",\n+            \"--document-private-items \\\n+            --enable-index-page -Zunstable-options\",\n+        );\n         compile::rustc_cargo(builder, &mut cargo, target);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`."}, {"sha": "646b9e05d99c3c25c9357c3d24f2e359dee06deb", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -31,6 +31,7 @@ pub struct Flags {\n     pub incremental: bool,\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n+    pub json_output: bool,\n     pub dry_run: bool,\n \n     // This overrides the deny-warnings configuration option,\n@@ -86,6 +87,9 @@ pub enum Subcommand {\n     Install {\n         paths: Vec<PathBuf>,\n     },\n+    Run {\n+        paths: Vec<PathBuf>,\n+    },\n }\n \n impl Default for Subcommand {\n@@ -102,17 +106,18 @@ impl Flags {\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n-    build       Compile either the compiler or libraries\n-    check       Compile either the compiler or libraries, using cargo check\n+    build, b    Compile either the compiler or libraries\n+    check, c    Compile either the compiler or libraries, using cargo check\n     clippy      Run clippy (uses rustup/cargo-installed clippy binary)\n     fix         Run cargo fix\n     fmt         Run rustfmt\n-    test        Build and run some test suites\n+    test, t     Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n     clean       Clean out build directories\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n+    run, r      Run tools contained in this repository\n \n To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         );\n@@ -152,6 +157,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"VALUE\",\n         );\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n+        opts.optflag(\"\", \"json-output\", \"use message-format=json\");\n         opts.optopt(\n             \"\",\n             \"llvm-skip-rebuild\",\n@@ -178,16 +184,21 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         // there on out.\n         let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n+                || (s == \"b\")\n                 || (s == \"check\")\n+                || (s == \"c\")\n                 || (s == \"clippy\")\n                 || (s == \"fix\")\n                 || (s == \"fmt\")\n                 || (s == \"test\")\n+                || (s == \"t\")\n                 || (s == \"bench\")\n                 || (s == \"doc\")\n                 || (s == \"clean\")\n                 || (s == \"dist\")\n                 || (s == \"install\")\n+                || (s == \"run\")\n+                || (s == \"r\")\n         });\n         let subcommand = match subcommand {\n             Some(s) => s,\n@@ -203,7 +214,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n \n         // Some subcommands get extra options\n         match subcommand.as_str() {\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n                 opts.optmulti(\n@@ -278,7 +289,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n         }\n         // Extra help text for some commands\n         match subcommand.as_str() {\n-            \"build\" => {\n+            \"build\" | \"b\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -305,7 +316,7 @@ Arguments:\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n                 );\n             }\n-            \"check\" => {\n+            \"check\" | \"c\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -355,7 +366,7 @@ Arguments:\n         ./x.py fmt --check\",\n                 );\n             }\n-            \"test\" => {\n+            \"test\" | \"t\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n@@ -400,6 +411,18 @@ Arguments:\n         ./x.py doc --stage 1\",\n                 );\n             }\n+            \"run\" | \"r\" => {\n+                subcommand_help.push_str(\n+                    \"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to tools to build and run. For\n+    example:\n+\n+        ./x.py run src/tool/expand-yaml-anchors\n+\n+    At least a tool needs to be called.\",\n+                );\n+            }\n             _ => {}\n         };\n         // Get any optional paths which occur after the subcommand\n@@ -434,11 +457,11 @@ Arguments:\n         }\n \n         let cmd = match subcommand.as_str() {\n-            \"build\" => Subcommand::Build { paths },\n-            \"check\" => Subcommand::Check { paths },\n+            \"build\" | \"b\" => Subcommand::Build { paths },\n+            \"check\" | \"c\" => Subcommand::Check { paths },\n             \"clippy\" => Subcommand::Clippy { paths },\n             \"fix\" => Subcommand::Fix { paths },\n-            \"test\" => Subcommand::Test {\n+            \"test\" | \"t\" => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n@@ -468,17 +491,39 @@ Arguments:\n             \"fmt\" => Subcommand::Format { check: matches.opt_present(\"check\") },\n             \"dist\" => Subcommand::Dist { paths },\n             \"install\" => Subcommand::Install { paths },\n+            \"run\" | \"r\" => {\n+                if paths.is_empty() {\n+                    println!(\"\\nrun requires at least a path!\\n\");\n+                    usage(1, &opts, &subcommand_help, &extra_help);\n+                }\n+                Subcommand::Run { paths }\n+            }\n             _ => {\n                 usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n+        if let Subcommand::Check { .. } = &cmd {\n+            if matches.opt_str(\"stage\").is_some() {\n+                println!(\"{}\", \"--stage not supported for x.py check, always treated as stage 0\");\n+                process::exit(1);\n+            }\n+            if matches.opt_str(\"keep-stage\").is_some() {\n+                println!(\n+                    \"{}\",\n+                    \"--keep-stage not supported for x.py check, only one stage available\"\n+                );\n+                process::exit(1);\n+            }\n+        }\n+\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),\n             dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n+            json_output: matches.opt_present(\"json-output\"),\n             keep_stage: matches\n                 .opt_strs(\"keep-stage\")\n                 .into_iter()"}, {"sha": "390b7e96b9a543cecdd806fe2369b10469bd9f50", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -4,7 +4,7 @@ use crate::Build;\n use build_helper::{output, t};\n use ignore::WalkBuilder;\n use std::path::Path;\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n \n fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     let mut cmd = Command::new(&rustfmt);\n@@ -23,7 +23,7 @@ fn rustfmt(src: &Path, rustfmt: &Path, path: &Path, check: bool) {\n     if !status.success() {\n         eprintln!(\n             \"Running `{}` failed.\\nIf you're running `tidy`, \\\n-            try again with `--bless` flag. Or, you just want to format \\\n+            try again with `--bless`. Or, if you just want to format \\\n             code, run `./x.py fmt` instead.\",\n             cmd_debug,\n         );\n@@ -56,16 +56,48 @@ pub fn format(build: &Build, check: bool) {\n     for ignore in rustfmt_config.ignore {\n         ignore_fmt.add(&format!(\"!{}\", ignore)).expect(&ignore);\n     }\n-    let untracked_paths_output = output(\n-        Command::new(\"git\").arg(\"status\").arg(\"--porcelain\").arg(\"--untracked-files=normal\"),\n-    );\n-    let untracked_paths = untracked_paths_output\n-        .lines()\n-        .filter(|entry| entry.starts_with(\"??\"))\n-        .map(|entry| entry.split(\" \").nth(1).expect(\"every git status entry should list a path\"));\n-    for untracked_path in untracked_paths {\n-        eprintln!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n-        ignore_fmt.add(&format!(\"!{}\", untracked_path)).expect(&untracked_path);\n+    let git_available = match Command::new(\"git\")\n+        .arg(\"--version\")\n+        .stdout(Stdio::null())\n+        .stderr(Stdio::null())\n+        .status()\n+    {\n+        Ok(status) => status.success(),\n+        Err(_) => false,\n+    };\n+    if git_available {\n+        let in_working_tree = match Command::new(\"git\")\n+            .arg(\"rev-parse\")\n+            .arg(\"--is-inside-work-tree\")\n+            .stdout(Stdio::null())\n+            .stderr(Stdio::null())\n+            .status()\n+        {\n+            Ok(status) => status.success(),\n+            Err(_) => false,\n+        };\n+        if in_working_tree {\n+            let untracked_paths_output = output(\n+                Command::new(\"git\")\n+                    .arg(\"status\")\n+                    .arg(\"--porcelain\")\n+                    .arg(\"--untracked-files=normal\"),\n+            );\n+            let untracked_paths = untracked_paths_output\n+                .lines()\n+                .filter(|entry| entry.starts_with(\"??\"))\n+                .map(|entry| {\n+                    entry.split(\" \").nth(1).expect(\"every git status entry should list a path\")\n+                });\n+            for untracked_path in untracked_paths {\n+                eprintln!(\"skip untracked path {} during rustfmt invocations\", untracked_path);\n+                ignore_fmt.add(&format!(\"!{}\", untracked_path)).expect(&untracked_path);\n+            }\n+        } else {\n+            eprintln!(\"Not in git tree. Skipping git-aware format checks\");\n+        }\n+    } else {\n+        eprintln!(\"Could not find usable git. Skipping git-aware format checks\");\n     }\n     let ignore_fmt = ignore_fmt.build().unwrap();\n "}, {"sha": "fafd3cdf927c08224ad0676e581da510b770d4e3", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -214,10 +214,8 @@ install!((self, builder, _config),\n         }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Clippy {\n-            compiler: self.compiler,\n-            target: self.target,\n-        }).is_some() || Self::should_install(builder) {\n+        builder.ensure(dist::Clippy { compiler: self.compiler, target: self.target });\n+        if Self::should_install(builder) {\n             install_clippy(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info("}, {"sha": "2fe9b06e42643916d84a2c59f52f34b28cae789a", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -103,7 +103,12 @@ pub unsafe fn setup(build: &mut Build) {\n     };\n \n     let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n-    assert!(!parent.is_null(), \"{}\", io::Error::last_os_error());\n+    assert!(\n+        !parent.is_null(),\n+        \"PID `{}` doesn't seem to exist: {}\",\n+        pid,\n+        io::Error::last_os_error()\n+    );\n     let mut parent_handle = ptr::null_mut();\n     let r = DuplicateHandle(\n         GetCurrentProcess(),"}, {"sha": "15bf831a14835a846f42dde91912ab6293735219", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -140,6 +140,7 @@ mod format;\n mod install;\n mod metadata;\n mod native;\n+mod run;\n mod sanity;\n mod test;\n mod tool;\n@@ -739,19 +740,18 @@ impl Build {\n         self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n-    fn debuginfo_map(&self, which: GitRepo) -> Option<String> {\n+    fn debuginfo_map_to(&self, which: GitRepo) -> Option<String> {\n         if !self.config.rust_remap_debuginfo {\n             return None;\n         }\n \n-        let path = match which {\n+        match which {\n             GitRepo::Rustc => {\n                 let sha = self.rust_sha().unwrap_or(channel::CFG_RELEASE_NUM);\n-                format!(\"/rustc/{}\", sha)\n+                Some(format!(\"/rustc/{}\", sha))\n             }\n-            GitRepo::Llvm => String::from(\"/rustc/llvm\"),\n-        };\n-        Some(format!(\"{}={}\", self.src.display(), path))\n+            GitRepo::Llvm => Some(String::from(\"/rustc/llvm\")),\n+        }\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -786,7 +786,8 @@ impl Build {\n             base.push(\"-fno-omit-frame-pointer\".into());\n         }\n \n-        if let Some(map) = self.debuginfo_map(which) {\n+        if let Some(map_to) = self.debuginfo_map_to(which) {\n+            let map = format!(\"{}={}\", self.src.display(), map_to);\n             let cc = self.cc(target);\n             if cc.ends_with(\"clang\") || cc.ends_with(\"gcc\") {\n                 base.push(format!(\"-fdebug-prefix-map={}\", map));\n@@ -1028,14 +1029,6 @@ impl Build {\n         self.rust_version()\n     }\n \n-    fn lldb_package_vers(&self) -> String {\n-        self.package_vers(channel::CFG_RELEASE_NUM)\n-    }\n-\n-    fn lldb_vers(&self) -> String {\n-        self.rust_version()\n-    }\n-\n     fn llvm_link_tools_dynamically(&self, target: Interned<String>) -> bool {\n         target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")\n     }"}, {"sha": "d8c97fc741478fefa7556c54950ad569ed23a834", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -48,7 +48,6 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n \t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)"}, {"sha": "5b6e9534843693551ab1b42adc7cdc3f6ff404f7", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 108, "deletions": 63, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -24,6 +24,72 @@ use crate::util::{self, exe};\n use crate::GitRepo;\n use build_helper::up_to_date;\n \n+pub struct Meta {\n+    stamp: HashStamp,\n+    build_llvm_config: PathBuf,\n+    out_dir: PathBuf,\n+    root: String,\n+}\n+\n+// This returns whether we've already previously built LLVM.\n+//\n+// It's used to avoid busting caches during x.py check -- if we've already built\n+// LLVM, it's fine for us to not try to avoid doing so.\n+//\n+// This will return the llvm-config if it can get it (but it will not build it\n+// if not).\n+pub fn prebuilt_llvm_config(\n+    builder: &Builder<'_>,\n+    target: Interned<String>,\n+) -> Result<PathBuf, Meta> {\n+    // If we're using a custom LLVM bail out here, but we can only use a\n+    // custom LLVM for the build triple.\n+    if let Some(config) = builder.config.target_config.get(&target) {\n+        if let Some(ref s) = config.llvm_config {\n+            check_llvm_version(builder, s);\n+            return Ok(s.to_path_buf());\n+        }\n+    }\n+\n+    let root = \"src/llvm-project/llvm\";\n+    let out_dir = builder.llvm_out(target);\n+    let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n+    if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n+        llvm_config_ret_dir.push(\"build\");\n+    }\n+    llvm_config_ret_dir.push(\"bin\");\n+\n+    let build_llvm_config = llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n+\n+    let stamp = out_dir.join(\"llvm-finished-building\");\n+    let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n+\n+    if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n+        builder.info(\n+            \"Warning: \\\n+                Using a potentially stale build of LLVM; \\\n+                This may not behave well.\",\n+        );\n+        return Ok(build_llvm_config);\n+    }\n+\n+    if stamp.is_done() {\n+        if stamp.hash.is_none() {\n+            builder.info(\n+                \"Could not determine the LLVM submodule commit hash. \\\n+                     Assuming that an LLVM rebuild is not necessary.\",\n+            );\n+            builder.info(&format!(\n+                \"To force LLVM to rebuild, remove the file `{}`\",\n+                stamp.path.display()\n+            ));\n+        }\n+        return Ok(build_llvm_config);\n+    }\n+\n+    Err(Meta { stamp, build_llvm_config, out_dir, root: root.into() })\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: Interned<String>,\n@@ -46,51 +112,11 @@ impl Step for Llvm {\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target = self.target;\n \n-        // If we're using a custom LLVM bail out here, but we can only use a\n-        // custom LLVM for the build triple.\n-        if let Some(config) = builder.config.target_config.get(&target) {\n-            if let Some(ref s) = config.llvm_config {\n-                check_llvm_version(builder, s);\n-                return s.to_path_buf();\n-            }\n-        }\n-\n-        let root = \"src/llvm-project/llvm\";\n-        let out_dir = builder.llvm_out(target);\n-        let mut llvm_config_ret_dir = builder.llvm_out(builder.config.build);\n-        if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n-            llvm_config_ret_dir.push(\"build\");\n-        }\n-        llvm_config_ret_dir.push(\"bin\");\n-\n-        let build_llvm_config =\n-            llvm_config_ret_dir.join(exe(\"llvm-config\", &*builder.config.build));\n-\n-        let stamp = out_dir.join(\"llvm-finished-building\");\n-        let stamp = HashStamp::new(stamp, builder.in_tree_llvm_info.sha());\n-\n-        if builder.config.llvm_skip_rebuild && stamp.path.exists() {\n-            builder.info(\n-                \"Warning: \\\n-                Using a potentially stale build of LLVM; \\\n-                This may not behave well.\",\n-            );\n-            return build_llvm_config;\n-        }\n-\n-        if stamp.is_done() {\n-            if stamp.hash.is_none() {\n-                builder.info(\n-                    \"Could not determine the LLVM submodule commit hash. \\\n-                     Assuming that an LLVM rebuild is not necessary.\",\n-                );\n-                builder.info(&format!(\n-                    \"To force LLVM to rebuild, remove the file `{}`\",\n-                    stamp.path.display()\n-                ));\n-            }\n-            return build_llvm_config;\n-        }\n+        let Meta { stamp, build_llvm_config, out_dir, root } =\n+            match prebuilt_llvm_config(builder, target) {\n+                Ok(p) => return p,\n+                Err(m) => m,\n+            };\n \n         builder.info(&format!(\"Building LLVM for {}\", target));\n         t!(stamp.remove());\n@@ -158,7 +184,7 @@ impl Step for Llvm {\n         }\n \n         // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n-        if builder.config.llvm_tools_enabled || builder.config.lldb_enabled {\n+        if builder.config.llvm_tools_enabled {\n             if !target.contains(\"msvc\") {\n                 if target.contains(\"apple\") {\n                     cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n@@ -186,17 +212,9 @@ impl Step for Llvm {\n             enabled_llvm_projects.push(\"compiler-rt\");\n         }\n \n-        if builder.config.lldb_enabled {\n-            enabled_llvm_projects.push(\"clang\");\n-            enabled_llvm_projects.push(\"lldb\");\n-            // For the time being, disable code signing.\n-            cfg.define(\"LLDB_CODESIGN_IDENTITY\", \"\");\n-            cfg.define(\"LLDB_NO_DEBUGSERVER\", \"ON\");\n-        } else {\n-            // LLDB requires libxml2; but otherwise we want it to be disabled.\n-            // See https://github.com/rust-lang/rust/pull/50104\n-            cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n-        }\n+        // We want libxml to be disabled.\n+        // See https://github.com/rust-lang/rust/pull/50104\n+        cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n \n         if !enabled_llvm_projects.is_empty() {\n             enabled_llvm_projects.sort();\n@@ -235,10 +253,14 @@ impl Step for Llvm {\n             if !suffix.is_empty() {\n                 cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n             }\n+        } else if builder.config.channel == \"dev\" {\n+            // Changes to a version suffix require a complete rebuild of the LLVM.\n+            // To avoid rebuilds during a time of version bump, don't include rustc\n+            // release number on the dev channel.\n+            cfg.define(\"LLVM_VERSION_SUFFIX\", \"-rust-dev\");\n         } else {\n-            let default_suffix =\n-                format!(\"-rust-{}-{}\", channel::CFG_RELEASE_NUM, builder.config.channel);\n-            cfg.define(\"LLVM_VERSION_SUFFIX\", default_suffix);\n+            let suffix = format!(\"-rust-{}-{}\", channel::CFG_RELEASE_NUM, builder.config.channel);\n+            cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n         }\n \n         if let Some(ref linker) = builder.config.llvm_use_linker {\n@@ -285,11 +307,11 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2).filter_map(|s| s.parse::<u32>().ok());\n     if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n-        if major >= 7 {\n+        if major >= 8 {\n             return;\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=8.0\\n\\n\", version)\n }\n \n fn configure_cmake(\n@@ -475,10 +497,33 @@ impl Step for Lld {\n         let llvm_config_shim = env::current_exe().unwrap().with_file_name(\"llvm-config-wrapper\");\n         cfg.out_dir(&out_dir)\n             .profile(\"Release\")\n-            .env(\"LLVM_CONFIG_REAL\", llvm_config)\n+            .env(\"LLVM_CONFIG_REAL\", &llvm_config)\n             .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n             .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n \n+        // While we're using this horrible workaround to shim the execution of\n+        // llvm-config, let's just pile on more. I can't seem to figure out how\n+        // to build LLD as a standalone project and also cross-compile it at the\n+        // same time. It wants a natively executable `llvm-config` to learn\n+        // about LLVM, but then it learns about all the host configuration of\n+        // LLVM and tries to link to host LLVM libraries.\n+        //\n+        // To work around that we tell our shim to replace anything with the\n+        // build target with the actual target instead. This'll break parts of\n+        // LLD though which try to execute host tools, such as llvm-tblgen, so\n+        // we specifically tell it where to find those. This is likely super\n+        // brittle and will break over time. If anyone knows better how to\n+        // cross-compile LLD it would be much appreciated to fix this!\n+        if target != builder.config.build {\n+            cfg.env(\"LLVM_CONFIG_SHIM_REPLACE\", &builder.config.build)\n+                .env(\"LLVM_CONFIG_SHIM_REPLACE_WITH\", &target)\n+                .define(\"LLVM_TABLEGEN_EXE\", llvm_config.with_file_name(\"llvm-tblgen\"));\n+        }\n+\n+        // Explicitly set C++ standard, because upstream doesn't do so\n+        // for standalone builds.\n+        cfg.define(\"CMAKE_CXX_STANDARD\", \"14\");\n+\n         cfg.build();\n \n         t!(File::create(&done_stamp));"}, {"sha": "900534714277cb83ef2296b9f2ba82c8f9992e8d", "filename": "src/bootstrap/run.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,43 @@\n+use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::tool::Tool;\n+use std::process::Command;\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ExpandYamlAnchors;\n+\n+impl Step for ExpandYamlAnchors {\n+    type Output = ();\n+\n+    /// Runs the `expand-yaml_anchors` tool.\n+    ///\n+    /// This tool in `src/tools` read the CI configuration files written in YAML and expands the\n+    /// anchors in them, since GitHub Actions doesn't support them.\n+    fn run(self, builder: &Builder<'_>) {\n+        builder.info(\"Expanding YAML anchors in the GitHub Actions configuration\");\n+        try_run(\n+            builder,\n+            &mut builder.tool_cmd(Tool::ExpandYamlAnchors).arg(\"generate\").arg(&builder.src),\n+        );\n+    }\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/expand-yaml-anchors\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(ExpandYamlAnchors);\n+    }\n+}\n+\n+fn try_run(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n+    if !builder.fail_fast {\n+        if !builder.try_run(cmd) {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+            return false;\n+        }\n+    } else {\n+        builder.run(cmd);\n+    }\n+    true\n+}"}, {"sha": "74b47d0772837a5c57f562a6ce5ef0eae97fe48b", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -117,23 +117,13 @@ pub fn check(build: &mut Build) {\n                 build.config.ninja = true;\n             }\n         }\n-\n-        if build.config.lldb_enabled {\n-            cmd_finder.must_have(\"swig\");\n-            let out = output(Command::new(\"swig\").arg(\"-version\"));\n-            if !out.contains(\"SWIG Version 3\") && !out.contains(\"SWIG Version 4\") {\n-                panic!(\"Ensure that Swig 3.x.x or 4.x.x is installed.\");\n-            }\n-        }\n     }\n \n     build.config.python = build\n         .config\n         .python\n         .take()\n         .map(|p| cmd_finder.must_have(p))\n-        .or_else(|| cmd_finder.maybe_have(\"python2.7\"))\n-        .or_else(|| cmd_finder.maybe_have(\"python2\"))\n         .or_else(|| env::var_os(\"BOOTSTRAP_PYTHON\").map(PathBuf::from)) // set by bootstrap.py\n         .or_else(|| Some(cmd_finder.must_have(\"python\")));\n "}, {"sha": "96196a80be466d628c77cfd578bfb3da091baadf", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -21,7 +21,7 @@ use crate::flags::Subcommand;\n use crate::native;\n use crate::tool::{self, SourceType, Tool};\n use crate::toolstate::ToolState;\n-use crate::util::{self, dylib_path, dylib_path_var};\n+use crate::util::{self, add_link_lib_path, dylib_path, dylib_path_var};\n use crate::Crate as CargoCrate;\n use crate::{envify, DocTests, GitRepo, Mode};\n \n@@ -436,7 +436,6 @@ impl Step for Miri {\n \n             // miri tests need to know about the stage sysroot\n             cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n             cargo.env(\"MIRI_PATH\", miri);\n \n@@ -528,7 +527,7 @@ impl Step for Clippy {\n                 host,\n                 \"test\",\n                 \"src/tools/clippy\",\n-                SourceType::Submodule,\n+                SourceType::InTree,\n                 &[],\n             );\n \n@@ -548,9 +547,7 @@ impl Step for Clippy {\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-            if try_run(builder, &mut cargo.into()) {\n-                builder.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n-            }\n+            try_run(builder, &mut cargo.into());\n         } else {\n             eprintln!(\"failed to test clippy: could not build\");\n         }\n@@ -627,8 +624,14 @@ impl Step for RustdocJSStd {\n         if let Some(ref nodejs) = builder.config.nodejs {\n             let mut command = Command::new(nodejs);\n             command\n-                .arg(builder.src.join(\"src/tools/rustdoc-js-std/tester.js\"))\n+                .arg(builder.src.join(\"src/tools/rustdoc-js/tester.js\"))\n+                .arg(\"--crate-name\")\n+                .arg(\"std\")\n+                .arg(\"--resource-suffix\")\n+                .arg(crate::channel::CFG_RELEASE_NUM)\n+                .arg(\"--doc-folder\")\n                 .arg(builder.doc_out(self.target))\n+                .arg(\"--test-folder\")\n                 .arg(builder.src.join(\"src/test/rustdoc-js-std\"));\n             builder.ensure(crate::doc::Std { target: self.target, stage: builder.top_stage });\n             builder.run(&mut command);\n@@ -750,6 +753,35 @@ impl Step for Tidy {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ExpandYamlAnchors;\n+\n+impl Step for ExpandYamlAnchors {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    /// Ensure the `generate-ci-config` tool was run locally.\n+    ///\n+    /// The tool in `src/tools` reads the CI definition in `src/ci/builders.yml` and generates the\n+    /// appropriate configuration for all our CI providers. This step ensures the tool was called\n+    /// by the user before committing CI changes.\n+    fn run(self, builder: &Builder<'_>) {\n+        builder.info(\"Ensuring the YAML anchors in the GitHub Actions config were expanded\");\n+        try_run(\n+            builder,\n+            &mut builder.tool_cmd(Tool::ExpandYamlAnchors).arg(\"check\").arg(&builder.src),\n+        );\n+    }\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/expand-yaml-anchors\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(ExpandYamlAnchors);\n+    }\n+}\n+\n fn testdir(builder: &Builder<'_>, host: Interned<String>) -> PathBuf {\n     builder.out.join(host).join(\"test\")\n }\n@@ -865,8 +897,6 @@ default_test!(CompileFail {\n     suite: \"compile-fail\"\n });\n \n-default_test!(RunFail { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" });\n-\n default_test!(RunPassValgrind {\n     path: \"src/test/run-pass-valgrind\",\n     mode: \"run-pass-valgrind\",\n@@ -896,13 +926,6 @@ host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-ful\n host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n \n host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n-test!(RunFailPretty {\n-    path: \"src/test/run-fail/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-fail\",\n-    default: false,\n-    host: true\n-});\n test!(RunPassValgrindPretty {\n     path: \"src/test/run-pass-valgrind/pretty\",\n     mode: \"pretty\",\n@@ -1073,20 +1096,15 @@ impl Step for Compiletest {\n                     .to_string()\n             })\n         };\n-        let lldb_exe = if builder.config.lldb_enabled {\n-            // Test against the lldb that was just built.\n-            builder.llvm_out(target).join(\"bin\").join(\"lldb\")\n-        } else {\n-            PathBuf::from(\"lldb\")\n-        };\n-        let lldb_version = Command::new(&lldb_exe)\n+        let lldb_exe = \"lldb\";\n+        let lldb_version = Command::new(lldb_exe)\n             .arg(\"--version\")\n             .output()\n             .map(|output| String::from_utf8_lossy(&output.stdout).to_string())\n             .ok();\n         if let Some(ref vers) = lldb_version {\n             cmd.arg(\"--lldb-version\").arg(vers);\n-            let lldb_python_dir = run(Command::new(&lldb_exe).arg(\"-P\")).ok();\n+            let lldb_python_dir = run(Command::new(lldb_exe).arg(\"-P\")).ok();\n             if let Some(ref dir) = lldb_python_dir {\n                 cmd.arg(\"--lldb-python-dir\").arg(dir);\n             }\n@@ -1149,6 +1167,15 @@ impl Step for Compiletest {\n                 cmd.arg(\"--system-llvm\");\n             }\n \n+            // Tests that use compiler libraries may inherit the `-lLLVM` link\n+            // requirement, but the `-L` library path is not propagated across\n+            // separate compilations. We can add LLVM's library path to the\n+            // platform-specific environment variable as a workaround.\n+            if !builder.config.dry_run && suite.ends_with(\"fulldeps\") {\n+                let llvm_libdir = output(Command::new(&llvm_config).arg(\"--libdir\"));\n+                add_link_lib_path(vec![llvm_libdir.trim().into()], &mut cmd);\n+            }\n+\n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n@@ -1494,22 +1521,22 @@ impl Step for RustcGuide {\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/doc/rustc-guide\")\n+        run.path(\"src/doc/rustc-dev-guide\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcGuide);\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let src = builder.src.join(\"src/doc/rustc-guide\");\n+        let src = builder.src.join(\"src/doc/rustc-dev-guide\");\n         let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         let toolstate = if try_run(builder, rustbook_cmd.arg(\"linkcheck\").arg(&src)) {\n             ToolState::TestPass\n         } else {\n             ToolState::TestFail\n         };\n-        builder.save_toolstate(\"rustc-guide\", toolstate);\n+        builder.save_toolstate(\"rustc-dev-guide\", toolstate);\n     }\n }\n \n@@ -1681,7 +1708,7 @@ impl Step for Crate {\n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {\n             Mode::Std => {\n-                compile::std_cargo(builder, target, &mut cargo);\n+                compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n             }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });"}, {"sha": "8ebad95ea176263384ccb970bb2101de09621bf0", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -378,6 +378,7 @@ bootstrap_tool!(\n     RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\";\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", is_external_tool = true;\n     RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\";\n+    ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -606,7 +607,15 @@ macro_rules! tool_extended {\n \n             fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.config.extended)\n+                run.path($path).default_condition(\n+                    builder.config.extended\n+                        && builder.config.tools.as_ref().map_or(true, |tools| {\n+                            tools.iter().any(|tool| match tool.as_ref() {\n+                                \"clippy\" => $tool_name == \"clippy-driver\",\n+                                x => $tool_name == x,\n+                            })\n+                        }),\n+                )\n             }\n \n             fn make_run(run: RunConfig<'_>) {\n@@ -643,14 +652,12 @@ tool_extended!((self, builder),\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n-        let clippy = builder.ensure(Clippy {\n+        builder.ensure(Clippy {\n             compiler: self.compiler,\n             target: self.target,\n             extra_features: Vec::new(),\n         });\n-        if clippy.is_some() {\n-            self.extra_features.push(\"clippy\".to_owned());\n-        }\n+        self.extra_features.push(\"clippy\".to_owned());\n     };\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n );"}, {"sha": "6c219cee01ee589330893f007020b0eb5d5efcb3", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -78,7 +78,6 @@ static STABLE_TOOLS: &[(&str, &str)] = &[\n     (\"edition-guide\", \"src/doc/edition-guide\"),\n     (\"rls\", \"src/tools/rls\"),\n     (\"rustfmt\", \"src/tools/rustfmt\"),\n-    (\"clippy-driver\", \"src/tools/clippy\"),\n ];\n \n // These tools are permitted to not build on the beta/stable channels.\n@@ -89,16 +88,16 @@ static STABLE_TOOLS: &[(&str, &str)] = &[\n static NIGHTLY_TOOLS: &[(&str, &str)] = &[\n     (\"miri\", \"src/tools/miri\"),\n     (\"embedded-book\", \"src/doc/embedded-book\"),\n-    (\"rustc-guide\", \"src/doc/rustc-guide\"),\n+    // (\"rustc-dev-guide\", \"src/doc/rustc-dev-guide\"),\n ];\n \n fn print_error(tool: &str, submodule: &str) {\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"We detected that this PR updated '{}', but its tests failed.\", tool);\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do intend to update '{}', please check the error messages above and\", tool);\n     eprintln!(\"commit another update.\");\n-    eprintln!(\"\");\n+    eprintln!();\n     eprintln!(\"If you do NOT intend to update '{}', please ensure you did not accidentally\", tool);\n     eprintln!(\"change the submodule at '{}'. You may ask your reviewer for the\", submodule);\n     eprintln!(\"proper steps.\");"}, {"sha": "46d3cf7a38ca22aa67d52de2b0194bd61f3e7f07", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n #\n # Azure Pipelines \"auto\" branch build for Rust on Linux, macOS, and Windows.\n #\n@@ -18,7 +29,7 @@ jobs:\n   - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-7:\n+      x86_64-gnu-llvm-8:\n         RUST_BACKTRACE: 1\n       dist-x86_64-linux: {}\n       dist-x86_64-linux-alt:"}, {"sha": "485b80398c8e4dead48155ba49d55004c2c8ba26", "filename": "src/ci/azure-pipelines/master.yml", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fmaster.yml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n #\n # Azure Pipelines job to publish toolstate. Only triggers on pushes to master.\n #"}, {"sha": "1fc8d187242f8cacc16df7c7c6f170e83cb7b733", "filename": "src/ci/azure-pipelines/pr.yml", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fpr.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fpr.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fpr.yml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n #\n # Azure Pipelines pull request build for Rust\n #\n@@ -18,7 +29,7 @@ jobs:\n     - template: steps/run.yml\n   strategy:\n     matrix:\n-      x86_64-gnu-llvm-7: {}\n+      x86_64-gnu-llvm-8: {}\n       mingw-check: {}\n       x86_64-gnu-tools:\n         CI_ONLY_WHEN_SUBMODULES_CHANGED: 1"}, {"sha": "85ff3e52a841d85865d004a54e913f955cc2355f", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n # FIXME(linux): need to configure core dumps, enable them, and then dump\n # backtraces on failure from all core dumps:\n #\n@@ -59,8 +70,8 @@ steps:\n   displayName: Install InnoSetup\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/windows-symlink-build-dir.sh\n-  displayName: Ensure the build happens on C:\\ instead of D:\\\n+- bash: src/ci/scripts/symlink-build-dir.sh\n+  displayName: Ensure the build happens on a partition with enough space\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n - bash: src/ci/scripts/disable-git-crlf-conversion.sh"}, {"sha": "38a0685e0f75a04cf2746584bbc49c658847ffae", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,14 @@\n+#####################################\n+##    READ BEFORE CHANGING THIS    ##\n+#####################################\n+\n+# We're in the process of evaluating GitHub Actions as a possible replacement\n+# for Azure Pipelines, and at the moment the configuration is duplicated\n+# between the two CI providers. Be sure to also change the configuration in\n+# src/ci/github-actions when changing this file.\n+\n+#####################################\n+\n pr: none\n trigger:\n - try"}, {"sha": "95936d65432fabfaaed0d3a050977db75ea10cbf", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -138,33 +138,31 @@ $category > $option = $value -- $comment\n For targets: `arm-unknown-linux-gnueabi`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Floating point = software (no FPU) -- (\\*)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `arm-linux-gnueabihf.config`\n \n For targets: `arm-unknown-linux-gnueabihf`\n \n - Path and misc options > Prefix directory = /x-tools/${CT\\_TARGET}\n-- Path and misc options > Patches origin = Bundled, then local\n-- Path and misc options > Local patch directory = /tmp/patches\n+- Path and misc options > Patches origin = Bundled only\n - Target options > Target Architecture = arm\n - Target options > Architecture level = armv6 -- (+)\n - Target options > Use specific FPU = vfp -- (+)\n - Target options > Floating point = hardware (FPU) -- (\\*)\n - Target options > Default instruction set mode = arm -- (+)\n - Operating System > Target OS = linux\n-- Operating System > Linux kernel version = 3.2.72 -- Precise kernel\n-- C-library > glibc version = 2.16.0\n-- C compiler > gcc version = 5.2.0\n+- Operating System > Linux kernel version = 3.2.101\n+- C-library > glibc version = 2.17.0\n+- C compiler > gcc version = 8.3.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n ### `armv7-linux-gnueabihf.config`"}, {"sha": "77514848167067b2187f680130f2584d9278b13a", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -31,7 +31,7 @@ ENV TARGETS=arm-linux-androideabi\n \n ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+ENV SCRIPT python3 ../x.py test --target $TARGETS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "d1bc70689e1e7bb97ce2c99f531d37f4f11f8985", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n       libc6-dev \\\n       libc6-dev-armhf-cross \\\n       make \\\n-      python2.7 \\\n+      python3 \\\n       qemu-system-arm \\\n       xz-utils\n \n@@ -78,6 +78,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --qemu-armhf-rootfs=/tmp/rootfs\n-ENV SCRIPT python2.7 ../x.py test --target arm-unknown-linux-gnueabihf\n+ENV SCRIPT python3 ../x.py test --target arm-unknown-linux-gnueabihf\n \n ENV NO_CHANGE_USER=1"}, {"sha": "9dd0435ac4f0c9727988c71d401d9303ac2ae456", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -14,7 +14,7 @@ RUN apt-get update -y && apt-get install -y --no-install-recommends \\\n       libc6-dev \\\n       libc6-dev-arm64-cross \\\n       make \\\n-      python2.7 \\\n+      python3 \\\n       qemu-system-aarch64 \\\n       xz-utils\n \n@@ -75,5 +75,5 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n       --qemu-aarch64-rootfs=/tmp/rootfs\n-ENV SCRIPT python2.7 ../x.py test --target aarch64-unknown-linux-gnu\n+ENV SCRIPT python3 ../x.py test --target aarch64-unknown-linux-gnu\n ENV NO_CHANGE_USER=1"}, {"sha": "3fa65511e94f783912f52b7f7d2619b9a7e41cce", "filename": "src/ci/docker/disabled/asmjs/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fasmjs%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -33,7 +33,7 @@ ENV EMCC_CFLAGS=-O1\n # Emscripten installation is user-specific\n ENV NO_CHANGE_USER=1\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+ENV SCRIPT python3 ../x.py test --target $TARGETS\n \n # This is almost identical to the wasm32-unknown-emscripten target, so\n # running with assertions again is not useful"}, {"sha": "dea445c295c994263ef8ce7886a8b76b84adbaec", "filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -19,7 +19,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-cargo-openssl-static\n \n-ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n+ENV SCRIPT python3 ../x.py dist --target $HOSTS --host $HOSTS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "7227c41ccca9a7dda4f54bcac161c7163a50384a", "filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -33,11 +33,11 @@ ENV RUST_CONFIGURE_ARGS \\\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n-  python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n+  python3 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/arm && \\\n     ln -s /android/ndk/arm-14 /android/ndk/arm && \\\n-    python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n+    python3 ../x.py dist --host $HOSTS --target $HOSTS)\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "b74dcefa3516c5566262896a62b18f781cf10b9a", "filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -33,11 +33,11 @@ ENV RUST_CONFIGURE_ARGS \\\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n-  python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n+  python3 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/x86 && \\\n     ln -s /android/ndk/x86-14 /android/ndk/x86 && \\\n-    python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n+    python3 ../x.py dist --host $HOSTS --target $HOSTS)\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "19df9d6cf6231e4712b79422c22cdf93d295340c", "filename": "src/ci/docker/disabled/dist-powerpcspe-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-powerpcspe-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=powerpc-unknown-linux-gnuspe\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "62d0bfc71b2fa76a0cdf5cb635b9aa366804c703", "filename": "src/ci/docker/disabled/dist-sparc64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=sparc64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "d44779763e5443901234b12dc213594a4def7222", "filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -19,7 +19,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-extended \\\n       --enable-cargo-openssl-static\n \n-ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n+ENV SCRIPT python3 ../x.py dist --target $HOSTS --host $HOSTS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "5b7196c573c8b278cb58c9284c548d64b4fb25bb", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -33,4 +33,4 @@ ENV \\\n ENV HOSTS=x86_64-unknown-dragonfly\n \n ENV RUST_CONFIGURE_ARGS --enable-extended\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5b65335bfe4e4f635ba58febbe0d6274a1c9ed27", "filename": "src/ci/docker/disabled/dist-x86_64-haiku/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -18,7 +18,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   make \\\n   nasm \\\n   pkg-config \\\n-  python2.7 \\\n+  python3 \\\n   sudo \\\n   texinfo \\\n   wget \\\n@@ -46,4 +46,4 @@ ENV RUST_CONFIGURE_ARGS --disable-jemalloc \\\n   --set=$TARGET.cc=x86_64-unknown-haiku-gcc \\\n   --set=$TARGET.cxx=x86_64-unknown-haiku-g++ \\\n   --set=$TARGET.llvm-config=/bin/llvm-config-haiku\n-ENV SCRIPT python2.7 ../x.py dist --host=$HOST --target=$HOST\n+ENV SCRIPT python3 ../x.py dist --host=$HOST --target=$HOST"}, {"sha": "7b53e73d700ba4cc418efb6b0356a59e70042c6f", "filename": "src/ci/docker/disabled/dist-x86_64-redox/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -19,4 +19,4 @@ ENV \\\n     CXX_x86_64_unknown_redox=x86_64-unknown-redox-g++\n \n ENV RUST_CONFIGURE_ARGS --enable-extended\n-ENV SCRIPT python2.7 ../x.py dist --target x86_64-unknown-redox\n+ENV SCRIPT python3 ../x.py dist --target x86_64-unknown-redox"}, {"sha": "74766dc970d9f8fbcfb173ce21c6101824c499a0", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -33,7 +33,7 @@ ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n ENV HOSTS=aarch64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-profiler \\\n       --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "6d38e199564b1d3de503864bbd36847f72031260", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -32,7 +32,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n       --disable-docs\n \n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+ENV SCRIPT python3 ../x.py dist --target $TARGETS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "06870a8a982f3ab40e9c24a7c730770ac7405d12", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-arm-linux/patches/ /tmp/patches/\n COPY dist-arm-linux/arm-linux-gnueabi.config dist-arm-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n@@ -33,5 +27,5 @@ ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabi\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "1dcdbd1a9008be2eb76c7f5f8c781e8e234e953c", "filename": "src/ci/docker/dist-arm-linux/arm-linux-gnueabi.config", "status": "modified", "additions": 510, "deletions": 309, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Farm-linux-gnueabi.config?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,9 +1,29 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -20,41 +40,48 @@ CT_MODULES=y\n #\n # Paths\n #\n-CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -77,11 +104,11 @@ CT_CONFIG_SHELL=\"${bash}\"\n #\n # CT_LOG_ERROR is not set\n # CT_LOG_WARN is not set\n-CT_LOG_INFO=y\n-# CT_LOG_EXTRA is not set\n+# CT_LOG_INFO is not set\n+CT_LOG_EXTRA=y\n # CT_LOG_ALL is not set\n # CT_LOG_DEBUG is not set\n-CT_LOG_LEVEL_MAX=\"INFO\"\n+CT_LOG_LEVEL_MAX=\"EXTRA\"\n # CT_LOG_SEE_TOOLS_WARN is not set\n CT_LOG_PROGRESS_BAR=y\n CT_LOG_TO_FILE=y\n@@ -90,85 +117,86 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n+# CT_ARCH_ALPHA_EV4 is not set\n+# CT_ARCH_ALPHA_EV45 is not set\n+# CT_ARCH_ALPHA_EV5 is not set\n+# CT_ARCH_ALPHA_EV56 is not set\n+# CT_ARCH_ALPHA_EV6 is not set\n+# CT_ARCH_ALPHA_EV67 is not set\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-# CT_ARCH_FLOAT_HW is not set\n-CT_ARCH_FLOAT_SW=y\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"arm\"\n+CT_ARCH_ARM_MODE_ARM=y\n+# CT_ARCH_ARM_MODE_THUMB is not set\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_FPU=\"\"\n # CT_ARCH_FLOAT_AUTO is not set\n+# CT_ARCH_FLOAT_HW is not set\n # CT_ARCH_FLOAT_SOFTFP is not set\n+CT_ARCH_FLOAT_SW=y\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"soft\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"arm\"\n-CT_ARCH_ARM_MODE_ARM=y\n-# CT_ARCH_ARM_MODE_THUMB is not set\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-\n #\n # Toolchain options\n #\n@@ -181,7 +209,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -215,227 +245,287 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_NEWLIB is not set\n+# CT_LIBC_NONE is not set\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_REQUIRE_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+# CT_GLIBC_SSP_DEFAULT is not set\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_NEWLIB_USE_REDHAT is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -464,97 +554,208 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-arm-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=374ab25585f0a817fe7bd6986737f12347b12d0b", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "155dd84891435e5ed4bb7ce4f2ed375d9b137049", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -3,20 +3,14 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-# Ubuntu 16.04 (this container) ships with make 4, but something in the\n-# toolchains we build below chokes on that, so go back to make 3\n-COPY scripts/make3.sh /scripts/\n-RUN sh /scripts/make3.sh\n-\n-COPY scripts/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n USER rustbuild\n WORKDIR /tmp\n \n-COPY dist-armhf-linux/patches/ /tmp/patches/\n COPY dist-armhf-linux/arm-linux-gnueabihf.config dist-armhf-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n@@ -33,5 +27,5 @@ ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a3dcff1c9363538d11ca2ad8967d948405d998eb", "filename": "src/ci/docker/dist-armhf-linux/arm-linux-gnueabihf.config", "status": "modified", "additions": 511, "deletions": 310, "changes": 821, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Farm-linux-gnueabihf.config?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,9 +1,29 @@\n #\n # Automatically generated file; DO NOT EDIT.\n-# Crosstool-NG Configuration\n-#\n-CT_CONFIGURE_has_make381=y\n-CT_CONFIGURE_has_xz=y\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n CT_MODULES=y\n \n #\n@@ -20,41 +40,48 @@ CT_MODULES=y\n #\n # Paths\n #\n-CT_LOCAL_TARBALLS_DIR=\"\"\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n-CT_INSTALL_DIR=\"${CT_PREFIX_DIR}\"\n CT_RM_RF_PREFIX_DIR=y\n CT_REMOVE_DOCS=y\n-CT_INSTALL_DIR_RO=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n # CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n \n #\n # Downloading\n #\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n # CT_FORBID_DOWNLOAD is not set\n # CT_FORCE_DOWNLOAD is not set\n CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n # CT_ONLY_DOWNLOAD is not set\n # CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n \n #\n # Extracting\n #\n # CT_FORCE_EXTRACT is not set\n-CT_OVERIDE_CONFIG_GUESS_SUB=y\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n # CT_ONLY_EXTRACT is not set\n-# CT_PATCH_BUNDLED is not set\n-# CT_PATCH_LOCAL is not set\n-CT_PATCH_BUNDLED_LOCAL=y\n-# CT_PATCH_LOCAL_BUNDLED is not set\n-# CT_PATCH_BUNDLED_FALLBACK_LOCAL is not set\n-# CT_PATCH_LOCAL_FALLBACK_BUNDLED is not set\n-# CT_PATCH_NONE is not set\n-CT_PATCH_ORDER=\"bundled,local\"\n-CT_PATCH_USE_LOCAL=y\n-CT_LOCAL_PATCH_DIR=\"/tmp/patches\"\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+CT_PATCH_ORDER=\"bundled\"\n \n #\n # Build behavior\n@@ -77,11 +104,11 @@ CT_CONFIG_SHELL=\"${bash}\"\n #\n # CT_LOG_ERROR is not set\n # CT_LOG_WARN is not set\n-CT_LOG_INFO=y\n-# CT_LOG_EXTRA is not set\n+# CT_LOG_INFO is not set\n+CT_LOG_EXTRA=y\n # CT_LOG_ALL is not set\n # CT_LOG_DEBUG is not set\n-CT_LOG_LEVEL_MAX=\"INFO\"\n+CT_LOG_LEVEL_MAX=\"EXTRA\"\n # CT_LOG_SEE_TOOLS_WARN is not set\n CT_LOG_PROGRESS_BAR=y\n CT_LOG_TO_FILE=y\n@@ -90,86 +117,87 @@ CT_LOG_FILE_COMPRESS=y\n #\n # Target options\n #\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+CT_ARCH_ARM=y\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n CT_ARCH=\"arm\"\n-CT_ARCH_SUPPORTS_BOTH_MMU=y\n-CT_ARCH_SUPPORTS_BOTH_ENDIAN=y\n-CT_ARCH_SUPPORTS_32=y\n-CT_ARCH_SUPPORTS_64=y\n-CT_ARCH_SUPPORTS_WITH_ARCH=y\n-CT_ARCH_SUPPORTS_WITH_CPU=y\n-CT_ARCH_SUPPORTS_WITH_TUNE=y\n-CT_ARCH_SUPPORTS_WITH_FLOAT=y\n-CT_ARCH_SUPPORTS_WITH_FPU=y\n-CT_ARCH_SUPPORTS_SOFTFP=y\n-CT_ARCH_DEFAULT_HAS_MMU=y\n-CT_ARCH_DEFAULT_LE=y\n-CT_ARCH_DEFAULT_32=y\n-CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_CHOICE_KSYM=\"ARM\"\n+# CT_ARCH_ALPHA_EV4 is not set\n+# CT_ARCH_ALPHA_EV45 is not set\n+# CT_ARCH_ALPHA_EV5 is not set\n+# CT_ARCH_ALPHA_EV56 is not set\n+# CT_ARCH_ALPHA_EV6 is not set\n+# CT_ARCH_ALPHA_EV67 is not set\n CT_ARCH_CPU=\"\"\n CT_ARCH_TUNE=\"\"\n-CT_ARCH_FPU=\"vfp\"\n-# CT_ARCH_BE is not set\n-CT_ARCH_LE=y\n-CT_ARCH_32=y\n-# CT_ARCH_64 is not set\n-CT_ARCH_BITNESS=32\n-CT_ARCH_FLOAT_HW=y\n-# CT_ARCH_FLOAT_SW is not set\n-CT_TARGET_CFLAGS=\"\"\n-CT_TARGET_LDFLAGS=\"\"\n-# CT_ARCH_alpha is not set\n-CT_ARCH_arm=y\n-# CT_ARCH_avr is not set\n-# CT_ARCH_m68k is not set\n-# CT_ARCH_mips is not set\n-# CT_ARCH_nios2 is not set\n-# CT_ARCH_powerpc is not set\n-# CT_ARCH_s390 is not set\n-# CT_ARCH_sh is not set\n-# CT_ARCH_sparc is not set\n-# CT_ARCH_x86 is not set\n-# CT_ARCH_xtensa is not set\n-CT_ARCH_alpha_AVAILABLE=y\n-CT_ARCH_arm_AVAILABLE=y\n-CT_ARCH_avr_AVAILABLE=y\n-CT_ARCH_m68k_AVAILABLE=y\n-CT_ARCH_microblaze_AVAILABLE=y\n-CT_ARCH_mips_AVAILABLE=y\n-CT_ARCH_nios2_AVAILABLE=y\n-CT_ARCH_powerpc_AVAILABLE=y\n-CT_ARCH_s390_AVAILABLE=y\n-CT_ARCH_sh_AVAILABLE=y\n-CT_ARCH_sparc_AVAILABLE=y\n-CT_ARCH_x86_AVAILABLE=y\n-CT_ARCH_xtensa_AVAILABLE=y\n+CT_ARCH_ARM_SHOW=y\n+\n+#\n+# Options for arm\n+#\n+CT_ARCH_ARM_PKG_KSYM=\"\"\n+CT_ARCH_ARM_MODE=\"arm\"\n+CT_ARCH_ARM_MODE_ARM=y\n+# CT_ARCH_ARM_MODE_THUMB is not set\n+# CT_ARCH_ARM_INTERWORKING is not set\n+CT_ARCH_ARM_EABI_FORCE=y\n+CT_ARCH_ARM_EABI=y\n+CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n \n #\n # Generic target options\n #\n # CT_MULTILIB is not set\n+CT_DEMULTILIB=y\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_DEFAULT_HAS_MMU=y\n CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_FLAT_FORMAT=y\n+CT_ARCH_SUPPORTS_EITHER_ENDIAN=y\n+CT_ARCH_DEFAULT_LE=y\n+# CT_ARCH_BE is not set\n+CT_ARCH_LE=y\n CT_ARCH_ENDIAN=\"little\"\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=32\n+CT_ARCH_32=y\n+# CT_ARCH_64 is not set\n \n #\n # Target optimisations\n #\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_CPU=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_SUPPORTS_WITH_FLOAT=y\n+CT_ARCH_SUPPORTS_WITH_FPU=y\n+CT_ARCH_SUPPORTS_SOFTFP=y\n CT_ARCH_EXCLUSIVE_WITH_CPU=y\n+CT_ARCH_ARCH=\"armv6\"\n+CT_ARCH_FPU=\"vfp\"\n # CT_ARCH_FLOAT_AUTO is not set\n+CT_ARCH_FLOAT_HW=y\n # CT_ARCH_FLOAT_SOFTFP is not set\n+# CT_ARCH_FLOAT_SW is not set\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n CT_ARCH_FLOAT=\"hard\"\n \n-#\n-# arm other options\n-#\n-CT_ARCH_ARM_MODE=\"arm\"\n-CT_ARCH_ARM_MODE_ARM=y\n-# CT_ARCH_ARM_MODE_THUMB is not set\n-# CT_ARCH_ARM_INTERWORKING is not set\n-CT_ARCH_ARM_EABI_FORCE=y\n-CT_ARCH_ARM_EABI=y\n-CT_ARCH_ARM_TUPLE_USE_EABIHF=y\n-\n #\n # Toolchain options\n #\n@@ -182,7 +210,9 @@ CT_USE_SYSROOT=y\n CT_SYSROOT_NAME=\"sysroot\"\n CT_SYSROOT_DIR_PREFIX=\"\"\n CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n # CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n CT_TOOLCHAIN_PKGVERSION=\"\"\n CT_TOOLCHAIN_BUGURL=\"\"\n \n@@ -216,227 +246,287 @@ CT_BUILD_SUFFIX=\"\"\n # Operating System\n #\n CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n CT_KERNEL=\"linux\"\n-CT_KERNEL_VERSION=\"3.2.72\"\n-# CT_KERNEL_bare_metal is not set\n-CT_KERNEL_linux=y\n-CT_KERNEL_bare_metal_AVAILABLE=y\n-CT_KERNEL_linux_AVAILABLE=y\n-# CT_KERNEL_V_4_3 is not set\n-# CT_KERNEL_V_4_2 is not set\n-# CT_KERNEL_V_4_1 is not set\n-# CT_KERNEL_V_3_18 is not set\n-# CT_KERNEL_V_3_14 is not set\n-# CT_KERNEL_V_3_12 is not set\n-# CT_KERNEL_V_3_10 is not set\n-# CT_KERNEL_V_3_4 is not set\n-CT_KERNEL_V_3_2=y\n-# CT_KERNEL_V_2_6_32 is not set\n-# CT_KERNEL_LINUX_CUSTOM is not set\n-CT_KERNEL_windows_AVAILABLE=y\n-\n-#\n-# Common kernel options\n-#\n-CT_SHARED_LIBS=y\n-\n-#\n-# linux other options\n-#\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+CT_LINUX_PATCH_ORDER=\"global\"\n+# CT_LINUX_V_4_20 is not set\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+CT_LINUX_V_3_2=y\n+# CT_LINUX_V_2_6_32 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"3.2.101\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_4_8_or_older=y\n+CT_LINUX_older_than_4_8=y\n+CT_LINUX_3_7_or_older=y\n+CT_LINUX_older_than_3_7=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n CT_KERNEL_LINUX_VERBOSITY_0=y\n # CT_KERNEL_LINUX_VERBOSITY_1 is not set\n # CT_KERNEL_LINUX_VERBOSITY_2 is not set\n CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n \n #\n # Binary utilities\n #\n CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n CT_BINUTILS=\"binutils\"\n-CT_BINUTILS_binutils=y\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n \n #\n # GNU binutils\n #\n-# CT_CC_BINUTILS_SHOW_LINARO is not set\n-CT_BINUTILS_V_2_25_1=y\n-# CT_BINUTILS_V_2_25 is not set\n-# CT_BINUTILS_V_2_24 is not set\n-# CT_BINUTILS_V_2_23_2 is not set\n-# CT_BINUTILS_V_2_23_1 is not set\n-# CT_BINUTILS_V_2_22 is not set\n-# CT_BINUTILS_V_2_21_53 is not set\n-# CT_BINUTILS_V_2_21_1a is not set\n-# CT_BINUTILS_V_2_20_1a is not set\n-# CT_BINUTILS_V_2_19_1a is not set\n-# CT_BINUTILS_V_2_18a is not set\n-CT_BINUTILS_VERSION=\"2.25.1\"\n-CT_BINUTILS_2_25_1_or_later=y\n-CT_BINUTILS_2_25_or_later=y\n-CT_BINUTILS_2_24_or_later=y\n-CT_BINUTILS_2_23_or_later=y\n-CT_BINUTILS_2_22_or_later=y\n-CT_BINUTILS_2_21_or_later=y\n-CT_BINUTILS_2_20_or_later=y\n-CT_BINUTILS_2_19_or_later=y\n-CT_BINUTILS_2_18_or_later=y\n CT_BINUTILS_HAS_HASH_STYLE=y\n CT_BINUTILS_HAS_GOLD=y\n-CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n-CT_BINUTILS_GOLD_SUPPORT=y\n CT_BINUTILS_HAS_PLUGINS=y\n CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n-CT_BINUTILS_FORCE_LD_BFD=y\n+CT_BINUTILS_GOLD_SUPPORTS_ARCH=y\n+CT_BINUTILS_GOLD_SUPPORT=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n CT_BINUTILS_LINKER_LD=y\n # CT_BINUTILS_LINKER_LD_GOLD is not set\n-# CT_BINUTILS_LINKER_GOLD_LD is not set\n CT_BINUTILS_LINKERS_LIST=\"ld\"\n CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n # CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # CT_BINUTILS_FOR_TARGET is not set\n-\n-#\n-# binutils other options\n-#\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n \n #\n # C-library\n #\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_NEWLIB is not set\n+# CT_LIBC_NONE is not set\n+# CT_LIBC_UCLIBC is not set\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.16.0\"\n-CT_LIBC_glibc=y\n-# CT_LIBC_musl is not set\n-# CT_LIBC_uClibc is not set\n-CT_LIBC_avr_libc_AVAILABLE=y\n-CT_LIBC_glibc_AVAILABLE=y\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n CT_THREADS=\"nptl\"\n-# CT_CC_GLIBC_SHOW_LINARO is not set\n-# CT_LIBC_GLIBC_V_2_22 is not set\n-# CT_LIBC_GLIBC_V_2_21 is not set\n-# CT_LIBC_GLIBC_V_2_20 is not set\n-# CT_LIBC_GLIBC_V_2_19 is not set\n-# CT_LIBC_GLIBC_V_2_18 is not set\n-# CT_LIBC_GLIBC_V_2_17 is not set\n-CT_LIBC_GLIBC_V_2_16_0=y\n-# CT_LIBC_GLIBC_V_2_15 is not set\n-# CT_LIBC_GLIBC_V_2_14_1 is not set\n-# CT_LIBC_GLIBC_V_2_14 is not set\n-# CT_LIBC_GLIBC_V_2_13 is not set\n-# CT_LIBC_GLIBC_V_2_12_2 is not set\n-# CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n-# CT_LIBC_GLIBC_V_2_11 is not set\n-# CT_LIBC_GLIBC_V_2_10_1 is not set\n-# CT_LIBC_GLIBC_V_2_9 is not set\n-# CT_LIBC_GLIBC_V_2_8 is not set\n-CT_LIBC_mingw_AVAILABLE=y\n-CT_LIBC_musl_AVAILABLE=y\n-CT_LIBC_newlib_AVAILABLE=y\n-CT_LIBC_none_AVAILABLE=y\n-CT_LIBC_uClibc_AVAILABLE=y\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+# CT_GLIBC_V_2_28 is not set\n+# CT_GLIBC_V_2_27 is not set\n+# CT_GLIBC_V_2_26 is not set\n+# CT_GLIBC_V_2_25 is not set\n+# CT_GLIBC_V_2_24 is not set\n+# CT_GLIBC_V_2_23 is not set\n+# CT_GLIBC_V_2_19 is not set\n+CT_GLIBC_V_2_17=y\n+# CT_GLIBC_V_2_12_1 is not set\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.17\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_older_than_2_29=y\n+CT_GLIBC_REQUIRE_older_than_2_29=y\n+CT_GLIBC_2_27_or_older=y\n+CT_GLIBC_older_than_2_27=y\n+CT_GLIBC_2_26_or_older=y\n+CT_GLIBC_older_than_2_26=y\n+CT_GLIBC_2_25_or_older=y\n+CT_GLIBC_older_than_2_25=y\n+CT_GLIBC_2_24_or_older=y\n+CT_GLIBC_older_than_2_24=y\n+CT_GLIBC_2_23_or_older=y\n+CT_GLIBC_older_than_2_23=y\n+CT_GLIBC_2_20_or_older=y\n+CT_GLIBC_older_than_2_20=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_2_17_or_older=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_HAS_NPTL_ADDON=y\n+CT_GLIBC_HAS_PORTS_ADDON=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+CT_GLIBC_USE_PORTS_ADDON=y\n+CT_GLIBC_USE_NPTL_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+# CT_GLIBC_KERNEL_VERSION_NONE is not set\n+CT_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"3.2.101\"\n+# CT_GLIBC_SSP_DEFAULT is not set\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_NEWLIB_USE_REDHAT is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n CT_LIBC_SUPPORT_THREADS_ANY=y\n CT_LIBC_SUPPORT_THREADS_NATIVE=y\n \n #\n # Common C library options\n #\n CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n CT_LIBC_XLDD=y\n \n-#\n-# glibc other options\n-#\n-CT_LIBC_GLIBC_PORTS_EXTERNAL=y\n-CT_LIBC_GLIBC_MAY_FORCE_PORTS=y\n-CT_LIBC_glibc_familly=y\n-CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_LIBC_GLIBC_CONFIGPARMS=\"\"\n-CT_LIBC_GLIBC_EXTRA_CFLAGS=\"\"\n-CT_LIBC_EXTRA_CC_ARGS=\"\"\n-# CT_LIBC_DISABLE_VERSIONING is not set\n-CT_LIBC_OLDEST_ABI=\"\"\n-CT_LIBC_GLIBC_FORCE_UNWIND=y\n-CT_LIBC_GLIBC_USE_PORTS=y\n-CT_LIBC_ADDONS_LIST=\"\"\n-\n-#\n-# WARNING !!!                                            \n-#\n-\n-#\n-#   For glibc >= 2.8, it can happen that the tarballs    \n-#\n-\n-#\n-#   for the addons are not available for download.       \n-#\n-\n-#\n-#   If that happens, bad luck... Try a previous version  \n-#\n-\n-#\n-#   or try again later... :-(                            \n-#\n-# CT_LIBC_LOCALES is not set\n-# CT_LIBC_GLIBC_KERNEL_VERSION_NONE is not set\n-CT_LIBC_GLIBC_KERNEL_VERSION_AS_HEADERS=y\n-# CT_LIBC_GLIBC_KERNEL_VERSION_CHOSEN is not set\n-CT_LIBC_GLIBC_MIN_KERNEL=\"3.2.72\"\n-\n #\n # C compiler\n #\n-CT_CC=\"gcc\"\n CT_CC_CORE_PASSES_NEEDED=y\n CT_CC_CORE_PASS_1_NEEDED=y\n CT_CC_CORE_PASS_2_NEEDED=y\n-CT_CC_gcc=y\n-# CT_CC_GCC_SHOW_LINARO is not set\n-CT_CC_GCC_V_5_2_0=y\n-# CT_CC_GCC_V_4_9_3 is not set\n-# CT_CC_GCC_V_4_8_5 is not set\n-# CT_CC_GCC_V_4_7_4 is not set\n-# CT_CC_GCC_V_4_6_4 is not set\n-# CT_CC_GCC_V_4_5_4 is not set\n-# CT_CC_GCC_V_4_4_7 is not set\n-# CT_CC_GCC_V_4_3_6 is not set\n-# CT_CC_GCC_V_4_2_4 is not set\n-CT_CC_GCC_4_2_or_later=y\n-CT_CC_GCC_4_3_or_later=y\n-CT_CC_GCC_4_4_or_later=y\n-CT_CC_GCC_4_5_or_later=y\n-CT_CC_GCC_4_6_or_later=y\n-CT_CC_GCC_4_7_or_later=y\n-CT_CC_GCC_4_8_or_later=y\n-CT_CC_GCC_4_9_or_later=y\n-CT_CC_GCC_5=y\n-CT_CC_GCC_5_or_later=y\n-CT_CC_GCC_HAS_GRAPHITE=y\n-CT_CC_GCC_USE_GRAPHITE=y\n-CT_CC_GCC_HAS_LTO=y\n-CT_CC_GCC_USE_LTO=y\n-CT_CC_GCC_HAS_PKGVERSION_BUGURL=y\n-CT_CC_GCC_HAS_BUILD_ID=y\n-CT_CC_GCC_HAS_LNK_HASH_STYLE=y\n-CT_CC_GCC_USE_GMP_MPFR=y\n-CT_CC_GCC_USE_MPC=y\n-CT_CC_GCC_HAS_LIBQUADMATH=y\n-CT_CC_GCC_HAS_LIBSANITIZER=y\n-CT_CC_GCC_VERSION=\"5.2.0\"\n-# CT_CC_LANG_FORTRAN is not set\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_V_6 is not set\n+# CT_GCC_V_5 is not set\n+# CT_GCC_V_4_9 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n-CT_CC_GCC_EXTRA_ENV_ARRAY=\"\"\n CT_CC_GCC_STATIC_LIBSTDCXX=y\n # CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n \n #\n # Optimisation features\n #\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n \n #\n # Settings for libraries running on target\n@@ -465,97 +555,208 @@ CT_CC_GCC_DEC_FLOAT_AUTO=y\n # CT_CC_GCC_DEC_FLOAT_BID is not set\n # CT_CC_GCC_DEC_FLOAT_DPD is not set\n # CT_CC_GCC_DEC_FLOATS_NO is not set\n-CT_CC_SUPPORT_CXX=y\n-CT_CC_SUPPORT_FORTRAN=y\n-CT_CC_SUPPORT_JAVA=y\n-CT_CC_SUPPORT_ADA=y\n-CT_CC_SUPPORT_OBJC=y\n-CT_CC_SUPPORT_OBJCXX=y\n-CT_CC_SUPPORT_GOLANG=y\n+CT_ALL_CC_CHOICES=\"GCC\"\n \n #\n # Additional supported languages:\n #\n CT_CC_LANG_CXX=y\n-# CT_CC_LANG_JAVA is not set\n+# CT_CC_LANG_FORTRAN is not set\n \n #\n # Debug facilities\n #\n-# CT_DEBUG_dmalloc is not set\n-# CT_DEBUG_duma is not set\n-# CT_DEBUG_gdb is not set\n-# CT_DEBUG_ltrace is not set\n-# CT_DEBUG_strace is not set\n+# CT_DEBUG_DUMA is not set\n+# CT_DEBUG_GDB is not set\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n \n #\n # Companion libraries\n #\n-CT_COMPLIBS_NEEDED=y\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+# CT_COMP_LIBS_EXPAT is not set\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n CT_LIBICONV_NEEDED=y\n CT_GETTEXT_NEEDED=y\n CT_GMP_NEEDED=y\n CT_MPFR_NEEDED=y\n CT_ISL_NEEDED=y\n CT_MPC_NEEDED=y\n-CT_COMPLIBS=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n CT_LIBICONV=y\n CT_GETTEXT=y\n CT_GMP=y\n CT_MPFR=y\n CT_ISL=y\n CT_MPC=y\n-CT_LIBICONV_V_1_14=y\n-CT_LIBICONV_VERSION=\"1.14\"\n-CT_GETTEXT_V_0_19_6=y\n-CT_GETTEXT_VERSION=\"0.19.6\"\n-CT_GMP_V_6_0_0=y\n-# CT_GMP_V_5_1_3 is not set\n-# CT_GMP_V_5_1_1 is not set\n-# CT_GMP_V_5_0_2 is not set\n-# CT_GMP_V_5_0_1 is not set\n-# CT_GMP_V_4_3_2 is not set\n-# CT_GMP_V_4_3_1 is not set\n-# CT_GMP_V_4_3_0 is not set\n-CT_GMP_5_0_2_or_later=y\n-CT_GMP_VERSION=\"6.0.0a\"\n-CT_MPFR_V_3_1_3=y\n-# CT_MPFR_V_3_1_2 is not set\n-# CT_MPFR_V_3_1_0 is not set\n-# CT_MPFR_V_3_0_1 is not set\n-# CT_MPFR_V_3_0_0 is not set\n-# CT_MPFR_V_2_4_2 is not set\n-# CT_MPFR_V_2_4_1 is not set\n-# CT_MPFR_V_2_4_0 is not set\n-CT_MPFR_VERSION=\"3.1.3\"\n-CT_ISL_V_0_14=y\n-# CT_ISL_V_0_12_2 is not set\n-CT_ISL_V_0_14_or_later=y\n-CT_ISL_V_0_12_or_later=y\n-CT_ISL_VERSION=\"0.14\"\n-# CT_CLOOG_V_0_18_4 is not set\n-# CT_CLOOG_V_0_18_1 is not set\n-# CT_CLOOG_V_0_18_0 is not set\n-CT_MPC_V_1_0_3=y\n-# CT_MPC_V_1_0_2 is not set\n-# CT_MPC_V_1_0_1 is not set\n-# CT_MPC_V_1_0 is not set\n-# CT_MPC_V_0_9 is not set\n-# CT_MPC_V_0_8_2 is not set\n-# CT_MPC_V_0_8_1 is not set\n-# CT_MPC_V_0_7 is not set\n-CT_MPC_VERSION=\"1.0.3\"\n-\n-#\n-# Companion libraries common options\n-#\n-# CT_COMPLIBS_CHECK is not set\n+CT_NCURSES=y\n+CT_ZLIB=y\n \n #\n # Companion tools\n #\n-\n-#\n-# READ HELP before you say 'Y' below !!!\n-#\n-# CT_COMP_TOOLS is not set\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\""}, {"sha": "871d5225c0f714e035a0d97c7c2d841acfa09431", "filename": "src/ci/docker/dist-armhf-linux/patches/glibc/ports-2.16.0/001-arm-libgcc_s_resume-used.patch", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2Fpatches%2Fglibc%2Fports-2.16.0%2F001-arm-libgcc_s_resume-used.patch?ref=374ab25585f0a817fe7bd6986737f12347b12d0b", "patch": "@@ -1,48 +0,0 @@\n-commit bdb24c2851fd5f0ad9b82d7ea1db911d334b02d2\n-Author: Joseph Myers <joseph@codesourcery.com>\n-Date:   Tue May 20 21:27:13 2014 +0000\n-\n-    Fix ARM build with GCC trunk.\n-    \n-    sysdeps/unix/sysv/linux/arm/unwind-resume.c and\n-    sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c have static\n-    variables that are written in C code but only read from toplevel asms.\n-    Current GCC trunk now optimizes away such apparently write-only static\n-    variables, so causing a build failure.  This patch marks those\n-    variables with __attribute_used__ to avoid that optimization.\n-    \n-    Tested that this fixes the build for ARM.\n-    \n-            * sysdeps/unix/sysv/linux/arm/unwind-forcedunwind.c\n-            (libgcc_s_resume): Use __attribute_used__.\n-            * sysdeps/unix/sysv/linux/arm/unwind-resume.c (libgcc_s_resume):\n-            Likewise.\n-\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-index 29e2c2b00b04..e848bfeffdcb 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-forcedunwind.c\n-@@ -22,7 +22,8 @@\n- #include <pthreadP.h>\n- \n- static void *libgcc_s_handle;\n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- static _Unwind_Reason_Code (*libgcc_s_forcedunwind)\n-diff --git a/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c b/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-index 285b99b5ed0d..48d00fc83641 100644\n---- a/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-+++ b/ports/sysdeps/unix/sysv/linux/arm/nptl/unwind-resume.c\n-@@ -20,7 +20,8 @@\n- #include <stdio.h>\n- #include <unwind.h>\n- \n--static void (*libgcc_s_resume) (struct _Unwind_Exception *exc);\n-+static void (*libgcc_s_resume) (struct _Unwind_Exception *exc)\n-+  __attribute_used__;\n- static _Unwind_Reason_Code (*libgcc_s_personality)\n-   (_Unwind_State, struct _Unwind_Exception *, struct _Unwind_Context *);\n- "}, {"sha": "649049da5dfe314719af3cfd920eb0ad9d83def6", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -3,8 +3,8 @@ FROM ubuntu:16.04\n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-COPY dist-armv7-linux/crosstool-ng.sh /scripts/\n-RUN sh /scripts/crosstool-ng.sh\n+COPY scripts/crosstool-ng-1.24.sh /scripts/\n+RUN sh /scripts/crosstool-ng-1.24.sh\n \n COPY scripts/rustbuild-setup.sh /scripts/\n RUN sh /scripts/rustbuild-setup.sh\n@@ -27,5 +27,5 @@ ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=armv7-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV RUST_CONFIGURE_ARGS --enable-full-tools --disable-docs\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "996fffeb871cfc9f7f6fe23e08f7ac33cc7b11ae", "filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   xz-utils \\\n@@ -46,5 +46,5 @@ ENV CFLAGS_i586_unknown_linux_musl=-Wa,-mrelax-relocations=no\n ENV TARGETS=i586-unknown-linux-gnu,i686-unknown-linux-musl\n \n ENV SCRIPT \\\n-      python2.7 ../x.py test --target $TARGETS && \\\n-      python2.7 ../x.py dist --target $TARGETS,i586-unknown-linux-musl\n+      python3 ../x.py test --target $TARGETS && \\\n+      python3 ../x.py dist --target $TARGETS,i586-unknown-linux-musl"}, {"sha": "7978bb70869652f8e5c39ad66f2bff6a27a9ee5f", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -30,4 +30,4 @@ ENV \\\n ENV HOSTS=i686-unknown-freebsd\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "57a7fc25b5c13ead0cf11168a452b053c94dd58c", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mips-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "63f1028e2be593db9db9c0e533f9ae6c2f0a5f6c", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -22,4 +22,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mips64-unknown-linux-gnuabi64\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a51edbc9c7923a49d0684efe54e5df4d0096f595", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mips64el-unknown-linux-gnuabi64\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "908cef90cef6900c801a8fab567b0a1f5e8587c5", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -22,4 +22,4 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=mipsel-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "b8792b0c7fa92711f9fe339b0293dda51751860c", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -35,4 +35,4 @@ ENV \\\n ENV HOSTS=powerpc-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "a790a143ac5e73918269a35c5e147a7aee13d765", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -36,4 +36,4 @@ ENV \\\n ENV HOSTS=powerpc64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5c17bc321c1712d8eb4b5cc7baedb3dd4503c851", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -33,4 +33,4 @@ ENV \\\n ENV HOSTS=powerpc64le-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "76d29a471c3967e14451c71495299bb3857ff65f", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -35,4 +35,4 @@ ENV \\\n ENV HOSTS=s390x-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "35b598e20f09932d3fc683f8406e90b8bdf60396", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -18,7 +18,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n   python3 \\\n   git \\\n   cmake \\\n@@ -72,6 +71,9 @@ RUN ./install-mips-musl.sh\n COPY dist-various-1/install-mipsel-musl.sh /build\n RUN ./install-mipsel-musl.sh\n \n+COPY dist-various-1/install-aarch64-none-elf.sh /build\n+RUN ./install-aarch64-none-elf.sh\n+\n # Suppress some warnings in the openwrt toolchains we downloaded\n ENV STAGING_DIR=/tmp\n \n@@ -140,6 +142,8 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n+ENV TARGETS=$TARGETS,aarch64-unknown-none\n+ENV TARGETS=$TARGETS,aarch64-unknown-none-softfloat\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n@@ -178,6 +182,10 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_armv7a_none_eabihf=arm-none-eabi-gcc \\\n     CFLAGS_armv7a_none_eabi=-march=armv7-a \\\n     CFLAGS_armv7a_none_eabihf=-march=armv7-a+vfpv3 \\\n+    CC_aarch64_unknown_none_softfloat=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none_softfloat=-mstrict-align -march=armv8-a+nofp+nosimd \\\n+    CC_aarch64_unknown_none=aarch64-none-elf-gcc \\\n+    CFLAGS_aarch64_unknown_none=-mstrict-align -march=armv8-a+fp+simd \\\n     CC_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-gcc \\\n     AR_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-ar \\\n     CXX_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-g++ \\\n@@ -200,8 +208,8 @@ ENV RUST_CONFIGURE_ARGS \\\n       --disable-docs\n \n ENV SCRIPT \\\n-      python2.7 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n-      python2.7 ../x.py dist --target $TARGETS\n+      python3 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n+      python3 ../x.py dist --target $TARGETS\n \n # sccache\n COPY scripts/sccache.sh /scripts/"}, {"sha": "d72976c28584225902eeed7ede849610ce3ee586", "filename": "src/ci/docker/dist-various-1/install-aarch64-none-elf.sh", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-aarch64-none-elf.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,6 @@\n+#!/usr/bin/env bash\n+\n+set -ex\n+\n+curl -L https://developer.arm.com/-/media/Files/downloads/gnu-a/9.2-2019.12/binrel/gcc-arm-9.2-2019.12-x86_64-aarch64-none-elf.tar.xz \\\n+| tar --extract --xz --strip 1 --directory /usr/local"}, {"sha": "5864b5ffab28601bb9e96cb4ab8a24a1345e1a46", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no\n   libmpfr-dev \\\n   ninja-build \\\n   nodejs \\\n-  python2.7-dev \\\n+  python3-dev \\\n   software-properties-common \\\n   unzip \\\n   # Needed for apt-key to work:\n@@ -110,4 +110,4 @@ ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n   --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n   --musl-root-armv7=/musl-armv7\n \n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+ENV SCRIPT python3 ../x.py dist --target $TARGETS"}, {"sha": "12170a366148755d884b97eb93cfaeb29e82cc2b", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -30,4 +30,4 @@ ENV \\\n ENV HOSTS=x86_64-unknown-freebsd\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "c026506b106618709844c4d7daa534eb9440cb99", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -7,7 +7,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   wget \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   xz-utils \\\n@@ -34,6 +34,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n       --enable-extended \\\n       --disable-docs \\\n+      --enable-lld \\\n       --set target.x86_64-unknown-linux-musl.crt-static=false \\\n       --build $HOSTS\n \n@@ -47,4 +48,4 @@ ENV CFLAGS_x86_64_unknown_linux_musl=\"-Wa,-mrelax-relocations=no -Wa,--compress-\n     -Wl,--compress-debug-sections=none\"\n \n # To run native tests replace `dist` below with `test`\n-ENV SCRIPT python2.7 ../x.py dist --build $HOSTS\n+ENV SCRIPT python3 ../x.py dist --build $HOSTS"}, {"sha": "135bb33cef71728f24cbc1bffc2956ed8e4e4f57", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -19,4 +19,4 @@ ENV \\\n ENV HOSTS=x86_64-unknown-netbsd\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "c15b437e6d3157dea376b816c82172a449564a41", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -18,7 +18,7 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n-ENV SCRIPT python2.7 ../x.py test\n+ENV SCRIPT python3 ../x.py test\n \n # FIXME(#59637) takes too long on CI right now\n ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "377f07cef4e46e7444e7a21eea56d742e2eafa56", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -20,7 +20,7 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n # Exclude some tests that are unlikely to be platform specific, to speed up\n # this slow job.\n-ENV SCRIPT python2.7 ../x.py test \\\n+ENV SCRIPT python3 ../x.py test \\\n   --exclude src/bootstrap \\\n   --exclude src/test/rustdoc-js \\\n   --exclude src/tools/error_index_generator \\"}, {"sha": "97e4d3fd7499e92ad4fbbc63a0f8efc52756c4f5", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -22,8 +22,10 @@ RUN sh /scripts/sccache.sh\n COPY mingw-check/validate-toolstate.sh /scripts/\n \n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n-ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n-           python2.7 ../x.py build --stage 0 src/tools/build-manifest && \\\n-           python2.7 ../x.py test --stage 0 src/tools/compiletest && \\\n-           python2.7 ../x.py test src/tools/tidy && \\\n+ENV SCRIPT python3 ../x.py test src/tools/expand-yaml-anchors && \\\n+           python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n+           python3 ../x.py build --stage 0 src/tools/build-manifest && \\\n+           python3 ../x.py test --stage 0 src/tools/compiletest && \\\n+           python3 ../x.py test src/tools/tidy && \\\n+           python3 ../x.py doc --stage 0 src/libstd && \\\n            /scripts/validate-toolstate.sh"}, {"sha": "c6d728eb80dd080377bf0a575b30cd828b49ab26", "filename": "src/ci/docker/mingw-check/validate-toolstate.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2Fvalidate-toolstate.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -7,12 +7,12 @@ IFS=$'\\n\\t'\n rm -rf rust-toolstate\n git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n cd rust-toolstate\n-python2.7 \"../../src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \\\n+python3 \"../../src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \\\n     \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n # Only check maintainers if this build is supposed to publish toolstate.\n # Builds that are not supposed to publish don't have the access token.\n if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n-  TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python2.7 \\\n+  TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python3 \\\n       \"../../src/tools/publish_toolstate.py\"\n fi\n cd .."}, {"sha": "d891ad1b6680e622323b7bbd21632d21a3e81fb2", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -17,6 +17,8 @@ dist=$objdir/build/dist\n \n source \"$ci_dir/shared.sh\"\n \n+CACHE_DOMAIN=\"${CACHE_DOMAIN:-ci-caches.rust-lang.org}\"\n+\n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n     if [ \"$CI\" != \"\" ]; then\n       hash_key=/tmp/.docker-hash-key.txt\n@@ -38,9 +40,7 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       cksum=$(sha512sum $hash_key | \\\n         awk '{print $1}')\n \n-      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n-      url=\"https://$SCCACHE_BUCKET.s3.amazonaws.com/docker/$cksum\"\n-      upload=\"aws s3 cp - $s3url\"\n+      url=\"https://$CACHE_DOMAIN/docker/$cksum\"\n \n       echo \"Attempting to download $url\"\n       rm -f /tmp/rustci_docker_cache\n@@ -65,7 +65,9 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -f \"$dockerfile\" \\\n       \"$context\"\n \n-    if [ \"$upload\" != \"\" ]; then\n+    if [ \"$CI\" != \"\" ]; then\n+      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n+      upload=\"aws s3 cp - $s3url\"\n       digest=$(docker inspect rust-ci --format '{{.Id}}')\n       echo \"Built container $digest\"\n       if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then"}, {"sha": "391b68ea637b0e4f4d1162fae217203a7a7ec4cc", "filename": "src/ci/docker/scripts/android-base-apt-get.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fandroid-base-apt-get.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fandroid-base-apt-get.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-base-apt-get.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -11,7 +11,7 @@ apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   make \\\n   pkg-config \\\n-  python2.7 \\\n+  python3 \\\n   sudo \\\n   unzip \\\n   xz-utils"}, {"sha": "dafcb3cb7a719a1a11a69bdc86f333a588c03551", "filename": "src/ci/docker/scripts/android-ndk.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -13,7 +13,7 @@ download_ndk() {\n \n make_standalone_toolchain() {\n     # See https://developer.android.com/ndk/guides/standalone_toolchain.htm\n-    python2.7 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n+    python3 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n         --install-dir /android/ndk/$1-$2 \\\n         --arch $1 \\\n         --api $2"}, {"sha": "7030cd74cae232c5e4a2aec35ae8d13ec0261b45", "filename": "src/ci/docker/scripts/cross-apt-packages.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -19,7 +19,7 @@ apt-get update && apt-get install -y --no-install-recommends \\\n   make \\\n   patch \\\n   pkg-config \\\n-  python2.7 \\\n+  python3 \\\n   sudo \\\n   texinfo \\\n   unzip \\"}, {"sha": "fb067a79a5c85c93691cdf5244394982d465289f", "filename": "src/ci/docker/scripts/crosstool-ng-1.24.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-1.24.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "previous_filename": "src/ci/docker/dist-armv7-linux/crosstool-ng.sh"}, {"sha": "9276e4ed82d78b2c886980927830b1310b25f4d3", "filename": "src/ci/docker/test-various/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -40,7 +40,7 @@ ENV RUST_CONFIGURE_ARGS \\\n ENV NO_DEBUG_ASSERTIONS=1\n \n ENV WASM_TARGETS=wasm32-unknown-unknown\n-ENV WASM_SCRIPT python2.7 /checkout/x.py test --target $WASM_TARGETS \\\n+ENV WASM_SCRIPT python3 /checkout/x.py test --target $WASM_TARGETS \\\n   src/test/run-make \\\n   src/test/ui \\\n   src/test/compile-fail \\\n@@ -49,13 +49,13 @@ ENV WASM_SCRIPT python2.7 /checkout/x.py test --target $WASM_TARGETS \\\n   src/libcore\n \n ENV NVPTX_TARGETS=nvptx64-nvidia-cuda\n-ENV NVPTX_SCRIPT python2.7 /checkout/x.py test --target $NVPTX_TARGETS \\\n+ENV NVPTX_SCRIPT python3 /checkout/x.py test --target $NVPTX_TARGETS \\\n   src/test/run-make \\\n   src/test/assembly\n \n ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n     CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n     CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n-ENV MUSL_SCRIPT python2.7 /checkout/x.py test --target $MUSL_TARGETS\n+ENV MUSL_SCRIPT python3 /checkout/x.py test --target $MUSL_TARGETS\n \n ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT"}, {"sha": "91c492d03c179dcdc073b1444ea2ad73fcc2e254", "filename": "src/ci/docker/wasm32/Dockerfile", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -20,6 +20,9 @@ RUN bash /scripts/emscripten.sh\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+# emcc seems to need python to specifically be \"python\" and not \"python3\"\n+RUN ln `which python3` /usr/bin/python\n+\n ENV PATH=$PATH:/emsdk-portable\n ENV PATH=$PATH:/emsdk-portable/upstream/emscripten/\n ENV PATH=$PATH:/emsdk-portable/node/12.9.1_64bit/bin/\n@@ -35,7 +38,7 @@ ENV NO_CHANGE_USER=1\n \n # FIXME: Re-enable these tests once https://github.com/rust-lang/cargo/pull/7476\n # is picked up by CI\n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n+ENV SCRIPT python3 ../x.py test --target $TARGETS \\\n     --exclude src/libcore \\\n     --exclude src/liballoc \\\n     --exclude src/libproc_macro \\"}, {"sha": "86ac0256d28201cd90cf9977171adf8e7fc9365f", "filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   libssl-dev \\"}, {"sha": "c5e41b8a75afe506048fa18eba18a27da91ae2d0", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,8 +6,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n-  python2.7-dev \\\n+  python3 \\\n+  python3-dev \\\n   libxml2-dev \\\n   libncurses-dev \\\n   libedit-dev \\\n@@ -40,5 +40,5 @@ ENV RUST_CONFIGURE_ARGS \\\n       --set target.x86_64-unknown-linux-gnu.cxx=clang++\n \n ENV SCRIPT \\\n-  python2.7 ../x.py build && \\\n-  python2.7 ../x.py test src/test/run-make-fulldeps --test-args clang\n+  python3 ../x.py build && \\\n+  python3 ../x.py test src/test/run-make-fulldeps --test-args clang"}, {"sha": "cc07a591cc17bec1c7d1d853f8216f75165aa98f", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -19,7 +19,7 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --set rust.ignore-git=false\n-ENV SCRIPT python2.7 ../x.py test distcheck\n+ENV SCRIPT python3 ../x.py test distcheck\n ENV DIST_SRC 1\n \n # The purpose of this builder is to test that we can `./x.py test` successfully"}, {"sha": "de7ee6950b51b26ca00c06b2c32af0bf8b2c51f0", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -21,7 +21,7 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-full-bootstrap\n-ENV SCRIPT python2.7 ../x.py build\n+ENV SCRIPT python3 ../x.py build\n \n # In general this just slows down the build and we're just a smoke test that\n # a full bootstrap works in general, so there's not much need to take this"}, {"sha": "4b5d5cac5163cc1f46cacbe3c9f806dcbe1adcb7", "filename": "src/ci/docker/x86_64-gnu-llvm-7/Dockerfile", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-7%2FDockerfile?ref=374ab25585f0a817fe7bd6986737f12347b12d0b", "patch": "@@ -1,38 +0,0 @@\n-FROM ubuntu:18.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  llvm-7-tools \\\n-  libedit-dev \\\n-  libssl-dev \\\n-  pkg-config \\\n-  zlib1g-dev \\\n-  xz-utils \\\n-  nodejs\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-# using llvm-link-shared due to libffi issues -- see #34486\n-ENV RUST_CONFIGURE_ARGS \\\n-      --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-7 \\\n-      --enable-llvm-link-shared \\\n-      --set rust.thin-lto-import-instr-limit=10\n-\n-ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && python2.7 ../x.py test src/tools/tidy\n-\n-# The purpose of this container isn't to test with debug assertions and\n-# this is run on all PRs, so let's get speedier builds by disabling these extra\n-# checks.\n-ENV NO_DEBUG_ASSERTIONS=1\n-ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "58fdc6f262376c8cc26a2484653be4672df7ffe4", "filename": "src/ci/docker/x86_64-gnu-llvm-8/Dockerfile", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-8%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,55 @@\n+FROM ubuntu:18.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  g++-arm-linux-gnueabi \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  llvm-8-tools \\\n+  libedit-dev \\\n+  libssl-dev \\\n+  pkg-config \\\n+  zlib1g-dev \\\n+  xz-utils \\\n+  nodejs\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# using llvm-link-shared due to libffi issues -- see #34486\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --llvm-root=/usr/lib/llvm-8 \\\n+      --enable-llvm-link-shared \\\n+      --set rust.thin-lto-import-instr-limit=10\n+\n+ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && \\\n+           # Run the `mir-opt` tests again but this time for a 32-bit target.\n+           # This enforces that tests using `// EMIT_MIR_FOR_EACH_BIT_WIDTH` have\n+           # both 32-bit and 64-bit outputs updated by the PR author, before\n+           # the PR is approved and tested for merging.\n+           # It will also detect tests lacking `// EMIT_MIR_FOR_EACH_BIT_WIDTH`,\n+           # despite having different output on 32-bit vs 64-bit targets.\n+           #\n+           # HACK(eddyb) `armv5te` is used (not `i686`) to support older LLVM than LLVM 9:\n+           # https://github.com/rust-lang/compiler-builtins/pull/311#issuecomment-612270089.\n+           # This also requires `--pass=build` because we can't execute the tests\n+           # on the `x86_64` host when they're built as `armv5te` binaries.\n+           # (we're only interested in the MIR output, so this doesn't matter)\n+           python2.7 ../x.py test src/test/mir-opt --pass=build \\\n+                                  --target=armv5te-unknown-linux-gnueabi && \\\n+           # Run tidy at the very end, after all the other tests.\n+           python2.7 ../x.py test src/tools/tidy\n+\n+# The purpose of this container isn't to test with debug assertions and\n+# this is run on all PRs, so let's get speedier builds by disabling these extra\n+# checks.\n+ENV NO_DEBUG_ASSERTIONS=1\n+ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "096f67e13d1e679c0414ca8445c63abece65cb49", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -21,4 +21,4 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu \\\n   --disable-optimize-tests \\\n   --set rust.test-compare-mode\n-ENV SCRIPT python2.7 ../x.py test\n+ENV SCRIPT python3 ../x.py test"}, {"sha": "148e09f6ad104c17177b126fcbb9339db907ffc1", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   libssl-dev \\"}, {"sha": "c9d1cb21da8b09779c0c9881809cf5269379155d", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -7,19 +7,18 @@ X_PY=\"$1\"\n # Try to test all the tools and store the build/test success in the TOOLSTATE_FILE\n \n set +e\n-python2.7 \"$X_PY\" test --no-fail-fast \\\n+python3 \"$X_PY\" test --no-fail-fast \\\n     src/doc/book \\\n     src/doc/nomicon \\\n     src/doc/reference \\\n     src/doc/rust-by-example \\\n     src/doc/embedded-book \\\n     src/doc/edition-guide \\\n-    src/doc/rustc-guide \\\n     src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n     src/tools/miri \\\n \n set -e\n \n-python2.7 \"$X_PY\" test check-tools\n+python3 \"$X_PY\" test check-tools"}, {"sha": "af6e13180627688b881fc9cc49b7bd3715a5ca01", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,7 +6,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -23,4 +23,4 @@ ENV RUST_CONFIGURE_ARGS \\\n  --enable-sanitizers \\\n  --enable-profiler \\\n  --enable-compiler-docs\n-ENV SCRIPT python2.7 ../x.py test\n+ENV SCRIPT python3 ../x.py test"}, {"sha": "26ce69e33d9c3ea14450b82061ac05a0a88874b6", "filename": "src/ci/exec-with-shell.py", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fexec-with-shell.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fexec-with-shell.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fexec-with-shell.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,16 @@\n+#!/usr/bin/env python\n+# A simple wrapper that forwards the arguments to bash, unless the\n+# CI_OVERRIDE_SHELL environment variable is present: in that case the content\n+# of that environment variable is used as the shell path.\n+\n+import os\n+import sys\n+import subprocess\n+\n+try:\n+    shell = os.environ[\"CI_OVERRIDE_SHELL\"]\n+except KeyError:\n+    shell = \"bash\"\n+\n+res = subprocess.call([shell] + sys.argv[1:])\n+sys.exit(res)"}, {"sha": "1c120f8163459579e0fcfdf4c8fa33df9c748976", "filename": "src/ci/github-actions/ci.yml", "status": "added", "additions": 649, "deletions": 0, "changes": 649, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,649 @@\n+######################################################\n+#   WARNING! Action needed when changing this file   #\n+######################################################\n+\n+# Due to GitHub Actions limitations, we can't use YAML Anchors directly in the\n+# CI configuration stored on the repository. To work around that this file is\n+# expanded by a tool in the repository, and the expansion is committed as well.\n+#\n+# After you make any change to the file you'll need to run this command:\n+#\n+#   ./x.py run src/tools/expand-yaml-anchors\n+#\n+# ...and commit the file it updated in addition to this one. If you forget this\n+# step CI will fail.\n+\n+---\n+\n+###############################\n+#   YAML Anchors Definition   #\n+###############################\n+\n+# This key contains most of the YAML anchors that will be used later in the\n+# document. YAML anchors allows us to greatly reduce duplication inside the CI\n+# configuration by reusing parts of the configuration.\n+#\n+# YAML anchors work by defining an anchor with `&anchor-name` and reusing its\n+# content in another place with `*anchor-name`. The special `<<` map key merges\n+# the content of the map with the content of the anchor (or list of anchors).\n+#\n+# The expand-yaml-anchors tool will automatically remove this block from the\n+# output YAML file.\n+x--expand-yaml-anchors--remove:\n+\n+  - &shared-ci-variables\n+    CI_JOB_NAME: ${{ matrix.name }}\n+\n+  - &public-variables\n+    SCCACHE_BUCKET: rust-lang-gha-caches\n+    TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+\n+  - &prod-variables\n+    SCCACHE_BUCKET: rust-lang-gha-caches\n+    DEPLOY_BUCKET: rust-lang-gha\n+    TOOLSTATE_REPO: https://github.com/pietroalbini/rust-toolstate\n+    TOOLSTATE_ISSUES_API_URL: https://api.github.com/repos/pietroalbini/rust-toolstate/issues\n+    TOOLSTATE_PUBLISH: 1\n+    # AWS_SECRET_ACCESS_KEYs are stored in GitHub's secrets storage, named\n+    # AWS_SECRET_ACCESS_KEY_<keyid>. Including the key id in the name allows to\n+    # rotate them in a single branch while keeping the old key in another\n+    # branch, which wouldn't be possible if the key was named with the kind\n+    # (caches, artifacts...).\n+    CACHES_AWS_ACCESS_KEY_ID: AKIA46X5W6CZOMUQATD5\n+    ARTIFACTS_AWS_ACCESS_KEY_ID: AKIA46X5W6CZH5AYXDVF\n+    CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n+\n+  - &base-job\n+    env: {}\n+\n+  - &job-linux-xl\n+    os: ubuntu-latest-xl\n+    <<: *base-job\n+\n+  - &job-macos-xl\n+    os: macos-latest  # We don't have an XL builder for this\n+    <<: *base-job\n+\n+  - &job-windows-xl\n+    os: windows-latest-xl\n+    <<: *base-job\n+\n+  - &step\n+    if: success() && !env.SKIP_JOB\n+\n+  - &base-ci-job\n+    timeout-minutes: 600\n+    runs-on: \"${{ matrix.os }}\"\n+    env: *shared-ci-variables\n+    steps:\n+      - name: disable git crlf conversion\n+        run: git config --global core.autocrlf false\n+        shell: bash\n+\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\n+        <<: *step\n+\n+      - name: add extra environment variables\n+        run: src/ci/scripts/setup-environment.sh\n+        env:\n+          # Since it's not possible to merge `${{ matrix.env }}` with the other\n+          # variables in `job.<name>.env`, the variables defined in the matrix\n+          # are passed to the `setup-environment.sh` script encoded in JSON,\n+          # which then uses log commands to actually set them.\n+          EXTRA_VARIABLES: ${{ toJson(matrix.env) }}\n+        <<: *step\n+\n+      - name: decide whether to skip this job\n+        run: src/ci/scripts/should-skip-this.sh\n+        <<: *step\n+\n+      - name: collect CPU statistics\n+        run: src/ci/scripts/collect-cpu-stats.sh\n+        <<: *step\n+\n+      - name: show the current environment\n+        run: src/ci/scripts/dump-environment.sh\n+        <<: *step\n+\n+      - name: install awscli\n+        run: src/ci/scripts/install-awscli.sh\n+        <<: *step\n+\n+      - name: install sccache\n+        run: src/ci/scripts/install-sccache.sh\n+        <<: *step\n+\n+      - name: install clang\n+        run: src/ci/scripts/install-clang.sh\n+        <<: *step\n+\n+      - name: install WIX\n+        run: src/ci/scripts/install-wix.sh\n+        <<: *step\n+\n+      - name: install InnoSetup\n+        run: src/ci/scripts/install-innosetup.sh\n+        <<: *step\n+\n+      - name: ensure the build happens on a partition with enough space\n+        run: src/ci/scripts/symlink-build-dir.sh\n+        <<: *step\n+\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        <<: *step\n+\n+      - name: install MSYS2\n+        run: src/ci/scripts/install-msys2.sh\n+        <<: *step\n+\n+      - name: install MSYS2 packages\n+        run: src/ci/scripts/install-msys2-packages.sh\n+        <<: *step\n+\n+      - name: install MinGW\n+        run: src/ci/scripts/install-mingw.sh\n+        <<: *step\n+\n+      - name: install ninja\n+        run: src/ci/scripts/install-ninja.sh\n+        <<: *step\n+\n+      - name: enable ipv6 on Docker\n+        run: src/ci/scripts/enable-docker-ipv6.sh\n+        <<: *step\n+\n+      # Disable automatic line ending conversion (again). On Windows, when we're\n+      # installing dependencies, something switches the git configuration directory or\n+      # re-enables autocrlf. We've not tracked down the exact cause -- and there may\n+      # be multiple -- but this should ensure submodules are checked out with the\n+      # appropriate line endings.\n+      - name: disable git crlf conversion\n+        run: src/ci/scripts/disable-git-crlf-conversion.sh\n+        <<: *step\n+\n+      - name: checkout submodules\n+        run: src/ci/scripts/checkout-submodules.sh\n+        <<: *step\n+\n+      - name: ensure line endings are correct\n+        run: src/ci/scripts/verify-line-endings.sh\n+        <<: *step\n+\n+      - name: run the build\n+        run: src/ci/scripts/run-build-from-ci.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: ${{ env.CACHES_AWS_ACCESS_KEY_ID }}\n+          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.CACHES_AWS_ACCESS_KEY_ID)] }}\n+          TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\n+        <<: *step\n+\n+      - name: upload artifacts to S3\n+        run: src/ci/scripts/upload-artifacts.sh\n+        env:\n+          AWS_ACCESS_KEY_ID: ${{ env.ARTIFACTS_AWS_ACCESS_KEY_ID }}\n+          AWS_SECRET_ACCESS_KEY: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', env.ARTIFACTS_AWS_ACCESS_KEY_ID)] }}\n+        # Adding a condition on DEPLOY=1 or DEPLOY_ALT=1 is not needed as all deploy\n+        # builders *should* have the AWS credentials available. Still, explicitly\n+        # adding the condition is helpful as this way CI will not silently skip\n+        # deploying artifacts from a dist builder if the variables are misconfigured,\n+        # erroring about invalid credentials instead.\n+        if: success() && !env.SKIP_JOB && (github.event_name == 'push' || env.DEPLOY == '1' || env.DEPLOY_ALT == '1')\n+        <<: *step\n+\n+  # These snippets are used by the try-success, try-failure, auto-success and auto-failure jobs.\n+  # Check out their documentation for more information on why they're needed.\n+\n+  - &base-outcome-job\n+    name: bors build finished\n+    runs-on: ubuntu-latest\n+\n+  - &base-success-job\n+    steps:\n+      - name: mark the job as a success\n+        run: exit 0\n+        shell: bash\n+    <<: *base-outcome-job\n+\n+  - &base-failure-job\n+    steps:\n+      - name: mark the job as a failure\n+        run: exit 1\n+        shell: bash\n+    <<: *base-outcome-job\n+\n+###########################\n+#   Builders definition   #\n+###########################\n+\n+name: CI\n+on:\n+  push:\n+    branches:\n+      - auto\n+      - try\n+      - master\n+  pull_request:\n+    branches:\n+      - \"**\"\n+\n+defaults:\n+  run:\n+    # While on Linux and macOS builders it just forwards the arguments to the\n+    # system bash, this wrapper allows switching from the host's bash.exe to\n+    # the one we install along with MSYS2 mid-build on Windows.\n+    #\n+    # Once the step to install MSYS2 is executed, the CI_OVERRIDE_SHELL\n+    # environment variable is set pointing to our MSYS2's bash.exe. From that\n+    # moment the host's bash.exe will not be called anymore.\n+    #\n+    # This is needed because we can't launch our own bash.exe from the host\n+    # bash.exe, as that would load two different cygwin1.dll in memory, causing\n+    # \"cygwin heap mismatch\" errors.\n+    shell: python src/ci/exec-with-shell.py {0}\n+\n+jobs:\n+  pr:\n+    <<: *base-ci-job\n+    name: PR\n+    env:\n+      <<: [*shared-ci-variables, *public-variables]\n+    if: github.event_name == 'pull_request'\n+    strategy:\n+      matrix:\n+        include:\n+          - name: mingw-check\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-llvm-8\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-tools\n+            env:\n+              CI_ONLY_WHEN_SUBMODULES_CHANGED: 1\n+            <<: *job-linux-xl\n+\n+  try:\n+    <<: *base-ci-job\n+    name: try\n+    env:\n+      <<: [*shared-ci-variables, *prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\n+    strategy:\n+      matrix:\n+        include:\n+          - name: dist-x86_64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-linux-alt\n+            env:\n+              IMAGE: dist-x86_64-linux\n+            <<: *job-linux-xl\n+\n+  auto:\n+    <<: *base-ci-job\n+    name: auto\n+    env:\n+      <<: [*shared-ci-variables, *prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\n+    strategy:\n+      matrix:\n+        include:\n+          #############################\n+          #   Linux/Docker builders   #\n+          #############################\n+\n+          - name: arm-android\n+            <<: *job-linux-xl\n+\n+          - name: armhf-gnu\n+            <<: *job-linux-xl\n+\n+          - name: dist-aarch64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-android\n+            <<: *job-linux-xl\n+\n+          - name: dist-arm-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-armhf-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-armv7-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-i586-gnu-i586-i686-musl\n+            <<: *job-linux-xl\n+\n+          - name: dist-i686-freebsd\n+            <<: *job-linux-xl\n+\n+          - name: dist-i686-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mips-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mips64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mips64el-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-mipsel-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-powerpc-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-powerpc64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-powerpc64le-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-s390x-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-various-1\n+            <<: *job-linux-xl\n+\n+          - name: dist-various-2\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-freebsd\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-linux-alt\n+            env:\n+              IMAGE: dist-x86_64-linux\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-musl\n+            <<: *job-linux-xl\n+\n+          - name: dist-x86_64-netbsd\n+            <<: *job-linux-xl\n+\n+          - name: i686-gnu\n+            <<: *job-linux-xl\n+\n+          - name: i686-gnu-nopt\n+            <<: *job-linux-xl\n+\n+          - name: mingw-check\n+            <<: *job-linux-xl\n+\n+          - name: test-various\n+            <<: *job-linux-xl\n+\n+          - name: wasm32\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-aux\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-debug\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-distcheck\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-full-bootstrap\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-llvm-8\n+            env:\n+              RUST_BACKTRACE: 1\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-nopt\n+            <<: *job-linux-xl\n+\n+          - name: x86_64-gnu-tools\n+            env:\n+              DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n+            <<: *job-linux-xl\n+\n+          ####################\n+          #  macOS Builders  #\n+          ####################\n+\n+          - name: dist-x86_64-apple\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-macos-xl\n+\n+          - name: dist-x86_64-apple-alt\n+            env:\n+              SCRIPT: ./x.py dist\n+              RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n+          - name: x86_64-apple\n+            env:\n+              SCRIPT: ./x.py test\n+              RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n+              RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+              MACOSX_DEPLOYMENT_TARGET: 10.8\n+              MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+              NO_LLVM_ASSERTIONS: 1\n+              NO_DEBUG_ASSERTIONS: 1\n+            <<: *job-macos-xl\n+\n+          ######################\n+          #  Windows Builders  #\n+          ######################\n+\n+          - name: x86_64-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+              SCRIPT: make ci-subset-1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+              SCRIPT: make ci-subset-2\n+            <<: *job-windows-xl\n+\n+          - name: i686-msvc-1\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+              SCRIPT: make ci-subset-1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: i686-msvc-2\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+              SCRIPT: make ci-subset-2\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-msvc-aux\n+            env:\n+              RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-msvc-cargo\n+            env:\n+              SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+              VCVARS_BAT: vcvars64.bat\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-msvc-tools\n+            env:\n+              SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\n+            <<: *job-windows-xl\n+\n+          # 32/64-bit MinGW builds.\n+          #\n+          # We are using MinGW with posix threads since LLVM does not compile with\n+          # the win32 threads version due to missing support for C++'s std::thread.\n+          #\n+          # Instead of relying on the MinGW version installed on appveryor we download\n+          # and install one ourselves so we won't be surprised by changes to appveyor's\n+          # build image.\n+          #\n+          # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n+          # bucket, but they cleraly didn't originate there! The downloads originally\n+          # came from the mingw-w64 SourceForge download site. Unfortunately\n+          # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n+\n+          - name: i686-mingw-1\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+              SCRIPT: make ci-mingw-subset-1\n+              CUSTOM_MINGW: 1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: i686-mingw-2\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+              SCRIPT: make ci-mingw-subset-2\n+              CUSTOM_MINGW: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-mingw-1\n+            env:\n+              SCRIPT: make ci-mingw-subset-1\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+              CUSTOM_MINGW: 1\n+              # FIXME(#59637)\n+              NO_DEBUG_ASSERTIONS: 1\n+              NO_LLVM_ASSERTIONS: 1\n+            <<: *job-windows-xl\n+\n+          - name: x86_64-mingw-2\n+            env:\n+              SCRIPT: make ci-mingw-subset-2\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+              CUSTOM_MINGW: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-x86_64-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: >-\n+                --build=x86_64-pc-windows-msvc\n+                --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n+                --enable-full-tools\n+                --enable-profiler\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-i686-msvc\n+            env:\n+              RUST_CONFIGURE_ARGS: >-\n+                --build=i686-pc-windows-msvc\n+                --target=i586-pc-windows-msvc\n+                --enable-full-tools\n+                --enable-profiler\n+              SCRIPT: python x.py dist\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-i686-mingw\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n+              SCRIPT: python x.py dist\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-x86_64-mingw\n+            env:\n+              SCRIPT: python x.py dist\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n+              CUSTOM_MINGW: 1\n+              DIST_REQUIRE_ALL_TOOLS: 1\n+            <<: *job-windows-xl\n+\n+          - name: dist-x86_64-msvc-alt\n+            env:\n+              RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+              SCRIPT: python x.py dist\n+            <<: *job-windows-xl\n+\n+  master:\n+    name: master\n+    runs-on: ubuntu-latest\n+    env:\n+      <<: [*prod-variables]\n+    if: github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository == 'rust-lang-ci/rust'\n+    steps:\n+      - name: checkout the source code\n+        uses: actions/checkout@v1\n+        with:\n+          fetch-depth: 2\n+\n+      - name: publish toolstate\n+        run: src/ci/publish_toolstate.sh\n+        env:\n+          TOOLSTATE_REPO_ACCESS_TOKEN: ${{ secrets.TOOLSTATE_REPO_ACCESS_TOKEN }}\n+        <<: *step\n+\n+  # These jobs don't actually test anything, but they're used to tell bors the\n+  # build completed, as there is no practical way to detect when a workflow is\n+  # successful listening to webhooks only.\n+  try-success:\n+    needs: [try]\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-success-job\n+  try-failure:\n+    needs: [try]\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/try' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-failure-job\n+  auto-success:\n+    needs: [auto]\n+    if: \"success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-success-job\n+  auto-failure:\n+    needs: [auto]\n+    if: \"!success() && github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n+    <<: *base-failure-job"}, {"sha": "59f2736cbd406b05e11bfebd35e97dd66218258e", "filename": "src/ci/run.sh", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -23,6 +23,14 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n+if command -v python > /dev/null; then\n+    PYTHON=\"python\"\n+elif command -v python3 > /dev/null; then\n+    PYTHON=\"python3\"\n+else\n+    PYTHON=\"python2\"\n+fi\n+\n if ! isCI || isCiBranch auto || isCiBranch beta; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n@@ -107,7 +115,7 @@ SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n \n if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n   $SRC/configure --enable-parallel-compiler\n-  CARGO_INCREMENTAL=0 python2.7 ../x.py check\n+  CARGO_INCREMENTAL=0 $PYTHON ../x.py check\n   rm -f config.toml\n   rm -rf build\n fi"}, {"sha": "f9b759fe343f007e2ade76ba16e2c51b4b2b6ee1", "filename": "src/ci/scripts/install-awscli.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-awscli.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -28,7 +28,7 @@ if isLinux; then\n     pipflags=\"--user\"\n \n     sudo apt-get install -y python3-setuptools\n-    echo \"##vso[task.prependpath]$HOME/.local/bin\"\n+    ciCommandAddPath \"${HOME}/.local/bin\"\n fi\n \n mkdir -p \"${DEPS_DIR}\""}, {"sha": "ae85d5cab0122f7fdca22d44c76bf73b03313d6e", "filename": "src/ci/scripts/install-mingw.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-mingw.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-mingw.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-mingw.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -51,7 +51,8 @@ if isWindows; then\n \n     if [[ \"${CUSTOM_MINGW-0}\" -ne 1 ]]; then\n         pacman -S --noconfirm --needed mingw-w64-$arch-toolchain mingw-w64-$arch-cmake \\\n-            mingw-w64-$arch-gcc mingw-w64-$arch-python2\n+            mingw-w64-$arch-gcc \\\n+            mingw-w64-$arch-python # the python package is actually for python3\n         ciCommandAddPath \"$(ciCheckoutPath)/msys2/mingw${bits}/bin\"\n     else\n         mingw_dir=\"mingw${bits}\""}, {"sha": "8fefddd959c9cc0d518eaec198a4330ee1eb0acc", "filename": "src/ci/scripts/install-msys2-packages.sh", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2-packages.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,14 +6,33 @@ IFS=$'\\n\\t'\n source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n \n if isWindows; then\n+    # FIXME(mati865): temporary workaround until chocolatey updates their MSYS2\n+    base_url='https://ci-mirrors.rust-lang.org/rustc/msys2-repo/msys/x86_64'\n+    curl ${base_url}/libzstd-1.4.4-2-x86_64.pkg.tar.xz -o libzstd-1.4.4-2-x86_64.pkg.tar.xz\n+    curl ${base_url}/pacman-5.2.1-6-x86_64.pkg.tar.xz -o pacman-5.2.1-6-x86_64.pkg.tar.xz\n+    curl ${base_url}/zstd-1.4.4-2-x86_64.pkg.tar.xz -o zstd-1.4.4-2-x86_64.pkg.tar.xz\n+    pacman -U --noconfirm libzstd-1.4.4-2-x86_64.pkg.tar.xz pacman-5.2.1-6-x86_64.pkg.tar.xz \\\n+        zstd-1.4.4-2-x86_64.pkg.tar.xz\n+    rm libzstd-1.4.4-2-x86_64.pkg.tar.xz pacman-5.2.1-6-x86_64.pkg.tar.xz \\\n+        zstd-1.4.4-2-x86_64.pkg.tar.xz\n+    pacman -Sy\n+\n     pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar \\\n         binutils\n \n+    # Detect the native Python version installed on the agent. On GitHub\n+    # Actions, the C:\\hostedtoolcache\\windows\\Python directory contains a\n+    # subdirectory for each installed Python version.\n+    #\n+    # The -V flag of the sort command sorts the input by version number.\n+    native_python_version=\"$(ls /c/hostedtoolcache/windows/Python | sort -Vr | head -n 1)\"\n+\n     # Make sure we use the native python interpreter instead of some msys equivalent\n     # one way or another. The msys interpreters seem to have weird path conversions\n     # baked in which break LLVM's build system one way or another, so let's use the\n     # native version which keeps everything as native as possible.\n-    python_home=\"C:/hostedtoolcache/windows/Python/2.7.17/x64\"\n-    cp \"${python_home}/python.exe\" \"${python_home}/python2.7.exe\"\n-    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\2.7.17\\\\x64\"\n+    python_home=\"/c/hostedtoolcache/windows/Python/${native_python_version}/x64\"\n+    cp \"${python_home}/python.exe\" \"${python_home}/python3.exe\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\"\n+    ciCommandAddPath \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\${native_python_version}\\\\x64\\\\Scripts\"\n fi"}, {"sha": "b94eb5fc6ddd562cf153f4f7d201bfe2e19edb9d", "filename": "src/ci/scripts/install-msys2.sh", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-msys2.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Finstall-msys2.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-msys2.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -17,9 +17,13 @@ if isWindows; then\n         msys2.nupkg\n     curl -sSL https://packages.chocolatey.org/chocolatey-core.extension.1.3.5.1.nupkg > \\\n         chocolatey-core.extension.nupkg\n+    # FIXME(mati865): remove `/NoUpdate` once chocolatey updates MSYS2\n     choco install -s . msys2 \\\n-        --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath\" -y --no-progress\n+        --params=\"/InstallDir:$(ciCheckoutPath)/msys2 /NoPath /NoUpdate\" -y --no-progress\n     rm msys2.nupkg chocolatey-core.extension.nupkg\n     mkdir -p \"$(ciCheckoutPath)/msys2/home/${USERNAME}\"\n     ciCommandAddPath \"$(ciCheckoutPath)/msys2/usr/bin\"\n+\n+    echo \"switching shell to use our own bash\"\n+    ciCommandSetEnv CI_OVERRIDE_SHELL \"$(ciCheckoutPath)/msys2/usr/bin/bash.exe\"\n fi"}, {"sha": "411ef6f9b2822de63d2bd621db865e68565161e4", "filename": "src/ci/scripts/setup-environment.sh", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Fsetup-environment.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Fsetup-environment.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsetup-environment.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -11,16 +11,34 @@ source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n # Since matrix variables are readonly in Azure Pipelines, we take\n # INITIAL_RUST_CONFIGURE_ARGS and establish RUST_CONFIGURE_ARGS\n # which downstream steps can alter\n-# macOS ships with Bash 3.16, so we cannot use [[ -v FOO ]],\n-# which was introduced in Bash 4.2\n-if [[ -z \"${INITIAL_RUST_CONFIGURE_ARGS+x}\" ]]; then\n-    INITIAL_RUST_CONFIG=\"\"\n-    echo \"No initial Rust configure args set\"\n-else\n-    INITIAL_RUST_CONFIG=\"${INITIAL_RUST_CONFIGURE_ARGS}\"\n-    ciCommandSetEnv RUST_CONFIGURE_ARGS \"${INITIAL_RUST_CONFIG}\"\n+if isAzurePipelines; then\n+    # macOS ships with Bash 3.16, so we cannot use [[ -v FOO ]],\n+    # which was introduced in Bash 4.2\n+    if [[ -z \"${INITIAL_RUST_CONFIGURE_ARGS+x}\" ]]; then\n+        INITIAL_RUST_CONFIG=\"\"\n+        echo \"No initial Rust configure args set\"\n+    else\n+        INITIAL_RUST_CONFIG=\"${INITIAL_RUST_CONFIGURE_ARGS}\"\n+        ciCommandSetEnv RUST_CONFIGURE_ARGS \"${INITIAL_RUST_CONFIG}\"\n+    fi\n fi\n \n+# Load extra environment variables\n+vars=\"${EXTRA_VARIABLES-}\"\n+echo \"${vars}\" | jq '' >/dev/null  # Validate JSON and exit on errors\n+for key in $(echo \"${vars}\" | jq \"keys[]\" -r); do\n+    # On Windows, for whatever reason, $key contains the BOM character in it,\n+    # and that messes up `jq \".${key}\"`. This line strips the BOM from the key.\n+    #\n+    # https://unix.stackexchange.com/a/381263\n+    key=\"$(echo \"${key}\" | sed '1s/^\\xEF\\xBB\\xBF//')\"\n+\n+    echo \"adding extra environment variable ${key}\"\n+    value=\"$(echo \"${vars}\" | jq \".${key}\" -r)\"\n+    export \"${key}\"=\"${value}\"\n+    ciCommandSetEnv \"${key}\" \"${value}\"\n+done\n+\n # Builders starting with `dist-` are dist builders, but if they also end with\n # `-alt` they are alternate dist builders.\n if [[ \"${CI_JOB_NAME}\" = dist-* ]]; then"}, {"sha": "50178b9c33ed46eb783c2fd788ec92aba1a84bf6", "filename": "src/ci/scripts/symlink-build-dir.sh", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,33 @@\n+#!/bin/bash\n+# We've had multiple issues with the default disk running out of disk space\n+# during builds, and it looks like other disks mounted in the VMs have more\n+# space available. This script synlinks the build directory to those other\n+# disks, in the CI providers and OSes affected by this.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+\n+if isWindows && isAzurePipelines; then\n+    cmd //c \"mkdir c:\\\\MORE_SPACE\"\n+    cmd //c \"mklink /J build c:\\\\MORE_SPACE\"\n+elif isLinux && isGitHubActions; then\n+    sudo mkdir -p /mnt/more-space\n+    sudo chown -R \"$(whoami):\" /mnt/more-space\n+\n+    # Switch the whole workspace to the /mnt partition, which has more space.\n+    # We don't just symlink the `obj` directory as doing that creates problems\n+    # with the docker container.\n+    current_dir=\"$(readlink -f \"$(pwd)\")\"\n+    cd /tmp\n+    mv \"${current_dir}\" /mnt/more-space/workspace\n+    ln -s /mnt/more-space/workspace \"${current_dir}\"\n+    cd \"${current_dir}\"\n+\n+    # Move the Docker data directory to /mnt\n+    sudo systemctl stop docker.service\n+    sudo mv /var/lib/docker /mnt/docker\n+    sudo ln -s /mnt/docker /var/lib/docker\n+    sudo systemctl start docker.service\n+fi"}, {"sha": "e57128c70f5f194e533adfbc15c1f3cde35220b0", "filename": "src/ci/scripts/windows-symlink-build-dir.sh", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fwindows-symlink-build-dir.sh?ref=374ab25585f0a817fe7bd6986737f12347b12d0b", "patch": "@@ -1,15 +0,0 @@\n-#!/bin/bash\n-# We've had issues with the default drive in use running out of space during a\n-# build, and it looks like the `C:` drive has more space than the default `D:`\n-# drive. We should probably confirm this with the azure pipelines team at some\n-# point, but this seems to fix our \"disk space full\" problems.\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isWindows; then\n-    cmd //c \"mkdir c:\\\\MORE_SPACE\"\n-    cmd //c \"mklink /J build c:\\\\MORE_SPACE\"\n-fi"}, {"sha": "6247be15a7f7509559f7981ee2209b9e0cc121df", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1 +1 @@\n-Subproject commit 6fb3705e5230311b096d47f7e2c91f9ce24393d0\n+Subproject commit 6247be15a7f7509559f7981ee2209b9e0cc121df"}, {"sha": "49270740c7a4bff2763e6bc730b191d45b7d5167", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1 +1 @@\n-Subproject commit 37f9e6848411188a1062ead1bd8ebe4b8aa16899\n+Subproject commit 49270740c7a4bff2763e6bc730b191d45b7d5167"}, {"sha": "366c50a03bed928589771eba8a6f18e0c0c01d23", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1 +1 @@\n-Subproject commit d22a9c487c78095afc4584f1d9b4ec43529d713c\n+Subproject commit 366c50a03bed928589771eba8a6f18e0c0c01d23"}, {"sha": "d1517d4e3f29264c5c67bce2658516bb5202c800", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1 +1 @@\n-Subproject commit 9f797e65e6bcc79419975b17aff8e21c9adc039f\n+Subproject commit d1517d4e3f29264c5c67bce2658516bb5202c800"}, {"sha": "892b928b565e35d25b6f9c47faee03b94bc41489", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1 +1 @@\n-Subproject commit e2f11fe4d6a5ecb471c70323197da43c70cb96b6\n+Subproject commit 892b928b565e35d25b6f9c47faee03b94bc41489"}, {"sha": "ab072b14393cbd9e8a1d1d75879bf51e27217bbb", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1 +1 @@\n-Subproject commit cb369ae95ca36b841960182d26f6d5d9b2e3cc18\n+Subproject commit ab072b14393cbd9e8a1d1d75879bf51e27217bbb"}, {"sha": "7adfab42bab045a848126895c2f1e09927c1331a", "filename": "src/doc/rustc-dev-guide", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1 @@\n+Subproject commit 7adfab42bab045a848126895c2f1e09927c1331a"}, {"sha": "5bd60bc51efaec04e69e2e18b59678e2af066433", "filename": "src/doc/rustc-guide", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=374ab25585f0a817fe7bd6986737f12347b12d0b", "patch": "@@ -1 +0,0 @@\n-Subproject commit 5bd60bc51efaec04e69e2e18b59678e2af066433"}, {"sha": "0b4bb05c1db23e66ead131d085b9ced6d7bf9141", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 358, "deletions": 234, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -7,12 +7,164 @@ a version of this list for your exact compiler by running `rustc -C help`.\n \n This option is deprecated and does nothing.\n \n-## linker\n+## code-model\n+\n+This option lets you choose which code model to use. \\\n+Code models put constraints on address ranges that the program and its symbols may use. \\\n+With smaller address ranges machine instructions\n+may be able to use use more compact addressing modes.\n+\n+The specific ranges depend on target architectures and addressing modes available to them. \\\n+For x86 more detailed description of its code models can be found in\n+[System V Application Binary Interface](https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf)\n+specification.\n+\n+Supported values for this option are:\n+\n+- `tiny` - Tiny code model.\n+- `small` - Small code model. This is the default model for majority of supported targets.\n+- `kernel` - Kernel code model.\n+- `medium` - Medium code model.\n+- `large` - Large code model.\n+\n+Supported values can also be discovered by running `rustc --print code-models`.\n+\n+## codegen-units\n+\n+This flag controls how many code generation units the crate is split into. It\n+takes an integer greater than 0.\n+\n+When a crate is split into multiple codegen units, LLVM is able to process\n+them in parallel. Increasing parallelism may speed up compile times, but may\n+also produce slower code. Setting this to 1 may improve the performance of\n+generated code, but may be slower to compile.\n+\n+The default value, if not specified, is 16 for non-incremental builds. For\n+incremental builds the default is 256 which allows caching to be more granular.\n+\n+## debug-assertions\n+\n+This flag lets you turn `cfg(debug_assertions)` [conditional\n+compilation](../../reference/conditional-compilation.md#debug_assertions) on\n+or off. It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: enable debug-assertions.\n+* `n`, `no`, or `off`: disable debug-assertions.\n+\n+If not specified, debug assertions are automatically enabled only if the\n+[opt-level](#opt-level) is 0.\n+\n+## debuginfo\n+\n+This flag controls the generation of debug information. It takes one of the\n+following values:\n+\n+* `0`: no debug info at all (the default).\n+* `1`: line tables only.\n+* `2`: full debug info.\n+\n+Note: The [`-g` flag][option-g-debug] is an alias for `-C debuginfo=2`.\n+\n+## default-linker-libraries\n+\n+This flag controls whether or not the linker includes its default libraries.\n+It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: include default libraries (the default).\n+* `n`, `no`, or `off`: exclude default libraries.\n \n-This flag lets you control which linker `rustc` invokes to link your code. It\n-takes a path to the linker executable. If this flag is not specified, the\n-linker will be inferred based on the target. See also the\n-[linker-flavor](#linker-flavor) flag for another way to specify the linker.\n+For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n+the linker.\n+\n+## embed-bitcode\n+\n+This flag controls whether or not the compiler embeds LLVM bitcode into object\n+files. It takes one of the following values:\n+\n+* `y`, `yes`, `on`, or no value: put bitcode in rlibs (the default).\n+* `n`, `no`, or `off`: omit bitcode from rlibs.\n+\n+LLVM bitcode is required when rustc is performing link-time optimization (LTO).\n+It is also required on some targets like iOS ones where vendors look for LLVM\n+bitcode. Embedded bitcode will appear in rustc-generated object files inside of\n+a section whose name is defined by the target platform. Most of the time this is\n+`.llvmbc`.\n+\n+The use of `-C embed-bitcode=no` can significantly improve compile times and\n+reduce generated file sizes if your compilation does not actually need bitcode\n+(e.g. if you're not compiling for iOS or you're not performing LTO). For these\n+reasons, Cargo uses `-C embed-bitcode=no` whenever possible. Likewise, if you\n+are building directly with `rustc` we recommend using `-C embed-bitcode=no`\n+whenever you are not using LTO.\n+\n+If combined with `-C lto`, `-C embed-bitcode=no` will cause `rustc` to abort\n+at start-up, because the combination is invalid.\n+\n+> **Note**: if you're building Rust code with LTO then you probably don't even\n+> need the `embed-bitcode` option turned on. You'll likely want to use\n+> `-Clinker-plugin-lto` instead which skips generating object files entirely and\n+> simply replaces object files with LLVM bitcode. The only purpose for\n+> `-Cembed-bitcode` is when you're generating an rlib that is both being used\n+> with and without LTO. For example Rust's standard library ships with embedded\n+> bitcode since users link to it both with and without LTO.\n+>\n+> This also may make you wonder why the default is `yes` for this option. The\n+> reason for that is that it's how it was for rustc 1.44 and prior. In 1.45 this\n+> option was added to turn off what had always been the default.\n+\n+## extra-filename\n+\n+This option allows you to put extra data in each output filename. It takes a\n+string to add as a suffix to the filename. See the [`--emit`\n+flag][option-emit] for more information.\n+\n+## force-frame-pointers\n+\n+This flag forces the use of frame pointers. It takes one of the following\n+values:\n+\n+* `y`, `yes`, `on`, or no value: force-enable frame pointers.\n+* `n`, `no`, or `off`: do not force-enable frame pointers. This does\n+  not necessarily mean frame pointers will be removed.\n+\n+The default behaviour, if frame pointers are not force-enabled, depends on the\n+target.\n+\n+## force-unwind-tables\n+\n+This flag forces the generation of unwind tables. It takes one of the following\n+values:\n+\n+* `y`, `yes`, `on`, or no value: Unwind tables are forced to be generated.\n+* `n`, `no`, or `off`: Unwind tables are not forced to be generated. If unwind\n+  tables are required by the target or `-C panic=unwind`, an error will be\n+  emitted.\n+\n+The default if not specified depends on the target.\n+\n+## incremental\n+\n+This flag allows you to enable incremental compilation, which allows `rustc`\n+to save information after compiling a crate to be reused when recompiling the\n+crate, improving re-compile times. This takes a path to a directory where\n+incremental files will be stored.\n+\n+## inline-threshold\n+\n+This option lets you set the default threshold for inlining a function. It\n+takes an unsigned integer as a value. Inlining is based on a cost model, where\n+a higher threshold will allow more inlining.\n+\n+The default depends on the [opt-level](#opt-level):\n+\n+| opt-level | Threshold |\n+|-----------|-----------|\n+| 0         | N/A, only inlines always-inline functions |\n+| 1         | N/A, only inlines always-inline functions and LLVM lifetime intrinsics |\n+| 2         | 225 |\n+| 3         | 275 |\n+| s         | 75 |\n+| z         | 25 |\n \n ## link-arg\n \n@@ -25,51 +177,91 @@ This flag lets you append a single extra argument to the linker invocation.\n This flag lets you append multiple extra arguments to the linker invocation. The\n options should be separated by spaces.\n \n-## linker-flavor\n+## link-dead-code\n+\n+This flag controls whether the linker will keep dead code. It takes one of\n+the following values:\n+\n+* `y`, `yes`, `on`, or no value: keep dead code.\n+* `n`, `no`, or `off`: remove dead code (the default).\n+\n+An example of when this flag might be useful is when trying to construct code coverage\n+metrics.\n \n-This flag lets you control the linker flavor used by `rustc`. If a linker is given with the\n-[`-C linker` flag](#linker), then the linker flavor is inferred from the value provided. If no\n-linker is given then the linker flavor is used to determine the linker to use. Every `rustc` target\n-defaults to some linker flavor. Valid options are:\n+## linker\n+\n+This flag controls which linker `rustc` invokes to link your code. It takes a\n+path to the linker executable. If this flag is not specified, the linker will\n+be inferred based on the target. See also the [linker-flavor](#linker-flavor)\n+flag for another way to specify the linker.\n \n-* `em`: Uses [Emscripten `emcc`](https://emscripten.org/docs/tools_reference/emcc.html).\n-* `gcc`: Uses the `cc` executable, which is typically gcc or clang on many systems.\n-* `ld`: Uses the `ld` executable.\n-* `msvc`: Uses the `link.exe` executable from Microsoft Visual Studio MSVC.\n-* `ptx-linker`: Uses\n+## linker-flavor\n+\n+This flag controls the linker flavor used by `rustc`. If a linker is given with\n+the [`-C linker` flag](#linker), then the linker flavor is inferred from the\n+value provided. If no linker is given then the linker flavor is used to\n+determine the linker to use. Every `rustc` target defaults to some linker\n+flavor. Valid options are:\n+\n+* `em`: use [Emscripten `emcc`](https://emscripten.org/docs/tools_reference/emcc.html).\n+* `gcc`: use the `cc` executable, which is typically gcc or clang on many systems.\n+* `ld`: use the `ld` executable.\n+* `msvc`: use the `link.exe` executable from Microsoft Visual Studio MSVC.\n+* `ptx-linker`: use\n   [`rust-ptx-linker`](https://github.com/denzp/rust-ptx-linker) for Nvidia\n   NVPTX GPGPU support.\n-* `wasm-ld`: Uses the [`wasm-ld`](https://lld.llvm.org/WebAssembly.html)\n+* `wasm-ld`: use the [`wasm-ld`](https://lld.llvm.org/WebAssembly.html)\n   executable, a port of LLVM `lld` for WebAssembly.\n-* `ld64.lld`: Uses the LLVM `lld` executable with the [`-flavor darwin`\n+* `ld64.lld`: use the LLVM `lld` executable with the [`-flavor darwin`\n   flag][lld-flavor] for Apple's `ld`.\n-* `ld.lld`: Uses the LLVM `lld` executable with the [`-flavor gnu`\n+* `ld.lld`: use the LLVM `lld` executable with the [`-flavor gnu`\n   flag][lld-flavor] for GNU binutils' `ld`.\n-* `lld-link`: Uses the LLVM `lld` executable with the [`-flavor link`\n+* `lld-link`: use the LLVM `lld` executable with the [`-flavor link`\n   flag][lld-flavor] for Microsoft's `link.exe`.\n \n [lld-flavor]: https://lld.llvm.org/Driver.html\n \n-## link-dead-code\n+## linker-plugin-lto\n \n-Normally, the linker will remove dead code. This flag disables this behavior.\n+This flag defers LTO optimizations to the linker. See\n+[linker-plugin-LTO](../linker-plugin-lto.md) for more details. It takes one of\n+the following values:\n \n-An example of when this flag might be useful is when trying to construct code coverage\n-metrics.\n+* `y`, `yes`, `on`, or no value: enable linker plugin LTO.\n+* `n`, `no`, or `off`: disable linker plugin LTO (the default).\n+* A path to the linker plugin.\n+\n+More specifically this flag will cause the compiler to replace its typical\n+object file output with LLVM bitcode files. For example an rlib produced with\n+`-Clinker-plugin-lto` will still have `*.o` files in it, but they'll all be LLVM\n+bitcode instead of actual machine code. It is expected that the native platform\n+linker is capable of loading these LLVM bitcode files and generating code at\n+link time (typically after performing optimizations).\n+\n+Note that rustc can also read its own object files produced with\n+`-Clinker-plugin-lto`. If an rlib is only ever going to get used later with a\n+`-Clto` compilation then you can pass `-Clinker-plugin-lto` to speed up\n+compilation and avoid generating object files that aren't used.\n+\n+## llvm-args\n+\n+This flag can be used to pass a list of arguments directly to LLVM.\n+\n+The list must be separated by spaces.\n+\n+Pass `--help` to see a list of options.\n \n ## lto\n \n-This flag instructs LLVM to use [link time\n+This flag controls whether LLVM uses [link time\n optimizations](https://llvm.org/docs/LinkTimeOptimization.html) to produce\n better optimized code, using whole-program analysis, at the cost of longer\n-linking time.\n+linking time. It takes one of the following values:\n \n-This flag may take one of the following values:\n-\n-* `y`, `yes`, `on`, `fat`, or no value: Performs \"fat\" LTO which attempts to\n+* `y`, `yes`, `on`, `fat`, or no value: perform \"fat\" LTO which attempts to\n   perform optimizations across all crates within the dependency graph.\n-* `n`, `no`, `off`: Disables LTO.\n-* `thin`: Performs [\"thin\"\n+* `n`, `no`, `off`: disables LTO.\n+* `thin`: perform [\"thin\"\n   LTO](http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html).\n   This is similar to \"fat\", but takes substantially less time to run while\n   still achieving performance gains similar to \"fat\".\n@@ -81,81 +273,67 @@ disabled if codegen units is 1 or optimizations are disabled ([`-C\n opt-level=0`](#opt-level)). That is:\n \n * When `-C lto` is not specified:\n-  * `codegen-units=1`: Disables LTO.\n-  * `opt-level=0`: Disables LTO.\n+  * `codegen-units=1`: disable LTO.\n+  * `opt-level=0`: disable LTO.\n * When `-C lto=true`:\n-  * `lto=true`: 16 codegen units, performs fat LTO across crates.\n+  * `lto=true`: 16 codegen units, perform fat LTO across crates.\n   * `codegen-units=1` + `lto=true`: 1 codegen unit, fat LTO across crates.\n \n See also [linker-plugin-lto](#linker-plugin-lto) for cross-language LTO.\n \n-## linker-plugin-lto\n-\n-Defers LTO optimizations to the linker. See\n-[linkger-plugin-LTO](../linker-plugin-lto.md) for more details. Takes one of\n-the following values:\n-\n-* `y`, `yes`, `on`, or no value: Enabled.\n-* `n`, `no`, or `off`: Disabled (default).\n-* A path to the linker plugin.\n-\n-## target-cpu\n-\n-This instructs `rustc` to generate code specifically for a particular processor.\n-\n-You can run `rustc --print target-cpus` to see the valid options to pass\n-here. Additionally, `native` can be passed to use the processor of the host\n-machine. Each target has a default base CPU.\n-\n-## target-feature\n+## metadata\n \n-Individual targets will support different features; this flag lets you control\n-enabling or disabling a feature. Each feature should be prefixed with a `+` to\n-enable it or `-` to disable it. Separate multiple features with commas.\n+This option allows you to control the metadata used for symbol mangling. This\n+takes a space-separated list of strings. Mangled symbols will incorporate a\n+hash of the metadata. This may be used, for example, to differentiate symbols\n+between two different versions of the same crate being linked.\n \n-To see the valid options and an example of use, run `rustc --print\n-target-features`.\n+## no-prepopulate-passes\n \n-Using this flag is unsafe and might result in [undefined runtime\n-behavior](../targets/known-issues.md).\n+This flag tells the pass manager to use an empty list of passes, instead of the\n+usual pre-populated list of passes.\n \n-See also the [`target_feature`\n-attribute](../../reference/attributes/codegen.md#the-target_feature-attribute)\n-for controlling features per-function.\n+## no-redzone\n \n-This also supports the feature `+crt-static` and `-crt-static` to control\n-[static C runtime linkage](../../reference/linkage.html#static-and-dynamic-c-runtimes).\n+This flag allows you to disable [the\n+red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). It takes one\n+of the following values:\n \n-Each target and [`target-cpu`](#target-cpu) has a default set of enabled\n-features.\n+* `y`, `yes`, `on`, or no value: disable the red zone.\n+* `n`, `no`, or `off`: enable the red zone.\n \n-## passes\n+The default behaviour, if the flag is not specified, depends on the target.\n \n-This flag can be used to add extra [LLVM\n-passes](http://llvm.org/docs/Passes.html) to the compilation.\n+## no-stack-check\n \n-The list must be separated by spaces.\n+This option is deprecated and does nothing.\n \n-See also the [`no-prepopulate-passes`](#no-prepopulate-passes) flag.\n+## no-vectorize-loops\n \n-## llvm-args\n+This flag disables [loop\n+vectorization](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer).\n \n-This flag can be used to pass a list of arguments directly to LLVM.\n+## no-vectorize-slp\n \n-The list must be separated by spaces.\n+This flag disables vectorization using\n+[superword-level\n+parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer).\n \n-Pass `--help` to see a list of options.\n+## opt-level\n \n-## save-temps\n+This flag controls the optimization level.\n \n-`rustc` will generate temporary files during compilation; normally it will\n-delete them after it's done with its work. This option will cause them to be\n-preserved instead of removed.\n+* `0`: no optimizations, also turns on\n+  [`cfg(debug_assertions)`](#debug-assertions) (the default).\n+* `1`: basic optimizations.\n+* `2`: some optimizations.\n+* `3`: all optimizations.\n+* `s`: optimize for binary size.\n+* `z`: optimize for binary size, but also turn off loop vectorization.\n \n-## rpath\n+Note: The [`-O` flag][option-o-optimize] is an alias for `-C opt-level=2`.\n \n-This option allows you to enable\n-[`rpath`](https://en.wikipedia.org/wiki/Rpath).\n+The default is `0`.\n \n ## overflow-checks\n \n@@ -164,35 +342,29 @@ overflow](../../reference/expressions/operator-expr.md#overflow). When\n overflow-checks are enabled, a panic will occur on overflow. This flag takes\n one of the following values:\n \n-* `y`, `yes`, `on`, or no value: Enable overflow checks.\n-* `n`, `no`, or `off`: Disable overflow checks.\n+* `y`, `yes`, `on`, or no value: enable overflow checks.\n+* `n`, `no`, or `off`: disable overflow checks.\n \n If not specified, overflow checks are enabled if\n [debug-assertions](#debug-assertions) are enabled, disabled otherwise.\n \n-## no-prepopulate-passes\n+## panic\n \n-The pass manager comes pre-populated with a list of passes; this flag\n-ensures that list is empty.\n+This option lets you control what happens when the code panics.\n \n-## no-vectorize-loops\n+* `abort`: terminate the process upon panic\n+* `unwind`: unwind the stack upon panic\n \n-By default, `rustc` will attempt to [vectorize\n-loops](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer). This\n-flag will turn that behavior off.\n+If not specified, the default depends on the target.\n \n-## no-vectorize-slp\n+## passes\n \n-By default, `rustc` will attempt to vectorize code using [superword-level\n-parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer). This\n-flag will turn that behavior off.\n+This flag can be used to add extra [LLVM\n+passes](http://llvm.org/docs/Passes.html) to the compilation.\n \n-## soft-float\n+The list must be separated by spaces.\n \n-This option will make `rustc` generate code using \"soft floats.\" By default,\n-a lot of hardware supports floating point instructions, and so the code generated\n-will take advantage of this. \"soft floats\" emulate floating point instructions\n-in software.\n+See also the [`no-prepopulate-passes`](#no-prepopulate-passes) flag.\n \n ## prefer-dynamic\n \n@@ -201,65 +373,68 @@ indicate that dynamic linking should be used if possible if both a static and\n dynamic versions of a library are available. There is an internal algorithm\n for determining whether or not it is possible to statically or dynamically\n link with a dependency. For example, `cdylib` crate types may only use static\n-linkage.\n-\n-## no-integrated-as\n+linkage. This flag takes one of the following values:\n \n-`rustc` normally uses the LLVM internal assembler to create object code. This\n-flag will disable the internal assembler and emit assembly code to be\n-translated using an external assembler, currently the linker such as `cc`.\n+* `y`, `yes`, `on`, or no value: use dynamic linking.\n+* `n`, `no`, or `off`: use static linking (the default).\n \n-## no-redzone\n+## profile-generate\n \n-This flag allows you to disable [the\n-red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). This flag can\n-be passed one of the following options:\n+This flag allows for creating instrumented binaries that will collect\n+profiling data for use with profile-guided optimization (PGO). The flag takes\n+an optional argument which is the path to a directory into which the\n+instrumented binary will emit the collected data. See the chapter on\n+[profile-guided optimization] for more information.\n \n-* `y`, `yes`, `on`, or no value: Disables the red zone.\n-* `n`, `no`, or `off`: Enables the red zone.\n+## profile-use\n \n-The default if not specified depends on the target.\n+This flag specifies the profiling data file to be used for profile-guided\n+optimization (PGO). The flag takes a mandatory argument which is the path\n+to a valid `.profdata` file. See the chapter on\n+[profile-guided optimization] for more information.\n \n ## relocation-model\n \n-This option lets you choose which\n-[relocation](https://en.wikipedia.org/wiki/Relocation_\\(computing\\)) model to\n-use.\n-\n-To find the valid options for this flag, run `rustc --print relocation-models`.\n+This option controls generation of\n+[position-independent code (PIC)](https://en.wikipedia.org/wiki/Position-independent_code).\n \n-## code-model\n+Supported values for this option are:\n \n-This option lets you choose which code model to use.\n+#### Primary relocation models\n \n-To find the valid options for this flag, run `rustc --print code-models`.\n-\n-## metadata\n+- `static` - non-relocatable code, machine instructions may use absolute addressing modes.\n \n-This option allows you to control the metadata used for symbol mangling. This\n-takes a space-separated list of strings. Mangled symbols will incorporate a\n-hash of the metadata. This may be used, for example, to differentiate symbols\n-between two different versions of the same crate being linked.\n+- `pic` - fully relocatable position independent code,\n+machine instructions need to use relative addressing modes.  \\\n+Equivalent to the \"uppercase\" `-fPIC` or `-fPIE` options in other compilers,\n+depending on the produced crate types.  \\\n+This is the default model for majority of supported targets.\n \n-## extra-filename\n+#### Special relocation models\n \n-This option allows you to put extra data in each output filename. It takes a\n-string to add as a suffix to the filename. See the [`--emit`\n-flag][option-emit] for more information.\n+- `dynamic-no-pic` - relocatable external references, non-relocatable code.  \\\n+Only makes sense on Darwin and is rarely used.  \\\n+If StackOverflow tells you to use this as an opt-out of PIC or PIE, don't believe it,\n+use `-C relocation-model=static` instead.\n+- `ropi`, `rwpi` and `ropi-rwpi` - relocatable code and read-only data, relocatable read-write data,\n+and combination of both, respectively.  \\\n+Only makes sense for certain embedded ARM targets.\n+- `default` - relocation model default to the current target.  \\\n+Only makes sense as an override for some other explicitly specified relocation model\n+previously set on the command line.\n \n-## codegen-units\n+Supported values can also be discovered by running `rustc --print relocation-models`.\n \n-This flag controls how many code generation units the crate is split into. It\n-takes an integer greater than 0.\n+#### Linking effects\n \n-When a crate is split into multiple codegen units, LLVM is able to process\n-them in parallel. Increasing parallelism may speed up compile times, but may\n-also produce slower code. Setting this to 1 may improve the performance of\n-generated code, but may be slower to compile.\n+In addition to codegen effects, `relocation-model` has effects during linking.\n \n-The default, if not specified, is 16. This flag is ignored if\n-[incremental](#incremental) is enabled, in which case an internal heuristic is\n-used to split the crate.\n+If the relocation model is `pic` and the current target supports position-independent executables\n+(PIE), the linker will be instructed (`-pie`) to produce one.  \\\n+If the target doesn't support both position-independent and statically linked executables,\n+then `-C target-feature=+crt-static` \"wins\" over `-C relocation-model=pic`,\n+and the linker is instructed (`-static`) to produce a statically linked\n+but not position-independent executable.\n \n ## remark\n \n@@ -269,118 +444,67 @@ The list of passes should be separated by spaces.\n \n `all` will remark on every pass.\n \n-## no-stack-check\n-\n-This option is deprecated and does nothing.\n-\n-## debuginfo\n-\n-This flag lets you control debug information:\n-\n-* `0`: no debug info at all (default)\n-* `1`: line tables only\n-* `2`: full debug info\n-\n-Note: The [`-g` flag][option-g-debug] is an alias for `-C debuginfo=2`.\n-\n-## opt-level\n-\n-This flag lets you control the optimization level.\n-\n-* `0`: no optimizations, also turns on [`cfg(debug_assertions)`](#debug-assertions).\n-* `1`: basic optimizations\n-* `2`: some optimizations\n-* `3`: all optimizations\n-* `s`: optimize for binary size\n-* `z`: optimize for binary size, but also turn off loop vectorization.\n-\n-Note: The [`-O` flag][option-o-optimize] is an alias for `-C opt-level=2`.\n-\n-The default is `0`.\n-\n-## debug-assertions\n-\n-This flag lets you turn `cfg(debug_assertions)` [conditional\n-compilation](../../reference/conditional-compilation.md#debug_assertions) on\n-or off. It takes one of the following values:\n-\n-* `y`, `yes`, `on`, or no value: Enable debug-assertions.\n-* `n`, `no`, or `off`: Disable debug-assertions.\n-\n-If not specified, debug assertions are automatically enabled only if the\n-[opt-level](#opt-level) is 0.\n-\n-## inline-threshold\n-\n-This option lets you set the default threshold for inlining a function. It\n-takes an unsigned integer as a value. Inlining is based on a cost model, where\n-a higher threshold will allow more inlining.\n-\n-The default depends on the [opt-level](#opt-level):\n+## rpath\n \n-| opt-level | Threshold |\n-|-----------|-----------|\n-| 0         | N/A, only inlines always-inline functions |\n-| 1         | N/A, only inlines always-inline functions and LLVM lifetime intrinsics |\n-| 2         | 225 |\n-| 3         | 275 |\n-| s         | 75 |\n-| z         | 25 |\n+This flag controls whether [`rpath`](https://en.wikipedia.org/wiki/Rpath) is\n+enabled. It takes one of the following values:\n \n-## panic\n+* `y`, `yes`, `on`, or no value: enable rpath.\n+* `n`, `no`, or `off`: disable rpath (the default).\n \n-This option lets you control what happens when the code panics.\n+## save-temps\n \n-* `abort`: terminate the process upon panic\n-* `unwind`: unwind the stack upon panic\n+This flag controls whether temporary files generated during compilation are\n+deleted once compilation finishes. It takes one of the following values:\n \n-If not specified, the default depends on the target.\n+* `y`, `yes`, `on`, or no value: save temporary files.\n+* `n`, `no`, or `off`: delete temporary files (the default).\n \n-## incremental\n+## soft-float\n \n-This flag allows you to enable incremental compilation, which allows `rustc`\n-to save information after compiling a crate to be reused when recompiling the\n-crate, improving re-compile times. This takes a path to a directory where\n-incremental files will be stored.\n+This option controls whether `rustc` generates code that emulates floating\n+point instructions in software. It takes one of the following values:\n \n-## profile-generate\n+* `y`, `yes`, `on`, or no value: use soft floats.\n+* `n`, `no`, or `off`: use hardware floats (the default).\n \n-This flag allows for creating instrumented binaries that will collect\n-profiling data for use with profile-guided optimization (PGO). The flag takes\n-an optional argument which is the path to a directory into which the\n-instrumented binary will emit the collected data. See the chapter on\n-[profile-guided optimization] for more information.\n-\n-## profile-use\n+## target-cpu\n \n-This flag specifies the profiling data file to be used for profile-guided\n-optimization (PGO). The flag takes a mandatory argument which is the path\n-to a valid `.profdata` file. See the chapter on\n-[profile-guided optimization] for more information.\n+This instructs `rustc` to generate code specifically for a particular processor.\n \n-## force-frame-pointers\n+You can run `rustc --print target-cpus` to see the valid options to pass\n+here. Additionally, `native` can be passed to use the processor of the host\n+machine. Each target has a default base CPU.\n \n-This flag forces the use of frame pointers. It takes one of the following\n-values:\n+## target-feature\n \n-* `y`, `yes`, `on`, or no value: Frame pointers are forced to be enabled.\n-* `n`, `no`, or `off`: Frame pointers are not forced to be enabled. This does\n-  not necessarily mean frame pointers will be removed.\n+Individual targets will support different features; this flag lets you control\n+enabling or disabling a feature. Each feature should be prefixed with a `+` to\n+enable it or `-` to disable it.\n \n-The default if not specified depends on the target.\n+Features from multiple `-C target-feature` options are combined. \\\n+Multiple features can be specified in a single option by separating them\n+with commas - `-C target-feature=+x,-y`. \\\n+If some feature is specified more than once with both `+` and `-`,\n+then values passed later override values passed earlier. \\\n+For example, `-C target-feature=+x,-y,+z -Ctarget-feature=-x,+y`\n+is equivalent to `-C target-feature=-x,+y,+z`.\n \n-## default-linker-libraries\n+To see the valid options and an example of use, run `rustc --print\n+target-features`.\n \n-This flag controls whether or not the linker includes its default libraries.\n-It takes one of the following values:\n+Using this flag is unsafe and might result in [undefined runtime\n+behavior](../targets/known-issues.md).\n \n-* `y`, `yes`, `on`, or no value: Default libraries are included.\n-* `n`, `no`, or `off`: Default libraries are **not** included.\n+See also the [`target_feature`\n+attribute](../../reference/attributes/codegen.md#the-target_feature-attribute)\n+for controlling features per-function.\n \n-For example, for gcc flavor linkers, this issues the `-nodefaultlibs` flag to\n-the linker.\n+This also supports the feature `+crt-static` and `-crt-static` to control\n+[static C runtime linkage](../../reference/linkage.html#static-and-dynamic-c-runtimes).\n \n-The default is `yes` if not specified.\n+Each target and [`target-cpu`](#target-cpu) has a default set of enabled\n+features.\n \n [option-emit]: ../command-line-arguments.md#option-emit\n [option-o-optimize]: ../command-line-arguments.md#option-o-optimize"}, {"sha": "5dee603142dcd006067653828627192ac6023f52", "filename": "src/doc/rustc/src/json.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fjson.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -59,8 +59,11 @@ Diagnostics have the following format:\n     \"spans\": [\n         {\n             /* The file where the span is located.\n-               For spans located within a macro expansion, this will be the\n-               name of the expanded macro in the format \"<MACRONAME macros>\".\n+               Note that this path may not exist. For example, if the path\n+               points to the standard library, and the rust src is not\n+               available in the sysroot, then it may point to a non-existent\n+               file. Beware that this may also point to the source of an\n+               external crate.\n             */\n             \"file_name\": \"lib.rs\",\n             /* The byte offset where the span starts (0-based, inclusive). */"}, {"sha": "c0b14352b7d1a6be4dacb64f0c05188db98d0b4a", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -100,11 +100,17 @@ LLVM. However, the approximation is usually reliable.\n \n The following table shows known good combinations of toolchain versions.\n \n-|           |  Clang 7  |  Clang 8  |\n-|-----------|-----------|-----------|\n-| Rust 1.34 |     \u2717     |     \u2713     |\n-| Rust 1.35 |     \u2717     |     \u2713     |\n-| Rust 1.36 |     \u2717     |     \u2713     |\n-| Rust 1.37 |     \u2717     |     \u2713     |\n+|           |  Clang 7  |  Clang 8  |  Clang 9  |\n+|-----------|-----------|-----------|-----------|\n+| Rust 1.34 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.35 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.36 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.37 |     \u2717     |     \u2713     |     \u2717     |\n+| Rust 1.38 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.39 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.40 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.41 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.42 |     \u2717     |     \u2717     |     \u2713     |\n+| Rust 1.43 |     \u2717     |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "64cbbbb003585fee465012f1115e831bb775d26c", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -170,7 +170,7 @@ The order of these command line arguments is taken into account. The following a\n $ rustc lib.rs --crate-type=lib -D unused-variables -A unused-variables\n ```\n \n-You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the `unused` group, but explicitly allows the `unused-variables` lint in that group:\n+You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the `unused` group, but explicitly allows the `unused-variables` lint in that group (forbid still trumps everything regardless of ordering):\n \n ```bash\n $ rustc lib.rs --crate-type=lib -D unused -A unused-variables"}, {"sha": "efadae1c5fb9d078f95828120999800f0084ceea", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -352,9 +352,9 @@ are added.\n /// ```\n ```\n \n-`edition2018` tells `rustdoc` that the code sample should be compiled the 2018\n-edition of Rust. Similarly, you can specify `edition2015` to compile the code\n-with the 2015 edition.\n+`edition2018` tells `rustdoc` that the code sample should be compiled using\n+the 2018 edition of Rust. Similarly, you can specify `edition2015` to compile\n+the code with the 2015 edition.\n \n ## Syntax reference\n "}, {"sha": "081e477de8010ce0db928b68d7fec560c4a1bba9", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -17,7 +17,7 @@ By default, rustdoc will run some passes, namely:\n * `collapse-docs`\n * `unindent-comments`\n \n-However, `strip-private` implies `strip-private-imports`, and so effectively,\n+However, `strip-private` implies `strip-priv-imports`, and so effectively,\n all passes are run by default.\n \n ## `strip-hidden`"}, {"sha": "0cd56d0940451ab40a0391c193c685e7b333342c", "filename": "src/doc/unstable-book/book.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fbook.toml?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,6 @@\n [book]\n title = \"The Rust Unstable Book\"\n author = \"The Rust Community\"\n+\n+[output.html]\n+git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/unstable-book\""}, {"sha": "7ebd8054ba0b0d19361365675332ba55b1d32eb2", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 150, "deletions": 86, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -6,73 +6,78 @@ The tracking issue for this feature is: [#39699](https://github.com/rust-lang/ru\n \n This feature allows for use of one of following sanitizers:\n \n-* [AddressSanitizer][clang-asan] a faster memory error detector. Can\n-  detect out-of-bounds access to heap, stack, and globals, use after free, use\n-  after return, double free, invalid free, memory leaks.\n+* [AddressSanitizer][clang-asan] a fast memory error detector.\n * [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n * [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n-To enable a sanitizer compile with `-Zsanitizer=...` option, where value is one\n-of `address`, `leak`, `memory` or `thread`.\n+To enable a sanitizer compile with `-Zsanitizer=address`, `-Zsanitizer=leak`,\n+`-Zsanitizer=memory` or `-Zsanitizer=thread`. Only a single sanitizer can be\n+enabled at a time.\n \n-# Examples\n+# AddressSanitizer\n \n-This sections show various issues that can be detected with sanitizers.  For\n-simplicity, the examples are prepared under assumption that optimization level\n-used is zero.\n+AddressSanitizer is a memory error detector. It can detect the following types\n+of bugs:\n \n-## AddressSanitizer\n+* Out of bound accesses to heap, stack and globals\n+* Use after free\n+* Use after return (runtime flag `ASAN_OPTIONS=detect_stack_use_after_return=1`)\n+* Use after scope\n+* Double-free, invalid free\n+* Memory leaks\n+\n+AddressSanitizer is supported on the following targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+AddressSanitizer works with non-instrumented code although it will impede its\n+ability to detect some bugs.  It is not expected to produce false positive\n+reports.\n+\n+## Examples\n \n Stack buffer overflow:\n \n-```shell\n-$ cat a.rs\n+```rust\n fn main() {\n     let xs = [0, 1, 2, 3];\n     let _y = unsafe { *xs.as_ptr().offset(4) };\n }\n-$ rustc -Zsanitizer=address a.rs\n-$ ./a\n-=================================================================\n-==10029==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc15f43d0 at pc 0x55f77dc015c5 bp 0x7ffcc15f4390 sp 0x7ffcc15f4388\n-READ of size 4 at 0x7ffcc15f43d0 thread T0\n-    #0 0x55f77dc015c4 in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa5c4)\n-    #1 0x55f77dc01cdb in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::haa8c76d1faa7b7ca (/tmp/a+0xacdb)\n-    #2 0x55f77dc90f02 in std::rt::lang_start_internal::_$u7b$$u7b$closure$u7d$$u7d$::hfeb9a1aef9ac820d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:48:12\n-    #3 0x55f77dc90f02 in std::panicking::try::do_call::h12f0919717b8e0a6 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:288:39\n-    #4 0x55f77dc926c9 in __rust_maybe_catch_panic /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libpanic_unwind/lib.rs:80:7\n-    #5 0x55f77dc9197c in std::panicking::try::h413b21cdcd6cfd86 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:267:12\n-    #6 0x55f77dc9197c in std::panic::catch_unwind::hc5cc8ef2fd73424d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panic.rs:396:8\n-    #7 0x55f77dc9197c in std::rt::lang_start_internal::h2039f418ab92218f /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:47:24\n-    #8 0x55f77dc01c61 in std::rt::lang_start::ha905d28f6b61d691 (/tmp/a+0xac61)\n-    #9 0x55f77dc0163a in main (/tmp/a+0xa63a)\n-    #10 0x7f9b3cf5bbba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #11 0x55f77dc01289 in _start (/tmp/a+0xa289)\n-\n-Address 0x7ffcc15f43d0 is located in stack of thread T0 at offset 48 in frame\n-    #0 0x55f77dc0135f in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa35f)\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208\n+READ of size 4 at 0x7ffe400e6250 thread T0\n+    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23\n+    ...\n+\n+Address 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame\n+    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1\n \n   This frame has 1 object(s):\n-    [32, 48) 'xs' <== Memory access at offset 48 overflows this variable\n+    [32, 48) 'xs' (line 2) <== Memory access at offset 48 overflows this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-buffer-overflow (/tmp/a+0xa5c4) in a::main::hab3bd2a745c2d0ac\n+SUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2\n Shadow bytes around the buggy address:\n-  0x1000182b6820: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6830: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6840: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6850: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6860: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x1000182b6870: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n-  0x1000182b6880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n+  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00\n+  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n-  Partially addressable: 01 02 03 04 05 06 07 \n+  Partially addressable: 01 02 03 04 05 06 07\n   Heap left redzone:       fa\n   Freed heap region:       fd\n   Stack left redzone:      f1\n@@ -90,13 +95,12 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==10029==ABORTING\n+==37882==ABORTING\n ```\n \n Use of a stack object after its scope has already ended:\n \n-```shell\n-$ cat b.rs\n+```rust\n static mut P: *mut usize = std::ptr::null_mut();\n \n fn main() {\n@@ -108,42 +112,38 @@ fn main() {\n         std::ptr::write_volatile(P, 123);\n     }\n }\n-$ rustc -Zsanitizer=address b.rs\n-$./b\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n =================================================================\n-==424427==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff67be6be0 at pc 0x5647a3ea4658 bp 0x7fff67be6b90 sp 0x7fff67be6b88\n-WRITE of size 8 at 0x7fff67be6be0 thread T0\n-    #0 0x5647a3ea4657 in core::ptr::write_volatile::h4b04601757d0376d (/tmp/b+0xb8657)\n-    #1 0x5647a3ea4432 in b::main::h5574a756e615c9cf (/tmp/b+0xb8432)\n-    #2 0x5647a3ea480b in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::hd57e7ee01866077e (/tmp/b+0xb880b)\n-    #3 0x5647a3eab412 in std::panicking::try::do_call::he0421ca82dd11ba3 (.llvm.8083791802951296215) (/tmp/b+0xbf412)\n-    #4 0x5647a3eacb26 in __rust_maybe_catch_panic (/tmp/b+0xc0b26)\n-    #5 0x5647a3ea5b66 in std::rt::lang_start_internal::h19bc96b28f670a64 (/tmp/b+0xb9b66)\n-    #6 0x5647a3ea4788 in std::rt::lang_start::h642d10b4b6965fb8 (/tmp/b+0xb8788)\n-    #7 0x5647a3ea449a in main (/tmp/b+0xb849a)\n-    #8 0x7fd1d18b3bba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #9 0x5647a3df7299 in _start (/tmp/b+0xb299)\n-\n-Address 0x7fff67be6be0 is located in stack of thread T0 at offset 32 in frame\n-    #0 0x5647a3ea433f in b::main::h5574a756e615c9cf (/tmp/b+0xb833f)\n+==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048\n+WRITE of size 8 at 0x7ffc7ed3e1a0 thread T0\n+    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5\n+    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9\n+    ...\n+\n+Address 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame\n+    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3\n \n   This frame has 1 object(s):\n-    [32, 40) 'x' <== Memory access at offset 32 is inside this variable\n+    [32, 40) 'x' (line 6) <== Memory access at offset 32 is inside this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-use-after-scope (/tmp/b+0xb8657) in core::ptr::write_volatile::h4b04601757d0376d\n+SUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a\n Shadow bytes around the buggy address:\n-  0x10006cf74d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x10006cf74d70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1[f8]f3 f3 f3\n-  0x10006cf74d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74da0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74dc0: f1 f1 f1 f1 00 f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3\n+  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n   Partially addressable: 01 02 03 04 05 06 07\n@@ -164,17 +164,26 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==424427==ABORTING\n+==39249==ABORTING\n ```\n \n-## MemorySanitizer\n+# MemorySanitizer\n+\n+MemorySanitizer is detector of uninitialized reads. It is only supported on the\n+`x86_64-unknown-linux-gnu` target.\n+\n+MemorySanitizer requires all program code to be instrumented. C/C++ dependencies\n+need to be recompiled using Clang with `-fsanitize=memory` option. Failing to\n+achieve that will result in false positive reports.\n+\n+## Example\n \n-Use of uninitialized memory. Note that we are using `-Zbuild-std` to instrument\n-the standard library, and passing `-Zsanitizer-track-origins` to track the\n+Detecting the use of uninitialized memory. The `-Zbuild-std` flag rebuilds and\n+instruments the standard library, and is strictly necessary for the correct\n+operation of the tool. The `-Zsanitizer-track-origins` enables tracking of the\n origins of uninitialized memory:\n \n-```shell\n-$ cat src/main.rs\n+```rust\n use std::mem::MaybeUninit;\n \n fn main() {\n@@ -184,7 +193,9 @@ fn main() {\n         println!(\"{}\", a[2]);\n     }\n }\n+```\n \n+```shell\n $ export \\\n   CC=clang \\\n   CXX=clang++ \\\n@@ -193,7 +204,7 @@ $ export \\\n   RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \\\n   RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'\n $ cargo clean\n-$ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n ==9416==WARNING: MemorySanitizer: use-of-uninitialized-value\n     #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16\n ...\n@@ -205,6 +216,55 @@ $ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n     #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3\n ```\n \n+# ThreadSanitizer\n+\n+ThreadSanitizer is a data race detection tool. It is supported on the following\n+targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+To work correctly ThreadSanitizer needs to be \"aware\" of all synchronization\n+operations in a program. It generally achieves that through combination of\n+library interception (for example synchronization performed through\n+`pthread_mutex_lock` / `pthread_mutex_unlock`) and compile time instrumentation\n+(e.g. atomic operations). Using it without instrumenting all the program code\n+can lead to false positive reports.\n+\n+ThreadSanitizer does not support atomic fences `std::sync::atomic::fence`,\n+nor synchronization performed using inline assembly code.\n+\n+## Example\n+\n+```rust\n+static mut A: usize = 0;\n+\n+fn main() {\n+    let t = std::thread::spawn(|| {\n+        unsafe { A += 1 };\n+    });\n+    unsafe { A += 1 };\n+\n+    t.join().unwrap();\n+}\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==================\n+WARNING: ThreadSanitizer: data race (pid=10574)\n+  Read of size 8 at 0x5632dfe3d030 by thread T1:\n+    #0 example::main::_$u7b$$u7b$closure$u7d$$u7d$::h23f64b0b2f8c9484 ../src/main.rs:5:18 (example+0x86cec)\n+    ...\n+\n+  Previous write of size 8 at 0x5632dfe3d030 by main thread:\n+    #0 example::main::h628ffc6626ed85b2 /.../src/main.rs:7:14 (example+0x868c8)\n+    ...\n+    #11 main <null> (example+0x86a1a)\n+\n+  Location is global 'example::A::h43ac149ddf992709' of size 8 at 0x5632dfe3d030 (example+0x000000bd9030)\n+```\n \n # Instrumentation of external dependencies and std\n \n@@ -231,6 +291,10 @@ In more practical terms when using cargo always remember to pass `--target`\n flag, so that rustflags will not be applied to build scripts and procedural\n macros.\n \n+# Symbolizing the Reports\n+\n+Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PATH`.\n+\n # Additional Information\n \n * [Sanitizers project page](https://github.com/google/sanitizers/wiki/)"}, {"sha": "5a7d0655a440aec788bee1d2c6565ed2797c2e00", "filename": "src/doc/unstable-book/src/compiler-flags/src-hash-algorithm.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsrc-hash-algorithm.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,11 @@\n+# `src-hash-algorithm`\n+\n+The tracking issue for this feature is: [#70401](https://github.com/rust-lang/rust/issues/70401).\n+\n+------------------------\n+\n+The `-Z src-hash-algorithm` compiler flag controls which algorithm is used when hashing each source file. The hash is stored in the debug info and can be used by a debugger to verify the source code matches the executable.\n+\n+Supported hash algorithms are: `md5`, and `sha1`. Note that not all hash algorithms are supported by all debug info formats.\n+\n+By default, the compiler chooses the hash algorithm based on the target specification."}, {"sha": "52cb98113c0c13296221f34d0daa6bfee04231cf", "filename": "src/doc/unstable-book/src/compiler-flags/strip.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,17 @@\n+# `strip`\n+\n+The tracking issue for this feature is: [#72110](https://github.com/rust-lang/rust/issues/72110).\n+\n+------------------------\n+\n+Option `-Z strip=val` controls stripping of debuginfo and similar auxiliary data from binaries\n+during linking.\n+\n+Supported values for this option are:\n+\n+- `none` - debuginfo and symbols (if they exist) are copied to the produced binary or separate files\n+depending on the target (e.g. `.pdb` files in case of MSVC).\n+- `debuginfo` - debuginfo sections and debuginfo symbols from the symbol table section\n+are stripped at link time and are not copied to the produced binary or separate files.\n+- `symbols` - same as `debuginfo`, but the rest of the symbol table section is stripped as well\n+if the linker supports it."}, {"sha": "0aefaa7fb01773794d5ca522ab18952ea8bc79cb", "filename": "src/doc/unstable-book/src/compiler-flags/tls-model.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,25 @@\n+# `tls_model`\n+\n+The tracking issue for this feature is: None.\n+\n+------------------------\n+\n+Option `-Z tls-model` controls [TLS model](https://www.akkadia.org/drepper/tls.pdf) used to\n+generate code for accessing `#[thread_local]` `static` items.\n+\n+Supported values for this option are:\n+\n+- `global-dynamic` - General Dynamic TLS Model (alternatively called Global Dynamic) is the most\n+general option usable in all circumstances, even if the TLS data is defined in a shared library\n+loaded at runtime and is accessed from code outside of that library.  \n+This is the default for most targets.\n+- `local-dynamic` - model usable if the TLS data is only accessed from the shared library or\n+executable it is defined in. The TLS data may be in a library loaded after startup (via `dlopen`).\n+- `initial-exec` - model usable if the TLS data is defined in the executable or in a shared library\n+loaded at program startup.\n+The TLS data must not be in a library loaded after startup (via `dlopen`).\n+- `local-exec` - model usable only if the TLS data is defined directly in the executable,\n+but not in a shared library, and is accessed only from that executable.\n+\n+`rustc` and LLVM may use a more optimized model than specified if they know that we are producing\n+and executable rather than a library, or that the `static` item is private enough."}, {"sha": "3442abf46df86cae98e4a85482b84b5d37caa2c9", "filename": "src/doc/unstable-book/src/language-features/cfg-sanitize.md", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-sanitize.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -11,26 +11,24 @@ depending on whether a particular sanitizer is enabled or not.\n \n ## Examples\n \n-``` rust\n+```rust\n #![feature(cfg_sanitize)]\n \n #[cfg(sanitize = \"thread\")]\n fn a() {\n-  // ...\n+    // ...\n }\n \n #[cfg(not(sanitize = \"thread\"))]\n fn a() {\n-  // ...\n+    // ...\n }\n \n fn b() {\n-  if cfg!(sanitize = \"leak\") {\n-    // ...\n-  } else {\n-    // ...\n-  }\n+    if cfg!(sanitize = \"leak\") {\n+        // ...\n+    } else {\n+        // ...\n+    }\n }\n-\n ```\n-"}, {"sha": "2b1e50835b7676ace00a28da09b1fdf041113f07", "filename": "src/doc/unstable-book/src/language-features/cfg-version.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfg-version.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,34 @@\n+# `cfg_version`\n+\n+The tracking issue for this feature is: [#64796]\n+\n+[#64796]: https://github.com/rust-lang/rust/issues/64796\n+\n+------------------------\n+\n+The `cfg_version` feature makes it possible to execute different code\n+depending on the compiler version.\n+\n+## Examples\n+\n+```rust\n+#![feature(cfg_version)]\n+\n+#[cfg(version(\"1.42\"))]\n+fn a() {\n+    // ...\n+}\n+\n+#[cfg(not(version(\"1.42\")))]\n+fn a() {\n+    // ...\n+}\n+\n+fn b() {\n+    if cfg!(version(\"1.42\")) {\n+        // ...\n+    } else {\n+        // ...\n+    }\n+}\n+```"}, {"sha": "9a1ced4033b2201772943a47a642d854bc04e8e2", "filename": "src/doc/unstable-book/src/language-features/ffi-const.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-const.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,47 @@\n+# `ffi_const`\n+\n+The `#[ffi_const]` attribute applies clang's `const` attribute to foreign\n+functions declarations.\n+\n+That is, `#[ffi_const]` functions shall have no effects except for its return\n+value, which can only depend on the values of the function parameters, and is\n+not affected by changes to the observable state of the program.\n+\n+Applying the `#[ffi_const]` attribute to a function that violates these\n+requirements is undefined behaviour.\n+\n+This attribute enables Rust to perform common optimizations, like sub-expression\n+elimination, and it can avoid emitting some calls in repeated invocations of the\n+function with the same argument values regardless of other operations being\n+performed in between these functions calls (as opposed to `#[ffi_pure]`\n+functions).\n+\n+## Pitfalls\n+\n+A `#[ffi_const]` function can only read global memory that would not affect\n+its return value for the whole execution of the program (e.g. immutable global\n+memory). `#[ffi_const]` functions are referentially-transparent and therefore\n+more strict than `#[ffi_pure]` functions.\n+\n+A common pitfall involves applying the `#[ffi_const]` attribute to a\n+function that reads memory through pointer arguments which do not necessarily\n+point to immutable global memory.\n+\n+A `#[ffi_const]` function that returns unit has no effect on the abstract\n+machine's state, and a `#[ffi_const]` function cannot be `#[ffi_pure]`.\n+\n+A `#[ffi_const]` function must not diverge, neither via a side effect (e.g. a\n+call to `abort`) nor by infinite loops.\n+\n+When translating C headers to Rust FFI, it is worth verifying for which targets\n+the `const` attribute is enabled in those headers, and using the appropriate\n+`cfg` macros in the Rust side to match those definitions. While the semantics of\n+`const` are implemented identically by many C and C++ compilers, e.g., clang,\n+[GCC], [ARM C/C++ compiler], [IBM ILE C/C++], etc. they are not necessarily\n+implemented in this way on all of them. It is therefore also worth verifying\n+that the semantics of the C toolchain used to compile the binary being linked\n+against are compatible with those of the `#[ffi_const]`.\n+\n+[ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacgigch.html\n+[GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-const-function-attribute\n+[IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_const.htm"}, {"sha": "7bfd7a378f00bff14f17c2e6cd5a9b7bf55deea2", "filename": "src/doc/unstable-book/src/language-features/ffi-pure.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fffi-pure.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,51 @@\n+# `ffi_pure`\n+\n+The `#[ffi_pure]` attribute applies clang's `pure` attribute to foreign\n+functions declarations.\n+\n+That is, `#[ffi_pure]` functions shall have no effects except for its return\n+value, which shall not change across two consecutive function calls with\n+the same parameters.\n+\n+Applying the `#[ffi_pure]` attribute to a function that violates these\n+requirements is undefined behavior.\n+\n+This attribute enables Rust to perform common optimizations, like sub-expression\n+elimination and loop optimizations. Some common examples of pure functions are\n+`strlen` or `memcmp`.\n+\n+These optimizations are only applicable when the compiler can prove that no\n+program state observable by the `#[ffi_pure]` function has changed between calls\n+of the function, which could alter the result. See also the `#[ffi_const]`\n+attribute, which provides stronger guarantees regarding the allowable behavior\n+of a function, enabling further optimization.\n+\n+## Pitfalls\n+\n+A `#[ffi_pure]` function can read global memory through the function\n+parameters (e.g. pointers), globals, etc. `#[ffi_pure]` functions are not\n+referentially-transparent, and are therefore more relaxed than `#[ffi_const]`\n+functions.\n+\n+However, accesing global memory through volatile or atomic reads can violate the\n+requirement that two consecutive function calls shall return the same value.\n+\n+A `pure` function that returns unit has no effect on the abstract machine's\n+state.\n+\n+A `#[ffi_pure]` function must not diverge, neither via a side effect (e.g. a\n+call to `abort`) nor by infinite loops.\n+\n+When translating C headers to Rust FFI, it is worth verifying for which targets\n+the `pure` attribute is enabled in those headers, and using the appropriate\n+`cfg` macros in the Rust side to match those definitions. While the semantics of\n+`pure` are implemented identically by many C and C++ compilers, e.g., clang,\n+[GCC], [ARM C/C++ compiler], [IBM ILE C/C++], etc. they are not necessarily\n+implemented in this way on all of them. It is therefore also worth verifying\n+that the semantics of the C toolchain used to compile the binary being linked\n+against are compatible with those of the `#[ffi_pure]`.\n+\n+\n+[ARM C/C++ compiler]: http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0491c/Cacigdac.html\n+[GCC]: https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-pure-function-attribute\n+[IBM ILE C/C++]: https://www.ibm.com/support/knowledgecenter/fr/ssw_ibm_i_71/rzarg/fn_attrib_pure.htm"}, {"sha": "7b865c9c679bc0f27d2de2d04eb5380f7365a937", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -87,7 +87,7 @@ Feedback on the design and usage is always appreciated!\n \n The `Generator` trait in `std::ops` currently looks like:\n \n-```\n+```rust\n # #![feature(arbitrary_self_types, generator_trait)]\n # use std::ops::GeneratorState;\n # use std::pin::Pin;\n@@ -107,7 +107,7 @@ point for executing the `Generator` itself.\n \n The return value of `resume`, `GeneratorState`, looks like:\n \n-```\n+```rust\n pub enum GeneratorState<Y, R> {\n     Yielded(Y),\n     Complete(R),"}, {"sha": "20c7d7dcec8d6a512f668a03ac55b65b391ee047", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -287,6 +287,7 @@ the source code.\n   - `unsize`: `libcore/marker.rs`\n   - `sync`: `libcore/marker.rs`\n   - `phantom_data`: `libcore/marker.rs`\n+  - `discriminant_kind`: `libcore/marker.rs`\n   - `freeze`: `libcore/marker.rs`\n   - `debug_trait`: `libcore/fmt/mod.rs`\n   - `non_zero`: `libcore/nonzero.rs`"}, {"sha": "151520f0e4abc4a5328c8f6105a4c25686ddba81", "filename": "src/doc/unstable-book/src/language-features/negative-impls.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnegative-impls.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnegative-impls.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnegative-impls.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,57 @@\n+# `negative_impls`\n+\n+The tracking issue for this feature is [#68318].\n+\n+[#68318]: https://github.com/rust-lang/rust/issues/68318\n+\n+----\n+\n+With the feature gate `negative_impls`, you can write negative impls as well as positive ones:\n+\n+```rust\n+#![feature(negative_impls)]\n+trait DerefMut { }\n+impl<T: ?Sized> !DerefMut for &T { }\n+```\n+\n+Negative impls indicate a semver guarantee that the given trait will not be implemented for the given types. Negative impls play an additional purpose for auto traits, described below.\n+\n+Negative impls have the following characteristics:\n+\n+* They do not have any items.\n+* They must obey the orphan rules as if they were a positive impl.\n+* They cannot \"overlap\" with any positive impls.\n+\n+## Semver interaction\n+\n+It is a breaking change to remove a negative impl. Negative impls are a commitment not to implement the given trait for the named types.\n+\n+## Orphan and overlap rules\n+\n+Negative impls must obey the same orphan rules as a positive impl. This implies you cannot add a negative impl for types defined in upstream crates and so forth.\n+\n+Similarly, negative impls cannot overlap with positive impls, again using the same \"overlap\" check that we ordinarily use to determine if two impls overlap. (Note that positive impls typically cannot overlap with one another either, except as permitted by specialization.)\n+\n+## Interaction with auto traits\n+\n+Declaring a negative impl `impl !SomeAutoTrait for SomeType` for an\n+auto-trait serves two purposes:\n+\n+* as with any trait, it declares that `SomeType` will never implement `SomeAutoTrait`;\n+* it disables the automatic `SomeType: SomeAutoTrait` impl that would otherwise have been generated.\n+\n+Note that, at present, there is no way to indicate that a given type\n+does not implement an auto trait *but that it may do so in the\n+future*. For ordinary types, this is done by simply not declaring any\n+impl at all, but that is not an option for auto traits. A workaround\n+is that one could embed a marker type as one of the fields, where the\n+marker type is `!AutoTrait`.\n+\n+## Immediate uses\n+\n+Negative impls are used to declare that `&T: !DerefMut`  and `&mut T: !Clone`, as required to fix the soundness of `Pin` described in [#66544](https://github.com/rust-lang/rust/issues/66544).\n+\n+This serves two purposes:\n+\n+* For proving the correctness of unsafe code, we can use that impl as evidence that no `DerefMut` or `Clone` impl exists.\n+* It prevents downstream crates from creating such impls."}, {"sha": "6f0f0cfd33e4dad6f788336f392be53259a22e61", "filename": "src/doc/unstable-book/src/language-features/optin-builtin-traits.md", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Foptin-builtin-traits.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -10,7 +10,8 @@ The `optin_builtin_traits` feature gate allows you to define auto traits.\n \n Auto traits, like [`Send`] or [`Sync`] in the standard library, are marker traits\n that are automatically implemented for every type, unless the type, or a type it contains, \n-has explicitly opted out via a negative impl. \n+has explicitly opted out via a negative impl. (Negative impls are separately controlled\n+by the `negative_impls` feature.)\n \n [`Send`]: https://doc.rust-lang.org/std/marker/trait.Send.html\n [`Sync`]: https://doc.rust-lang.org/std/marker/trait.Sync.html\n@@ -22,6 +23,7 @@ impl !Trait for Type\n Example:\n \n ```rust\n+#![feature(negative_impls)]\n #![feature(optin_builtin_traits)]\n \n auto trait Valid {}\n@@ -43,3 +45,63 @@ fn main() {\n     // must_be_valid( MaybeValid(False) );\n }\n ```\n+\n+## Automatic trait implementations\n+\n+When a type is declared as an `auto trait`, we will automatically\n+create impls for every struct/enum/union, unless an explicit impl is\n+provided. These automatic impls contain a where clause for each field\n+of the form `T: AutoTrait`, where `T` is the type of the field and\n+`AutoTrait` is the auto trait in question. As an example, consider the\n+struct `List` and the auto trait `Send`:\n+\n+```rust\n+struct List<T> {\n+  data: T,\n+  next: Option<Box<List<T>>>,\n+}\n+```\n+\n+Presuming that there is no explicit impl of `Send` for `List`, the\n+compiler will supply an automatic impl of the form:\n+\n+```rust\n+struct List<T> {\n+  data: T,\n+  next: Option<Box<List<T>>>,\n+}\n+\n+unsafe impl<T> Send for List<T>\n+where\n+  T: Send, // from the field `data`\n+  Option<Box<List<T>>>: Send, // from the field `next`\n+{ }\n+```\n+\n+Explicit impls may be either positive or negative. They take the form:\n+\n+```rust,ignore\n+impl<...> AutoTrait for StructName<..> { }\n+impl<...> !AutoTrait for StructName<..> { }\n+```\n+\n+## Coinduction: Auto traits permit cyclic matching\n+\n+Unlike ordinary trait matching, auto traits are **coinductive**. This\n+means, in short, that cycles which occur in trait matching are\n+considered ok. As an example, consider the recursive struct `List`\n+introduced in the previous section. In attempting to determine whether\n+`List: Send`, we would wind up in a cycle: to apply the impl, we must\n+show that `Option<Box<List>>: Send`, which will in turn require\n+`Box<List>: Send` and then finally `List: Send` again. Under ordinary\n+trait matching, this cycle would be an error, but for an auto trait it\n+is considered a successful match.\n+\n+## Items\n+\n+Auto traits cannot have any trait items, such as methods or associated types. This ensures that we can generate default implementations.\n+\n+## Supertraits\n+\n+Auto traits cannot have supertraits. This is for soundness reasons, as the interaction of coinduction with implied bounds is difficult to reconcile.\n+"}, {"sha": "0b68991fce2a1053538de77b9ec7805edcae4839", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 634, "deletions": 128, "changes": 762, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,193 +1,699 @@\n # `asm`\n \n-The tracking issue for this feature is: [#29722]\n+The tracking issue for this feature is: [#72016]\n \n-[#29722]: https://github.com/rust-lang/rust/issues/29722\n+[#72016]: https://github.com/rust-lang/rust/issues/72016\n \n ------------------------\n \n For extremely low-level manipulations and performance reasons, one\n might wish to control the CPU directly. Rust supports using inline\n assembly to do this via the `asm!` macro.\n \n-```rust,ignore\n-asm!(assembly template\n-   : output operands\n-   : input operands\n-   : clobbers\n-   : options\n-   );\n+# Guide-level explanation\n+[guide-level-explanation]: #guide-level-explanation\n+\n+Rust provides support for inline assembly via the `asm!` macro.\n+It can be used to embed handwritten assembly in the assembly output generated by the compiler.\n+Generally this should not be necessary, but might be where the required performance or timing\n+cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but ARM, AArch64 and RISC-V are also supported.\n+\n+## Basic usage\n+\n+Let us start with the simplest possible example:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+unsafe {\n+    asm!(\"nop\");\n+}\n+```\n+\n+This will insert a NOP (no operation) instruction into the assembly generated by the compiler.\n+Note that all `asm!` invocations have to be inside an `unsafe` block, as they could insert\n+arbitrary instructions and break various invariants. The instructions to be inserted are listed\n+in the first argument of the `asm!` macro as a string literal.\n+\n+## Inputs and outputs\n+\n+Now inserting an instruction that does nothing is rather boring. Let us do something that\n+actually acts on data:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64;\n+unsafe {\n+    asm!(\"mov {}, 5\", out(reg) x);\n+}\n+assert_eq!(x, 5);\n ```\n \n-Any use of `asm` is feature gated (requires `#![feature(asm)]` on the\n-crate to allow) and of course requires an `unsafe` block.\n+This will write the value `5` into the `u64` variable `x`.\n+You can see that the string literal we use to specify instructions is actually a template string.\n+It is governed by the same rules as Rust [format strings][format-syntax].\n+The arguments that are inserted into the template however look a bit different then you may\n+be familiar with. First we need to specify if the variable is an input or an output of the\n+inline assembly. In this case it is an output. We declared this by writing `out`.\n+We also need to specify in what kind of register the assembly expects the variable.\n+In this case we put it in an arbitrary general purpose register by specifying `reg`.\n+The compiler will choose an appropriate register to insert into\n+the template and will read the variable from there after the inline assembly finishes executing.\n \n-> **Note**: the examples here are given in x86/x86-64 assembly, but\n-> all platforms are supported.\n+Let us see another example that also uses an input:\n \n-## Assembly template\n+```rust,allow_fail\n+# #![feature(asm)]\n+let i: u64 = 3;\n+let o: u64;\n+unsafe {\n+    asm!(\"\n+        mov {0}, {1}\n+        add {0}, {number}\n+    \", out(reg) o, in(reg) i, number = const 5);\n+}\n+assert_eq!(o, 8);\n+```\n \n-The `assembly template` is the only required parameter and must be a\n-literal string (i.e. `\"\"`)\n+This will add `5` to the input in variable `i` and write the result to variable `o`.\n+The particular way this assembly does this is first copying the value from `i` to the output,\n+and then adding `5` to it.\n \n-```rust\n-#![feature(asm)]\n+The example shows a few things:\n \n-#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn foo() {\n-    unsafe {\n-        asm!(\"NOP\");\n-    }\n+First we can see that inputs are declared by writing `in` instead of `out`.\n+\n+Second one of our operands has a type we haven't seen yet, `const`.\n+This tells the compiler to expand this argument to value directly inside the assembly template.\n+This is only possible for constants and literals.\n+\n+Third we can see that we can specify an argument number, or name as in any format string.\n+For inline assembly templates this is particularly useful as arguments are often used more than once.\n+For more complex inline assembly using this facility is generally recommended, as it improves\n+readability, and allows reordering instructions without changing the argument order.\n+\n+We can further refine the above example to avoid the `mov` instruction:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut x: u64 = 3;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x, number = const 5);\n+}\n+assert_eq!(x, 8);\n+```\n+\n+We can see that `inout` is used to specify an argument that is both input and output.\n+This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.\n+\n+It is also possible to specify different variables for the input and output parts of an `inout` operand:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let x: u64 = 3;\n+let y: u64;\n+unsafe {\n+    asm!(\"add {0}, {number}\", inout(reg) x => y, number = const 5);\n }\n+assert_eq!(y, 8);\n+```\n \n-// Other platforms:\n-#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-fn foo() { /* ... */ }\n+## Late output operands\n \n-fn main() {\n-    // ...\n-    foo();\n-    // ...\n+The Rust compiler is conservative with its allocation of operands. It is assumed that an `out`\n+can be written at any time, and can therefore not share its location with any other argument.\n+However, to guarantee optimal performance it is important to use as few registers as possible,\n+so they won't have to be saved and reloaded around the inline assembly block.\n+To achieve this Rust provides a `lateout` specifier. This can be used on any output that is\n+written only after all inputs have been consumed.\n+There is also a `inlateout` variant of this specifier.\n+\n+Here is an example where `inlateout` *cannot* be used:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+let c: u64 = 4;\n+unsafe {\n+    asm!(\"\n+        add {0}, {1}\n+        add {0}, {2}\n+    \", inout(reg) a, in(reg) b, in(reg) c);\n }\n+assert_eq!(a, 12);\n ```\n \n-(The `feature(asm)` and `#[cfg]`s are omitted from now on.)\n+Here the compiler is free to allocate the same register for inputs `b` and `c` since it knows they have the same value. However it must allocate a separate register for `a` since it uses `inout` and not `inlateout`. If `inlateout` was used, then `a` and `c` could be allocated to the same register, in which case the first instruction to overwrite the value of `c` and cause the assembly code to produce the wrong result.\n \n-Output operands, input operands, clobbers and options are all optional\n-but you must add the right number of `:` if you skip them:\n+However the following example can use `inlateout` since the output is only modified after all input registers have been read:\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\"\n-    :\n-    :\n-    : \"eax\"\n-   );\n-# } }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n+unsafe {\n+    asm!(\"add {0}, {1}\", inlateout(reg) a, in(reg) b);\n+}\n+assert_eq!(a, 8);\n ```\n \n-Whitespace also doesn't matter:\n+As you can see, this assembly fragment will still work correctly if `a` and `b` are assigned to the same register.\n+\n+## Explicit register operands\n+\n+Some instructions require that the operands be in a specific register.\n+Therefore, Rust inline assembly provides some more specific constraint specifiers.\n+While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n+among others can be addressed by their name.\n \n-```rust\n+```rust,allow_fail,no_run\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-asm!(\"xor %eax, %eax\" ::: \"eax\");\n-# } }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+let cmd = 0xd1;\n+unsafe {\n+    asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n+}\n ```\n \n-## Operands\n+In this example we call the `out` instruction to output the content of the `cmd` variable\n+to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand\n+we had to use the `eax` constraint specifier.\n+\n+Note that unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n \n-Input and output operands follow the same format: `:\n-\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n-expressions must be mutable lvalues, or not yet assigned:\n+Consider this example which uses the x86 `mul` instruction:\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn add(a: i32, b: i32) -> i32 {\n-    let c: i32;\n+fn mul(a: u64, b: u64) -> u128 {\n+    let lo: u64;\n+    let hi: u64;\n+\n     unsafe {\n-        asm!(\"add $2, $0\"\n-             : \"=r\"(c)\n-             : \"0\"(a), \"r\"(b)\n-             );\n+        asm!(\n+            // The x86 mul instruction takes rax as an implicit input and writes\n+            // the 128-bit result of the multiplication to rax:rdx.\n+            \"mul {}\",\n+            in(reg) a,\n+            inlateout(\"rax\") b => lo,\n+            lateout(\"rdx\") hi\n+        );\n     }\n-    c\n+\n+    (hi as u128) << 64 + lo as u128\n+}\n+```\n+\n+This uses the `mul` instruction to multiply two 64-bit inputs with a 128-bit result.\n+The only explicit operand is a register, that we fill from the variable `a`.\n+The second operand is implicit, and must be the `rax` register, which we fill from the variable `b`.\n+The lower 64 bits of the result are stored in `rax` from which we fill the variable `lo`.\n+The higher 64 bits are stored in `rdx` from which we fill the variable `hi`.\n+\n+## Clobbered registers\n+\n+In many cases inline assembly will modify state that is not needed as an output.\n+Usually this is either because we have to use a scratch register in the assembly,\n+or instructions modify state that we don't need to further examine.\n+This state is generally referred to as being \"clobbered\".\n+We need to tell the compiler about this since it may need to save and restore this state\n+around the inline assembly block.\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+let ebx: u32;\n+let ecx: u32;\n+\n+unsafe {\n+    asm!(\n+        \"cpuid\",\n+        // EAX 4 selects the \"Deterministic Cache Parameters\" CPUID leaf\n+        inout(\"eax\") 4 => _,\n+        // ECX 0 selects the L0 cache information.\n+        inout(\"ecx\") 0 => ecx,\n+        lateout(\"ebx\") ebx,\n+        lateout(\"edx\") _\n+    );\n }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn add(a: i32, b: i32) -> i32 { a + b }\n \n-fn main() {\n-    assert_eq!(add(3, 14159), 14162)\n+println!(\n+    \"L1 Cache: {}\",\n+    ((ebx >> 22) + 1) * (((ebx >> 12) & 0x3ff) + 1) * ((ebx & 0xfff) + 1) * (ecx + 1)\n+);\n+```\n+\n+In the example above we use the `cpuid` instruction to get the L1 cache size.\n+This instruction writes to `eax`, `ebx`, `ecx`, and `edx`, but for the cache size we only care about the contents of `ebx` and `ecx`.\n+\n+However we still need to tell the compiler that `eax` and `edx` have been modified so that it can save any values that were in these registers before the asm. This is done by declaring these as outputs but with `_` instead of a variable name, which indicates that the output value is to be discarded.\n+\n+This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code:\n+\n+```rust,allow_fail\n+# #![feature(asm)]\n+// Multiply x by 6 using shifts and adds\n+let mut x: u64 = 4;\n+unsafe {\n+    asm!(\"\n+        mov {tmp}, {x}\n+        shl {tmp}, 1\n+        shl {x}, 2\n+        add {x}, {tmp}\n+    \", x = inout(reg) x, tmp = out(reg) _);\n }\n+assert_eq!(x, 4 * 6);\n ```\n \n-If you would like to use real operands in this position, however,\n-you are required to put curly braces `{}` around the register that\n-you want, and you are required to put the specific size of the\n-operand. This is useful for very low level programming, where\n-which register you use is important:\n+## Symbol operands\n+\n+A special operand type, `sym`, allows you to use the symbol name of a `fn` or `static` in inline assembly code.\n+This allows you to call a function or access a global variable without needing to keep its address in a register.\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# unsafe fn read_byte_in(port: u16) -> u8 {\n-let result: u8;\n-asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\"(port));\n-result\n-# }\n+extern \"C\" fn foo(arg: i32) {\n+    println!(\"arg = {}\", arg);\n+}\n+\n+fn call_foo(arg: i32) {\n+    unsafe {\n+        asm!(\n+            \"call {}\",\n+            sym foo,\n+            // 1st argument in rdi, which is caller-saved\n+            inout(\"rdi\") arg => _,\n+            // All caller-saved registers must be marked as clobberred\n+            out(\"rax\") _, out(\"rcx\") _, out(\"rdx\") _, out(\"rsi\") _,\n+            out(\"r8\") _, out(\"r9\") _, out(\"r10\") _, out(\"r11\") _,\n+            out(\"xmm0\") _, out(\"xmm1\") _, out(\"xmm2\") _, out(\"xmm3\") _,\n+            out(\"xmm4\") _, out(\"xmm5\") _, out(\"xmm6\") _, out(\"xmm7\") _,\n+            out(\"xmm8\") _, out(\"xmm9\") _, out(\"xmm10\") _, out(\"xmm11\") _,\n+            out(\"xmm12\") _, out(\"xmm13\") _, out(\"xmm14\") _, out(\"xmm15\") _,\n+        )\n+    }\n+}\n ```\n \n-## Clobbers\n+Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`:\n+the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n+\n+## Register template modifiers\n \n-Some instructions modify registers which might otherwise have held\n-different values so we use the clobbers list to indicate to the\n-compiler not to assume any values loaded into those registers will\n-stay valid.\n+In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a \"view\" over a subset of the register (e.g. the low 32 bits of a 64-bit register).\n \n-```rust\n+By default the compiler will always choose the name that refers to the full register size (e.g. `rax` on x86-64, `eax` on x86, etc).\n+\n+This default can be overriden by using modifiers on the template string operands, just like you would with format strings:\n+\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() { unsafe {\n-// Put the value 0x200 in eax:\n-asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n-# } }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+let mut x: u16 = 0xab;\n+\n+unsafe {\n+    asm!(\"mov {0:h}, {0:l}\", inout(reg_abcd) x);\n+}\n+\n+assert_eq!(x, 0xabab);\n ```\n \n-Input and output registers need not be listed since that information\n-is already communicated by the given constraints. Otherwise, any other\n-registers used either implicitly or explicitly should be listed.\n+In this example, we use the `reg_abcd` register class to restrict the register allocator to the 4 legacy x86 register (`ax`, `bx`, `cx`, `dx`) of which the first two bytes can be addressed independently.\n \n-If the assembly changes the condition code register `cc` should be\n-specified as one of the clobbers. Similarly, if the assembly modifies\n-memory, `memory` should also be specified.\n+Let us assume that the register allocator has chosen to allocate `x` in the `ax` register.\n+The `h` modifier will emit the register name for the high byte of that register and the `l` modifier will emit the register name for the low byte. The asm code will therefore be expanded as `mov ah, al` which copies the low byte of the value into the high byte.\n \n-## Options\n+If you use a smaller data type (e.g. `u16`) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.\n \n-The last section, `options` is specific to Rust. The format is comma\n-separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n-specify some extra info about the inline assembly:\n+## Options\n \n-Current valid options are:\n+By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n \n-1. *volatile* - specifying this is analogous to\n-   `__asm__ __volatile__ (...)` in gcc/clang.\n-2. *alignstack* - certain instructions expect the stack to be\n-   aligned a certain way (i.e. SSE) and specifying this indicates to\n-   the compiler to insert its usual stack alignment code\n-3. *intel* - use intel syntax instead of the default AT&T.\n+Let's take our previous example of an `add` instruction:\n \n-```rust\n+```rust,allow_fail\n # #![feature(asm)]\n-# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-# fn main() {\n-let result: i32;\n+let mut a: u64 = 4;\n+let b: u64 = 4;\n unsafe {\n-   asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")\n+    asm!(\n+        \"add {0}, {1}\",\n+        inlateout(reg) a, in(reg) b,\n+        options(pure, nomem, nostack)\n+    );\n }\n-println!(\"eax is currently {}\", result);\n-# }\n-# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-# fn main() {}\n+assert_eq!(a, 8);\n ```\n \n-## More Information\n+Options can be provided as an optional final argument to the `asm!` macro. We specified three options here:\n+- `pure` means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.\n+- `nomem` means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).\n+- `nostack` means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.\n+\n+These allow the compiler to better optimize code using `asm!`, for example by eliminating pure `asm!` blocks whose outputs are not needed.\n+\n+See the reference for the full list of available options and their effects.\n+\n+# Reference-level explanation\n+[reference-level-explanation]: #reference-level-explanation\n \n-The current implementation of the `asm!` macro is a direct binding to [LLVM's\n-inline assembler expressions][llvm-docs], so be sure to check out [their\n-documentation as well][llvm-docs] for more information about clobbers,\n-constraints, etc.\n+Inline assembler is implemented as an unsafe macro `asm!()`.\n+The first argument to this macro is a template string literal used to build the final assembly.\n+The following arguments specify input and output operands.\n+When required, options are specified as the final argument.\n \n-[llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n+The following ABNF specifies the general syntax:\n+\n+```ignore\n+dir_spec := \"in\" / \"out\" / \"lateout\" / \"inout\" / \"inlateout\"\n+reg_spec := <register class> / \"<explicit register>\"\n+operand_expr := expr / \"_\" / expr \"=>\" expr / expr \"=>\" \"_\"\n+reg_operand := dir_spec \"(\" reg_spec \")\" operand_expr\n+operand := reg_operand / \"const\" const_expr / \"sym\" path\n+option := \"pure\" / \"nomem\" / \"readonly\" / \"preserves_flags\" / \"noreturn\" / \"att_syntax\"\n+options := \"options(\" option *[\",\" option] [\",\"] \")\"\n+asm := \"asm!(\" format_string *(\",\" [ident \"=\"] operand) [\",\" options] [\",\"] \")\"\n+```\n+\n+The macro will initially be supported only on ARM, AArch64, x86, x86-64 and RISC-V targets. Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n+\n+[format-syntax]: https://doc.rust-lang.org/std/fmt/#syntax\n+\n+## Template string\n+\n+The assembler template uses the same syntax as [format strings][format-syntax] (i.e. placeholders are specified by curly braces). The corresponding arguments are accessed in order, by index, or by name. However, implicit named arguments (introduced by [RFC #2795][rfc-2795]) are not supported.\n+\n+As with format strings, named arguments must appear after positional arguments. Explicit register operands must appear at the end of the operand list, after any named arguments if any. Explicit register operands cannot be used by placeholders in the template string. All other operands must appear at least once in the template string, otherwise a compiler error is generated.\n+\n+The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.\n+\n+The 4 targets specified in this RFC (x86, ARM, AArch64, RISC-V) all use the assembly code syntax of the GNU assembler (GAS). On x86, the `.intel_syntax noprefix` mode of GAS is used by default. On ARM, the `.syntax unified` mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with `.section`) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior.\n+\n+[rfc-2795]: https://github.com/rust-lang/rfcs/pull/2795\n+\n+## Operand type\n+\n+Several types of operands are supported:\n+\n+* `in(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - The allocated register must contain the same value at the end of the asm code (except if a `lateout` is allocated to the same register).\n+* `out(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain an undefined value at the start of the asm code.\n+  - `<expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+* `lateout(<reg>) <expr>`\n+  - Identical to `out` except that the register allocator can reuse a register allocated to an `in`.\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `inout(<reg>) <expr>`\n+  - `<reg>` can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.\n+  - The allocated register will contain the value of `<expr>` at the start of the asm code.\n+  - `<expr>` must be a mutable initialized place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+* `inout(<reg>) <in expr> => <out expr>`\n+  - Same as `inout` except that the initial value of the register is taken from the value of `<in expr>`.\n+  - `<out expr>` must be a (possibly uninitialized) place expression, to which the contents of the allocated register is written to at the end of the asm code.\n+  - An underscore (`_`) may be specified instead of an expression for `<out expr>`, which will cause the contents of the register to be discarded at the end of the asm code (effectively acting as a clobber).\n+  - `<in expr>` and `<out expr>` may have different types.\n+* `inlateout(<reg>) <expr>` / `inlateout(<reg>) <in expr> => <out expr>`\n+  - Identical to `inout` except that the register allocator can reuse a register allocated to an `in` (this can happen if the compiler knows the `in` has the same initial value as the `inlateout`).\n+  - You should only write to the register after all inputs are read, otherwise you may clobber an input.\n+* `const <expr>`\n+  - `<expr>` must be an integer or floating-point constant expression.\n+  - The value of the expression is formatted as a string and substituted directly into the asm template string.\n+* `sym <path>`\n+  - `<path>` must refer to a `fn` or `static`.\n+  - A mangled symbol name referring to the item is substituted into the asm template string.\n+  - The substituted string does not include any modifiers (e.g. GOT, PLT, relocations, etc).\n+  - `<path>` is allowed to point to a `#[thread_local]` static, in which case the asm code can combine the symbol with relocations (e.g. `@plt`, `@TPOFF`) to read from thread-local data.\n+\n+Operand expressions are evaluated from left to right, just like function call arguments. After the `asm!` has executed, outputs are written to in left to right order. This is significant if two outputs point to the same place: that place will contain the value of the rightmost output.\n+\n+## Register operands\n+\n+Input and output operands can be specified either as an explicit register or as a register class from which the register allocator can select a register. Explicit registers are specified as string literals (e.g. `\"eax\"`) while register classes are specified as identifiers (e.g. `reg`). Using string literals for register names enables support for architectures that use special characters in register names, such as MIPS (`$0`, `$1`, etc).\n+\n+Note that explicit registers treat register aliases (e.g. `r14` vs `lr` on ARM) and smaller views of a register (e.g. `eax` vs `rax`) as equivalent to the base register. It is a compile-time error to use the same explicit register for two input operands or two output operands. Additionally, it is also a compile-time error to use overlapping registers (e.g. ARM VFP) in input operands or in output operands.\n+\n+Only the following types are allowed as operands for inline assembly:\n+- Integers (signed and unsigned)\n+- Floating-point numbers\n+- Pointers (thin only)\n+- Function pointers\n+- SIMD vectors (structs defined with `#[repr(simd)]` and which implement `Copy`). This includes architecture-specific vector types defined in `std::arch` such as `__m128` (x86) or `int8x16_t` (ARM).\n+\n+Here is the list of currently supported register classes:\n+\n+| Architecture | Register class | Registers | LLVM constraint code |\n+| ------------ | -------------- | --------- | -------------------- |\n+| x86 | `reg` | `ax`, `bx`, `cx`, `dx`, `si`, `di`, `r[8-15]` (x86-64 only) | `r` |\n+| x86 | `reg_abcd` | `ax`, `bx`, `cx`, `dx` | `Q` |\n+| x86-32 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `ah`, `bh`, `ch`, `dh` | `q` |\n+| x86-64 | `reg_byte` | `al`, `bl`, `cl`, `dl`, `sil`, `dil`, `r[8-15]b`, `ah`\\*, `bh`\\*, `ch`\\*, `dh`\\* | `q` |\n+| x86 | `xmm_reg` | `xmm[0-7]` (x86) `xmm[0-15]` (x86-64) | `x` |\n+| x86 | `ymm_reg` | `ymm[0-7]` (x86) `ymm[0-15]` (x86-64) | `x` |\n+| x86 | `zmm_reg` | `zmm[0-7]` (x86) `zmm[0-31]` (x86-64) | `v` |\n+| x86 | `kreg` | `k[1-7]` | `Yk` |\n+| AArch64 | `reg` | `x[0-28]`, `x30` | `r` |\n+| AArch64 | `vreg` | `v[0-31]` | `w` |\n+| AArch64 | `vreg_low16` | `v[0-15]` | `x` |\n+| ARM | `reg` | `r[0-r10]`, `r12`, `r14` | `r` |\n+| ARM (Thumb) | `reg_thumb` | `r[0-r7]` | `l` |\n+| ARM (ARM) | `reg_thumb` | `r[0-r10]`, `r12`, `r14` | `l` |\n+| ARM | `sreg` | `s[0-31]` | `t` |\n+| ARM | `sreg_low16` | `s[0-15]` | `x` |\n+| ARM | `dreg` | `d[0-31]` | `w` |\n+| ARM | `dreg_low16` | `d[0-15]` | `t` |\n+| ARM | `dreg_low8` | `d[0-8]` | `x` |\n+| ARM | `qreg` | `q[0-15]` | `w` |\n+| ARM | `qreg_low8` | `q[0-7]` | `t` |\n+| ARM | `qreg_low4` | `q[0-3]` | `x` |\n+| RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n+| RISC-V | `freg` | `f[0-31]` | `f` |\n+\n+> **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n+>\n+> Note #2: On x86-64 the high byte registers (e.g. `ah`) are only available when used as an explicit register. Specifying the `reg_byte` register class for an operand will always allocate a low byte register.\n+\n+Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n+\n+Each register class has constraints on which value types they can be used with. This is necessary because the way a value is loaded into a register depends on its type. For example, on big-endian systems, loading a `i32x4` and a `i8x16` into a SIMD register may result in different register contents even if the byte-wise memory representation of both values is identical. The availability of supported types for a particular register class may depend on what target features are currently enabled.\n+\n+| Architecture | Register class | Target feature | Allowed types |\n+| ------------ | -------------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `i16`, `i32`, `f32` |\n+| x86-64 | `reg` | None | `i16`, `i32`, `f32`, `i64`, `f64` |\n+| x86 | `reg_byte` | None | `i8` |\n+| x86 | `xmm_reg` | `sse` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| x86 | `ymm_reg` | `avx` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` |\n+| x86 | `zmm_reg` | `avx512f` | `i32`, `f32`, `i64`, `f64`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` <br> `i8x32`, `i16x16`, `i32x8`, `i64x4`, `f32x8`, `f64x4` <br> `i8x64`, `i16x32`, `i32x16`, `i64x8`, `f32x16`, `f64x8` |\n+| x86 | `kreg` | `axv512f` | `i8`, `i16` |\n+| x86 | `kreg` | `axv512bw` | `i32`, `i64` |\n+| AArch64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| AArch64 | `vreg` | `fp` | `i8`, `i16`, `i32`, `f32`, `i64`, `f64`, <br> `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2`, `f64x1`, <br> `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4`, `f64x2` |\n+| ARM | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| ARM | `sreg` | `vfp2` | `i32`, `f32` |\n+| ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n+| ARM | `qreg` | `neon` | `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4` |\n+| RISC-V32 | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n+| RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n+| RISC-V | `freg` | `f` | `f32` |\n+| RISC-V | `freg` | `d` | `f64` |\n+\n+> **Note**: For the purposes of the above table pointers, function pointers and `isize`/`usize` are treated as the equivalent integer type (`i16`/`i32`/`i64` depending on the target).\n+\n+If a value is of a smaller size than the register it is allocated in then the upper bits of that register will have an undefined value for inputs and will be ignored for outputs. The only exception is the `freg` register class on RISC-V where `f32` values are NaN-boxed in a `f64` as required by the RISC-V architecture.\n+\n+When separate input and output expressions are specified for an `inout` operand, both expressions must have the same type. The only exception is if both operands are pointers or integers, in which case they are only required to have the same size. This restriction exists because the register allocators in LLVM and GCC sometimes cannot handle tied operands with different types.\n+\n+## Register names\n+\n+Some registers have multiple names. These are all treated by the compiler as identical to the base register name. Here is the list of all supported register aliases:\n+\n+| Architecture | Base register | Aliases |\n+| ------------ | ------------- | ------- |\n+| x86 | `ax` | `eax`, `rax` |\n+| x86 | `bx` | `ebx`, `rbx` |\n+| x86 | `cx` | `ecx`, `rcx` |\n+| x86 | `dx` | `edx`, `rdx` |\n+| x86 | `si` | `esi`, `rsi` |\n+| x86 | `di` | `edi`, `rdi` |\n+| x86 | `bp` | `bpl`, `ebp`, `rbp` |\n+| x86 | `sp` | `spl`, `esp`, `rsp` |\n+| x86 | `ip` | `eip`, `rip` |\n+| x86 | `st(0)` | `st` |\n+| x86 | `r[8-15]` | `r[8-15]b`, `r[8-15]w`, `r[8-15]d` |\n+| x86 | `xmm[0-31]` | `ymm[0-31]`, `zmm[0-31]` |\n+| AArch64 | `x[0-30]` | `w[0-30]` |\n+| AArch64 | `x29` | `fp` |\n+| AArch64 | `x30` | `lr` |\n+| AArch64 | `sp` | `wsp` |\n+| AArch64 | `xzr` | `wzr` |\n+| AArch64 | `v[0-31]` | `b[0-31]`, `h[0-31]`, `s[0-31]`, `d[0-31]`, `q[0-31]` |\n+| ARM | `r[0-3]` | `a[1-4]` |\n+| ARM | `r[4-9]` | `v[1-6]` |\n+| ARM | `r9` | `rfp` |\n+| ARM | `r10` | `sl` |\n+| ARM | `r11` | `fp` |\n+| ARM | `r12` | `ip` |\n+| ARM | `r13` | `sp` |\n+| ARM | `r14` | `lr` |\n+| ARM | `r15` | `pc` |\n+| RISC-V | `x0` | `zero` |\n+| RISC-V | `x1` | `ra` |\n+| RISC-V | `x2` | `sp` |\n+| RISC-V | `x3` | `gp` |\n+| RISC-V | `x4` | `tp` |\n+| RISC-V | `x[5-7]` | `t[0-2]` |\n+| RISC-V | `x8` | `fp`, `s0` |\n+| RISC-V | `x9` | `s1` |\n+| RISC-V | `x[10-17]` | `a[0-7]` |\n+| RISC-V | `x[18-27]` | `s[2-11]` |\n+| RISC-V | `x[28-31]` | `t[3-6]` |\n+| RISC-V | `f[0-7]` | `ft[0-7]` |\n+| RISC-V | `f[8-9]` | `fs[0-1]` |\n+| RISC-V | `f[10-17]` | `fa[0-7]` |\n+| RISC-V | `f[18-27]` | `fs[2-11]` |\n+| RISC-V | `f[28-31]` | `ft[8-11]` |\n+\n+Some registers cannot be used for input or output operands:\n+\n+| Architecture | Unsupported register | Reason |\n+| ------------ | -------------------- | ------ |\n+| All | `sp` | The stack pointer must be restored to its original value at the end of an asm code block. |\n+| All | `bp` (x86), `r11` (ARM), `x29` (AArch64), `x8` (RISC-V) | The frame pointer cannot be used as an input or output. |\n+| x86 | `k0` | This is a constant zero register which can't be modified. |\n+| x86 | `ip` | This is the program counter, not a real register. |\n+| x86 | `mm[0-7]` | MMX registers are not currently supported (but may be in the future). |\n+| x86 | `st([0-7])` | x87 registers are not currently supported (but may be in the future). |\n+| AArch64 | `xzr` | This is a constant zero register which can't be modified. |\n+| ARM | `pc` | This is the program counter, not a real register. |\n+| RISC-V | `x0` | This is a constant zero register which can't be modified. |\n+| RISC-V | `gp`, `tp` | These registers are reserved and cannot be used as inputs or outputs. |\n+\n+## Template modifiers\n+\n+The placeholders can be augmented by modifiers which are specified after the `:` in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string. Only one modifier is allowed per template placeholder.\n+\n+The supported modifiers are a subset of LLVM's (and GCC's) [asm template argument modifiers][llvm-argmod], but do not use the same letter codes.\n+\n+| Architecture | Register class | Modifier | Example output | LLVM modifier |\n+| ------------ | -------------- | -------- | -------------- | ------------- |\n+| x86-32 | `reg` | None | `eax` | `k` |\n+| x86-64 | `reg` | None | `rax` | `q` |\n+| x86-32 | `reg_abcd` | `l` | `al` | `b` |\n+| x86-64 | `reg` | `l` | `al` | `b` |\n+| x86 | `reg_abcd` | `h` | `ah` | `h` |\n+| x86 | `reg` | `x` | `ax` | `w` |\n+| x86 | `reg` | `e` | `eax` | `k` |\n+| x86-64 | `reg` | `r` | `rax` | `q` |\n+| x86 | `reg_byte` | None | `al` / `ah` | None |\n+| x86 | `xmm_reg` | None | `xmm0` | `x` |\n+| x86 | `ymm_reg` | None | `ymm0` | `t` |\n+| x86 | `zmm_reg` | None | `zmm0` | `g` |\n+| x86 | `*mm_reg` | `x` | `xmm0` | `x` |\n+| x86 | `*mm_reg` | `y` | `ymm0` | `t` |\n+| x86 | `*mm_reg` | `z` | `zmm0` | `g` |\n+| x86 | `kreg` | None | `k1` | None |\n+| AArch64 | `reg` | None | `x0` | `x` |\n+| AArch64 | `reg` | `w` | `w0` | `w` |\n+| AArch64 | `reg` | `x` | `x0` | `x` |\n+| AArch64 | `vreg` | None | `v0` | None |\n+| AArch64 | `vreg` | `v` | `v0` | None |\n+| AArch64 | `vreg` | `b` | `b0` | `b` |\n+| AArch64 | `vreg` | `h` | `h0` | `h` |\n+| AArch64 | `vreg` | `s` | `s0` | `s` |\n+| AArch64 | `vreg` | `d` | `d0` | `d` |\n+| AArch64 | `vreg` | `q` | `q0` | `q` |\n+| ARM | `reg` | None | `r0` | None |\n+| ARM | `sreg` | None | `s0` | None |\n+| ARM | `dreg` | None | `d0` | `P` |\n+| ARM | `qreg` | None | `q0` | `q` |\n+| ARM | `qreg` | `e` / `f` | `d0` / `d1` | `e` / `f` |\n+| RISC-V | `reg` | None | `x1` | None |\n+| RISC-V | `freg` | None | `f0` | None |\n+\n+> Notes:\n+> - on ARM `e` / `f`: this prints the low or high doubleword register name of a NEON quad (128-bit) register.\n+> - on x86: our behavior for `reg` with no modifiers differs from what GCC does. GCC will infer the modifier based on the operand value type, while we default to the full register size.\n+> - on x86 `xmm_reg`: the `x`, `t` and `g` LLVM modifiers are not yet implemented in LLVM (they are supported by GCC only), but this should be a simple change.\n+\n+As stated in the previous section, passing an input value smaller than the register width will result in the upper bits of the register containing undefined values. This is not a problem if the inline asm only accesses the lower bits of the register, which can be done by using a template modifier to use a subregister name in the asm code (e.g. `ax` instead of `rax`). Since this an easy pitfall, the compiler will suggest a template modifier to use where appropriate given the input type. If all references to an operand already have modifiers then the warning is suppressed for that operand.\n+\n+[llvm-argmod]: http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers\n+\n+## Options\n \n-If you need more power and don't mind losing some of the niceties of\n-`asm!`, check out [global_asm](global-asm.md).\n+Flags are used to further influence the behavior of the inline assembly block.\n+Currently the following options are defined:\n+- `pure`: The `asm` block has no side effects, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to) or values read from memory (unless the `nomem` options is also set). This allows the compiler to execute the `asm` block fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used.\n+- `nomem`: The `asm` blocks does not read or write to any memory. This allows the compiler to cache the values of modified global variables in registers across the `asm` block since it knows that they are not read or written to by the `asm`.\n+- `readonly`: The `asm` block does not write to any memory. This allows the compiler to cache the values of unmodified global variables in registers across the `asm` block since it knows that they are not written to by the `asm`.\n+- `preserves_flags`: The `asm` block does not modify the flags register (defined in the rules below). This allows the compiler to avoid recomputing the condition flags after the `asm` block.\n+- `noreturn`: The `asm` block never returns, and its return type is defined as `!` (never). Behavior is undefined if execution falls through past the end of the asm code. A `noreturn` asm block behaves just like a function which doesn't return; notably, local variables in scope are not dropped before it is invoked.\n+- `nostack`: The `asm` block does not push data to the stack, or write to the stack red-zone (if supported by the target). If this option is *not* used then the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+- `att_syntax`: This option is only valid on x86, and causes the assembler to use the `.att_syntax prefix` mode of the GNU assembler. Register operands are substituted in with a leading `%`.\n+\n+The compiler performs some additional checks on options:\n+- The `nomem` and `readonly` options are mutually exclusive: it is a compile-time error to specify both.\n+- The `pure` option must be combined with either the `nomem` or `readonly` options, otherwise a compile-time error is emitted.\n+- It is a compile-time error to specify `pure` on an asm block with no outputs or only discarded outputs (`_`).\n+- It is a compile-time error to specify `noreturn` on an asm block with outputs.\n+\n+## Rules for inline assembly\n+\n+- Any registers not specified as inputs will contain an undefined value on entry to the asm block.\n+  - An \"undefined value\" in the context of inline assembly means that the register can (non-deterministically) have any one of the possible values allowed by the architecture. Notably it is not the same as an LLVM `undef` which can have a different value every time you read it (since such a concept does not exist in assembly code).\n+- Any registers not specified as outputs must have the same value upon exiting the asm block as they had on entry, otherwise behavior is undefined.\n+  - This only applies to registers which can be specified as an input or output. Other registers follow target-specific rules.\n+  - Note that a `lateout` may be allocated to the same register as an `in`, in which case this rule does not apply. Code should not rely on this however since it depends on the results of register allocation.\n+- Behavior is undefined if execution unwinds out of an asm block.\n+  - This also applies if the assembly code calls a function which then unwinds.\n+- The set of memory locations that assembly code is allowed the read and write are the same as those allowed for an FFI function.\n+  - Refer to the unsafe code guidelines for the exact rules.\n+  - If the `readonly` option is set, then only memory reads are allowed.\n+  - If the `nomem` option is set then no reads or writes to memory are allowed.\n+  - These rules do not apply to memory which is private to the asm code, such as stack space allocated within the asm block.\n+- The compiler cannot assume that the instructions in the asm are the ones that will actually end up executed.\n+  - This effectively means that the compiler must treat the `asm!` as a black box and only take the interface specification into account, not the instructions themselves.\n+  - Runtime code patching is allowed, via target-specific mechanisms (outside the scope of this RFC).\n+- Unless the `nostack` option is set, asm code is allowed to use stack space below the stack pointer.\n+  - On entry to the asm block the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.\n+  - You are responsible for making sure you don't overflow the stack (e.g. use stack probing to ensure you hit a guard page).\n+  - You should adjust the stack pointer when allocating stack memory as required by the target ABI.\n+  - The stack pointer must be restored to its original value before leaving the asm block.\n+- If the `noreturn` option is set then behavior is undefined if execution falls through to the end of the asm block.\n+- If the `pure` option is set then behavior is undefined if the `asm` has side-effects other than its direct outputs. Behavior is also undefined if two executions of the `asm` code with the same inputs result in different outputs.\n+  - When used with the `nomem` option, \"inputs\" are just the direct inputs of the `asm!`.\n+  - When used with the `readonly` option, \"inputs\" comprise the direct inputs of the `asm!` and any memory that the `asm!` block is allowed to read.\n+- These flags registers must be restored upon exiting the asm block if the `preserves_flags` option is set:\n+  - x86\n+    - Status flags in `EFLAGS` (CF, PF, AF, ZF, SF, OF).\n+    - Floating-point status word (all).\n+    - Floating-point exception flags in `MXCSR` (PE, UE, OE, ZE, DE, IE).\n+  - ARM\n+    - Condition flags in `CPSR` (N, Z, C, V)\n+    - Saturation flag in `CPSR` (Q)\n+    - Greater than or equal flags in `CPSR` (GE).\n+    - Condition flags in `FPSCR` (N, Z, C, V)\n+    - Saturation flag in `FPSCR` (QC)\n+    - Floating-point exception flags in `FPSCR` (IDC, IXC, UFC, OFC, DZC, IOC).\n+  - AArch64\n+    - Condition flags (`NZCV` register).\n+    - Floating-point status (`FPSR` register).\n+  - RISC-V\n+    - Floating-point exception flags in `fcsr` (`fflags`).\n+- On x86, the direction flag (DF in `EFLAGS`) is clear on entry to an asm block and must be clear on exit.\n+  - Behavior is undefined if the direction flag is set on exiting an asm block.\n+- The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting an `asm!` block.\n+  - This means that `asm!` blocks that never return (even if not marked `noreturn`) don't need to preserve these registers.\n+  - When returning to a different `asm!` block than you entered (e.g. for context switching), these registers must contain the value they had upon entering the `asm!` block that you are *exiting*.\n+    - You cannot exit an `asm!` block that has not been entered. Neither can you exit an `asm!` block that has already been exited.\n+    - You are responsible for switching any target-specific state (e.g. thread-local storage, stack bounds).\n+    - The set of memory locations that you may access is the intersection of those allowed by the `asm!` blocks you entered and exited.\n+- You cannot assume that an `asm!` block will appear exactly once in the output binary. The compiler is allowed to instantiate multiple copies of the `asm!` block, for example when the function containing it is inlined in multiple places.\n+  - As a consequence, you should only use [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+\n+> **Note**: As a general rule, the flags covered by `preserves_flags` are those which are *not* preserved when performing a function call.\n+\n+[local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels"}, {"sha": "da01d9228f14e0ff12177e7694205a4f9a6ed095", "filename": "src/doc/unstable-book/src/library-features/llvm-asm.md", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fllvm-asm.md?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,193 @@\n+# `llvm_asm`\n+\n+The tracking issue for this feature is: [#70173]\n+\n+[#70173]: https://github.com/rust-lang/rust/issues/70173\n+\n+------------------------\n+\n+For extremely low-level manipulations and performance reasons, one\n+might wish to control the CPU directly. Rust supports using inline\n+assembly to do this via the `llvm_asm!` macro.\n+\n+```rust,ignore\n+llvm_asm!(assembly template\n+   : output operands\n+   : input operands\n+   : clobbers\n+   : options\n+   );\n+```\n+\n+Any use of `llvm_asm` is feature gated (requires `#![feature(llvm_asm)]` on the\n+crate to allow) and of course requires an `unsafe` block.\n+\n+> **Note**: the examples here are given in x86/x86-64 assembly, but\n+> all platforms are supported.\n+\n+## Assembly template\n+\n+The `assembly template` is the only required parameter and must be a\n+literal string (i.e. `\"\"`)\n+\n+```rust\n+#![feature(llvm_asm)]\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn foo() {\n+    unsafe {\n+        llvm_asm!(\"NOP\");\n+    }\n+}\n+\n+// Other platforms:\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+fn foo() { /* ... */ }\n+\n+fn main() {\n+    // ...\n+    foo();\n+    // ...\n+}\n+```\n+\n+(The `feature(llvm_asm)` and `#[cfg]`s are omitted from now on.)\n+\n+Output operands, input operands, clobbers and options are all optional\n+but you must add the right number of `:` if you skip them:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+llvm_asm!(\"xor %eax, %eax\"\n+    :\n+    :\n+    : \"eax\"\n+   );\n+# } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+Whitespace also doesn't matter:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+llvm_asm!(\"xor %eax, %eax\" ::: \"eax\");\n+# } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+## Operands\n+\n+Input and output operands follow the same format: `:\n+\"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n+expressions must be mutable place, or not yet assigned:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+fn add(a: i32, b: i32) -> i32 {\n+    let c: i32;\n+    unsafe {\n+        llvm_asm!(\"add $2, $0\"\n+             : \"=r\"(c)\n+             : \"0\"(a), \"r\"(b)\n+             );\n+    }\n+    c\n+}\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn add(a: i32, b: i32) -> i32 { a + b }\n+\n+fn main() {\n+    assert_eq!(add(3, 14159), 14162)\n+}\n+```\n+\n+If you would like to use real operands in this position, however,\n+you are required to put curly braces `{}` around the register that\n+you want, and you are required to put the specific size of the\n+operand. This is useful for very low level programming, where\n+which register you use is important:\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# unsafe fn read_byte_in(port: u16) -> u8 {\n+let result: u8;\n+llvm_asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\"(port));\n+result\n+# }\n+```\n+\n+## Clobbers\n+\n+Some instructions modify registers which might otherwise have held\n+different values so we use the clobbers list to indicate to the\n+compiler not to assume any values loaded into those registers will\n+stay valid.\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() { unsafe {\n+// Put the value 0x200 in eax:\n+llvm_asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n+# } }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+Input and output registers need not be listed since that information\n+is already communicated by the given constraints. Otherwise, any other\n+registers used either implicitly or explicitly should be listed.\n+\n+If the assembly changes the condition code register `cc` should be\n+specified as one of the clobbers. Similarly, if the assembly modifies\n+memory, `memory` should also be specified.\n+\n+## Options\n+\n+The last section, `options` is specific to Rust. The format is comma\n+separated literal strings (i.e. `:\"foo\", \"bar\", \"baz\"`). It's used to\n+specify some extra info about the inline assembly:\n+\n+Current valid options are:\n+\n+1. *volatile* - specifying this is analogous to\n+   `__asm__ __volatile__ (...)` in gcc/clang.\n+2. *alignstack* - certain instructions expect the stack to be\n+   aligned a certain way (i.e. SSE) and specifying this indicates to\n+   the compiler to insert its usual stack alignment code\n+3. *intel* - use intel syntax instead of the default AT&T.\n+\n+```rust\n+# #![feature(llvm_asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() {\n+let result: i32;\n+unsafe {\n+   llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")\n+}\n+println!(\"eax is currently {}\", result);\n+# }\n+# #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+# fn main() {}\n+```\n+\n+## More Information\n+\n+The current implementation of the `llvm_asm!` macro is a direct binding to [LLVM's\n+inline assembler expressions][llvm-docs], so be sure to check out [their\n+documentation as well][llvm-docs] for more information about clobbers,\n+constraints, etc.\n+\n+[llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n+\n+If you need more power and don't mind losing some of the niceties of\n+`llvm_asm!`, check out [global_asm](global-asm.md)."}, {"sha": "9bbcaf7c4cc49fc413c795706b8671007e8ce809", "filename": "src/etc/dec2flt_table.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Fdec2flt_table.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Fdec2flt_table.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdec2flt_table.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2.7\n+#!/usr/bin/env python3\n \n \"\"\"\n Generate powers of ten using William Clinger's ``AlgorithmM`` for use in"}, {"sha": "d580329cb504ed9c6d40ddf36e486e94f9df5670", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -374,7 +374,7 @@ def children(self):\n         innermap = GdbValue(self.__val.get_wrapped_value()['map'])\n         if innermap.get_wrapped_value()['length'] > 0:\n             root = GdbValue(innermap.get_wrapped_value()['root'])\n-            type_name = str(root.type.ty.name).replace('core::option::Option<', '')[:-1]\n+            type_name = str(root.type.ty.name).replace('core::option::Option<', '', 1)[:-1]\n             root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n             node_ptr = root['node']\n             i = 0\n@@ -398,7 +398,7 @@ def to_string(self):\n     def children(self):\n         if self.__val.get_wrapped_value()['length'] > 0:\n             root = GdbValue(self.__val.get_wrapped_value()['root'])\n-            type_name = str(root.type.ty.name).replace('core::option::Option<', '')[:-1]\n+            type_name = str(root.type.ty.name).replace('core::option::Option<', '', 1)[:-1]\n             root = root.get_wrapped_value().cast(gdb.lookup_type(type_name))\n             node_ptr = root['node']\n             i = 0"}, {"sha": "a0ba47e1dbe313d1fd7683c4d73766d0dcce0b6a", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -15,9 +15,6 @@\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n \n TEMPLATE = \"\"\"\\\n-// FIXME: missing sysroot spans (#53081)\n-// ignore-i586-unknown-linux-gnu\n-// ignore-i586-unknown-linux-musl\n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n {error_deriving}"}, {"sha": "629c8e04ec533b0fc66f923b63794080c0dbc966", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -139,11 +139,17 @@ def listen():\n def start_watchdog():\n     \"\"\"Starts a watchdog thread that will terminate the process after a certain\n     period of time\"\"\"\n-    watchdog_start_time = time.clock()\n+\n+    try:\n+        from time import clock\n+    except ImportError:\n+        from time import perf_counter as clock\n+\n+    watchdog_start_time = clock()\n     watchdog_max_time = watchdog_start_time + 30\n \n     def watchdog():\n-        while time.clock() < watchdog_max_time:\n+        while clock() < watchdog_max_time:\n             time.sleep(1)\n         print(\"TIMEOUT: lldb_batchmode.py has been running for too long. Aborting!\")\n         thread.interrupt_main()"}, {"sha": "b950cea79edfeaef99761ae1ab76d5cee09cf974", "filename": "src/etc/rust-gdb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Frust-gdb", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Frust-gdb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdb?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -2,8 +2,16 @@\n # Exit if anything fails\n set -e\n \n+# Prefer rustc in the same directory as this script\n+DIR=\"$(dirname \"$0\")\"\n+if [ -x \"$DIR/rustc\" ]; then\n+  RUSTC=\"$DIR/rustc\"\n+else\n+  RUSTC=\"rustc\"\n+fi\n+\n # Find out where the pretty printer Python module is\n-RUSTC_SYSROOT=`rustc --print=sysroot`\n+RUSTC_SYSROOT=\"$(\"$RUSTC\" --print=sysroot)\"\n GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n \n # Run GDB with the additional arguments that load the pretty printers"}, {"sha": "9744913b686501d83f864bd1c5b2d8674f9cd913", "filename": "src/etc/rust-gdbgui", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Frust-gdbgui", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Frust-gdbgui", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdbgui?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -31,8 +31,16 @@ icon to start your program running.\n     exit 0\n fi\n \n+# Prefer rustc in the same directory as this script\n+DIR=\"$(dirname \"$0\")\"\n+if [ -x \"$DIR/rustc\" ]; then\n+  RUSTC=\"$DIR/rustc\"\n+else\n+  RUSTC=\"rustc\"\n+fi\n+\n # Find out where the pretty printer Python module is\n-RUSTC_SYSROOT=`rustc --print=sysroot`\n+RUSTC_SYSROOT=\"$(\"$RUSTC\" --print=sysroot)\"\n GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n \n # Set the environment variable `RUST_GDB` to overwrite the call to a"}, {"sha": "fe6fd45f9a5f8f824f73b340bac489330b4ed172", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,4 +1,4 @@\n-#!/usr/bin/env python2.7\n+#!/usr/bin/env python3\n \n \"\"\"\n Testing dec2flt"}, {"sha": "7e67e2b1246ef2f4798fcb374c6cec67b1a31edc", "filename": "src/etc/test-float-parse/u64-pow2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fu64-pow2.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,7 +1,6 @@\n mod _common;\n \n use _common::validate;\n-use std::u64;\n \n fn main() {\n     for exp in 19..64 {"}, {"sha": "d31c73cc1bd8d576e3e2492d46bce1e0c3e34f36", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 76, "deletions": 37, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -2,9 +2,8 @@\n \n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n-use core::intrinsics::{min_align_of_val, size_of_val};\n+use core::intrinsics::{self, min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n-use core::usize;\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n@@ -165,11 +164,19 @@ pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl AllocRef for Global {\n     #[inline]\n-    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        if layout.size() == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe { NonNull::new(alloc(layout)).ok_or(AllocErr).map(|p| (p, layout.size())) }\n+    fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n+        unsafe {\n+            let size = layout.size();\n+            if size == 0 {\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+            } else {\n+                let raw_ptr = match init {\n+                    AllocInit::Uninitialized => alloc(layout),\n+                    AllocInit::Zeroed => alloc_zeroed(layout),\n+                };\n+                let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n+                Ok(MemoryBlock { ptr, size })\n+            }\n         }\n     }\n \n@@ -181,32 +188,71 @@ unsafe impl AllocRef for Global {\n     }\n \n     #[inline]\n-    unsafe fn realloc(\n+    unsafe fn grow(\n         &mut self,\n         ptr: NonNull<u8>,\n         layout: Layout,\n         new_size: usize,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        match (layout.size(), new_size) {\n-            (0, 0) => Ok((layout.dangling(), 0)),\n-            (0, _) => self.alloc(Layout::from_size_align_unchecked(new_size, layout.align())),\n-            (_, 0) => {\n-                self.dealloc(ptr, layout);\n-                Ok((layout.dangling(), 0))\n+        placement: ReallocPlacement,\n+        init: AllocInit,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size >= size,\n+            \"`new_size` must be greater than or equal to `memory.size()`\"\n+        );\n+\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n+\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if layout.size() == 0 => {\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                self.alloc(new_layout, init)\n+            }\n+            ReallocPlacement::MayMove => {\n+                // `realloc` probably checks for `new_size > size` or something similar.\n+                intrinsics::assume(new_size > size);\n+                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let memory =\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                init.init_offset(memory, size);\n+                Ok(memory)\n             }\n-            (_, _) => NonNull::new(realloc(ptr.as_ptr(), layout, new_size))\n-                .ok_or(AllocErr)\n-                .map(|p| (p, new_size)),\n         }\n     }\n \n     #[inline]\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        if layout.size() == 0 {\n-            Ok((layout.dangling(), 0))\n-        } else {\n-            unsafe {\n-                NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr).map(|p| (p, layout.size()))\n+    unsafe fn shrink(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let size = layout.size();\n+        debug_assert!(\n+            new_size <= size,\n+            \"`new_size` must be smaller than or equal to `memory.size()`\"\n+        );\n+\n+        if size == new_size {\n+            return Ok(MemoryBlock { ptr, size });\n+        }\n+\n+        match placement {\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if new_size == 0 => {\n+                self.dealloc(ptr, layout);\n+                Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n+            }\n+            ReallocPlacement::MayMove => {\n+                // `realloc` probably checks for `new_size < size` or something similar.\n+                intrinsics::assume(new_size < size);\n+                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n             }\n         }\n     }\n@@ -218,14 +264,10 @@ unsafe impl AllocRef for Global {\n #[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n-    if size == 0 {\n-        align as *mut u8\n-    } else {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        match Global.alloc(layout) {\n-            Ok((ptr, _)) => ptr.as_ptr(),\n-            Err(_) => handle_alloc_error(layout),\n-        }\n+    let layout = Layout::from_size_align_unchecked(size, align);\n+    match Global.alloc(layout, AllocInit::Uninitialized) {\n+        Ok(memory) => memory.ptr.as_ptr(),\n+        Err(_) => handle_alloc_error(layout),\n     }\n }\n \n@@ -239,11 +281,8 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     let size = size_of_val(ptr.as_ref());\n     let align = min_align_of_val(ptr.as_ref());\n-    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n-    if size != 0 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr.cast().into(), layout);\n-    }\n+    let layout = Layout::from_size_align_unchecked(size, align);\n+    Global.dealloc(ptr.cast().into(), layout)\n }\n \n /// Abort on memory allocation error or failure."}, {"sha": "1c003983df9892a1c13aef1d7796a9ad36594559", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -8,21 +8,22 @@ use test::Bencher;\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let (ptr, _) =\n-            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let memory = Global\n+            .alloc(layout.clone(), AllocInit::Zeroed)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n-        let mut i = ptr.cast::<u8>().as_ptr();\n+        let mut i = memory.ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());\n         while i < end {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(ptr, layout);\n+        Global.dealloc(memory.ptr, layout);\n     }\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn alloc_owned_small(b: &mut Bencher) {\n     b.iter(|| {\n         let _: Box<_> = box 10;"}, {"sha": "38d19c59ad186edfbad8b6d8f972320d9df57f22", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n-use std::ops::Bound::{Excluded, Unbounded};\n+use std::ops::RangeBounds;\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -117,7 +117,7 @@ map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n-fn bench_iter(b: &mut Bencher, size: i32) {\n+fn bench_iteration(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -133,21 +133,21 @@ fn bench_iter(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_20(b: &mut Bencher) {\n-    bench_iter(b, 20);\n+pub fn iteration_20(b: &mut Bencher) {\n+    bench_iteration(b, 20);\n }\n \n #[bench]\n-pub fn iter_1000(b: &mut Bencher) {\n-    bench_iter(b, 1000);\n+pub fn iteration_1000(b: &mut Bencher) {\n+    bench_iteration(b, 1000);\n }\n \n #[bench]\n-pub fn iter_100000(b: &mut Bencher) {\n-    bench_iter(b, 100000);\n+pub fn iteration_100000(b: &mut Bencher) {\n+    bench_iteration(b, 100000);\n }\n \n-fn bench_iter_mut(b: &mut Bencher, size: i32) {\n+fn bench_iteration_mut(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -163,18 +163,18 @@ fn bench_iter_mut(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_mut_20(b: &mut Bencher) {\n-    bench_iter_mut(b, 20);\n+pub fn iteration_mut_20(b: &mut Bencher) {\n+    bench_iteration_mut(b, 20);\n }\n \n #[bench]\n-pub fn iter_mut_1000(b: &mut Bencher) {\n-    bench_iter_mut(b, 1000);\n+pub fn iteration_mut_1000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 1000);\n }\n \n #[bench]\n-pub fn iter_mut_100000(b: &mut Bencher) {\n-    bench_iter_mut(b, 100000);\n+pub fn iteration_mut_100000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 100000);\n }\n \n fn bench_first_and_last(b: &mut Bencher, size: i32) {\n@@ -202,57 +202,83 @@ pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n \n-#[bench]\n-pub fn range_excluded_excluded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+const BENCH_RANGE_SIZE: i32 = 145;\n+const BENCH_RANGE_COUNT: i32 = BENCH_RANGE_SIZE * (BENCH_RANGE_SIZE - 1) / 2;\n+\n+fn bench_range<F, R>(b: &mut Bencher, f: F)\n+where\n+    F: Fn(i32, i32) -> R,\n+    R: RangeBounds<i32>,\n+{\n+    let map: BTreeMap<_, _> = (0..BENCH_RANGE_SIZE).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            for last in first + 1..size {\n-                black_box(map.range((Excluded(first), Excluded(last))));\n+        let mut c = 0;\n+        for i in 0..BENCH_RANGE_SIZE {\n+            for j in i + 1..BENCH_RANGE_SIZE {\n+                black_box(map.range(f(i, j)));\n+                c += 1;\n             }\n         }\n+        debug_assert_eq!(c, BENCH_RANGE_COUNT);\n     });\n }\n \n #[bench]\n-pub fn range_excluded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range((Excluded(first), Unbounded)));\n-        }\n-    });\n+pub fn range_included_excluded(b: &mut Bencher) {\n+    bench_range(b, |i, j| i..j);\n }\n \n #[bench]\n pub fn range_included_included(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            for last in first..size {\n-                black_box(map.range(first..=last));\n-            }\n-        }\n-    });\n+    bench_range(b, |i, j| i..=j);\n }\n \n #[bench]\n pub fn range_included_unbounded(b: &mut Bencher) {\n-    let size = 144;\n+    bench_range(b, |i, _| i..);\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    bench_range(b, |_, _| ..);\n+}\n+\n+fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range(first..));\n+        for _ in 0..repeats {\n+            black_box(map.iter());\n         }\n     });\n }\n \n+/// Contrast range_unbounded_unbounded with `iter()`.\n #[bench]\n-pub fn range_unbounded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| map.range(..));\n+pub fn range_unbounded_vs_iter(b: &mut Bencher) {\n+    bench_iter(b, BENCH_RANGE_COUNT, BENCH_RANGE_SIZE);\n+}\n+\n+#[bench]\n+pub fn iter_0(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 0);\n+}\n+\n+#[bench]\n+pub fn iter_1(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1);\n+}\n+\n+#[bench]\n+pub fn iter_100(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 100);\n+}\n+\n+#[bench]\n+pub fn iter_10k(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 10_000);\n+}\n+\n+#[bench]\n+pub fn iter_1m(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1_000_000);\n }"}, {"sha": "2518506b9b5f3915996f9bc84fbc0f688c1e05af", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -62,6 +62,22 @@ pub fn clone_100_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_100_and_drain_all(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_100_and_drain_half(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(set.len(), 100 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n     let src = pos(100);\n@@ -115,6 +131,22 @@ pub fn clone_10k_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(set.len(), 10_000 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n     let src = pos(10_000);"}, {"sha": "f31717d9fd517e76b860364f430e7170d2194822", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,4 @@\n+#![feature(btree_drain_filter)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(test)]"}, {"sha": "8ef6090c743a9e6daf052670d370ef8a08e7a719", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 80, "deletions": 40, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -143,10 +143,10 @@ use core::ops::{\n };\n use core::pin::Pin;\n use core::ptr::{self, NonNull, Unique};\n-use core::slice;\n use core::task::{Context, Poll};\n \n-use crate::alloc::{self, AllocRef, Global};\n+use crate::alloc::{self, AllocInit, AllocRef, Global};\n+use crate::borrow::Cow;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n use crate::vec::Vec;\n@@ -196,14 +196,12 @@ impl<T> Box<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n         let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n-        unsafe {\n-            let ptr = if layout.size() == 0 {\n-                NonNull::dangling()\n-            } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n-            };\n-            Box::from_raw(ptr.as_ptr())\n-        }\n+        let ptr = Global\n+            .alloc(layout, AllocInit::Uninitialized)\n+            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+            .ptr\n+            .cast();\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory\n@@ -226,11 +224,13 @@ impl<T> Box<T> {\n     /// [zeroed]: ../../std/mem/union.MaybeUninit.html#method.zeroed\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {\n-        unsafe {\n-            let mut uninit = Self::new_uninit();\n-            ptr::write_bytes::<T>(uninit.as_mut_ptr(), 0, 1);\n-            uninit\n-        }\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = Global\n+            .alloc(layout, AllocInit::Zeroed)\n+            .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+            .ptr\n+            .cast();\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n \n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n@@ -240,6 +240,16 @@ impl<T> Box<T> {\n     pub fn pin(x: T) -> Pin<Box<T>> {\n         (box x).into()\n     }\n+\n+    /// Converts a `Box<T>` into a `Box<[T]>`\n+    ///\n+    /// This conversion does not allocate on the heap and happens in place.\n+    ///\n+    #[unstable(feature = \"box_into_boxed_slice\", issue = \"71582\")]\n+    pub fn into_boxed_slice(boxed: Box<T>) -> Box<[T]> {\n+        // *mut T and *mut [T; 1] have the same size and alignment\n+        unsafe { Box::from_raw(Box::into_raw(boxed) as *mut [T; 1] as *mut [T]) }\n+    }\n }\n \n impl<T> Box<[T]> {\n@@ -265,15 +275,7 @@ impl<T> Box<[T]> {\n     /// ```\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n-        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n-        unsafe {\n-            let ptr = if layout.size() == 0 {\n-                NonNull::dangling()\n-            } else {\n-                Global.alloc(layout).unwrap_or_else(|_| alloc::handle_alloc_error(layout)).0.cast()\n-            };\n-            Box::from_raw(slice::from_raw_parts_mut(ptr.as_ptr(), len))\n-        }\n+        unsafe { RawVec::with_capacity(len).into_box(len) }\n     }\n }\n \n@@ -437,7 +439,12 @@ impl<T: ?Sized> Box<T> {\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n-        Box::into_raw_non_null(b).as_ptr()\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b) as *mut T\n     }\n \n     /// Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.\n@@ -460,6 +467,7 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// ```\n     /// #![feature(box_into_raw_non_null)]\n+    /// #![allow(deprecated)]\n     ///\n     /// let x = Box::new(5);\n     /// let ptr = Box::into_raw_non_null(x);\n@@ -469,24 +477,34 @@ impl<T: ?Sized> Box<T> {\n     /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n+    #[rustc_deprecated(\n+        since = \"1.44.0\",\n+        reason = \"use `Box::leak(b).into()` or `NonNull::from(Box::leak(b))` instead\"\n+    )]\n     #[inline]\n     pub fn into_raw_non_null(b: Box<T>) -> NonNull<T> {\n-        Box::into_unique(b).into()\n-    }\n-\n-    #[unstable(feature = \"ptr_internals\", issue = \"none\", reason = \"use into_raw_non_null instead\")]\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b).into()\n+    }\n+\n+    #[unstable(\n+        feature = \"ptr_internals\",\n+        issue = \"none\",\n+        reason = \"use `Box::leak(b).into()` or `Unique::from(Box::leak(b))` instead\"\n+    )]\n     #[inline]\n     #[doc(hidden)]\n     pub fn into_unique(b: Box<T>) -> Unique<T> {\n-        let mut unique = b.0;\n-        mem::forget(b);\n-        // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n-        // Stacked Borrows.  This function here corresponds to \"reborrowing to\n-        // a raw pointer\", but there is no actual reborrow here -- so\n-        // without some care, the pointer we are returning here still carries\n-        // the tag of `b`, with `Unique` permission.\n-        // We round-trip through a mutable reference to avoid that.\n-        unsafe { Unique::new_unchecked(unique.as_mut() as *mut T) }\n+        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n+        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n+        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n+        // so all raw pointer methods go through `leak` which creates a (unique)\n+        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n+        Box::leak(b).into()\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n@@ -532,7 +550,7 @@ impl<T: ?Sized> Box<T> {\n     where\n         T: 'a, // Technically not needed, but kept to be explicit.\n     {\n-        unsafe { &mut *Box::into_raw(b) }\n+        unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }\n     }\n \n     /// Converts a `Box<T>` into a `Pin<Box<T>>`\n@@ -778,7 +796,18 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n         let buf = RawVec::with_capacity(len);\n         unsafe {\n             ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n-            buf.into_box()\n+            buf.into_box(slice.len()).assume_init()\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n+impl<T: Copy> From<Cow<'_, [T]>> for Box<[T]> {\n+    #[inline]\n+    fn from(cow: Cow<'_, [T]>) -> Box<[T]> {\n+        match cow {\n+            Cow::Borrowed(slice) => Box::from(slice),\n+            Cow::Owned(slice) => Box::from(slice),\n         }\n     }\n }\n@@ -801,6 +830,17 @@ impl From<&str> for Box<str> {\n     }\n }\n \n+#[stable(feature = \"box_from_cow\", since = \"1.45.0\")]\n+impl From<Cow<'_, str>> for Box<str> {\n+    #[inline]\n+    fn from(cow: Cow<'_, str>) -> Box<str> {\n+        match cow {\n+            Cow::Borrowed(s) => Box::from(s),\n+            Cow::Owned(s) => Box::from(s),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\n impl From<Box<str>> for Box<[u8]> {\n     /// Converts a `Box<str>>` into a `Box<[u8]>`"}, {"sha": "a3ef9989184336fb20881b878e26aa5c2f2a8d8c", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,10 +1,10 @@\n //! A priority queue implemented with a binary heap.\n //!\n-//! Insertion and popping the largest element have `O(log n)` time complexity.\n+//! Insertion and popping the largest element have `O(log(n))` time complexity.\n //! Checking the largest element is `O(1)`. Converting a vector to a binary heap\n //! can be done in-place, and has `O(n)` complexity. A binary heap can also be\n-//! converted to a sorted vector in-place, allowing it to be used for an `O(n\n-//! log n)` in-place heapsort.\n+//! converted to a sorted vector in-place, allowing it to be used for an `O(n * log(n))`\n+//! in-place heapsort.\n //!\n //! # Examples\n //!\n@@ -20,7 +20,6 @@\n //! ```\n //! use std::cmp::Ordering;\n //! use std::collections::BinaryHeap;\n-//! use std::usize;\n //!\n //! #[derive(Copy, Clone, Eq, PartialEq)]\n //! struct State {\n@@ -234,9 +233,9 @@ use super::SpecExtend;\n ///\n /// # Time complexity\n ///\n-/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n-/// |--------|----------|--------------------|\n-/// | O(1)~  | O(log n) | O(1)               |\n+/// | [push] | [pop]     | [peek]/[peek\\_mut] |\n+/// |--------|-----------|--------------------|\n+/// | O(1)~  | O(log(n)) | O(1)               |\n ///\n /// The value for `push` is an expected cost; the method documentation gives a\n /// more detailed analysis.\n@@ -399,7 +398,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() { None } else { Some(PeekMut { heap: self, sift: true }) }\n@@ -423,8 +422,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n-    /// n).\n+    /// The worst case cost of `pop` on a heap containing *n* elements is `O(log(n))`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -457,15 +455,15 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// The expected cost of `push`, averaged over every possible ordering of\n     /// the elements being pushed, and over a sufficiently large number of\n-    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n+    /// pushes, is `O(1)`. This is the most meaningful cost metric when pushing\n     /// elements that are *not* already in any sorted pattern.\n     ///\n     /// The time complexity degrades if elements are pushed in predominantly\n     /// ascending order. In the worst case, elements are pushed in ascending\n-    /// sorted order and the amortized cost per push is O(log n) against a heap\n+    /// sorted order and the amortized cost per push is `O(log(n))` against a heap\n     /// containing *n* elements.\n     ///\n-    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n+    /// The worst case cost of a *single* call to `push` is `O(n)`. The worst case\n     /// occurs when capacity is exhausted and needs a resize. The resize cost\n     /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -624,7 +622,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n         // `rebuild` takes O(len1 + len2) operations\n         // and about 2 * (len1 + len2) comparisons in the worst case\n-        // while `extend` takes O(len2 * log_2(len1)) operations\n+        // while `extend` takes O(len2 * log(len1)) operations\n         // and about 1 * len2 * log_2(len1) comparisons in the worst case,\n         // assuming len1 >= len2.\n         #[inline]\n@@ -645,7 +643,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// The remaining elements will be removed on drop in heap order.\n     ///\n     /// Note:\n-    /// * `.drain_sorted()` is O(n lg n); much slower than `.drain()`.\n+    /// * `.drain_sorted()` is `O(n * log(n))`; much slower than `.drain()`.\n     ///   You should use the latter for most cases.\n     ///\n     /// # Examples\n@@ -667,6 +665,34 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n         DrainSorted { inner: self }\n     }\n+\n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all elements `e` such that `f(&e)` returns\n+    /// `false`. The elements are visited in unsorted (and unspecified) order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_retain)]\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    ///\n+    /// heap.retain(|x| x % 2 == 0); // only keep even numbers\n+    ///\n+    /// assert_eq!(heap.into_sorted_vec(), [-10, 2, 4])\n+    /// ```\n+    #[unstable(feature = \"binary_heap_retain\", issue = \"71503\")]\n+    pub fn retain<F>(&mut self, f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        self.data.retain(f);\n+        self.rebuild();\n+    }\n }\n \n impl<T> BinaryHeap<T> {\n@@ -730,7 +756,7 @@ impl<T> BinaryHeap<T> {\n     ///\n     /// # Time complexity\n     ///\n-    /// Cost is O(1) in the worst case.\n+    /// Cost is `O(1)` in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -1243,7 +1269,7 @@ impl<'a, T: Ord> Drop for DrainSorted<'a, T> {\n \n         impl<'r, 'a, T: Ord> Drop for DropGuard<'r, 'a, T> {\n             fn drop(&mut self) {\n-                while let Some(_) = self.0.inner.pop() {}\n+                while self.0.inner.pop().is_some() {}\n             }\n         }\n "}, {"sha": "c6cb39b1bf51114ed619a3eacc252d87bb7b6af4", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 378, "deletions": 185, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -4,9 +4,10 @@ use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n+use core::mem::{self, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, mem, ptr};\n+use core::{fmt, ptr};\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n@@ -39,7 +40,7 @@ use UnderflowResult::*;\n /// performance on *small* nodes of elements which are cheap to compare. However in the future we\n /// would like to further explore choosing the optimal search strategy based on the choice of B,\n /// and possibly other factors. Using linear search, searching for a random element is expected\n-/// to take O(B log<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n+/// to take O(B * log(n)) comparisons, which is generally worse than a BST. In practice,\n /// however, performance is excellent.\n ///\n /// It is a logic error for a key to be modified in such a way that the key's ordering relative to\n@@ -190,9 +191,9 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n                             // We can't destructure subtree directly\n                             // because BTreeMap implements Drop\n                             let (subroot, sublength) = unsafe {\n+                                let subtree = ManuallyDrop::new(subtree);\n                                 let root = ptr::read(&subtree.root);\n                                 let length = subtree.length;\n-                                mem::forget(subtree);\n                                 (root, length)\n                             };\n \n@@ -214,59 +215,6 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             clone_subtree(self.root.as_ref().unwrap().as_ref())\n         }\n     }\n-\n-    fn clone_from(&mut self, other: &Self) {\n-        BTreeClone::clone_from(self, other);\n-    }\n-}\n-\n-trait BTreeClone {\n-    fn clone_from(&mut self, other: &Self);\n-}\n-\n-impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    default fn clone_from(&mut self, other: &Self) {\n-        *self = other.clone();\n-    }\n-}\n-\n-impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n-    fn clone_from(&mut self, other: &Self) {\n-        // This truncates `self` to `other.len()` by calling `split_off` on\n-        // the first key after `other.len()` elements if it exists.\n-        let split_off_key = if self.len() > other.len() {\n-            let diff = self.len() - other.len();\n-            if diff <= other.len() {\n-                self.iter().nth_back(diff - 1).map(|pair| (*pair.0).clone())\n-            } else {\n-                self.iter().nth(other.len()).map(|pair| (*pair.0).clone())\n-            }\n-        } else {\n-            None\n-        };\n-        if let Some(key) = split_off_key {\n-            self.split_off(&key);\n-        }\n-\n-        let mut siter = self.range_mut(..);\n-        let mut oiter = other.iter();\n-        // After truncation, `self` is at most as long as `other` so this loop\n-        // replaces every key-value pair in `self`. Since `oiter` is in sorted\n-        // order and the structure of the `BTreeMap` stays the same,\n-        // the BTree invariants are maintained at the end of the loop.\n-        while !siter.is_empty() {\n-            if let Some((ok, ov)) = oiter.next() {\n-                // SAFETY: This is safe because `siter` is nonempty.\n-                let (sk, sv) = unsafe { siter.next_unchecked() };\n-                sk.clone_from(ok);\n-                sv.clone_from(ov);\n-            } else {\n-                break;\n-            }\n-        }\n-        // If `other` is longer than `self`, the remaining elements are inserted.\n-        self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n-    }\n }\n \n impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n@@ -555,7 +503,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// map.insert(1, \"a\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BTreeMap<K, V> {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn new() -> BTreeMap<K, V> {\n         BTreeMap { root: None, length: 0 }\n     }\n \n@@ -652,11 +601,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n         let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n         front.right_kv().ok().map(Handle::into_kv)\n     }\n@@ -666,36 +611,54 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n-    ///\n     /// ```\n     /// #![feature(map_first_last)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.first_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// if let Some(mut entry) = map.first_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"first\");\n+    ///     }\n     /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"first\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n-        if let Ok(kv) = front.right_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        let kv = front.right_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the first element in the map.\n+    /// The key of this element is the minimum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in ascending order, while keeping a usable map each iteration.\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some((key, _val)) = map.pop_first() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k > key));\n+    /// }\n+    /// assert!(map.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_first(&mut self) -> Option<(K, V)> {\n+        self.first_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns the last key-value pair in the map.\n@@ -715,11 +678,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_key_value<T: ?Sized>(&self) -> Option<(&K, &V)>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n         let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n         back.left_kv().ok().map(Handle::into_kv)\n     }\n@@ -729,36 +688,54 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// # Examples\n     ///\n-    /// Contrived way to `clear` a map:\n-    ///\n     /// ```\n     /// #![feature(map_first_last)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// map.insert(2, \"b\");\n-    /// while let Some(entry) = map.last_entry() {\n-    ///     let (key, val) = entry.remove_entry();\n-    ///     assert!(!map.contains_key(&key));\n+    /// if let Some(mut entry) = map.last_entry() {\n+    ///     if *entry.key() > 0 {\n+    ///         entry.insert(\"last\");\n+    ///     }\n     /// }\n+    /// assert_eq!(*map.get(&1).unwrap(), \"a\");\n+    /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry<T: ?Sized>(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n-    where\n-        T: Ord,\n-        K: Borrow<T>,\n-    {\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n         let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n-        if let Ok(kv) = back.left_kv() {\n-            Some(OccupiedEntry {\n-                handle: kv.forget_node_type(),\n-                length: &mut self.length,\n-                _marker: PhantomData,\n-            })\n-        } else {\n-            None\n-        }\n+        let kv = back.left_kv().ok()?;\n+        Some(OccupiedEntry {\n+            handle: kv.forget_node_type(),\n+            length: &mut self.length,\n+            _marker: PhantomData,\n+        })\n+    }\n+\n+    /// Removes and returns the last element in the map.\n+    /// The key of this element is the maximum key that was in the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Draining elements in descending order, while keeping a usable map each iteration.\n+    ///\n+    /// ```\n+    /// #![feature(map_first_last)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map = BTreeMap::new();\n+    /// map.insert(1, \"a\");\n+    /// map.insert(2, \"b\");\n+    /// while let Some((key, _val)) = map.pop_last() {\n+    ///     assert!(map.iter().all(|(k, _v)| *k < key));\n+    /// }\n+    /// assert!(map.is_empty());\n+    /// ```\n+    #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n+    pub fn pop_last(&mut self) -> Option<(K, V)> {\n+        self.last_entry().map(|entry| entry.remove_entry())\n     }\n \n     /// Returns `true` if the map contains a value for the specified key.\n@@ -894,15 +871,14 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(btreemap_remove_entry)]\n     /// use std::collections::BTreeMap;\n     ///\n     /// let mut map = BTreeMap::new();\n     /// map.insert(1, \"a\");\n     /// assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n     /// assert_eq!(map.remove_entry(&1), None);\n     /// ```\n-    #[unstable(feature = \"btreemap_remove_entry\", issue = \"66714\")]\n+    #[stable(feature = \"btreemap_remove_entry\", since = \"1.45.0\")]\n     pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n     where\n         K: Borrow<Q>,\n@@ -1005,9 +981,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n-            let root1 = root.as_ref();\n-            let root2 = root.as_ref();\n-            let (f, b) = range_search(root1, root2, range);\n+            let (f, b) = range_search(root.as_ref(), range);\n \n             Range { front: Some(f), back: Some(b) }\n         } else {\n@@ -1053,9 +1027,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n-            let root1 = root.as_mut();\n-            let root2 = unsafe { ptr::read(&root1) };\n-            let (f, b) = range_search(root1, root2, range);\n+            let (f, b) = range_search(root.as_mut(), range);\n \n             RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n         } else {\n@@ -1256,6 +1228,48 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         right\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let evens: BTreeMap<_, _> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let odds = map;\n+    /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.drain_filter_inner() }\n+    }\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+        let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n+        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+    }\n+\n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n         fn dfs<'a, K, V>(node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>) -> usize\n@@ -1473,20 +1487,13 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type IntoIter = IntoIter<K, V>;\n \n     fn into_iter(self) -> IntoIter<K, V> {\n-        if self.root.is_none() {\n-            mem::forget(self);\n-            return IntoIter { front: None, back: None, length: 0 };\n-        }\n-\n-        let root1 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n-        let root2 = unsafe { unwrap_unchecked(ptr::read(&self.root)).into_ref() };\n-        let len = self.length;\n-        mem::forget(self);\n+        let mut me = ManuallyDrop::new(self);\n+        if let Some(root) = me.root.take() {\n+            let (f, b) = full_range_search(root.into_ref());\n \n-        IntoIter {\n-            front: Some(root1.first_leaf_edge()),\n-            back: Some(root2.last_leaf_edge()),\n-            length: len,\n+            IntoIter { front: Some(f), back: Some(b), length: me.length }\n+        } else {\n+            IntoIter { front: None, back: None, length: 0 }\n         }\n     }\n }\n@@ -1653,6 +1660,101 @@ impl<K, V> Clone for Values<'_, K, V> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeMap.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    K: 'a,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    pred: F,\n+    inner: DrainFilterInner<'a, K, V>,\n+}\n+pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n+    length: &'a mut usize,\n+    cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> Drop for DrainFilter<'_, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> fmt::Debug for DrainFilter<'_, K, V, F>\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek()).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next(&mut self.pred)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n+    /// Allow Debug implementations to predict the next element.\n+    pub(super) fn peek(&self) -> Option<(&K, &V)> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        edge.reborrow().next_kv().ok().map(|kv| kv.into_kv())\n+    }\n+\n+    unsafe fn next_kv(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        ptr::read(edge).next_kv().ok()\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n+    pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        while let Some(mut kv) = unsafe { self.next_kv() } {\n+            let (k, v) = kv.kv_mut();\n+            if pred(k, v) {\n+                *self.length -= 1;\n+                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n+                self.cur_leaf_edge = Some(leaf_edge_location);\n+                return Some((k, v));\n+            }\n+            self.cur_leaf_edge = Some(kv.next_leaf_edge());\n+        }\n+        None\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::size_hint` method.\n+    pub(super) fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(*self.length))\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -1877,9 +1979,9 @@ where\n     }\n }\n \n+/// Finds the leaf edges delimiting a specified range in or underneath a node.\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n-    root1: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    root2: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R,\n ) -> (\n     Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n@@ -1893,19 +1995,16 @@ where\n         (Excluded(s), Excluded(e)) if s == e => {\n             panic!(\"range start and end are equal and excluded in BTreeMap\")\n         }\n-        (Included(s), Included(e))\n-        | (Included(s), Excluded(e))\n-        | (Excluded(s), Included(e))\n-        | (Excluded(s), Excluded(e))\n-            if s > e =>\n-        {\n+        (Included(s) | Excluded(s), Included(e) | Excluded(e)) if s > e => {\n             panic!(\"range start is greater than range end in BTreeMap\")\n         }\n         _ => {}\n     };\n \n-    let mut min_node = root1;\n-    let mut max_node = root2;\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n     let mut min_found = false;\n     let mut max_found = false;\n \n@@ -1966,6 +2065,33 @@ where\n     }\n }\n \n+/// Equivalent to `range_search(k, v, ..)` without the `Ord` bound.\n+fn full_range_search<BorrowType, K, V>(\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+) {\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n+    loop {\n+        let front = min_node.first_edge();\n+        let back = max_node.last_edge();\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -1990,12 +2116,12 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            range: Range {\n-                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n-                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n-            },\n-            length: self.length,\n+        if let Some(root) = &self.root {\n+            let (f, b) = full_range_search(root.as_ref());\n+\n+            Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n+        } else {\n+            Iter { range: Range { front: None, back: None }, length: 0 }\n         }\n     }\n \n@@ -2022,19 +2148,15 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        IterMut {\n-            range: if let Some(root) = &mut self.root {\n-                let root1 = root.as_mut();\n-                let root2 = unsafe { ptr::read(&root1) };\n-                RangeMut {\n-                    front: Some(root1.first_leaf_edge()),\n-                    back: Some(root2.last_leaf_edge()),\n-                    _marker: PhantomData,\n-                }\n-            } else {\n-                RangeMut { front: None, back: None, _marker: PhantomData }\n-            },\n-            length: self.length,\n+        if let Some(root) = &mut self.root {\n+            let (f, b) = full_range_search(root.as_mut());\n+\n+            IterMut {\n+                range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n+                length: self.length,\n+            }\n+        } else {\n+            IterMut { range: RangeMut { front: None, back: None, _marker: PhantomData }, length: 0 }\n         }\n     }\n \n@@ -2196,6 +2318,34 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n         }\n     }\n \n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n+    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n+    /// which takes the key as its argument, and returns a mutable reference to the value in the\n+    /// entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(or_insert_with_key)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 9);\n+    /// ```\n+    #[inline]\n+    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                let value = default(entry.key());\n+                entry.insert(value)\n+            }\n+        }\n+    }\n+\n     /// Returns a reference to this entry's key.\n     ///\n     /// # Examples\n@@ -2315,15 +2465,14 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     ///\n     /// ```\n     /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n     ///\n-    /// let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n     ///\n-    /// // count the number of occurrences of letters in the vec\n-    /// for x in vec![\"a\",\"b\",\"a\",\"c\",\"a\",\"b\"] {\n-    ///     *count.entry(x).or_insert(0) += 1;\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n     /// }\n-    ///\n-    /// assert_eq!(count[\"a\"], 3);\n+    /// assert_eq!(map[\"poneyland\"], 37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n@@ -2531,85 +2680,129 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (small_leaf, old_key, old_val) = match self.handle.force() {\n+        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n+        (old_key, old_val)\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair.\n+    fn remove_kv_tracking(\n+        self,\n+    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, false)\n             }\n             Internal(mut internal) => {\n+                // Replace the location freed in the internal node with the next KV,\n+                // and remove that next KV from its leaf.\n+\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                let to_remove = internal.right_edge().descend().first_leaf_edge().right_kv().ok();\n+                // Deleting from the left side is typically faster since we can\n+                // just pop an element from the end of the KV array without\n+                // needing to shift the other values.\n+                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n                 let (hole, key, val) = to_remove.remove();\n \n                 let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n                 let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n \n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, true)\n             }\n         };\n \n         // Handle underflow\n-        let mut cur_node = small_leaf.forget_type();\n+        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n+        let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n                 AtRoot => break,\n-                EmptyParent(_) => unreachable!(),\n-                Merged(parent) => {\n+                Merged(edge, merged_with_left, offset) => {\n+                    // If we merged with our right sibling then our tracked\n+                    // position has not changed. However if we merged with our\n+                    // left sibling then our tracked position is now dangling.\n+                    if at_leaf && merged_with_left {\n+                        let idx = pos.idx() + offset;\n+                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n+                            Leaf(leaf) => leaf,\n+                            Internal(_) => unreachable!(),\n+                        };\n+                        pos = unsafe { Handle::new_edge(node, idx) };\n+                    }\n+\n+                    let parent = edge.into_node();\n                     if parent.len() == 0 {\n                         // We must be at the root\n                         parent.into_root_mut().pop_level();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n+                        at_leaf = false;\n                     }\n                 }\n-                Stole(_) => break,\n+                Stole(stole_from_left) => {\n+                    // Adjust the tracked position if we stole from a left sibling\n+                    if stole_from_left && at_leaf {\n+                        // SAFETY: This is safe since we just added an element to our node.\n+                        unsafe {\n+                            pos.next_unchecked();\n+                        }\n+                    }\n+                    break;\n+                }\n             }\n         }\n \n-        (old_key, old_val)\n+        // If we deleted from an internal node then we need to compensate for\n+        // the earlier swap and adjust the tracked position to point to the\n+        // next element.\n+        if was_internal {\n+            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n+        }\n+\n+        (old_key, old_val, pos)\n     }\n }\n \n enum UnderflowResult<'a, K, V> {\n     AtRoot,\n-    EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n+    Stole(bool),\n }\n \n fn handle_underfull_node<K, V>(\n     node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n ) -> UnderflowResult<'_, K, V> {\n-    let parent = if let Ok(parent) = node.ascend() {\n-        parent\n-    } else {\n-        return AtRoot;\n+    let parent = match node.ascend() {\n+        Ok(parent) => parent,\n+        Err(_) => return AtRoot,\n     };\n \n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n-        Err(parent) => match parent.right_kv() {\n-            Ok(right) => (false, right),\n-            Err(parent) => {\n-                return EmptyParent(parent.into_node());\n-            }\n-        },\n+        Err(parent) => {\n+            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n+            (false, right)\n+        }\n     };\n \n     if handle.can_merge() {\n-        Merged(handle.merge().into_node())\n+        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n+        Merged(handle.merge(), is_left, offset)\n     } else {\n         if is_left {\n             handle.steal_left();\n         } else {\n             handle.steal_right();\n         }\n-        Stole(handle.into_node())\n+        Stole(is_left)\n     }\n }\n "}, {"sha": "5569c293e2f6605e50ba1e0f7250188b19d4337a", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -131,7 +131,7 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::from(ptr) }\n+        BoxedNode { ptr: Unique::new_unchecked(ptr.as_ptr()) }\n     }\n \n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n@@ -161,7 +161,7 @@ impl<K, V> Root<K, V> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n-            root: self as *const _ as *mut _,\n+            root: ptr::null(),\n             _marker: PhantomData,\n         }\n     }\n@@ -179,7 +179,7 @@ impl<K, V> Root<K, V> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n-            root: ptr::null_mut(), // FIXME: Is there anything better to do here?\n+            root: ptr::null(),\n             _marker: PhantomData,\n         }\n     }\n@@ -723,6 +723,11 @@ impl<Node, Type> Handle<Node, Type> {\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n+\n+    /// Returns the position of this handle in the node.\n+    pub fn idx(&self) -> usize {\n+        self.idx\n+    }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {\n@@ -1142,7 +1147,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n \n             (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n-            if self.node.height > 1 {\n+            let layout = if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n                     right_node.cast_unchecked().as_internal().edges.as_ptr(),\n                     left_node\n@@ -1159,10 +1164,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                         .correct_parent_link();\n                 }\n \n-                Global.dealloc(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n+                Layout::new::<InternalNode<K, V>>()\n             } else {\n-                Global.dealloc(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n-            }\n+                Layout::new::<LeafNode<K, V>>()\n+            };\n+            Global.dealloc(right_node.node.cast(), layout);\n \n             Handle::new_edge(self.node, self.idx)\n         }"}, {"sha": "dee5fb878ff2a2998ad2c75e04237d7477012882", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 93, "deletions": 4, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -8,8 +8,8 @@ use core::fmt::{self, Debug};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n+use super::map::{BTreeMap, Keys};\n use super::Recover;\n-use crate::collections::btree_map::{self, BTreeMap, Keys};\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -102,7 +102,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    iter: btree_map::IntoIter<T, ()>,\n+    iter: super::map::IntoIter<T, ()>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -115,7 +115,7 @@ pub struct IntoIter<T> {\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n-    iter: btree_map::Range<'a, T, ()>,\n+    iter: super::map::Range<'a, T, ()>,\n }\n \n /// Core of SymmetricDifference and Union.\n@@ -309,7 +309,8 @@ impl<T: Ord> BTreeSet<T> {\n     /// let mut set: BTreeSet<i32> = BTreeSet::new();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> BTreeSet<T> {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn new() -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n@@ -944,6 +945,41 @@ impl<T: Ord> BTreeSet<T> {\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n+\n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set: BTreeSet<i32> = (0..8).collect();\n+    /// let evens: BTreeSet<_> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let odds = set;\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n+    where\n+        F: 'a + FnMut(&T) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.map.drain_filter_inner() }\n+    }\n }\n \n impl<T> BTreeSet<T> {\n@@ -1055,6 +1091,59 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeSet.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, T, F>\n+where\n+    T: 'a,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    pred: F,\n+    inner: super::map::DrainFilterInner<'a, T, ()>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<T, F> Drop for DrainFilter<'_, T, F>\n+where\n+    F: FnMut(&T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<T, F> fmt::Debug for DrainFilter<'_, T, F>\n+where\n+    T: fmt::Debug,\n+    F: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> Iterator for DrainFilter<'_, T, F>\n+where\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        let pred = &mut self.pred;\n+        let mut mapped_pred = |k: &T, _v: &mut ()| pred(k);\n+        self.inner.next(&mut mapped_pred).map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<T, F> FusedIterator for DrainFilter<'_, T, F> where F: FnMut(&T) -> bool {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]"}, {"sha": "cc0f07b822741bd76610541da02b7d83e91e75d9", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -143,7 +143,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n-            let node = Some(Box::into_raw_non_null(node));\n+            let node = Some(Box::leak(node).into());\n \n             match self.head {\n                 None => self.tail = node,\n@@ -184,7 +184,7 @@ impl<T> LinkedList<T> {\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n-            let node = Some(Box::into_raw_non_null(node));\n+            let node = Some(Box::leak(node).into());\n \n             match self.tail {\n                 None => self.head = node,\n@@ -390,7 +390,7 @@ impl<T> LinkedList<T> {\n     /// This reuses all the nodes from `other` and moves them into `self`. After\n     /// this operation, `other` becomes empty.\n     ///\n-    /// This operation should compute in O(1) time and O(1) memory.\n+    /// This operation should compute in `O(1)` time and `O(1)` memory.\n     ///\n     /// # Examples\n     ///\n@@ -547,7 +547,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -568,7 +568,7 @@ impl<T> LinkedList<T> {\n \n     /// Returns the length of the `LinkedList`.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -594,7 +594,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes all elements from the `LinkedList`.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Examples\n     ///\n@@ -737,7 +737,7 @@ impl<T> LinkedList<T> {\n \n     /// Adds an element first in the list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -760,7 +760,7 @@ impl<T> LinkedList<T> {\n     /// Removes the first element and returns it, or `None` if the list is\n     /// empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -783,7 +783,7 @@ impl<T> LinkedList<T> {\n \n     /// Appends an element to the back of a list.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -803,7 +803,7 @@ impl<T> LinkedList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in `O(1)` time.\n     ///\n     /// # Examples\n     ///\n@@ -824,7 +824,7 @@ impl<T> LinkedList<T> {\n     /// Splits the list into two at the given index. Returns everything after the given index,\n     /// including the index.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     ///\n@@ -880,7 +880,7 @@ impl<T> LinkedList<T> {\n \n     /// Removes the element at the given index and returns it.\n     ///\n-    /// This operation should compute in O(n) time.\n+    /// This operation should compute in `O(n)` time.\n     ///\n     /// # Panics\n     /// Panics if at >= len\n@@ -972,7 +972,7 @@ unsafe impl<#[may_dangle] T> Drop for LinkedList<T> {\n             fn drop(&mut self) {\n                 // Continue the same loop we do below. This only runs when a destructor has\n                 // panicked. If another one panics this will abort.\n-                while let Some(_) = self.0.pop_front_node() {}\n+                while self.0.pop_front_node().is_some() {}\n             }\n         }\n \n@@ -1133,11 +1133,9 @@ impl<T> IterMut<'_, T> {\n                     Some(prev) => prev,\n                 };\n \n-                let node = Some(Box::into_raw_non_null(box Node {\n-                    next: Some(head),\n-                    prev: Some(prev),\n-                    element,\n-                }));\n+                let node = Some(\n+                    Box::leak(box Node { next: Some(head), prev: Some(prev), element }).into(),\n+                );\n \n                 // Not creating references to entire nodes to not invalidate the\n                 // reference to `element` we handed to the user.\n@@ -1197,6 +1195,14 @@ pub struct Cursor<'a, T: 'a> {\n     list: &'a LinkedList<T>,\n }\n \n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T> Clone for Cursor<'_, T> {\n+    fn clone(&self) -> Self {\n+        let Cursor { index, current, list } = *self;\n+        Cursor { index, current, list }\n+    }\n+}\n+\n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -1442,7 +1448,7 @@ impl<'a, T> CursorMut<'a, T> {\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_after(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n             let node_next = match self.current {\n                 None => self.list.head,\n                 Some(node) => node.as_ref().next,\n@@ -1462,7 +1468,7 @@ impl<'a, T> CursorMut<'a, T> {\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_before(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n             let node_prev = match self.current {\n                 None => self.list.tail,\n                 Some(node) => node.as_ref().prev,\n@@ -1490,6 +1496,31 @@ impl<'a, T> CursorMut<'a, T> {\n         }\n     }\n \n+    /// Removes the current element from the `LinkedList` without deallocating the list node.\n+    ///\n+    /// The node that was removed is returned as a new `LinkedList` containing only this node.\n+    /// The cursor is moved to point to the next element in the current `LinkedList`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn remove_current_as_list(&mut self) -> Option<LinkedList<T>> {\n+        let mut unlinked_node = self.current?;\n+        unsafe {\n+            self.current = unlinked_node.as_ref().next;\n+            self.list.unlink_node(unlinked_node);\n+\n+            unlinked_node.as_mut().prev = None;\n+            unlinked_node.as_mut().next = None;\n+            Some(LinkedList {\n+                head: Some(unlinked_node),\n+                tail: Some(unlinked_node),\n+                len: 1,\n+                marker: PhantomData,\n+            })\n+        }\n+    }\n+\n     /// Inserts the elements from the given `LinkedList` after the current one.\n     ///\n     /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n@@ -1835,3 +1866,15 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Send for Cursor<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Sync for Cursor<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Send> Send for CursorMut<'_, T> {}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+unsafe impl<T: Sync> Sync for CursorMut<'_, T> {}"}, {"sha": "b8c93a28bba815a1bfa38fea9a49e581a335c13f", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -182,7 +182,6 @@ fn test_insert_prev() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {"}, {"sha": "540649c61b332345e59f143efcc318839d39bd7f", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 184, "deletions": 74, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -12,7 +12,7 @@ use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::iter::{once, repeat_with, FromIterator, FusedIterator};\n-use core::mem::{self, replace};\n+use core::mem::{self, replace, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n use core::ptr::{self, NonNull};\n@@ -50,6 +50,7 @@ const MAXIMUM_ZST_CAPACITY: usize = 1 << (64 - 1); // Largest possible power of\n /// [`pop_front`]: #method.pop_front\n /// [`extend`]: #method.extend\n /// [`append`]: #method.append\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"vecdeque_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VecDeque<T> {\n     // tail and head are pointers into the buffer. Tail always points\n@@ -72,7 +73,7 @@ pub struct VecDeque<T> {\n /// It produces the following sequence of matching slices:\n ///\n /// ([0 1], [a b])\n-/// ([2], [c])\n+/// (\\[2\\], \\[c\\])\n /// ([3 4], [d e])\n ///\n /// and the uneven remainder of either A or B is skipped.\n@@ -488,7 +489,7 @@ impl<T> VecDeque<T> {\n         VecDeque { tail: 0, head: 0, buf: RawVec::with_capacity(cap) }\n     }\n \n-    /// Retrieves an element in the `VecDeque` by index.\n+    /// Provides a reference to the element at the given index.\n     ///\n     /// Element at index 0 is the front of the queue.\n     ///\n@@ -513,7 +514,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Retrieves an element in the `VecDeque` mutably by index.\n+    /// Provides a mutable reference to the element at the given index.\n     ///\n     /// Element at index 0 is the front of the queue.\n     ///\n@@ -651,7 +652,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// Tries to reserve the minimum capacity for exactly `additional` more elements to\n     /// be inserted in the given `VecDeque<T>`. After calling `reserve_exact`,\n     /// capacity will be greater than or equal to `self.len() + additional`.\n     /// Does nothing if the capacity is already sufficient.\n@@ -662,7 +663,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Errors\n     ///\n-    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// If the capacity overflows `usize`, or the allocator reports a failure, then an error\n     /// is returned.\n     ///\n     /// # Examples\n@@ -678,7 +679,7 @@ impl<T> VecDeque<T> {\n     ///     // Pre-reserve the memory, exiting if we can't\n     ///     output.try_reserve_exact(data.len())?;\n     ///\n-    ///     // Now we know this can't OOM in the middle of our complex work\n+    ///     // Now we know this can't OOM(Out-Of-Memory) in the middle of our complex work\n     ///     output.extend(data.iter().map(|&val| {\n     ///         val * 2 + 5 // very complicated\n     ///     }));\n@@ -700,7 +701,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Errors\n     ///\n-    /// If the capacity overflows, or the allocator reports a failure, then an error\n+    /// If the capacity overflows `usize`, or the allocator reports a failure, then an error\n     /// is returned.\n     ///\n     /// # Examples\n@@ -959,6 +960,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -989,6 +993,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1347,7 +1354,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n@@ -1370,7 +1379,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n@@ -1385,7 +1396,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it,\n     /// replacing it with the first element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -1420,7 +1431,7 @@ impl<T> VecDeque<T> {\n     /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n     /// last element.\n     ///\n-    /// This does not preserve ordering, but is O(1).\n+    /// This does not preserve ordering, but is `O(1)`.\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n@@ -1478,7 +1489,9 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n         assert!(index <= self.len(), \"index out of bounds\");\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         // Move the least number of elements in the ring buffer and insert\n         // the given object\n@@ -1876,6 +1889,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(buf2, [2, 3]);\n     /// ```\n     #[inline]\n+    #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n         let len = self.len();\n@@ -1995,11 +2009,13 @@ impl<T> VecDeque<T> {\n     }\n \n     // This may panic or abort\n-    #[inline]\n-    fn grow_if_necessary(&mut self) {\n+    #[inline(never)]\n+    fn grow(&mut self) {\n         if self.is_full() {\n             let old_cap = self.cap();\n-            self.buf.double();\n+            // Double the buffer size.\n+            self.buf.reserve_exact(old_cap, old_cap);\n+            assert!(self.cap() == old_cap * 2);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }\n@@ -2043,6 +2059,148 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.\n+    ///\n+    /// This method does not allocate and does not change the order of the inserted elements.\n+    /// As it returns a mutable slice, this can be used to sort or binary search a deque.\n+    ///\n+    /// Once the internal storage is contiguous, the [`as_slices`](#method.as_slices) and\n+    /// [`as_mut_slices`](#method.as_mut_slices) methods will return the entire contents of the\n+    /// `VecDeque` in a single slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Sorting the content of a deque.\n+    ///\n+    /// ```\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// // sorting the deque\n+    /// buf.make_contiguous().sort();\n+    /// assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n+    ///\n+    /// // sorting it in reverse order\n+    /// buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n+    /// assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n+    /// ```\n+    ///\n+    /// Getting immutable access to the contiguous slice.\n+    ///\n+    /// ```rust\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// buf.make_contiguous();\n+    /// if let (slice, &[]) = buf.as_slices() {\n+    ///     // we can now be sure that `slice` contains all elements of the deque,\n+    ///     // while still having immutable access to `buf`.\n+    ///     assert_eq!(buf.len(), slice.len());\n+    ///     assert_eq!(slice, &[3, 2, 1] as &[_]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"deque_make_contiguous\", issue = \"70929\")]\n+    pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if self.is_contiguous() {\n+            let tail = self.tail;\n+            let head = self.head;\n+            return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n+        }\n+\n+        let buf = self.buf.ptr();\n+        let cap = self.cap();\n+        let len = self.len();\n+\n+        let free = self.tail - self.head;\n+        let tail_len = cap - self.tail;\n+\n+        if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head backwards, and then\n+            // copy the tail to the correct position.\n+            //\n+            // from: DEFGH....ABC\n+            // to:   ABCDEFGH....\n+            unsafe {\n+                ptr::copy(buf, buf.add(tail_len), self.head);\n+                // ...DEFGH.ABC\n+                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                // ABCDEFGH....\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        } else if free >= self.head {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail forwards, and then\n+            // copy the head to the correct position.\n+            //\n+            // from: FGH....ABCDE\n+            // to:   ...ABCDEFGH.\n+            unsafe {\n+                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                // FGHABCDE....\n+                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                // ...ABCDEFGH.\n+\n+                self.tail = self.head;\n+                self.head = self.tail + len;\n+            }\n+        } else {\n+            // free is smaller than both head and tail,\n+            // this means we have to slowly \"swap\" the tail and the head.\n+            //\n+            // from: EFGHI...ABCD or HIJK.ABCDEFG\n+            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n+            let mut left_edge: usize = 0;\n+            let mut right_edge: usize = self.tail;\n+            unsafe {\n+                // The general problem looks like this\n+                // GHIJKLM...ABCDEF - before any swaps\n+                // ABCDEFM...GHIJKL - after 1 pass of swaps\n+                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n+                //                  - then restart the algorithm with a new (smaller) store\n+                // Sometimes the temp store is reached when the right edge is at the end\n+                // of the buffer - this means we've hit the right order with fewer swaps!\n+                // E.g\n+                // EF..ABCD\n+                // ABCDEF.. - after four only swaps we've finished\n+                while left_edge < len && right_edge != cap {\n+                    let mut right_offset = 0;\n+                    for i in left_edge..right_edge {\n+                        right_offset = (i - left_edge) % (cap - right_edge);\n+                        let src: isize = (right_edge + right_offset) as isize;\n+                        ptr::swap(buf.add(i), buf.offset(src));\n+                    }\n+                    let n_ops = right_edge - left_edge;\n+                    left_edge += n_ops;\n+                    right_edge += right_offset + 1;\n+                }\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        }\n+\n+        let tail = self.tail;\n+        let head = self.head;\n+        unsafe { &mut self.buffer_as_mut_slice()[tail..head] }\n+    }\n+\n     /// Rotates the double-ended queue `mid` places to the left.\n     ///\n     /// Equivalently,\n@@ -2749,12 +2907,12 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n     /// This avoids reallocating where possible, but the conditions for that are\n     /// strict, and subject to change, and so shouldn't be relied upon unless the\n     /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n-    fn from(mut other: Vec<T>) -> Self {\n+    fn from(other: Vec<T>) -> Self {\n         unsafe {\n+            let mut other = ManuallyDrop::new(other);\n             let other_buf = other.as_mut_ptr();\n             let mut buf = RawVec::from_raw_parts(other_buf, other.capacity());\n             let len = other.len();\n-            mem::forget(other);\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n@@ -2778,7 +2936,7 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// [`Vec<T>`]: crate::vec::Vec\n     /// [`VecDeque<T>`]: crate::collections::VecDeque\n     ///\n-    /// This never needs to re-allocate, but does need to do O(n) data movement if\n+    /// This never needs to re-allocate, but does need to do `O(n)` data movement if\n     /// the circular buffer doesn't happen to be at the beginning of the allocation.\n     ///\n     /// # Examples\n@@ -2802,67 +2960,19 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T>) -> Self {\n+        other.make_contiguous();\n+\n         unsafe {\n+            let other = ManuallyDrop::new(other);\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let tail = other.tail;\n-            let head = other.head;\n             let cap = other.cap();\n \n-            // Need to move the ring to the front of the buffer, as vec will expect this.\n-            if other.is_contiguous() {\n-                ptr::copy(buf.add(tail), buf, len);\n-            } else {\n-                if (tail - head) >= cmp::min(cap - tail, head) {\n-                    // There is enough free space in the centre for the shortest block so we can\n-                    // do this in at most three copy moves.\n-                    if (cap - tail) > head {\n-                        // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.add(tail), buf.add(tail - head), cap - tail);\n-                        // copy left in the end\n-                        ptr::copy(buf, buf.add(cap - head), head);\n-                        // shift the new thing to the start\n-                        ptr::copy(buf.add(tail - head), buf, len);\n-                    } else {\n-                        // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.add(cap - tail), head);\n-                        ptr::copy(buf.add(tail), buf, cap - tail);\n-                    }\n-                } else {\n-                    // Need to use N swaps to move the ring\n-                    // We can use the space at the end of the ring as a temp store\n-\n-                    let mut left_edge: usize = 0;\n-                    let mut right_edge: usize = tail;\n-\n-                    // The general problem looks like this\n-                    // GHIJKLM...ABCDEF - before any swaps\n-                    // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                    // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                    //                  - then restart the algorithm with a new (smaller) store\n-                    // Sometimes the temp store is reached when the right edge is at the end\n-                    // of the buffer - this means we've hit the right order with fewer swaps!\n-                    // E.g\n-                    // EF..ABCD\n-                    // ABCDEF.. - after four only swaps we've finished\n-\n-                    while left_edge < len && right_edge != cap {\n-                        let mut right_offset = 0;\n-                        for i in left_edge..right_edge {\n-                            right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.add(i), buf.offset(src));\n-                        }\n-                        let n_ops = right_edge - left_edge;\n-                        left_edge += n_ops;\n-                        right_edge += right_offset + 1;\n-                    }\n-                }\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.tail), buf, len);\n             }\n-            let out = Vec::from_raw_parts(buf, len, cap);\n-            mem::forget(other);\n-            out\n+            Vec::from_raw_parts(buf, len, cap)\n         }\n     }\n }"}, {"sha": "fc2ec7908e82368e5c667a847a1abc2ab8a6765b", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 88, "deletions": 9, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,9 +1,9 @@\n use super::*;\n \n-use ::test;\n+use test;\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -16,7 +16,7 @@ fn bench_push_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -29,7 +29,7 @@ fn bench_push_front_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n \n@@ -43,7 +43,7 @@ fn bench_pop_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n+#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::<i32>::with_capacity(101);\n \n@@ -130,6 +130,87 @@ fn test_insert() {\n     }\n }\n \n+#[test]\n+fn make_contiguous_big_tail() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..3 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 3..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 012......9876543\n+    assert_eq!(tester.capacity(), 15);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n+\n+    let expected_start = tester.head;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_big_head() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..8 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 8..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 01234567......98\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 0, 1, 2, 3, 4, 5, 6, 7] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_small_free() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // ABCDEFGH...MLKJI\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+\n+    tester.clear();\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // IJKLM...HGFEDCBA\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'I', 'J', 'K', 'L', 'M'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+}\n+\n #[test]\n fn test_remove() {\n     // This test checks that every single combination of tail position, length, and\n@@ -305,10 +386,8 @@ fn test_vec_from_vecdeque() {\n         assert!(vec.into_iter().eq(vd));\n     }\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    let max_pwr = 7;\n-    #[cfg(miri)]\n-    let max_pwr = 5;\n+    // Miri is too slow\n+    let max_pwr = if cfg!(miri) { 5 } else { 7 };\n \n     for cap_pwr in 0..max_pwr {\n         // Make capacity as a (2^x)-1, so that the ring size is 2^x"}, {"sha": "26077f3c8d15045820c9912e54d4facd790f9954", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -50,8 +50,8 @@\n //! The internal iterator over the argument has not been advanced by the time\n //! the first `{}` is seen, so it prints the first argument. Then upon reaching\n //! the second `{}`, the iterator has advanced forward to the second argument.\n-//! Essentially, parameters which explicitly name their argument do not affect\n-//! parameters which do not name an argument in terms of positional specifiers.\n+//! Essentially, parameters that explicitly name their argument do not affect\n+//! parameters that do not name an argument in terms of positional specifiers.\n //!\n //! A format string is required to use all of its arguments, otherwise it is a\n //! compile-time error. You may refer to the same argument more than once in the\n@@ -60,7 +60,7 @@\n //! ## Named parameters\n //!\n //! Rust itself does not have a Python-like equivalent of named parameters to a\n-//! function, but the [`format!`] macro is a syntax extension which allows it to\n+//! function, but the [`format!`] macro is a syntax extension that allows it to\n //! leverage named parameters. Named parameters are listed at the end of the\n //! argument list and have the syntax:\n //!\n@@ -77,7 +77,7 @@\n //! ```\n //!\n //! It is not valid to put positional parameters (those without names) after\n-//! arguments which have names. Like with positional parameters, it is not\n+//! arguments that have names. Like with positional parameters, it is not\n //! valid to provide named parameters that are unused by the format string.\n //!\n //! # Formatting Parameters\n@@ -130,7 +130,7 @@\n //!\n //! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n //! left-aligned. The\n-//! defaults for numeric formatters is also a space but with right-alignment. If\n+//! default for numeric formatters is also a space character but with right-alignment. If\n //! the `0` flag (see below) is specified for numerics, then the implicit fill character is\n //! `0`.\n //!\n@@ -161,7 +161,7 @@\n //!         `Signed` trait. This flag indicates that the correct sign (`+` or `-`)\n //!         should always be printed.\n //! * `-` - Currently not used\n-//! * `#` - This flag is indicates that the \"alternate\" form of printing should\n+//! * `#` - This flag indicates that the \"alternate\" form of printing should\n //!         be used. The alternate forms are:\n //!     * `#?` - pretty-print the [`Debug`] formatting\n //!     * `#x` - precedes the argument with a `0x`\n@@ -173,9 +173,9 @@\n //!         like `{:08}` would yield `00000001` for the integer `1`, while the\n //!         same format would yield `-0000001` for the integer `-1`. Notice that\n //!         the negative version has one fewer zero than the positive version.\n-//!         Note that padding zeroes are always placed after the sign (if any)\n+//!         Note that padding zeros are always placed after the sign (if any)\n //!         and before the digits. When used together with the `#` flag, a similar\n-//!         rule applies: padding zeroes are inserted after the prefix but before\n+//!         rule applies: padding zeros are inserted after the prefix but before\n //!         the digits. The prefix is included in the total width.\n //!\n //! ## Precision\n@@ -251,7 +251,7 @@\n //!\n //! In some programming languages, the behavior of string formatting functions\n //! depends on the operating system's locale setting. The format functions\n-//! provided by Rust's standard library do not have any concept of locale, and\n+//! provided by Rust's standard library do not have any concept of locale and\n //! will produce the same results on all systems regardless of user\n //! configuration.\n //!\n@@ -470,7 +470,7 @@\n //!\n //! ### `format_args!`\n //!\n-//! This is a curious macro which is used to safely pass around\n+//! This is a curious macro used to safely pass around\n //! an opaque object describing the format string. This object\n //! does not require any heap allocations to create, and it only\n //! references information on the stack. Under the hood, all of\n@@ -495,7 +495,7 @@\n //! This structure can then be passed to the [`write`] and [`format`] functions\n //! inside this module in order to process the format string.\n //! The goal of this macro is to even further prevent intermediate allocations\n-//! when dealing formatting strings.\n+//! when dealing with formatting strings.\n //!\n //! For example, a logging library could use the standard formatting syntax, but\n //! it would internally pass around this structure until it has been determined"}, {"sha": "7aaa91ee10d97d1628768aaf3604b16cfb0bd0a0", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -77,12 +77,12 @@\n #![feature(allocator_api)]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n-#![feature(box_into_raw_non_null)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_sanitize)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(const_btree_new)]\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n #![feature(const_in_array_repeat_expressions)]\n@@ -99,14 +99,17 @@\n #![feature(internal_uninit_const)]\n #![feature(lang_items)]\n #![feature(libc)]\n+#![feature(negative_impls)]\n+#![feature(new_uninit)]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n+#![feature(or_patterns)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n-#![feature(specialization)]\n+#![feature(min_specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(str_internals)]"}, {"sha": "e163a166b498fceab4aa669f23d3069f76195629", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -36,13 +36,15 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable(box_syntax)]\n macro_rules! vec {\n+    () => (\n+        $crate::vec::Vec::new()\n+    );\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n     );\n-    ($($x:expr),*) => (\n-        <[_]>::into_vec(box [$($x),*])\n+    ($($x:expr),+ $(,)?) => (\n+        <[_]>::into_vec(box [$($x),+])\n     );\n-    ($($x:expr,)*) => ($crate::vec![$($x),*])\n }\n \n // HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n@@ -51,6 +53,9 @@ macro_rules! vec {\n // NB see the slice::hack module in slice.rs for more information\n #[cfg(test)]\n macro_rules! vec {\n+    () => (\n+        $crate::vec::Vec::new()\n+    );\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n     );"}, {"sha": "2bd4733db420bf0c713b0a2d788f5341508838ff", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 301, "deletions": 471, "changes": 772, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,13 +1,19 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n+use core::alloc::{LayoutErr, MemoryBlock};\n use core::cmp;\n-use core::mem;\n+use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n-use core::ptr::{self, NonNull, Unique};\n+use core::ptr::{NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n+use crate::alloc::{\n+    handle_alloc_error, AllocErr,\n+    AllocInit::{self, *},\n+    AllocRef, Global, Layout,\n+    ReallocPlacement::{self, *},\n+};\n use crate::boxed::Box;\n use crate::collections::TryReserveError::{self, *};\n \n@@ -19,83 +25,28 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces `Unique::empty()` on zero-sized types.\n-/// * Produces `Unique::empty()` on zero-length allocations.\n+/// * Produces `Unique::dangling()` on zero-sized types.\n+/// * Produces `Unique::dangling()` on zero-length allocations.\n+/// * Avoids freeing `Unique::dangling()`.\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n /// * Guards against overflowing your length.\n-/// * Aborts on OOM or calls `handle_alloc_error` as applicable.\n-/// * Avoids freeing `Unique::empty()`.\n+/// * Calls `handle_alloc_error` for fallible allocations.\n /// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n+/// * Uses the excess returned from the allocator to use the largest available capacity.\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n /// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n /// to handle the actual things *stored* inside of a `RawVec`.\n ///\n-/// Note that a `RawVec` always forces its capacity to be `usize::MAX` for zero-sized types.\n-/// This enables you to use capacity-growing logic catch the overflows in your length\n-/// that might occur with zero-sized types.\n-///\n-/// The above means that you need to be careful when round-tripping this type with a\n-/// `Box<[T]>`, since `capacity()` won't yield the length. However, `with_capacity`,\n-/// `shrink_to_fit`, and `from_box` will actually set `RawVec`'s private capacity\n-/// field. This allows zero-sized types to not be special-cased by consumers of\n-/// this type.\n+/// Note that the excess of a zero-sized types is always infinite, so `capacity()` always returns\n+/// `usize::MAX`. This means that you need to be careful when round-tripping this type with a\n+/// `Box<[T]>`, since `capacity()` won't yield the length.\n #[allow(missing_debug_implementations)]\n pub struct RawVec<T, A: AllocRef = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n-    a: A,\n-}\n-\n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Like `new`, but parameterized over the choice of allocator for\n-    /// the returned `RawVec`.\n-    pub const fn new_in(a: A) -> Self {\n-        let cap = if mem::size_of::<T>() == 0 { core::usize::MAX } else { 0 };\n-\n-        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n-        RawVec { ptr: Unique::empty(), cap, a }\n-    }\n-\n-    /// Like `with_capacity`, but parameterized over the choice of\n-    /// allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n-        RawVec::allocate_in(capacity, false, a)\n-    }\n-\n-    /// Like `with_capacity_zeroed`, but parameterized over the choice\n-    /// of allocator for the returned `RawVec`.\n-    #[inline]\n-    pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n-        RawVec::allocate_in(capacity, true, a)\n-    }\n-\n-    fn allocate_in(mut capacity: usize, zeroed: bool, mut a: A) -> Self {\n-        let elem_size = mem::size_of::<T>();\n-\n-        let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n-        alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n-\n-        // Handles ZSTs and `capacity == 0` alike.\n-        let ptr = if alloc_size == 0 {\n-            NonNull::<T>::dangling()\n-        } else {\n-            let align = mem::align_of::<T>();\n-            let layout = Layout::from_size_align(alloc_size, align).unwrap();\n-            let result = if zeroed { a.alloc_zeroed(layout) } else { a.alloc(layout) };\n-            match result {\n-                Ok((ptr, size)) => {\n-                    capacity = size / elem_size;\n-                    ptr.cast()\n-                }\n-                Err(_) => handle_alloc_error(layout),\n-            }\n-        };\n-\n-        RawVec { ptr: ptr.into(), cap: capacity, a }\n-    }\n+    alloc: A,\n }\n \n impl<T> RawVec<T, Global> {\n@@ -138,54 +89,90 @@ impl<T> RawVec<T, Global> {\n     /// Aborts on OOM.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n-        RawVec::allocate_in(capacity, false, Global)\n+        Self::with_capacity_in(capacity, Global)\n     }\n \n     /// Like `with_capacity`, but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n-        RawVec::allocate_in(capacity, true, Global)\n+        Self::with_capacity_zeroed_in(capacity, Global)\n     }\n-}\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n-    ///\n-    /// # Undefined Behavior\n-    ///\n-    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n-    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n-    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n-        RawVec { ptr: Unique::new_unchecked(ptr), cap: capacity, a }\n-    }\n-}\n-\n-impl<T> RawVec<T, Global> {\n     /// Reconstitutes a `RawVec` from a pointer and capacity.\n     ///\n-    /// # Undefined Behavior\n+    /// # Safety\n     ///\n     /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n-    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n+    /// systems). ZST vectors may have a capacity up to `usize::MAX`.\n     /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n+    #[inline]\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n-        RawVec { ptr: Unique::new_unchecked(ptr), cap: capacity, a: Global }\n+        Self::from_raw_parts_in(ptr, capacity, Global)\n     }\n \n     /// Converts a `Box<[T]>` into a `RawVec<T>`.\n-    pub fn from_box(mut slice: Box<[T]>) -> Self {\n+    pub fn from_box(slice: Box<[T]>) -> Self {\n         unsafe {\n-            let result = RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len());\n-            mem::forget(slice);\n-            result\n+            let mut slice = ManuallyDrop::new(slice);\n+            RawVec::from_raw_parts(slice.as_mut_ptr(), slice.len())\n         }\n     }\n }\n \n impl<T, A: AllocRef> RawVec<T, A> {\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n+    pub const fn new_in(alloc: A) -> Self {\n+        // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n+        Self { ptr: Unique::dangling(), cap: 0, alloc }\n+    }\n+\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, Uninitialized, alloc)\n+    }\n+\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n+    #[inline]\n+    pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {\n+        Self::allocate_in(capacity, Zeroed, alloc)\n+    }\n+\n+    fn allocate_in(capacity: usize, init: AllocInit, mut alloc: A) -> Self {\n+        if mem::size_of::<T>() == 0 {\n+            Self::new_in(alloc)\n+        } else {\n+            let layout = Layout::array::<T>(capacity).unwrap_or_else(|_| capacity_overflow());\n+            alloc_guard(layout.size()).unwrap_or_else(|_| capacity_overflow());\n+\n+            let memory = alloc.alloc(layout, init).unwrap_or_else(|_| handle_alloc_error(layout));\n+            Self {\n+                ptr: unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) },\n+                cap: Self::capacity_from_bytes(memory.size),\n+                alloc,\n+            }\n+        }\n+    }\n+\n+    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n+    /// systems). ZST vectors may have a capacity up to `usize::MAX`.\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n+    #[inline]\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n+        Self { ptr: Unique::new_unchecked(ptr), cap: capacity, alloc: a }\n+    }\n+\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n+    /// `Unique::dangling()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -196,241 +183,34 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     #[inline(always)]\n     pub fn capacity(&self) -> usize {\n-        if mem::size_of::<T>() == 0 { !0 } else { self.cap }\n+        if mem::size_of::<T>() == 0 { usize::MAX } else { self.cap }\n     }\n \n     /// Returns a shared reference to the allocator backing this `RawVec`.\n     pub fn alloc(&self) -> &A {\n-        &self.a\n+        &self.alloc\n     }\n \n     /// Returns a mutable reference to the allocator backing this `RawVec`.\n     pub fn alloc_mut(&mut self) -> &mut A {\n-        &mut self.a\n+        &mut self.alloc\n     }\n \n-    fn current_layout(&self) -> Option<Layout> {\n-        if self.cap == 0 {\n+    fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {\n+        if mem::size_of::<T>() == 0 || self.cap == 0 {\n             None\n         } else {\n             // We have an allocated chunk of memory, so we can bypass runtime\n             // checks to get our current layout.\n             unsafe {\n                 let align = mem::align_of::<T>();\n                 let size = mem::size_of::<T>() * self.cap;\n-                Some(Layout::from_size_align_unchecked(size, align))\n+                let layout = Layout::from_size_align_unchecked(size, align);\n+                Some((self.ptr.cast().into(), layout))\n             }\n         }\n     }\n \n-    /// Doubles the size of the type's backing allocation. This is common enough\n-    /// to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// This function is ideal for when pushing elements one-at-a-time because\n-    /// you don't need to incur the costs of the more general computations\n-    /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == capacity`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(raw_vec_internals)]\n-    /// # extern crate alloc;\n-    /// # use std::ptr;\n-    /// # use alloc::raw_vec::RawVec;\n-    /// struct MyVec<T> {\n-    ///     buf: RawVec<T>,\n-    ///     len: usize,\n-    /// }\n-    ///\n-    /// impl<T> MyVec<T> {\n-    ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n-    ///         // double would have aborted or panicked if the len exceeded\n-    ///         // `isize::MAX` so this is safe to do unchecked now.\n-    ///         unsafe {\n-    ///             ptr::write(self.buf.ptr().add(self.len), elem);\n-    ///         }\n-    ///         self.len += 1;\n-    ///     }\n-    /// }\n-    /// # fn main() {\n-    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n-    /// #   vec.push(1);\n-    /// # }\n-    /// ```\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double(&mut self) {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n-\n-            // Since we set the capacity to `usize::MAX` when `elem_size` is\n-            // 0, getting to here necessarily means the `RawVec` is overfull.\n-            assert!(elem_size != 0, \"capacity overflow\");\n-\n-            let (ptr, new_cap) = match self.current_layout() {\n-                Some(cur) => {\n-                    // Since we guarantee that we never allocate more than\n-                    // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n-                    // a precondition, so this can't overflow. Additionally the\n-                    // alignment will never be too large as to \"not be\n-                    // satisfiable\", so `Layout::from_size_align` will always\n-                    // return `Some`.\n-                    //\n-                    // TL;DR, we bypass runtime checks due to dynamic assertions\n-                    // in this module, allowing us to use\n-                    // `from_size_align_unchecked`.\n-                    let new_cap = 2 * self.cap;\n-                    let new_size = new_cap * elem_size;\n-                    alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(), cur, new_size);\n-                    match ptr_res {\n-                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n-                        Err(_) => handle_alloc_error(Layout::from_size_align_unchecked(\n-                            new_size,\n-                            cur.align(),\n-                        )),\n-                    }\n-                }\n-                None => {\n-                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n-                    // would cause overflow.\n-                    let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                    let layout = Layout::array::<T>(new_cap).unwrap();\n-                    match self.a.alloc(layout) {\n-                        Ok((ptr, new_size)) => (ptr, new_size / elem_size),\n-                        Err(_) => handle_alloc_error(layout),\n-                    }\n-                }\n-            };\n-            self.ptr = ptr.cast().into();\n-            self.cap = new_cap;\n-        }\n-    }\n-\n-    /// Attempts to double the size of the type's backing allocation in place. This is common\n-    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// Returns `true` if the reallocation attempt has succeeded.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double_in_place(&mut self) -> bool {\n-        unsafe {\n-            let elem_size = mem::size_of::<T>();\n-            let old_layout = match self.current_layout() {\n-                Some(layout) => layout,\n-                None => return false, // nothing to double\n-            };\n-\n-            // Since we set the capacity to `usize::MAX` when `elem_size` is\n-            // 0, getting to here necessarily means the `RawVec` is overfull.\n-            assert!(elem_size != 0, \"capacity overflow\");\n-\n-            // Since we guarantee that we never allocate more than `isize::MAX`\n-            // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n-            // this can't overflow.\n-            //\n-            // Similarly to with `double` above, we can go straight to\n-            // `Layout::from_size_align_unchecked` as we know this won't\n-            // overflow and the alignment is sufficiently small.\n-            let new_cap = 2 * self.cap;\n-            let new_size = new_cap * elem_size;\n-            alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-            match self.a.grow_in_place(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n-                Ok(_) => {\n-                    // We can't directly divide `size`.\n-                    self.cap = new_cap;\n-                    true\n-                }\n-                Err(_) => false,\n-            }\n-        }\n-    }\n-\n-    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve_exact(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<(), TryReserveError> {\n-        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n-    }\n-\n-    /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n-    /// will reallocate the minimum possible amount of memory necessary.\n-    /// Generally this will be exactly the amount of memory necessary,\n-    /// but in principle the allocator is free to give back more than\n-    /// we asked for.\n-    ///\n-    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n-    /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behavior of this function may break.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM.\n-    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { .. }) => unreachable!(),\n-            Ok(()) => { /* yay */ }\n-        }\n-    }\n-\n-    /// Calculates the buffer's new size given that it'll hold `used_capacity +\n-    /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n-    /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(\n-        &self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<usize, TryReserveError> {\n-        // Nothing we can really do about these checks, sadly.\n-        let required_cap =\n-            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-        let double_cap = self.cap * 2;\n-        // `double_cap` guarantees exponential growth.\n-        Ok(cmp::max(double_cap, required_cap))\n-    }\n-\n-    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(\n-        &mut self,\n-        used_capacity: usize,\n-        needed_extra_capacity: usize,\n-    ) -> Result<(), TryReserveError> {\n-        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n-    }\n-\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -484,12 +264,26 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// # }\n     /// ```\n     pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n-        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n+        match self.try_reserve(used_capacity, needed_extra_capacity) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { .. }) => unreachable!(),\n+            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n             Ok(()) => { /* yay */ }\n         }\n     }\n+\n+    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n+        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n+            self.grow_amortized(used_capacity, needed_extra_capacity, MayMove)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n@@ -508,45 +302,53 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n     pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n-        unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity. If the current `cap` is 0, we can't\n-            // reallocate in place.\n-            // Wrapping in case they give a bad `used_capacity`\n-            let old_layout = match self.current_layout() {\n-                Some(layout) => layout,\n-                None => return false,\n-            };\n-            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n-                return false;\n-            }\n+        // This is more readable than putting this in one line:\n+        // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n+        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n+            self.grow_amortized(used_capacity, needed_extra_capacity, InPlace).is_ok()\n+        } else {\n+            true\n+        }\n+    }\n \n-            let new_cap = self\n-                .amortized_new_size(used_capacity, needed_extra_capacity)\n-                .unwrap_or_else(|_| capacity_overflow());\n-\n-            // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n-            // (regardless of whether `self.cap - used_capacity` wrapped).\n-            // Therefore, we can safely call `grow_in_place`.\n-\n-            let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size()).unwrap_or_else(|_| capacity_overflow());\n-            match self.a.grow_in_place(\n-                NonNull::from(self.ptr).cast(),\n-                old_layout,\n-                new_layout.size(),\n-            ) {\n-                Ok(_) => {\n-                    self.cap = new_cap;\n-                    true\n-                }\n-                Err(_) => false,\n-            }\n+    /// Ensures that the buffer contains at least enough space to hold\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n+    /// will reallocate the minimum possible amount of memory necessary.\n+    /// Generally this will be exactly the amount of memory necessary,\n+    /// but in principle the allocator is free to give back more than\n+    /// we asked for.\n+    ///\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n+    /// the requested space. This is not really unsafe, but the unsafe\n+    /// code *you* write that relies on the behavior of this function may break.\n+    ///\n+    /// # Panics\n+    ///\n+    /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n+    /// * Panics on 32-bit platforms if the requested capacity exceeds\n+    ///   `isize::MAX` bytes.\n+    ///\n+    /// # Aborts\n+    ///\n+    /// Aborts on OOM.\n+    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.try_reserve_exact(used_capacity, needed_extra_capacity) {\n+            Err(CapacityOverflow) => capacity_overflow(),\n+            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n+            Ok(()) => { /* yay */ }\n+        }\n+    }\n+\n+    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve_exact(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n+        if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n+            self.grow_exact(used_capacity, needed_extra_capacity)\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -561,166 +363,194 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ///\n     /// Aborts on OOM.\n     pub fn shrink_to_fit(&mut self, amount: usize) {\n-        let elem_size = mem::size_of::<T>();\n-\n-        // Set the `cap` because they might be about to promote to a `Box<[T]>`\n-        if elem_size == 0 {\n-            self.cap = amount;\n-            return;\n+        match self.shrink(amount, MayMove) {\n+            Err(CapacityOverflow) => capacity_overflow(),\n+            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n+            Ok(()) => { /* yay */ }\n         }\n+    }\n+}\n \n-        // This check is my waterloo; it's the only thing `Vec` wouldn't have to do.\n-        assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n+impl<T, A: AllocRef> RawVec<T, A> {\n+    /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n+    /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n+    fn needs_to_grow(&self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n+        needed_extra_capacity > self.capacity().wrapping_sub(used_capacity)\n+    }\n \n-        if amount == 0 {\n-            // We want to create a new zero-length vector within the\n-            // same allocator. We use `ptr::write` to avoid an\n-            // erroneous attempt to drop the contents, and we use\n-            // `ptr::read` to sidestep condition against destructuring\n-            // types that implement Drop.\n+    fn capacity_from_bytes(excess: usize) -> usize {\n+        debug_assert_ne!(mem::size_of::<T>(), 0);\n+        excess / mem::size_of::<T>()\n+    }\n \n-            unsafe {\n-                let a = ptr::read(&self.a as *const A);\n-                self.dealloc_buffer();\n-                ptr::write(self, RawVec::new_in(a));\n-            }\n-        } else if self.cap != amount {\n-            unsafe {\n-                // We know here that our `amount` is greater than zero. This\n-                // implies, via the assert above, that capacity is also greater\n-                // than zero, which means that we've got a current layout that\n-                // \"fits\"\n-                //\n-                // We also know that `self.cap` is greater than `amount`, and\n-                // consequently we don't need runtime checks for creating either\n-                // layout.\n-                let old_size = elem_size * self.cap;\n-                let new_size = elem_size * amount;\n-                let align = mem::align_of::<T>();\n-                let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n-                    Ok((ptr, _)) => self.ptr = ptr.cast().into(),\n-                    Err(_) => {\n-                        handle_alloc_error(Layout::from_size_align_unchecked(new_size, align))\n-                    }\n-                }\n-            }\n-            self.cap = amount;\n-        }\n+    fn set_memory(&mut self, memory: MemoryBlock) {\n+        self.ptr = unsafe { Unique::new_unchecked(memory.ptr.cast().as_ptr()) };\n+        self.cap = Self::capacity_from_bytes(memory.size);\n     }\n-}\n \n-enum Fallibility {\n-    Fallible,\n-    Infallible,\n-}\n+    // This method is usually instantiated many times. So we want it to be as\n+    // small as possible, to improve compile times. But we also want as much of\n+    // its contents to be statically computable as possible, to make the\n+    // generated code run faster. Therefore, this method is carefully written\n+    // so that all of the code that depends on `T` is within it, while as much\n+    // of the code that doesn't depend on `T` as possible is in functions that\n+    // are non-generic over `T`.\n+    fn grow_amortized(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<(), TryReserveError> {\n+        // This is ensured by the calling contexts.\n+        debug_assert!(needed_extra_capacity > 0);\n \n-use Fallibility::*;\n+        if mem::size_of::<T>() == 0 {\n+            // Since we return a capacity of `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n+            return Err(CapacityOverflow);\n+        }\n \n-enum ReserveStrategy {\n-    Exact,\n-    Amortized,\n-}\n+        // Nothing we can really do about these checks, sadly.\n+        let required_cap =\n+            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n \n-use ReserveStrategy::*;\n+        // This guarantees exponential growth. The doubling cannot overflow\n+        // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n+        let cap = cmp::max(self.cap * 2, required_cap);\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    fn reserve_internal(\n+        // Tiny Vecs are dumb. Skip to:\n+        // - 8 if the element size is 1, because any heap allocators is likely\n+        //   to round up a request of less than 8 bytes to at least 8 bytes.\n+        // - 4 if elements are moderate-sized (<= 1 KiB).\n+        // - 1 otherwise, to avoid wasting too much space for very short Vecs.\n+        // Note that `min_non_zero_cap` is computed statically.\n+        let elem_size = mem::size_of::<T>();\n+        let min_non_zero_cap = if elem_size == 1 {\n+            8\n+        } else if elem_size <= 1024 {\n+            4\n+        } else {\n+            1\n+        };\n+        let cap = cmp::max(min_non_zero_cap, cap);\n+\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, placement, self.current_memory(), &mut self.alloc)?;\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n+\n+    // The constraints on this method are much the same as those on\n+    // `grow_amortized`, but this method is usually instantiated less often so\n+    // it's less critical.\n+    fn grow_exact(\n         &mut self,\n         used_capacity: usize,\n         needed_extra_capacity: usize,\n-        fallibility: Fallibility,\n-        strategy: ReserveStrategy,\n     ) -> Result<(), TryReserveError> {\n-        let elem_size = mem::size_of::<T>();\n+        if mem::size_of::<T>() == 0 {\n+            // Since we return a capacity of `usize::MAX` when the type size is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n+            return Err(CapacityOverflow);\n+        }\n \n-        unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they gave a bad `used_capacity`.\n-            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n-                return Ok(());\n-            }\n+        let cap = used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        let new_layout = Layout::array::<T>(cap);\n \n-            // Nothing we can really do about these checks, sadly.\n-            let new_cap = match strategy {\n-                Exact => {\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?\n-                }\n-                Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n-            };\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, MayMove, self.current_memory(), &mut self.alloc)?;\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n \n-            alloc_guard(new_layout.size())?;\n+    fn shrink(\n+        &mut self,\n+        amount: usize,\n+        placement: ReallocPlacement,\n+    ) -> Result<(), TryReserveError> {\n+        assert!(amount <= self.capacity(), \"Tried to shrink to a larger capacity\");\n \n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).cast(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            let (ptr, new_cap) = match (res, fallibility) {\n-                (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                (Err(AllocErr), Fallible) => {\n-                    return Err(TryReserveError::AllocError {\n-                        layout: new_layout,\n-                        non_exhaustive: (),\n-                    });\n-                }\n-                (Ok((ptr, new_size)), _) => (ptr, new_size / elem_size),\n-            };\n+        let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n+        let new_size = amount * mem::size_of::<T>();\n \n-            self.ptr = ptr.cast().into();\n-            self.cap = new_cap;\n+        let memory = unsafe {\n+            self.alloc.shrink(ptr, layout, new_size, placement).map_err(|_| {\n+                TryReserveError::AllocError {\n+                    layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n+                    non_exhaustive: (),\n+                }\n+            })?\n+        };\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n+}\n \n-            Ok(())\n+// This function is outside `RawVec` to minimize compile times. See the comment\n+// above `RawVec::grow_amortized` for details. (The `A` parameter isn't\n+// significant, because the number of different `A` types seen in practice is\n+// much smaller than the number of `T` types.)\n+fn finish_grow<A>(\n+    new_layout: Result<Layout, LayoutErr>,\n+    placement: ReallocPlacement,\n+    current_memory: Option<(NonNull<u8>, Layout)>,\n+    alloc: &mut A,\n+) -> Result<MemoryBlock, TryReserveError>\n+where\n+    A: AllocRef,\n+{\n+    // Check for the error here to minimize the size of `RawVec::grow_*`.\n+    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n+\n+    alloc_guard(new_layout.size())?;\n+\n+    let memory = if let Some((ptr, old_layout)) = current_memory {\n+        debug_assert_eq!(old_layout.align(), new_layout.align());\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), placement, Uninitialized) }\n+    } else {\n+        match placement {\n+            MayMove => alloc.alloc(new_layout, Uninitialized),\n+            InPlace => Err(AllocErr),\n         }\n     }\n+    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n+\n+    Ok(memory)\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Converts the entire buffer into `Box<[T]>`.\n+    /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n     /// that may have been performed. (See description of type for details.)\n     ///\n-    /// # Undefined Behavior\n-    ///\n-    /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n-    /// the rules around uninitialized boxed values are not finalized yet,\n-    /// but until they are, it is advisable to avoid them.\n-    pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n-        let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n-        let output: Box<[T]> = Box::from_raw(slice);\n-        mem::forget(self);\n-        output\n-    }\n-}\n+    /// # Safety\n+    ///\n+    /// * `len` must be greater than or equal to the most recently requested capacity, and\n+    /// * `len` must be less than or equal to `self.capacity()`.\n+    ///\n+    /// Note, that the requested capacity and `self.capacity()` could differ, as\n+    /// an allocator could overallocate and return a greater memory block than requested.\n+    pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+        // Sanity-check one half of the safety requirement (we cannot check the other half).\n+        debug_assert!(\n+            len <= self.capacity(),\n+            \"`len` must be smaller than or equal to `self.capacity()`\"\n+        );\n \n-impl<T, A: AllocRef> RawVec<T, A> {\n-    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n-    pub unsafe fn dealloc_buffer(&mut self) {\n-        let elem_size = mem::size_of::<T>();\n-        if elem_size != 0 {\n-            if let Some(layout) = self.current_layout() {\n-                self.a.dealloc(NonNull::from(self.ptr).cast(), layout);\n-            }\n-        }\n+        let me = ManuallyDrop::new(self);\n+        let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n+        Box::from_raw(slice)\n     }\n }\n \n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n-        unsafe {\n-            self.dealloc_buffer();\n+        if let Some((ptr, layout)) = self.current_memory() {\n+            unsafe { self.alloc.dealloc(ptr, layout) }\n         }\n     }\n }\n@@ -736,7 +566,7 @@ unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n-    if mem::size_of::<usize>() < 8 && alloc_size > core::isize::MAX as usize {\n+    if mem::size_of::<usize>() < 8 && alloc_size > isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {\n         Ok(())"}, {"sha": "17622d72a059c2e99266c23f7e489023bdea8f7c", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -12,6 +12,7 @@ fn allocator_param() {\n     //\n     // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n+\n     // storage.\n \n     // A dumb allocator that consumes a fixed amount of fuel\n@@ -20,12 +21,12 @@ fn allocator_param() {\n         fuel: usize,\n     }\n     unsafe impl AllocRef for BoundedAlloc {\n-        fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n+        fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n-            match Global.alloc(layout) {\n+            match Global.alloc(layout, init) {\n                 ok @ Ok(_) => {\n                     self.fuel -= size;\n                     ok\n@@ -40,9 +41,9 @@ fn allocator_param() {\n \n     let a = BoundedAlloc { fuel: 500 };\n     let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-    assert_eq!(v.a.fuel, 450);\n+    assert_eq!(v.alloc.fuel, 450);\n     v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-    assert_eq!(v.a.fuel, 250);\n+    assert_eq!(v.alloc.fuel, 250);\n }\n \n #[test]\n@@ -58,7 +59,7 @@ fn reserve_does_not_overallocate() {\n         let mut v: RawVec<u32> = RawVec::new();\n         v.reserve(0, 7);\n         assert_eq!(7, v.capacity());\n-        // 97 if more than double of 7, so `reserve` should work\n+        // 97 is more than double of 7, so `reserve` should work\n         // like `reserve_exact`.\n         v.reserve(7, 90);\n         assert_eq!(97, v.capacity());"}, {"sha": "ad96a138d7e55b36fb80664e00b096821a3b0e64", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 91, "deletions": 65, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -249,10 +249,10 @@ use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n-use core::usize;\n+use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -280,7 +280,7 @@ struct RcBox<T: ?Sized> {\n /// type `T`.\n ///\n /// [get_mut]: #method.get_mut\n-#[cfg_attr(not(test), lang = \"rc\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Rc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: NonNull<RcBox<T>>,\n@@ -324,11 +324,9 @@ impl<T> Rc<T> {\n         // pointers, which ensures that the weak destructor never frees\n         // the allocation while the strong destructor is running, even\n         // if the weak pointer is stored inside the strong one.\n-        Self::from_inner(Box::into_raw_non_null(box RcBox {\n-            strong: Cell::new(1),\n-            weak: Cell::new(1),\n-            value,\n-        }))\n+        Self::from_inner(\n+            Box::leak(box RcBox { strong: Cell::new(1), weak: Cell::new(1), value }).into(),\n+        )\n     }\n \n     /// Constructs a new `Rc` with uninitialized contents.\n@@ -569,9 +567,33 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n+        let ptr = Self::as_ptr(&this);\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Provides a raw pointer to the data.\n+    ///\n+    /// The counts are not affected in any way and the `Rc` is not consumed. The pointer is valid\n+    /// for as long there are strong counts in the `Rc`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(\"hello\".to_owned());\n+    /// let y = Rc::clone(&x);\n+    /// let x_ptr = Rc::as_ptr(&x);\n+    /// assert_eq!(x_ptr, Rc::as_ptr(&y));\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n-        mem::forget(this);\n \n         // SAFETY: This cannot go through Deref::deref.\n         // Instead, we manually offset the pointer rather than manifesting a reference.\n@@ -638,6 +660,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// ```\n     /// #![feature(rc_into_raw_non_null)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::rc::Rc;\n     ///\n@@ -647,6 +670,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n+    #[rustc_deprecated(since = \"1.44.0\", reason = \"use `Rc::into_raw` instead\")]\n     #[inline]\n     pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n         // safe because Rc guarantees its pointer is non-null\n@@ -936,10 +960,12 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global\n+            .alloc(layout, AllocInit::Uninitialized)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = mem_to_rcbox(mem.as_ptr());\n+        let inner = mem_to_rcbox(mem.ptr.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n@@ -998,7 +1024,7 @@ unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n }\n \n impl<T> Rc<[T]> {\n-    /// Copy elements from slice into newly allocated Rc<[T]>\n+    /// Copy elements from slice into newly allocated Rc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n@@ -1196,6 +1222,12 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n     }\n }\n \n+// Hack to allow specializing on `Eq` even though `Eq` has a method.\n+#[rustc_unsafe_specialization_marker]\n+pub(crate) trait MarkerEq: PartialEq<Self> {}\n+\n+impl<T: Eq> MarkerEq for T {}\n+\n /// We're doing this specialization here, and not as a more general optimization on `&T`, because it\n /// would otherwise add a cost to all equality checks on refs. We assume that `Rc`s are used to\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n@@ -1204,7 +1236,7 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n+impl<T: ?Sized + MarkerEq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n     fn eq(&self, other: &Rc<T>) -> bool {\n         Rc::ptr_eq(self, other) || **self == **other\n@@ -1466,6 +1498,21 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     }\n }\n \n+#[stable(feature = \"shared_from_cow\", since = \"1.45.0\")]\n+impl<'a, B> From<Cow<'a, B>> for Rc<B>\n+where\n+    B: ToOwned + ?Sized,\n+    Rc<B>: From<&'a B> + From<B::Owned>,\n+{\n+    #[inline]\n+    fn from(cow: Cow<'a, B>) -> Rc<B> {\n+        match cow {\n+            Cow::Borrowed(s) => Rc::from(s),\n+            Cow::Owned(s) => Rc::from(s),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]>\n where\n@@ -1523,25 +1570,25 @@ impl<T> iter::FromIterator<T> for Rc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        RcFromIter::from_iter(iter.into_iter())\n+        ToRcSlice::to_rc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Rc<[T]>`.\n-trait RcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToRcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_rc_slice(self) -> Rc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToRcSlice<T> for I {\n+    default fn to_rc_slice(self) -> Rc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToRcSlice<T> for I {\n+    fn to_rc_slice(self) -> Rc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -1552,29 +1599,15 @@ impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Rc::from_iter_exact(iter, low)\n+                Rc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Rc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -1642,8 +1675,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1656,31 +1689,22 @@ impl<T> Weak<T> {\n     /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const RcBox<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1689,7 +1713,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1710,10 +1734,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1728,9 +1752,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw`], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`]  and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1763,7 +1786,6 @@ impl<T> Weak<T> {\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Rc`]: struct.Rc.html\n     /// [`Weak`]: struct.Weak.html\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n@@ -2021,6 +2043,8 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if strong == 0 || strong == usize::max_value() {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }\n@@ -2047,6 +2071,8 @@ trait RcBoxPtr<T: ?Sized> {\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n         if weak == 0 || weak == usize::max_value() {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }"}, {"sha": "53477288b59ee8a89d39bb2bbbd5eceb0730ea8e", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -90,7 +90,6 @@ use core::borrow::{Borrow, BorrowMut};\n use core::cmp::Ordering::{self, Less};\n use core::mem::{self, size_of};\n use core::ptr;\n-use core::{u16, u32, u8};\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n@@ -141,6 +140,9 @@ mod hack {\n     use crate::string::ToString;\n     use crate::vec::Vec;\n \n+    // We shouldn't add inline attribute to this since this is used in\n+    // `vec!` macro mostly and causes perf regression. See #71204 for\n+    // discussion and perf results.\n     pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n             let len = b.len();\n@@ -165,7 +167,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -200,7 +202,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n log n)` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -254,7 +256,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log(m n))`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n * log(n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n@@ -297,7 +299,7 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n + n log n)`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n + n * log(n))`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n@@ -432,7 +434,7 @@ impl<T> [T] {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// b\"0123456789abcdef\".repeat(usize::max_value());\n+    /// b\"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T>\n@@ -734,14 +736,14 @@ impl<T: Clone> ToOwned for [T] {\n     fn clone_into(&self, target: &mut Vec<T>) {\n         // drop anything in target that will not be overwritten\n         target.truncate(self.len());\n-        let len = target.len();\n-\n-        // reuse the contained values' allocations/resources.\n-        target.clone_from_slice(&self[..len]);\n \n         // target.len <= self.len due to the truncate above, so the\n-        // slice here is always in-bounds.\n-        target.extend_from_slice(&self[len..]);\n+        // slices here are always in-bounds.\n+        let (init, tail) = self.split_at(target.len());\n+\n+        // reuse the contained values' allocations/resources.\n+        target.clone_from_slice(init);\n+        target.extend_from_slice(tail);\n     }\n }\n \n@@ -935,7 +937,7 @@ where\n /// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n-/// The invariants ensure that the total running time is `O(n log n)` worst-case.\n+/// The invariants ensure that the total running time is `O(n * log(n))` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "70860c09a2c31d0b031b753253265b667e391311", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -499,7 +499,7 @@ impl str {\n     ///\n     /// ```should_panic\n     /// // this will panic at runtime\n-    /// \"0123456789abcdef\".repeat(usize::max_value());\n+    /// \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {"}, {"sha": "f3fe1adebb141d4dd3c1b91b2c42e304825e3112", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -278,6 +278,7 @@ use crate::vec::Vec;\n /// [`Deref`]: ../../std/ops/trait.Deref.html\n /// [`as_str()`]: struct.String.html#method.as_str\n #[derive(PartialOrd, Eq, Ord)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"string_type\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n     vec: Vec<u8>,\n@@ -482,6 +483,7 @@ impl String {\n     /// [`String`]: struct.String.html\n     /// [`u8`]: ../../std/primitive.u8.html\n     /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n+    /// [`&str`]: ../../std/primitive.str.html\n     /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n     /// [`into_bytes`]: struct.String.html#method.into_bytes\n     /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n@@ -1461,6 +1463,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"string_split_off\", since = \"1.16.0\")]\n+    #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     pub fn split_off(&mut self, at: usize) -> String {\n         assert!(self.is_char_boundary(at));\n         let other = self.vec.split_off(at);\n@@ -1826,7 +1829,13 @@ impl<'a> Extend<Cow<'a, str>> for String {\n     }\n }\n \n-/// A convenience impl that delegates to the impl for `&str`\n+/// A convenience impl that delegates to the impl for `&str`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// assert_eq!(String::from(\"Hello world\").find(\"world\"), Some(6));\n+/// ```\n #[unstable(\n     feature = \"pattern\",\n     reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -1848,6 +1857,21 @@ impl<'a, 'b> Pattern<'a> for &'b String {\n     fn is_prefix_of(self, haystack: &'a str) -> bool {\n         self[..].is_prefix_of(haystack)\n     }\n+\n+    #[inline]\n+    fn strip_prefix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self[..].strip_prefix_of(haystack)\n+    }\n+\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool {\n+        self[..].is_suffix_of(haystack)\n+    }\n+\n+    #[inline]\n+    fn strip_suffix_of(self, haystack: &'a str) -> Option<&'a str> {\n+        self[..].strip_suffix_of(haystack)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "b7be8042ea49f33114750b3405eb26cece218b7f", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 159, "deletions": 61, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -20,12 +20,12 @@ use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{CoerceUnsized, Deref, DispatchFromDyn, Receiver};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::{self, from_raw_parts_mut};\n+use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n-use core::{isize, usize};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n+use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n use crate::string::String;\n@@ -208,7 +208,7 @@ macro_rules! acquire {\n /// counting in general.\n ///\n /// [rc_examples]: ../../std/rc/index.html#examples\n-#[cfg_attr(not(test), lang = \"arc\")]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"Arc\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: NonNull<ArcInner<T>>,\n@@ -325,7 +325,7 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         };\n-        Self::from_inner(Box::into_raw_non_null(x))\n+        Self::from_inner(Box::leak(x).into())\n     }\n \n     /// Constructs a new `Arc` with uninitialized contents.\n@@ -566,9 +566,33 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n+        let ptr = Self::as_ptr(&this);\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Provides a raw pointer to the data.\n+    ///\n+    /// The counts are not affected in way and the `Arc` is not consumed. The pointer is valid for\n+    /// as long as there are strong counts in the `Arc`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(\"hello\".to_owned());\n+    /// let y = Arc::clone(&x);\n+    /// let x_ptr = Arc::as_ptr(&x);\n+    /// assert_eq!(x_ptr, Arc::as_ptr(&y));\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n-        mem::forget(this);\n \n         // SAFETY: This cannot go through Deref::deref.\n         // Instead, we manually offset the pointer rather than manifesting a reference.\n@@ -635,6 +659,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// ```\n     /// #![feature(rc_into_raw_non_null)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::sync::Arc;\n     ///\n@@ -644,6 +669,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n+    #[rustc_deprecated(since = \"1.44.0\", reason = \"use `Arc::into_raw` instead\")]\n     #[inline]\n     pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n         // safe because Arc guarantees its pointer is non-null\n@@ -751,6 +777,81 @@ impl<T: ?Sized> Arc<T> {\n         this.inner().strong.load(SeqCst)\n     }\n \n+    /// Increments the strong reference count on the `Arc<T>` associated with the\n+    /// provided pointer by one.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must have been obtained through `Arc::into_raw`, and the\n+    /// associated `Arc` instance must be valid (i.e. the strong count must be at\n+    /// least 1) for the duration of this method.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_mutate_strong_count)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// unsafe {\n+    ///     let ptr = Arc::into_raw(five);\n+    ///     Arc::incr_strong_count(ptr);\n+    ///\n+    ///     // This assertion is deterministic because we haven't shared\n+    ///     // the `Arc` between threads.\n+    ///     let five = Arc::from_raw(ptr);\n+    ///     assert_eq!(2, Arc::strong_count(&five));\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_mutate_strong_count\", issue = \"71983\")]\n+    pub unsafe fn incr_strong_count(ptr: *const T) {\n+        // Retain Arc, but don't touch refcount by wrapping in ManuallyDrop\n+        let arc = mem::ManuallyDrop::new(Arc::<T>::from_raw(ptr));\n+        // Now increase refcount, but don't drop new refcount either\n+        let _arc_clone: mem::ManuallyDrop<_> = arc.clone();\n+    }\n+\n+    /// Decrements the strong reference count on the `Arc<T>` associated with the\n+    /// provided pointer by one.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must have been obtained through `Arc::into_raw`, and the\n+    /// associated `Arc` instance must be valid (i.e. the strong count must be at\n+    /// least 1) when invoking this method. This method can be used to release the final\n+    /// `Arc` and backing storage, but **should not** be called after the final `Arc` has been\n+    /// released.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_mutate_strong_count)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// unsafe {\n+    ///     let ptr = Arc::into_raw(five);\n+    ///     Arc::incr_strong_count(ptr);\n+    ///\n+    ///     // Those assertions are deterministic because we haven't shared\n+    ///     // the `Arc` between threads.\n+    ///     let five = Arc::from_raw(ptr);\n+    ///     assert_eq!(2, Arc::strong_count(&five));\n+    ///     Arc::decr_strong_count(ptr);\n+    ///     assert_eq!(1, Arc::strong_count(&five));\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"arc_mutate_strong_count\", issue = \"71983\")]\n+    pub unsafe fn decr_strong_count(ptr: *const T) {\n+        mem::drop(Arc::from_raw(ptr));\n+    }\n+\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // This unsafety is ok because while this arc is alive we're guaranteed\n@@ -814,10 +915,12 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let (mem, _) = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let mem = Global\n+            .alloc(layout, AllocInit::Uninitialized)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = mem_to_arcinner(mem.as_ptr());\n+        let inner = mem_to_arcinner(mem.ptr.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n@@ -876,7 +979,7 @@ unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n }\n \n impl<T> Arc<[T]> {\n-    /// Copy elements from slice into newly allocated Arc<[T]>\n+    /// Copy elements from slice into newly allocated Arc<\\[T\\]>\n     ///\n     /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n@@ -994,6 +1097,8 @@ impl<T: ?Sized> Clone for Arc<T> {\n         // We abort because such a program is incredibly degenerate, and we\n         // don't care to support it.\n         if old_size > MAX_REFCOUNT {\n+            // remove `unsafe` on bootstrap bump\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n             unsafe {\n                 abort();\n             }\n@@ -1338,8 +1443,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1352,31 +1457,22 @@ impl<T> Weak<T> {\n     /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const ArcInner<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1385,7 +1481,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1406,10 +1502,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1425,9 +1521,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw'], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`] and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1456,7 +1551,6 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n@@ -1523,6 +1617,8 @@ impl<T: ?Sized> Weak<T> {\n \n             // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n             if n > MAX_REFCOUNT {\n+                // remove `unsafe` on bootstrap bump\n+                #[cfg_attr(not(bootstrap), allow(unused_unsafe))]\n                 unsafe {\n                     abort();\n                 }\n@@ -1662,6 +1758,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n         // See comments in Arc::clone() for why we do this (for mem::forget).\n         if old_size > MAX_REFCOUNT {\n+            #[cfg_attr(not(bootstrap), allow(unused_unsafe))] // remove `unsafe` on bootstrap bump\n             unsafe {\n                 abort();\n             }\n@@ -1763,7 +1860,7 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n ///\n /// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n+impl<T: ?Sized + crate::rc::MarkerEq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n     fn eq(&self, other: &Arc<T>) -> bool {\n         Arc::ptr_eq(self, other) || **self == **other\n@@ -2032,6 +2129,21 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     }\n }\n \n+#[stable(feature = \"shared_from_cow\", since = \"1.45.0\")]\n+impl<'a, B> From<Cow<'a, B>> for Arc<B>\n+where\n+    B: ToOwned + ?Sized,\n+    Arc<B>: From<&'a B> + From<B::Owned>,\n+{\n+    #[inline]\n+    fn from(cow: Cow<'a, B>) -> Arc<B> {\n+        match cow {\n+            Cow::Borrowed(s) => Arc::from(s),\n+            Cow::Owned(s) => Arc::from(s),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Arc<[T]>> for Arc<[T; N]>\n where\n@@ -2089,25 +2201,25 @@ impl<T> iter::FromIterator<T> for Arc<[T]> {\n     /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n     /// ```\n     fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n-        ArcFromIter::from_iter(iter.into_iter())\n+        ToArcSlice::to_arc_slice(iter.into_iter())\n     }\n }\n \n /// Specialization trait used for collecting into `Arc<[T]>`.\n-trait ArcFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n+trait ToArcSlice<T>: Iterator<Item = T> + Sized {\n+    fn to_arc_slice(self) -> Arc<[T]>;\n }\n \n-impl<T, I: Iterator<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n-        iter.collect::<Vec<T>>().into()\n+impl<T, I: Iterator<Item = T>> ToArcSlice<T> for I {\n+    default fn to_arc_slice(self) -> Arc<[T]> {\n+        self.collect::<Vec<T>>().into()\n     }\n }\n \n-impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n-    default fn from_iter(iter: I) -> Self {\n+impl<T, I: iter::TrustedLen<Item = T>> ToArcSlice<T> for I {\n+    fn to_arc_slice(self) -> Arc<[T]> {\n         // This is the case for a `TrustedLen` iterator.\n-        let (low, high) = iter.size_hint();\n+        let (low, high) = self.size_hint();\n         if let Some(high) = high {\n             debug_assert_eq!(\n                 low,\n@@ -2118,29 +2230,15 @@ impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n \n             unsafe {\n                 // SAFETY: We need to ensure that the iterator has an exact length and we have.\n-                Arc::from_iter_exact(iter, low)\n+                Arc::from_iter_exact(self, low)\n             }\n         } else {\n             // Fall back to normal implementation.\n-            iter.collect::<Vec<T>>().into()\n+            self.collect::<Vec<T>>().into()\n         }\n     }\n }\n \n-impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n-    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n-        // Delegate to `impl<T: Clone> From<&[T]> for Arc<[T]>`.\n-        //\n-        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n-        // which is even more performant.\n-        //\n-        // In the fall-back case we have `T: Clone`. This is still better\n-        // than the `TrustedLen` implementation as slices have a known length\n-        // and so we get to avoid calling `size_hint` and avoid the branching.\n-        iter.as_slice().into()\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n     fn borrow(&self) -> &T {"}, {"sha": "a2bb651e2b77804397d0e88fea8955cacee86d5b", "filename": "src/liballoc/sync/tests.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -32,7 +32,6 @@ impl Drop for Canary {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn manually_share_arc() {\n     let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = Arc::new(v);\n@@ -337,12 +336,13 @@ fn test_ptr_eq() {\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg_attr(miri, ignore)] // Miri does not support threads\n fn test_weak_count_locked() {\n     let mut a = Arc::new(atomic::AtomicBool::new(false));\n     let a2 = a.clone();\n     let t = thread::spawn(move || {\n-        for _i in 0..1000000 {\n+        // Miri is too slow\n+        let count = if cfg!(miri) { 1000 } else { 1000000 };\n+        for _i in 0..count {\n             Arc::get_mut(&mut a);\n         }\n         a.store(true, SeqCst);\n@@ -351,6 +351,8 @@ fn test_weak_count_locked() {\n     while !a2.load(SeqCst) {\n         let n = Arc::weak_count(&a2);\n         assert!(n < 2, \"bad weak count: {}\", n);\n+        #[cfg(miri)] // Miri's scheduler does not guarantee liveness, and thus needs this hint.\n+        atomic::spin_loop_hint();\n     }\n     t.join().unwrap();\n }"}, {"sha": "745444a152e1b737ba4b399ee3970e424430f9fe", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,6 +1,6 @@\n #![unstable(feature = \"wake_trait\", issue = \"69912\")]\n //! Types and Traits for working with asynchronous tasks.\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::ManuallyDrop;\n use core::task::{RawWaker, RawWakerVTable, Waker};\n \n use crate::sync::Arc;\n@@ -12,10 +12,12 @@ use crate::sync::Arc;\n /// to the tasks that are executed on that executor.\n ///\n /// This trait is a memory-safe and ergonomic alternative to constructing a\n-/// [`RawWaker`]. It supports the common executor design in which the data\n-/// used to wake up a task is stored in an [`Arc`]. Some executors (especially\n+/// [`RawWaker`]. It supports the common executor design in which the data used\n+/// to wake up a task is stored in an [`Arc`][arc]. Some executors (especially\n /// those for embedded systems) cannot use this API, which is why [`RawWaker`]\n /// exists as an alternative for those systems.\n+///\n+/// [arc]: ../../std/sync/struct.Arc.html\n #[unstable(feature = \"wake_trait\", issue = \"69912\")]\n pub trait Wake {\n     /// Wake this task.\n@@ -58,9 +60,11 @@ impl<W: Wake + Send + Sync + 'static> From<Arc<W>> for RawWaker {\n fn raw_waker<W: Wake + Send + Sync + 'static>(waker: Arc<W>) -> RawWaker {\n     // Increment the reference count of the arc to clone it.\n     unsafe fn clone_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) -> RawWaker {\n-        let waker: Arc<W> = Arc::from_raw(waker as *const W);\n-        mem::forget(Arc::clone(&waker));\n-        raw_waker(waker)\n+        Arc::incr_strong_count(waker as *const W);\n+        RawWaker::new(\n+            waker as *const (),\n+            &RawWakerVTable::new(clone_waker::<W>, wake::<W>, wake_by_ref::<W>, drop_waker::<W>),\n+        )\n     }\n \n     // Wake by value, moving the Arc into the Wake::wake function\n@@ -77,7 +81,7 @@ fn raw_waker<W: Wake + Send + Sync + 'static>(waker: Arc<W>) -> RawWaker {\n \n     // Decrement the reference count of the Arc on drop\n     unsafe fn drop_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        mem::drop(Arc::from_raw(waker as *const W));\n+        Arc::decr_strong_count(waker as *const W);\n     }\n \n     RawWaker::new("}, {"sha": "bddaab0c761887a80e99eca5a2bb4e6f94a6acd7", "filename": "src/liballoc/tests.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -3,8 +3,6 @@\n use core::any::Any;\n use core::clone::Clone;\n use core::convert::TryInto;\n-use core::f64;\n-use core::i64;\n use core::ops::Deref;\n use core::result::Result::{Err, Ok};\n "}, {"sha": "c02ba267056d6dd391e51cd97bbbdbaf4906302e", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -50,7 +50,7 @@ fn trait_object() {\n \n #[test]\n fn float_nan_ne() {\n-    let x = Arc::new(std::f32::NAN);\n+    let x = Arc::new(f32::NAN);\n     assert!(x != x);\n     assert!(!(x == x));\n }"}, {"sha": "62084ccf53c5929f78edcd6c7e1dff45ea614de4", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -372,6 +372,14 @@ fn assert_covariance() {\n     }\n }\n \n+#[test]\n+fn test_retain() {\n+    let mut a = BinaryHeap::from(vec![-10, -5, 1, 2, 4, 13]);\n+    a.retain(|x| x % 2 == 0);\n+\n+    assert_eq!(a.into_sorted_vec(), [-10, 2, 4])\n+}\n+\n // old binaryheap failed this test\n //\n // Integrity means that all elements are present after a comparison panics,\n@@ -409,16 +417,14 @@ fn panic_safe() {\n     }\n     let mut rng = thread_rng();\n     const DATASZ: usize = 32;\n-    #[cfg(not(miri))] // Miri is too slow\n-    const NTEST: usize = 10;\n-    #[cfg(miri)]\n-    const NTEST: usize = 1;\n+    // Miri is too slow\n+    let ntest = if cfg!(miri) { 1 } else { 10 };\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n     let data = (1..=DATASZ).collect::<Vec<_>>();\n \n     // since it's a fuzzy test, run several tries.\n-    for _ in 0..NTEST {\n+    for _ in 0..ntest {\n         for i in 1..=DATASZ {\n             DROP_COUNTER.store(0, Ordering::SeqCst);\n "}, {"sha": "8bfcf323f674a74c610038a96cb1ed3beb9b473d", "filename": "src/liballoc/tests/borrow.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fborrow.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,47 @@\n+use std::borrow::{Cow, ToOwned};\n+use std::ffi::{CStr, OsStr};\n+use std::path::Path;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+macro_rules! test_from_cow {\n+    ($value:ident => $($ty:ty),+) => {$(\n+        let borrowed = <$ty>::from(Cow::Borrowed($value));\n+        let owned = <$ty>::from(Cow::Owned($value.to_owned()));\n+        assert_eq!($value, &*borrowed);\n+        assert_eq!($value, &*owned);\n+    )+};\n+    ($value:ident : & $ty:ty) => {\n+        test_from_cow!($value => Box<$ty>, Rc<$ty>, Arc<$ty>);\n+    }\n+}\n+\n+#[test]\n+fn test_from_cow_slice() {\n+    let slice: &[i32] = &[1, 2, 3];\n+    test_from_cow!(slice: &[i32]);\n+}\n+\n+#[test]\n+fn test_from_cow_str() {\n+    let string = \"hello\";\n+    test_from_cow!(string: &str);\n+}\n+\n+#[test]\n+fn test_from_cow_c_str() {\n+    let string = CStr::from_bytes_with_nul(b\"hello\\0\").unwrap();\n+    test_from_cow!(string: &CStr);\n+}\n+\n+#[test]\n+fn test_from_cow_os_str() {\n+    let string = OsStr::new(\"hello\");\n+    test_from_cow!(string: &OsStr);\n+}\n+\n+#[test]\n+fn test_from_cow_path() {\n+    let path = Path::new(\"hello\");\n+    test_from_cow!(path: &Path);\n+}"}, {"sha": "731a1b5f875b7c32bcf1f046684287df1b5c599d", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 322, "deletions": 73, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -5,19 +5,31 @@ use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n-use std::sync::atomic::{AtomicU32, Ordering};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n use super::DeterministicRng;\n \n+// Value of node::CAPACITY, thus capacity of a tree with a single level,\n+// i.e. a tree who's root is a leaf node at height 0.\n+const NODE_CAPACITY: usize = 11;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 2 levels,\n+// i.e. a tree who's root is an internal node at height 1, with edges to leaf nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n+\n+// Minimum number of elements to insert in order to guarantee a tree with 3 levels,\n+// i.e. a tree who's root is an internal node at height 2, with edges to more internal nodes.\n+// It's not the minimum size: removing an element from such a tree does not always reduce height.\n+const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    // Miri is too slow\n+    let size = if cfg!(miri) { MIN_INSERTS_HEIGHT_2 } else { 10000 };\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -141,10 +153,8 @@ fn test_basic_small() {\n \n #[test]\n fn test_iter() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = 200;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { 200 } else { 10000 };\n \n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n@@ -166,10 +176,8 @@ fn test_iter() {\n \n #[test]\n fn test_iter_rev() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = 200;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { 200 } else { 10000 };\n \n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n@@ -237,30 +245,26 @@ impl TryFrom<usize> for Align32 {\n \n #[test]\n fn test_iter_mut_mutation() {\n-    // Check many alignments because various fields precede array in NodeHeader.\n-    // Check with size 0 which should not iterate at all.\n-    // Check with size 1 for a tree with one kind of node (root = leaf).\n-    // Check with size 12 for a tree with two kinds of nodes (root and leaves).\n-    // Check with size 144 for a tree with all kinds of nodes (root, internals and leaves).\n+    // Check many alignments and trees with roots at various heights.\n     do_test_iter_mut_mutation::<u8>(0);\n     do_test_iter_mut_mutation::<u8>(1);\n-    do_test_iter_mut_mutation::<u8>(12);\n-    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test 144\n+    do_test_iter_mut_mutation::<u8>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test MIN_INSERTS_HEIGHT_2\n     do_test_iter_mut_mutation::<u16>(1);\n-    do_test_iter_mut_mutation::<u16>(12);\n-    do_test_iter_mut_mutation::<u16>(144);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u32>(1);\n-    do_test_iter_mut_mutation::<u32>(12);\n-    do_test_iter_mut_mutation::<u32>(144);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u32>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u64>(1);\n-    do_test_iter_mut_mutation::<u64>(12);\n-    do_test_iter_mut_mutation::<u64>(144);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u64>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u128>(1);\n-    do_test_iter_mut_mutation::<u128>(12);\n-    do_test_iter_mut_mutation::<u128>(144);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<u128>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<Align32>(1);\n-    do_test_iter_mut_mutation::<Align32>(12);\n-    do_test_iter_mut_mutation::<Align32>(144);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_1);\n+    do_test_iter_mut_mutation::<Align32>(MIN_INSERTS_HEIGHT_2);\n }\n \n #[test]\n@@ -279,10 +283,8 @@ fn test_values_mut() {\n \n #[test]\n fn test_iter_mixed() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 10000;\n-    #[cfg(miri)]\n-    let size = 200;\n+    // Miri is too slow\n+    let size = if cfg!(miri) { 200 } else { 10000 };\n \n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n@@ -376,12 +378,11 @@ fn test_range_small() {\n }\n \n #[test]\n-fn test_range_height_2() {\n-    // Assuming that node.CAPACITY is 11, having 12 pairs implies a height 2 tree\n-    // with 2 leaves. Depending on details we don't want or need to rely upon,\n-    // the single key at the root will be 6 or 7.\n+fn test_range_height_1() {\n+    // Tests tree with a root and 2 leaves. Depending on details we don't want or need\n+    // to rely upon, the single key at the root will be 6 or 7.\n \n-    let map: BTreeMap<_, _> = (1..=12).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (1..=MIN_INSERTS_HEIGHT_1 as i32).map(|i| (i, i)).collect();\n     for &root in &[6, 7] {\n         assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n         assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n@@ -466,7 +467,7 @@ fn test_range_large() {\n \n #[test]\n fn test_range_inclusive_max_value() {\n-    let max = std::usize::MAX;\n+    let max = usize::MAX;\n     let map: BTreeMap<_, _> = vec![(max, 0)].into_iter().collect();\n \n     assert_eq!(map.range(max..=max).collect::<Vec<_>>(), &[(&max, &0)]);\n@@ -516,10 +517,8 @@ fn test_range_backwards_4() {\n \n #[test]\n fn test_range_1000() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 1000;\n-    #[cfg(miri)]\n-    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n+    // Miri is too slow\n+    let size = if cfg!(miri) { MIN_INSERTS_HEIGHT_2 as u32 } else { 1000 };\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -557,10 +556,8 @@ fn test_range_borrowed_key() {\n #[test]\n fn test_range() {\n     let size = 200;\n-    #[cfg(not(miri))] // Miri is too slow\n-    let step = 1;\n-    #[cfg(miri)]\n-    let step = 66;\n+    // Miri is too slow\n+    let step = if cfg!(miri) { 66 } else { 1 };\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in (0..size).step_by(step) {\n@@ -580,10 +577,8 @@ fn test_range() {\n #[test]\n fn test_range_mut() {\n     let size = 200;\n-    #[cfg(not(miri))] // Miri is too slow\n-    let step = 1;\n-    #[cfg(miri)]\n-    let step = 66;\n+    // Miri is too slow\n+    let step = if cfg!(miri) { 66 } else { 1 };\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     for i in (0..size).step_by(step) {\n@@ -600,6 +595,263 @@ fn test_range_mut() {\n     }\n }\n \n+mod test_drain_filter {\n+    use super::*;\n+\n+    #[test]\n+    fn empty() {\n+        let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn consuming_nothing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+    }\n+\n+    #[test]\n+    fn consuming_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        assert!(map.drain_filter(|_, _| true).eq(pairs));\n+    }\n+\n+    #[test]\n+    fn mutating_and_keeping() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                false\n+            })\n+            .eq(std::iter::empty())\n+        );\n+        assert!(map.keys().copied().eq(0..3));\n+        assert!(map.values().copied().eq(6..9));\n+    }\n+\n+    #[test]\n+    fn mutating_and_removing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                true\n+            })\n+            .eq((0..3).map(|i| (i, i + 6)))\n+        );\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..3));\n+    }\n+\n+    #[test]\n+    fn underfull_removing_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for doomed in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for sacred in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_removing_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..NODE_CAPACITY));\n+    }\n+\n+    #[test]\n+    fn height_0_removing_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for doomed in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), NODE_CAPACITY - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for sacred in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_removing_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_half() {\n+        let mut map: BTreeMap<_, _> = (0..16).map(|i| (i, i)).collect();\n+        assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n+        assert_eq!(map.len(), 8);\n+    }\n+\n+    #[test]\n+    fn height_1_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_1_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_1_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_2_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn drop_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                    panic!(\"panic in `drop`\");\n+                }\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(move || {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                true\n+            }))\n+        })\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    }\n+\n+    #[test]\n+    fn pred_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(AssertUnwindSafe(|| {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                match i {\n+                    0 => true,\n+                    _ => panic!(),\n+                }\n+            }))\n+        }))\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+        assert_eq!(map.first_entry().unwrap().key(), &4);\n+        assert_eq!(map.last_entry().unwrap().key(), &8);\n+    }\n+}\n+\n #[test]\n fn test_borrow() {\n     // make sure these compile -- using the Borrow trait\n@@ -755,7 +1007,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n-    let size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let size = MIN_INSERTS_HEIGHT_1;\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -783,20 +1035,19 @@ fn test_clone() {\n         assert_eq!(map, map.clone());\n     }\n \n-    // Full 2-level and minimal 3-level tree (sizes 143, 144 -- the only ones we clone for).\n-    for i in 1..=144 {\n-        assert_eq!(map.insert(i, i), None);\n-        assert_eq!(map.len(), i);\n-        if i >= 143 {\n-            assert_eq!(map, map.clone());\n-        }\n-    }\n+    // Test a tree with 2 chock-full levels and a tree with 3 levels.\n+    map = (1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+    assert_eq!(map, map.clone());\n+    map.insert(0, 0);\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2);\n+    assert_eq!(map, map.clone());\n }\n \n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n-    let max_size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n+    let max_size = MIN_INSERTS_HEIGHT_1;\n \n     // Range to max_size inclusive, because i is the size of map1 being tested.\n     for i in 0..=max_size {\n@@ -998,10 +1249,8 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let mut data = rand_data(1529);\n-    #[cfg(miri)]\n-    let mut data = rand_data(529);\n+    // Miri is too slow\n+    let mut data = if cfg!(miri) { rand_data(529) } else { rand_data(1529) };\n     // special case with maximum height.\n     data.sort();\n \n@@ -1014,8 +1263,8 @@ fn test_split_off_large_random_sorted() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_1() {\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_0() {\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n \n@@ -1040,10 +1289,10 @@ fn test_into_iter_drop_leak_1() {\n }\n \n #[test]\n-fn test_into_iter_drop_leak_2() {\n-    let size = 12; // to obtain tree with 2 levels (having edges to leaf nodes)\n-    static DROPS: AtomicU32 = AtomicU32::new(0);\n-    static PANIC_POINT: AtomicU32 = AtomicU32::new(0);\n+fn test_into_iter_drop_leak_height_1() {\n+    let size = MIN_INSERTS_HEIGHT_1;\n+    static DROPS: AtomicUsize = AtomicUsize::new(0);\n+    static PANIC_POINT: AtomicUsize = AtomicUsize::new(0);\n \n     struct D;\n     impl Drop for D {"}, {"sha": "75251ca0d51e9b8b4c49f4f057d03da80f886e54", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,5 +1,7 @@\n use std::collections::BTreeSet;\n use std::iter::FromIterator;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n use super::DeterministicRng;\n \n@@ -302,6 +304,85 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n+#[test]\n+fn test_drain_filter() {\n+    let mut x: BTreeSet<_> = [1].iter().copied().collect();\n+    let mut y: BTreeSet<_> = [1].iter().copied().collect();\n+\n+    x.drain_filter(|_| true);\n+    y.drain_filter(|_| false);\n+    assert_eq!(x.len(), 0);\n+    assert_eq!(y.len(), 1);\n+}\n+\n+#[test]\n+fn test_drain_filter_drop_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(move || {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            true\n+        }))\n+    })\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+}\n+\n+#[test]\n+fn test_drain_filter_pred_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            match d.0 {\n+                0 => true,\n+                _ => panic!(),\n+            }\n+        }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+    assert_eq!(set.len(), 2);\n+    assert_eq!(set.first().unwrap().0, 4);\n+    assert_eq!(set.last().unwrap().0, 8);\n+}\n+\n #[test]\n fn test_clear() {\n     let mut x = BTreeSet::new();\n@@ -540,10 +621,8 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let mut data = rand_data(1529);\n-    #[cfg(miri)]\n-    let mut data = rand_data(529);\n+    // Miri is too slow\n+    let mut data = if cfg!(miri) { rand_data(529) } else { rand_data(1529) };\n     // special case with maximum height.\n     data.sort();\n "}, {"sha": "62f062b83d75d77c5e34dfc62b2b347501716236", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{AllocRef, Global, Layout, System};\n+use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -20,7 +20,13 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n             unsafe {\n                 let pointers: Vec<_> = (0..iterations)\n                     .map(|_| {\n-                        allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap().0\n+                        allocator\n+                            .alloc(\n+                                Layout::from_size_align(size, align).unwrap(),\n+                                AllocInit::Uninitialized,\n+                            )\n+                            .unwrap()\n+                            .ptr\n                     })\n                     .collect();\n                 for &ptr in &pointers {"}, {"sha": "f3da46bd0cc4ebf5470b0241f3687802d3aa8b09", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,5 +1,6 @@\n #![feature(allocator_api)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(map_first_last)]\n@@ -13,12 +14,14 @@\n #![feature(binary_heap_drain_sorted)]\n #![feature(vec_remove_item)]\n #![feature(split_inclusive)]\n+#![feature(binary_heap_retain)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};\n \n mod arc;\n mod binary_heap;\n+mod borrow;\n mod boxed;\n mod btree;\n mod cow_str;"}, {"sha": "501b4f0f816be3f861bf768de3fecc45576875db", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -50,7 +50,7 @@ fn trait_object() {\n \n #[test]\n fn float_nan_ne() {\n-    let x = Rc::new(std::f32::NAN);\n+    let x = Rc::new(f32::NAN);\n     assert!(x != x);\n     assert!(!(x == x));\n }"}, {"sha": "75b76bb73ed9e83c327f949c833fb5f9f4022ca9", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -463,15 +463,9 @@ fn test_sort() {\n \n #[test]\n fn test_sort_stability() {\n-    #[cfg(not(miri))] // Miri is too slow\n-    let large_range = 500..510;\n-    #[cfg(not(miri))] // Miri is too slow\n-    let rounds = 10;\n-\n-    #[cfg(miri)]\n-    let large_range = 0..0; // empty range\n-    #[cfg(miri)]\n-    let rounds = 1;\n+    // Miri is too slow\n+    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    let rounds = if cfg!(miri) { 1 } else { 10 };\n \n     for len in (2..25).chain(large_range) {\n         for _ in 0..rounds {\n@@ -1727,15 +1721,9 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    let lens = (1..20).chain(70..MAX_LEN);\n-    #[cfg(not(miri))] // Miri is too slow\n-    let moduli = &[5, 20, 50];\n-\n-    #[cfg(miri)]\n-    let lens = 1..10;\n-    #[cfg(miri)]\n-    let moduli = &[5];\n+    // Miri is too slow\n+    let lens = if cfg!(miri) { (1..10).chain(20..21) } else { (1..20).chain(70..MAX_LEN) };\n+    let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n \n     for len in lens {\n         for &modulus in moduli {"}, {"sha": "9ea020d2d19f4a6349b3b21920e1e3a2b341f3e5", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,7 +1,6 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n use std::mem::size_of;\n-use std::{isize, usize};\n \n pub trait IntoCow<'a, B: ?Sized>\n where\n@@ -266,14 +265,14 @@ fn test_split_off_empty() {\n fn test_split_off_past_end() {\n     let orig = \"Hello, world!\";\n     let mut split = String::from(orig);\n-    split.split_off(orig.len() + 1);\n+    let _ = split.split_off(orig.len() + 1);\n }\n \n #[test]\n #[should_panic]\n fn test_split_off_mid_char() {\n     let mut orig = String::from(\"\u5c71\");\n-    orig.split_off(1);\n+    let _ = orig.split_off(1);\n }\n \n #[test]\n@@ -556,6 +555,7 @@ fn test_reserve_exact() {\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n+#[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve() {\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n@@ -645,6 +645,7 @@ fn test_try_reserve() {\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n+#[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve_exact() {\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments."}, {"sha": "b16044d9640457a38a9f784b69fcc6558f6e3421", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 183, "deletions": 6, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -3,7 +3,6 @@ use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::vec::{Drain, IntoIter};\n-use std::{isize, usize};\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -1138,6 +1137,7 @@ fn test_reserve_exact() {\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n+#[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve() {\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n@@ -1255,6 +1255,7 @@ fn test_try_reserve() {\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n+#[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve_exact() {\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n@@ -1351,24 +1352,85 @@ fn test_try_reserve_exact() {\n }\n \n #[test]\n-fn test_stable_push_pop() {\n+fn test_stable_pointers() {\n+    /// Pull an element from the iterator, then drop it.\n+    /// Useful to cover both the `next` and `drop` paths of an iterator.\n+    fn next_then_drop<I: Iterator>(mut i: I) {\n+        i.next().unwrap();\n+        drop(i);\n+    }\n+\n     // Test that, if we reserved enough space, adding and removing elements does not\n     // invalidate references into the vector (such as `v0`).  This test also\n     // runs in Miri, which would detect such problems.\n-    let mut v = Vec::with_capacity(10);\n+    let mut v = Vec::with_capacity(128);\n     v.push(13);\n \n-    // laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n-    let v0 = unsafe { &*(&v[0] as *const _) };\n-\n+    // Laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n+    let v0 = &mut v[0];\n+    let v0 = unsafe { &mut *(v0 as *mut _) };\n     // Now do a bunch of things and occasionally use `v0` again to assert it is still valid.\n+\n+    // Pushing/inserting and popping/removing\n     v.push(1);\n     v.push(2);\n     v.insert(1, 1);\n     assert_eq!(*v0, 13);\n     v.remove(1);\n     v.pop().unwrap();\n     assert_eq!(*v0, 13);\n+    v.push(1);\n+    v.swap_remove(1);\n+    assert_eq!(v.len(), 2);\n+    v.swap_remove(1); // swap_remove the last element\n+    assert_eq!(*v0, 13);\n+\n+    // Appending\n+    v.append(&mut vec![27, 19]);\n+    assert_eq!(*v0, 13);\n+\n+    // Extending\n+    v.extend_from_slice(&[1, 2]);\n+    v.extend(&[1, 2]); // `slice::Iter` (with `T: Copy`) specialization\n+    v.extend(vec![2, 3]); // `vec::IntoIter` specialization\n+    v.extend(std::iter::once(3)); // `TrustedLen` specialization\n+    v.extend(std::iter::empty::<i32>()); // `TrustedLen` specialization with empty iterator\n+    v.extend(std::iter::once(3).filter(|_| true)); // base case\n+    v.extend(std::iter::once(&3)); // `cloned` specialization\n+    assert_eq!(*v0, 13);\n+\n+    // Truncation\n+    v.truncate(2);\n+    assert_eq!(*v0, 13);\n+\n+    // Resizing\n+    v.resize_with(v.len() + 10, || 42);\n+    assert_eq!(*v0, 13);\n+    v.resize_with(2, || panic!());\n+    assert_eq!(*v0, 13);\n+\n+    // No-op reservation\n+    v.reserve(32);\n+    v.reserve_exact(32);\n+    assert_eq!(*v0, 13);\n+\n+    // Partial draining\n+    v.resize_with(10, || 42);\n+    next_then_drop(v.drain(5..));\n+    assert_eq!(*v0, 13);\n+\n+    // Splicing\n+    v.resize_with(10, || 42);\n+    next_then_drop(v.splice(5.., vec![1, 2, 3, 4, 5])); // empty tail after range\n+    assert_eq!(*v0, 13);\n+    next_then_drop(v.splice(5..8, vec![1])); // replacement is smaller than original range\n+    assert_eq!(*v0, 13);\n+    next_then_drop(v.splice(5..6, vec![1; 10].into_iter().filter(|_| true))); // lower bound not exact\n+    assert_eq!(*v0, 13);\n+\n+    // Smoke test that would fire even outside Miri if an actual relocation happened.\n+    *v0 -= 13;\n+    assert_eq!(v[0], 0);\n }\n \n // https://github.com/rust-lang/rust/pull/49496 introduced specialization based on:\n@@ -1411,3 +1473,118 @@ fn vec_macro_repeating_null_raw_fat_pointer() {\n         vtable: *mut (),\n     }\n }\n+\n+// This test will likely fail if you change the capacities used in\n+// `RawVec::grow_amortized`.\n+#[test]\n+fn test_push_growth_strategy() {\n+    // If the element size is 1, we jump from 0 to 8, then double.\n+    {\n+        let mut v1: Vec<u8> = vec![];\n+        assert_eq!(v1.capacity(), 0);\n+\n+        for _ in 0..8 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 8);\n+        }\n+\n+        for _ in 8..16 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 16);\n+        }\n+\n+        for _ in 16..32 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 32);\n+        }\n+\n+        for _ in 32..64 {\n+            v1.push(0);\n+            assert_eq!(v1.capacity(), 64);\n+        }\n+    }\n+\n+    // If the element size is 2..=1024, we jump from 0 to 4, then double.\n+    {\n+        let mut v2: Vec<u16> = vec![];\n+        let mut v1024: Vec<[u8; 1024]> = vec![];\n+        assert_eq!(v2.capacity(), 0);\n+        assert_eq!(v1024.capacity(), 0);\n+\n+        for _ in 0..4 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 4);\n+            assert_eq!(v1024.capacity(), 4);\n+        }\n+\n+        for _ in 4..8 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 8);\n+            assert_eq!(v1024.capacity(), 8);\n+        }\n+\n+        for _ in 8..16 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 16);\n+            assert_eq!(v1024.capacity(), 16);\n+        }\n+\n+        for _ in 16..32 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 32);\n+            assert_eq!(v1024.capacity(), 32);\n+        }\n+\n+        for _ in 32..64 {\n+            v2.push(0);\n+            v1024.push([0; 1024]);\n+            assert_eq!(v2.capacity(), 64);\n+            assert_eq!(v1024.capacity(), 64);\n+        }\n+    }\n+\n+    // If the element size is > 1024, we jump from 0 to 1, then double.\n+    {\n+        let mut v1025: Vec<[u8; 1025]> = vec![];\n+        assert_eq!(v1025.capacity(), 0);\n+\n+        for _ in 0..1 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 1);\n+        }\n+\n+        for _ in 1..2 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 2);\n+        }\n+\n+        for _ in 2..4 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 4);\n+        }\n+\n+        for _ in 4..8 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 8);\n+        }\n+\n+        for _ in 8..16 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 16);\n+        }\n+\n+        for _ in 16..32 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 32);\n+        }\n+\n+        for _ in 32..64 {\n+            v1025.push([0; 1025]);\n+            assert_eq!(v1025.capacity(), 64);\n+        }\n+    }\n+}"}, {"sha": "762dc4be44d6208950d4bd03e2fba8de66c45fcc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -3,7 +3,6 @@ use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n use std::mem::size_of;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::{isize, usize};\n \n use crate::hash;\n \n@@ -955,16 +954,14 @@ fn test_append_permutations() {\n         out\n     }\n \n-    #[cfg(not(miri))] // Miri is too slow\n-    const MAX: usize = 5;\n-    #[cfg(miri)]\n-    const MAX: usize = 3;\n+    // Miri is too slow\n+    let max = if cfg!(miri) { 3 } else { 5 };\n \n     // Many different permutations of both the `VecDeque` getting appended to\n     // and the one getting appended are generated to check `append`.\n     // This ensures all 6 code paths of `append` are tested.\n-    for src_push_back in 0..MAX {\n-        for src_push_front in 0..MAX {\n+    for src_push_back in 0..max {\n+        for src_push_front in 0..max {\n             // doesn't pop more values than are pushed\n             for src_pop_back in 0..(src_push_back + src_push_front) {\n                 for src_pop_front in 0..(src_push_back + src_push_front - src_pop_back) {\n@@ -975,8 +972,8 @@ fn test_append_permutations() {\n                         src_pop_front,\n                     );\n \n-                    for dst_push_back in 0..MAX {\n-                        for dst_push_front in 0..MAX {\n+                    for dst_push_back in 0..max {\n+                        for dst_push_front in 0..max {\n                             for dst_pop_back in 0..(dst_push_back + dst_push_front) {\n                                 for dst_pop_front in\n                                     0..(dst_push_back + dst_push_front - dst_pop_back)\n@@ -1135,6 +1132,7 @@ fn test_reserve_exact_2() {\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n+#[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve() {\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n@@ -1249,6 +1247,7 @@ fn test_try_reserve() {\n \n #[test]\n #[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n+#[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve_exact() {\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments."}, {"sha": "d26cd77aae4b7120e9ca0a04fbd885b6bf942556", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 115, "deletions": 43, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! A contiguous growable array type with heap-allocated contents, written\n //! `Vec<T>`.\n //!\n@@ -65,7 +66,7 @@ use core::hash::{self, Hash};\n use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n-use core::mem;\n+use core::mem::{self, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Index, IndexMut, RangeBounds};\n use core::ptr::{self, NonNull};\n@@ -391,7 +392,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[unstable(feature = \"vec_into_raw_parts\", reason = \"new API\", issue = \"65816\")]\n     pub fn into_raw_parts(self) -> (*mut T, usize, usize) {\n-        let mut me = mem::ManuallyDrop::new(self);\n+        let mut me = ManuallyDrop::new(self);\n         (me.as_mut_ptr(), me.len(), me.capacity())\n     }\n \n@@ -677,9 +678,10 @@ impl<T> Vec<T> {\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         unsafe {\n             self.shrink_to_fit();\n-            let buf = ptr::read(&self.buf);\n-            mem::forget(self);\n-            buf.into_box()\n+            let me = ManuallyDrop::new(self);\n+            let buf = ptr::read(&me.buf);\n+            let len = me.len();\n+            buf.into_box(len).assume_init()\n         }\n     }\n \n@@ -738,7 +740,8 @@ impl<T> Vec<T> {\n             if len > self.len {\n                 return;\n             }\n-            let s = self.get_unchecked_mut(len..) as *mut _;\n+            let remaining_len = self.len - len;\n+            let s = ptr::slice_from_raw_parts_mut(self.as_mut_ptr().add(len), remaining_len);\n             self.len = len;\n             ptr::drop_in_place(s);\n         }\n@@ -961,13 +964,23 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: usize) -> T {\n+        #[cold]\n+        #[inline(never)]\n+        fn assert_failed(index: usize, len: usize) -> ! {\n+            panic!(\"swap_remove index (is {}) should be < len (is {})\", index, len);\n+        }\n+\n+        let len = self.len();\n+        if index >= len {\n+            assert_failed(index, len);\n+        }\n         unsafe {\n             // We replace self[index] with the last element. Note that if the\n-            // bounds check on hole succeeds there must be a last element (which\n+            // bounds check above succeeds there must be a last element (which\n             // can be self[index] itself).\n-            let hole: *mut T = &mut self[index];\n-            let last = ptr::read(self.get_unchecked(self.len - 1));\n-            self.len -= 1;\n+            let last = ptr::read(self.as_ptr().add(len - 1));\n+            let hole: *mut T = self.as_mut_ptr().add(index);\n+            self.set_len(len - 1);\n             ptr::replace(hole, last)\n         }\n     }\n@@ -990,8 +1003,16 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: usize, element: T) {\n+        #[cold]\n+        #[inline(never)]\n+        fn assert_failed(index: usize, len: usize) -> ! {\n+            panic!(\"insertion index (is {}) should be <= len (is {})\", index, len);\n+        }\n+\n         let len = self.len();\n-        assert!(index <= len);\n+        if index > len {\n+            assert_failed(index, len);\n+        }\n \n         // space for the new element\n         if len == self.buf.capacity() {\n@@ -1030,8 +1051,16 @@ impl<T> Vec<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: usize) -> T {\n+        #[cold]\n+        #[inline(never)]\n+        fn assert_failed(index: usize, len: usize) -> ! {\n+            panic!(\"removal index (is {}) should be < len (is {})\", index, len);\n+        }\n+\n         let len = self.len();\n-        assert!(index < len);\n+        if index >= len {\n+            assert_failed(index, len);\n+        }\n         unsafe {\n             // infallible\n             let ret;\n@@ -1198,7 +1227,7 @@ impl<T> Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(ptr::read(self.get_unchecked(self.len())))\n+                Some(ptr::read(self.as_ptr().add(self.len())))\n             }\n         }\n     }\n@@ -1289,8 +1318,25 @@ impl<T> Vec<T> {\n             Excluded(&n) => n,\n             Unbounded => len,\n         };\n-        assert!(start <= end);\n-        assert!(end <= len);\n+\n+        #[cold]\n+        #[inline(never)]\n+        fn start_assert_failed(start: usize, end: usize) -> ! {\n+            panic!(\"start drain index (is {}) should be <= end drain index (is {})\", start, end);\n+        }\n+\n+        #[cold]\n+        #[inline(never)]\n+        fn end_assert_failed(end: usize, len: usize) -> ! {\n+            panic!(\"end drain index (is {}) should be <= len (is {})\", end, len);\n+        }\n+\n+        if start > end {\n+            start_assert_failed(start, end);\n+        }\n+        if end > len {\n+            end_assert_failed(end, len);\n+        }\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked\n@@ -1380,7 +1426,15 @@ impl<T> Vec<T> {\n     #[must_use = \"use `.truncate()` if you don't need the other half\"]\n     #[stable(feature = \"split_off\", since = \"1.4.0\")]\n     pub fn split_off(&mut self, at: usize) -> Self {\n-        assert!(at <= self.len(), \"`at` out of bounds\");\n+        #[cold]\n+        #[inline(never)]\n+        fn assert_failed(at: usize, len: usize) -> ! {\n+            panic!(\"`at` split index (is {}) should be <= len (is {})\", at, len);\n+        }\n+\n+        if at > self.len() {\n+            assert_failed(at, self.len());\n+        }\n \n         let other_len = self.len - at;\n         let mut other = Vec::with_capacity(other_len);\n@@ -1565,8 +1619,8 @@ impl<T: Default> Vec<T> {\n     #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n     #[rustc_deprecated(\n         reason = \"This is moving towards being removed in favor \\\n-        of `.resize_with(Default::default)`.  If you disagree, please comment \\\n-        in the tracking issue.\",\n+                  of `.resize_with(Default::default)`.  If you disagree, please comment \\\n+                  in the tracking issue.\",\n         since = \"1.33.0\"\n     )]\n     pub fn resize_default(&mut self, new_len: usize) {\n@@ -1771,6 +1825,7 @@ impl<T: Clone + IsZero> SpecFromElem for T {\n     }\n }\n \n+#[rustc_specialization_trait]\n unsafe trait IsZero {\n     /// Whether this value is zero\n     fn is_zero(&self) -> bool;\n@@ -1820,9 +1875,12 @@ unsafe impl<T> IsZero for *mut T {\n     }\n }\n \n-// `Option<&T>`, `Option<&mut T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n-// For fat pointers, the bytes that would be the pointer metadata in the `Some` variant\n-// are padding in the `None` variant, so ignoring them and zero-initializing instead is ok.\n+// `Option<&T>` and `Option<Box<T>>` are guaranteed to represent `None` as null.\n+// For fat pointers, the bytes that would be the pointer metadata in the `Some`\n+// variant are padding in the `None` variant, so ignoring them and\n+// zero-initializing instead is ok.\n+// `Option<&mut T>` never implements `Clone`, so there's no need for an impl of\n+// `SpecFromElem`.\n \n unsafe impl<T: ?Sized> IsZero for Option<&T> {\n     #[inline]\n@@ -1831,13 +1889,6 @@ unsafe impl<T: ?Sized> IsZero for Option<&T> {\n     }\n }\n \n-unsafe impl<T: ?Sized> IsZero for Option<&mut T> {\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.is_none()\n-    }\n-}\n-\n unsafe impl<T: ?Sized> IsZero for Option<Box<T>> {\n     #[inline]\n     fn is_zero(&self) -> bool {\n@@ -1947,16 +1998,16 @@ impl<T> IntoIterator for Vec<T> {\n     /// }\n     /// ```\n     #[inline]\n-    fn into_iter(mut self) -> IntoIter<T> {\n+    fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let begin = self.as_mut_ptr();\n+            let mut me = ManuallyDrop::new(self);\n+            let begin = me.as_mut_ptr();\n             let end = if mem::size_of::<T>() == 0 {\n-                arith_offset(begin as *const i8, self.len() as isize) as *const T\n+                arith_offset(begin as *const i8, me.len() as isize) as *const T\n             } else {\n-                begin.add(self.len()) as *const T\n+                begin.add(me.len()) as *const T\n             };\n-            let cap = self.buf.capacity();\n-            mem::forget(self);\n+            let cap = me.buf.capacity();\n             IntoIter {\n                 buf: NonNull::new_unchecked(begin),\n                 phantom: PhantomData,\n@@ -2018,7 +2069,7 @@ where\n                 let (lower, _) = iterator.size_hint();\n                 let mut vector = Vec::with_capacity(lower.saturating_add(1));\n                 unsafe {\n-                    ptr::write(vector.get_unchecked_mut(0), element);\n+                    ptr::write(vector.as_mut_ptr(), element);\n                     vector.set_len(1);\n                 }\n                 vector\n@@ -2079,9 +2130,8 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n         // has not been advanced at all.\n         if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n             unsafe {\n-                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(), iterator.len(), iterator.cap);\n-                mem::forget(iterator);\n-                vec\n+                let it = ManuallyDrop::new(iterator);\n+                Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap)\n             }\n         } else {\n             let mut vector = Vec::new();\n@@ -2121,8 +2171,9 @@ where\n         self.reserve(slice.len());\n         unsafe {\n             let len = self.len();\n+            let dst_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(len), slice.len());\n+            dst_slice.copy_from_slice(slice);\n             self.set_len(len + slice.len());\n-            self.get_unchecked_mut(len..).copy_from_slice(slice);\n         }\n     }\n }\n@@ -2143,7 +2194,7 @@ impl<T> Vec<T> {\n                 self.reserve(lower.saturating_add(1));\n             }\n             unsafe {\n-                ptr::write(self.get_unchecked_mut(len), element);\n+                ptr::write(self.as_mut_ptr().add(len), element);\n                 // NB can't overflow since we would have had to alloc the address space\n                 self.set_len(len + 1);\n             }\n@@ -2325,7 +2376,9 @@ unsafe impl<#[may_dangle] T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // use drop for [T]\n-            ptr::drop_in_place(&mut self[..]);\n+            // use a raw slice to refer to the elements of the vector as weakest necessary type;\n+            // could avoid questions of validity in certain cases\n+            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr(), self.len))\n         }\n         // RawVec handles deallocation\n     }\n@@ -2398,6 +2451,21 @@ impl<T: Clone> From<&mut [T]> for Vec<T> {\n     }\n }\n \n+#[stable(feature = \"vec_from_array\", since = \"1.44.0\")]\n+impl<T, const N: usize> From<[T; N]> for Vec<T>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[cfg(not(test))]\n+    fn from(s: [T; N]) -> Vec<T> {\n+        <[T]>::into_vec(box s)\n+    }\n+    #[cfg(test)]\n+    fn from(s: [T; N]) -> Vec<T> {\n+        crate::slice::into_vec(box s)\n+    }\n+}\n+\n #[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\n impl<'a, T> From<Cow<'a, [T]>> for Vec<T>\n where\n@@ -2527,7 +2595,11 @@ impl<T> IntoIter<T> {\n     /// ```\n     #[stable(feature = \"vec_into_iter_as_slice\", since = \"1.15.0\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        unsafe { slice::from_raw_parts_mut(self.ptr as *mut T, self.len()) }\n+        unsafe { &mut *self.as_raw_mut_slice() }\n+    }\n+\n+    fn as_raw_mut_slice(&mut self) -> *mut [T] {\n+        ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n     }\n }\n \n@@ -2639,7 +2711,7 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n         let guard = DropGuard(self);\n         // destroy the remaining elements\n         unsafe {\n-            ptr::drop_in_place(guard.0.as_mut_slice());\n+            ptr::drop_in_place(guard.0.as_raw_mut_slice());\n         }\n         // now `guard` will be dropped and do the rest\n     }"}, {"sha": "bbe80c26dcbf98d9c2612e15eb6b4670fdd4c274", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -5,8 +5,7 @@\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate implements `TypedArena`, a simple arena that can only hold\n-//! objects of a single type.\n+//! This crate implements several kinds of arena.\n \n #![doc(\n     html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -98,7 +97,13 @@ impl<T> TypedArenaChunk<T> {\n     }\n }\n \n+// The arenas start with PAGE-sized chunks, and then each new chunk is twice as\n+// big as its predecessor, up until we reach HUGE_PAGE-sized chunks, whereupon\n+// we stop growing. This scales well, from arenas that are barely used up to\n+// arenas that are used for 100s of MiBs. Note also that the chosen sizes match\n+// the usual sizes of pages and huge pages on Linux.\n const PAGE: usize = 4096;\n+const HUGE_PAGE: usize = 2 * 1024 * 1024;\n \n impl<T> Default for TypedArena<T> {\n     /// Creates a new `TypedArena`.\n@@ -211,6 +216,9 @@ impl<T> TypedArena<T> {\n     #[cold]\n     fn grow(&self, n: usize) {\n         unsafe {\n+            // We need the element size in to convert chunk sizes (ranging from\n+            // PAGE to HUGE_PAGE bytes) to element counts.\n+            let elem_size = cmp::max(1, mem::size_of::<T>());\n             let mut chunks = self.chunks.borrow_mut();\n             let (chunk, mut new_capacity);\n             if let Some(last_chunk) = chunks.last_mut() {\n@@ -221,18 +229,20 @@ impl<T> TypedArena<T> {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE / elem_size {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= currently_used_cap + n {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                let elem_size = cmp::max(1, mem::size_of::<T>());\n-                new_capacity = cmp::max(n, PAGE / elem_size);\n+                new_capacity = PAGE / elem_size;\n             }\n+            // Also ensure that this chunk can fit `n`.\n+            new_capacity = cmp::max(n, new_capacity);\n+\n             chunk = TypedArenaChunk::<T>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n@@ -347,17 +357,20 @@ impl DroplessArena {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= used_bytes + needed_bytes {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                new_capacity = cmp::max(needed_bytes, PAGE);\n+                new_capacity = PAGE;\n             }\n+            // Also ensure that this chunk can fit `needed_bytes`.\n+            new_capacity = cmp::max(needed_bytes, new_capacity);\n+\n             chunk = TypedArenaChunk::<u8>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());"}, {"sha": "be20a1cde3694fe0fd89285a91cacfe601c19340", "filename": "src/libcore/alloc.rs", "status": "removed", "additions": 0, "deletions": 1043, "changes": 1043, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b", "patch": "@@ -1,1043 +0,0 @@\n-//! Memory allocation APIs\n-\n-// ignore-tidy-undocumented-unsafe\n-\n-#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n-\n-use crate::cmp;\n-use crate::fmt;\n-use crate::mem;\n-use crate::num::NonZeroUsize;\n-use crate::ptr::{self, NonNull};\n-use crate::usize;\n-\n-const fn size_align<T>() -> (usize, usize) {\n-    (mem::size_of::<T>(), mem::align_of::<T>())\n-}\n-\n-/// Layout of a block of memory.\n-///\n-/// An instance of `Layout` describes a particular layout of memory.\n-/// You build a `Layout` up as an input to give to an allocator.\n-///\n-/// All layouts have an associated non-negative size and a\n-/// power-of-two alignment.\n-///\n-/// (Note however that layouts are *not* required to have positive\n-/// size, even though many allocators require that all memory\n-/// requests have positive size. A caller to the `AllocRef::alloc`\n-/// method must either ensure that conditions like this are met, or\n-/// use specific allocators with looser requirements.)\n-#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-#[lang = \"alloc_layout\"]\n-pub struct Layout {\n-    // size of the requested block of memory, measured in bytes.\n-    size_: usize,\n-\n-    // alignment of the requested block of memory, measured in bytes.\n-    // we ensure that this is always a power-of-two, because API's\n-    // like `posix_memalign` require it and it is a reasonable\n-    // constraint to impose on Layout constructors.\n-    //\n-    // (However, we do not analogously require `align >= sizeof(void*)`,\n-    //  even though that is *also* a requirement of `posix_memalign`.)\n-    align_: NonZeroUsize,\n-}\n-\n-impl Layout {\n-    /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `LayoutErr` if any of the following conditions\n-    /// are not met:\n-    ///\n-    /// * `align` must not be zero,\n-    ///\n-    /// * `align` must be a power of two,\n-    ///\n-    /// * `size`, when rounded up to the nearest multiple of `align`,\n-    ///    must not overflow (i.e., the rounded value must be less than\n-    ///    `usize::MAX`).\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n-        if !align.is_power_of_two() {\n-            return Err(LayoutErr { private: () });\n-        }\n-\n-        // (power-of-two implies align != 0.)\n-\n-        // Rounded up size is:\n-        //   size_rounded_up = (size + align - 1) & !(align - 1);\n-        //\n-        // We know from above that align != 0. If adding (align - 1)\n-        // does not overflow, then rounding up will be fine.\n-        //\n-        // Conversely, &-masking with !(align - 1) will subtract off\n-        // only low-order-bits. Thus if overflow occurs with the sum,\n-        // the &-mask cannot subtract enough to undo that overflow.\n-        //\n-        // Above implies that checking for summation overflow is both\n-        // necessary and sufficient.\n-        if size > usize::MAX - (align - 1) {\n-            return Err(LayoutErr { private: () });\n-        }\n-\n-        unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }\n-    }\n-\n-    /// Creates a layout, bypassing all checks.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe as it does not verify the preconditions from\n-    /// [`Layout::from_size_align`](#method.from_size_align).\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[inline]\n-    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n-    }\n-\n-    /// The minimum size in bytes for a memory block of this layout.\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn size(&self) -> usize {\n-        self.size_\n-    }\n-\n-    /// The minimum byte alignment for a memory block of this layout.\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn align(&self) -> usize {\n-        self.align_.get()\n-    }\n-\n-    /// Constructs a `Layout` suitable for holding a value of type `T`.\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[rustc_const_stable(feature = \"alloc_layout_const_new\", since = \"1.42.0\")]\n-    #[inline]\n-    pub const fn new<T>() -> Self {\n-        let (size, align) = size_align::<T>();\n-        // Note that the align is guaranteed by rustc to be a power of two and\n-        // the size+align combo is guaranteed to fit in our address space. As a\n-        // result use the unchecked constructor here to avoid inserting code\n-        // that panics if it isn't optimized well enough.\n-        unsafe { Layout::from_size_align_unchecked(size, align) }\n-    }\n-\n-    /// Produces layout describing a record that could be used to\n-    /// allocate backing structure for `T` (which could be a trait\n-    /// or other unsized type like a slice).\n-    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-    #[inline]\n-    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n-        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n-        // See rationale in `new` for why this is using an unsafe variant below\n-        debug_assert!(Layout::from_size_align(size, align).is_ok());\n-        unsafe { Layout::from_size_align_unchecked(size, align) }\n-    }\n-\n-    /// Produces layout describing a record that could be used to\n-    /// allocate backing structure for `T` (which could be a trait\n-    /// or other unsized type like a slice).\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is only safe to call if the following conditions hold:\n-    ///\n-    /// - If `T` is `Sized`, this function is always safe to call.\n-    /// - If the unsized tail of `T` is:\n-    ///     - a [slice], then the length of the slice tail must be an intialized\n-    ///       integer, and the size of the *entire value*\n-    ///       (dynamic tail length + statically sized prefix) must fit in `isize`.\n-    ///     - a [trait object], then the vtable part of the pointer must point\n-    ///       to a valid vtable acquired by an unsizing coersion, and the size\n-    ///       of the *entire value* (dynamic tail length + statically sized prefix)\n-    ///       must fit in `isize`.\n-    ///     - an (unstable) [extern type], then this function is always safe to\n-    ///       call, but may panic or otherwise return the wrong value, as the\n-    ///       extern type's layout is not known. This is the same behavior as\n-    ///       [`Layout::for_value`] on a reference to an extern type tail.\n-    ///     - otherwise, it is conservatively not allowed to call this function.\n-    ///\n-    /// [slice]: ../../std/primitive.slice.html\n-    /// [trait object]: ../../book/ch17-02-trait-objects.html\n-    /// [extern type]: ../../unstable-book/language-features/extern-types.html\n-    #[inline]\n-    #[cfg(not(bootstrap))]\n-    #[unstable(feature = \"layout_for_ptr\", issue = \"69835\")]\n-    pub unsafe fn for_value_raw<T: ?Sized>(t: *const T) -> Self {\n-        let (size, align) = (mem::size_of_val_raw(t), mem::align_of_val_raw(t));\n-        // See rationale in `new` for why this is using an unsafe variant below\n-        debug_assert!(Layout::from_size_align(size, align).is_ok());\n-        Layout::from_size_align_unchecked(size, align)\n-    }\n-\n-    /// Creates a `NonNull` that is dangling, but well-aligned for this Layout.\n-    ///\n-    /// Note that the pointer value may potentially represent a valid pointer,\n-    /// which means this must not be used as a \"not yet initialized\"\n-    /// sentinel value. Types that lazily allocate must track initialization by\n-    /// some other means.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    pub const fn dangling(&self) -> NonNull<u8> {\n-        // align is non-zero and a power of two\n-        unsafe { NonNull::new_unchecked(self.align() as *mut u8) }\n-    }\n-\n-    /// Creates a layout describing the record that can hold a value\n-    /// of the same layout as `self`, but that also is aligned to\n-    /// alignment `align` (measured in bytes).\n-    ///\n-    /// If `self` already meets the prescribed alignment, then returns\n-    /// `self`.\n-    ///\n-    /// Note that this method does not add any padding to the overall\n-    /// size, regardless of whether the returned layout has a different\n-    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n-    /// will *still* have size 16.\n-    ///\n-    /// Returns an error if the combination of `self.size()` and the given\n-    /// `align` violates the conditions listed in\n-    /// [`Layout::from_size_align`](#method.from_size_align).\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n-        Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n-    }\n-\n-    /// Returns the amount of padding we must insert after `self`\n-    /// to ensure that the following address will satisfy `align`\n-    /// (measured in bytes).\n-    ///\n-    /// e.g., if `self.size()` is 9, then `self.padding_needed_for(4)`\n-    /// returns 3, because that is the minimum number of bytes of\n-    /// padding required to get a 4-aligned address (assuming that the\n-    /// corresponding memory block starts at a 4-aligned address).\n-    ///\n-    /// The return value of this function has no meaning if `align` is\n-    /// not a power-of-two.\n-    ///\n-    /// Note that the utility of the returned value requires `align`\n-    /// to be less than or equal to the alignment of the starting\n-    /// address for the whole allocated block of memory. One way to\n-    /// satisfy this constraint is to ensure `align <= self.align()`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n-    #[inline]\n-    pub const fn padding_needed_for(&self, align: usize) -> usize {\n-        let len = self.size();\n-\n-        // Rounded up value is:\n-        //   len_rounded_up = (len + align - 1) & !(align - 1);\n-        // and then we return the padding difference: `len_rounded_up - len`.\n-        //\n-        // We use modular arithmetic throughout:\n-        //\n-        // 1. align is guaranteed to be > 0, so align - 1 is always\n-        //    valid.\n-        //\n-        // 2. `len + align - 1` can overflow by at most `align - 1`,\n-        //    so the &-mask with `!(align - 1)` will ensure that in the\n-        //    case of overflow, `len_rounded_up` will itself be 0.\n-        //    Thus the returned padding, when added to `len`, yields 0,\n-        //    which trivially satisfies the alignment `align`.\n-        //\n-        // (Of course, attempts to allocate blocks of memory whose\n-        // size and padding overflow in the above manner should cause\n-        // the allocator to yield an error anyway.)\n-\n-        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n-        len_rounded_up.wrapping_sub(len)\n-    }\n-\n-    /// Creates a layout by rounding the size of this layout up to a multiple\n-    /// of the layout's alignment.\n-    ///\n-    /// This is equivalent to adding the result of `padding_needed_for`\n-    /// to the layout's current size.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn pad_to_align(&self) -> Layout {\n-        let pad = self.padding_needed_for(self.align());\n-        // This cannot overflow. Quoting from the invariant of Layout:\n-        // > `size`, when rounded up to the nearest multiple of `align`,\n-        // > must not overflow (i.e., the rounded value must be less than\n-        // > `usize::MAX`)\n-        let new_size = self.size() + pad;\n-\n-        Layout::from_size_align(new_size, self.align()).unwrap()\n-    }\n-\n-    /// Creates a layout describing the record for `n` instances of\n-    /// `self`, with a suitable amount of padding between each to\n-    /// ensure that each instance is given its requested size and\n-    /// alignment. On success, returns `(k, offs)` where `k` is the\n-    /// layout of the array and `offs` is the distance between the start\n-    /// of each element in the array.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n-        // This cannot overflow. Quoting from the invariant of Layout:\n-        // > `size`, when rounded up to the nearest multiple of `align`,\n-        // > must not overflow (i.e., the rounded value must be less than\n-        // > `usize::MAX`)\n-        let padded_size = self.size() + self.padding_needed_for(self.align());\n-        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n-\n-        unsafe {\n-            // self.align is already known to be valid and alloc_size has been\n-            // padded already.\n-            Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size))\n-        }\n-    }\n-\n-    /// Creates a layout describing the record for `self` followed by\n-    /// `next`, including any necessary padding to ensure that `next`\n-    /// will be properly aligned. Note that the resulting layout will\n-    /// satisfy the alignment properties of both `self` and `next`.\n-    ///\n-    /// The resulting layout will be the same as that of a C struct containing\n-    /// two fields with the layouts of `self` and `next`, in that order.\n-    ///\n-    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n-    /// record and `offset` is the relative location, in bytes, of the\n-    /// start of the `next` embedded within the concatenated record\n-    /// (assuming that the record itself starts at offset 0).\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n-        let new_align = cmp::max(self.align(), next.align());\n-        let pad = self.padding_needed_for(next.align());\n-\n-        let offset = self.size().checked_add(pad).ok_or(LayoutErr { private: () })?;\n-        let new_size = offset.checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n-\n-        let layout = Layout::from_size_align(new_size, new_align)?;\n-        Ok((layout, offset))\n-    }\n-\n-    /// Creates a layout describing the record for `n` instances of\n-    /// `self`, with no padding between each instance.\n-    ///\n-    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n-    /// that the repeated instances of `self` will be properly\n-    /// aligned, even if a given instance of `self` is properly\n-    /// aligned. In other words, if the layout returned by\n-    /// `repeat_packed` is used to allocate an array, it is not\n-    /// guaranteed that all elements in the array will be properly\n-    /// aligned.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n-        let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n-        Layout::from_size_align(size, self.align())\n-    }\n-\n-    /// Creates a layout describing the record for `self` followed by\n-    /// `next` with no additional padding between the two. Since no\n-    /// padding is inserted, the alignment of `next` is irrelevant,\n-    /// and is not incorporated *at all* into the resulting layout.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n-        let new_size = self.size().checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n-        Layout::from_size_align(new_size, self.align())\n-    }\n-\n-    /// Creates a layout describing the record for a `[T; n]`.\n-    ///\n-    /// On arithmetic overflow, returns `LayoutErr`.\n-    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n-    #[inline]\n-    pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n-        Layout::new::<T>().repeat(n).map(|(k, offs)| {\n-            debug_assert!(offs == mem::size_of::<T>());\n-            k\n-        })\n-    }\n-}\n-\n-/// The parameters given to `Layout::from_size_align`\n-/// or some other `Layout` constructor\n-/// do not satisfy its documented constraints.\n-#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct LayoutErr {\n-    private: (),\n-}\n-\n-// (we need this for downstream impl of trait Error)\n-#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n-impl fmt::Display for LayoutErr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"invalid parameters to Layout::from_size_align\")\n-    }\n-}\n-\n-/// The `AllocErr` error indicates an allocation failure\n-/// that may be due to resource exhaustion or to\n-/// something wrong when combining the given input arguments with this\n-/// allocator.\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct AllocErr;\n-\n-// (we need this for downstream impl of trait Error)\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-impl fmt::Display for AllocErr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(\"memory allocation failed\")\n-    }\n-}\n-\n-/// The `CannotReallocInPlace` error is used when [`grow_in_place`] or\n-/// [`shrink_in_place`] were unable to reuse the given memory block for\n-/// a requested layout.\n-///\n-/// [`grow_in_place`]: ./trait.AllocRef.html#method.grow_in_place\n-/// [`shrink_in_place`]: ./trait.AllocRef.html#method.shrink_in_place\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct CannotReallocInPlace;\n-\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-impl CannotReallocInPlace {\n-    pub fn description(&self) -> &str {\n-        \"cannot reallocate allocator's memory in place\"\n-    }\n-}\n-\n-// (we need this for downstream impl of trait Error)\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-impl fmt::Display for CannotReallocInPlace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", self.description())\n-    }\n-}\n-\n-/// A memory allocator that can be registered as the standard library\u2019s default\n-/// through the `#[global_allocator]` attribute.\n-///\n-/// Some of the methods require that a memory block be *currently\n-/// allocated* via an allocator. This means that:\n-///\n-/// * the starting address for that memory block was previously\n-///   returned by a previous call to an allocation method\n-///   such as `alloc`, and\n-///\n-/// * the memory block has not been subsequently deallocated, where\n-///   blocks are deallocated either by being passed to a deallocation\n-///   method such as `dealloc` or by being\n-///   passed to a reallocation method that returns a non-null pointer.\n-///\n-///\n-/// # Example\n-///\n-/// ```no_run\n-/// use std::alloc::{GlobalAlloc, Layout, alloc};\n-/// use std::ptr::null_mut;\n-///\n-/// struct MyAllocator;\n-///\n-/// unsafe impl GlobalAlloc for MyAllocator {\n-///     unsafe fn alloc(&self, _layout: Layout) -> *mut u8 { null_mut() }\n-///     unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n-/// }\n-///\n-/// #[global_allocator]\n-/// static A: MyAllocator = MyAllocator;\n-///\n-/// fn main() {\n-///     unsafe {\n-///         assert!(alloc(Layout::new::<u32>()).is_null())\n-///     }\n-/// }\n-/// ```\n-///\n-/// # Safety\n-///\n-/// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n-/// implementors must ensure that they adhere to these contracts:\n-///\n-/// * It's undefined behavior if global allocators unwind. This restriction may\n-///   be lifted in the future, but currently a panic from any of these\n-///   functions may lead to memory unsafety.\n-///\n-/// * `Layout` queries and calculations in general must be correct. Callers of\n-///   this trait are allowed to rely on the contracts defined on each method,\n-///   and implementors must ensure such contracts remain true.\n-#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-pub unsafe trait GlobalAlloc {\n-    /// Allocate memory as described by the given `layout`.\n-    ///\n-    /// Returns a pointer to newly-allocated memory,\n-    /// or null to indicate allocation failure.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure that `layout` has non-zero size.\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n-    /// The allocated block of memory may or may not be initialized.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning a null pointer indicates that either memory is exhausted\n-    /// or `layout` does not meet this allocator's size or alignment constraints.\n-    ///\n-    /// Implementations are encouraged to return null on memory\n-    /// exhaustion rather than aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n-\n-    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via\n-    ///   this allocator,\n-    ///\n-    /// * `layout` must be the same layout that was used\n-    ///   to allocate that block of memory,\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n-\n-    /// Behaves like `alloc`, but also ensures that the contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `alloc` is.\n-    /// However the allocated block of memory is guaranteed to be initialized.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning a null pointer indicates that either memory is exhausted\n-    /// or `layout` does not meet allocator's size or alignment constraints,\n-    /// just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        let size = layout.size();\n-        let ptr = self.alloc(layout);\n-        if !ptr.is_null() {\n-            ptr::write_bytes(ptr, 0, size);\n-        }\n-        ptr\n-    }\n-\n-    /// Shrink or grow a block of memory to the given `new_size`.\n-    /// The block is described by the given `ptr` pointer and `layout`.\n-    ///\n-    /// If this returns a non-null pointer, then ownership of the memory block\n-    /// referenced by `ptr` has been transferred to this allocator.\n-    /// The memory may or may not have been deallocated,\n-    /// and should be considered unusable (unless of course it was\n-    /// transferred back to the caller again via the return value of\n-    /// this method). The new memory block is allocated with `layout`, but\n-    /// with the `size` updated to `new_size`.\n-    ///\n-    /// If this method returns null, then ownership of the memory\n-    /// block has not been transferred to this allocator, and the\n-    /// contents of the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must be the same layout that was used\n-    ///   to allocate that block of memory,\n-    ///\n-    /// * `new_size` must be greater than zero.\n-    ///\n-    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns null if the new layout does not meet the size\n-    /// and alignment constraints of the allocator, or if reallocation\n-    /// otherwise fails.\n-    ///\n-    /// Implementations are encouraged to return null on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let new_ptr = self.alloc(new_layout);\n-        if !new_ptr.is_null() {\n-            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n-            self.dealloc(ptr, layout);\n-        }\n-        new_ptr\n-    }\n-}\n-\n-/// An implementation of `AllocRef` can allocate, reallocate, and\n-/// deallocate arbitrary blocks of data described via `Layout`.\n-///\n-/// `AllocRef` is designed to be implemented on ZSTs, references, or\n-/// smart pointers because having an allocator like `MyAlloc([u8; N])`\n-/// cannot be moved, without updating the pointers to the allocated\n-/// memory.\n-///\n-/// Some of the methods require that a memory block be *currently\n-/// allocated* via an allocator. This means that:\n-///\n-/// * the starting address for that memory block was previously\n-///   returned by a previous call to an allocation method (`alloc`,\n-///   `alloc_zeroed`) or reallocation method (`realloc`), and\n-///\n-/// * the memory block has not been subsequently deallocated, where\n-///   blocks are deallocated either by being passed to a deallocation\n-///   method (`dealloc`) or by being passed to a reallocation method\n-///  (see above) that returns `Ok`.\n-///\n-/// Unlike [`GlobalAlloc`], zero-sized allocations are allowed in\n-/// `AllocRef`. If an underlying allocator does not support this (like\n-/// jemalloc) or return a null pointer (such as `libc::malloc`), this case\n-/// must be caught. In this case [`Layout::dangling()`] can be used to\n-/// create a dangling, but aligned `NonNull<u8>`.\n-///\n-/// Some of the methods require that a layout *fit* a memory block.\n-/// What it means for a layout to \"fit\" a memory block means (or\n-/// equivalently, for a memory block to \"fit\" a layout) is that the\n-/// following two conditions must hold:\n-///\n-/// 1. The block's starting address must be aligned to `layout.align()`.\n-///\n-/// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n-///\n-///    * `use_min` is `layout.size()`, and\n-///\n-///    * `use_max` is the capacity that was returned.\n-///\n-/// Note that:\n-///\n-///  * the size of the layout most recently used to allocate the block\n-///    is guaranteed to be in the range `[use_min, use_max]`, and\n-///\n-///  * a lower-bound on `use_max` can be safely approximated by a call to\n-///    `usable_size`.\n-///\n-///  * if a layout `k` fits a memory block (denoted by `ptr`)\n-///    currently allocated via an allocator `a`, then it is legal to\n-///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n-///\n-///  * if an allocator does not support overallocating, it is fine to\n-///    simply return `layout.size()` as the allocated size.\n-///\n-/// [`GlobalAlloc`]: self::GlobalAlloc\n-/// [`Layout::dangling()`]: self::Layout::dangling\n-///\n-/// # Safety\n-///\n-/// The `AllocRef` trait is an `unsafe` trait for a number of reasons, and\n-/// implementors must ensure that they adhere to these contracts:\n-///\n-/// * Pointers returned from allocation functions must point to valid memory and\n-///   retain their validity until at least one instance of `AllocRef` is dropped\n-///   itself.\n-///\n-/// * Cloning or moving the allocator must not invalidate pointers returned\n-///   from this allocator. Cloning must return a reference to the same allocator.\n-///\n-/// * `Layout` queries and calculations in general must be correct. Callers of\n-///   this trait are allowed to rely on the contracts defined on each method,\n-///   and implementors must ensure such contracts remain true.\n-///\n-/// Note that this list may get tweaked over time as clarifications are made in\n-/// the future.\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub unsafe trait AllocRef {\n-    /// On success, returns a pointer meeting the size and alignment\n-    /// guarantees of `layout` and the actual size of the allocated block,\n-    /// which must be greater than or equal to `layout.size()`.\n-    ///\n-    /// If this method returns an `Ok(addr)`, then the `addr` returned\n-    /// will be non-null address pointing to a block of storage\n-    /// suitable for holding an instance of `layout`.\n-    ///\n-    /// The returned block of storage may or may not have its contents\n-    /// initialized. (Extension subtraits might restrict this\n-    /// behavior, e.g., to ensure initialization to particular sets of\n-    /// bit patterns.)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints.\n-    ///\n-    /// Implementations are encouraged to return `Err` on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr>;\n-\n-    /// Deallocate the memory referenced by `ptr`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must denote a block of memory currently allocated via\n-    ///   this allocator,\n-    ///\n-    /// * `layout` must *fit* that block of memory,\n-    ///\n-    /// * In addition to fitting the block of memory `layout`, the\n-    ///   alignment of the `layout` must match the alignment used\n-    ///   to allocate that block of memory.\n-    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n-\n-    /// Behaves like `alloc`, but also ensures that the contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returning `Err` indicates that either memory is exhausted or\n-    /// `layout` does not meet allocator's size or alignment\n-    /// constraints, just as in `alloc`.\n-    ///\n-    /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    fn alloc_zeroed(&mut self, layout: Layout) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let size = layout.size();\n-        let result = self.alloc(layout);\n-        if let Ok((p, _)) = result {\n-            unsafe { ptr::write_bytes(p.as_ptr(), 0, size) }\n-        }\n-        result\n-    }\n-\n-    // == METHODS FOR MEMORY REUSE ==\n-    // realloc, realloc_zeroed, grow_in_place, grow_in_place_zeroed, shrink_in_place\n-\n-    /// Returns a pointer suitable for holding data described by\n-    /// a new layout with `layout`\u2019s alignment and a size given\n-    /// by `new_size` and the actual size of the allocated block.\n-    /// The latter is greater than or equal to `layout.size()`.\n-    /// To accomplish this, the allocator may extend or shrink\n-    /// the allocation referenced by `ptr` to fit the new layout.\n-    ///\n-    /// If this returns `Ok`, then ownership of the memory block\n-    /// referenced by `ptr` has been transferred to this\n-    /// allocator. The memory may or may not have been freed, and\n-    /// should be considered unusable (unless of course it was\n-    /// transferred back to the caller again via the return value of\n-    /// this method).\n-    ///\n-    /// If this method returns `Err`, then ownership of the memory\n-    /// block has not been transferred to this allocator, and the\n-    /// contents of the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must *fit* the `ptr` (see above). (The `new_size`\n-    ///   argument need not fit it.)\n-    ///\n-    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n-    ///\n-    /// (Extension subtraits might provide more specific bounds on\n-    /// behavior, e.g., guarantee a sentinel address or a null pointer\n-    /// in response to a zero-size allocation request.)\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err` only if the new layout\n-    /// does not meet the allocator's size\n-    /// and alignment constraints of the allocator, or if reallocation\n-    /// otherwise fails.\n-    ///\n-    /// Implementations are encouraged to return `Err` on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n-\n-        if new_size > old_size {\n-            if let Ok(size) = self.grow_in_place(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else if new_size < old_size {\n-            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else {\n-            return Ok((ptr, new_size));\n-        }\n-\n-        // otherwise, fall back on alloc + copy + dealloc.\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let result = self.alloc(new_layout);\n-        if let Ok((new_ptr, _)) = result {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n-            self.dealloc(ptr, layout);\n-        }\n-        result\n-    }\n-\n-    /// Behaves like `realloc`, but also ensures that the new contents\n-    /// are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `realloc` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err` only if the new layout\n-    /// does not meet the allocator's size\n-    /// and alignment constraints of the allocator, or if reallocation\n-    /// otherwise fails.\n-    ///\n-    /// Implementations are encouraged to return `Err` on memory\n-    /// exhaustion rather than panicking or aborting, but this is not\n-    /// a strict requirement. (Specifically: it is *legal* to\n-    /// implement this trait atop an underlying native allocation\n-    /// library that aborts on memory exhaustion.)\n-    ///\n-    /// Clients wishing to abort computation in response to a\n-    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n-    /// rather than directly invoking `panic!` or similar.\n-    ///\n-    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n-    unsafe fn realloc_zeroed(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<(NonNull<u8>, usize), AllocErr> {\n-        let old_size = layout.size();\n-\n-        if new_size > old_size {\n-            if let Ok(size) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else if new_size < old_size {\n-            if let Ok(size) = self.shrink_in_place(ptr, layout, new_size) {\n-                return Ok((ptr, size));\n-            }\n-        } else {\n-            return Ok((ptr, new_size));\n-        }\n-\n-        // otherwise, fall back on alloc + copy + dealloc.\n-        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n-        let result = self.alloc_zeroed(new_layout);\n-        if let Ok((new_ptr, _)) = result {\n-            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n-            self.dealloc(ptr, layout);\n-        }\n-        result\n-    }\n-\n-    /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n-    ///\n-    /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_size`, and thus can\n-    /// be used to carry data of a layout of that size and same alignment as\n-    /// `layout`. The returned value is the new size of the allocated block.\n-    /// (The allocator is allowed to expend effort to accomplish this, such\n-    /// as extending the memory block to include successor blocks, or virtual\n-    /// memory tricks.)\n-    ///\n-    /// Regardless of what this method returns, ownership of the\n-    /// memory block referenced by `ptr` has not been transferred, and\n-    /// the contents of the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_size` argument need not fit it,\n-    ///\n-    /// * `new_size` must not be less than `layout.size()`,\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n-    /// unable to assert that the memory block referenced by `ptr`\n-    /// could fit `layout`.\n-    ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n-    /// function; clients are expected either to be able to recover from\n-    /// `grow_in_place` failures without aborting, or to fall back on\n-    /// another reallocation method before resorting to an abort.\n-    #[inline]\n-    unsafe fn grow_in_place(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<usize, CannotReallocInPlace> {\n-        let _ = ptr;\n-        let _ = layout;\n-        let _ = new_size;\n-        Err(CannotReallocInPlace)\n-    }\n-\n-    /// Behaves like `grow_in_place`, but also ensures that the new\n-    /// contents are set to zero before being returned.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe for the same reasons that `grow_in_place` is.\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n-    /// unable to assert that the memory block referenced by `ptr`\n-    /// could fit `layout`.\n-    ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n-    /// function; clients are expected either to be able to recover from\n-    /// `grow_in_place` failures without aborting, or to fall back on\n-    /// another reallocation method before resorting to an abort.\n-    unsafe fn grow_in_place_zeroed(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<usize, CannotReallocInPlace> {\n-        let size = self.grow_in_place(ptr, layout, new_size)?;\n-        ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n-        Ok(size)\n-    }\n-\n-    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n-    ///\n-    /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_size`, and\n-    /// thus can only be used to carry data of that smaller\n-    /// layout. The returned value is the new size the allocated block.\n-    /// (The allocator is allowed to take advantage of this,\n-    /// carving off portions of the block for reuse elsewhere.) The\n-    /// truncated contents of the block within the smaller layout are\n-    /// unaltered, and ownership of block has not been transferred.\n-    ///\n-    /// If this returns `Err`, then the memory block is considered to\n-    /// still represent the original (larger) `layout`. None of the\n-    /// block has been carved off for reuse elsewhere, ownership of\n-    /// the memory block has not been transferred, and the contents of\n-    /// the memory block are unaltered.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function is unsafe because undefined behavior can result\n-    /// if the caller does not ensure all of the following:\n-    ///\n-    /// * `ptr` must be currently allocated via this allocator,\n-    ///\n-    /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_size` argument need not fit it,\n-    ///\n-    /// * `new_size` must not be greater than `layout.size()`,\n-    ///\n-    /// # Errors\n-    ///\n-    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n-    /// unable to assert that the memory block referenced by `ptr`\n-    /// could fit `layout`.\n-    ///\n-    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n-    /// function; clients are expected either to be able to recover from\n-    /// `shrink_in_place` failures without aborting, or to fall back\n-    /// on another reallocation method before resorting to an abort.\n-    #[inline]\n-    unsafe fn shrink_in_place(\n-        &mut self,\n-        ptr: NonNull<u8>,\n-        layout: Layout,\n-        new_size: usize,\n-    ) -> Result<usize, CannotReallocInPlace> {\n-        let _ = ptr;\n-        let _ = layout;\n-        let _ = new_size;\n-        Err(CannotReallocInPlace)\n-    }\n-}"}, {"sha": "147fe696ac02fb2433f1071705f15c6882d0c37f", "filename": "src/libcore/alloc/global.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fglobal.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,198 @@\n+use crate::alloc::Layout;\n+use crate::cmp;\n+use crate::ptr;\n+\n+/// A memory allocator that can be registered as the standard library\u2019s default\n+/// through the `#[global_allocator]` attribute.\n+///\n+/// Some of the methods require that a memory block be *currently\n+/// allocated* via an allocator. This means that:\n+///\n+/// * the starting address for that memory block was previously\n+///   returned by a previous call to an allocation method\n+///   such as `alloc`, and\n+///\n+/// * the memory block has not been subsequently deallocated, where\n+///   blocks are deallocated either by being passed to a deallocation\n+///   method such as `dealloc` or by being\n+///   passed to a reallocation method that returns a non-null pointer.\n+///\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::alloc::{GlobalAlloc, Layout, alloc};\n+/// use std::ptr::null_mut;\n+///\n+/// struct MyAllocator;\n+///\n+/// unsafe impl GlobalAlloc for MyAllocator {\n+///     unsafe fn alloc(&self, _layout: Layout) -> *mut u8 { null_mut() }\n+///     unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n+/// }\n+///\n+/// #[global_allocator]\n+/// static A: MyAllocator = MyAllocator;\n+///\n+/// fn main() {\n+///     unsafe {\n+///         assert!(alloc(Layout::new::<u32>()).is_null())\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Safety\n+///\n+/// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n+/// implementors must ensure that they adhere to these contracts:\n+///\n+/// * It's undefined behavior if global allocators unwind. This restriction may\n+///   be lifted in the future, but currently a panic from any of these\n+///   functions may lead to memory unsafety.\n+///\n+/// * `Layout` queries and calculations in general must be correct. Callers of\n+///   this trait are allowed to rely on the contracts defined on each method,\n+///   and implementors must ensure such contracts remain true.\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+pub unsafe trait GlobalAlloc {\n+    /// Allocate memory as described by the given `layout`.\n+    ///\n+    /// Returns a pointer to newly-allocated memory,\n+    /// or null to indicate allocation failure.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure that `layout` has non-zero size.\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// The allocated block of memory may or may not be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet this allocator's size or alignment constraints.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n+\n+    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must denote a block of memory currently allocated via\n+    ///   this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocate that block of memory,\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n+\n+    /// Behaves like `alloc`, but also ensures that the contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    /// However the allocated block of memory is guaranteed to be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet allocator's size or alignment constraints,\n+    /// just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        let size = layout.size();\n+        let ptr = self.alloc(layout);\n+        if !ptr.is_null() {\n+            ptr::write_bytes(ptr, 0, size);\n+        }\n+        ptr\n+    }\n+\n+    /// Shrink or grow a block of memory to the given `new_size`.\n+    /// The block is described by the given `ptr` pointer and `layout`.\n+    ///\n+    /// If this returns a non-null pointer, then ownership of the memory block\n+    /// referenced by `ptr` has been transferred to this allocator.\n+    /// The memory may or may not have been deallocated,\n+    /// and should be considered unusable (unless of course it was\n+    /// transferred back to the caller again via the return value of\n+    /// this method). The new memory block is allocated with `layout`, but\n+    /// with the `size` updated to `new_size`.\n+    ///\n+    /// If this method returns null, then ownership of the memory\n+    /// block has not been transferred to this allocator, and the\n+    /// contents of the memory block are unaltered.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocate that block of memory,\n+    ///\n+    /// * `new_size` must be greater than zero.\n+    ///\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n+    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g., guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns null if the new layout does not meet the size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let new_ptr = self.alloc(new_layout);\n+        if !new_ptr.is_null() {\n+            ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        new_ptr\n+    }\n+}"}, {"sha": "a09c2387d0de2b597c476ffec8d78e3a568cefde", "filename": "src/libcore/alloc/layout.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Flayout.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965", "patch": "@@ -0,0 +1,374 @@\n+use crate::cmp;\n+use crate::fmt;\n+use crate::mem;\n+use crate::num::NonZeroUsize;\n+use crate::ptr::NonNull;\n+\n+const fn size_align<T>() -> (usize, usize) {\n+    (mem::size_of::<T>(), mem::align_of::<T>())\n+}\n+\n+/// Layout of a block of memory.\n+///\n+/// An instance of `Layout` describes a particular layout of memory.\n+/// You build a `Layout` up as an input to give to an allocator.\n+///\n+/// All layouts have an associated size and a power-of-two alignment.\n+///\n+/// (Note that layouts are *not* required to have non-zero size,\n+/// even though `GlobalAlloc` requires that all memory requests\n+/// be non-zero in size. A caller must either ensure that conditions\n+/// like this are met, use specific allocators with looser\n+/// requirements, or use the more lenient `AllocRef` interface.)\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[lang = \"alloc_layout\"]\n+pub struct Layout {\n+    // size of the requested block of memory, measured in bytes.\n+    size_: usize,\n+\n+    // alignment of the requested block of memory, measured in bytes.\n+    // we ensure that this is always a power-of-two, because API's\n+    // like `posix_memalign` require it and it is a reasonable\n+    // constraint to impose on Layout constructors.\n+    //\n+    // (However, we do not analogously require `align >= sizeof(void*)`,\n+    //  even though that is *also* a requirement of `posix_memalign`.)\n+    align_: NonZeroUsize,\n+}\n+\n+impl Layout {\n+    /// Constructs a `Layout` from a given `size` and `align`,\n+    /// or returns `LayoutErr` if any of the following conditions\n+    /// are not met:\n+    ///\n+    /// * `align` must not be zero,\n+    ///\n+    /// * `align` must be a power of two,\n+    ///\n+    /// * `size`, when rounded up to the nearest multiple of `align`,\n+    ///    must not overflow (i.e., the rounded value must be less than\n+    ///    or equal to `usize::MAX`).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n+        if !align.is_power_of_two() {\n+            return Err(LayoutErr { private: () });\n+        }\n+\n+        // (power-of-two implies align != 0.)\n+\n+        // Rounded up size is:\n+        //   size_rounded_up = (size + align - 1) & !(align - 1);\n+        //\n+        // We know from above that align != 0. If adding (align - 1)\n+        // does not overflow, then rounding up will be fine.\n+        //\n+        // Conversely, &-masking with !(align - 1) will subtract off\n+        // only low-order-bits. Thus if overflow occurs with the sum,\n+        // the &-mask cannot subtract enough to undo that overflow.\n+        //\n+        // Above implies that checking for summation overflow is both\n+        // necessary and sufficient.\n+        if size > usize::MAX - (align - 1) {\n+            return Err(LayoutErr { private: () });\n+        }\n+\n+        // SAFETY: the conditions for `from_size_align_unchecked` have been\n+        // checked above.\n+        unsafe { Ok(Layout::from_size_align_unchecked(size, align)) }\n+    }\n+\n+    /// Creates a layout, bypassing all checks.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe as it does not verify the preconditions from\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[inline]\n+    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n+        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n+    }\n+\n+    /// The minimum size in bytes for a memory block of this layout.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn size(&self) -> usize {\n+        self.size_\n+    }\n+\n+    /// The minimum byte alignment for a memory block of this layout.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn align(&self) -> usize {\n+        self.align_.get()\n+    }\n+\n+    /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[rustc_const_stable(feature = \"alloc_layout_const_new\", since = \"1.42.0\")]\n+    #[inline]\n+    pub const fn new<T>() -> Self {\n+        let (size, align) = size_align::<T>();\n+        // SAFETY: the align is guaranteed by Rust to be a power of two and\n+        // the size+align combo is guaranteed to fit in our address space. As a\n+        // result use the unchecked constructor here to avoid inserting code\n+        // that panics if it isn't optimized well enough.\n+        unsafe { Layout::from_size_align_unchecked(size, align) }\n+    }\n+\n+    /// Produces layout describing a record that could be used to\n+    /// allocate backing structure for `T` (which could be a trait\n+    /// or other unsized type like a slice).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+    #[inline]\n+    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n+        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n+        debug_assert!(Layout::from_size_align(size, align).is_ok());\n+        // SAFETY: see rationale in `new` for why this is using an unsafe variant below\n+        unsafe { Layout::from_size_align_unchecked(size, align) }\n+    }\n+\n+    /// Creates a `NonNull` that is dangling, but well-aligned for this Layout.\n+    ///\n+    /// Note that the pointer value may potentially represent a valid pointer,\n+    /// which means this must not be used as a \"not yet initialized\"\n+    /// sentinel value. Types that lazily allocate must track initialization by\n+    /// some other means.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub const fn dangling(&self) -> NonNull<u8> {\n+        // SAFETY: align is guaranteed to be non-zero\n+        unsafe { NonNull::new_unchecked(self.align() as *mut u8) }\n+    }\n+\n+    /// Creates a layout describing the record that can hold a value\n+    /// of the same layout as `self`, but that also is aligned to\n+    /// alignment `align` (measured in bytes).\n+    ///\n+    /// If `self` already meets the prescribed alignment, then returns\n+    /// `self`.\n+    ///\n+    /// Note that this method does not add any padding to the overall\n+    /// size, regardless of whether the returned layout has a different\n+    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n+    /// will *still* have size 16.\n+    ///\n+    /// Returns an error if the combination of `self.size()` and the given\n+    /// `align` violates the conditions listed in\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[inline]\n+    pub fn align_to(&self, align: usize) -> Result<Self, LayoutErr> {\n+        Layout::from_size_align(self.size(), cmp::max(self.align(), align))\n+    }\n+\n+    /// Returns the amount of padding we must insert after `self`\n+    /// to ensure that the following address will satisfy `align`\n+    /// (measured in bytes).\n+    ///\n+    /// e.g., if `self.size()` is 9, then `self.padding_needed_for(4)`\n+    /// returns 3, because that is the minimum number of bytes of\n+    /// padding required to get a 4-aligned address (assuming that the\n+    /// corresponding memory block starts at a 4-aligned address).\n+    ///\n+    /// The return value of this function has no meaning if `align` is\n+    /// not a power-of-two.\n+    ///\n+    /// Note that the utility of the returned value requires `align`\n+    /// to be less than or equal to the alignment of the starting\n+    /// address for the whole allocated block of memory. One way to\n+    /// satisfy this constraint is to ensure `align <= self.align()`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n+    #[inline]\n+    pub const fn padding_needed_for(&self, align: usize) -> usize {\n+        let len = self.size();\n+\n+        // Rounded up value is:\n+        //   len_rounded_up = (len + align - 1) & !(align - 1);\n+        // and then we return the padding difference: `len_rounded_up - len`.\n+        //\n+        // We use modular arithmetic throughout:\n+        //\n+        // 1. align is guaranteed to be > 0, so align - 1 is always\n+        //    valid.\n+        //\n+        // 2. `len + align - 1` can overflow by at most `align - 1`,\n+        //    so the &-mask with `!(align - 1)` will ensure that in the\n+        //    case of overflow, `len_rounded_up` will itself be 0.\n+        //    Thus the returned padding, when added to `len`, yields 0,\n+        //    which trivially satisfies the alignment `align`.\n+        //\n+        // (Of course, attempts to allocate blocks of memory whose\n+        // size and padding overflow in the above manner should cause\n+        // the allocator to yield an error anyway.)\n+\n+        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n+        len_rounded_up.wrapping_sub(len)\n+    }\n+\n+    /// Creates a layout by rounding the size of this layout up to a multiple\n+    /// of the layout's alignment.\n+    ///\n+    /// This is equivalent to adding the result of `padding_needed_for`\n+    /// to the layout's current size.\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[inline]\n+    pub fn pad_to_align(&self) -> Layout {\n+        let pad = self.padding_needed_for(self.align());\n+        // This cannot overflow. Quoting from the invariant of Layout:\n+        // > `size`, when rounded up to the nearest multiple of `align`,\n+        // > must not overflow (i.e., the rounded value must be less than\n+        // > `usize::MAX`)\n+        let new_size = self.size() + pad;\n+\n+        Layout::from_size_align(new_size, self.align()).unwrap()\n+    }\n+\n+    /// Creates a layout describing the record for `n` instances of\n+    /// `self`, with a suitable amount of padding between each to\n+    /// ensure that each instance is given its requested size and\n+    /// alignment. On success, returns `(k, offs)` where `k` is the\n+    /// layout of the array and `offs` is the distance between the start\n+    /// of each element in the array.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n+        // This cannot overflow. Quoting from the invariant of Layout:\n+        // > `size`, when rounded up to the nearest multiple of `align`,\n+        // > must not overflow (i.e., the rounded value must be less than\n+        // > `usize::MAX`)\n+        let padded_size = self.size() + self.padding_needed_for(self.align());\n+        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutErr { private: () })?;\n+\n+        // SAFETY: self.align is already known to be valid and alloc_size has been\n+        // padded already.\n+        unsafe { Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size)) }\n+    }\n+\n+    /// Creates a layout describing the record for `self` followed by\n+    /// `next`, including any necessary padding to ensure that `next`\n+    /// will be properly aligned, but *no trailing padding*.\n+    ///\n+    /// In order to match C representation layout `repr(C)`, you should\n+    /// call `pad_to_align` after extending the layout with all fields.\n+    /// (There is no way to match the default Rust representation\n+    /// layout `repr(Rust)`, as it is unspecified.)\n+    ///\n+    /// Note that the alignment of the resulting layout will be the maximum of\n+    /// those of `self` and `next`, in order to ensure alignment of both parts.\n+    ///\n+    /// Returns `Ok((k, offset))`, where `k` is layout of the concatenated\n+    /// record and `offset` is the relative location, in bytes, of the\n+    /// start of the `next` embedded within the concatenated record\n+    /// (assuming that the record itself starts at offset 0).\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// To calculate the layout of a `#[repr(C)]` structure and the offsets of\n+    /// the fields from its fields' layouts:\n+    ///\n+    /// ```rust\n+    /// # use std::alloc::{Layout, LayoutErr};\n+    /// pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutErr> {\n+    ///     let mut offsets = Vec::new();\n+    ///     let mut layout = Layout::from_size_align(0, 1)?;\n+    ///     for &field in fields {\n+    ///         let (new_layout, offset) = layout.extend(field)?;\n+    ///         layout = new_layout;\n+    ///         offsets.push(offset);\n+    ///     }\n+    ///     // Remember to finalize with `pad_to_align`!\n+    ///     Ok((layout.pad_to_align(), offsets))\n+    /// }\n+    /// # // test that it works\n+    /// # #[repr(C)] struct S { a: u64, b: u32, c: u16, d: u32 }\n+    /// # let s = Layout::new::<S>();\n+    /// # let u16 = Layout::new::<u16>();\n+    /// # let u32 = Layout::new::<u32>();\n+    /// # let u64 = Layout::new::<u64>();\n+    /// # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n+    /// ```\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[inline]\n+    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n+        let new_align = cmp::max(self.align(), next.align());\n+        let pad = self.padding_needed_for(next.align());\n+\n+        let offset = self.size().checked_add(pad).ok_or(LayoutErr { private: () })?;\n+        let new_size = offset.checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n+\n+        let layout = Layout::from_size_align(new_size, new_align)?;\n+        Ok((layout, offset))\n+    }\n+\n+    /// Creates a layout describing the record for `n` instances of\n+    /// `self`, with no padding between each instance.\n+    ///\n+    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n+    /// that the repeated instances of `self` will be properly\n+    /// aligned, even if a given instance of `self` is properly\n+    /// aligned. In other words, if the layout returned by\n+    /// `repeat_packed` is used to allocate an array, it is not\n+    /// guaranteed that all elements in the array will be properly\n+    /// aligned.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n+        let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n+        Layout::from_size_align(size, self.align())\n+    }\n+\n+    /// Creates a layout describing the record for `self` followed by\n+    /// `next` with no additional padding between the two. Since no\n+    /// padding is inserted, the alignment of `next` is irrelevant,\n+    /// and is not incorporated *at all* into the resulting layout.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"alloc_layout_extra\", issue = \"55724\")]\n+    #[inline]\n+    pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutErr> {\n+        let new_size = self.size().checked_add(next.size()).ok_or(LayoutErr { private: () })?;\n+        Layout::from_size_align(new_size, self.align())\n+    }\n+\n+    /// Creates a layout describing the record for a `[T; n]`.\n+    ///\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[stable(feature = \"alloc_layout_manipulation\", since = \"1.44.0\")]\n+    #[inline]\n+    pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n+        let (layout, offset) = Layout::new::<T>().repeat(n)?;\n+        debug_assert_eq!(offset, mem::size_of::<T>());\n+        Ok(layout.pad_to_align())\n+    }\n+}\n+\n+/// The parameters given to `Layout::from_size_align`\n+/// or some other `Layout` constructor\n+/// do not satisfy its documented constraints.\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct LayoutErr {\n+    private: (),\n+}\n+\n+// (we need this for downstream impl of trait Error)\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n+impl fmt::Display for LayoutErr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"invalid parameters to Layout::from_size_align\")\n+    }\n+}"}, {"sha": "1346fbd4810038caf3064f5dd19f9dfcc90aebe2", "filename": "src/libcore/alloc/mod.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "79b6304958d51332af85ff9987ba5c8740feb385", "filename": "src/libcore/any.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "f6b8d4ba081467647534044fe3dbbfe4428f4d3d", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "549228ffffaa4d832ae1c92d750cf7665d6513a9", "filename": "src/libcore/array/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "305baa68729eb2a2fb512cac2a98b6bc7b33dd4b", "filename": "src/libcore/benches/num/dec2flt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fdec2flt%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "a1ce33d0bb49ef90f8f065874273e4cda9f39a3e", "filename": "src/libcore/benches/num/flt2dec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "4e1fd8bf753cad249414eaa1d2acc32ff202c864", "filename": "src/libcore/benches/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "77ca901a90af39890588491cf122386eca0c763c", "filename": "src/libcore/benches/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "fad3095f8a3fcd4b4fe1128516aba2afb198781f", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "5c5bc9adb5df29fbed1e0338cfbea2ba3e26764d", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 241, "deletions": 2, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "bf65c31e135975826e856cbbe6a41f02783fd403", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "7784ec687ea9a9378ad2cca7770b62e148fb99d7", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "9856efc6bd8a48c080048465d2f81b833363be65", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "eef9ee7cb0093d811e92c6d3f5b9034e6ffc83e8", "filename": "src/libcore/convert/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "6dd0522f7f610bae1e3839045fb779031ee2055a", "filename": "src/libcore/convert/num.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert%2Fnum.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "06402a05d2687e29319a00e7c5ddb240462d6d6c", "filename": "src/libcore/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "7bc2866dc2e6756eda3eaf9c2c18f2d8c41c32a1", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "95411b525d0db3934f1dd40d703be0c505455f83", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "b5a102916a07ebc970bb47f3264d4567d399c0ba", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "74887b68aa0fadf95eaa9b7504f2ffdd3ae51c5c", "filename": "src/libcore/future/pending.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffuture%2Fpending.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffuture%2Fpending.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fpending.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "31b39d7fb6cd5c8f7b0096c83855e9b6e0c695d0", "filename": "src/libcore/future/ready.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffuture%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ffuture%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fready.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "d80101753cbef4b554c1a536fcebd4a47523d2c7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "ac058609f45ed34ef6b6006581104bf0e34a7a0d", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "0d794de5fe84b3233d904382b15959203c126b33", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "9006e4cfaf7bbc0e70bb5a2dd6cf1ea901a51075", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 229, "deletions": 156, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "6700ef017bde43922f51411083d3f99d4b9ce134", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 125, "deletions": 154, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "502fc2e631502a2c5637a482c746a6ab95b58b05", "filename": "src/libcore/iter/adapters/fuse.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Ffuse.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "195847ee98dc4755944db419326f636e743961da", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 137, "deletions": 247, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "e83d36a580f06464022d3b0b51bb0f2c9f64f142", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "388a5548a31a5e0f0adeb8440822619d6d36faa5", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 440, "deletions": 173, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "d76fa89bd012c22f4167b25e336a4aa917d321f0", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "cceb373d552a86ba682c5f63121bf6496979f2fa", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "1c3d95cbb8c3504f9e5b47d52ebbe809980ea18f", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 67, "deletions": 36, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "a9ba3908c38982a1e4014e0bf6efb09e4c068456", "filename": "src/libcore/iter/traits/marker.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmarker.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "3b7929f00168ad0c5bcf2a16754b1172bd490e39", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "625ceb0953b0a9404d940a3726f8f15568bde154", "filename": "src/libcore/macros/mod.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "c0c0f66aff90867f68b72cf073b120bb4bc8cb5d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "18767c482c77ea47cd863685db33ee1110ffe1dc", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "f7ea7eba7b16b9ff712c7a4fb70ac4600917162d", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "010f2958e36b9ecd940b9ab4493762e5f589852e", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "aaeb4d8a22c297eee22fb9514d1fe85ee60e6ad6", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "2766843155a0e7fb2c52622f81017ff29362ad4a", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "434569020d2a8b1b00cdfce94c6648113d0af2d8", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 158, "deletions": 17, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "6476ddb4541ff8900952247be05e5082c3ba94e3", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 160, "deletions": 19, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "c43536c6fcca86585db29821f1772c2f3fbc94dc", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "9bf56e93d896f1d96db0c7de7b6e0053ea62b1e6", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "ffd30b03f2109c677692713e06c203351aa89b09", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "c164e893b4fbf295dd165a2e4e4a71878cc9b6cd", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 169, "deletions": 17, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "622a138abe9d19cae5ff0945563469b166a1da82", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "6e96aa330ff1930f85958f54b4ea3d52d95dd09a", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "06cfc36363615ee56515bcb64e439bea37676484", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 98, "deletions": 44, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "763b33606fe88b18c044359c74dec2c3bf6172e1", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "d4e6048579a56fa74eeba5c025c9c27879b7fdce", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "e8483875c97e5b87eebea50b5b4bd253ab6914d5", "filename": "src/libcore/option.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "1ffd493d8130ba677c939f7da69e614fc9721266", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "16739b4a1afdf9628f12a713bb0a7b95acfe01a0", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "b4fff3d67b555b0bf109b5f94c5277208eeda578", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "85ba5fc0638ea18fc84e80df6b152257ebfa07a2", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "ecc70adda4111c764bb084f1bcab5bc907a772b2", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "0781d7e6cac452c63a4d7376ce73b4c07ec08848", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "7d08503215ed022bfb1920d791d9855ac1665d79", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "f58d35f06137d4ea870403a42cc7cb41ad21bfd1", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "cb0fb8795e581edbd5dd7c6acdae66e4758e65f1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "c7b5777a16e7f7459c8d89f4f9b3b5a5f3d1f3ee", "filename": "src/libcore/result.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "3b13ed5fed396918ac7ab575eb6e17ba3a3ab54b", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "9582ac33ff6b78ac9387d9ee6347c58e34a1a19d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 154, "deletions": 36, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "be3e7aaa2e89a678fbd297d70a3b67874b65817e", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "c517286d49898ab824872b90c40f8cfed323b6b9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 133, "deletions": 75, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "1a2b612b2f95c531787802548b8e31f28a9fd1db", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 150, "deletions": 6, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "275a1d062cafbb06d8c1c9186ae1d01728465918", "filename": "src/libcore/tests/fmt/num.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fnum.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "52cf068f0a56720c362035ff494b6453fb35c51f", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 156, "deletions": 82, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "6a8e908b9c6183b58285e95a69bd6808223f46c9", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "0227a66b8633a704137287e33ca8486b01dcade7", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "1c172f49c279c726fc73a69968ec5fdf6fd1521e", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "c098b9c2ba27ddf1618fe74d97f1b8913e12ef62", "filename": "src/libcore/tests/num/dec2flt/rawfp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Frawfp.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "da203b5f3620ef7606115ebf7bfe1a3a6bba02b4", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "ae892e3b0bfbfb7bec345fb7d3b82c1df3c38bf0", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "0ebc0881f5223870ec8b546c302adb0aa9c9c30c", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "8396a0dd62db91ad3fdb3c8f0ffcc30264d8d67a", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "181bbb8e18784c3515d03f2d6b58d576a222c400", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "3c83f0f2300038ca4a4ddf5a1204f256e63193af", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "54a585415bce2b512a93a3d52ff85052d242b816", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "7a6675dc82fa6ef70e9f526c206c100cb95f9ee4", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "ea1e281425c8904b02c1266809e769e289678f54", "filename": "src/libcore/tests/tuple.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftests%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftuple.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "ed1d5d46db5c4c02c7b793f3ad240edb9f68d007", "filename": "src/libcore/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "28c07f7717046599a1e9db0153ddfe7355ff565d", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "9c92a8ba28ae4f707d3287d5c30d9d09d60d4dd6", "filename": "src/libcore/unicode/unicode_data.rs", "status": "modified", "additions": 444, "deletions": 515, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Funicode%2Funicode_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibcore%2Funicode%2Funicode_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode_data.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "4d68d2e8c2ef784907507485c590292870c3e29f", "filename": "src/libcore/unicode/version.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibcore%2Funicode%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibcore%2Funicode%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fversion.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "677c027f17b54c65480db41e57d50c5132730931", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 154, "deletions": 4, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "9932c1df7a935c4ef8fe89879878d819853d117c", "filename": "src/libfmt_macros/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "fd3e11858cef67719f1acb85a8d217d670573e0a", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "f5d83c21da0684170d40bd13eb85669dda70fb86", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "f791fe82a27e7dcf7182111f50f0eda14ee53a8f", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "b1e87a7cac26a5313a7fc371c19032c052daaedb", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "283aa25b0ea13e1603903972505699c560f4d89a", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "bf0d8fcee5b8f4cd31b9fe908f0316874c2a7792", "filename": "src/libproc_macro/bridge/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fmod.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "f11401b5a0c7c2afc2558d4d9c833de4022fbd77", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "e23e2f2c1306f6a4caece4226eba825a4b9bbd63", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6127e3fde9e8d24388847ad1b442a4337f19965/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=a6127e3fde9e8d24388847ad1b442a4337f19965"}, {"sha": "47b94a2f1a4b49947eef67613ecdd6a3de4cb3a1", "filename": "src/librustc/Cargo.toml", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "57c1e5521a9d9044128d8582f547dc35d01d5a26", "filename": "src/librustc/arena.rs", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "3c39597584df50cffbde05897ee6f38ce58c4b06", "filename": "src/librustc/dep_graph/mod.rs", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "47a1c09672ff60aad8fa8c5f84b788d0e34b1b02", "filename": "src/librustc/dep_graph/safe.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "7024e86f95d06a169dabcd2675c3cad5d6b7cb03", "filename": "src/librustc/hir/map/blocks.rs", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "eb8e57743b8f81c5ad984b4904f535ec67c94887", "filename": "src/librustc/hir/map/mod.rs", "status": "removed", "additions": 0, "deletions": 1168, "changes": 1168, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "ce8e1f48daa77dcf5c0e925b90e743c3a7dca14b", "filename": "src/librustc/hir/mod.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}, {"sha": "2c4618dcd42cfbdf98fac87c345cfddbdbc848c4", "filename": "src/librustc/ich/mod.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/374ab25585f0a817fe7bd6986737f12347b12d0b/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=374ab25585f0a817fe7bd6986737f12347b12d0b"}]}