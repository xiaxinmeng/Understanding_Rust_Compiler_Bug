{"sha": "ce8d4a21348c6185e7df2817a80910f86e9db205", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOGQ0YTIxMzQ4YzYxODVlN2RmMjgxN2E4MDkxMGY4NmU5ZGIyMDU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-07T19:35:11Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-11T17:51:45Z"}, "message": "trans: initial implementation of MIR debuginfo.", "tree": {"sha": "84b99d964a9a868e75641251e358e3db2ffa1561", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84b99d964a9a868e75641251e358e3db2ffa1561"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce8d4a21348c6185e7df2817a80910f86e9db205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce8d4a21348c6185e7df2817a80910f86e9db205", "html_url": "https://github.com/rust-lang/rust/commit/ce8d4a21348c6185e7df2817a80910f86e9db205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce8d4a21348c6185e7df2817a80910f86e9db205/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f680c623d4bcc30772f4eed400631128ffedda05", "url": "https://api.github.com/repos/rust-lang/rust/commits/f680c623d4bcc30772f4eed400631128ffedda05", "html_url": "https://github.com/rust-lang/rust/commit/f680c623d4bcc30772f4eed400631128ffedda05"}], "stats": {"total": 412, "additions": 289, "deletions": 123}, "files": [{"sha": "464e5c0cf1c1d6823d7ea565c3e8e7ce17242122", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -1276,7 +1276,7 @@ pub fn alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n     }\n-    debuginfo::clear_source_location(cx.fcx);\n+    DebugLoc::None.apply(cx.fcx);\n     Alloca(cx, ty, name)\n }\n \n@@ -1739,7 +1739,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         self.build_return_block(ret_cx, ret_debug_loc);\n \n-        debuginfo::clear_source_location(self);\n+        DebugLoc::None.apply(self);\n         self.cleanup();\n     }\n "}, {"sha": "f793f0a6d553ba8ec1326a3e3cbdf33348356e35", "filename": "src/librustc_trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontrolflow.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -167,11 +167,11 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         if cv == 1 {\n             // if true { .. } [else { .. }]\n             bcx = trans_block(bcx, &thn, dest);\n-            debuginfo::clear_source_location(bcx.fcx);\n+            DebugLoc::None.apply(bcx.fcx);\n         } else {\n             if let Some(elexpr) = els {\n                 bcx = expr::trans_into(bcx, &elexpr, dest);\n-                debuginfo::clear_source_location(bcx.fcx);\n+                DebugLoc::None.apply(bcx.fcx);\n             }\n         }\n \n@@ -181,7 +181,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let name = format!(\"then-block-{}-\", thn.id);\n     let then_bcx_in = bcx.fcx.new_id_block(&name[..], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &thn, dest);\n-    debuginfo::clear_source_location(bcx.fcx);\n+    DebugLoc::None.apply(bcx.fcx);\n \n     let cond_source_loc = cond.debug_loc();\n \n@@ -204,7 +204,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Clear the source location because it is still set to whatever has been translated\n     // right before.\n-    debuginfo::clear_source_location(next_bcx.fcx);\n+    DebugLoc::None.apply(next_bcx.fcx);\n \n     next_bcx\n }"}, {"sha": "3eebd1f5ea25a0bbafa49ad23dbcc9b06e8bc364", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 77, "deletions": 4, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -8,19 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::FunctionDebugContext;\n use super::metadata::file_metadata;\n-use super::utils::DIB;\n+use super::utils::{DIB, span_start};\n \n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n-use common::CrateContext;\n+use common::{CrateContext, FunctionContext};\n use rustc::hir::pat_util;\n+use rustc::mir::repr::{Mir, ScopeId};\n use rustc::util::nodemap::NodeMap;\n \n use libc::c_uint;\n+use std::ptr;\n+\n use syntax::codemap::{Span, Pos};\n use syntax::{ast, codemap};\n \n+use rustc_data_structures::bitvec::BitVector;\n use rustc::hir::{self, PatKind};\n \n // This procedure builds the *scope map* for a given function, which maps any\n@@ -65,6 +70,74 @@ pub fn create_scope_map(cx: &CrateContext,\n     return scope_map;\n }\n \n+/// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n+/// If debuginfo is disabled, the returned vector is empty.\n+pub fn create_mir_scopes(fcx: &FunctionContext) -> Vec<DIScope> {\n+    let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n+    let mut scopes = vec![ptr::null_mut(); mir.scopes.len()];\n+\n+    let fn_metadata = match fcx.debug_context {\n+        FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n+        FunctionDebugContext::DebugInfoDisabled |\n+        FunctionDebugContext::FunctionWithoutDebugInfo => {\n+            return scopes;\n+        }\n+    };\n+\n+    // Find all the scopes with variables defined in them.\n+    let mut has_variables = BitVector::new(mir.scopes.len());\n+    for var in &mir.var_decls {\n+        has_variables.insert(var.scope.index());\n+    }\n+\n+    // Instantiate all scopes.\n+    for idx in 0..mir.scopes.len() {\n+        let scope = ScopeId::new(idx);\n+        make_mir_scope(fcx.ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n+    }\n+\n+    scopes\n+}\n+\n+fn make_mir_scope(ccx: &CrateContext,\n+                  mir: &Mir,\n+                  has_variables: &BitVector,\n+                  fn_metadata: DISubprogram,\n+                  scope: ScopeId,\n+                  scopes: &mut [DIScope]) {\n+    let idx = scope.index();\n+    if !scopes[idx].is_null() {\n+        return;\n+    }\n+\n+    let scope_data = &mir.scopes[scope];\n+    let parent_scope = if let Some(parent) = scope_data.parent_scope {\n+        make_mir_scope(ccx, mir, has_variables, fn_metadata, parent, scopes);\n+        scopes[parent.index()]\n+    } else {\n+        // The root is the function itself.\n+        scopes[idx] = fn_metadata;\n+        return;\n+    };\n+\n+    scopes[idx] = if !has_variables.contains(idx) {\n+        // Do not create a DIScope if there are no variables\n+        // defined in this MIR Scope, to avoid debuginfo bloat.\n+        parent_scope\n+    } else {\n+        let loc = span_start(ccx, scope_data.span);\n+        let file_metadata = file_metadata(ccx, &loc.file.name);\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateLexicalBlock(\n+                DIB(ccx),\n+                parent_scope,\n+                file_metadata,\n+                loc.line as c_uint,\n+                loc.col.to_usize() as c_uint)\n+        }\n+    };\n+}\n+\n // local helper functions for walking the AST.\n fn with_new_scope<F>(cx: &CrateContext,\n                      scope_span: Span,\n@@ -74,7 +147,7 @@ fn with_new_scope<F>(cx: &CrateContext,\n     F: FnOnce(&CrateContext, &mut Vec<ScopeStackEntry>, &mut NodeMap<DIScope>),\n {\n     // Create a new lexical scope and push it onto the stack\n-    let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n+    let loc = span_start(cx, scope_span);\n     let file_metadata = file_metadata(cx, &loc.file.name);\n     let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n@@ -199,7 +272,7 @@ fn walk_pattern(cx: &CrateContext,\n \n                 if need_new_scope {\n                     // Create a new lexical scope and push it onto the stack\n-                    let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n+                    let loc = span_start(cx, pat.span);\n                     let file_metadata = file_metadata(cx, &loc.file.name);\n                     let parent_scope = scope_stack.last().unwrap().scope_metadata;\n "}, {"sha": "371f6b5efaa94ac72af1204f9aadb8a329537c12", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -20,7 +20,7 @@ use self::namespace::mangled_name_of_item;\n use self::type_names::compute_debuginfo_type_name;\n use self::metadata::{type_metadata, diverging_type_metadata};\n use self::metadata::{file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n-use self::source_loc::InternalDebugLocation;\n+use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n@@ -32,7 +32,7 @@ use rustc::ty::subst::Substs;\n use rustc::hir;\n \n use abi::Abi;\n-use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n+use common::{NodeIdAndSpan, CrateContext, FunctionContext, Block, BlockAndBuilder};\n use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n@@ -55,8 +55,7 @@ mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n-pub use self::source_loc::set_source_location;\n-pub use self::source_loc::clear_source_location;\n+pub use self::create_scope_map::create_mir_scopes;\n pub use self::source_loc::start_emitting_source_locations;\n pub use self::source_loc::get_cleanup_debug_loc_for_ast_node;\n pub use self::source_loc::with_source_location_override;\n@@ -218,7 +217,7 @@ pub fn empty_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>)\n     }\n \n     // Clear the debug location so we don't assign them in the function prelude.\n-    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+    source_loc::set_debug_location(cx, None, UnknownLocation);\n     FunctionDebugContext::FunctionWithoutDebugInfo\n }\n \n@@ -239,7 +238,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // Clear the debug location so we don't assign them in the function prelude.\n     // Do this here already, in case we do an early exit from this function.\n-    source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+    source_loc::set_debug_location(cx, None, UnknownLocation);\n \n     // This can be the case for functions inlined from another crate\n     let (containing_scope, span) = get_namespace_and_span_for_item(cx, instance.def);\n@@ -425,13 +424,13 @@ pub fn fill_scope_map_for_function<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n     }\n }\n \n-fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             variable_name: ast::Name,\n-                             variable_type: Ty<'tcx>,\n-                             scope_metadata: DIScope,\n-                             variable_access: VariableAccess,\n-                             variable_kind: VariableKind,\n-                             span: Span) {\n+pub fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                 variable_name: ast::Name,\n+                                 variable_type: Ty<'tcx>,\n+                                 scope_metadata: DIScope,\n+                                 variable_access: VariableAccess,\n+                                 variable_kind: VariableKind,\n+                                 span: Span) {\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n@@ -465,9 +464,8 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     address_operations.len() as c_uint,\n                     argument_index)\n             };\n-            source_loc::set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n-                                                                          loc.line,\n-                                                                          loc.col.to_usize()));\n+            source_loc::set_debug_location(cx, None,\n+                InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()));\n             unsafe {\n                 let debug_loc = llvm::LLVMGetCurrentDebugLocation(cx.raw_builder());\n                 let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n@@ -491,7 +489,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         .get_ref(span)\n                         .source_locations_enabled\n                         .get());\n-            source_loc::set_debug_location(cx, InternalDebugLocation::UnknownLocation);\n+            source_loc::set_debug_location(cx, None, UnknownLocation);\n         }\n         _ => { /* nothing to do */ }\n     }\n@@ -500,19 +498,17 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DebugLoc {\n     At(ast::NodeId, Span),\n+    ScopeAt(DIScope, Span),\n     None\n }\n \n impl DebugLoc {\n-    pub fn apply(&self, fcx: &FunctionContext) {\n-        match *self {\n-            DebugLoc::At(node_id, span) => {\n-                source_loc::set_source_location(fcx, node_id, span);\n-            }\n-            DebugLoc::None => {\n-                source_loc::clear_source_location(fcx);\n-            }\n-        }\n+    pub fn apply(self, fcx: &FunctionContext) {\n+        source_loc::set_source_location(fcx, None, self);\n+    }\n+\n+    pub fn apply_to_bcx(self, bcx: &BlockAndBuilder) {\n+        source_loc::set_source_location(bcx.fcx(), Some(bcx), self);\n     }\n }\n "}, {"sha": "6b00c1bb1a85582b39484ffdab05b8121c3ae0a6", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -10,12 +10,13 @@\n \n use self::InternalDebugLocation::*;\n \n-use super::utils::{debug_context, span_start, fn_should_be_ignored};\n+use super::utils::{debug_context, span_start};\n use super::metadata::{scope_metadata,UNKNOWN_COLUMN_NUMBER};\n use super::{FunctionDebugContext, DebugLoc};\n \n use llvm;\n use llvm::debuginfo::DIScope;\n+use builder::Builder;\n use common::{NodeIdAndSpan, CrateContext, FunctionContext};\n \n use libc::c_uint;\n@@ -86,41 +87,46 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n /// Sets the current debug location at the beginning of the span.\n ///\n-/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n-/// parameter is used to reliably find the correct visibility scope for the code\n-/// position.\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n pub fn set_source_location(fcx: &FunctionContext,\n-                           node_id: ast::NodeId,\n-                           span: Span) {\n-    match fcx.debug_context {\n+                           builder: Option<&Builder>,\n+                           debug_loc: DebugLoc) {\n+    let builder = builder.map(|b| b.llbuilder);\n+    let function_debug_context = match fcx.debug_context {\n         FunctionDebugContext::DebugInfoDisabled => return,\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, UnknownLocation);\n+            set_debug_location(fcx.ccx, builder, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n-            if function_debug_context.source_location_override.get() {\n-                // Just ignore any attempts to set a new debug location while\n-                // the override is active.\n-                return;\n-            }\n-\n-            let cx = fcx.ccx;\n-\n-            debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n+        FunctionDebugContext::RegularContext(box ref data) => data\n+    };\n \n-            if function_debug_context.source_locations_enabled.get() {\n-                let loc = span_start(cx, span);\n-                let scope = scope_metadata(fcx, node_id, span);\n+    if function_debug_context.source_location_override.get() {\n+        // Just ignore any attempts to set a new debug location while\n+        // the override is active.\n+        return;\n+    }\n \n-                set_debug_location(cx, InternalDebugLocation::new(scope,\n-                                                                  loc.line,\n-                                                                  loc.col.to_usize()));\n-            } else {\n-                set_debug_location(cx, UnknownLocation);\n+    let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n+        let (scope, span) = match debug_loc {\n+            DebugLoc::At(node_id, span) => {\n+                (scope_metadata(fcx, node_id, span), span)\n             }\n-        }\n-    }\n+            DebugLoc::ScopeAt(scope, span) => (scope, span),\n+            DebugLoc::None => {\n+                set_debug_location(fcx.ccx, builder, UnknownLocation);\n+                return;\n+            }\n+        };\n+\n+        debug!(\"set_source_location: {}\",\n+               fcx.ccx.sess().codemap().span_to_string(span));\n+        let loc = span_start(fcx.ccx, span);\n+        InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n+    } else {\n+        UnknownLocation\n+    };\n+    set_debug_location(fcx.ccx, builder, dbg_loc);\n }\n \n /// This function makes sure that all debug locations emitted while executing\n@@ -135,7 +141,7 @@ pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n             wrapped_function()\n         }\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, UnknownLocation);\n+            set_debug_location(fcx.ccx, None, UnknownLocation);\n             wrapped_function()\n         }\n         FunctionDebugContext::RegularContext(box ref function_debug_context) => {\n@@ -152,17 +158,6 @@ pub fn with_source_location_override<F, R>(fcx: &FunctionContext,\n     }\n }\n \n-/// Clears the current debug location.\n-///\n-/// Instructions generated hereafter won't be assigned a source location.\n-pub fn clear_source_location(fcx: &FunctionContext) {\n-    if fn_should_be_ignored(fcx) {\n-        return;\n-    }\n-\n-    set_debug_location(fcx.ccx, UnknownLocation);\n-}\n-\n /// Enables emitting source locations for the given functions.\n ///\n /// Since we don't want source locations to be emitted for the function prelude,\n@@ -195,37 +190,42 @@ impl InternalDebugLocation {\n     }\n }\n \n-pub fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n-    if debug_location == debug_context(cx).current_debug_location.get() {\n-        return;\n+pub fn set_debug_location(cx: &CrateContext,\n+                          builder: Option<llvm::BuilderRef>,\n+                          debug_location: InternalDebugLocation) {\n+    if builder.is_none() {\n+        if debug_location == debug_context(cx).current_debug_location.get() {\n+            return;\n+        }\n     }\n \n-    let metadata_node;\n-\n-    match debug_location {\n+    let metadata_node = match debug_location {\n         KnownLocation { scope, line, .. } => {\n             // Always set the column to zero like Clang and GCC\n             let col = UNKNOWN_COLUMN_NUMBER;\n             debug!(\"setting debug location to {} {}\", line, col);\n \n             unsafe {\n-                metadata_node = llvm::LLVMDIBuilderCreateDebugLocation(\n+                llvm::LLVMDIBuilderCreateDebugLocation(\n                     debug_context(cx).llcontext,\n                     line as c_uint,\n                     col as c_uint,\n                     scope,\n-                    ptr::null_mut());\n+                    ptr::null_mut())\n             }\n         }\n         UnknownLocation => {\n             debug!(\"clearing debug location \");\n-            metadata_node = ptr::null_mut();\n+            ptr::null_mut()\n         }\n     };\n \n-    unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(cx.raw_builder(), metadata_node);\n+    if builder.is_none() {\n+        debug_context(cx).current_debug_location.set(debug_location);\n     }\n \n-    debug_context(cx).current_debug_location.set(debug_location);\n+    let builder = builder.unwrap_or_else(|| cx.raw_builder());\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(builder, metadata_node);\n+    }\n }"}, {"sha": "6955d51ceccafb3b8e40ab74928701e20dadcc5d", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -115,7 +115,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     if adjustment_required(bcx, expr) {\n         // use trans, which may be less efficient but\n@@ -587,7 +587,7 @@ fn trans_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_unadjusted(expr={:?})\", expr);\n     let _indenter = indenter();\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     return match expr_kind(bcx.tcx(), expr) {\n         ExprKind::Lvalue | ExprKind::RvalueDatum => {\n@@ -923,7 +923,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return bcx;\n     }\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     match expr.node {\n         hir::ExprBreak(label_opt) => {\n@@ -987,7 +987,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 //\n                 // We could avoid this intermediary with some analysis\n                 // to determine whether `dst` may possibly own `src`.\n-                debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+                expr.debug_loc().apply(bcx.fcx);\n                 let src_datum = unpack_datum!(\n                     bcx, src_datum.to_rvalue_datum(bcx, \"ExprAssign\"));\n                 let opt_hint_datum = dst_datum.kind.drop_flag_info.hint_datum(bcx);\n@@ -1062,7 +1062,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let mut bcx = bcx;\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+    expr.debug_loc().apply(bcx.fcx);\n \n     // Entry into the method table if this is an overloaded call/op.\n     let method_call = MethodCall::expr(expr.id);"}, {"sha": "d79320462430cceaa196843391427462a1b64bae", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -195,8 +195,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let name = tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n-        DebugLoc::At(_, span) => span,\n-        DebugLoc::None => fcx.span.unwrap_or(DUMMY_SP)\n+        DebugLoc::At(_, span) | DebugLoc::ScopeAt(_, span) => span,\n+        DebugLoc::None => {\n+            span_bug!(fcx.span.unwrap_or(DUMMY_SP),\n+                      \"intrinsic `{}` called with missing span\", name);\n+        }\n     };\n \n     let cleanup_scope = fcx.push_custom_cleanup_scope();"}, {"sha": "f70dc0183fdf199fcbf5d06d95c1524d6eb8bff9", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -54,9 +54,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             bcx = self.trans_statement(bcx, statement);\n         }\n \n-        debug!(\"trans_block: terminator: {:?}\", data.terminator());\n-\n-        match data.terminator().kind {\n+        let terminator = data.terminator();\n+        debug!(\"trans_block: terminator: {:?}\", terminator);\n+\n+        let debug_loc = DebugLoc::ScopeAt(self.scopes[terminator.scope.index()],\n+                                          terminator.span);\n+        debug_loc.apply_to_bcx(&bcx);\n+        debug_loc.apply(bcx.fcx());\n+        match terminator.kind {\n             mir::TerminatorKind::Resume => {\n                 if let Some(cleanup_pad) = cleanup_pad {\n                     bcx.cleanup_ret(cleanup_pad, None);\n@@ -117,7 +122,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::TerminatorKind::Return => {\n                 bcx.with_block(|bcx| {\n-                    self.fcx.build_return_block(bcx, DebugLoc::None);\n+                    self.fcx.build_return_block(bcx, debug_loc);\n                 })\n             }\n \n@@ -144,7 +149,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                self.llblock(target),\n                                unwind.llbb(),\n                                cleanup_bundle.as_ref());\n-                    self.bcx(target).at_start(|bcx| drop::drop_fill(bcx, lvalue.llval, ty));\n+                    self.bcx(target).at_start(|bcx| {\n+                        debug_loc.apply_to_bcx(bcx);\n+                        drop::drop_fill(bcx, lvalue.llval, ty)\n+                    });\n                 } else {\n                     bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref());\n                     drop::drop_fill(&bcx, lvalue.llval, ty);\n@@ -267,7 +275,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         bcx.with_block(|bcx| {\n                             trans_intrinsic_call(bcx, callee.ty, &fn_ty,\n                                                            ArgVals(llargs), dest,\n-                                                           DebugLoc::None);\n+                                                           debug_loc);\n                         });\n \n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -311,13 +319,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                cleanup_bundle.as_ref());\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n-                    landingpad.at_start(|bcx| for op in args {\n-                        self.set_operand_dropped(bcx, op);\n+                    landingpad.at_start(|bcx| {\n+                        debug_loc.apply_to_bcx(bcx);\n+                        for op in args {\n+                            self.set_operand_dropped(bcx, op);\n+                        }\n                     });\n \n                     if destination.is_some() {\n                         let ret_bcx = ret_bcx.build();\n                         ret_bcx.at_start(|ret_bcx| {\n+                            debug_loc.apply_to_bcx(ret_bcx);\n                             let op = OperandRef {\n                                 val: OperandValue::Immediate(invokeret),\n                                 ty: sig.output.unwrap()\n@@ -514,7 +526,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let use_funclets = base::wants_msvc_seh(bcx.sess()) && data.is_cleanup;\n         let cleanup_pad = if use_funclets {\n             bcx.set_personality_fn(self.fcx.eh_personality());\n-            bcx.at_start(|bcx| Some(bcx.cleanup_pad(None, &[])))\n+            bcx.at_start(|bcx| {\n+                DebugLoc::None.apply_to_bcx(bcx);\n+                Some(bcx.cleanup_pad(None, &[]))\n+            })\n         } else {\n             None\n         };"}, {"sha": "1869845ccb1896b69e944a3265f8f33743a430a5", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 81, "deletions": 10, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -10,11 +10,19 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n+use llvm::debuginfo::DIScope;\n use rustc::ty;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n+use session::config::FullDebugInfo;\n use base;\n use common::{self, Block, BlockAndBuilder, FunctionContext};\n+use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind};\n+use machine;\n+use type_of;\n+\n+use syntax::codemap::DUMMY_SP;\n+use syntax::parse::token;\n \n use std::ops::Deref;\n use std::rc::Rc;\n@@ -44,8 +52,6 @@ impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     }\n }\n \n-// FIXME DebugLoc is always None right now\n-\n /// Master context for translating MIR.\n pub struct MirContext<'bcx, 'tcx:'bcx> {\n     mir: CachedMir<'bcx, 'tcx>,\n@@ -92,6 +98,9 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     /// always indirect, though we try to avoid creating an alloca\n     /// when we can (and just reuse the pointer the caller provided).\n     args: Vec<LvalueRef<'tcx>>,\n+\n+    /// Debug information for MIR scopes.\n+    scopes: Vec<DIScope>\n }\n \n enum TempRef<'tcx> {\n@@ -113,11 +122,26 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n       analyze::lvalue_temps(bcx, &mir)\n     });\n \n+    // Compute debuginfo scopes from MIR scopes.\n+    let scopes = debuginfo::create_mir_scopes(fcx);\n+\n     // Allocate variable and temp allocas\n     let vars = mir.var_decls.iter()\n-                            .map(|decl| (bcx.monomorphize(&decl.ty), decl.name))\n-                            .map(|(mty, name)| LvalueRef::alloca(&bcx, mty, &name.as_str()))\n-                            .collect();\n+                            .map(|decl| (bcx.monomorphize(&decl.ty), decl))\n+                            .map(|(mty, decl)| {\n+        let lvalue = LvalueRef::alloca(&bcx, mty, &decl.name.as_str());\n+\n+        let scope = scopes[decl.scope.index()];\n+        if !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+            bcx.with_block(|bcx| {\n+                declare_local(bcx, decl.name, mty, scope,\n+                              VariableAccess::DirectVariable { alloca: lvalue.llval },\n+                              VariableKind::LocalVariable, decl.span);\n+            });\n+        }\n+\n+        lvalue\n+    }).collect();\n     let temps = mir.temp_decls.iter()\n                               .map(|decl| bcx.monomorphize(&decl.ty))\n                               .enumerate()\n@@ -132,7 +156,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   TempRef::Operand(None)\n                               })\n                               .collect();\n-    let args = arg_value_refs(&bcx, &mir);\n+    let args = arg_value_refs(&bcx, &mir, &scopes);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: Vec<Block<'blk,'tcx>> =\n@@ -152,6 +176,11 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let start_bcx = block_bcxs[mir::START_BLOCK.index()];\n     bcx.br(start_bcx.llbb);\n \n+    // Up until here, IR instructions for this function have explicitly not been annotated with\n+    // source code location, so we don't step into call setup code. From here on, source location\n+    // emitting should be enabled.\n+    debuginfo::start_emitting_source_locations(fcx);\n+\n     let mut mircx = MirContext {\n         mir: mir.clone(),\n         fcx: fcx,\n@@ -161,6 +190,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         vars: vars,\n         temps: temps,\n         args: args,\n+        scopes: scopes\n     };\n \n     let mut visited = BitVector::new(mir_blocks.len());\n@@ -185,19 +215,33 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         }\n     }\n \n+    DebugLoc::None.apply(fcx);\n     fcx.cleanup();\n }\n \n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                              mir: &mir::Mir<'tcx>)\n+                              mir: &mir::Mir<'tcx>,\n+                              scopes: &[DIScope])\n                               -> Vec<LvalueRef<'tcx>> {\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+\n+    // Get the argument scope assuming ScopeId(0) has no parent.\n+    let arg_scope = mir.scopes.get(0).and_then(|data| {\n+        let scope = scopes[0];\n+        if data.parent_scope.is_none() && !scope.is_null() &&\n+           bcx.sess().opts.debuginfo == FullDebugInfo {\n+            Some(scope)\n+        } else {\n+            None\n+        }\n+    });\n+\n     mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);\n         if arg_decl.spread {\n@@ -211,13 +255,14 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n+            let lltuplety = type_of::type_of(bcx.ccx(), arg_ty);\n             let lltemp = bcx.with_block(|bcx| {\n                 base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n             });\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                 let dst = bcx.struct_gep(lltemp, i);\n                 let arg = &fcx.fn_ty.args[idx];\n-                    idx += 1;\n+                idx += 1;\n                 if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n                         // We pass fat pointers as two words, but inside the tuple\n                         // they are the two sub-fields of a single aggregate field.\n@@ -228,17 +273,37 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                 } else {\n                     arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n                 }\n+\n+                bcx.with_block(|bcx| arg_scope.map(|scope| {\n+                    let byte_offset_of_var_in_tuple =\n+                        machine::llelement_offset(bcx.ccx(), lltuplety, i);\n+\n+                    let address_operations = unsafe {\n+                        [llvm::LLVMDIBuilderCreateOpDeref(),\n+                         llvm::LLVMDIBuilderCreateOpPlus(),\n+                         byte_offset_of_var_in_tuple as i64]\n+                    };\n+\n+                    let variable_access = VariableAccess::IndirectVariable {\n+                        alloca: lltemp,\n+                        address_operations: &address_operations\n+                    };\n+                    declare_local(bcx, token::special_idents::invalid.name,\n+                                  tupled_arg_ty, scope, variable_access,\n+                                  VariableKind::ArgumentVariable(arg_index + i + 1),\n+                                  bcx.fcx().span.unwrap_or(DUMMY_SP));\n+                }));\n             }\n             return LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty));\n         }\n \n         let arg = &fcx.fn_ty.args[idx];\n         idx += 1;\n-        let llval = if arg.is_indirect() {\n+        let llval = if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up, unless\n             // we emit extra-debug-info, which requires local allocas :(.\n-            // FIXME: lifetimes, debug info\n+            // FIXME: lifetimes\n             let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n             llarg_idx += 1;\n             llarg\n@@ -261,6 +326,12 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             }\n             lltemp\n         };\n+        bcx.with_block(|bcx| arg_scope.map(|scope| {\n+            declare_local(bcx, token::special_idents::invalid.name, arg_ty, scope,\n+                          VariableAccess::DirectVariable { alloca: llval },\n+                          VariableKind::ArgumentVariable(arg_index + 1),\n+                          bcx.fcx().span.unwrap_or(DUMMY_SP));\n+        }));\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n     }).collect()\n }"}, {"sha": "641603f5aaad9a88538ca7662f18df7e348d93ee", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -38,7 +38,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n                         bcx: BlockAndBuilder<'bcx, 'tcx>,\n                         dest: LvalueRef<'tcx>,\n-                        rvalue: &mir::Rvalue<'tcx>)\n+                        rvalue: &mir::Rvalue<'tcx>,\n+                        debug_loc: DebugLoc)\n                         -> BlockAndBuilder<'bcx, 'tcx>\n     {\n         debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n@@ -58,7 +59,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n-                    let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                    let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue, debug_loc);\n                     self.store_operand(&bcx, dest.llval, temp);\n                     return bcx;\n                 }\n@@ -217,7 +218,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n-                let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue, debug_loc);\n                 self.store_operand(&bcx, dest.llval, temp);\n                 bcx\n             }\n@@ -226,7 +227,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n     pub fn trans_rvalue_operand(&mut self,\n                                 bcx: BlockAndBuilder<'bcx, 'tcx>,\n-                                rvalue: &mir::Rvalue<'tcx>)\n+                                rvalue: &mir::Rvalue<'tcx>,\n+                                debug_loc: DebugLoc)\n                                 -> (BlockAndBuilder<'bcx, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n@@ -419,7 +421,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        lhs_addr, lhs_extra,\n                                                        rhs_addr, rhs_extra,\n                                                        lhs.ty, op.to_hir_binop(),\n-                                                       DebugLoc::None)\n+                                                       debug_loc)\n                             })\n                         }\n                         _ => bug!()\n@@ -470,7 +472,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                                    box_ty,\n                                                                    llsize,\n                                                                    llalign,\n-                                                                   DebugLoc::None);\n+                                                                   debug_loc);\n                     llval = Some(val);\n                     bcx\n                 });"}, {"sha": "e4967cead07e9b4098f5203bd33bceff0ee4c327", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce8d4a21348c6185e7df2817a80910f86e9db205/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=ce8d4a21348c6185e7df2817a80910f86e9db205", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::mir::repr as mir;\n use common::BlockAndBuilder;\n+use debuginfo::DebugLoc;\n \n use super::MirContext;\n use super::TempRef;\n@@ -21,17 +22,22 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                            -> BlockAndBuilder<'bcx, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n+        let debug_loc = DebugLoc::ScopeAt(self.scopes[statement.scope.index()],\n+                                          statement.span);\n+        debug_loc.apply_to_bcx(&bcx);\n+        debug_loc.apply(bcx.fcx());\n         match statement.kind {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 match *lvalue {\n                     mir::Lvalue::Temp(index) => {\n                         let index = index as usize;\n                         match self.temps[index as usize] {\n                             TempRef::Lvalue(tr_dest) => {\n-                                self.trans_rvalue(bcx, tr_dest, rvalue)\n+                                self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n                             }\n                             TempRef::Operand(None) => {\n-                                let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue);\n+                                let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue,\n+                                                                               debug_loc);\n                                 self.temps[index] = TempRef::Operand(Some(operand));\n                                 bcx\n                             }\n@@ -44,7 +50,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     _ => {\n                         let tr_dest = self.trans_lvalue(&bcx, lvalue);\n-                        self.trans_rvalue(bcx, tr_dest, rvalue)\n+                        self.trans_rvalue(bcx, tr_dest, rvalue, debug_loc)\n                     }\n                 }\n             }"}]}