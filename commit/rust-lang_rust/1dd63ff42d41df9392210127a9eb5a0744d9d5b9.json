{"sha": "1dd63ff42d41df9392210127a9eb5a0744d9d5b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZDYzZmY0MmQ0MWRmOTM5MjIxMDEyN2E5ZWI1YTA3NDRkOWQ1Yjk=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-01T20:55:57Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-01T20:57:36Z"}, "message": "Remove the search direction from resolve's fold environment\n\nIt's not actually involved in the fold so it can just be passed between the\nfunctions that need it.", "tree": {"sha": "596434bea9f814412fca0ab41870b4137001bf0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/596434bea9f814412fca0ab41870b4137001bf0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dd63ff42d41df9392210127a9eb5a0744d9d5b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd63ff42d41df9392210127a9eb5a0744d9d5b9", "html_url": "https://github.com/rust-lang/rust/commit/1dd63ff42d41df9392210127a9eb5a0744d9d5b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dd63ff42d41df9392210127a9eb5a0744d9d5b9/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f25e6783657cde34e25aa8ba105cd43fe9bda787", "url": "https://api.github.com/repos/rust-lang/rust/commits/f25e6783657cde34e25aa8ba105cd43fe9bda787", "html_url": "https://github.com/rust-lang/rust/commit/f25e6783657cde34e25aa8ba105cd43fe9bda787"}], "stats": {"total": 67, "additions": 31, "deletions": 36}, "files": [{"sha": "d75a6db09d9ab5c3e8f19e07f758e03900a2262c", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1dd63ff42d41df9392210127a9eb5a0744d9d5b9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dd63ff42d41df9392210127a9eb5a0744d9d5b9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=1dd63ff42d41df9392210127a9eb5a0744d9d5b9", "patch": "@@ -27,23 +27,22 @@ tag scope {\n     scope_arm(ast.arm);\n }\n \n-// This indicates whether we're searching up the scope chain\n-// or whether we've found a path component and started following\n-// it back down, which has an effect on export visibility\n-tag search_direction {\n-    up;\n-    down;\n-}\n-\n type env = rec(list[scope] scopes,\n-               session.session sess,\n-               search_direction direction);\n+               session.session sess);\n \n tag namespace {\n     ns_value;\n     ns_type;\n }\n \n+// This indicates whether we're searching up the scope chain or whether we've\n+// found a path component and started following it back down, which has an\n+// effect on export visibility\n+tag direction {\n+    up;\n+    down;\n+}\n+\n type import_map = std.map.hashmap[ast.def_id,def_wrap];\n \n // A simple wrapper over defs that stores a bit more information about modules\n@@ -157,11 +156,10 @@ fn find_final_def(&env e, import_map index,\n             auto len = _vec.len[ident](idents);\n             auto rest_idents = _vec.slice[ident](idents, 1u, len);\n             auto empty_e = rec(scopes = nil[scope],\n-                               sess = e.sess,\n-                               direction = down);\n+                               sess = e.sess);\n             auto tmp_e = update_env_for_item(empty_e, i);\n             auto next_i = rest_idents.(0);\n-            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns);\n+            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns, down);\n             alt (next_) {\n                 case (none[tup(@env, def_wrap)]) {\n                     e.sess.span_err(sp, \"unresolved name: \" + next_i);\n@@ -183,11 +181,10 @@ fn find_final_def(&env e, import_map index,\n             auto len = _vec.len[ident](idents);\n             auto rest_idents = _vec.slice[ident](idents, 1u, len);\n             auto empty_e = rec(scopes = nil[scope],\n-                               sess = e.sess,\n-                               direction = down);\n+                               sess = e.sess);\n             auto tmp_e = update_env_for_external_mod(empty_e, mod_id, idents);\n             auto next_i = rest_idents.(0);\n-            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns);\n+            auto next_ = lookup_name_wrapped(tmp_e, next_i, ns, down);\n             alt (next_) {\n                 case (none[tup(@env, def_wrap)]) {\n                     e.sess.span_err(sp, \"unresolved name: \" + next_i);\n@@ -282,7 +279,7 @@ fn find_final_def(&env e, import_map index,\n         index.insert(option.get[ast.def_id](import_id), def_wrap_resolving);\n     }\n     auto first = idents.(0);\n-    auto d_ = lookup_name_wrapped(e, first, ns);\n+    auto d_ = lookup_name_wrapped(e, first, ns, up);\n     alt (d_) {\n         case (none[tup(@env, def_wrap)]) {\n             e.sess.span_err(sp, \"unresolved name: \" + first);\n@@ -298,8 +295,8 @@ fn find_final_def(&env e, import_map index,\n     }\n }\n \n-fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n-        -> option.t[tup(@env, def_wrap)] {\n+fn lookup_name_wrapped(&env e, ast.ident i, namespace ns, direction dir)\n+    -> option.t[tup(@env, def_wrap)] {\n \n     // log \"resolving name \" + i;\n \n@@ -359,12 +356,12 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n         fail;\n     }\n \n-    fn check_mod(&env e, ast.ident i, ast._mod m, namespace ns)\n-            -> option.t[def_wrap] {\n+    fn check_mod(ast.ident i, ast._mod m, namespace ns,\n+                 direction dir) -> option.t[def_wrap] {\n \n-        fn visible(&env e, ast.ident i, ast._mod m) -> bool {\n+        fn visible(ast.ident i, ast._mod m, direction dir) -> bool {\n \n-            alt (e.direction) {\n+            alt (dir) {\n                 case (up) {\n                     ret true;\n                 }\n@@ -400,14 +397,14 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n                         ret some(found_def_view(view_item));\n                     }\n                     case (ast.mie_item(?item)) {\n-                        if (visible(e, i, m)) {\n+                        if (visible(i, m, dir)) {\n                             ret some(found_def_item(item, ns));\n                         }\n                     }\n                     case (ast.mie_tag_variant(?item, ?variant_idx)) {\n                         alt (item.node) {\n                             case (ast.item_tag(_, ?variants, _, ?tid, _)) {\n-                                if (visible(e, i, m)) {\n+                                if (visible(i, m, dir)) {\n                                     auto vid = variants.(variant_idx).node.id;\n                                     auto t = ast.def_variant(tid, vid);\n                                     ret some[def_wrap](def_wrap_other(t));\n@@ -501,12 +498,12 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n         }\n     }\n \n-    fn in_scope(&env e, ast.ident identifier, &scope s,\n-            namespace ns) -> option.t[def_wrap] {\n+    fn in_scope(&session.session sess, ast.ident identifier, &scope s,\n+                namespace ns, direction dir) -> option.t[def_wrap] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n-                ret check_mod(e, identifier, c.node.module, ns);\n+                ret check_mod(identifier, c.node.module, ns, dir);\n             }\n \n             case (scope_item(?it)) {\n@@ -542,7 +539,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n                         }\n                     }\n                     case (ast.item_mod(_, ?m, _)) {\n-                        ret check_mod(e, identifier, m, ns);\n+                        ret check_mod(identifier, m, ns, dir);\n                     }\n                     case (ast.item_native_mod(_, ?m, _)) {\n                         ret check_native_mod(identifier, m);\n@@ -570,7 +567,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n             }\n \n             case (scope_external_mod(?mod_id, ?path)) {\n-                ret lookup_external_def(e.sess, mod_id._0, path);\n+                ret lookup_external_def(sess, mod_id._0, path);\n             }\n \n             case (scope_loop(?d)) {\n@@ -606,14 +603,14 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n             ret none[tup(@env, def_wrap)];\n         }\n         case (cons[scope](?hd, ?tl)) {\n-            auto x = in_scope(e, i, hd, ns);\n+            auto x = in_scope(e.sess, i, hd, ns, dir);\n             alt (x) {\n                 case (some[def_wrap](?x)) {\n                     ret some(tup(@e, x));\n                 }\n                 case (none[def_wrap]) {\n                     auto outer_env = rec(scopes = *tl with e);\n-                    ret lookup_name_wrapped(outer_env, i, ns);\n+                    ret lookup_name_wrapped(outer_env, i, ns, up);\n                 }\n             }\n         }\n@@ -785,8 +782,7 @@ fn resolve_imports(session.session sess, @ast.crate crate) -> @ast.crate {\n                 with *fld );\n \n     auto e = rec(scopes = nil[scope],\n-                 sess = sess,\n-                 direction = up);\n+                 sess = sess);\n \n     ret fold.fold_crate[env](e, fld, crate);\n }\n@@ -810,8 +806,7 @@ fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n                 with *fld );\n \n     auto e = rec(scopes = nil[scope],\n-                 sess = sess,\n-                 direction = up);\n+                 sess = sess);\n \n     ret fold.fold_crate[env](e, fld, new_crate);\n }"}]}