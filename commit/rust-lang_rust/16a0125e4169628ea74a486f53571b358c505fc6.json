{"sha": "16a0125e4169628ea74a486f53571b358c505fc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YTAxMjVlNDE2OTYyOGVhNzRhNDg2ZjUzNTcxYjM1OGM1MDVmYzY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-08T00:57:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:04:01Z"}, "message": "libcore: Fix tests.", "tree": {"sha": "6e12248803f83c2797320ed3226543e7a5640fe2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e12248803f83c2797320ed3226543e7a5640fe2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16a0125e4169628ea74a486f53571b358c505fc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16a0125e4169628ea74a486f53571b358c505fc6", "html_url": "https://github.com/rust-lang/rust/commit/16a0125e4169628ea74a486f53571b358c505fc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16a0125e4169628ea74a486f53571b358c505fc6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49a66a5c5a0361291db22e08bfa6e8c17209d01c", "url": "https://api.github.com/repos/rust-lang/rust/commits/49a66a5c5a0361291db22e08bfa6e8c17209d01c", "html_url": "https://github.com/rust-lang/rust/commit/49a66a5c5a0361291db22e08bfa6e8c17209d01c"}], "stats": {"total": 248, "additions": 135, "deletions": 113}, "files": [{"sha": "7eaa8535493368ca24fbaa4c02189ec190794826", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -596,9 +596,10 @@ mod test {\n \n         c1.send(~\"abc\");\n \n-        match (p1, p2).select() {\n-          Right(_) => fail!(),\n-          _ => ()\n+        let mut tuple = (p1, p2);\n+        match tuple.select() {\n+            Right(_) => fail!(),\n+            _ => (),\n         }\n \n         c2.send(123);"}, {"sha": "29d0eb422d50a220750410e65dd8cb86f159b271", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -84,10 +84,11 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n #[test]\n #[allow(non_implicitly_copyable_typarams)]\n fn test_flate_round_trip() {\n-    let r = rand::rng();\n+    let mut r = rand::rng();\n     let mut words = ~[];\n     for 20.times {\n-        words.push(r.gen_bytes(r.gen_uint_range(1, 10)));\n+        let range = r.gen_uint_range(1, 10);\n+        words.push(r.gen_bytes(range));\n     }\n     for 20.times {\n         let mut in = ~[];"}, {"sha": "d535abf8ead7c7d304a1ba2af8c3bf6bc4375786", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -473,10 +473,10 @@ mod tests {\n         let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n         let mut buf : ~[u8] = ~[];\n         let mut t = 0;\n-        let stream_inc = &State(k0,k1);\n-        let stream_full = &State(k0,k1);\n+        let mut stream_inc = SipState::new(k0, k1);\n+        let mut stream_full = SipState::new(k0, k1);\n \n-        fn to_hex_str(r:  &[u8, ..8]) -> ~str {\n+        fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n             for vec::each(*r) |b| {\n                 s += uint::to_str_radix(*b as uint, 16u);"}, {"sha": "1bb754fc2be4229cacb01f8606065511bd6aa0c3", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -1886,15 +1886,15 @@ mod tests {\n     fn bytes_buffer_overwrite() {\n         let wr = BytesWriter();\n         wr.write(~[0u8, 1u8, 2u8, 3u8]);\n-        assert!(wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n+        assert!(*wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n         wr.seek(-2, SeekCur);\n         wr.write(~[4u8, 5u8, 6u8, 7u8]);\n-        assert!(wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n+        assert!(*wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n         wr.seek(-2, SeekEnd);\n         wr.write(~[8u8]);\n         wr.seek(1, SeekSet);\n         wr.write(~[9u8]);\n-        assert!(wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n+        assert!(*wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n \n     #[test]"}, {"sha": "afb9641485859a275042d0d8aadcd5530c401aef", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -1435,7 +1435,7 @@ mod tests {\n     }\n \n     fn make_rand_name() -> ~str {\n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert!(getenv(n).is_none());\n         n"}, {"sha": "8301254fbdd18a705fd495ac76d4f21fa1757bbf", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -894,9 +894,10 @@ mod test {\n \n         c1.send(~\"abc\");\n \n-        match (p1, p2).select() {\n-          Right(_) => fail!(),\n-          _ => ()\n+        let mut tuple = (p1, p2);\n+        match tuple.select() {\n+            Right(_) => fail!(),\n+            _ => (),\n         }\n \n         c2.send(123);"}, {"sha": "f11840c95d5acc95384e43cf6cbc2ff66b8cce37", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -879,24 +879,24 @@ mod tests {\n     #[test]\n     fn test_rng_seeded() {\n         let seed = seed();\n-        let ra = IsaacRng::new_seeded(seed);\n-        let rb = IsaacRng::new_seeded(seed);\n+        let mut ra = IsaacRng::new_seeded(seed);\n+        let mut rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n     fn test_rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 bytes\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = IsaacRng::new_seeded(seed);\n-        let rb = IsaacRng::new_seeded(seed);\n+        let mut ra = IsaacRng::new_seeded(seed);\n+        let mut rb = IsaacRng::new_seeded(seed);\n         assert!(ra.gen_str(100u) == rb.gen_str(100u));\n     }\n \n     #[test]\n     fn test_rng_seeded_custom_seed2() {\n         let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let ra = IsaacRng::new_seeded(seed);\n+        let mut ra = IsaacRng::new_seeded(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n         error!(\"%?\", r);\n@@ -906,7 +906,7 @@ mod tests {\n \n     #[test]\n     fn test_gen_int_range() {\n-        let r = rng();\n+        let mut r = rng();\n         let a = r.gen_int_range(-3, 42);\n         assert!(a >= -3 && a < 42);\n         assert!(r.gen_int_range(0, 1) == 0);\n@@ -917,12 +917,13 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_gen_int_from_fail() {\n-        rng().gen_int_range(5, -2);\n+        let mut r = rng();\n+        r.gen_int_range(5, -2);\n     }\n \n     #[test]\n     fn test_gen_uint_range() {\n-        let r = rng();\n+        let mut r = rng();\n         let a = r.gen_uint_range(3u, 42u);\n         assert!(a >= 3u && a < 42u);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n@@ -933,27 +934,28 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_gen_uint_range_fail() {\n-        rng().gen_uint_range(5u, 2u);\n+        let mut r = rng();\n+        r.gen_uint_range(5u, 2u);\n     }\n \n     #[test]\n     fn test_gen_float() {\n-        let r = rng();\n+        let mut r = rng();\n         let a = r.gen::<float>();\n         let b = r.gen::<float>();\n         debug!((a, b));\n     }\n \n     #[test]\n     fn test_gen_weighted_bool() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.gen_weighted_bool(0u) == true);\n         assert!(r.gen_weighted_bool(1u) == true);\n     }\n \n     #[test]\n     fn test_gen_str() {\n-        let r = rng();\n+        let mut r = rng();\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n         debug!(r.gen_str(10u));\n@@ -964,29 +966,29 @@ mod tests {\n \n     #[test]\n     fn test_gen_bytes() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.gen_bytes(0u).len() == 0u);\n         assert!(r.gen_bytes(10u).len() == 10u);\n         assert!(r.gen_bytes(16u).len() == 16u);\n     }\n \n     #[test]\n     fn test_choose() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.choose([1, 1, 1]) == 1);\n     }\n \n     #[test]\n     fn test_choose_option() {\n-        let r = rng();\n+        let mut r = rng();\n         let x: Option<int> = r.choose_option([]);\n         assert!(x.is_none());\n         assert!(r.choose_option([1, 1, 1]) == Some(1));\n     }\n \n     #[test]\n     fn test_choose_weighted() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.choose_weighted(~[\n             Weighted { weight: 1u, item: 42 },\n         ]) == 42);\n@@ -998,7 +1000,7 @@ mod tests {\n \n     #[test]\n     fn test_choose_weighted_option() {\n-        let r = rng();\n+        let mut r = rng();\n         assert!(r.choose_weighted_option(~[\n             Weighted { weight: 1u, item: 42 },\n         ]) == Some(42));\n@@ -1012,7 +1014,7 @@ mod tests {\n \n     #[test]\n     fn test_weighted_vec() {\n-        let r = rng();\n+        let mut r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.weighted_vec(~[]) == empty);\n         assert!(r.weighted_vec(~[\n@@ -1024,15 +1026,15 @@ mod tests {\n \n     #[test]\n     fn test_shuffle() {\n-        let r = rng();\n+        let mut r = rng();\n         let empty: ~[int] = ~[];\n         assert!(r.shuffle(~[]) == empty);\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n     }\n \n     #[test]\n     fn test_task_rng() {\n-        let r = task_rng();\n+        let mut r = task_rng();\n         r.gen::<int>();\n         assert!(r.shuffle(~[1, 1, 1]) == ~[1, 1, 1]);\n         assert!(r.gen_uint_range(0u, 1u) == 0u);\n@@ -1079,7 +1081,7 @@ mod tests {\n                 let rt_rng = do vec::as_imm_buf(seed) |p, sz| {\n                     rustrt::rand_new_seeded(p, sz as size_t)\n                 };\n-                let rng = IsaacRng::new_seeded(seed);\n+                let mut rng = IsaacRng::new_seeded(seed);\n \n                 for 10000.times {\n                     assert_eq!(rng.next(), rustrt::rand_next(rt_rng));"}, {"sha": "e58aa14572b7e4dacbb05fc1beaae17edd9c176c", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 52, "deletions": 47, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -597,12 +597,13 @@ pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_cant_dup_task_builder() {\n-    let b = task().unlinked();\n-    do b.spawn { }\n+    let mut builder = task();\n+    builder.unlinked();\n+    do builder.spawn {}\n     // FIXME(#3724): For now, this is a -runtime- failure, because we haven't\n     // got move mode on self. When 3724 is fixed, this test should fail to\n     // compile instead, and should go in tests/compile-fail.\n-    do b.spawn { } // b should have been consumed by the previous call\n+    do builder.spawn {} // b should have been consumed by the previous call\n }\n \n // The following 8 tests test the following 2^3 combinations:\n@@ -645,43 +646,31 @@ fn test_spawn_unlinked_sup_fail_down() {\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n     let (po, _ch) = stream::<()>();\n+\n     // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n-    let opts = {\n-        let mut opts = default_task_opts();\n-        opts.linked = true;\n-        opts.supervised = true;\n-        opts\n-    };\n+    let mut b0 = task();\n+    b0.opts.linked = true;\n+    b0.opts.supervised = true;\n \n-    let b0 = task();\n-    let b1 = TaskBuilder {\n-        opts: opts,\n-        can_not_copy: None,\n-        .. b0\n-    };\n-    do b1.spawn { fail!(); }\n+    do b0.spawn {\n+        fail!();\n+    }\n     po.recv(); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n-    let opts = {\n-        let mut opts = default_task_opts();\n-        opts.linked = true;\n-        opts.supervised = true;\n-        opts\n-    };\n-\n-    let b0 = task();\n-    let b1 = TaskBuilder {\n-        opts: opts,\n-        can_not_copy: None,\n-        .. b0\n-    };\n-    do b1.spawn { loop { task::yield(); } }\n+    let mut b0 = task();\n+    b0.opts.linked = true;\n+    b0.opts.supervised = true;\n+    do b0.spawn {\n+        loop {\n+            task::yield();\n+        }\n+    }\n     fail!(); // *both* mechanisms would be wrong if this didn't kill the child\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -700,7 +689,13 @@ fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_default_opts() { // parent fails; child fails\n     // Make sure the above test is the same as this one.\n-    do task().linked().spawn { loop { task::yield(); } }\n+    let mut builder = task();\n+    builder.linked();\n+    do builder.spawn {\n+        loop {\n+            task::yield();\n+        }\n+    }\n     fail!();\n }\n \n@@ -758,7 +753,8 @@ fn test_spawn_linked_sup_propagate_sibling() {\n #[test]\n fn test_run_basic() {\n     let (po, ch) = stream::<()>();\n-    do task().spawn {\n+    let mut builder = task();\n+    do builder.spawn {\n         ch.send(());\n     }\n     po.recv();\n@@ -772,39 +768,45 @@ struct Wrapper {\n #[test]\n fn test_add_wrapper() {\n     let (po, ch) = stream::<()>();\n-    let b0 = task();\n-    let ch = Wrapper { f: Some(ch) };\n-    let b1 = do b0.add_wrapper |body| {\n-        let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n+    let mut b0 = task();\n+    let ch = Cell(ch);\n+    do b0.add_wrapper |body| {\n+        let ch = Cell(ch.take());\n         let result: ~fn() = || {\n-            let ch = ch.f.swap_unwrap();\n+            let mut ch = ch.take();\n             body();\n             ch.send(());\n         };\n         result\n     };\n-    do b1.spawn { }\n+    do b0.spawn { }\n     po.recv();\n }\n \n #[test]\n #[ignore(cfg(windows))]\n fn test_future_result() {\n     let mut result = None;\n-    do task().future_result(|r| { result = Some(r); }).spawn { }\n+    let mut builder = task();\n+    builder.future_result(|r| result = Some(r));\n+    do builder.spawn {}\n     assert!(result.unwrap().recv() == Success);\n \n     result = None;\n-    do task().future_result(|r|\n-        { result = Some(r); }).unlinked().spawn {\n+    let mut builder = task();\n+    builder.future_result(|r| result = Some(r));\n+    builder.unlinked();\n+    do builder.spawn {\n         fail!();\n     }\n     assert!(result.unwrap().recv() == Failure);\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_back_to_the_future_result() {\n-    let _ = task().future_result(util::ignore).future_result(util::ignore);\n+    let mut builder = task();\n+    builder.future_result(util::ignore);\n+    builder.future_result(util::ignore);\n }\n \n #[test]\n@@ -866,12 +868,12 @@ fn test_spawn_sched_childs_on_default_sched() {\n     // Assuming tests run on the default scheduler\n     let default_id = unsafe { rt::rust_get_sched_id() };\n \n-    let ch = Wrapper { f: Some(ch) };\n+    let ch = Cell(ch);\n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = unsafe { rt::rust_get_sched_id() };\n-        let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n+        let ch = Cell(ch.take());\n         do spawn {\n-            let ch = ch.f.swap_unwrap();\n+            let ch = ch.take();\n             let child_sched_id = unsafe { rt::rust_get_sched_id() };\n             assert!(parent_sched_id != child_sched_id);\n             assert!(child_sched_id == default_id);\n@@ -979,7 +981,8 @@ fn test_avoid_copying_the_body_spawn() {\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        do task().spawn || {\n+        let mut builder = task();\n+        do builder.spawn || {\n             f();\n         }\n     }\n@@ -1006,7 +1009,9 @@ fn test_avoid_copying_the_body_unlinked() {\n #[test]\n fn test_platform_thread() {\n     let (po, ch) = stream();\n-    do task().sched_mode(PlatformThread).spawn {\n+    let mut builder = task();\n+    builder.sched_mode(PlatformThread);\n+    do builder.spawn {\n         ch.send(());\n     }\n     po.recv();"}, {"sha": "8670bcfcd9a056f1c2f56b08666b9079d6514917", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -191,12 +191,14 @@ fn test_select_stream_and_oneshot() {\n     use comm::select2i;\n     use either::{Left, Right};\n \n-    let (port, chan) = stream();\n+    let mut (port, chan) = stream();\n+    let port = Cell(port);\n     let (waitport, waitchan) = stream();\n     do spawn {\n         unsafe {\n-            do weaken_task |signal| {\n-                match select2i(&port, &signal) {\n+            do weaken_task |mut signal| {\n+                let mut port = port.take();\n+                match select2i(&mut port, &mut signal) {\n                     Left(*) => (),\n                     Right(*) => fail!()\n                 }"}, {"sha": "c223ff821c268c514ce115dce4d9afe2239972db", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -1237,7 +1237,7 @@ fn test_simplification() {\n     let ext_cx = mk_ctxt();\n     let item_in = ast::ii_item(quote_item!(\n         fn new_int_alist<B:Copy>() -> alist<int, B> {\n-            fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+            fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());"}, {"sha": "d69839faa64bc9cdb16fe4e781cbd1d6ee5d5d92", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -673,19 +673,25 @@ mod tests {\n         let mut children = ~[];\n         for 5.times {\n             let arc3 = (*arc).clone();\n-            do task::task().future_result(|r| children.push(r)).spawn {\n+            let mut builder = task::task();\n+            builder.future_result(|r| children.push(r));\n+            do builder.spawn {\n                 do arc3.read |num| {\n                     assert!(*num >= 0);\n                 }\n             }\n         }\n \n         // Wait for children to pass their asserts\n-        for vec::each(children) |r| { r.recv(); }\n+        for vec::each(children) |r| {\n+            r.recv();\n+        }\n \n         // Wait for writer to finish\n         p.recv();\n-        do arc.read |num| { assert!(*num == 10); }\n+        do arc.read |num| {\n+            assert!(*num == 10);\n+        }\n     }\n     #[test]\n     fn test_rw_downgrade() {"}, {"sha": "461fb61ed5665ee9f777498f097f79f89253b135", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -1426,7 +1426,7 @@ mod tests {\n \n     #[bench]\n     fn bench_uint_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = 0 as uint;\n         do b.iter {\n             bitv |= (1 << ((r.next() as uint) % uint::bits));\n@@ -1435,7 +1435,7 @@ mod tests {\n \n     #[bench]\n     fn bench_small_bitv_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n         do b.iter {\n             bitv.set((r.next() as uint) % uint::bits, true);\n@@ -1444,7 +1444,7 @@ mod tests {\n \n     #[bench]\n     fn bench_big_bitv_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n         do b.iter {\n             bitv.set((r.next() as uint) % uint::bits, true);\n@@ -1453,7 +1453,7 @@ mod tests {\n \n     #[bench]\n     fn bench_big_bitv_big(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut storage = ~[];\n         storage.grow(bench_bits / uint::bits, &0);\n         let mut bitv = BigBitv::new(storage);\n@@ -1464,7 +1464,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_big(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = Bitv::new(bench_bits, false);\n         do b.iter {\n             bitv.set((r.next() as uint) % bench_bits, true);\n@@ -1473,7 +1473,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n             bitv.set((r.next() as uint) % uint::bits, true);\n@@ -1482,7 +1482,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_set_small(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n             bitv.insert((r.next() as uint) % uint::bits);\n@@ -1491,7 +1491,7 @@ mod tests {\n \n     #[bench]\n     fn bench_bitv_set_big(b: &mut BenchHarness) {\n-        let r = rng();\n+        let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n             bitv.insert((r.next() as uint) % bench_bits);"}, {"sha": "0d4ef69a2753b1abc41397b6129920b8588944d1", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -645,7 +645,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = copy chan.byte_chan.writer.bytes;\n+        let bytes = copy *chan.byte_chan.writer.bytes;\n \n         let reader = BufReader::new(bytes);\n         let port = serial::reader_port(reader);\n@@ -692,7 +692,7 @@ mod test {\n \n         chan.send(10);\n \n-        let bytes = copy chan.byte_chan.writer.bytes;\n+        let bytes = copy *chan.byte_chan.writer.bytes;\n \n         let reader = BufReader::new(bytes);\n         let port = pod::reader_port(reader);"}, {"sha": "37eb1e02a8014e2089c253f49956264978cac0e4", "filename": "src/libstd/future.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -184,9 +184,9 @@ pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n #[allow(non_implicitly_copyable_typarams)]\n #[cfg(test)]\n mod test {\n-\n     use future::*;\n \n+    use core::cell::Cell;\n     use core::comm::{oneshot, send_one};\n     use core::task;\n \n@@ -239,8 +239,9 @@ mod test {\n     #[test]\n     fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n-        let mut f = do spawn { copy expected };\n-        do task::spawn || {\n+        let f = Cell(do spawn { copy expected });\n+        do task::spawn {\n+            let mut f = f.take();\n             let actual = f.get();\n             assert!(actual == expected);\n         }"}, {"sha": "bc4168ba7f8756ab9c98403652acd4b251dff779", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -1963,7 +1963,7 @@ mod test {\n     }\n \n     fn tcp_write_single(sock: &TcpSocket, val: ~[u8]) {\n-        let write_result_future = sock.write_future(val);\n+        let mut write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n         if result::is_err(&write_result) {\n             debug!(\"tcp_write_single: write failed!\");"}, {"sha": "6994ca4aedb6d8369c8b8dcd7626f5f969857926", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -946,8 +946,10 @@ mod test_tim_sort {\n \n     impl Ord for CVal {\n         fn lt(&self, other: &CVal) -> bool {\n-            let rng = rand::rng();\n-            if rng.gen::<float>() > 0.995 { fail!(~\"It's happening!!!\"); }\n+            let mut rng = rand::rng();\n+            if rng.gen::<float>() > 0.995 {\n+                fail!(~\"It's happening!!!\");\n+            }\n             (*self).val < other.val\n         }\n         fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n@@ -995,7 +997,7 @@ mod test_tim_sort {\n     #[should_fail]\n     #[cfg(unix)]\n     fn crash_test() {\n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n         let mut arr = do vec::from_fn(1000) |_i| {\n             CVal { val: rng.gen() }\n         };\n@@ -1015,7 +1017,7 @@ mod test_tim_sort {\n \n     #[test]\n     fn test_bad_Ord_impl() {\n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n         let mut arr = do vec::from_fn(500) |_i| {\n             DVal { val: rng.gen() }\n         };\n@@ -1067,7 +1069,7 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;\n@@ -1138,7 +1140,7 @@ mod big_tests {\n             }\n         }\n \n-        let rng = rand::rng();\n+        let mut rng = rand::rng();\n \n         for uint::range(lo, hi) |i| {\n             let n = 1 << i;"}, {"sha": "0d15bbb54d321785e92fa7816fbd752fae016c48", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -219,7 +219,7 @@ mod test {\n                 let hl_loop_clone = hl_loop.clone();\n                 do task::spawn {\n                     use core::rand::*;\n-                    let rng = rng();\n+                    let mut rng = rng();\n                     for old_iter::repeat(times) {\n                         sleep(&hl_loop_clone, rng.next() as uint % maxms);\n                     }\n@@ -276,7 +276,8 @@ mod test {\n         let hl_loop = uv::global_loop::get();\n \n         for old_iter::repeat(times as uint) {\n-            let expected = rand::rng().gen_str(16u);\n+            let mut rng = rand::rng();\n+            let expected = rng.gen_str(16u);\n             let (test_po, test_ch) = stream::<~str>();\n             let hl_loop_clone = hl_loop.clone();\n             do task::spawn() {"}, {"sha": "06ac1a71bacd0eedd0a86ec7c9b112e89ba63523", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a0125e4169628ea74a486f53571b358c505fc6/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=16a0125e4169628ea74a486f53571b358c505fc6", "patch": "@@ -848,7 +848,7 @@ mod test_treemap {\n         check_equal(ctrl, &map);\n         assert!(map.find(&5).is_none());\n \n-        let rng = rand::IsaacRng::new_seeded(&[42]);\n+        let mut rng = rand::IsaacRng::new_seeded(&[42]);\n \n         for 3.times {\n             for 90.times {"}]}