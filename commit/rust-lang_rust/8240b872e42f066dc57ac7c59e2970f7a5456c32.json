{"sha": "8240b872e42f066dc57ac7c59e2970f7a5456c32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNDBiODcyZTQyZjA2NmRjNTdhYzdjNTllMjk3MGY3YTU0NTZjMzI=", "commit": {"author": {"name": "Brian Leibig", "email": "brian@brianleibig.com", "date": "2017-10-09T01:46:42Z"}, "committer": {"name": "Brian Leibig", "email": "brian@brianleibig.com", "date": "2017-10-09T01:46:42Z"}, "message": "Update grammar to parse current rust syntax", "tree": {"sha": "46debae287ae5bb0a41e1635fdde73d62bd61fc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46debae287ae5bb0a41e1635fdde73d62bd61fc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8240b872e42f066dc57ac7c59e2970f7a5456c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8240b872e42f066dc57ac7c59e2970f7a5456c32", "html_url": "https://github.com/rust-lang/rust/commit/8240b872e42f066dc57ac7c59e2970f7a5456c32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8240b872e42f066dc57ac7c59e2970f7a5456c32/comments", "author": {"login": "bleibig", "id": 1253302, "node_id": "MDQ6VXNlcjEyNTMzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1253302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bleibig", "html_url": "https://github.com/bleibig", "followers_url": "https://api.github.com/users/bleibig/followers", "following_url": "https://api.github.com/users/bleibig/following{/other_user}", "gists_url": "https://api.github.com/users/bleibig/gists{/gist_id}", "starred_url": "https://api.github.com/users/bleibig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bleibig/subscriptions", "organizations_url": "https://api.github.com/users/bleibig/orgs", "repos_url": "https://api.github.com/users/bleibig/repos", "events_url": "https://api.github.com/users/bleibig/events{/privacy}", "received_events_url": "https://api.github.com/users/bleibig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bleibig", "id": 1253302, "node_id": "MDQ6VXNlcjEyNTMzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1253302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bleibig", "html_url": "https://github.com/bleibig", "followers_url": "https://api.github.com/users/bleibig/followers", "following_url": "https://api.github.com/users/bleibig/following{/other_user}", "gists_url": "https://api.github.com/users/bleibig/gists{/gist_id}", "starred_url": "https://api.github.com/users/bleibig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bleibig/subscriptions", "organizations_url": "https://api.github.com/users/bleibig/orgs", "repos_url": "https://api.github.com/users/bleibig/repos", "events_url": "https://api.github.com/users/bleibig/events{/privacy}", "received_events_url": "https://api.github.com/users/bleibig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "150b625a07f135d0a5e1693adf2b14315709779e", "url": "https://api.github.com/repos/rust-lang/rust/commits/150b625a07f135d0a5e1693adf2b14315709779e", "html_url": "https://github.com/rust-lang/rust/commit/150b625a07f135d0a5e1693adf2b14315709779e"}], "stats": {"total": 457, "additions": 271, "deletions": 186}, "files": [{"sha": "2f282c8281d6eeba11b412101461aef4a2f3baa3", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8240b872e42f066dc57ac7c59e2970f7a5456c32/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/8240b872e42f066dc57ac7c59e2970f7a5456c32/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=8240b872e42f066dc57ac7c59e2970f7a5456c32", "patch": "@@ -85,43 +85,60 @@ ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n <blockcomment>(.|\\n)   { }\n \n _        { return UNDERSCORE; }\n+abstract { return ABSTRACT; }\n+alignof  { return ALIGNOF; }\n as       { return AS; }\n+become   { return BECOME; }\n box      { return BOX; }\n break    { return BREAK; }\n+catch    { return CATCH; }\n const    { return CONST; }\n continue { return CONTINUE; }\n crate    { return CRATE; }\n+default  { return DEFAULT; }\n+do       { return DO; }\n else     { return ELSE; }\n enum     { return ENUM; }\n extern   { return EXTERN; }\n false    { return FALSE; }\n+final    { return FINAL; }\n fn       { return FN; }\n for      { return FOR; }\n if       { return IF; }\n impl     { return IMPL; }\n in       { return IN; }\n let      { return LET; }\n loop     { return LOOP; }\n+macro    { return MACRO; }\n match    { return MATCH; }\n mod      { return MOD; }\n move     { return MOVE; }\n mut      { return MUT; }\n+offsetof { return OFFSETOF; }\n+override { return OVERRIDE; }\n priv     { return PRIV; }\n proc     { return PROC; }\n+pure     { return PURE; }\n pub      { return PUB; }\n ref      { return REF; }\n return   { return RETURN; }\n self     { return SELF; }\n+sizeof   { return SIZEOF; }\n static   { return STATIC; }\n struct   { return STRUCT; }\n+super    { return SUPER; }\n trait    { return TRAIT; }\n true     { return TRUE; }\n type     { return TYPE; }\n typeof   { return TYPEOF; }\n+union    { return UNION; }\n unsafe   { return UNSAFE; }\n+unsized  { return UNSIZED; }\n use      { return USE; }\n+virtual  { return VIRTUAL; }\n where    { return WHERE; }\n while    { return WHILE; }\n+yield    { return YIELD; }\n \n {ident}  { return IDENT; }\n \n@@ -189,25 +206,25 @@ while    { return WHILE; }\n \\>\\>= { return SHREQ; }\n \\>    { return '>'; }\n \n-\\x27                                  { BEGIN(ltorchar); yymore(); }\n-<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n-<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n-<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n-<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n+\\x27                                      { BEGIN(ltorchar); yymore(); }\n+<ltorchar>static                          { BEGIN(INITIAL); return STATIC_LIFETIME; }\n+<ltorchar>{ident}                         { BEGIN(INITIAL); return LIFETIME; }\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27          { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\u\\{([0-9a-fA-F]_*){1,6}\\}\\x27 { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>.\\x27                           { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27            { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar><<EOF>>                         { BEGIN(INITIAL); return -1; }\n \n b\\x22              { BEGIN(bytestr); yymore(); }\n <bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n \n-<bytestr><<EOF>>                { return -1; }\n-<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n-<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<bytestr>(.|\\n)                 { yymore(); }\n+<bytestr><<EOF>>                     { return -1; }\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]        { yymore(); }\n+<bytestr>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<bytestr>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<bytestr>(.|\\n)                      { yymore(); }\n \n br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n <rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n@@ -252,13 +269,13 @@ br/# {\n }\n <rawbytestr><<EOF>> { return -1; }\n \n-b\\x27                        { BEGIN(byte); yymore(); }\n-<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n-<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n+b\\x27                           { BEGIN(byte); yymore(); }\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27    { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\u([0-9a-fA-F]_*){4}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\U([0-9a-fA-F]_*){8}\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>.\\x27                     { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte><<EOF>>                   { BEGIN(INITIAL); return -1; }\n \n r\\x22           { BEGIN(rawstr); yymore(); }\n <rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n@@ -310,12 +327,12 @@ r/#             {\n \\x22                     { BEGIN(str); yymore(); }\n <str>\\x22                { BEGIN(suffix); return LIT_STR; }\n \n-<str><<EOF>>                { return -1; }\n-<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n-<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n-<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n-<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n-<str>(.|\\n)                 { yymore(); }\n+<str><<EOF>>                     { return -1; }\n+<str>\\\\[n\\nr\\rt\\\\\\x27\\x220]      { yymore(); }\n+<str>\\\\x[0-9a-fA-F]{2}           { yymore(); }\n+<str>\\\\u\\{([0-9a-fA-F]_*){1,6}\\} { yymore(); }\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]       { return -1; }\n+<str>(.|\\n)                      { yymore(); }\n \n \\<-  { return LARROW; }\n -\\>  { return RARROW; }"}, {"sha": "de1f96aac504653db2d440a8426ea623143abc29", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 208, "deletions": 158, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/8240b872e42f066dc57ac7c59e2970f7a5456c32/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/8240b872e42f066dc57ac7c59e2970f7a5456c32/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=8240b872e42f066dc57ac7c59e2970f7a5456c32", "patch": "@@ -62,33 +62,49 @@ extern char *yytext;\n // keywords\n %token SELF\n %token STATIC\n+%token ABSTRACT\n+%token ALIGNOF\n %token AS\n+%token BECOME\n %token BREAK\n+%token CATCH\n %token CRATE\n+%token DO\n %token ELSE\n %token ENUM\n %token EXTERN\n %token FALSE\n+%token FINAL\n %token FN\n %token FOR\n %token IF\n %token IMPL\n %token IN\n %token LET\n %token LOOP\n+%token MACRO\n %token MATCH\n %token MOD\n %token MOVE\n %token MUT\n+%token OFFSETOF\n+%token OVERRIDE\n %token PRIV\n %token PUB\n+%token PURE\n %token REF\n %token RETURN\n+%token SIZEOF\n %token STRUCT\n+%token SUPER\n+%token UNION\n+%token UNSIZED\n %token TRUE\n %token TRAIT\n %token TYPE\n %token UNSAFE\n+%token VIRTUAL\n+%token YIELD\n %token DEFAULT\n %token USE\n %token WHILE\n@@ -141,6 +157,10 @@ extern char *yytext;\n // 'foo:bar . <' is shifted (in a trait reference occurring in a\n // bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n %precedence IDENT\n+ // Put the weak keywords that can be used as idents here as well\n+%precedence CATCH\n+%precedence DEFAULT\n+%precedence UNION\n \n // A couple fake-precedence symbols to use in rules associated with +\n // and < in trailing type contexts. These come up when you have a type\n@@ -161,13 +181,13 @@ extern char *yytext;\n %precedence FOR\n \n // Binops & unops, and their precedences\n+%precedence '?'\n %precedence BOX\n-%precedence BOXPLACE\n %nonassoc DOTDOT\n \n // RETURN needs to be lower-precedence than tokens that start\n // prefix_exprs\n-%precedence RETURN\n+%precedence RETURN YIELD\n \n %right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n %right LARROW\n@@ -321,6 +341,8 @@ view_path\n | path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n |                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n | path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n+|                       MOD_SEP '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n+|                               '*'                        { $$ = mk_atom(\"ViewPathGlob\"); }\n |                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n |                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n |                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n@@ -334,6 +356,7 @@ block_item\n | item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n | item_struct\n | item_enum\n+| item_union\n | item_trait\n | item_impl\n ;\n@@ -387,6 +410,7 @@ struct_decl_field\n struct_tuple_fields\n : struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n | struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n+| %empty                                      { $$ = mk_none(); }\n ;\n \n struct_tuple_field\n@@ -417,6 +441,11 @@ enum_args\n | %empty                         { $$ = mk_none(); }\n ;\n \n+// unions\n+item_union\n+: UNION ident generic_params maybe_where_clause '{' struct_decl_fields '}'     { $$ = mk_node(\"ItemUnion\", 0); }\n+| UNION ident generic_params maybe_where_clause '{' struct_decl_fields ',' '}' { $$ = mk_node(\"ItemUnion\", 0); }\n+\n item_mod\n : MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n | MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n@@ -475,7 +504,7 @@ visibility\n \n idents_or_self\n : ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n-| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n+| idents_or_self AS ident          { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n | idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -515,6 +544,7 @@ trait_item\n : trait_const\n | trait_type\n | trait_method\n+| maybe_outer_attrs item_macro { $$ = mk_node(\"TraitMacroItem\", 2, $1, $2); }\n ;\n \n trait_const\n@@ -547,36 +577,48 @@ trait_method\n ;\n \n type_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 6, $1, $3, $5, $6, $7, $8);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n {\n   $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n }\n ;\n \n method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+: maybe_outer_attrs maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+| maybe_outer_attrs CONST maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $3, $5, $6, $7, $8, $9);\n+}\n+| maybe_outer_attrs maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n ;\n \n impl_method\n-: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+: attrs_and_vis maybe_default maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n-  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+  $$ = mk_node(\"Method\", 8, $1, $2, $3, $5, $6, $7, $8, $9);\n }\n-| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+| attrs_and_vis maybe_default CONST maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n }\n+| attrs_and_vis maybe_default maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 9, $1, $2, $3, $5, $7, $8, $9, $10, $11);\n+}\n ;\n \n // There are two forms of impl:\n@@ -638,26 +680,39 @@ impl_item\n | impl_type\n ;\n \n+maybe_default\n+: DEFAULT { $$ = mk_atom(\"Default\"); }\n+| %empty { $$ = mk_none(); }\n+;\n+\n impl_const\n-: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+: attrs_and_vis maybe_default item_const { $$ = mk_node(\"ImplConst\", 3, $1, $2, $3); }\n ;\n \n impl_type\n-: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n+: attrs_and_vis maybe_default TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 5, $1, $2, $4, $5, $7); }\n ;\n \n item_fn\n : FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n }\n+| CONST FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemFn\", 5, $3, $4, $5, $6, $7);\n+}\n ;\n \n item_unsafe_fn\n : UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n }\n+| CONST UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 5, $4, $5, $6, $7, $8);\n+}\n | UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n {\n   $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n@@ -723,12 +778,6 @@ inferrable_param\n : pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n ;\n \n-maybe_unboxed_closure_kind\n-: %empty\n-| ':'\n-| '&' maybe_mut ':'\n-;\n-\n maybe_comma_params\n : ','            { $$ = mk_none(); }\n | ',' params     { $$ = $2; }\n@@ -784,7 +833,8 @@ ret_ty\n ;\n \n generic_params\n-: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+: '<' '>'                             { $$ = mk_node(\"Generics\", 2, mk_none(), mk_none()); }\n+| '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n | '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n@@ -837,6 +887,8 @@ path_no_types_allowed\n | MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n | SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n | MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| SUPER                               { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n+| MOD_SEP SUPER                       { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Super\")); }\n | path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -882,7 +934,7 @@ generic_args\n ;\n \n generic_values\n-: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n+: maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 1, $1); }\n ;\n \n maybe_ty_sums_and_or_bindings\n@@ -910,12 +962,11 @@ pat\n | ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n | '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n | '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n-| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n | '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n | lit_or_path\n | lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n | path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n-| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n+| path_expr '(' ')'                               { $$ = mk_node(\"PatEnum\", 2, $1, mk_none()); }\n | path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n | path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n | binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n@@ -953,6 +1004,7 @@ pat_field\n | BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n |              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n | binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n+|        LIT_INTEGER ':' pat    { $$ = mk_node(\"PatField\", 2, mk_atom(yytext), $3); }\n ;\n \n pat_fields\n@@ -965,11 +1017,26 @@ pat_struct\n | pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n | pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n | DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n+| %empty                     { $$ = mk_node(\"PatStruct\", 1, mk_none()); }\n ;\n \n pat_tup\n-: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n-| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n+: pat_tup_elts                                  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts                             ','  { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts ',' DOTDOT                       { $$ = mk_node(\"PatTup\", 2, $1, mk_none()); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts     DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $4); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+| pat_tup_elts ',' DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, $1, $5); }\n+|                  DOTDOT ',' pat_tup_elts      { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT ',' pat_tup_elts ','  { $$ = mk_node(\"PatTup\", 2, mk_none(), $3); }\n+|                  DOTDOT                       { $$ = mk_node(\"PatTup\", 2, mk_none(), mk_none()); }\n+;\n+\n+pat_tup_elts\n+: pat                    { $$ = mk_node(\"PatTupElts\", 1, $1); }\n+| pat_tup_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n ;\n \n pat_vec\n@@ -1007,24 +1074,25 @@ ty\n ;\n \n ty_prim\n-: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n-| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n-| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n-| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n-| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n-| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n-| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n-| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n-| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n-| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n-| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n-| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n-| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n-| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n-| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n-| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n+: %prec IDENT path_generic_args_without_colons                                               { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons                                       { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons                                  { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n+| %prec IDENT path_generic_args_without_colons '!' maybe_ident delimited_token_trees         { $$ = mk_node(\"TyMacro\", 3, $1, $3, $4); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons '!' maybe_ident delimited_token_trees { $$ = mk_node(\"TyMacro\", 3, $2, $4, $5); }\n+| BOX ty                                                                                     { $$ = mk_node(\"TyBox\", 1, $2); }\n+| '*' maybe_mut_or_const ty                                                                  { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n+| '&' ty                                                                                     { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n+| '&' MUT ty                                                                                 { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n+| ANDAND ty                                                                                  { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n+| ANDAND MUT ty                                                                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n+| '&' lifetime maybe_mut ty                                                                  { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n+| ANDAND lifetime maybe_mut ty                                                               { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n+| '[' ty ']'                                                                                 { $$ = mk_node(\"TyVec\", 1, $2); }\n+| '[' ty ',' DOTDOT expr ']'                                                                 { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n+| '[' ty ';' expr ']'                                                                        { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n+| TYPEOF '(' expr ')'                                                                        { $$ = mk_node(\"TyTypeof\", 1, $3); }\n+| UNDERSCORE                                                                                 { $$ = mk_atom(\"TyInfer\"); }\n | ty_bare_fn\n-| ty_proc\n | for_in_type\n ;\n \n@@ -1046,17 +1114,12 @@ ty_closure\n |        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n ;\n \n-ty_proc\n-: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n-;\n-\n for_in_type\n : FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n ;\n \n for_in_type_suffix\n-: ty_proc\n-| ty_bare_fn\n+: ty_bare_fn\n | trait_ref\n | ty_closure\n ;\n@@ -1100,13 +1163,23 @@ ty_sums\n ;\n \n ty_sum\n-: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_sum_elt            { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_sum '+' ty_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_sum_elt\n+: ty\n+| lifetime\n ;\n \n ty_prim_sum\n-: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n-| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+: ty_prim_sum_elt                 { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_prim_sum '+' ty_prim_sum_elt { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_prim_sum_elt\n+: ty_prim\n+| lifetime\n ;\n \n maybe_ty_param_bounds\n@@ -1127,6 +1200,7 @@ boundseq\n polybound\n : FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n | bound\n+| '?' FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $4, $6); }\n | '?' bound { $$ = $2; }\n ;\n \n@@ -1244,26 +1318,22 @@ maybe_stmts\n // block, nonblock-prefix, and nonblock-nonprefix.\n //\n // In non-stmts contexts, expr can relax this trichotomy.\n-//\n-// There is also one other expr subtype: nonparen_expr disallows exprs\n-// surrounded by parens (including tuple expressions), this is\n-// necessary for BOX (place) expressions, so a parens expr following\n-// the BOX is always parsed as the place.\n \n stmts\n : stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n | stmts stmt     { $$ = ext_node($1, 1, $2); }\n ;\n \n stmt\n-: let\n+: maybe_outer_attrs let     { $$ = $2; }\n |                 stmt_item\n |             PUB stmt_item { $$ = $2; }\n | outer_attrs     stmt_item { $$ = $2; }\n | outer_attrs PUB stmt_item { $$ = $3; }\n | full_block_expr\n-| block\n-| nonblock_expr ';'\n+| maybe_outer_attrs block   { $$ = $2; }\n+|             nonblock_expr ';'\n+| outer_attrs nonblock_expr ';' { $$ = $2; }\n | ';'                   { $$ = mk_none(); }\n ;\n \n@@ -1296,7 +1366,9 @@ path_expr\n // expressions.\n path_generic_args_with_colons\n : ident                                              { $$ = mk_node(\"components\", 1, $1); }\n+| SUPER                                              { $$ = mk_atom(\"Super\"); }\n | path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n+| path_generic_args_with_colons MOD_SEP SUPER        { $$ = ext_node($1, 1, mk_atom(\"Super\")); }\n | path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n ;\n \n@@ -1313,6 +1385,7 @@ nonblock_expr\n | SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonblock_expr '?'                                             { $$ = mk_node(\"ExprTry\", 1, $1); }\n | nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1325,6 +1398,8 @@ nonblock_expr\n | RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n | nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1360,8 +1435,8 @@ nonblock_expr\n |               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| nonblock_expr ':' ty                                          { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                                      { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | nonblock_prefix_expr\n ;\n@@ -1373,6 +1448,7 @@ expr\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n | path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr '?'                                            { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1385,6 +1461,8 @@ expr\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1420,69 +1498,8 @@ expr\n |      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n-| expr_qualified_path\n-| block_expr\n-| block\n-| nonblock_prefix_expr\n-;\n-\n-nonparen_expr\n-: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n-| %prec IDENT\n-  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n-| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n-| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n-| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n-| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n-| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n-| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n-| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n-| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n-| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n-| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n-| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n-| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n-| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n-| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n-| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n-| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n-| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n-| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n-| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n-| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n-| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n-| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n-| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n-| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n-| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n-| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n-| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n-| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n-| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n-| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n-| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n-| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n-| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n-| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n-| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n-| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n-| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n-| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n-| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n-| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n-| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n-| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n-| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n-| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n-| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n-|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n-|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n-| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr ':' ty                                         { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1495,6 +1512,7 @@ expr_nostruct\n   path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n | SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n | macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| expr_nostruct '?'                                   { $$ = mk_node(\"ExprTry\", 1, $1); }\n | expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n | expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n | expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n@@ -1507,6 +1525,8 @@ expr_nostruct\n | RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n | BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n+| YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n | expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n@@ -1542,8 +1562,8 @@ expr_nostruct\n |               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n |               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n | expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n-| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n-| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_nostruct ':' ty                                { $$ = mk_node(\"ExprTypeAscr\", 2, $1, $3); }\n+| BOX expr                                            { $$ = mk_node(\"ExprBox\", 1, $2); }\n | expr_qualified_path\n | block_expr\n | block\n@@ -1558,7 +1578,6 @@ nonblock_prefix_expr_nostruct\n | ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr_nostruct\n | MOVE lambda_expr_nostruct                 { $$ = $2; }\n-| proc_expr_nostruct\n ;\n \n nonblock_prefix_expr\n@@ -1569,7 +1588,6 @@ nonblock_prefix_expr\n | ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n | lambda_expr\n | MOVE lambda_expr                 { $$ = $2; }\n-| proc_expr\n ;\n \n expr_qualified_path\n@@ -1606,43 +1624,42 @@ maybe_as_trait_ref\n \n lambda_expr\n : %prec LAMBDA\n-  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n+  OROR ret_ty expr                                    { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n+  '|' '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n+  '|' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n | %prec LAMBDA\n-  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n+  '|' inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-lambda_expr_nostruct\n+lambda_expr_no_first_bar\n : %prec LAMBDA\n-  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n-| %prec LAMBDA\n-  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n+  '|' ret_ty expr                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n | %prec LAMBDA\n-  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+  inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n-| %prec LAMBDA\n-  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n-\n+  inferrable_params OROR lambda_expr_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n-proc_expr\n+lambda_expr_nostruct\n : %prec LAMBDA\n-  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  OROR expr_nostruct                                           { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n+| %prec LAMBDA\n+  '|' '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  '|' inferrable_params '|' expr_nostruct                      { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+| %prec LAMBDA\n+  '|' inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $2, mk_none(), $4); }\n ;\n \n-proc_expr_nostruct\n+lambda_expr_nostruct_no_first_bar\n : %prec LAMBDA\n-  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+  '|' ret_ty expr_nostruct                                 { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n+| %prec LAMBDA\n+  inferrable_params '|' ret_ty expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 3, $1, $3, $4); }\n | %prec LAMBDA\n-  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+  inferrable_params OROR lambda_expr_nostruct_no_first_bar { $$ = mk_node(\"ExprFnBlock\", 3, $1, mk_none(), $3); }\n ;\n \n vec_expr\n@@ -1654,6 +1671,7 @@ struct_expr_fields\n : field_inits\n | field_inits ','\n | maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n+| %empty                               { $$ = mk_none(); }\n ;\n \n maybe_field_inits\n@@ -1668,7 +1686,9 @@ field_inits\n ;\n \n field_init\n-: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+: ident                { $$ = mk_node(\"FieldInit\", 1, $1); }\n+| ident ':' expr       { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+| LIT_INTEGER ':' expr { $$ = mk_node(\"FieldInit\", 2, mk_atom(yytext), $3); }\n ;\n \n default_field_init\n@@ -1689,10 +1709,18 @@ block_expr\n \n full_block_expr\n : block_expr\n-| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n-| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n-| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n-| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot\n+;\n+\n+block_expr_dot\n+: block_expr     '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr_dot '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| block_expr     '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| block_expr     '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr_dot '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| block_expr     '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| block_expr_dot '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n ;\n \n expr_match\n@@ -1714,12 +1742,13 @@ match_clause\n ;\n \n nonblock_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n-| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr  { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr_dot { $$ = mk_node(\"ArmNonblock\", 4, $1, $2, $3, $5); }\n ;\n \n block_match_clause\n-: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block      { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW block_expr { $$ = mk_node(\"ArmBlock\", 4, $1, $2, $3, $5); }\n ;\n \n maybe_guard\n@@ -1796,6 +1825,10 @@ maybe_ident\n \n ident\n : IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+// Weak keywords that can be used as identifiers\n+| CATCH                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| DEFAULT                    { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+| UNION                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n ;\n \n unpaired_token\n@@ -1836,35 +1869,52 @@ unpaired_token\n | LIFETIME                   { $$ = mk_atom(yytext); }\n | SELF                       { $$ = mk_atom(yytext); }\n | STATIC                     { $$ = mk_atom(yytext); }\n+| ABSTRACT                   { $$ = mk_atom(yytext); }\n+| ALIGNOF                    { $$ = mk_atom(yytext); }\n | AS                         { $$ = mk_atom(yytext); }\n+| BECOME                     { $$ = mk_atom(yytext); }\n | BREAK                      { $$ = mk_atom(yytext); }\n+| CATCH                      { $$ = mk_atom(yytext); }\n | CRATE                      { $$ = mk_atom(yytext); }\n+| DEFAULT                    { $$ = mk_atom(yytext); }\n+| DO                         { $$ = mk_atom(yytext); }\n | ELSE                       { $$ = mk_atom(yytext); }\n | ENUM                       { $$ = mk_atom(yytext); }\n | EXTERN                     { $$ = mk_atom(yytext); }\n | FALSE                      { $$ = mk_atom(yytext); }\n+| FINAL                      { $$ = mk_atom(yytext); }\n | FN                         { $$ = mk_atom(yytext); }\n | FOR                        { $$ = mk_atom(yytext); }\n | IF                         { $$ = mk_atom(yytext); }\n | IMPL                       { $$ = mk_atom(yytext); }\n | IN                         { $$ = mk_atom(yytext); }\n | LET                        { $$ = mk_atom(yytext); }\n | LOOP                       { $$ = mk_atom(yytext); }\n+| MACRO                      { $$ = mk_atom(yytext); }\n | MATCH                      { $$ = mk_atom(yytext); }\n | MOD                        { $$ = mk_atom(yytext); }\n | MOVE                       { $$ = mk_atom(yytext); }\n | MUT                        { $$ = mk_atom(yytext); }\n+| OFFSETOF                   { $$ = mk_atom(yytext); }\n+| OVERRIDE                   { $$ = mk_atom(yytext); }\n | PRIV                       { $$ = mk_atom(yytext); }\n | PUB                        { $$ = mk_atom(yytext); }\n+| PURE                       { $$ = mk_atom(yytext); }\n | REF                        { $$ = mk_atom(yytext); }\n | RETURN                     { $$ = mk_atom(yytext); }\n | STRUCT                     { $$ = mk_atom(yytext); }\n+| SIZEOF                     { $$ = mk_atom(yytext); }\n+| SUPER                      { $$ = mk_atom(yytext); }\n | TRUE                       { $$ = mk_atom(yytext); }\n | TRAIT                      { $$ = mk_atom(yytext); }\n | TYPE                       { $$ = mk_atom(yytext); }\n+| UNION                      { $$ = mk_atom(yytext); }\n | UNSAFE                     { $$ = mk_atom(yytext); }\n+| UNSIZED                    { $$ = mk_atom(yytext); }\n | USE                        { $$ = mk_atom(yytext); }\n+| VIRTUAL                    { $$ = mk_atom(yytext); }\n | WHILE                      { $$ = mk_atom(yytext); }\n+| YIELD                      { $$ = mk_atom(yytext); }\n | CONTINUE                   { $$ = mk_atom(yytext); }\n | PROC                       { $$ = mk_atom(yytext); }\n | BOX                        { $$ = mk_atom(yytext); }\n@@ -1942,4 +1992,4 @@ brackets_delimited_token_trees\n                $2,\n                mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n }\n-;\n\\ No newline at end of file\n+;"}, {"sha": "15ea738ed0057edd741da93228106a9c3aa8fca8", "filename": "src/grammar/tokens.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8240b872e42f066dc57ac7c59e2970f7a5456c32/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/8240b872e42f066dc57ac7c59e2970f7a5456c32/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=8240b872e42f066dc57ac7c59e2970f7a5456c32", "patch": "@@ -30,6 +30,7 @@ enum Token {\n   DOTDOT,\n   DOTDOTDOT,\n   MOD_SEP,\n+  LARROW,\n   RARROW,\n   FAT_ARROW,\n   LIT_BYTE,\n@@ -47,35 +48,52 @@ enum Token {\n   // keywords\n   SELF,\n   STATIC,\n+  ABSTRACT,\n+  ALIGNOF,\n   AS,\n+  BECOME,\n   BREAK,\n+  CATCH,\n   CRATE,\n+  DEFAULT,\n+  DO,\n   ELSE,\n   ENUM,\n   EXTERN,\n   FALSE,\n+  FINAL,\n   FN,\n   FOR,\n   IF,\n   IMPL,\n   IN,\n   LET,\n   LOOP,\n+  MACRO,\n   MATCH,\n   MOD,\n   MOVE,\n   MUT,\n+  OFFSETOF,\n+  OVERRIDE,\n   PRIV,\n   PUB,\n+  PURE,\n   REF,\n   RETURN,\n+  SIZEOF,\n   STRUCT,\n+  SUPER,\n+  UNION,\n   TRUE,\n   TRAIT,\n   TYPE,\n   UNSAFE,\n+  UNSIZED,\n   USE,\n+  VIRTUAL,\n   WHILE,\n+  YIELD,\n   CONTINUE,\n   PROC,\n   BOX,"}]}