{"sha": "d275114bda57e272b7a0a439d6b0a668bf988dd5", "node_id": "C_kwDOAAsO6NoAKGQyNzUxMTRiZGE1N2UyNzJiN2EwYTQzOWQ2YjBhNjY4YmY5ODhkZDU", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-22T17:20:54Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-02-22T17:29:38Z"}, "message": "resolve: Remove `ImportResolver`\n\nIt's a trivial wrapper over `Resolver` that doesn't bring any benefits", "tree": {"sha": "3c3665e022cacdc9f7a435947885e817d5be3195", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c3665e022cacdc9f7a435947885e817d5be3195"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d275114bda57e272b7a0a439d6b0a668bf988dd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d275114bda57e272b7a0a439d6b0a668bf988dd5", "html_url": "https://github.com/rust-lang/rust/commit/d275114bda57e272b7a0a439d6b0a668bf988dd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d275114bda57e272b7a0a439d6b0a668bf988dd5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b4d6e080404560f63599deeb328dfa27fe081a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4d6e080404560f63599deeb328dfa27fe081a6", "html_url": "https://github.com/rust-lang/rust/commit/3b4d6e080404560f63599deeb328dfa27fe081a6"}], "stats": {"total": 190, "additions": 87, "deletions": 103}, "files": [{"sha": "760a81b9a590db29b22c258ad8281006383f3bc8", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=d275114bda57e272b7a0a439d6b0a668bf988dd5", "patch": "@@ -29,7 +29,7 @@ use rustc_span::{BytePos, Span, SyntaxContext};\n use thin_vec::ThinVec;\n \n use crate::errors as errs;\n-use crate::imports::{Import, ImportKind, ImportResolver};\n+use crate::imports::{Import, ImportKind};\n use crate::late::{PatternSource, Rib};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, BindingError, Finalize};\n@@ -1888,15 +1888,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             (format!(\"use of undeclared crate or module `{}`\", ident), suggestion)\n         }\n     }\n-}\n \n-impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     /// Adds suggestions for a path that cannot be resolved.\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n \n@@ -1931,11 +1929,11 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_missing_self_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+        let result = self.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n@@ -1950,11 +1948,11 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_missing_crate_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+        let result = self.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1981,11 +1979,11 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_missing_super_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+        let result = self.maybe_resolve_path(&path, None, parent_scope);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, None)) } else { None }\n     }\n@@ -2003,7 +2001,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn make_external_crate_suggestion(\n         &mut self,\n         mut path: Vec<Segment>,\n-        parent_scope: &ParentScope<'b>,\n+        parent_scope: &ParentScope<'a>,\n     ) -> Option<(Vec<Segment>, Option<String>)> {\n         if path[1].ident.span.is_rust_2015() {\n             return None;\n@@ -2013,13 +2011,13 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         // 1) some consistent ordering for emitted diagnostics, and\n         // 2) `std` suggestions before `core` suggestions.\n         let mut extern_crate_names =\n-            self.r.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+            self.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n         extern_crate_names.sort_by(|a, b| b.as_str().partial_cmp(a.as_str()).unwrap());\n \n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.maybe_resolve_path(&path, None, parent_scope);\n+            let result = self.maybe_resolve_path(&path, None, parent_scope);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result\n@@ -2046,8 +2044,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     /// ```\n     pub(crate) fn check_for_module_export_macro(\n         &mut self,\n-        import: &'b Import<'b>,\n-        module: ModuleOrUniformRoot<'b>,\n+        import: &'a Import<'a>,\n+        module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n     ) -> Option<(Option<Suggestion>, Option<String>)> {\n         let ModuleOrUniformRoot::Module(mut crate_module) = module else {\n@@ -2064,8 +2062,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             return None;\n         }\n \n-        let resolutions = self.r.resolutions(crate_module).borrow();\n-        let resolution = resolutions.get(&self.r.new_key(ident, MacroNS))?;\n+        let resolutions = self.resolutions(crate_module).borrow();\n+        let resolution = resolutions.get(&self.new_key(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n         if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = binding.res() {\n             let module_name = crate_module.kind.name().unwrap();\n@@ -2086,7 +2084,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.r.tcx.sess,\n+                    self.tcx.sess,\n                     import.span,\n                     import.use_span,\n                 );\n@@ -2105,7 +2103,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     //   ie. `use a::b::{c, d};`\n                     //                    ^^^\n                     if let Some(previous_span) =\n-                        extend_span_to_previous_binding(self.r.tcx.sess, binding_span)\n+                        extend_span_to_previous_binding(self.tcx.sess, binding_span)\n                     {\n                         debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n                         removal_span = removal_span.with_lo(previous_span.lo());\n@@ -2123,7 +2121,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   or  `use a::{b, c, d}};`\n                 //               ^^^^^^^^^^^\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.r.tcx.sess,\n+                    self.tcx.sess,\n                     module_name,\n                     import.use_span,\n                 );\n@@ -2132,7 +2130,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     has_nested, after_crate_name\n                 );\n \n-                let source_map = self.r.tcx.sess.source_map();\n+                let source_map = self.tcx.sess.source_map();\n \n                 // Make sure this is actually crate-relative.\n                 let is_definitely_crate = import"}, {"sha": "4dab0836d28b14f2a5c720c7622f91113c24fb15", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 65, "deletions": 76, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=d275114bda57e272b7a0a439d6b0a668bf988dd5", "patch": "@@ -210,6 +210,17 @@ impl<'a> NameResolution<'a> {\n     }\n }\n \n+/// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved\n+/// import errors within the same use tree into a single diagnostic.\n+#[derive(Debug, Clone)]\n+struct UnresolvedImportError {\n+    span: Span,\n+    label: Option<String>,\n+    note: Option<String>,\n+    suggestion: Option<Suggestion>,\n+    candidates: Option<Vec<ImportSuggestion>>,\n+}\n+\n // Reexports of the form `pub use foo as bar;` where `foo` is `extern crate foo;`\n // are permitted for backward-compatibility under a deprecation lint.\n fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBinding<'_>) -> bool {\n@@ -392,24 +403,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n     }\n-}\n-\n-/// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved\n-/// import errors within the same use tree into a single diagnostic.\n-#[derive(Debug, Clone)]\n-struct UnresolvedImportError {\n-    span: Span,\n-    label: Option<String>,\n-    note: Option<String>,\n-    suggestion: Option<Suggestion>,\n-    candidates: Option<Vec<ImportSuggestion>>,\n-}\n-\n-pub(crate) struct ImportResolver<'a, 'b, 'tcx> {\n-    pub r: &'a mut Resolver<'b, 'tcx>,\n-}\n \n-impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     // Import resolution\n     //\n     // This is a fixed-point algorithm. We resolve imports until our efforts\n@@ -421,28 +415,28 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     pub(crate) fn resolve_imports(&mut self) {\n-        let mut prev_num_indeterminates = self.r.indeterminate_imports.len() + 1;\n-        while self.r.indeterminate_imports.len() < prev_num_indeterminates {\n-            prev_num_indeterminates = self.r.indeterminate_imports.len();\n-            for import in mem::take(&mut self.r.indeterminate_imports) {\n+        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n+        while self.indeterminate_imports.len() < prev_num_indeterminates {\n+            prev_num_indeterminates = self.indeterminate_imports.len();\n+            for import in mem::take(&mut self.indeterminate_imports) {\n                 match self.resolve_import(&import) {\n-                    true => self.r.determined_imports.push(import),\n-                    false => self.r.indeterminate_imports.push(import),\n+                    true => self.determined_imports.push(import),\n+                    false => self.indeterminate_imports.push(import),\n                 }\n             }\n         }\n     }\n \n     pub(crate) fn finalize_imports(&mut self) {\n-        for module in self.r.arenas.local_modules().iter() {\n+        for module in self.arenas.local_modules().iter() {\n             self.finalize_resolutions_in(module);\n         }\n \n         let mut seen_spans = FxHashSet::default();\n         let mut errors = vec![];\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n-        let determined_imports = mem::take(&mut self.r.determined_imports);\n-        let indeterminate_imports = mem::take(&mut self.r.indeterminate_imports);\n+        let determined_imports = mem::take(&mut self.determined_imports);\n+        let indeterminate_imports = mem::take(&mut self.indeterminate_imports);\n \n         for (is_indeterminate, import) in determined_imports\n             .into_iter()\n@@ -453,7 +447,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n             // If this import is unresolved then create a dummy import\n             // resolution for it so that later resolve stages won't complain.\n-            self.r.import_dummy_binding(import);\n+            self.import_dummy_binding(import);\n \n             if let Some(err) = unresolved_import_error {\n                 if let ImportKind::Single { source, ref source_bindings, .. } = import.kind {\n@@ -526,7 +520,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             .collect::<Vec<_>>();\n         let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n-        let mut diag = struct_span_err!(self.r.tcx.sess, span, E0432, \"{}\", &msg);\n+        let mut diag = struct_span_err!(self.tcx.sess, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n             diag.note(note);\n@@ -548,7 +542,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             if let Some(candidates) = &err.candidates {\n                 match &import.kind {\n                     ImportKind::Single { nested: false, source, target, .. } => import_candidates(\n-                        self.r.tcx,\n+                        self.tcx,\n                         &mut diag,\n                         Some(err.span),\n                         &candidates,\n@@ -560,7 +554,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     ),\n                     ImportKind::Single { nested: true, source, target, .. } => {\n                         import_candidates(\n-                            self.r.tcx,\n+                            self.tcx,\n                             &mut diag,\n                             None,\n                             &candidates,\n@@ -581,7 +575,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, import: &'b Import<'b>) -> bool {\n+    fn resolve_import(&mut self, import: &'a Import<'a>) -> bool {\n         debug!(\n             \"(resolving import for module) resolving import `{}::...` in `{}`\",\n             Segment::names_to_string(&import.module_path),\n@@ -594,8 +588,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.take();\n-            let path_res =\n-                self.r.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n+            let path_res = self.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -623,7 +616,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         };\n \n         let mut indeterminate = false;\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n                     // For better failure detection, pretend that the import will\n@@ -676,23 +669,23 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     ///\n     /// Optionally returns an unresolved import error. This error is buffered and used to\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n-    fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n+    fn finalize_import(&mut self, import: &'a Import<'a>) -> Option<UnresolvedImportError> {\n         let orig_vis = import.vis.take();\n         let ignore_binding = match &import.kind {\n             ImportKind::Single { target_bindings, .. } => target_bindings[TypeNS].get(),\n             _ => None,\n         };\n-        let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n+        let prev_ambiguity_errors_len = self.ambiguity_errors.len();\n         let finalize = Finalize::with_root_span(import.root_id, import.span, import.root_span);\n-        let path_res = self.r.resolve_path(\n+        let path_res = self.resolve_path(\n             &import.module_path,\n             None,\n             &import.parent_scope,\n             Some(finalize),\n             ignore_binding,\n         );\n \n-        let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n+        let no_ambiguity = self.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         import.vis.set(orig_vis);\n         let module = match path_res {\n             PathResult::Module(module) => {\n@@ -701,19 +694,18 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     if !ModuleOrUniformRoot::same_def(module, initial_module) && no_ambiguity {\n                         span_bug!(import.span, \"inconsistent resolution for an import\");\n                     }\n-                } else if self.r.privacy_errors.is_empty() {\n+                } else if self.privacy_errors.is_empty() {\n                     let msg = \"cannot determine resolution for the import\";\n                     let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                    self.r.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n+                    self.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                 }\n \n                 module\n             }\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n                     assert!(import.imported_module.get().is_none());\n-                    self.r\n-                        .report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n+                    self.report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n                 }\n                 return None;\n             }\n@@ -775,7 +767,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                         // 2 segments, so the `resolve_path` above won't trigger it.\n                         let mut full_path = import.module_path.clone();\n                         full_path.push(Segment::from_ident(Ident::empty()));\n-                        self.r.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n+                        self.lint_if_path_starts_with_module(Some(finalize), &full_path, None);\n                     }\n \n                     if let ModuleOrUniformRoot::Module(module) = module {\n@@ -794,18 +786,18 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     }\n                     if !is_prelude\n                     && let Some(max_vis) = max_vis.get()\n-                    && !max_vis.is_at_least(import.expect_vis(), &*self.r)\n+                    && !max_vis.is_at_least(import.expect_vis(), &*self)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n-                    self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n+                    self.lint_buffer.buffer_lint(UNUSED_IMPORTS, id, import.span, msg);\n                 }\n                     return None;\n                 }\n                 _ => unreachable!(),\n             };\n \n         let mut all_ns_err = true;\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n                 let orig_vis = import.vis.take();\n                 let binding = this.resolve_ident_in_module(\n@@ -874,7 +866,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n         if all_ns_err {\n             let mut all_ns_failed = true;\n-            self.r.per_ns(|this, ns| {\n+            self.per_ns(|this, ns| {\n                 if !type_ns_only || ns == TypeNS {\n                     let binding = this.resolve_ident_in_module(\n                         module,\n@@ -892,9 +884,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n             return if all_ns_failed {\n                 let resolutions = match module {\n-                    ModuleOrUniformRoot::Module(module) => {\n-                        Some(self.r.resolutions(module).borrow())\n-                    }\n+                    ModuleOrUniformRoot::Module(module) => Some(self.resolutions(module).borrow()),\n                     _ => None,\n                 };\n                 let resolutions = resolutions.as_ref().into_iter().flat_map(|r| r.iter());\n@@ -963,7 +953,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 };\n \n                 let parent_suggestion =\n-                    self.r.lookup_import_candidates(ident, TypeNS, &import.parent_scope, |_| true);\n+                    self.lookup_import_candidates(ident, TypeNS, &import.parent_scope, |_| true);\n \n                 Some(UnresolvedImportError {\n                     span: import.span,\n@@ -985,7 +975,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         let mut reexport_error = None;\n         let mut any_successful_reexport = false;\n         let mut crate_private_reexport = false;\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 if !binding.vis.is_at_least(import.expect_vis(), &*this) {\n                     reexport_error = Some((ns, binding));\n@@ -1010,7 +1000,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                                    `pub`\",\n                     ident\n                 );\n-                self.r.lint_buffer.buffer_lint(\n+                self.lint_buffer.buffer_lint(\n                     PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n                     import_id,\n                     import.span,\n@@ -1033,17 +1023,17 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                         format!(\"re-export of private `{}`\", ident)\n                     };\n \n-                    struct_span_err!(self.r.tcx.sess, import.span, E0365, \"{}\", error_msg)\n+                    struct_span_err!(self.tcx.sess, import.span, E0365, \"{}\", error_msg)\n                         .span_label(import.span, label_msg)\n                         .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                         .emit();\n                 } else {\n                     let mut err =\n-                        struct_span_err!(self.r.tcx.sess, import.span, E0364, \"{error_msg}\");\n+                        struct_span_err!(self.tcx.sess, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n                         NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n-                            if self.r.get_macro_by_def_id(def_id).macro_rules =>\n+                            if self.get_macro_by_def_id(def_id).macro_rules =>\n                         {\n                             err.span_help(\n                                 binding.span,\n@@ -1069,7 +1059,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             // 2 segments, so the `resolve_path` above won't trigger it.\n             let mut full_path = import.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n-            self.r.per_ns(|this, ns| {\n+            self.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(Some(finalize), &full_path, Some(binding));\n                 }\n@@ -1079,7 +1069,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 this.import_res_map.entry(import_id).or_default()[ns] = Some(binding.res());\n             }\n@@ -1094,9 +1084,9 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n     fn check_for_redundant_imports(\n         &mut self,\n         ident: Ident,\n-        import: &'b Import<'b>,\n-        source_bindings: &PerNS<Cell<Result<&'b NameBinding<'b>, Determinacy>>>,\n-        target_bindings: &PerNS<Cell<Option<&'b NameBinding<'b>>>>,\n+        import: &'a Import<'a>,\n+        source_bindings: &PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n+        target_bindings: &PerNS<Cell<Option<&'a NameBinding<'a>>>>,\n         target: Ident,\n     ) {\n         // This function is only called for single imports.\n@@ -1117,7 +1107,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n \n         let mut redundant_span = PerNS { value_ns: None, type_ns: None, macro_ns: None };\n \n-        self.r.per_ns(|this, ns| {\n+        self.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n                 if binding.res() == Res::Err {\n                     return;\n@@ -1147,7 +1137,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             let mut redundant_spans: Vec<_> = redundant_span.present_items().collect();\n             redundant_spans.sort();\n             redundant_spans.dedup();\n-            self.r.lint_buffer.buffer_lint_with_diagnostic(\n+            self.lint_buffer.buffer_lint_with_diagnostic(\n                 UNUSED_IMPORTS,\n                 id,\n                 import.span,\n@@ -1157,22 +1147,22 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn resolve_glob_import(&mut self, import: &'b Import<'b>) {\n+    fn resolve_glob_import(&mut self, import: &'a Import<'a>) {\n         // This function is only called for glob imports.\n         let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n \n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n-            self.r.tcx.sess.span_err(import.span, \"cannot glob-import all possible crates\");\n+            self.tcx.sess.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n         };\n \n         if module.is_trait() {\n-            self.r.tcx.sess.span_err(import.span, \"items in traits are not importable\");\n+            self.tcx.sess.span_err(import.span, \"items in traits are not importable\");\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;\n         } else if is_prelude {\n-            self.r.prelude = Some(module);\n+            self.prelude = Some(module);\n             return;\n         }\n \n@@ -1182,7 +1172,6 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n         let bindings = self\n-            .r\n             .resolutions(module)\n             .borrow()\n             .iter()\n@@ -1192,30 +1181,30 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             .collect::<Vec<_>>();\n         for (mut key, binding) in bindings {\n             let scope = match key.ident.span.reverse_glob_adjust(module.expansion, import.span) {\n-                Some(Some(def)) => self.r.expn_def_scope(def),\n+                Some(Some(def)) => self.expn_def_scope(def),\n                 Some(None) => import.parent_scope.module,\n                 None => continue,\n             };\n-            if self.r.is_accessible_from(binding.vis, scope) {\n-                let imported_binding = self.r.import(binding, import);\n-                let _ = self.r.try_define(import.parent_scope.module, key, imported_binding);\n+            if self.is_accessible_from(binding.vis, scope) {\n+                let imported_binding = self.import(binding, import);\n+                let _ = self.try_define(import.parent_scope.module, key, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        self.r.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n+        self.record_partial_res(id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,\n     // reporting conflicts, and reporting unresolved imports.\n-    fn finalize_resolutions_in(&mut self, module: Module<'b>) {\n+    fn finalize_resolutions_in(&mut self, module: Module<'a>) {\n         // Since import resolution is finished, globs will not define any more names.\n         *module.globs.borrow_mut() = Vec::new();\n \n         if let Some(def_id) = module.opt_def_id() {\n             let mut reexports = Vec::new();\n \n-            module.for_each_child(self.r, |this, ident, _, binding| {\n+            module.for_each_child(self, |this, ident, _, binding| {\n                 if let Some(res) = this.is_reexport(binding) {\n                     reexports.push(ModChild {\n                         ident,\n@@ -1230,7 +1219,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             if !reexports.is_empty() {\n                 // Call to `expect_local` should be fine because current\n                 // code is only called for local modules.\n-                self.r.reexport_map.insert(def_id.expect_local(), reexports);\n+                self.reexport_map.insert(def_id.expect_local(), reexports);\n             }\n         }\n     }"}, {"sha": "fae3a1900399512ba4a6481e04bdf53342a17f9a", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=d275114bda57e272b7a0a439d6b0a668bf988dd5", "patch": "@@ -57,7 +57,7 @@ use std::collections::BTreeSet;\n use std::{fmt, ptr};\n \n use diagnostics::{ImportSuggestion, LabelSuggestion, Suggestion};\n-use imports::{Import, ImportKind, ImportResolver, NameResolution};\n+use imports::{Import, ImportKind, NameResolution};\n use late::{HasGenericParams, PathSource, PatternSource};\n use macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n \n@@ -1486,9 +1486,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.tcx.sess.time(\"resolve_crate\", || {\n-            self.tcx\n-                .sess\n-                .time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n+            self.tcx.sess.time(\"finalize_imports\", || self.finalize_imports());\n             self.tcx.sess.time(\"compute_effective_visibilities\", || {\n                 EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });"}, {"sha": "b38c11e8bb8d4b6e4627cd630afebfdbc971dfe9", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d275114bda57e272b7a0a439d6b0a668bf988dd5/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=d275114bda57e272b7a0a439d6b0a668bf988dd5", "patch": "@@ -1,7 +1,6 @@\n //! A bunch of methods and structures more or less related to resolving macros and\n //! interface provided by `Resolver` to macro expander.\n \n-use crate::imports::ImportResolver;\n use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n@@ -233,7 +232,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n     }\n \n     fn resolve_imports(&mut self) {\n-        ImportResolver { r: self }.resolve_imports()\n+        self.resolve_imports()\n     }\n \n     fn resolve_macro_invocation("}]}