{"sha": "d80642b5196497e3b90bdc3ed47c60aedece2c57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4MDY0MmI1MTk2NDk3ZTNiOTBiZGMzZWQ0N2M2MGFlZGVjZTJjNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-29T05:16:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-29T05:16:50Z"}, "message": "auto merge of #6784 : nikomatsakis/rust/moves-into-borrowck, r=pcwalton\n\nMove the computation of what data is moved out of `liveness` and into `borrowck`. The resulting code is cleaner, since before we had a split distribution of responsibilities, and also this avoids having multiple implementations of the dataflow code. Liveness is still used to report warnings about useless writes. This will go away when we get the control-flow graph code landed (working on that).\r\n\r\nAlso adds borrow checker documentation.\r\n\r\nFixes #4384.\r\nRequired to support once fns and to properly fix closures (#2202).\r\nFirst step to generalize our treatment of moves somewhat as well.", "tree": {"sha": "d81caac44c5b30df30d97a718e00140882cbd7b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d81caac44c5b30df30d97a718e00140882cbd7b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d80642b5196497e3b90bdc3ed47c60aedece2c57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d80642b5196497e3b90bdc3ed47c60aedece2c57", "html_url": "https://github.com/rust-lang/rust/commit/d80642b5196497e3b90bdc3ed47c60aedece2c57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d80642b5196497e3b90bdc3ed47c60aedece2c57/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e946b4fa3f7d9a551fd8f039a2b15142d132f3fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e946b4fa3f7d9a551fd8f039a2b15142d132f3fb", "html_url": "https://github.com/rust-lang/rust/commit/e946b4fa3f7d9a551fd8f039a2b15142d132f3fb"}, {"sha": "f30b53892962ebe0511821c1a9d20b644ecb0e02", "url": "https://api.github.com/repos/rust-lang/rust/commits/f30b53892962ebe0511821c1a9d20b644ecb0e02", "html_url": "https://github.com/rust-lang/rust/commit/f30b53892962ebe0511821c1a9d20b644ecb0e02"}], "stats": {"total": 3566, "additions": 2203, "deletions": 1363}, "files": [{"sha": "00925a5700ada3d6730f6878f8478a6850ac1e66", "filename": "src/librust/rust.rc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -152,15 +152,15 @@ fn cmd_help(args: &[~str]) -> ValidUsage {\n     }\n \n     match args {\n-        [command_string] => print_usage(command_string),\n-        _                => Invalid\n+        [ref command_string] => print_usage(copy *command_string),\n+        _                    => Invalid\n     }\n }\n \n fn cmd_test(args: &[~str]) -> ValidUsage {\n     match args {\n-        [filename] => {\n-            let test_exec = Path(filename).filestem().unwrap() + \"test~\";\n+        [ref filename] => {\n+            let test_exec = Path(*filename).filestem().unwrap() + \"test~\";\n             invoke(\"rustc\", &[~\"--test\", filename.to_owned(),\n                               ~\"-o\", test_exec.to_owned()], rustc::main);\n             let exit_code = run::process_status(~\"./\" + test_exec, []);\n@@ -172,8 +172,8 @@ fn cmd_test(args: &[~str]) -> ValidUsage {\n \n fn cmd_run(args: &[~str]) -> ValidUsage {\n     match args {\n-        [filename, ..prog_args] => {\n-            let exec = Path(filename).filestem().unwrap() + \"~\";\n+        [ref filename, ..prog_args] => {\n+            let exec = Path(*filename).filestem().unwrap() + \"~\";\n             invoke(\"rustc\", &[filename.to_owned(), ~\"-o\", exec.to_owned()],\n                    rustc::main);\n             let exit_code = run::process_status(~\"./\"+exec, prog_args);"}, {"sha": "65838f62498dcd2470b9c10f8122a6eec62c1538", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -263,8 +263,8 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"loop checking\", ||\n              middle::check_loop::check_crate(ty_cx, crate));\n \n-        let middle::moves::MoveMaps {moves_map, variable_moves_map,\n-                                     moved_variables_set, capture_map} =\n+        let middle::moves::MoveMaps {moves_map, moved_variables_set,\n+                                     capture_map} =\n             time(time_passes, ~\"compute moves\", ||\n                  middle::moves::compute_moves(ty_cx, method_map, crate));\n \n@@ -274,7 +274,6 @@ pub fn compile_rest(sess: Session,\n \n         time(time_passes, ~\"liveness checking\", ||\n              middle::liveness::check_crate(ty_cx, method_map,\n-                                           variable_moves_map,\n                                            capture_map, crate));\n \n         let (root_map, write_guard_map) ="}, {"sha": "183771956eae0116aaae96eefeabeabab7985c59", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 121, "deletions": 120, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -33,20 +33,23 @@ use syntax::codemap::span;\n \n struct CheckLoanCtxt<'self> {\n     bccx: @BorrowckCtxt,\n-    dfcx: &'self LoanDataFlow,\n+    dfcx_loans: &'self LoanDataFlow,\n+    move_data: move_data::FlowedMoveData,\n     all_loans: &'self [Loan],\n     reported: @mut HashSet<ast::node_id>,\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-                   dfcx: &LoanDataFlow,\n+                   dfcx_loans: &LoanDataFlow,\n+                   move_data: move_data::FlowedMoveData,\n                    all_loans: &[Loan],\n                    body: &ast::blk) {\n     debug!(\"check_loans(body id=%?)\", body.node.id);\n \n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n-        dfcx: dfcx,\n+        dfcx_loans: dfcx_loans,\n+        move_data: move_data,\n         all_loans: all_loans,\n         reported: @mut HashSet::new(),\n     };\n@@ -62,8 +65,7 @@ pub fn check_loans(bccx: @BorrowckCtxt,\n \n enum MoveError {\n     MoveOk,\n-    MoveFromIllegalCmt(mc::cmt),\n-    MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/span)\n+    MoveWhileBorrowed(/*move*/@LoanPath, /*loan*/@LoanPath, /*loan*/span)\n }\n \n pub impl<'self> CheckLoanCtxt<'self> {\n@@ -79,7 +81,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         //! are issued for future scopes and thus they may have been\n         //! *issued* but not yet be in effect.\n \n-        for self.dfcx.each_bit_on_entry(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_bit_on_entry(scope_id) |loan_index| {\n             let loan = &self.all_loans[loan_index];\n             if !op(loan) {\n                 return false;\n@@ -131,7 +133,7 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         //! we encounter `scope_id`.\n \n         let mut result = ~[];\n-        for self.dfcx.each_gen_bit(scope_id) |loan_index| {\n+        for self.dfcx_loans.each_gen_bit(scope_id) |loan_index| {\n             result.push(loan_index);\n         }\n         return result;\n@@ -198,9 +200,9 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                loan1.repr(self.tcx()),\n                loan2.repr(self.tcx()));\n \n-        // Restrictions that would cause the new loan to be immutable:\n+        // Restrictions that would cause the new loan to be illegal:\n         let illegal_if = match loan2.mutbl {\n-            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_MUTATE,\n+            m_mutbl => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n             m_imm =>   RESTR_ALIAS | RESTR_FREEZE,\n             m_const => RESTR_ALIAS,\n         };\n@@ -251,6 +253,29 @@ pub impl<'self> CheckLoanCtxt<'self> {\n         }\n     }\n \n+    fn check_if_path_is_moved(&self,\n+                              id: ast::node_id,\n+                              span: span,\n+                              use_kind: MovedValueUseKind,\n+                              lp: @LoanPath) {\n+        /*!\n+         * Reports an error if `expr` (which should be a path)\n+         * is using a moved/uninitialized value\n+         */\n+\n+        debug!(\"check_if_path_is_moved(id=%?, use_kind=%?, lp=%s)\",\n+               id, use_kind, lp.repr(self.bccx.tcx));\n+        for self.move_data.each_move_of(id, lp) |move, moved_lp| {\n+            self.bccx.report_use_of_moved_value(\n+                span,\n+                use_kind,\n+                lp,\n+                move,\n+                moved_lp);\n+            return;\n+        }\n+    }\n+\n     fn check_assignment(&self, expr: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n@@ -261,48 +286,42 @@ pub impl<'self> CheckLoanCtxt<'self> {\n \n         debug!(\"check_assignment(cmt=%s)\", cmt.repr(self.tcx()));\n \n-        // check that the value being assigned is declared as mutable\n-        // and report an error otherwise.\n-        match cmt.mutbl {\n-            mc::McDeclared => {\n-                // OK, but we have to mark arguments as requiring mut\n-                // if they are assigned (other cases are handled by liveness,\n-                // since we need to distinguish local variables assigned\n-                // once vs those assigned multiple times)\n-                match cmt.cat {\n-                    mc::cat_self(*) |\n-                    mc::cat_arg(*) => {\n-                        mark_variable_as_used_mut(self, cmt);\n-                    }\n-                    _ => {}\n+        // Mutable values can be assigned, as long as they obey loans\n+        // and aliasing restrictions:\n+        if cmt.mutbl.is_mutable() {\n+            if check_for_aliasable_mutable_writes(self, expr, cmt) {\n+                if check_for_assignment_to_restricted_or_frozen_location(\n+                    self, expr, cmt)\n+                {\n+                    // Safe, but record for lint pass later:\n+                    mark_variable_as_used_mut(self, cmt);\n                 }\n             }\n-            mc::McInherited => {\n-                // OK, but we may have to add an entry to `used_mut_nodes`\n-                mark_variable_as_used_mut(self, cmt);\n-            }\n-            mc::McReadOnly | mc::McImmutable => {\n-                // Subtle: liveness guarantees that immutable local\n-                // variables are only assigned once, so no need to\n-                // report an error for an assignment to a local\n-                // variable (note also that it is not legal to borrow\n-                // for a local variable before it has been assigned\n-                // for the first time).\n-                if !self.is_local_variable(cmt) {\n-                    self.bccx.span_err(\n-                        expr.span,\n-                        fmt!(\"cannot assign to %s %s\"\n-                             cmt.mutbl.to_user_str(),\n-                             self.bccx.cmt_to_str(cmt)));\n-                }\n+            return;\n+        }\n+\n+        // For immutable local variables, assignments are legal\n+        // if they cannot already have been assigned\n+        if self.is_local_variable(cmt) {\n+            assert!(cmt.mutbl.is_immutable()); // no \"const\" locals\n+            let lp = opt_loan_path(cmt).get();\n+            for self.move_data.each_assignment_of(expr.id, lp) |assign| {\n+                self.bccx.report_reassigned_immutable_variable(\n+                    expr.span,\n+                    lp,\n+                    assign);\n                 return;\n             }\n+            return;\n         }\n \n-        if check_for_aliasable_mutable_writes(self, expr, cmt) {\n-            check_for_assignment_to_restricted_or_frozen_location(\n-                self, expr, cmt);\n-        }\n+        // Otherwise, just a plain error.\n+        self.bccx.span_err(\n+            expr.span,\n+            fmt!(\"cannot assign to %s %s\"\n+                 cmt.mutbl.to_user_str(),\n+                 self.bccx.cmt_to_str(cmt)));\n+        return;\n \n         fn mark_variable_as_used_mut(this: &CheckLoanCtxt,\n                                      cmt: mc::cmt) {\n@@ -538,18 +557,12 @@ pub impl<'self> CheckLoanCtxt<'self> {\n                 let cmt = self.bccx.cat_expr(ex);\n                 match self.analyze_move_out_from_cmt(cmt) {\n                     MoveOk => {}\n-                    MoveFromIllegalCmt(_) => {\n-                        self.bccx.span_err(\n-                            cmt.span,\n-                            fmt!(\"cannot move out of %s\",\n-                                 self.bccx.cmt_to_str(cmt)));\n-                    }\n-                    MoveWhileBorrowed(loan_path, loan_span) => {\n+                    MoveWhileBorrowed(move_path, loan_path, loan_span) => {\n                         self.bccx.span_err(\n                             cmt.span,\n                             fmt!(\"cannot move out of `%s` \\\n                                   because it is borrowed\",\n-                                 self.bccx.loan_path_to_str(loan_path)));\n+                                 self.bccx.loan_path_to_str(move_path)));\n                         self.bccx.span_note(\n                             loan_span,\n                             fmt!(\"borrow of `%s` occurs here\",\n@@ -561,37 +574,15 @@ pub impl<'self> CheckLoanCtxt<'self> {\n     }\n \n     fn analyze_move_out_from_cmt(&self, cmt: mc::cmt) -> MoveError {\n-        debug!(\"check_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n-\n-        match cmt.cat {\n-            // Rvalues, locals, and arguments can be moved:\n-            mc::cat_rvalue | mc::cat_local(_) |\n-            mc::cat_arg(_) | mc::cat_self(_) => {}\n-\n-            // It seems strange to allow a move out of a static item,\n-            // but what happens in practice is that you have a\n-            // reference to a constant with a type that should be\n-            // moved, like `None::<~int>`.  The type of this constant\n-            // is technically `Option<~int>`, which moves, but we know\n-            // that the content of static items will never actually\n-            // contain allocated pointers, so we can just memcpy it.\n-            mc::cat_static_item => {}\n-\n-            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {}\n-\n-            // Nothing else.\n-            _ => {\n-                return MoveFromIllegalCmt(cmt);\n-            }\n-        }\n+        debug!(\"analyze_move_out_from_cmt(cmt=%s)\", cmt.repr(self.tcx()));\n \n         // FIXME(#4384) inadequare if/when we permit `move a.b`\n \n         // check for a conflicting loan:\n         for opt_loan_path(cmt).each |&lp| {\n             for self.each_in_scope_restriction(cmt.id, lp) |loan, _| {\n                 // Any restriction prevents moves.\n-                return MoveWhileBorrowed(loan.loan_path, loan.span);\n+                return MoveWhileBorrowed(lp, loan.loan_path, loan.span);\n             }\n         }\n \n@@ -631,54 +622,53 @@ fn check_loans_in_fn<'a>(fk: &visit::fn_kind,\n \n         visit::fk_anon(*) |\n         visit::fk_fn_block(*) => {\n-            let fty = ty::node_id_to_type(this.tcx(), id);\n-            let fty_sigil = ty::ty_closure_sigil(fty);\n-            check_moves_from_captured_variables(this, id, fty_sigil);\n+            check_captured_variables(this, id, sp);\n         }\n     }\n \n     visit::visit_fn(fk, decl, body, sp, id, this, visitor);\n \n-    fn check_moves_from_captured_variables(this: @mut CheckLoanCtxt,\n-                                           id: ast::node_id,\n-                                           fty_sigil: ast::Sigil) {\n-        match fty_sigil {\n-            ast::ManagedSigil | ast::OwnedSigil => {\n-                let cap_vars = this.bccx.capture_map.get(&id);\n-                for cap_vars.each |cap_var| {\n-                    match cap_var.mode {\n-                        moves::CapRef | moves::CapCopy => { loop; }\n-                        moves::CapMove => { }\n-                    }\n-                    let def_id = ast_util::def_id_of_def(cap_var.def).node;\n-                    let ty = ty::node_id_to_type(this.tcx(), def_id);\n-                    let cmt = this.bccx.cat_def(id, cap_var.span,\n-                                                ty, cap_var.def);\n-                    let move_err = this.analyze_move_out_from_cmt(cmt);\n-                    match move_err {\n-                        MoveOk => {}\n-                        MoveFromIllegalCmt(move_cmt) => {\n-                            this.bccx.span_err(\n-                                cap_var.span,\n-                                fmt!(\"illegal by-move capture of %s\",\n-                                     this.bccx.cmt_to_str(move_cmt)));\n-                        }\n-                        MoveWhileBorrowed(loan_path, loan_span) => {\n-                            this.bccx.span_err(\n-                                cap_var.span,\n-                                fmt!(\"cannot move `%s` into closure \\\n-                                      because it is borrowed\",\n-                                     this.bccx.loan_path_to_str(loan_path)));\n-                            this.bccx.span_note(\n-                                loan_span,\n-                                fmt!(\"borrow of `%s` occurs here\",\n-                                     this.bccx.loan_path_to_str(loan_path)));\n-                        }\n-                    }\n+    fn check_captured_variables(this: @mut CheckLoanCtxt,\n+                                closure_id: ast::node_id,\n+                                span: span) {\n+        let cap_vars = this.bccx.capture_map.get(&closure_id);\n+        for cap_vars.each |cap_var| {\n+            match cap_var.mode {\n+                moves::CapRef | moves::CapCopy => {\n+                    let var_id = ast_util::def_id_of_def(cap_var.def).node;\n+                    let lp = @LpVar(var_id);\n+                    this.check_if_path_is_moved(closure_id, span,\n+                                                MovedInCapture, lp);\n+                }\n+                moves::CapMove => {\n+                    check_by_move_capture(this, closure_id, cap_var);\n+                }\n+            }\n+        }\n+        return;\n+\n+        fn check_by_move_capture(this: @mut CheckLoanCtxt,\n+                                 closure_id: ast::node_id,\n+                                 cap_var: &moves::CaptureVar) {\n+            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n+            let ty = ty::node_id_to_type(this.tcx(), var_id);\n+            let cmt = this.bccx.cat_def(closure_id, cap_var.span,\n+                                        ty, cap_var.def);\n+            let move_err = this.analyze_move_out_from_cmt(cmt);\n+            match move_err {\n+                MoveOk => {}\n+                MoveWhileBorrowed(move_path, loan_path, loan_span) => {\n+                    this.bccx.span_err(\n+                        cap_var.span,\n+                        fmt!(\"cannot move `%s` into closure \\\n+                              because it is borrowed\",\n+                             this.bccx.loan_path_to_str(move_path)));\n+                    this.bccx.span_note(\n+                        loan_span,\n+                        fmt!(\"borrow of `%s` occurs here\",\n+                             this.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n-\n-            ast::BorrowedSigil => {}\n         }\n     }\n }\n@@ -692,18 +682,29 @@ fn check_loans_in_local<'a>(local: @ast::local,\n fn check_loans_in_expr<'a>(expr: @ast::expr,\n                            this: @mut CheckLoanCtxt<'a>,\n                            vt: visit::vt<@mut CheckLoanCtxt<'a>>) {\n+    visit::visit_expr(expr, this, vt);\n+\n     debug!(\"check_loans_in_expr(expr=%s)\",\n            expr.repr(this.tcx()));\n \n-    visit::visit_expr(expr, this, vt);\n-\n     this.check_for_conflicting_loans(expr.id);\n \n     if this.bccx.moves_map.contains(&expr.id) {\n         this.check_move_out_from_expr(expr);\n     }\n \n     match expr.node {\n+      ast::expr_self |\n+      ast::expr_path(*) => {\n+          if !this.move_data.is_assignee(expr.id) {\n+              let cmt = this.bccx.cat_expr_unadjusted(expr);\n+              debug!(\"path cmt=%s\", cmt.repr(this.tcx()));\n+              for opt_loan_path(cmt).each |&lp| {\n+                  this.check_if_path_is_moved(expr.id, expr.span,\n+                                              MovedInUse, lp);\n+              }\n+          }\n+      }\n       ast::expr_assign(dest, _) |\n       ast::expr_assign_op(_, dest, _) => {\n         this.check_assignment(dest);"}, {"sha": "cb3983117e97c496c7817705df6916e8d440982a", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 750, "deletions": 638, "changes": 1388, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -13,13 +13,48 @@\n # The Borrow Checker\n \n This pass has the job of enforcing memory safety. This is a subtle\n-topic. The only way I know how to explain it is terms of a formal\n-model, so that's what I'll do.\n+topic. This docs aim to explain both the practice and the theory\n+behind the borrow checker. They start with a high-level overview of\n+how it works, and then proceed to dive into the theoretical\n+background. Finally, they go into detail on some of the more subtle\n+aspects.\n+\n+# Table of contents\n+\n+These docs are long. Search for the section you are interested in.\n+\n+- Overview\n+- Formal model\n+- Borrowing and loans\n+- Moves and initialization\n+- Future work\n+\n+# Overview\n+\n+The borrow checker checks one function at a time. It operates in two\n+passes. The first pass, called `gather_loans`, walks over the function\n+and identifies all of the places where borrows (e.g., `&` expressions\n+and `ref` bindings) and moves (copies or captures of a linear value)\n+occur. It also tracks initialization sites. For each borrow and move,\n+it checks various basic safety conditions at this time (for example,\n+that the lifetime of the borrow doesn't exceed the lifetime of the\n+value being borrowed, or that there is no move out of an `&T`\n+pointee).\n+\n+It then uses the dataflow module to propagate which of those borrows\n+may be in scope at each point in the procedure. A loan is considered\n+to come into scope at the expression that caused it and to go out of\n+scope when the lifetime of the resulting borrowed pointer expires.\n+\n+Once the in-scope loans are known for each point in the program, the\n+borrow checker walks the IR again in a second pass called\n+`check_loans`. This pass examines each statement and makes sure that\n+it is safe with respect to the in-scope loans.\n \n # Formal model\n \n-Let's consider a simple subset of Rust in which you can only borrow\n-from lvalues like so:\n+Throughout the docs we'll consider a simple subset of Rust in which\n+you can only borrow from lvalues, defined like so:\n \n     LV = x | LV.f | *LV\n \n@@ -42,9 +77,11 @@ struct name and we assume structs are declared like so:\n \n     SD = struct S<'LT...> { (f: TY)... }\n \n-# An intuitive explanation\n+# Borrowing and loans\n \n-## Issuing loans\n+## An intuitive explanation\n+\n+### Issuing loans\n \n Now, imagine we had a program like this:\n \n@@ -60,691 +97,766 @@ This is of course dangerous because mutating `x` will free the old\n value and hence invalidate `y`. The borrow checker aims to prevent\n this sort of thing.\n \n-### Loans\n+#### Loans and restrictions\n \n The way the borrow checker works is that it analyzes each borrow\n expression (in our simple model, that's stuff like `&LV`, though in\n real life there are a few other cases to consider). For each borrow\n-expression, it computes a vector of loans:\n-\n-    LOAN = (LV, LT, PT, LK)\n-    PT = Partial | Total\n-    LK = MQ | RESERVE\n-\n-Each `LOAN` tuple indicates some sort of restriction on what can be\n-done to the lvalue `LV`; `LV` will always be a path owned by the\n-current stack frame. These restrictions are called \"loans\" because\n-they are always the result of a borrow expression.\n-\n-Every loan has a lifetime `LT` during which those restrictions are in\n-effect.  The indicator `PT` distinguishes between *total* loans, in\n-which the LV itself was borrowed, and *partial* loans, which means\n-that some content ownwed by LV was borrowed.\n-\n-The final element in the loan tuple is the *loan kind* `LK`.  There\n-are four kinds: mutable, immutable, const, and reserve:\n-\n-- A \"mutable\" loan means that LV may be written to through an alias, and\n-  thus LV cannot be written to directly or immutably aliased (remember\n-  that we preserve the invariant that any given value can only be\n-  written to through one path at a time; hence if there is a mutable\n-  alias to LV, then LV cannot be written directly until this alias is\n-  out of scope).\n-\n-- An \"immutable\" loan means that LV must remain immutable.  Hence it\n-  cannot be written, but other immutable aliases are permitted.\n-\n-- A \"const\" loan means that an alias to LV exists.  LV may still be\n-  written or frozen.\n-\n-- A \"reserve\" loan is the strongest case.  It prevents both mutation\n-  and aliasing of any kind, including `&const` loans.  Reserve loans\n-  are a side-effect of borrowing an `&mut` loan.\n-\n-In addition to affecting mutability, a loan of any kind implies that\n-LV cannot be moved.\n-\n-### Example\n-\n-To give you a better feeling for what a loan is, let's look at three\n-loans that would be issued as a result of the borrow `&(*x).f` in the\n-example above:\n-\n-    ((*x).f, Total, mut, 'a)\n-    (*x, Partial, mut, 'a)\n-    (x, Partial, mut, 'a)\n-\n-The first loan states that the expression `(*x).f` has been loaned\n-totally as mutable for the lifetime `'a`. This first loan would\n-prevent an assignment `(*x).f = ...` from occurring during the\n-lifetime `'a`.\n-\n-Now let's look at the second loan. You may have expected that each\n-borrow would result in only one loan. But this is not the case.\n-Instead, there will be loans for every path where mutation might\n-affect the validity of the borrowed pointer that is created (in some\n-cases, there can even be multiple loans per path, see the section on\n-\"Borrowing in Calls\" below for the gory details). The reason for this\n-is to prevent actions that would indirectly affect the borrowed path.\n-In this case, we wish to ensure that `(*x).f` is not mutated except\n-through the mutable alias `y`.  Therefore, we must not only prevent an\n-assignment to `(*x).f` but also an assignment like `*x = Foo {...}`,\n-as this would also mutate the field `f`.  To do so, we issue a\n-*partial* mutable loan for `*x` (the loan is partial because `*x`\n-itself was not borrowed).  This partial loan will cause any attempt to\n-assign to `*x` to be flagged as an error.\n-\n-Because both partial and total loans prevent assignments, you may\n-wonder why we bother to distinguish between them.  The reason for this\n-distinction has to do with preventing double borrows. In particular,\n-it is legal to borrow both `&mut x.f` and `&mut x.g` simultaneously,\n-but it is not legal to borrow `&mut x.f` twice. In the borrow checker,\n-the first case would result in two *partial* mutable loans of `x`\n-(along with one total mutable loan of `x.f` and one of `x.g) whereas\n-the second would result in two *total* mutable loans of `x.f` (along\n-with two partial mutable loans of `x`).  Multiple *total mutable* loan\n-for the same path are not permitted, but multiple *partial* loans (of\n-any mutability) are permitted.\n-\n-Finally, we come to the third loan. This loan is a partial mutable\n-loan of `x`.  This loan prevents us from reassigning `x`, which would\n-be bad for two reasons.  First, it would change the value of `(*x).f`\n-but, even worse, it would cause the pointer `y` to become a dangling\n-pointer.  Bad all around.\n-\n-## Checking for illegal assignments, moves, and reborrows\n+expression, it computes a `Loan`, which is a data structure that\n+records (1) the value being borrowed, (2) the mutability and scope of\n+the borrow, and (3) a set of restrictions. In the code, `Loan` is a\n+struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n+follows:\n+\n+    LOAN = (LV, LT, MQ, RESTRICTION*)\n+    RESTRICTION = (LV, ACTION*)\n+    ACTION = MUTATE | CLAIM | FREEZE | ALIAS\n+\n+Here the `LOAN` tuple defines the lvalue `LV` being borrowed; the\n+lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n+list of restrictions. The restrictions indicate actions which, if\n+taken, could invalidate the loan and lead to type safety violations.\n+\n+Each `RESTRICTION` is a pair of a restrictive lvalue `LV` (which will\n+either be the path that was borrowed or some prefix of the path that\n+was borrowed) and a set of restricted actions.  There are three kinds\n+of actions that may be restricted for the path `LV`:\n+\n+- `MUTATE` means that `LV` cannot be assigned to;\n+- `CLAIM` means that the `LV` cannot be borrowed mutably;\n+- `FREEZE` means that the `LV` cannot be borrowed immutably;\n+- `ALIAS` means that `LV` cannot be aliased in any way (not even `&const`).\n+\n+Finally, it is never possible to move from an lvalue that appears in a\n+restriction. This implies that the \"empty restriction\" `(LV, [])`,\n+which contains an empty set of actions, still has a purpose---it\n+prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n+action because that would imply that sometimes moves are permitted\n+from restrictived values, which is not the case.\n+\n+#### Example\n+\n+To give you a better feeling for what kind of restrictions derived\n+from a loan, let's look at the loan `L` that would be issued as a\n+result of the borrow `&mut (*x).f` in the example above:\n+\n+    L = ((*x).f, 'a, mut, RS) where\n+        RS = [((*x).f, [MUTATE, CLAIM, FREEZE]),\n+              (*x, [MUTATE, CLAIM, FREEZE]),\n+              (x, [MUTATE, CLAIM, FREEZE])]\n+\n+The loan states that the expression `(*x).f` has been loaned as\n+mutable for the lifetime `'a`. Because the loan is mutable, that means\n+that the value `(*x).f` may be mutated via the newly created borrowed\n+pointer (and *only* via that pointer). This is reflected in the\n+restrictions `RS` that accompany the loan.\n+\n+The first restriction `((*x).f, [MUTATE, CLAIM, FREEZE])` states that\n+the lender may not mutate nor freeze `(*x).f`. Mutation is illegal\n+because `(*x).f` is only supposed to be mutated via the new borrowed\n+pointer, not by mutating the original path `(*x).f`. Freezing is\n+illegal because the path now has an `&mut` alias; so even if we the\n+lender were to consider `(*x).f` to be immutable, it might be mutated\n+via this alias. Both of these restrictions are temporary. They will be\n+enforced for the lifetime `'a` of the loan. After the loan expires,\n+the restrictions no longer apply.\n+\n+The second restriction on `*x` is interesting because it does not\n+apply to the path that was lent (`(*x).f`) but rather to a prefix of\n+the borrowed path. This is due to the rules of inherited mutability:\n+if the user were to assign to (or freeze) `*x`, they would indirectly\n+overwrite (or freeze) `(*x).f`, and thus invalidate the borrowed\n+pointer that was created. In general it holds that when a path is\n+lent, restrictions are issued for all the owning prefixes of that\n+path. In this case, the path `*x` owns the path `(*x).f` and,\n+because `x` is an owned pointer, the path `x` owns the path `*x`.\n+Therefore, borrowing `(*x).f` yields restrictions on both\n+`*x` and `x`.\n+\n+### Checking for illegal assignments, moves, and reborrows\n \n Once we have computed the loans introduced by each borrow, the borrow\n-checker will determine the full set of loans in scope at each\n-expression and use that to decide whether that expression is legal.\n-Remember that the scope of loan is defined by its lifetime LT.  We\n-sometimes say that a loan which is in-scope at a particular point is\n-an \"outstanding loan\".\n-\n-The kinds of expressions which in-scope loans can render illegal are\n-*assignments*, *moves*, and *borrows*.\n-\n-An assignments to an lvalue LV is illegal if there is in-scope mutable\n-or immutable loan for LV.  Assignment with an outstanding mutable loan\n-is illegal because then the `&mut` pointer is supposed to be the only\n-way to mutate the value.  Assignment with an outstanding immutable\n-loan is illegal because the value is supposed to be immutable at that\n-point.\n-\n-A move from an lvalue LV is illegal if there is any sort of\n-outstanding loan.\n-\n-A borrow expression may be illegal if any of the loans which it\n-produces conflict with other outstanding loans.  Two loans are\n-considered compatible if one of the following conditions holds:\n-\n-- At least one loan is a const loan.\n-- Both loans are partial loans.\n-- Both loans are immutable.\n-\n-Any other combination of loans is illegal.\n-\n-# The set of loans that results from a borrow expression\n-\n-Here we'll define four functions---MUTATE, FREEZE, ALIAS, and\n-TAKE---which are all used to compute the set of LOANs that result\n-from a borrow expression.  The first three functions each have\n-a similar type signature:\n-\n-    MUTATE(LV, LT, PT) -> LOANS\n-    FREEZE(LV, LT, PT) -> LOANS\n-    ALIAS(LV, LT, PT) -> LOANS\n-\n-MUTATE, FREEZE, and ALIAS are used when computing the loans result\n-from mutable, immutable, and const loans respectively.  For example,\n-the loans resulting from an expression like `&mut (*x).f` would be\n-computed by `MUTATE((*x).f, LT, Total)`, where `LT` is the lifetime of\n-the resulting pointer.  Similarly the loans for `&(*x).f` and `&const\n-(*x).f` would be computed by `FREEZE((*x).f, LT, Total)` and\n-`ALIAS((*x).f, LT, Total)` respectively. (Actually this is a slight\n-simplification; see the section below on Borrows in Calls for the full\n-gory details)\n-\n-The names MUTATE, FREEZE, and ALIAS are intended to suggest the\n-semantics of `&mut`, `&`, and `&const` borrows respectively.  `&mut`,\n-for example, creates a mutable alias of LV.  `&` causes the borrowed\n-value to be frozen (immutable).  `&const` does neither but does\n-introduce an alias to be the borrowed value.\n-\n-Each of these three functions is only defined for some inputs.  That\n-is, it may occur that some particular borrow is not legal.  For\n-example, it is illegal to make an `&mut` loan of immutable data.  In\n-that case, the MUTATE() function is simply not defined (in the code,\n-it returns a Result<> condition to indicate when a loan would be\n-illegal).\n-\n-The final function, RESERVE, is used as part of borrowing an `&mut`\n-pointer.  Due to the fact that it is used for one very particular\n-purpose, it has a rather simpler signature than the others:\n-\n-    RESERVE(LV, LT) -> LOANS\n-\n-It is explained when we come to that case.\n-\n-## The function MUTATE()\n-\n-Here we use [inference rules][ir] to define the MUTATE() function.\n-We will go case by case for the various kinds of lvalues that\n-can be borrowed.\n-\n-[ir]: http://en.wikipedia.org/wiki/Rule_of_inference\n-\n-### Mutating local variables\n-\n-The rule for mutating local variables is as follows:\n-\n-    Mutate-Variable:\n-      LT <= Scope(x)\n-      Mut(x) = Mut\n-      --------------------------------------------------\n-      MUTATE(x, LT, PT) = (x, LT, PT, mut)\n-\n-Here `Scope(x)` is the lifetime of the block in which `x` was declared\n-and `Mut(x)` indicates the mutability with which `x` was declared.\n-This rule simply states that you can only create a mutable alias\n-to a variable if it is mutable, and that alias cannot outlive the\n-stack frame in which the variable is declared.\n-\n-### Mutating fields and owned pointers\n-\n-As it turns out, the rules for mutating fields and mutating owned\n-pointers turn out to be quite similar.  The reason is that the\n-expressions `LV.f` and `*LV` are both owned by their base expression\n-`LV`.  So basically the result of mutating `LV.f` or `*LV` is computed\n-by adding a loan for `LV.f` or `*LV` and then the loans for a partial\n-take of `LV`:\n-\n-    Mutate-Field:\n-      MUTATE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      MUTATE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, mut)\n-\n-    Mutate-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      MUTATE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, mut)\n-\n-Note that while our micro-language only has fields, the slight\n-variations on the `Mutate-Field` rule are used for any interior content\n-that appears in the full Rust language, such as the contents of a\n-tuple, fields in a struct, or elements of a fixed-length vector.\n-\n-### Mutating dereferenced borrowed pointers\n-\n-The rule for borrowed pointers is by far the most complicated:\n-\n-    Mutate-Mut-Borrowed-Ptr:\n-      Type(LV) = &LT_P mut Ty             // (1)\n-      LT <= LT_P                          // (2)\n-      RESERVE(LV, LT) = LOANS             // (3)\n-      ------------------------------------------------------------\n-      MUTATE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n-\n-Condition (1) states that only a mutable borrowed pointer can be\n-taken.  Condition (2) states that the lifetime of the alias must be\n-less than the lifetime of the borrowed pointer being taken.\n-\n-Conditions (3) and (4) are where things get interesting.  The intended\n-semantics of the borrow is that the new `&mut` pointer is the only one\n-which has the right to modify the data; the original `&mut` pointer\n-must not be used for mutation.  Because borrowed pointers do not own\n-their content nor inherit mutability, we must be particularly cautious\n-of aliases, which could permit the original borrowed pointer to be\n-reached from another path and thus circumvent our loans.\n-\n-Here is one example of what could go wrong if we ignore clause (4):\n-\n-    let x: &mut T;\n-    ...\n-    let y = &mut *x;   // Only *y should be able to mutate...\n-    let z = &const x;\n-    **z = ...;         // ...but here **z is still able to mutate!\n+checker uses a data flow propagation to compute the full set of loans\n+in scope at each expression and then uses that set to decide whether\n+that expression is legal.  Remember that the scope of loan is defined\n+by its lifetime LT.  We sometimes say that a loan which is in-scope at\n+a particular point is an \"outstanding loan\", aand the set of\n+restrictions included in those loans as the \"outstanding\n+restrictions\".\n+\n+The kinds of expressions which in-scope loans can render illegal are:\n+- *assignments* (`lv = v`): illegal if there is an in-scope restriction\n+  against mutating `lv`;\n+- *moves*: illegal if there is any in-scope restriction on `lv` at all;\n+- *mutable borrows* (`&mut lv`): illegal there is an in-scope restriction\n+  against mutating `lv` or aliasing `lv`;\n+- *immutable borrows* (`&lv`): illegal there is an in-scope restriction\n+  against freezing `lv` or aliasing `lv`;\n+- *read-only borrows* (`&const lv`): illegal there is an in-scope restriction\n+  against aliasing `lv`.\n \n-Another possible error could occur with moves:\n+## Formal rules\n \n-    let x: &mut T;\n-    ...\n-    let y = &mut *x;   // Issues loan: (*x, LT, Total, Mut)\n-    let z = x;         // moves from x\n-    *z = ...;          // Mutates *y indirectly! Bad.\n-\n-In both of these cases, the problem is that when creating the alias\n-`y` we would only issue a loan preventing assignment through `*x`.\n-But this loan can be easily circumvented by moving from `x` or\n-aliasing it.  Note that, in the first example, the alias of `x` was\n-created using `&const`, which is a particularly weak form of alias.\n-\n-The danger of aliases can also occur when the `&mut` pointer itself\n-is already located in an alias location, as here:\n-\n-    let x: @mut &mut T; // or &mut &mut T, &&mut T,\n-    ...                 // &const &mut T, @&mut T, etc\n-    let y = &mut **x;   // Only *y should be able to mutate...\n-    let z = x;\n-    **z = ...;          // ...but here **z is still able to mutate!\n-\n-When we cover the rules for RESERVE, we will see that it would\n-disallow this case, because MUTATE can only be applied to canonical\n-lvalues which are owned by the current stack frame.\n-\n-It might be the case that if `&const` and `@const` pointers were\n-removed, we could do away with RESERVE and simply use MUTATE instead.\n-But we have to be careful about the final example in particular, since\n-dynamic freezing would not be sufficient to prevent this example.\n-Perhaps a combination of MUTATE with a predicate OWNED(LV).\n-\n-One final detail: unlike every other case, when we calculate the loans\n-using RESERVE we do not use the original lifetime `LT` but rather\n-`GLB(Scope(LV), LT)`.  What this says is:\n-\n-### Mutating dereferenced managed pointers\n-\n-Because the correctness of managed pointer loans is checked dynamically,\n-the rule is quite simple:\n-\n-    Mutate-Mut-Managed-Ptr:\n-      Type(LV) = @mut Ty\n-      Add ROOT-FREEZE annotation for *LV with lifetime LT\n-      ------------------------------------------------------------\n-      MUTATE(*LV, LT, Total) = []\n-\n-No loans are issued.  Instead, we add a side annotation that causes\n-`*LV` to be rooted and frozen on entry to LV.  You could rephrase\n-these rules as having multiple returns values, or rephrase this as a\n-kind of loan, but whatever.\n-\n-One interesting point is that *partial takes* of `@mut` are forbidden.\n-This is not for any soundness reason but just because it is clearer\n-for users when `@mut` values are either lent completely or not at all.\n-\n-## The function FREEZE\n-\n-The rules for FREEZE are pretty similar to MUTATE.  The first four\n-cases I'll just present without discussion, as the reasoning is\n-quite analogous to the MUTATE case:\n-\n-    Freeze-Variable:\n-      LT <= Scope(x)\n-      --------------------------------------------------\n-      FREEZE(x, LT, PT) = (x, LT, PT, imm)\n-\n-    Freeze-Field:\n-      FREEZE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      FREEZE(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, imm)\n-\n-    Freeze-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      FREEZE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, imm)\n-\n-    Freeze-Mut-Borrowed-Ptr:\n-      Type(LV) = &LT_P mut Ty\n-      LT <= LT_P\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Imm)\n-\n-    Freeze-Mut-Managed-Ptr:\n-      Type(LV) = @mut Ty\n-      Add ROOT-FREEZE annotation for *LV with lifetime LT\n-      ------------------------------------------------------------\n-      Freeze(*LV, LT, Total) = []\n-\n-The rule to \"freeze\" an immutable borrowed pointer is quite\n-simple, since the content is already immutable:\n-\n-    Freeze-Imm-Borrowed-Ptr:\n-      Type(LV) = &LT_P Ty                 // (1)\n-      LT <= LT_P                          // (2)\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = LOANS, (*LV, LT, PT, Mut)\n-\n-The final two rules pertain to borrows of `@Ty`.  There is a bit of\n-subtlety here.  The main problem is that we must guarantee that the\n-managed box remains live for the entire borrow.  We can either do this\n-dynamically, by rooting it, or (better) statically, and hence there\n-are two rules:\n-\n-    Freeze-Imm-Managed-Ptr-1:\n-      Type(LV) = @Ty\n-      Add ROOT annotation for *LV\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = []\n-\n-    Freeze-Imm-Managed-Ptr-2:\n-      Type(LV) = @Ty\n-      LT <= Scope(LV)\n-      Mut(LV) = imm\n-      LV is not moved\n-      ------------------------------------------------------------\n-      FREEZE(*LV, LT, PT) = []\n-\n-The intention of the second rule is to avoid an extra root if LV\n-serves as a root.  In that case, LV must (1) outlive the borrow; (2)\n-be immutable; and (3) not be moved.\n-\n-## The ALIAS function\n-\n-The function ALIAS is used for `&const` loans but also to handle one\n-corner case concerning function arguments (covered in the section\n-\"Borrows in Calls\" below).  It computes the loans that result from\n-observing that there is a pointer to `LV` and thus that pointer must\n-remain valid.\n-\n-The first two rules are simple:\n-\n-    Alias-Variable:\n-      LT <= Scope(x)\n-      --------------------------------------------------\n-      ALIAS(x, LT, PT) = (x, LT, PT, Const)\n-\n-    Alias-Field:\n-      ALIAS(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      ALIAS(LV.f, LT, PT) = LOANS, (LV.F, LT, PT, Const)\n-\n-### Aliasing owned pointers\n-\n-The rule for owned pointers is somewhat interesting:\n-\n-    Alias-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      FREEZE(LV, LT, Partial) = LOANS\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = LOANS, (*LV, LT, PT, Const)\n-\n-Here we *freeze* the base `LV`.  The reason is that if an owned\n-pointer is mutated it frees its content, which means that the alias to\n-`*LV` would become a dangling pointer.\n-\n-### Aliasing borrowed pointers\n-\n-The rule for borrowed pointers is quite simple, because borrowed\n-pointers do not own their content and thus do not play a role in\n-keeping it live:\n-\n-    Alias-Borrowed-Ptr:\n-      Type(LV) = &LT_P MQ Ty\n-      LT <= LT_P\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = []\n-\n-Basically, the existence of a borrowed pointer to some memory with\n-lifetime LT_P is proof that the memory can safely be aliased for any\n-lifetime LT <= LT_P.\n-\n-### Aliasing managed pointers\n-\n-The rules for aliasing managed pointers are similar to those\n-used with FREEZE, except that they apply to all manager pointers\n-regardles of mutability:\n-\n-    Alias-Managed-Ptr-1:\n-      Type(LV) = @MQ Ty\n-      Add ROOT annotation for *LV\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = []\n-\n-    Alias-Managed-Ptr-2:\n-      Type(LV) = @MQ Ty\n-      LT <= Scope(LV)\n-      Mut(LV) = imm\n-      LV is not moved\n-      ------------------------------------------------------------\n-      ALIAS(*LV, LT, PT) = []\n-\n-## The RESERVE function\n-\n-The final function, RESERVE, is used for loans of `&mut` pointers.  As\n-discussed in the section on the function MUTATE, we must be quite\n-careful when \"re-borrowing\" an `&mut` pointer to ensure that the original\n-`&mut` pointer can no longer be used to mutate.\n-\n-There are a couple of dangers to be aware of:\n-\n-- `&mut` pointers do not inherit mutability.  Therefore, if you have\n-  an lvalue LV with type `&mut T` and you freeze `LV`, you do *not*\n-  freeze `*LV`.  This is quite different from an `LV` with type `~T`.\n-\n-- Also, because they do not inherit mutability, if the `&mut` pointer\n-  lives in an aliased location, then *any alias* can be used to write!\n-\n-As a consequence of these two rules, RESERVE can only be successfully\n-invoked on an lvalue LV that is *owned by the current stack frame*.\n-This ensures that there are no aliases that are not visible from the\n-outside.  Moreover, Reserve loans are incompatible with all other\n-loans, even Const loans.  This prevents any aliases from being created\n-within the current function.\n+Now that we hopefully have some kind of intuitive feeling for how the\n+borrow checker works, let's look a bit more closely now at the precise\n+conditions that it uses. For simplicity I will ignore const loans.\n \n-### Reserving local variables\n+I will present the rules in a modified form of standard inference\n+rules, which looks as as follows:\n \n-The rule for reserving a variable is generally straightforward but\n-with one interesting twist:\n+    PREDICATE(X, Y, Z)                  // Rule-Name\n+      Condition 1\n+      Condition 2\n+      Condition 3\n+\n+The initial line states the predicate that is to be satisfied.  The\n+indented lines indicate the conditions that must be met for the\n+predicate to be satisfied. The right-justified comment states the name\n+of this rule: there are comments in the borrowck source referencing\n+these names, so that you can cross reference to find the actual code\n+that corresponds to the formal rule.\n+\n+### The `gather_loans` pass\n \n-    Reserve-Variable:\n-      --------------------------------------------------\n-      RESERVE(x, LT) = (x, LT, Total, Reserve)\n+We start with the `gather_loans` pass, which walks the AST looking for\n+borrows.  For each borrow, there are three bits of information: the\n+lvalue `LV` being borrowed and the mutability `MQ` and lifetime `LT`\n+of the resulting pointer. Given those, `gather_loans` applies three\n+validity tests:\n \n-The twist here is that the incoming lifetime is not required to\n-be a subset of the incoming variable, unlike every other case.  To\n-see the reason for this, imagine the following function:\n+1. `MUTABILITY(LV, MQ)`: The mutability of the borrowed pointer is\n+compatible with the mutability of `LV` (i.e., not borrowing immutable\n+data as mutable).\n \n-    struct Foo { count: uint }\n-    fn count_field(x: &'a mut Foo) -> &'a mut count {\n-        &mut (*x).count\n-    }\n+2. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n+the lifetime of the value being borrowed. This pass is also\n+responsible for inserting root annotations to keep managed values\n+alive and for dynamically freezing `@mut` boxes.\n \n-This function consumes one `&mut` pointer and returns another with the\n-same lifetime pointing at a particular field.  The borrow for the\n-`&mut` expression will result in a call to `RESERVE(x, 'a)`, which is\n-intended to guarantee that `*x` is not later aliased or used to\n-mutate.  But the lifetime of `x` is limited to the current function,\n-which is a sublifetime of the parameter `'a`, so the rules used for\n-MUTATE, FREEZE, and ALIAS (which require that the lifetime of the loan\n-not exceed the lifetime of the variable) would result in an error.\n+3. `RESTRICTIONS(LV, ACTIONS) = RS`: This pass checks and computes the\n+restrictions to maintain memory safety. These are the restrictions\n+that will go into the final loan. We'll discuss in more detail below.\n \n-Nonetheless this function is perfectly legitimate.  After all, the\n-caller has moved in an `&mut` pointer with lifetime `'a`, and thus has\n-given up their right to mutate the value for the remainder of `'a`.\n-So it is fine for us to return a pointer with the same lifetime.\n+## Checking mutability\n \n-The reason that RESERVE differs from the other functions is that\n-RESERVE is not responsible for guaranteeing that the pointed-to data\n-will outlive the borrowed pointer being created.  After all, `&mut`\n-values do not own the data they point at.\n+Checking mutability is fairly straightforward. We just want to prevent\n+immutable data from being borrowed as mutable. Note that it is ok to\n+borrow mutable data as immutable, since that is simply a\n+freeze. Formally we define a predicate `MUTABLE(LV, MQ)` which, if\n+defined, means that \"borrowing `LV` with mutability `MQ` is ok. The\n+Rust code corresponding to this predicate is the function\n+`check_mutability` in `middle::borrowck::gather_loans`.\n \n-### Reserving owned content\n+### Checking mutability of variables\n \n-The rules for fields and owned pointers are very straightforward:\n+*Code pointer:* Function `check_mutability()` in `gather_loans/mod.rs`,\n+but also the code in `mem_categorization`.\n \n-    Reserve-Field:\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      RESERVE(LV.f, LT) = LOANS, (LV.F, LT, Total, Reserve)\n+Let's begin with the rules for variables, which state that if a\n+variable is declared as mutable, it may be borrowed any which way, but\n+otherwise the variable must be borrowed as immutable or const:\n \n-    Reserve-Owned-Ptr:\n-      Type(LV) = ~Ty\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+    MUTABILITY(X, MQ)                   // M-Var-Mut\n+      DECL(X) = mut\n \n-### Reserving `&mut` borrowed pointers\n+    MUTABILITY(X, MQ)                   // M-Var-Imm\n+      DECL(X) = imm\n+      MQ = imm | const\n \n-Unlike other borrowed pointers, `&mut` pointers are unaliasable,\n-so we can reserve them like everything else:\n+### Checking mutability of owned content\n \n-    Reserve-Mut-Borrowed-Ptr:\n-      Type(LV) = &LT_P mut Ty\n-      RESERVE(LV, LT) = LOANS\n-      ------------------------------------------------------------\n-      RESERVE(*LV, LT) = LOANS, (*LV, LT, Total, Reserve)\n+Fields and owned pointers inherit their mutability from\n+their base expressions, so both of their rules basically\n+delegate the check to the base expression `LV`:\n \n-## Borrows in calls\n+    MUTABILITY(LV.f, MQ)                // M-Field\n+      MUTABILITY(LV, MQ)\n \n-Earlier we said that the MUTATE, FREEZE, and ALIAS functions were used\n-to compute the loans resulting from a borrow expression.  But this is\n-not strictly correct, there is a slight complication that occurs with\n-calls by which additional loans may be necessary.  We will explain\n-that here and give the full details.\n+    MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n+      TYPE(LV) = ~Ty\n+      MUTABILITY(LV, MQ)\n \n-Imagine a call expression `'a: E1(E2, E3)`, where `Ei` are some\n-expressions. If we break this down to something a bit lower-level, it\n-is kind of short for:\n+### Checking mutability of immutable pointer types\n \n-    'a: {\n-        'a_arg1: let temp1: ... = E1;\n-        'a_arg2: let temp2: ... = E2;\n-        'a_arg3: let temp3: ... = E3;\n-        'a_call: temp1(temp2, temp3)\n-    }\n+Immutable pointer types like `&T` and `@T` can only\n+be borrowed if MQ is immutable or const:\n \n-Here the lifetime labels indicate the various lifetimes. As you can\n-see there are in fact four relevant lifetimes (only one of which was\n-named by the user): `'a` corresponds to the expression `E1(E2, E3)` as\n-a whole. `'a_arg1`, `'a_arg2`, and `'a_arg3` correspond to the\n-evaluations of `E1`, `E2`, and `E3` respectively. Finally, `'a_call`\n-corresponds to the *actual call*, which is the point where the values\n-of the parameters will be used.\n+    MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n+      TYPE(LV) = &Ty\n+      MQ == imm | const\n \n-Now, let's look at a (contrived, but representative) example to see\n-why all this matters:\n+    MUTABILITY(*LV, MQ)                // M-Deref-Managed-Imm\n+      TYPE(LV) = @Ty\n+      MQ == imm | const\n \n-    struct Foo { f: uint, g: uint }\n-    ...\n-    fn add(p: &mut uint, v: uint) {\n-        *p += v;\n-    }\n-    ...\n-    fn inc(p: &mut uint) -> uint {\n-        *p += 1; *p\n-    }\n-    fn weird() {\n-        let mut x: ~Foo = ~Foo { ... };\n-        'a: add(&mut (*x).f,\n-                'b: inc(&mut (*x).f)) // (*)\n-    }\n+### Checking mutability of mutable pointer types\n \n-The important part is the line marked `(*)` which contains a call to\n-`add()`. The first argument is a mutable borrow of the field `f`.\n-The second argument *always borrows* the field `f`. Now, if these two\n-borrows overlapped in time, this would be illegal, because there would\n-be two `&mut` pointers pointing at `f`. And, in a way, they *do*\n-overlap in time, since the first argument will be evaluated first,\n-meaning that the pointer will exist when the second argument executes.\n-But in another important way they do not overlap in time. Let's\n-expand out that final call to `add()` as we did before:\n+`&mut T` and `@mut T` can be frozen, so it is acceptable to borrow\n+them as either imm or mut:\n \n-    'a: {\n-        'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n-        'a_arg3_: let a_temp3: uint = {\n-            let b_temp1: ... = inc;\n-            let b_temp2: &'b_call = &'b_call mut (*x).f;\n-            'b_call: b_temp1(b_temp2)\n-        };\n-        'a_call: a_temp1(a_temp2, a_temp3)\n-    }\n+    MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n+      TYPE(LV) = &mut Ty\n \n-When it's written this way, we can see that although there are two\n-borrows, the first has lifetime `'a_call` and the second has lifetime\n-`'b_call` and in fact these lifetimes do not overlap. So everything\n-is fine.\n+    MUTABILITY(*LV, MQ)                 // M-Deref-Managed-Mut\n+      TYPE(LV) = @mut Ty\n \n-But this does not mean that there isn't reason for caution!  Imagine a\n-devious program like *this* one:\n+## Checking lifetime\n \n-    struct Foo { f: uint, g: uint }\n-    ...\n-    fn add(p: &mut uint, v: uint) {\n-        *p += v;\n+These rules aim to ensure that no data is borrowed for a scope that\n+exceeds its lifetime. In addition, these rules manage the rooting and\n+dynamic freezing of `@` and `@mut` values. These two computations wind\n+up being intimately related. Formally, we define a predicate\n+`LIFETIME(LV, LT, MQ)`, which states that \"the lvalue `LV` can be\n+safely borrowed for the lifetime `LT` with mutability `MQ`\". The Rust\n+code corresponding to this predicate is the module\n+`middle::borrowck::gather_loans::lifetime`.\n+\n+### The Scope function\n+\n+Several of the rules refer to a helper function `SCOPE(LV)=LT`.  The\n+`SCOPE(LV)` yields the lifetime `LT` for which the lvalue `LV` is\n+guaranteed to exist, presuming that no mutations occur.\n+\n+The scope of a local variable is the block where it is declared:\n+\n+      SCOPE(X) = block where X is declared\n+\n+The scope of a field is the scope of the struct:\n+\n+      SCOPE(LV.f) = SCOPE(LV)\n+\n+The scope of a unique pointee is the scope of the pointer, since\n+(barring mutation or moves) the pointer will not be freed until\n+the pointer itself `LV` goes out of scope:\n+\n+      SCOPE(*LV) = SCOPE(LV) if LV has type ~T\n+\n+The scope of a managed pointee is also the scope of the pointer.  This\n+is a conservative approximation, since there may be other aliases fo\n+that same managed box that would cause it to live longer:\n+\n+      SCOPE(*LV) = SCOPE(LV) if LV has type @T or @mut T\n+\n+The scope of a borrowed pointee is the scope associated with the\n+pointer.  This is a conservative approximation, since the data that\n+the pointer points at may actually live longer:\n+\n+      SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n+\n+### Checking lifetime of variables\n+\n+The rule for variables states that a variable can only be borrowed a\n+lifetime `LT` that is a subregion of the variable's scope:\n+\n+    LIFETIME(X, LT, MQ)                 // L-Local\n+      LT <= SCOPE(X)\n+\n+### Checking lifetime for owned content\n+\n+The lifetime of a field or owned pointer is the same as the lifetime\n+of its owner:\n+\n+    LIFETIME(LV.f, LT, MQ)              // L-Field\n+      LIFETIME(LV, LT, MQ)\n+\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Owned\n+      TYPE(LV) = ~Ty\n+      LIFETIME(LV, LT, MQ)\n+\n+### Checking lifetime for derefs of borrowed pointers\n+\n+Borrowed pointers have a lifetime `LT'` associated with them.  The\n+data they point at has been guaranteed to be valid for at least this\n+lifetime. Therefore, the borrow is valid so long as the lifetime `LT`\n+of the borrow is shorter than the lifetime `LT'` of the pointer\n+itself:\n+\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n+      TYPE(LV) = &LT' Ty OR &LT' mut Ty\n+      LT <= LT'\n+\n+### Checking lifetime for derefs of managed, immutable pointers\n+\n+Managed pointers are valid so long as the data within them is\n+*rooted*. There are two ways that this can be achieved. The first is\n+when the user guarantees such a root will exist. For this to be true,\n+three conditions must be met:\n+\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-User-Root\n+      TYPE(LV) = @Ty\n+      LT <= SCOPE(LV)                   // (1)\n+      LV is immutable                   // (2)\n+      LV is not moved or not movable    // (3)\n+\n+Condition (1) guarantees that the managed box will be rooted for at\n+least the lifetime `LT` of the borrow, presuming that no mutation or\n+moves occur. Conditions (2) and (3) then serve to guarantee that the\n+value is not mutated or moved. Note that lvalues are either\n+(ultimately) owned by a local variable, in which case we can check\n+whether that local variable is ever moved in its scope, or they are\n+owned by the pointee of an (immutable, due to condition 2) managed or\n+borrowed pointer, in which case moves are not permitted because the\n+location is aliasable.\n+\n+If the conditions of `L-Deref-Managed-Imm-User-Root` are not met, then\n+there is a second alternative. The compiler can attempt to root the\n+managed pointer itself. This permits great flexibility, because the\n+location `LV` where the managed pointer is found does not matter, but\n+there are some limitations. The lifetime of the borrow can only extend\n+to the innermost enclosing loop or function body. This guarantees that\n+the compiler never requires an unbounded amount of stack space to\n+perform the rooting; if this condition were violated, the compiler\n+might have to accumulate a list of rooted objects, for example if the\n+borrow occurred inside the body of a loop but the scope of the borrow\n+extended outside the loop. More formally, the requirement is that\n+there is no path starting from the borrow that leads back to the\n+borrow without crossing the exit from the scope `LT`.\n+\n+The rule for compiler rooting is as follows:\n+\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Managed-Imm-Compiler-Root\n+      TYPE(LV) = @Ty\n+      LT <= innermost enclosing loop/func\n+      ROOT LV at *LV for LT\n+\n+Here I have written `ROOT LV at *LV FOR LT` to indicate that the code\n+makes a note in a side-table that the box `LV` must be rooted into the\n+stack when `*LV` is evaluated, and that this root can be released when\n+the scope `LT` exits.\n+\n+### Checking lifetime for derefs of managed, mutable pointers\n+\n+Loans of the contents of mutable managed pointers are simpler in some\n+ways that loans of immutable managed pointers, because we can never\n+rely on the user to root them (since the contents are, after all,\n+mutable). This means that the burden always falls to the compiler, so\n+there is only one rule:\n+\n+    LIFETIME(*LV, LT, MQ)              // L-Deref-Managed-Mut-Compiler-Root\n+      TYPE(LV) = @mut Ty\n+      LT <= innermost enclosing loop/func\n+      ROOT LV at *LV for LT\n+      LOCK LV at *LV as MQ for LT\n+\n+Note that there is an additional clause this time `LOCK LV at *LV as\n+MQ for LT`.  This clause states that in addition to rooting `LV`, the\n+compiler should also \"lock\" the box dynamically, meaning that we\n+register that the box has been borrowed as mutable or immutable,\n+depending on `MQ`. This lock will fail if the box has already been\n+borrowed and either the old loan or the new loan is a mutable loan\n+(multiple immutable loans are okay). The lock is released as we exit\n+the scope `LT`.\n+\n+## Computing the restrictions\n+\n+The final rules govern the computation of *restrictions*, meaning that\n+we compute the set of actions that will be illegal for the life of the\n+loan. The predicate is written `RESTRICTIONS(LV, ACTIONS) =\n+RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n+occuring on `LV`, the restrictions `RESTRICTION*` must be respected\n+for the lifetime of the loan\".\n+\n+Note that there is an initial set of restrictions: these restrictions\n+are computed based on the kind of borrow:\n+\n+    &mut LV =>   RESTRICTIONS(LV, MUTATE|CLAIM|FREEZE)\n+    &LV =>       RESTRICTIONS(LV, MUTATE|CLAIM)\n+    &const LV => RESTRICTIONS(LV, [])\n+\n+The reasoning here is that a mutable borrow must be the only writer,\n+therefore it prevents other writes (`MUTATE`), mutable borrows\n+(`CLAIM`), and immutable borrows (`FREEZE`). An immutable borrow\n+permits other immutable borows but forbids writes and mutable borows.\n+Finally, a const borrow just wants to be sure that the value is not\n+moved out from under it, so no actions are forbidden.\n+\n+### Restrictions for loans of a local variable\n+\n+The simplest case is a borrow of a local variable `X`:\n+\n+    RESTRICTIONS(X, ACTIONS) = (X, ACTIONS)            // R-Variable\n+\n+In such cases we just record the actions that are not permitted.\n+\n+### Restrictions for loans of fields\n+\n+Restricting a field is the same as restricting the owner of that\n+field:\n+\n+    RESTRICTIONS(LV.f, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n+      RESTRICTIONS(LV, ACTIONS) = RS\n+\n+The reasoning here is as follows. If the field must not be mutated,\n+then you must not mutate the owner of the field either, since that\n+would indirectly modify the field. Similarly, if the field cannot be\n+frozen or aliased, we cannot allow the owner to be frozen or aliased,\n+since doing so indirectly freezes/aliases the field. This is the\n+origin of inherited mutability.\n+\n+### Restrictions for loans of owned pointees\n+\n+Because the mutability of owned pointees is inherited, restricting an\n+owned pointee is similar to restricting a field, in that it implies\n+restrictions on the pointer. However, owned pointers have an important\n+twist: if the owner `LV` is mutated, that causes the owned pointee\n+`*LV` to be freed! So whenever an owned pointee `*LV` is borrowed, we\n+must prevent the owned pointer `LV` from being mutated, which means\n+that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n+on `LV`:\n+\n+    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Owned-Pointer\n+      TYPE(LV) = ~Ty\n+      RESTRICTIONS(LV, ACTIONS|MUTATE|CLAIM) = RS\n+\n+### Restrictions for loans of immutable managed/borrowed pointees\n+\n+Immutable managed/borrowed pointees are freely aliasable, meaning that\n+the compiler does not prevent you from copying the pointer.  This\n+implies that issuing restrictions is useless. We might prevent the\n+user from acting on `*LV` itself, but there could be another path\n+`*LV1` that refers to the exact same memory, and we would not be\n+restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n+pointers always returns an empty set of restrictions, and it only\n+permits restricting `MUTATE` and `CLAIM` actions:\n+\n+    RESTRICTIONS(*LV, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+      TYPE(LV) = &Ty or @Ty\n+      ACTIONS subset of [MUTATE, CLAIM]\n+\n+The reason that we can restrict `MUTATE` and `CLAIM` actions even\n+without a restrictions list is that it is never legal to mutate nor to\n+borrow mutably the contents of a `&Ty` or `@Ty` pointer. In other\n+words, those restrictions are already inherent in the type.\n+\n+Typically, this limitation is not an issue, because restrictions other\n+than `MUTATE` or `CLAIM` typically arise due to `&mut` borrow, and as\n+we said, that is already illegal for `*LV`. However, there is one case\n+where we can be asked to enforce an `ALIAS` restriction on `*LV`,\n+which is when you have a type like `&&mut T`. In such cases we will\n+report an error because we cannot enforce a lack of aliases on a `&Ty`\n+or `@Ty` type. That case is described in more detail in the section on\n+mutable borrowed pointers.\n+\n+### Restrictions for loans of const aliasable pointees\n+\n+Const pointers are read-only. There may be `&mut` or `&` aliases, and\n+we can not prevent *anything* but moves in that case. So the\n+`RESTRICTIONS` function is only defined if `ACTIONS` is the empty set.\n+Because moves from a `&const` or `@const` lvalue are never legal, it\n+is not necessary to add any restrictions at all to the final\n+result.\n+\n+    RESTRICTIONS(*LV, []) = []                         // R-Deref-Const-Borrowed\n+      TYPE(LV) = &const Ty or @const Ty\n+\n+### Restrictions for loans of mutable borrowed pointees\n+\n+Borrowing mutable borrowed pointees is a bit subtle because we permit\n+users to freeze or claim `&mut` pointees. To see what I mean, consider this\n+(perfectly safe) code example:\n+\n+    fn foo(t0: &mut T, op: fn(&T)) {\n+        let t1: &T = &*t0; // (1)\n+        op(t1);\n     }\n-    ...\n-    fn consume(x: ~Foo) -> uint {\n-        x.f + x.g\n+\n+In the borrow marked `(1)`, the data at `*t0` is *frozen* as part of a\n+re-borrow. Therefore, for the lifetime of `t1`, `*t0` must not be\n+mutated. This is the same basic idea as when we freeze a mutable local\n+variable, but unlike in that case `t0` is a *pointer* to the data, and\n+thus we must enforce some subtle restrictions in order to guarantee\n+soundness.\n+\n+Intuitively, we must ensure that `*t0` is the only *mutable* path to\n+reach the memory that was frozen. The reason that we are so concerned\n+with *mutable* paths is that those are the paths through which the\n+user could mutate the data that was frozen and hence invalidate the\n+`t1` pointer. Note that const aliases to `*t0` are acceptable (and in\n+fact we can't prevent them without unacceptable performance cost, more\n+on that later) because\n+\n+There are two rules governing `&mut` pointers, but we'll begin with\n+the first. This rule governs cases where we are attempting to prevent\n+an `&mut` pointee from being mutated, claimed, or frozen, as occurs\n+whenever the `&mut` pointee `*LV` is reborrowed as mutable or\n+immutable:\n+\n+    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed-1\n+      TYPE(LV) = &mut Ty\n+      RESTRICTIONS(LV, MUTATE|CLAIM|ALIAS) = RS\n+\n+The main interesting part of the rule is the final line, which\n+requires that the `&mut` *pointer* `LV` be restricted from being\n+mutated, claimed, or aliased. The goal of these restrictions is to\n+ensure that, not considering the pointer that will result from this\n+borrow, `LV` remains the *sole pointer with mutable access* to `*LV`.\n+\n+Restrictions against mutations and claims are necessary because if the\n+pointer in `LV` were to be somehow copied or moved to a different\n+location, then the restriction issued for `*LV` would not apply to the\n+new location. Note that because `&mut` values are non-copyable, a\n+simple attempt to move the base pointer will fail due to the\n+(implicit) restriction against moves:\n+\n+    // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n+    fn foo(t0: &mut int) {\n+        let p: &int = &*t0; // Freezes `*t0`\n+        let t1 = t0;        //~ ERROR cannot move out of `t0`\n+        *t1 = 22;\n     }\n-    fn weird() {\n-        let mut x: ~Foo = ~Foo { ... };\n-        'a: add(&mut (*x).f, consume(x)) // (*)\n+\n+However, the additional restrictions against mutation mean that even a\n+clever attempt to use a swap to circumvent the type system will\n+encounter an error:\n+\n+    // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n+    fn foo<'a>(mut t0: &'a mut int,\n+               mut t1: &'a mut int) {\n+        let p: &int = &*t0;     // Freezes `*t0`\n+        swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+        *t1 = 22;\n     }\n \n-In this case, there is only one borrow, but the second argument is\n-`consume(x)` instead of a second borrow. Because `consume()` is\n-declared to take a `~Foo`, it will in fact free the pointer `x` when\n-it has finished executing. If it is not obvious why this is\n-troublesome, consider this expanded version of that call:\n+The restriction against *aliasing* (and, in turn, freezing) is\n+necessary because, if an alias were of `LV` were to be produced, then\n+`LV` would no longer be the sole path to access the `&mut`\n+pointee. Since we are only issuing restrictions against `*LV`, these\n+other aliases would be unrestricted, and the result would be\n+unsound. For example:\n+\n+    // src/test/compile-fail/borrowck-alias-mut-base-ptr.rs\n+    fn foo(t0: &mut int) {\n+        let p: &int = &*t0; // Freezes `*t0`\n+        let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n+        **q = 22; // (*)\n+    }\n \n-    'a: {\n-        'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a_call mut uint = &'a_call mut (*x).f;\n-        'a_arg3_: let a_temp3: uint = {\n-            let b_temp1: ... = consume;\n-            let b_temp2: ~Foo = x;\n-            'b_call: b_temp1(x)\n-        };\n-        'a_call: a_temp1(a_temp2, a_temp3)\n+Note that the current rules also report an error at the assignment in\n+`(*)`, because we only permit `&mut` poiners to be assigned if they\n+are located in a non-aliasable location. However, I do not believe\n+this restriction is strictly necessary. It was added, I believe, to\n+discourage `&mut` from being placed in aliasable locations in the\n+first place. One (desirable) side-effect of restricting aliasing on\n+`LV` is that borrowing an `&mut` pointee found inside an aliasable\n+pointee yields an error:\n+\n+    // src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc:\n+    fn foo(t0: & &mut int) {\n+        let t1 = t0;\n+        let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&` pointer\n+        **t1 = 22; // (*)\n     }\n \n-In this example, we will have borrowed the first argument before `x`\n-is freed and then free `x` during evaluation of the second\n-argument. This causes `a_temp2` to be invalidated.\n+Here at the line `(*)` you will also see the error I referred to\n+above, which I do not believe is strictly necessary.\n+\n+The second rule for `&mut` handles the case where we are not adding\n+any restrictions (beyond the default of \"no move\"):\n \n-Of course the loans computed from the borrow expression are supposed\n-to prevent this situation.  But if we just considered the loans from\n-`MUTATE((*x).f, 'a_call, Total)`, the resulting loans would be:\n+    RESTRICTIONS(*LV, []) = []                    // R-Deref-Mut-Borrowed-2\n+      TYPE(LV) = &mut Ty\n \n-    ((*x).f, 'a_call, Total,   Mut)\n-    (*x,     'a_call, Partial, Mut)\n-    (x,      'a_call, Partial, Mut)\n+Moving from an `&mut` pointee is never legal, so no special\n+restrictions are needed.\n \n-Because these loans are only in scope for `'a_call`, they do nothing\n-to prevent the move that occurs evaluating the second argument.\n+### Restrictions for loans of mutable managed pointees\n \n-The way that we solve this is to say that if you have a borrow\n-expression `&'LT_P mut LV` which itself occurs in the lifetime\n-`'LT_B`, then the resulting loans are:\n+With `@mut` pointees, we don't make any static guarantees.  But as a\n+convenience, we still register a restriction against `*LV`, because\n+that way if we *can* find a simple static error, we will:\n \n-    MUTATE(LV, LT_P, Total) + ALIAS(LV, LUB(LT_P, LT_B), Total)\n+    RESTRICTIONS(*LV, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n+      TYPE(LV) = @mut Ty\n \n-The call to MUTATE is what we've seen so far.  The second part\n-expresses the idea that the expression LV will be evaluated starting\n-at LT_B until the end of LT_P.  Now, in the normal case, LT_P >= LT_B,\n-and so the second set of loans that result from a ALIAS are basically\n-a no-op.  However, in the case of an argument where the evaluation of\n-the borrow occurs before the interval where the resulting pointer will\n-be used, this ALIAS is important.\n+# Moves and initialization\n \n-In the case of our example, it would produce a set of loans like:\n+The borrow checker is also in charge of ensuring that:\n \n-    ((*x).f, 'a, Total, Const)\n-    (*x, 'a, Total, Const)\n-    (x, 'a, Total, Imm)\n+- all memory which is accessed is initialized\n+- immutable local variables are assigned at most once.\n \n-The scope of these loans is `'a = LUB('a_arg2, 'a_call)`, and so they\n-encompass all subsequent arguments.  The first set of loans are Const\n-loans, which basically just prevent moves.  However, when we cross\n-over the dereference of the owned pointer `x`, the rule for ALIAS\n-specifies that `x` must be frozen, and hence the final loan is an Imm\n-loan.  In any case the troublesome second argument would be flagged\n-as an error.\n+These are two separate dataflow analyses built on the same\n+framework. Let's look at checking that memory is initialized first;\n+the checking of immutable local variabe assignments works in a very\n+similar way.\n \n-# Maps that are created\n+To track the initialization of memory, we actually track all the\n+points in the program that *create uninitialized memory*, meaning\n+moves and the declaration of uninitialized variables. For each of\n+these points, we create a bit in the dataflow set. Assignments to a\n+variable `x` or path `a.b.c` kill the move/uninitialization bits for\n+those paths and any subpaths (e.g., `x`, `x.y`, `a.b.c`, `*a.b.c`).\n+The bits are also killed when the root variables (`x`, `a`) go out of\n+scope. Bits are unioned when two control-flow paths join. Thus, the\n+presence of a bit indicates that the move may have occurred without an\n+intervening assignment to the same memory. At each use of a variable,\n+we examine the bits in scope, and check that none of them are\n+moves/uninitializations of the variable that is being used.\n \n-Borrowck results in two maps.\n+Let's look at a simple example:\n+\n+    fn foo(a: ~int) {\n+        let b: ~int;       // Gen bit 0.\n+\n+        if cond {          // Bits: 0\n+            use(&*a);\n+            b = a;         // Gen bit 1, kill bit 0.\n+            use(&*b);\n+        } else {\n+                           // Bits: 0\n+        }\n+                           // Bits: 0,1\n+        use(&*a);          // Error.\n+        use(&*b);          // Error.\n+    }\n \n-- `root_map`: identifies those expressions or patterns whose result\n-  needs to be rooted. Conceptually the root_map maps from an\n-  expression or pattern node to a `node_id` identifying the scope for\n-  which the expression must be rooted (this `node_id` should identify\n-  a block or call). The actual key to the map is not an expression id,\n-  however, but a `root_map_key`, which combines an expression id with a\n-  deref count and is used to cope with auto-deref.\n+    fn use(a: &int) { }\n+\n+In this example, the variable `b` is created uninitialized. In one\n+branch of an `if`, we then move the variable `a` into `b`. Once we\n+exit the `if`, therefore, it is an error to use `a` or `b` since both\n+are only conditionally initialized. I have annotated the dataflow\n+state using comments. There are two dataflow bits, with bit 0\n+corresponding to the creation of `b` without an initializer, and bit 1\n+corresponding to the move of `a`. The assignment `b = a` both\n+generates bit 1, because it is a move of `a`, and kills bit 0, because\n+`b` is now initialized. On the else branch, though, `b` is never\n+initialized, and so bit 0 remains untouched. When the two flows of\n+control join, we union the bits from both sides, resulting in both\n+bits 0 and 1 being set. Thus any attempt to use `a` uncovers the bit 1\n+from the \"then\" branch, showing that `a` may be moved, and any attempt\n+to use `b` uncovers bit 0, from the \"else\" branch, showing that `b`\n+may not be initialized.\n+\n+## Initialization of immutable variables\n+\n+Initialization of immutable variables works in a very similar way,\n+except that:\n+\n+1. we generate bits for each assignment to a variable;\n+2. the bits are never killed except when the variable goes out of scope.\n+\n+Thus the presence of an assignment bit indicates that the assignment\n+may have occurred. Note that assignments are only killed when the\n+variable goes out of scope, as it is not relevant whether or not there\n+has been a move in the meantime. Using these bits, we can declare that\n+an assignment to an immutable variable is legal iff there is no other\n+assignment bit to that same variable in scope.\n+\n+## Why is the design made this way?\n+\n+It may seem surprising that we assign dataflow bits to *each move*\n+rather than *each path being moved*. This is somewhat less efficient,\n+since on each use, we must iterate through all moves and check whether\n+any of them correspond to the path in question. Similar concerns apply\n+to the analysis for double assignments to immutable variables. The\n+main reason to do it this way is that it allows us to print better\n+error messages, because when a use occurs, we can print out the\n+precise move that may be in scope, rather than simply having to say\n+\"the variable may not be initialized\".\n+\n+## Data structures used in the move analysis\n+\n+The move analysis maintains several data structures that enable it to\n+cross-reference moves and assignments to determine when they may be\n+moving/assigning the same memory. These are all collected into the\n+`MoveData` and `FlowedMoveData` structs. The former represents the set\n+of move paths, moves, and assignments, and the latter adds in the\n+results of a dataflow computation.\n+\n+### Move paths\n+\n+The `MovePath` tree tracks every path that is moved or assigned to.\n+These paths have the same form as the `LoanPath` data structure, which\n+in turn is the \"real world version of the lvalues `LV` that we\n+introduced earlier. The difference between a `MovePath` and a `LoanPath`\n+is that move paths are:\n+\n+1. Canonicalized, so that we have exactly one copy of each, and\n+   we can refer to move paths by index;\n+2. Cross-referenced with other paths into a tree, so that given a move\n+   path we can efficiently find all parent move paths and all\n+   extensions (e.g., given the `a.b` move path, we can easily find the\n+   move path `a` and also the move paths `a.b.c`)\n+3. Cross-referenced with moves and assignments, so that we can\n+   easily find all moves and assignments to a given path.\n+\n+The mechanism that we use is to create a `MovePath` record for each\n+move path. These are arranged in an array and are referenced using\n+`MovePathIndex` values, which are newtype'd indices. The `MovePath`\n+structs are arranged into a tree, representing using the standard\n+Knuth representation where each node has a child 'pointer' and a \"next\n+sibling\" 'pointer'. In addition, each `MovePath` has a parent\n+'pointer'.  In this case, the 'pointers' are just `MovePathIndex`\n+values.\n+\n+In this way, if we want to find all base paths of a given move path,\n+we can just iterate up the parent pointers (see `each_base_path()` in\n+the `move_data` module). If we want to find all extensions, we can\n+iterate through the subtree (see `each_extending_path()`).\n+\n+### Moves and assignments\n+\n+There are structs to represent moves (`Move`) and assignments\n+(`Assignment`), and these are also placed into arrays and referenced\n+by index. All moves of a particular path are arranged into a linked\n+lists, beginning with `MovePath.first_move` and continuing through\n+`Move.next_move`.\n+\n+We distinguish between \"var\" assignments, which are assignments to a\n+variable like `x = foo`, and \"path\" assignments (`x.f = foo`).  This\n+is because we need to assign dataflows to the former, but not the\n+latter, so as to check for double initialization of immutable\n+variables.\n+\n+### Gathering and checking moves\n+\n+Like loans, we distinguish two phases. The first, gathering, is where\n+we uncover all the moves and assignments. As with loans, we do some\n+basic sanity checking in this phase, so we'll report errors if you\n+attempt to move out of a borrowed pointer etc. Then we do the dataflow\n+(see `FlowedMoveData::new`). Finally, in the `check_loans.rs` code, we\n+walk back over, identify all uses, assignments, and captures, and\n+check that they are legal given the set of dataflow bits we have\n+computed for that program point.\n+\n+# Future work\n+\n+While writing up these docs, I encountered some rules I believe to be\n+stricter than necessary:\n+\n+- I think the restriction against mutating `&mut` pointers found in an\n+  aliasable location is unnecessary. They cannot be reborrowed, to be sure,\n+  so it should be safe to mutate them. Lifting this might cause some common\n+  cases (`&mut int`) to work just fine, but might lead to further confusion\n+  in other cases, so maybe it's best to leave it as is.\n+- I think restricting the `&mut` LV against moves and `ALIAS` is sufficient,\n+  `MUTATE` and `CLAIM` are overkill. `MUTATE` was necessary when swap was\n+  a built-in operator, but as it is not, it is implied by `CLAIM`,\n+  and `CLAIM` is implied by `ALIAS`. The only net effect of this is an\n+  extra error message in some cases, though.\n+- I have not described how closures interact. Current code is unsound.\n+  I am working on describing and implementing the fix.\n+- If we wish, we can easily extend the move checking to allow finer-grained\n+  tracking of what is initialized and what is not, enabling code like\n+  this:\n+\n+      a = x.f.g; // x.f.g is now uninitialized\n+      // here, x and x.f are not usable, but x.f.h *is*\n+      x.f.g = b; // x.f.g is not initialized\n+      // now x, x.f, x.f.g, x.f.h are all usable\n+\n+  What needs to change here, most likely, is that the `moves` module\n+  should record not only what paths are moved, but what expressions\n+  are actual *uses*. For example, the reference to `x` in `x.f.g = b`\n+  is not a true *use* in the sense that it requires `x` to be fully\n+  initialized. This is in fact why the above code produces an error\n+  today: the reference to `x` in `x.f.g = b` is considered illegal\n+  because `x` is not fully initialized.\n+\n+There are also some possible refactorings:\n+\n+- It might be nice to replace all loan paths with the MovePath mechanism,\n+  since they allow lightweight comparison using an integer.\n \n */"}, {"sha": "d32c1873ba053b70a96b0b9bdf1cd421528673e9", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Computes moves.\n+ */\n+\n+use core::prelude::*;\n+use mc = middle::mem_categorization;\n+use middle::borrowck::*;\n+use middle::borrowck::move_data::*;\n+use middle::moves;\n+use middle::ty;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::codemap::span;\n+use util::ppaux::{UserString};\n+\n+pub fn gather_decl(bccx: @BorrowckCtxt,\n+                   move_data: &mut MoveData,\n+                   decl_id: ast::node_id,\n+                   _decl_span: span,\n+                   var_id: ast::node_id) {\n+    let loan_path = @LpVar(var_id);\n+    move_data.add_move(bccx.tcx, loan_path, decl_id, Declared);\n+}\n+\n+pub fn gather_move_from_expr(bccx: @BorrowckCtxt,\n+                             move_data: &mut MoveData,\n+                             move_expr: @ast::expr,\n+                             cmt: mc::cmt) {\n+    gather_move_from_expr_or_pat(bccx, move_data, move_expr.id,\n+                                 MoveExpr(move_expr), cmt);\n+}\n+\n+pub fn gather_move_from_pat(bccx: @BorrowckCtxt,\n+                            move_data: &mut MoveData,\n+                            move_pat: @ast::pat,\n+                            cmt: mc::cmt) {\n+    gather_move_from_expr_or_pat(bccx, move_data, move_pat.id,\n+                                 MovePat(move_pat), cmt);\n+}\n+\n+fn gather_move_from_expr_or_pat(bccx: @BorrowckCtxt,\n+                                move_data: &mut MoveData,\n+                                move_id: ast::node_id,\n+                                move_kind: MoveKind,\n+                                cmt: mc::cmt) {\n+    if !check_is_legal_to_move_from(bccx, cmt, cmt) {\n+        return;\n+    }\n+\n+    match opt_loan_path(cmt) {\n+        Some(loan_path) => {\n+            move_data.add_move(bccx.tcx, loan_path, move_id, move_kind);\n+        }\n+        None => {\n+            // move from rvalue or unsafe pointer, hence ok\n+        }\n+    }\n+}\n+\n+pub fn gather_captures(bccx: @BorrowckCtxt,\n+                       move_data: &mut MoveData,\n+                       closure_expr: @ast::expr) {\n+    let captured_vars = bccx.capture_map.get(&closure_expr.id);\n+    for captured_vars.each |captured_var| {\n+        match captured_var.mode {\n+            moves::CapMove => {\n+                let fvar_id = ast_util::def_id_of_def(captured_var.def).node;\n+                let loan_path = @LpVar(fvar_id);\n+                move_data.add_move(bccx.tcx, loan_path, closure_expr.id,\n+                                   Captured(closure_expr));\n+            }\n+            moves::CapCopy | moves::CapRef => {}\n+        }\n+    }\n+}\n+\n+pub fn gather_assignment(bccx: @BorrowckCtxt,\n+                         move_data: &mut MoveData,\n+                         assignment_id: ast::node_id,\n+                         assignment_span: span,\n+                         assignee_loan_path: @LoanPath,\n+                         assignee_id: ast::node_id) {\n+    move_data.add_assignment(bccx.tcx,\n+                             assignee_loan_path,\n+                             assignment_id,\n+                             assignment_span,\n+                             assignee_id);\n+}\n+\n+fn check_is_legal_to_move_from(bccx: @BorrowckCtxt,\n+                               cmt0: mc::cmt,\n+                               cmt: mc::cmt) -> bool {\n+    match cmt.cat {\n+        mc::cat_stack_upvar(*) |\n+        mc::cat_implicit_self(*) |\n+        mc::cat_copied_upvar(*) |\n+        mc::cat_deref(_, _, mc::region_ptr(*)) |\n+        mc::cat_deref(_, _, mc::gc_ptr(*)) => {\n+            bccx.span_err(\n+                cmt0.span,\n+                fmt!(\"cannot move out of %s\",\n+                     bccx.cmt_to_str(cmt)));\n+            false\n+        }\n+\n+        // It seems strange to allow a move out of a static item,\n+        // but what happens in practice is that you have a\n+        // reference to a constant with a type that should be\n+        // moved, like `None::<~int>`.  The type of this constant\n+        // is technically `Option<~int>`, which moves, but we know\n+        // that the content of static items will never actually\n+        // contain allocated pointers, so we can just memcpy it.\n+        // Since static items can never have allocated memory,\n+        // this is ok. For now anyhow.\n+        mc::cat_static_item => {\n+            true\n+        }\n+\n+        mc::cat_rvalue(*) |\n+        mc::cat_local(*) |\n+        mc::cat_arg(*) |\n+        mc::cat_self(*) |\n+        mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+            true\n+        }\n+\n+        mc::cat_downcast(b) |\n+        mc::cat_interior(b, _) => {\n+            match ty::get(b.ty).sty {\n+                ty::ty_struct(did, _) | ty::ty_enum(did, _) => {\n+                    if ty::has_dtor(bccx.tcx, did) {\n+                        bccx.span_err(\n+                            cmt0.span,\n+                            fmt!(\"cannot move out of type `%s`, \\\n+                                  which defines the `Drop` trait\",\n+                                 b.ty.user_string(bccx.tcx)));\n+                        false\n+                    } else {\n+                        check_is_legal_to_move_from(bccx, cmt0, b)\n+                    }\n+                }\n+                _ => {\n+                    check_is_legal_to_move_from(bccx, cmt0, b)\n+                }\n+            }\n+        }\n+\n+        mc::cat_deref(b, _, mc::uniq_ptr(*)) |\n+        mc::cat_discr(b, _) => {\n+            check_is_legal_to_move_from(bccx, cmt0, b)\n+        }\n+    }\n+}\n+"}, {"sha": "9455340268eff0a6c50d9ea234bd674546d149b0", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -70,11 +70,11 @@ impl GuaranteeLifetimeContext {\n         match cmt.cat {\n             mc::cat_rvalue |\n             mc::cat_implicit_self |\n-            mc::cat_copied_upvar(*) |\n-            mc::cat_local(*) |\n-            mc::cat_arg(*) |\n-            mc::cat_self(*) |\n-            mc::cat_deref(_, _, mc::region_ptr(*)) |\n+            mc::cat_copied_upvar(*) |                  // L-Local\n+            mc::cat_local(*) |                         // L-Local\n+            mc::cat_arg(*) |                           // L-Local\n+            mc::cat_self(*) |                          // L-Local\n+            mc::cat_deref(_, _, mc::region_ptr(*)) |   // L-Deref-Borrowed\n             mc::cat_deref(_, _, mc::unsafe_ptr) => {\n                 let scope = self.scope(cmt);\n                 self.check_scope(scope)\n@@ -90,7 +90,7 @@ impl GuaranteeLifetimeContext {\n             mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n                 let base_scope = self.scope(base);\n \n-                // See rule Freeze-Imm-Managed-Ptr-2 in doc.rs\n+                // L-Deref-Managed-Imm-User-Root\n                 let omit_root = (\n                     ptr_mutbl == m_imm &&\n                     self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n@@ -99,6 +99,8 @@ impl GuaranteeLifetimeContext {\n                 );\n \n                 if !omit_root {\n+                    // L-Deref-Managed-Imm-Compiler-Root\n+                    // L-Deref-Managed-Mut-Compiler-Root\n                     self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n                 } else {\n                     debug!(\"omitting root, base=%s, base_scope=%?\",\n@@ -107,8 +109,8 @@ impl GuaranteeLifetimeContext {\n             }\n \n             mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::uniq_ptr(*)) |\n-            mc::cat_interior(base, _) => {\n+            mc::cat_deref(base, _, mc::uniq_ptr(*)) |  // L-Deref-Owned\n+            mc::cat_interior(base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n \n@@ -321,6 +323,8 @@ impl GuaranteeLifetimeContext {\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n+        // See the SCOPE(LV) function in doc.rs\n+\n         match cmt.cat {\n             mc::cat_rvalue => {\n                 ty::re_scope(self.bccx.tcx.region_maps.cleanup_scope(cmt.id))"}, {"sha": "c2ae364e54ce89372d0f19e76ac7c223440b1d29", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -19,6 +19,7 @@\n use core::prelude::*;\n \n use middle::borrowck::*;\n+use middle::borrowck::move_data::MoveData;\n use mc = middle::mem_categorization;\n use middle::pat_util;\n use middle::ty::{ty_region};\n@@ -35,6 +36,7 @@ use syntax::visit;\n \n mod lifetime;\n mod restrictions;\n+mod gather_moves;\n \n /// Context used while gathering loans:\n ///\n@@ -65,28 +67,32 @@ mod restrictions;\n struct GatherLoanCtxt {\n     bccx: @BorrowckCtxt,\n     id_range: id_range,\n+    move_data: @mut move_data::MoveData,\n     all_loans: @mut ~[Loan],\n     item_ub: ast::node_id,\n     repeating_ids: ~[ast::node_id]\n }\n \n pub fn gather_loans(bccx: @BorrowckCtxt,\n-                    body: &ast::blk) -> (id_range, @mut ~[Loan]) {\n+                    body: &ast::blk)\n+                    -> (id_range, @mut ~[Loan], @mut move_data::MoveData) {\n     let glcx = @mut GatherLoanCtxt {\n         bccx: bccx,\n         id_range: id_range::max(),\n         all_loans: @mut ~[],\n         item_ub: body.node.id,\n-        repeating_ids: ~[body.node.id]\n+        repeating_ids: ~[body.node.id],\n+        move_data: @mut MoveData::new()\n     };\n     let v = visit::mk_vt(@visit::Visitor {visit_expr: gather_loans_in_expr,\n                                           visit_block: gather_loans_in_block,\n                                           visit_fn: gather_loans_in_fn,\n                                           visit_stmt: add_stmt_to_map,\n                                           visit_pat: add_pat_to_id_range,\n+                                          visit_local: gather_loans_in_local,\n                                           .. *visit::default_visitor()});\n     (v.visit_block)(body, glcx, v);\n-    return (glcx.id_range, glcx.all_loans);\n+    return (glcx.id_range, glcx.all_loans, glcx.move_data);\n }\n \n fn add_pat_to_id_range(p: @ast::pat,\n@@ -130,6 +136,35 @@ fn gather_loans_in_block(blk: &ast::blk,\n     visit::visit_block(blk, this, vt);\n }\n \n+fn gather_loans_in_local(local: @ast::local,\n+                         this: @mut GatherLoanCtxt,\n+                         vt: visit::vt<@mut GatherLoanCtxt>) {\n+    if local.node.init.is_none() {\n+        // Variable declarations without initializers are considered \"moves\":\n+        let tcx = this.bccx.tcx;\n+        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n+            gather_moves::gather_decl(this.bccx,\n+                                      this.move_data,\n+                                      id,\n+                                      span,\n+                                      id);\n+        }\n+    } else {\n+        // Variable declarations with initializers are considered \"assigns\":\n+        let tcx = this.bccx.tcx;\n+        do pat_util::pat_bindings(tcx.def_map, local.node.pat) |_, id, span, _| {\n+            gather_moves::gather_assignment(this.bccx,\n+                                            this.move_data,\n+                                            id,\n+                                            span,\n+                                            @LpVar(id),\n+                                            id);\n+        }\n+    }\n+\n+    visit::visit_local(local, this, vt);\n+}\n+\n fn gather_loans_in_expr(ex: @ast::expr,\n                         this: @mut GatherLoanCtxt,\n                         vt: visit::vt<@mut GatherLoanCtxt>) {\n@@ -147,6 +182,13 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         this.guarantee_adjustments(ex, *adjustments);\n     }\n \n+    // If this expression is a move, gather it:\n+    if this.bccx.is_move(ex.id) {\n+        let cmt = this.bccx.cat_expr(ex);\n+        gather_moves::gather_move_from_expr(\n+            this.bccx, this.move_data, ex, cmt);\n+    }\n+\n     // Special checks for various kinds of expressions:\n     match ex.node {\n       ast::expr_addr_of(mutbl, base) => {\n@@ -159,6 +201,23 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, this, vt);\n       }\n \n+      ast::expr_assign(l, _) | ast::expr_assign_op(_, l, _) => {\n+          let l_cmt = this.bccx.cat_expr(l);\n+          match opt_loan_path(l_cmt) {\n+              Some(l_lp) => {\n+                  gather_moves::gather_assignment(this.bccx, this.move_data,\n+                                                  ex.id, ex.span,\n+                                                  l_lp, l.id);\n+              }\n+              None => {\n+                  // This can occur with e.g. `*foo() = 5`.  In such\n+                  // cases, there is no need to check for conflicts\n+                  // with moves etc, just ignore.\n+              }\n+          }\n+          visit::visit_expr(ex, this, vt);\n+      }\n+\n       ast::expr_match(ex_v, ref arms) => {\n         let cmt = this.bccx.cat_expr(ex_v);\n         for arms.each |arm| {\n@@ -203,6 +262,11 @@ fn gather_loans_in_expr(ex: @ast::expr,\n           this.pop_repeating_id(body.node.id);\n       }\n \n+      ast::expr_fn_block(*) => {\n+          gather_moves::gather_captures(this.bccx, this.move_data, ex);\n+          visit::visit_expr(ex, this, vt);\n+      }\n+\n       _ => {\n         visit::visit_expr(ex, this, vt);\n       }\n@@ -417,6 +481,8 @@ pub impl GatherLoanCtxt {\n                             borrow_span: span,\n                             cmt: mc::cmt,\n                             req_mutbl: ast::mutability) {\n+            //! Implements the M-* rules in doc.rs.\n+\n             match req_mutbl {\n                 m_const => {\n                     // Data of any mutability can be lent as const.\n@@ -451,8 +517,8 @@ pub impl GatherLoanCtxt {\n     fn restriction_set(&self, req_mutbl: ast::mutability) -> RestrictionSet {\n         match req_mutbl {\n             m_const => RESTR_EMPTY,\n-            m_imm   => RESTR_EMPTY | RESTR_MUTATE,\n-            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_FREEZE\n+            m_imm   => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n+            m_mutbl => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n         }\n     }\n \n@@ -558,8 +624,11 @@ pub impl GatherLoanCtxt {\n                     }\n                   }\n                   ast::bind_by_copy | ast::bind_infer => {\n-                    // Nothing to do here; neither copies nor moves induce\n-                    // borrows.\n+                      // No borrows here, but there may be moves\n+                      if self.bccx.is_move(pat.id) {\n+                          gather_moves::gather_move_from_pat(\n+                              self.bccx, self.move_data, pat, cmt);\n+                      }\n                   }\n                 }\n               }"}, {"sha": "82a3b145e1d5da3bfe36537179232c2472d05e63", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -33,7 +33,7 @@ pub fn compute_restrictions(bccx: @BorrowckCtxt,\n         cmt_original: cmt\n     };\n \n-    ctxt.compute(cmt, restr)\n+    ctxt.restrict(cmt, restr)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -50,9 +50,9 @@ impl RestrictionsContext {\n         self.bccx.tcx\n     }\n \n-    fn compute(&self,\n-               cmt: mc::cmt,\n-               restrictions: RestrictionSet) -> RestrictionResult {\n+    fn restrict(&self,\n+                cmt: mc::cmt,\n+                restrictions: RestrictionSet) -> RestrictionResult {\n \n         // Check for those cases where we cannot control the aliasing\n         // and make sure that we are not being asked to.\n@@ -76,6 +76,7 @@ impl RestrictionsContext {\n             mc::cat_local(local_id) |\n             mc::cat_arg(local_id) |\n             mc::cat_self(local_id) => {\n+                // R-Variable\n                 let lp = @LpVar(local_id);\n                 SafeIf(lp, ~[Restriction {loan_path: lp,\n                                           set: restrictions}])\n@@ -85,22 +86,30 @@ impl RestrictionsContext {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n                 // could cause the type of the memory to change.\n-                self.compute(cmt_base, restrictions | RESTR_MUTATE)\n+                self.restrict(\n+                    cmt_base,\n+                    restrictions | RESTR_MUTATE | RESTR_CLAIM)\n             }\n \n             mc::cat_interior(cmt_base, i) => {\n+                // R-Field\n+                //\n                 // Overwriting the base would not change the type of\n                 // the memory, so no additional restrictions are\n                 // needed.\n-                let result = self.compute(cmt_base, restrictions);\n+                let result = self.restrict(cmt_base, restrictions);\n                 self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n             }\n \n             mc::cat_deref(cmt_base, _, mc::uniq_ptr(*)) => {\n+                // R-Deref-Owned-Pointer\n+                //\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n                 // would cause the unique pointer to be freed.\n-                let result = self.compute(cmt_base, restrictions | RESTR_MUTATE);\n+                let result = self.restrict(\n+                    cmt_base,\n+                    restrictions | RESTR_MUTATE | RESTR_CLAIM);\n                 self.extend(result, cmt.mutbl, LpDeref, restrictions)\n             }\n \n@@ -109,16 +118,20 @@ impl RestrictionsContext {\n             mc::cat_implicit_self(*) |\n             mc::cat_deref(_, _, mc::region_ptr(m_imm, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(m_imm)) => {\n+                // R-Deref-Imm-Borrowed\n                 Safe\n             }\n \n             mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n+                // R-Deref-Const-Borrowed\n                 self.check_no_mutability_control(cmt, restrictions);\n                 Safe\n             }\n \n             mc::cat_deref(cmt_base, _, mc::gc_ptr(m_mutbl)) => {\n+                // R-Deref-Managed-Borrowed\n+                //\n                 // Technically, no restrictions are *necessary* here.\n                 // The validity of the borrow is guaranteed\n                 // dynamically.  However, nonetheless we add a\n@@ -169,12 +182,15 @@ impl RestrictionsContext {\n                 // mutability, we can only prevent mutation or prevent\n                 // freezing if it is not aliased. Therefore, in such\n                 // cases we restrict aliasing on `cmt_base`.\n-                if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n-                    let result = self.compute(cmt_base, restrictions | RESTR_ALIAS);\n+                if restrictions != RESTR_EMPTY {\n+                    // R-Deref-Mut-Borrowed-1\n+                    let result = self.restrict(\n+                        cmt_base,\n+                        RESTR_ALIAS | RESTR_MUTATE | RESTR_CLAIM);\n                     self.extend(result, cmt.mutbl, LpDeref, restrictions)\n                 } else {\n-                    let result = self.compute(cmt_base, restrictions);\n-                    self.extend(result, cmt.mutbl, LpDeref, restrictions)\n+                    // R-Deref-Mut-Borrowed-2\n+                    Safe\n                 }\n             }\n \n@@ -185,7 +201,7 @@ impl RestrictionsContext {\n \n             mc::cat_stack_upvar(cmt_base) |\n             mc::cat_discr(cmt_base, _) => {\n-                self.compute(cmt_base, restrictions)\n+                self.restrict(cmt_base, restrictions)\n             }\n         }\n     }\n@@ -233,7 +249,7 @@ impl RestrictionsContext {\n     fn check_no_mutability_control(&self,\n                                    cmt: mc::cmt,\n                                    restrictions: RestrictionSet) {\n-        if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE) {\n+        if restrictions.intersects(RESTR_MUTATE | RESTR_FREEZE | RESTR_CLAIM) {\n             self.bccx.report(BckError {span: self.span,\n                                        cmt: cmt,\n                                        code: err_freeze_aliasable_const});"}, {"sha": "1babf08aa705caeeec53233dd19b45843bfaddcd", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 115, "deletions": 18, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -19,7 +19,7 @@ use middle::moves;\n use middle::dataflow::DataFlowContext;\n use middle::dataflow::DataFlowOperator;\n use util::common::stmt_set;\n-use util::ppaux::{note_and_explain_region, Repr};\n+use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use core::hashmap::{HashSet, HashMap};\n use core::io;\n@@ -46,6 +46,8 @@ pub mod check_loans;\n #[path=\"gather_loans/mod.rs\"]\n pub mod gather_loans;\n \n+pub mod move_data;\n+\n pub struct LoanDataFlowOperator;\n pub type LoanDataFlow = DataFlowContext<LoanDataFlowOperator>;\n \n@@ -121,21 +123,28 @@ fn borrowck_fn(fk: &visit::fn_kind,\n             debug!(\"borrowck_fn(id=%?)\", id);\n \n             // Check the body of fn items.\n-            let (id_range, all_loans) =\n+            let (id_range, all_loans, move_data) =\n                 gather_loans::gather_loans(this, body);\n-            let all_loans: &~[Loan] = &*all_loans; // FIXME(#5074)\n-            let mut dfcx =\n+            let mut loan_dfcx =\n                 DataFlowContext::new(this.tcx,\n                                      this.method_map,\n                                      LoanDataFlowOperator,\n                                      id_range,\n                                      all_loans.len());\n             for all_loans.eachi |loan_idx, loan| {\n-                dfcx.add_gen(loan.gen_scope, loan_idx);\n-                dfcx.add_kill(loan.kill_scope, loan_idx);\n+                loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n+                loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n             }\n-            dfcx.propagate(body);\n-            check_loans::check_loans(this, &dfcx, *all_loans, body);\n+            loan_dfcx.propagate(body);\n+\n+            let flowed_moves = move_data::FlowedMoveData::new(move_data,\n+                                                              this.tcx,\n+                                                              this.method_map,\n+                                                              id_range,\n+                                                              body);\n+\n+            check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n+                                     *all_loans, body);\n         }\n     }\n \n@@ -226,13 +235,13 @@ pub struct Loan {\n     span: span,\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum LoanPath {\n     LpVar(ast::node_id),               // `x` in doc.rs\n     LpExtend(@LoanPath, mc::MutabilityCategory, LoanPathElem)\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum LoanPathElem {\n     LpDeref,                     // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n@@ -292,10 +301,10 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // Borrowing an lvalue often results in *restrictions* that limit what\n // can be done with this lvalue during the scope of the loan:\n //\n-// - `RESTR_MUTATE`: The lvalue may not be modified and mutable pointers to\n-//                   the value cannot be created.\n-// - `RESTR_FREEZE`: Immutable pointers to the value cannot be created.\n-// - `RESTR_ALIAS`: The lvalue may not be aliased in any way.\n+// - `RESTR_MUTATE`: The lvalue may not be modified.\n+// - `RESTR_CLAIM`: `&mut` borrows of the lvalue are forbidden.\n+// - `RESTR_FREEZE`: `&` borrows of the lvalue are forbidden.\n+// - `RESTR_ALIAS`: All borrows of the lvalue are forbidden.\n //\n // In addition, no value which is restricted may be moved. Therefore,\n // restrictions are meaningful even if the RestrictionSet is empty,\n@@ -306,14 +315,16 @@ pub struct Restriction {\n     set: RestrictionSet\n }\n \n+#[deriving(Eq)]\n pub struct RestrictionSet {\n     bits: u32\n }\n \n-pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b000};\n-pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b001};\n-pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b010};\n-pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b100};\n+pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n+pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n+pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n+pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n+pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b1000};\n \n pub impl RestrictionSet {\n     fn intersects(&self, restr: RestrictionSet) -> bool {\n@@ -407,6 +418,11 @@ pub enum AliasableViolationKind {\n     BorrowViolation\n }\n \n+pub enum MovedValueUseKind {\n+    MovedInUse,\n+    MovedInCapture,\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Misc\n \n@@ -419,6 +435,10 @@ pub impl BorrowckCtxt {\n         self.tcx.region_maps.is_subscope_of(r_sub, r_sup)\n     }\n \n+    fn is_move(&self, id: ast::node_id) -> bool {\n+        self.moves_map.contains(&id)\n+    }\n+\n     fn cat_expr(&self, expr: @ast::expr) -> mc::cmt {\n         mc::cat_expr(self.tcx, self.method_map, expr)\n     }\n@@ -478,6 +498,83 @@ pub impl BorrowckCtxt {\n         self.note_and_explain_bckerr(err);\n     }\n \n+    fn report_use_of_moved_value(&self,\n+                                 use_span: span,\n+                                 use_kind: MovedValueUseKind,\n+                                 lp: @LoanPath,\n+                                 move: &move_data::Move,\n+                                 moved_lp: @LoanPath) {\n+        let verb = match use_kind {\n+            MovedInUse => \"use\",\n+            MovedInCapture => \"capture\",\n+        };\n+\n+        match move.kind {\n+            move_data::Declared => {\n+                self.tcx.sess.span_err(\n+                    use_span,\n+                    fmt!(\"%s of possibly uninitialized value: `%s`\",\n+                         verb,\n+                         self.loan_path_to_str(lp)));\n+            }\n+            _ => {\n+                let partially = if lp == moved_lp {\"\"} else {\"partially \"};\n+                self.tcx.sess.span_err(\n+                    use_span,\n+                    fmt!(\"%s of %smoved value: `%s`\",\n+                         verb,\n+                         partially,\n+                         self.loan_path_to_str(lp)));\n+            }\n+        }\n+\n+        match move.kind {\n+            move_data::Declared => {}\n+\n+            move_data::MoveExpr(expr) => {\n+                let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n+                self.tcx.sess.span_note(\n+                    expr.span,\n+                    fmt!(\"`%s` moved here because it has type `%s`, \\\n+                          which is moved by default (use `copy` to override)\",\n+                         self.loan_path_to_str(moved_lp),\n+                         expr_ty.user_string(self.tcx)));\n+            }\n+\n+            move_data::MovePat(pat) => {\n+                let pat_ty = ty::node_id_to_type(self.tcx, pat.id);\n+                self.tcx.sess.span_note(\n+                    pat.span,\n+                    fmt!(\"`%s` moved here because it has type `%s`, \\\n+                          which is moved by default (use `ref` to override)\",\n+                         self.loan_path_to_str(moved_lp),\n+                         pat_ty.user_string(self.tcx)));\n+            }\n+\n+            move_data::Captured(expr) => {\n+                self.tcx.sess.span_note(\n+                    expr.span,\n+                    fmt!(\"`%s` moved into closure environment here \\\n+                          because its type is moved by default \\\n+                          (make a copy and capture that instead to override)\",\n+                         self.loan_path_to_str(moved_lp)));\n+            }\n+        }\n+    }\n+\n+    fn report_reassigned_immutable_variable(&self,\n+                                            span: span,\n+                                            lp: @LoanPath,\n+                                            assign: &move_data::Assignment) {\n+        self.tcx.sess.span_err(\n+            span,\n+            fmt!(\"re-assignment of immutable variable `%s`\",\n+                 self.loan_path_to_str(lp)));\n+        self.tcx.sess.span_note(\n+            assign.span,\n+            fmt!(\"prior assignment occurs here\"));\n+    }\n+\n     fn span_err(&self, s: span, m: &str) {\n         self.tcx.sess.span_err(s, m);\n     }"}, {"sha": "91962f17d596f1259cdeaa94ebec794a7310651c", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "added", "additions": 603, "deletions": 0, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,603 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Data structures used for tracking moves. Please see the extensive\n+comments in the section \"Moves and initialization\" and in `doc.rs`.\n+\n+*/\n+\n+use core::prelude::*;\n+use core::hashmap::{HashMap, HashSet};\n+use middle::borrowck::*;\n+use middle::dataflow::DataFlowContext;\n+use middle::dataflow::DataFlowOperator;\n+use middle::ty;\n+use middle::typeck;\n+use syntax::ast;\n+use syntax::ast_util;\n+use syntax::codemap::span;\n+use syntax::opt_vec::OptVec;\n+use syntax::opt_vec;\n+use util::ppaux::Repr;\n+\n+pub struct MoveData {\n+    /// Move paths. See section \"Move paths\" in `doc.rs`.\n+    paths: ~[MovePath],\n+\n+    /// Cache of loan path to move path index, for easy lookup.\n+    path_map: HashMap<@LoanPath, MovePathIndex>,\n+\n+    /// Each move or uninitialized variable gets an entry here.\n+    moves: ~[Move],\n+\n+    /// Assignments to a variable, like `x = foo`. These are assigned\n+    /// bits for dataflow, since we must track them to ensure that\n+    /// immutable variables are assigned at most once along each path.\n+    var_assignments: ~[Assignment],\n+\n+    /// Assignments to a path, like `x.f = foo`. These are not\n+    /// assigned dataflow bits, but we track them because they still\n+    /// kill move bits.\n+    path_assignments: ~[Assignment],\n+    assignee_ids: HashSet<ast::node_id>,\n+}\n+\n+pub struct FlowedMoveData {\n+    move_data: @mut MoveData,\n+    //         ^~~~~~~~~~~~~\n+    // It makes me sad to use @mut here, except that due to\n+    // the visitor design, this is what gather_loans\n+    // must produce.\n+\n+    dfcx_moves: MoveDataFlow,\n+\n+    // We could (and maybe should, for efficiency) combine both move\n+    // and assign data flow into one, but this way it's easier to\n+    // distinguish the bits that correspond to moves and assignments.\n+    dfcx_assign: AssignDataFlow\n+}\n+\n+/// Index into `MoveData.paths`, used like a pointer\n+#[deriving(Eq)]\n+pub struct MovePathIndex(uint);\n+\n+static InvalidMovePathIndex: MovePathIndex =\n+    MovePathIndex(uint::max_value);\n+\n+/// Index into `MoveData.moves`, used like a pointer\n+#[deriving(Eq)]\n+pub struct MoveIndex(uint);\n+\n+static InvalidMoveIndex: MoveIndex =\n+    MoveIndex(uint::max_value);\n+\n+pub struct MovePath {\n+    /// Loan path corresponding to this move path\n+    loan_path: @LoanPath,\n+\n+    /// Parent pointer, `InvalidMovePathIndex` if root\n+    parent: MovePathIndex,\n+\n+    /// Head of linked list of moves to this path,\n+    /// `InvalidMoveIndex` if not moved\n+    first_move: MoveIndex,\n+\n+    /// First node in linked list of children, `InvalidMovePathIndex` if leaf\n+    first_child: MovePathIndex,\n+\n+    /// Next node in linked list of parent's children (siblings),\n+    /// `InvalidMovePathIndex` if none.\n+    next_sibling: MovePathIndex,\n+}\n+\n+pub enum MoveKind {\n+    Declared,               // When declared, variables start out \"moved\".\n+    MoveExpr(@ast::expr),   // Expression or binding that moves a variable\n+    MovePat(@ast::pat),     // By-move binding\n+    Captured(@ast::expr),   // Closure creation that moves a value\n+}\n+\n+pub struct Move {\n+    /// Path being moved.\n+    path: MovePathIndex,\n+\n+    /// id of node that is doing the move.\n+    id: ast::node_id,\n+\n+    /// Kind of move, for error messages.\n+    kind: MoveKind,\n+\n+    /// Next node in linked list of moves from `path`, or `InvalidMoveIndex`\n+    next_move: MoveIndex,\n+}\n+\n+pub struct Assignment {\n+    /// Path being assigned.\n+    path: MovePathIndex,\n+\n+    /// id where assignment occurs\n+    id: ast::node_id,\n+\n+    /// span of node where assignment occurs\n+    span: span,\n+}\n+\n+pub struct MoveDataFlowOperator;\n+pub type MoveDataFlow = DataFlowContext<MoveDataFlowOperator>;\n+\n+pub struct AssignDataFlowOperator;\n+pub type AssignDataFlow = DataFlowContext<AssignDataFlowOperator>;\n+\n+impl MoveData {\n+    pub fn new() -> MoveData {\n+        MoveData {\n+            paths: ~[],\n+            path_map: HashMap::new(),\n+            moves: ~[],\n+            path_assignments: ~[],\n+            var_assignments: ~[],\n+            assignee_ids: HashSet::new(),\n+        }\n+    }\n+\n+    fn path<'a>(&'a self, index: MovePathIndex) -> &'a MovePath {\n+        //! Type safe indexing operator\n+        &self.paths[*index]\n+    }\n+\n+    fn mut_path<'a>(&'a mut self, index: MovePathIndex) -> &'a mut MovePath {\n+        //! Type safe indexing operator\n+        &mut self.paths[*index]\n+    }\n+\n+    fn move<'a>(&'a self, index: MoveIndex) -> &'a Move {\n+        //! Type safe indexing operator\n+        &self.moves[*index]\n+    }\n+\n+    fn is_var_path(&self, index: MovePathIndex) -> bool {\n+        //! True if `index` refers to a variable\n+        self.path(index).parent == InvalidMovePathIndex\n+    }\n+\n+    pub fn move_path(&mut self,\n+                     tcx: ty::ctxt,\n+                     lp: @LoanPath) -> MovePathIndex {\n+        /*!\n+         * Returns the existing move path index for `lp`, if any,\n+         * and otherwise adds a new index for `lp` and any of its\n+         * base paths that do not yet have an index.\n+         */\n+\n+        match self.path_map.find(&lp) {\n+            Some(&index) => {\n+                return index;\n+            }\n+            None => {}\n+        }\n+\n+        let index = match *lp {\n+            LpVar(*) => {\n+                let index = MovePathIndex(self.paths.len());\n+\n+                self.paths.push(MovePath {\n+                    loan_path: lp,\n+                    parent: InvalidMovePathIndex,\n+                    first_move: InvalidMoveIndex,\n+                    first_child: InvalidMovePathIndex,\n+                    next_sibling: InvalidMovePathIndex,\n+                });\n+\n+                index\n+            }\n+\n+            LpExtend(base, _, _) => {\n+                let parent_index = self.move_path(tcx, base);\n+                let index = MovePathIndex(self.paths.len());\n+\n+                let next_sibling = self.path(parent_index).first_child;\n+                self.mut_path(parent_index).first_child = index;\n+\n+                self.paths.push(MovePath {\n+                    loan_path: lp,\n+                    parent: parent_index,\n+                    first_move: InvalidMoveIndex,\n+                    first_child: InvalidMovePathIndex,\n+                    next_sibling: next_sibling,\n+                });\n+\n+                index\n+            }\n+        };\n+\n+        debug!(\"move_path(lp=%s, index=%?)\",\n+               lp.repr(tcx),\n+               index);\n+\n+        assert_eq!(*index, self.paths.len() - 1);\n+        self.path_map.insert(lp, index);\n+        return index;\n+    }\n+\n+    fn existing_move_path(&self,\n+                          lp: @LoanPath)\n+                          -> Option<MovePathIndex> {\n+        self.path_map.find_copy(&lp)\n+    }\n+\n+    fn existing_base_paths(&self,\n+                           lp: @LoanPath)\n+                           -> OptVec<MovePathIndex> {\n+        let mut result = opt_vec::Empty;\n+        self.add_existing_base_paths(lp, &mut result);\n+        result\n+    }\n+\n+    fn add_existing_base_paths(&self,\n+                               lp: @LoanPath,\n+                               result: &mut OptVec<MovePathIndex>) {\n+        /*!\n+         * Adds any existing move path indices for `lp` and any base\n+         * paths of `lp` to `result`, but does not add new move paths\n+         */\n+\n+        match self.path_map.find_copy(&lp) {\n+            Some(index) => {\n+                for self.each_base_path(index) |p| {\n+                    result.push(p);\n+                }\n+            }\n+            None => {\n+                match *lp {\n+                    LpVar(*) => { }\n+                    LpExtend(b, _, _) => {\n+                        self.add_existing_base_paths(b, result);\n+                    }\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    pub fn add_move(&mut self,\n+                    tcx: ty::ctxt,\n+                    lp: @LoanPath,\n+                    id: ast::node_id,\n+                    kind: MoveKind) {\n+        /*!\n+         * Adds a new move entry for a move of `lp` that occurs at\n+         * location `id` with kind `kind`.\n+         */\n+\n+        debug!(\"add_move(lp=%s, id=%?, kind=%?)\",\n+               lp.repr(tcx),\n+               id,\n+               kind);\n+\n+        let path_index = self.move_path(tcx, lp);\n+        let move_index = MoveIndex(self.moves.len());\n+\n+        let next_move = self.path(path_index).first_move;\n+        self.mut_path(path_index).first_move = move_index;\n+\n+        self.moves.push(Move {\n+            path: path_index,\n+            id: id,\n+            kind: kind,\n+            next_move: next_move\n+        });\n+    }\n+\n+    pub fn add_assignment(&mut self,\n+                          tcx: ty::ctxt,\n+                          lp: @LoanPath,\n+                          assign_id: ast::node_id,\n+                          span: span,\n+                          assignee_id: ast::node_id) {\n+        /*!\n+         * Adds a new record for an assignment to `lp` that occurs at\n+         * location `id` with the given `span`.\n+         */\n+\n+        debug!(\"add_assignment(lp=%s, assign_id=%?, assignee_id=%?\",\n+               lp.repr(tcx), assign_id, assignee_id);\n+\n+        let path_index = self.move_path(tcx, lp);\n+\n+        self.assignee_ids.insert(assignee_id);\n+\n+        let assignment = Assignment {\n+            path: path_index,\n+            id: assign_id,\n+            span: span,\n+        };\n+\n+        if self.is_var_path(path_index) {\n+            debug!(\"add_assignment[var](lp=%s, assignment=%u, path_index=%?)\",\n+                   lp.repr(tcx), self.var_assignments.len(), path_index);\n+\n+            self.var_assignments.push(assignment);\n+        } else {\n+            debug!(\"add_assignment[path](lp=%s, path_index=%?)\",\n+                   lp.repr(tcx), path_index);\n+\n+            self.path_assignments.push(assignment);\n+        }\n+    }\n+\n+    fn add_gen_kills(&self,\n+                     tcx: ty::ctxt,\n+                     dfcx_moves: &mut MoveDataFlow,\n+                     dfcx_assign: &mut AssignDataFlow) {\n+        /*!\n+         * Adds the gen/kills for the various moves and\n+         * assignments into the provided data flow contexts.\n+         * Moves are generated by moves and killed by assignments and\n+         * scoping. Assignments are generated by assignment to variables and\n+         * killed by scoping. See `doc.rs` for more details.\n+         */\n+\n+        for self.moves.eachi |i, move| {\n+            dfcx_moves.add_gen(move.id, i);\n+        }\n+\n+        for self.var_assignments.eachi |i, assignment| {\n+            dfcx_assign.add_gen(assignment.id, i);\n+            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+        }\n+\n+        for self.path_assignments.each |assignment| {\n+            self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n+        }\n+\n+        // Kill all moves related to a variable `x` when it goes out\n+        // of scope:\n+        for self.paths.each |path| {\n+            match *path.loan_path {\n+                LpVar(id) => {\n+                    let kill_id = tcx.region_maps.encl_scope(id);\n+                    let path = *self.path_map.get(&path.loan_path);\n+                    self.kill_moves(path, kill_id, dfcx_moves);\n+                }\n+                LpExtend(*) => {}\n+            }\n+        }\n+\n+        // Kill all assignments when the variable goes out of scope:\n+        for self.var_assignments.eachi |assignment_index, assignment| {\n+            match *self.path(assignment.path).loan_path {\n+                LpVar(id) => {\n+                    let kill_id = tcx.region_maps.encl_scope(id);\n+                    dfcx_assign.add_kill(kill_id, assignment_index);\n+                }\n+                LpExtend(*) => {\n+                    tcx.sess.bug(\"Var assignment for non var path\");\n+                }\n+            }\n+        }\n+    }\n+\n+    fn each_base_path(&self,\n+                      index: MovePathIndex,\n+                      f: &fn(MovePathIndex) -> bool)\n+                      -> bool {\n+        let mut p = index;\n+        while p != InvalidMovePathIndex {\n+            if !f(p) {\n+                return false;\n+            }\n+            p = self.path(p).parent;\n+        }\n+        return true;\n+    }\n+\n+    fn each_extending_path(&self,\n+                           index: MovePathIndex,\n+                           f: &fn(MovePathIndex) -> bool) -> bool {\n+        if !f(index) {\n+            return false;\n+        }\n+\n+        let mut p = self.path(index).first_child;\n+        while p != InvalidMovePathIndex {\n+            if !self.each_extending_path(p, f) {\n+                return false;\n+            }\n+            p = self.path(p).next_sibling;\n+        }\n+\n+        return true;\n+    }\n+\n+    fn each_applicable_move(&self,\n+                            index0: MovePathIndex,\n+                            f: &fn(MoveIndex) -> bool) -> bool {\n+        for self.each_extending_path(index0) |index| {\n+            let mut p = self.path(index).first_move;\n+            while p != InvalidMoveIndex {\n+                if !f(p) {\n+                    return false;\n+                }\n+                p = self.move(p).next_move;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    fn kill_moves(&self,\n+                  path: MovePathIndex,\n+                  kill_id: ast::node_id,\n+                  dfcx_moves: &mut MoveDataFlow) {\n+        for self.each_applicable_move(path) |move_index| {\n+            dfcx_moves.add_kill(kill_id, *move_index);\n+        }\n+    }\n+}\n+\n+impl FlowedMoveData {\n+    pub fn new(move_data: @mut MoveData,\n+               tcx: ty::ctxt,\n+               method_map: typeck::method_map,\n+               id_range: ast_util::id_range,\n+               body: &ast::blk)\n+               -> FlowedMoveData\n+    {\n+        let mut dfcx_moves =\n+            DataFlowContext::new(tcx,\n+                                 method_map,\n+                                 MoveDataFlowOperator,\n+                                 id_range,\n+                                 move_data.moves.len());\n+        let mut dfcx_assign =\n+            DataFlowContext::new(tcx,\n+                                 method_map,\n+                                 AssignDataFlowOperator,\n+                                 id_range,\n+                                 move_data.var_assignments.len());\n+        move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n+        dfcx_moves.propagate(body);\n+        dfcx_assign.propagate(body);\n+        FlowedMoveData {\n+            move_data: move_data,\n+            dfcx_moves: dfcx_moves,\n+            dfcx_assign: dfcx_assign,\n+        }\n+    }\n+\n+    pub fn each_move_of(&self,\n+                        id: ast::node_id,\n+                        loan_path: @LoanPath,\n+                        f: &fn(&Move, @LoanPath) -> bool)\n+                        -> bool {\n+        /*!\n+         * Iterates through each move of `loan_path` (or some base path\n+         * of `loan_path`) that *may* have occurred on entry to `id` without\n+         * an intervening assignment. In other words, any moves that\n+         * would invalidate a reference to `loan_path` at location `id`.\n+         */\n+\n+        // Bad scenarios:\n+        //\n+        // 1. Move of `a.b.c`, use of `a.b.c`\n+        // 2. Move of `a.b.c`, use of `a.b.c.d`\n+        // 3. Move of `a.b.c`, use of `a` or `a.b`\n+        //\n+        // OK scenario:\n+        //\n+        // 4. move of `a.b.c`, use of `a.b.d`\n+\n+        let base_indices = self.move_data.existing_base_paths(loan_path);\n+        if base_indices.is_empty() {\n+            return true;\n+        }\n+\n+        let opt_loan_path_index = self.move_data.existing_move_path(loan_path);\n+\n+        for self.dfcx_moves.each_bit_on_entry(id) |index| {\n+            let move = &self.move_data.moves[index];\n+            let moved_path = move.path;\n+            if base_indices.contains(&moved_path) {\n+                // Scenario 1 or 2: `loan_path` or some base path of\n+                // `loan_path` was moved.\n+                if !f(move, self.move_data.path(moved_path).loan_path) {\n+                    return false;\n+                }\n+                loop;\n+            }\n+\n+            for opt_loan_path_index.each |&loan_path_index| {\n+                for self.move_data.each_base_path(moved_path) |p| {\n+                    if p == loan_path_index {\n+                        // Scenario 3: some extension of `loan_path`\n+                        // was moved\n+                        if !f(move, self.move_data.path(moved_path).loan_path) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pub fn is_assignee(&self,\n+                       id: ast::node_id)\n+                       -> bool {\n+        //! True if `id` is the id of the LHS of an assignment\n+\n+        self.move_data.assignee_ids.contains(&id)\n+    }\n+\n+    pub fn each_assignment_of(&self,\n+                              id: ast::node_id,\n+                              loan_path: @LoanPath,\n+                              f: &fn(&Assignment) -> bool)\n+                              -> bool {\n+        /*!\n+         * Iterates through every assignment to `loan_path` that\n+         * may have occurred on entry to `id`. `loan_path` must be\n+         * a single variable.\n+         */\n+\n+        let loan_path_index = {\n+            match self.move_data.existing_move_path(loan_path) {\n+                Some(i) => i,\n+                None => {\n+                    // if there were any assignments, it'd have an index\n+                    return true;\n+                }\n+            }\n+        };\n+\n+        for self.dfcx_assign.each_bit_on_entry(id) |index| {\n+            let assignment = &self.move_data.var_assignments[index];\n+            if assignment.path == loan_path_index && !f(assignment) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n+\n+impl DataFlowOperator for MoveDataFlowOperator {\n+    #[inline(always)]\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n+    }\n+\n+    #[inline(always)]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // moves from both preds are in scope\n+    }\n+\n+    #[inline(always)]\n+    fn walk_closures(&self) -> bool {\n+        true\n+    }\n+}\n+\n+impl DataFlowOperator for AssignDataFlowOperator {\n+    #[inline(always)]\n+    fn initial_value(&self) -> bool {\n+        false // no assignments in scope by default\n+    }\n+\n+    #[inline(always)]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // moves from both preds are in scope\n+    }\n+\n+    #[inline(always)]\n+    fn walk_closures(&self) -> bool {\n+        true\n+    }\n+}"}, {"sha": "748ae83a60c570e32b25192641fe6af68bf6fdd9", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -866,7 +866,7 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n \n     if !any_by_move { return; } // pointless micro-optimization\n     for pats.each |pat| {\n-        do walk_pat(*pat) |p| {\n+        for walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n                     pat_ident(_, _, sub) => {\n@@ -884,66 +884,5 @@ pub fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n                 }\n             }\n         }\n-\n-        // Now check to ensure that any move binding is not behind an\n-        // @ or &, or within a struct with a destructor.  This is\n-        // always illegal.\n-        let vt = visit::mk_vt(@visit::Visitor {\n-            visit_pat: |pat, (behind_bad_pointer, behind_dtor_struct): (bool, bool), v| {\n-                match pat.node {\n-                    pat_ident(_, _, sub) => {\n-                        debug!(\"(check legality of move) checking pat \\\n-                                ident with behind_bad_pointer %? and behind_dtor_struct %?\",\n-                               behind_bad_pointer, behind_dtor_struct);\n-\n-                        if behind_bad_pointer || behind_dtor_struct &&\n-                            cx.moves_map.contains(&pat.id)\n-                        {\n-                            let msg = if behind_bad_pointer {\n-                                \"by-move pattern bindings may not occur behind @ or & bindings\"\n-                            } else {\n-                                \"cannot bind by-move within struct (it has a destructor)\"\n-                            };\n-                            cx.tcx.sess.span_err(pat.span, msg);\n-                        }\n-\n-                        match sub {\n-                            None => {}\n-                            Some(subpat) => {\n-                                (v.visit_pat)(subpat,\n-                                              (behind_bad_pointer, behind_dtor_struct),\n-                                              v);\n-                            }\n-                        }\n-                    }\n-\n-                    pat_box(subpat) | pat_region(subpat) => {\n-                        (v.visit_pat)(subpat, (true, behind_dtor_struct), v);\n-                    }\n-\n-                    pat_struct(_, ref fields, _) => {\n-                        let behind_dtor_struct = behind_dtor_struct ||\n-                            (match cx.tcx.def_map.find(&pat.id) {\n-                                Some(&def_struct(id)) => {\n-                                    ty::has_dtor(cx.tcx, id)\n-                                }\n-                                _ => false\n-                            });\n-                        debug!(\"(check legality of move) checking pat \\\n-                                struct with behind_bad_pointer %? and behind_dtor_struct %?\",\n-                               behind_bad_pointer, behind_dtor_struct);\n-\n-                        for fields.each |fld| {\n-                            (v.visit_pat)(fld.pat, (behind_bad_pointer,\n-                                                    behind_dtor_struct), v)\n-                        }\n-                    }\n-\n-                    _ => visit::visit_pat(pat, (behind_bad_pointer, behind_dtor_struct), v)\n-                }\n-            },\n-            .. *visit::default_visitor::<(bool, bool)>()\n-        });\n-        (vt.visit_pat)(*pat, (false, false), vt);\n     }\n }"}, {"sha": "e0806359c5d092a656b54456b6f439980a043653", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -651,10 +651,10 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_struct(_, ref fields, with_expr) => {\n-                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n                 for fields.each |field| {\n                     self.walk_expr(field.node.expr, in_out, loop_scopes);\n                 }\n+                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n             }\n \n             ast::expr_call(f, ref args, _) => {\n@@ -826,7 +826,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         debug!(\"DataFlowContext::walk_pat(pat=%s, in_out=%s)\",\n                pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n \n-        do ast_util::walk_pat(pat) |p| {\n+        for ast_util::walk_pat(pat) |p| {\n             debug!(\"  p.id=%? in_out=%s\", p.id, bits_to_str(reslice(in_out)));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);"}, {"sha": "4897d6c87dec191e3935b5c1f0ad0d7bdee11f22", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 180, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -109,7 +109,6 @@ use middle::pat_util;\n use middle::ty;\n use middle::typeck;\n use middle::moves;\n-use util::ppaux::ty_to_str;\n \n use core::cast::transmute;\n use core::hashmap::HashMap;\n@@ -146,7 +145,6 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n \n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n-                   variable_moves_map: moves::VariableMovesMap,\n                    capture_map: moves::CaptureMap,\n                    crate: @crate) {\n     let visitor = visit::mk_vt(@visit::Visitor {\n@@ -159,7 +157,6 @@ pub fn check_crate(tcx: ty::ctxt,\n \n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n-                                   variable_moves_map,\n                                    capture_map);\n     visit::visit_crate(crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n@@ -229,7 +226,6 @@ enum VarKind {\n struct IrMaps {\n     tcx: ty::ctxt,\n     method_map: typeck::method_map,\n-    variable_moves_map: moves::VariableMovesMap,\n     capture_map: moves::CaptureMap,\n \n     num_live_nodes: uint,\n@@ -243,13 +239,11 @@ struct IrMaps {\n \n fn IrMaps(tcx: ty::ctxt,\n           method_map: typeck::method_map,\n-          variable_moves_map: moves::VariableMovesMap,\n           capture_map: moves::CaptureMap)\n        -> IrMaps {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n-        variable_moves_map: variable_moves_map,\n         capture_map: capture_map,\n         num_live_nodes: 0,\n         num_vars: 0,\n@@ -349,7 +343,6 @@ fn visit_fn(fk: &visit::fn_kind,\n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @mut IrMaps(this.tcx,\n                               this.method_map,\n-                              this.variable_moves_map,\n                               this.capture_map);\n \n     unsafe {\n@@ -1399,11 +1392,7 @@ pub impl Liveness {\n fn check_local(local: @local, this: @Liveness, vt: vt<@Liveness>) {\n     match local.node.init {\n       Some(_) => {\n-\n-        // Initializer:\n         this.warn_about_unused_or_dead_vars_in_pat(local.node.pat);\n-        this.check_for_reassignments_in_pat(local.node.pat,\n-                                            local.node.is_mutbl);\n       }\n       None => {\n \n@@ -1438,35 +1427,6 @@ fn check_arm(arm: &arm, this: @Liveness, vt: vt<@Liveness>) {\n \n fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n-      expr_path(_) | expr_self => {\n-        for this.variable_from_def_map(expr.id, expr.span).each |var| {\n-            let ln = this.live_node(expr.id, expr.span);\n-\n-            match this.ir.variable_moves_map.find(&expr.id) {\n-                None => {}\n-                Some(&entire_expr) => {\n-                    debug!(\"(checking expr) is a move: `%s`\",\n-                           expr_to_str(expr, this.tcx.sess.intr()));\n-                    this.check_move_from_var(ln, *var, entire_expr);\n-                }\n-            }\n-        }\n-\n-        visit::visit_expr(expr, this, vt);\n-      }\n-\n-      expr_fn_block(*) => {\n-        let caps = this.ir.captures(expr);\n-        for caps.each |cap| {\n-            let var = this.variable(cap.var_nid, expr.span);\n-            if cap.is_move {\n-                this.check_move_from_var(cap.ln, var, expr);\n-            }\n-        }\n-\n-        visit::visit_expr(expr, this, vt);\n-      }\n-\n       expr_assign(l, r) => {\n         this.check_lvalue(l, vt);\n         (vt.visit_expr)(r, this, vt);\n@@ -1507,7 +1467,7 @@ fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n       expr_cast(*) | expr_unary(*) | expr_ret(*) | expr_break(*) |\n       expr_again(*) | expr_lit(_) | expr_block(*) |\n       expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n-      expr_paren(*) => {\n+      expr_paren(*) | expr_fn_block(*) | expr_path(*) | expr_self(*) => {\n         visit::visit_expr(expr, this, vt);\n       }\n     }\n@@ -1547,43 +1507,17 @@ pub impl Liveness {\n         }\n     }\n \n-    fn check_move_from_var(&self,\n-                           ln: LiveNode,\n-                           var: Variable,\n-                           move_expr: @expr) {\n-        /*!\n-         * Checks whether `var` is live on entry to any of the\n-         * successors of `ln`.  If it is, report an error.\n-         * `move_expr` is the expression which caused the variable\n-         * to be moved.\n-         *\n-         * Note that `move_expr` is not necessarily a reference to the\n-         * variable.  It might be an expression like `x.f` which could\n-         * cause a move of the variable `x`, or a closure creation.\n-         */\n-\n-        debug!(\"check_move_from_var(%s, %s)\",\n-               ln.to_str(), var.to_str());\n-\n-        match self.live_on_exit(ln, var) {\n-          None => {}\n-          Some(lnk) => self.report_illegal_move(lnk, var, move_expr)\n-        }\n-    }\n-\n     fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get_copy(&expr.id) {\n-              def_local(nid, mutbl) => {\n+              def_local(nid, _) => {\n                 // Assignment to an immutable variable or argument: only legal\n                 // if there is no later assignment. If this local is actually\n                 // mutable, then check for a reassignment to flag the mutability\n                 // as being used.\n                 let ln = self.live_node(expr.id, expr.span);\n                 let var = self.variable(nid, expr.span);\n-                self.check_for_reassignment(ln, var, expr.span,\n-                                            if mutbl {Some(nid)} else {None});\n                 self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n               }\n               def => {\n@@ -1607,118 +1541,6 @@ pub impl Liveness {\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(&self, pat: @pat, mutbl: bool) {\n-        do self.pat_bindings(pat) |ln, var, sp, id| {\n-            self.check_for_reassignment(ln, var, sp,\n-                                        if mutbl {Some(id)} else {None});\n-        }\n-    }\n-\n-    fn check_for_reassignment(&self, ln: LiveNode, var: Variable,\n-                              orig_span: span, mutbl: Option<node_id>) {\n-        match self.assigned_on_exit(ln, var) {\n-          Some(ExprNode(span)) => {\n-            match mutbl {\n-              Some(id) => { self.tcx.used_mut_nodes.insert(id); }\n-              None => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"re-assignment of immutable variable\");\n-                self.tcx.sess.span_note(\n-                    orig_span,\n-                    \"prior assignment occurs here\");\n-              }\n-            }\n-          }\n-          Some(lnk) => {\n-            self.tcx.sess.span_bug(\n-                orig_span,\n-                fmt!(\"illegal writer: %?\", lnk));\n-          }\n-          None => {}\n-        }\n-    }\n-\n-    fn report_illegal_move(&self, lnk: LiveNodeKind,\n-                           var: Variable,\n-                           move_expr: @expr) {\n-        // the only time that it is possible to have a moved variable\n-        // used by ExitNode would be arguments or fields in a ctor.\n-        // we give a slightly different error message in those cases.\n-        if lnk == ExitNode {\n-            // FIXME #4715: this seems like it should be reported in the\n-            // borrow checker\n-            let vk = self.ir.var_kinds[*var];\n-            match vk {\n-              Arg(_, name) => {\n-                self.tcx.sess.span_err(\n-                    move_expr.span,\n-                    fmt!(\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", *self.tcx.sess.str_of(name)));\n-                return;\n-              }\n-              Local(*) | ImplicitRet => {\n-                self.tcx.sess.span_bug(\n-                    move_expr.span,\n-                    fmt!(\"illegal reader (%?) for `%?`\",\n-                         lnk, vk));\n-              }\n-            }\n-        }\n-\n-        match move_expr.node {\n-            expr_fn_block(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, MovedValue);\n-                let name = self.ir.variable_name(var);\n-                self.tcx.sess.span_note(\n-                    move_expr.span,\n-                    fmt!(\"`%s` moved into closure environment here \\\n-                          because its type is moved by default\",\n-                         *name));\n-            }\n-            expr_path(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, MovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"\", \"it\");\n-            }\n-            expr_field(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, PartiallyMovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"field of \", \"the field\");\n-            }\n-            expr_index(*) => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, PartiallyMovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"element of \", \"the element\");\n-            }\n-            _ => {\n-                self.report_illegal_read(\n-                    move_expr.span, lnk, var, PartiallyMovedValue);\n-                self.report_move_location(\n-                    move_expr, var, \"subcomponent of \", \"the subcomponent\");\n-            }\n-        };\n-    }\n-\n-    fn report_move_location(&self,\n-                            move_expr: @expr,\n-                            var: Variable,\n-                            expr_descr: &str,\n-                            pronoun: &str) {\n-        let move_expr_ty = ty::expr_ty(self.tcx, move_expr);\n-        let name = self.ir.variable_name(var);\n-        self.tcx.sess.span_note(\n-            move_expr.span,\n-            fmt!(\"%s`%s` moved here because %s has type %s, \\\n-                  which is moved by default (use `copy` to override)\",\n-                 expr_descr, *name, pronoun,\n-                 ty_to_str(self.tcx, move_expr_ty)));\n-    }\n-\n     fn report_illegal_read(&self,\n                            chk_span: span,\n                            lnk: LiveNodeKind,"}, {"sha": "0d335559747249d48500e00d170fe16b7645f3ff", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -93,19 +93,26 @@ pub enum ptr_kind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n-    InteriorElement(ty::t),    // ty::t is the type of the vec/str\n+    InteriorElement(ElementKind),\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n pub enum FieldName {\n     NamedField(ast::ident),\n     PositionalField(uint)\n }\n \n-#[deriving(Eq)]\n+#[deriving(Eq, IterBytes)]\n+pub enum ElementKind {\n+    VecElement,\n+    StrElement,\n+    OtherElement,\n+}\n+\n+#[deriving(Eq, IterBytes)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McReadOnly,  // Read-only (`const`)\n@@ -192,7 +199,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n \n         ty::ty_evec(_, ty::vstore_fixed(_)) |\n         ty::ty_estr(ty::vstore_fixed(_)) => {\n-            Some(deref_interior(InteriorElement(t)))\n+            Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n         _ => None\n@@ -749,7 +756,7 @@ pub impl mem_categorization_ctxt {\n             @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n-                cat:cat_interior(of_cmt, InteriorElement(vec_ty)),\n+                cat:cat_interior(of_cmt, InteriorElement(element_kind(vec_ty))),\n                 mutbl:mutbl,\n                 ty:mt.ty\n             }\n@@ -993,12 +1000,14 @@ pub impl mem_categorization_ctxt {\n           cat_interior(_, InteriorField(PositionalField(_))) => {\n               ~\"anonymous field\"\n           }\n-          cat_interior(_, InteriorElement(t)) => {\n-            match ty::get(t).sty {\n-              ty::ty_evec(*) => ~\"vec content\",\n-              ty::ty_estr(*) => ~\"str content\",\n-              _ => ~\"indexed content\"\n-            }\n+          cat_interior(_, InteriorElement(VecElement)) => {\n+              ~\"vec content\"\n+          }\n+          cat_interior(_, InteriorElement(StrElement)) => {\n+              ~\"str content\"\n+          }\n+          cat_interior(_, InteriorElement(OtherElement)) => {\n+              ~\"indexed content\"\n           }\n           cat_stack_upvar(_) => {\n               ~\"captured outer variable\"\n@@ -1193,3 +1202,11 @@ impl Repr for InteriorKind {\n         }\n     }\n }\n+\n+fn element_kind(t: ty::t) -> ElementKind {\n+    match ty::get(t).sty {\n+        ty::ty_evec(*) => VecElement,\n+        ty::ty_estr(*) => StrElement,\n+        _ => OtherElement\n+    }\n+}"}, {"sha": "abec56d32d79edbd783d2e645304b8a183691987", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 54, "deletions": 202, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -88,112 +88,32 @@ Similar reasoning can be applied to `let` expressions:\n \n ## Output\n \n-The pass results in the struct `MoveMaps` which contains two sets,\n-`moves_map` and `variable_moves_map`, and one map, `capture_map`.\n-\n-`moves_map` is a set containing the id of every *outermost\n-expression* or *binding* that is moved.  Note that `moves_map` only\n-contains the *outermost expressions* that are moved.  Therefore, if\n-you have a use of `x.b`, as in the example `y` above, the\n-expression `x.b` would be in the `moves_map` but not `x`.  The\n-reason for this is that, for most purposes, it's only the outermost\n-expression that is needed.  The borrow checker and trans, for\n-example, only care about the outermost expressions that are moved.\n-It is more efficient therefore just to store those entries.\n-\n-In the case of the liveness pass, however, we need to know which\n-*variable references* are moved (see the Enforcement of Moves\n-section below for more details).  That is, for the `x.b`\n-expression, liveness only cares about the `x`.  For this purpose,\n-we have a second map, `variable_moves_map`, that contains the ids\n-of all variable references which is moved.\n-\n-The `capture_map` maps from the node_id of a closure expression to an\n-array of `CaptureVar` structs detailing which variables are captured\n-and how (by ref, by copy, by move).\n+The pass results in the struct `MoveMaps` which contains several\n+maps:\n+\n+`moves_map` is a set containing the id of every *outermost expression* or\n+*binding* that causes a move.  Note that `moves_map` only contains the *outermost\n+expressions* that are moved.  Therefore, if you have a use of `x.b`,\n+as in the example `y` above, the expression `x.b` would be in the\n+`moves_map` but not `x`.  The reason for this is that, for most\n+purposes, it's only the outermost expression that is needed.  The\n+borrow checker and trans, for example, only care about the outermost\n+expressions that are moved.  It is more efficient therefore just to\n+store those entries.\n+\n+Sometimes though we want to know the variables that are moved (in\n+particular in the borrow checker). For these cases, the set\n+`moved_variables_set` just collects the ids of variables that are\n+moved.\n+\n+Finally, the `capture_map` maps from the node_id of a closure\n+expression to an array of `CaptureVar` structs detailing which\n+variables are captured and how (by ref, by copy, by move).\n \n ## Enforcement of Moves\n \n-The enforcement of moves is somewhat complicated because it is divided\n-amongst the liveness and borrowck modules. In general, the borrow\n-checker is responsible for guaranteeing that *only owned data is\n-moved*.  The liveness checker, in contrast, is responsible for\n-checking that *no variable is used after it is moved*.\n-\n-To see the difference, let's look at a few examples.  Here is a\n-program fragment where the error would be caught by liveness:\n-\n-    struct Foo { a: int, b: ~int }\n-    let x: Foo = ...;\n-    let y = x.b; // (1)\n-    let z = x;   // (2)            //~ ERROR use of moved value `x`\n-\n-Here the liveness checker will see the assignment to `y` moves\n-invalidates the variable `x` because it moves the expression `x.b`.\n-An error is resported because `x` is not dead at the point where it is\n-invalidated.\n-\n-In more concrete terms, the `moves_map` generated from this example\n-would contain both the expression `x.b` (1) and the expression `x`\n-(2).  Note that it would not contain `x` (1), because `moves_map` only\n-contains the outermost expressions that are moved.  However,\n-`moves_map` is not used by liveness.  It uses the\n-`variable_moves_map`, which would contain both references to `x`: (1)\n-and (2).  Therefore, after computing which variables are live where,\n-liveness will see that the reference (1) to `x` is both present in\n-`variable_moves_map` and that `x` is live and report an error.\n-\n-Now let's look at another illegal example, but one where liveness would\n-not catch the error:\n-\n-    struct Foo { a: int, b: ~int }\n-    let x: @Foo = ...;\n-    let y = x.b;                   //~ ERROR move from managed (@) box\n-\n-This is an interesting example because the only change I've made is\n-to make `x` have type `@Foo` and not `Foo`.  Thanks to auto-deref,\n-the expression `x.b` still works, but now it is short for `{x).b`,\n-and hence the move is actually moving out of the contents of a\n-managed box, which is illegal.  However, liveness knows nothing of\n-this.  It only tracks what variables are used where.  The moves\n-pass (that is, this pass) is also ignorant of such details.  From\n-the perspective of the moves pass, the `let y = x.b` line above\n-will be categorized as follows:\n-\n-    let y = {(x{Move}) {Move}).b; {Move}\n-\n-Therefore, the reference to `x` will be present in\n-`variable_moves_map`, but liveness will not report an error because\n-there is no subsequent use.\n-\n-This is where the borrow checker comes in.  When the borrow checker\n-runs, it will see that `x.b` is present in the `moves_map`.  It will\n-use the `mem_categorization` module to determine where the result of\n-this expression resides in memory and see that it is owned by managed\n-data, and report an error.\n-\n-In principle, liveness could use the `mem_categorization` module\n-itself and check that moves always originate from owned data\n-(historically, of course, this was not the case; `mem_categorization`\n-used to be private to the borrow checker).  However, there is another\n-kind of error which liveness could not possibly detect. Sometimes a\n-move is an error due to an outstanding loan, and it is borrow\n-checker's job to compute those loans.  That is, consider *this*\n-example:\n-\n-    struct Foo { a: int, b: ~int }\n-    let x: Foo = ...;\n-    let y = &x.b;                   //~ NOTE loan issued here\n-    let z = x.b;                    //~ ERROR move with outstanding loan\n-\n-In this case, `y` is a pointer into `x`, so when `z` tries to move out\n-of `x`, we get an error.  There is no way that liveness could compute\n-this information without redoing the efforts of the borrow checker.\n-\n-### Closures\n-\n-Liveness is somewhat complicated by having to deal with stack\n-closures.  More information to come!\n+The enforcement of moves is done by the borrow checker.  Please see\n+the section \"Moves and initialization\" in `middle/borrowck/doc.rs`.\n \n ## Distributive property\n \n@@ -213,14 +133,14 @@ use middle::freevars;\n use middle::ty;\n use middle::typeck::{method_map};\n use util::ppaux;\n+use util::ppaux::Repr;\n use util::common::indenter;\n \n use core::hashmap::{HashSet, HashMap};\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;\n use syntax::visit::vt;\n-use syntax::print::pprust;\n use syntax::codemap::span;\n \n #[deriving(Encodable, Decodable)]\n@@ -241,11 +161,6 @@ pub type CaptureMap = @mut HashMap<node_id, @[CaptureVar]>;\n \n pub type MovesMap = @mut HashSet<node_id>;\n \n-/**\n- * For each variable which will be moved, links to the\n- * expression */\n-pub type VariableMovesMap = @mut HashMap<node_id, @expr>;\n-\n /**\n  * Set of variable node-ids that are moved.\n  *\n@@ -257,7 +172,6 @@ pub type MovedVariablesSet = @mut HashSet<node_id>;\n /** See the section Output on the module comment for explanation. */\n pub struct MoveMaps {\n     moves_map: MovesMap,\n-    variable_moves_map: VariableMovesMap,\n     moved_variables_set: MovedVariablesSet,\n     capture_map: CaptureMap\n }\n@@ -269,9 +183,8 @@ struct VisitContext {\n }\n \n enum UseMode {\n-    MoveInWhole,         // Move the entire value.\n-    MoveInPart(@expr),   // Some subcomponent will be moved\n-    Read                 // Read no matter what the type.\n+    Move,        // This value or something owned by it is moved.\n+    Read         // Read no matter what the type.\n }\n \n pub fn compute_moves(tcx: ty::ctxt,\n@@ -287,7 +200,6 @@ pub fn compute_moves(tcx: ty::ctxt,\n         method_map: method_map,\n         move_maps: MoveMaps {\n             moves_map: @mut HashSet::new(),\n-            variable_moves_map: @mut HashMap::new(),\n             capture_map: @mut HashMap::new(),\n             moved_variables_set: @mut HashSet::new()\n         }\n@@ -317,21 +229,6 @@ fn compute_modes_for_expr(expr: @expr,\n     cx.consume_expr(expr, v);\n }\n \n-pub impl UseMode {\n-    fn component_mode(&self, expr: @expr) -> UseMode {\n-        /*!\n-         *\n-         * Assuming that `self` is the mode for an expression E,\n-         * returns the appropriate mode to use for a subexpression of E.\n-         */\n-\n-        match *self {\n-            Read | MoveInPart(_) => *self,\n-            MoveInWhole => MoveInPart(expr)\n-        }\n-    }\n-}\n-\n pub impl VisitContext {\n     fn consume_exprs(&self,\n                      exprs: &[@expr],\n@@ -347,26 +244,27 @@ pub impl VisitContext {\n                     visitor: vt<VisitContext>)\n     {\n         /*!\n-         *\n          * Indicates that the value of `expr` will be consumed,\n          * meaning either copied or moved depending on its type.\n          */\n \n-        debug!(\"consume_expr(expr=%?/%s)\",\n-               expr.id,\n-               pprust::expr_to_str(expr, self.tcx.sess.intr()));\n+        debug!(\"consume_expr(expr=%s)\",\n+               expr.repr(self.tcx));\n \n         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-        let mode = self.consume_mode_for_ty(expr_ty);\n-        self.use_expr(expr, mode, visitor);\n+        if ty::type_moves_by_default(self.tcx, expr_ty) {\n+            self.move_maps.moves_map.insert(expr.id);\n+            self.use_expr(expr, Move, visitor);\n+        } else {\n+            self.use_expr(expr, Read, visitor);\n+        };\n     }\n \n     fn consume_block(&self,\n                      blk: &blk,\n                      visitor: vt<VisitContext>)\n     {\n         /*!\n-         *\n          * Indicates that the value of `blk` will be consumed,\n          * meaning either copied or moved depending on its type.\n          */\n@@ -382,76 +280,42 @@ pub impl VisitContext {\n         }\n     }\n \n-    fn consume_mode_for_ty(&self, ty: ty::t) -> UseMode {\n-        /*!\n-         *\n-         * Selects the appropriate `UseMode` to consume a value with\n-         * the type `ty`.  This will be `MoveEntireMode` if `ty` is\n-         * not implicitly copyable.\n-         */\n-\n-        let result = if ty::type_moves_by_default(self.tcx, ty) {\n-            MoveInWhole\n-        } else {\n-            Read\n-        };\n-\n-        debug!(\"consume_mode_for_ty(ty=%s) = %?\",\n-               ppaux::ty_to_str(self.tcx, ty), result);\n-\n-        return result;\n-    }\n-\n     fn use_expr(&self,\n                 expr: @expr,\n                 expr_mode: UseMode,\n                 visitor: vt<VisitContext>)\n     {\n         /*!\n-         *\n          * Indicates that `expr` is used with a given mode.  This will\n          * in turn trigger calls to the subcomponents of `expr`.\n          */\n \n-        debug!(\"use_expr(expr=%?/%s, mode=%?)\",\n-               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()),\n+        debug!(\"use_expr(expr=%s, mode=%?)\",\n+               expr.repr(self.tcx),\n                expr_mode);\n \n-        match expr_mode {\n-            MoveInWhole => { self.move_maps.moves_map.insert(expr.id); }\n-            MoveInPart(_) | Read => {}\n-        }\n-\n         // `expr_mode` refers to the post-adjustment value.  If one of\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n         let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n             Some(&@ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoref: Some(_), _})) => Read,\n-            _ => expr_mode.component_mode(expr)\n+            _ => expr_mode\n         };\n \n         debug!(\"comp_mode = %?\", comp_mode);\n \n         match expr.node {\n             expr_path(*) | expr_self => {\n                 match comp_mode {\n-                    MoveInPart(entire_expr) => {\n-                        self.move_maps.variable_moves_map.insert(\n-                            expr.id, entire_expr);\n-\n+                    Move => {\n                         let def = self.tcx.def_map.get_copy(&expr.id);\n                         for moved_variable_node_id_from_def(def).each |&id| {\n                             self.move_maps.moved_variables_set.insert(id);\n                         }\n                     }\n                     Read => {}\n-                    MoveInWhole => {\n-                        self.tcx.sess.span_bug(\n-                            expr.span,\n-                            \"Component mode can never be MoveInWhole\");\n-                    }\n                 }\n             }\n \n@@ -546,19 +410,10 @@ pub impl VisitContext {\n                     self.consume_arm(arm, visitor);\n                 }\n \n-                let by_move_bindings_present =\n-                    self.arms_have_by_move_bindings(\n-                        self.move_maps.moves_map, *arms);\n-\n-                if by_move_bindings_present {\n-                    // If one of the arms moves a value out of the\n-                    // discriminant, then the discriminant itself is\n-                    // moved.\n-                    self.consume_expr(discr, visitor);\n-                } else {\n-                    // Otherwise, the discriminant is merely read.\n-                    self.use_expr(discr, Read, visitor);\n-                }\n+                // The discriminant may, in fact, be partially moved\n+                // if there are by-move bindings, but borrowck deals\n+                // with that itself.\n+                self.use_expr(discr, Read, visitor);\n             }\n \n             expr_copy(base) => {\n@@ -719,18 +574,17 @@ pub impl VisitContext {\n          */\n \n         do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, _path| {\n-            let mode = match bm {\n-                bind_by_copy => Read,\n-                bind_by_ref(_) => Read,\n+            let binding_moves = match bm {\n+                bind_by_copy => false,\n+                bind_by_ref(_) => false,\n                 bind_infer => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n-                    self.consume_mode_for_ty(pat_ty)\n+                    ty::type_moves_by_default(self.tcx, pat_ty)\n                 }\n             };\n \n-            match mode {\n-                MoveInWhole => { self.move_maps.moves_map.insert(id); }\n-                MoveInPart(_) | Read => {}\n+            if binding_moves {\n+                self.move_maps.moves_map.insert(id);\n             }\n         }\n     }\n@@ -759,20 +613,18 @@ pub impl VisitContext {\n \n     fn arms_have_by_move_bindings(&self,\n                                   moves_map: MovesMap,\n-                                  arms: &[arm]) -> bool\n+                                  arms: &[arm]) -> Option<@pat>\n     {\n         for arms.each |arm| {\n-            for arm.pats.each |pat| {\n-                let mut found = false;\n-                do pat_bindings(self.tcx.def_map, *pat) |_, node_id, _, _| {\n-                    if moves_map.contains(&node_id) {\n-                        found = true;\n+            for arm.pats.each |&pat| {\n+                for ast_util::walk_pat(pat) |p| {\n+                    if moves_map.contains(&p.id) {\n+                        return Some(p);\n                     }\n                 }\n-                if found { return true; }\n             }\n         }\n-        return false;\n+        return None;\n     }\n \n     fn compute_captures(&self, fn_expr_id: node_id) -> @[CaptureVar] {"}, {"sha": "1237e9fb4a26a690dd23f00a78e2dbce233f2691", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -72,8 +72,8 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                it: &fn(binding_mode, node_id, span, @Path)) {\n-    do walk_pat(pat) |p| {\n+                    it: &fn(binding_mode, node_id, span, @Path)) {\n+    for walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {\n             it(binding_mode, p.id, p.span, pth);"}, {"sha": "979d04e18c3408c957ff14e60992b6b207a1f2ef", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -4151,7 +4151,7 @@ pub impl Resolver {\n                        bindings_list: Option<@mut HashMap<ident,node_id>>,\n                        visitor: ResolveVisitor) {\n         let pat_id = pattern.id;\n-        do walk_pat(pattern) |pattern| {\n+        for walk_pat(pattern) |pattern| {\n             match pattern.node {\n                 pat_ident(binding_mode, path, _)\n                         if !path.global && path.idents.len() == 1 => {"}, {"sha": "8edae63cea92649bee448116095a1b8b708e3e4b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -157,8 +157,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                              None);\n                     fcx.write_error(pat.id);\n                     kind_name = \"[error]\";\n-                    arg_types = (copy subpats).get_or_default(~[]).map(|_|\n-                                                                       ty::mk_err());\n+                    arg_types = (copy *subpats).get_or_default(~[]).map(|_|\n+                                                                        ty::mk_err());\n                 }\n             }\n         }\n@@ -199,8 +199,8 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                     None);\n             fcx.write_error(pat.id);\n             kind_name = \"[error]\";\n-            arg_types = (copy subpats).get_or_default(~[]).map(|_|\n-                                                               ty::mk_err());\n+            arg_types = (copy *subpats).get_or_default(~[]).map(|_|\n+                                                                ty::mk_err());\n         }\n     }\n "}, {"sha": "8694c0e356eb182582af5a46553695fe8c0a7d04", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -801,3 +801,9 @@ impl UserString for ty::TraitRef {\n         }\n     }\n }\n+\n+impl UserString for ty::t {\n+    fn user_string(&self, tcx: ctxt) -> ~str {\n+        ty_to_str(tcx, *self)\n+    }\n+}"}, {"sha": "289aa33f67c37cd4a6dda7a605c814a9abad56c6", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -74,7 +74,7 @@ fn build_mod_index(\n ) -> doc::Index {\n     doc::Index {\n         entries: doc.items.map(|doc| {\n-            item_to_entry(copy *doc, copy config)\n+            item_to_entry(copy *doc, &config)\n         })\n     }\n }\n@@ -85,14 +85,14 @@ fn build_nmod_index(\n ) -> doc::Index {\n     doc::Index {\n         entries: doc.fns.map(|doc| {\n-            item_to_entry(doc::FnTag(copy *doc), copy config)\n+            item_to_entry(doc::FnTag(copy *doc), &config)\n         })\n     }\n }\n \n fn item_to_entry(\n     doc: doc::ItemTag,\n-    config: config::Config\n+    config: &config::Config\n ) -> doc::IndexEntry {\n     let link = match doc {\n       doc::ModTag(_) | doc::NmodTag(_)\n@@ -222,13 +222,13 @@ mod test {\n             config::DocPerCrate,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[0] == doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"#module-a\"\n         });\n-        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[1] == doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -242,13 +242,13 @@ mod test {\n             config::DocPerMod,\n             ~\"mod a { } fn b() { }\"\n         );\n-        assert!((&doc.cratemod().index).get().entries[0] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[0] == doc::IndexEntry {\n             kind: ~\"Module\",\n             name: ~\"a\",\n             brief: None,\n             link: ~\"a.html\"\n         });\n-        assert!((&doc.cratemod().index).get().entries[1] == doc::IndexEntry {\n+        assert!(doc.cratemod().index.get().entries[1] == doc::IndexEntry {\n             kind: ~\"Function\",\n             name: ~\"b\",\n             brief: None,\n@@ -262,7 +262,7 @@ mod test {\n             config::DocPerMod,\n             ~\"#[doc = \\\"test\\\"] mod a { }\"\n         );\n-        assert!((&doc.cratemod().index).get().entries[0].brief\n+        assert!(doc.cratemod().index.get().entries[0].brief\n                 == Some(~\"test\"));\n     }\n \n@@ -272,7 +272,7 @@ mod test {\n             config::DocPerCrate,\n             ~\"extern { fn b(); }\"\n         );\n-        assert!((&doc.cratemod().nmods()[0].index).get().entries[0]\n+        assert!(doc.cratemod().nmods()[0].index.get().entries[0]\n                 == doc::IndexEntry {\n                     kind: ~\"Function\",\n                     name: ~\"b\","}, {"sha": "a3ad8d8d04de3413bad36958debf7d431f163f35", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -181,12 +181,12 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n         }\n         &doc::ImplTag(ref doc) => {\n             assert!(doc.self_ty.is_some());\n-            let bounds = if (&doc.bounds_str).is_some() {\n-                fmt!(\" where %s\", (&doc.bounds_str).get())\n+            let bounds = if doc.bounds_str.is_some() {\n+                fmt!(\" where %s\", *doc.bounds_str.get_ref())\n             } else {\n                 ~\"\"\n             };\n-            let self_ty = (&doc.self_ty).get();\n+            let self_ty = doc.self_ty.get_ref();\n             let mut trait_part = ~\"\";\n             for doc.trait_types.eachi |i, trait_type| {\n                 if i == 0 {\n@@ -196,7 +196,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n                 }\n                 trait_part += *trait_type;\n             }\n-            fmt!(\"%s for %s%s\", trait_part, self_ty, bounds)\n+            fmt!(\"%s for %s%s\", trait_part, *self_ty, bounds)\n         }\n         _ => {\n             doc.name()\n@@ -208,17 +208,17 @@ pub fn header_text(doc: doc::ItemTag) -> ~str {\n     match &doc {\n         &doc::ImplTag(ref ImplDoc) => {\n             let header_kind = header_kind(copy doc);\n-            let bounds = if (&ImplDoc.bounds_str).is_some() {\n-                fmt!(\" where `%s`\", (&ImplDoc.bounds_str).get())\n+            let bounds = if ImplDoc.bounds_str.is_some() {\n+                fmt!(\" where `%s`\", *ImplDoc.bounds_str.get_ref())\n             } else {\n                 ~\"\"\n             };\n             let desc = if ImplDoc.trait_types.is_empty() {\n-                fmt!(\"for `%s`%s\", (&ImplDoc.self_ty).get(), bounds)\n+                fmt!(\"for `%s`%s\", *ImplDoc.self_ty.get_ref(), bounds)\n             } else {\n                 fmt!(\"of `%s` for `%s`%s\",\n                      ImplDoc.trait_types[0],\n-                     (&ImplDoc.self_ty).get(),\n+                     *ImplDoc.self_ty.get_ref(),\n                      bounds)\n             };\n             return fmt!(\"%s %s\", header_kind, desc);\n@@ -295,7 +295,7 @@ fn write_mod_contents(\n ) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n-        write_index(ctxt, (&doc.index).get());\n+        write_index(ctxt, doc.index.get_ref());\n     }\n \n     for doc.items.each |itemTag| {\n@@ -340,7 +340,7 @@ fn item_header_lvl(doc: &doc::ItemTag) -> Hlvl {\n     }\n }\n \n-fn write_index(ctxt: &Ctxt, index: doc::Index) {\n+fn write_index(ctxt: &Ctxt, index: &doc::Index) {\n     if vec::is_empty(index.entries) {\n         return;\n     }\n@@ -353,7 +353,7 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n         let id = copy entry.link;\n         if entry.brief.is_some() {\n             ctxt.w.put_line(fmt!(\"* [%s](%s) - %s\",\n-                                 header, id, (&entry.brief).get()));\n+                                 header, id, *entry.brief.get_ref()));\n         } else {\n             ctxt.w.put_line(fmt!(\"* [%s](%s)\", header, id));\n         }\n@@ -366,7 +366,7 @@ fn write_index(ctxt: &Ctxt, index: doc::Index) {\n fn write_nmod(ctxt: &Ctxt, doc: doc::NmodDoc) {\n     write_common(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n-        write_index(ctxt, (&doc.index).get());\n+        write_index(ctxt, doc.index.get_ref());\n     }\n \n     for doc.fns.each |FnDoc| {\n@@ -450,17 +450,17 @@ fn write_variants(\n \n fn write_variant(ctxt: &Ctxt, doc: doc::VariantDoc) {\n     assert!(doc.sig.is_some());\n-    let sig = (&doc.sig).get();\n+    let sig = doc.sig.get_ref();\n \n     // space out list items so they all end up within paragraph elements\n     ctxt.w.put_line(~\"\");\n \n     match copy doc.desc {\n         Some(desc) => {\n-            ctxt.w.put_line(list_item_indent(fmt!(\"* `%s` - %s\", sig, desc)));\n+            ctxt.w.put_line(list_item_indent(fmt!(\"* `%s` - %s\", *sig, desc)));\n         }\n         None => {\n-            ctxt.w.put_line(fmt!(\"* `%s`\", sig));\n+            ctxt.w.put_line(fmt!(\"* `%s`\", *sig));\n         }\n     }\n }"}, {"sha": "973326b10dce8bfa11a5ae20bce4b5bb04c6f9cd", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -59,20 +59,20 @@ pub fn make_writer_factory(config: config::Config) -> WriterFactory {\n \n fn markdown_writer_factory(config: config::Config) -> WriterFactory {\n     let result: ~fn(page: doc::Page) -> Writer = |page| {\n-        markdown_writer(copy config, page)\n+        markdown_writer(&config, page)\n     };\n     result\n }\n \n fn pandoc_writer_factory(config: config::Config) -> WriterFactory {\n     let result: ~fn(doc::Page) -> Writer = |page| {\n-        pandoc_writer(copy config, page)\n+        pandoc_writer(&config, page)\n     };\n     result\n }\n \n fn markdown_writer(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Writer {\n     let filename = make_local_filename(config, page);\n@@ -82,11 +82,11 @@ fn markdown_writer(\n }\n \n fn pandoc_writer(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Writer {\n     assert!(config.pandoc_cmd.is_some());\n-    let pandoc_cmd = (&config.pandoc_cmd).get();\n+    let pandoc_cmd = copy *config.pandoc_cmd.get_ref();\n     let filename = make_local_filename(config, page);\n \n     let pandoc_args = ~[\n@@ -136,15 +136,15 @@ fn generic_writer(process: ~fn(markdown: ~str)) -> Writer {\n }\n \n pub fn make_local_filename(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Path {\n-    let filename = make_filename(copy config, page);\n+    let filename = make_filename(config, page);\n     config.output_dir.push_rel(&filename)\n }\n \n pub fn make_filename(\n-    config: config::Config,\n+    config: &config::Config,\n     page: doc::Page\n ) -> Path {\n     let filename = {\n@@ -247,7 +247,7 @@ mod test {\n         };\n         let doc = mk_doc(~\"test\", ~\"\");\n         let page = doc::CratePage(doc.CrateDoc());\n-        let filename = make_local_filename(config, page);\n+        let filename = make_local_filename(&config, page);\n         assert_eq!(filename.to_str(), ~\"output/dir/test.md\");\n     }\n \n@@ -261,7 +261,7 @@ mod test {\n         };\n         let doc = mk_doc(~\"\", ~\"\");\n         let page = doc::CratePage(doc.CrateDoc());\n-        let filename = make_local_filename(config, page);\n+        let filename = make_local_filename(&config, page);\n         assert_eq!(filename.to_str(), ~\"output/dir/index.html\");\n     }\n \n@@ -276,7 +276,7 @@ mod test {\n         let doc = mk_doc(~\"\", ~\"mod a { mod b { } }\");\n         let modb = copy doc.cratemod().mods()[0].mods()[0];\n         let page = doc::ItemPage(doc::ModTag(modb));\n-        let filename = make_local_filename(config, page);\n+        let filename = make_local_filename(&config, page);\n         assert_eq!(filename, Path(\"output/dir/a_b.html\"));\n     }\n }"}, {"sha": "ed069b5ed56033bd9c0bc751ad3df7fcfe6a0766", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -113,7 +113,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n         match parse_header(copy *line) {\n           Some(header) => {\n             if current_section.is_some() {\n-                sections += [(&current_section).get()];\n+                sections += [copy *current_section.get_ref()];\n             }\n             current_section = Some(doc::Section {\n                 header: header,"}, {"sha": "716784c51c513db9cec00664094ac254ad28b539", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -434,14 +434,14 @@ mod test {\n     #[test]\n     fn should_add_struct_defs() {\n         let doc = mk_doc(~\"struct S { field: () }\");\n-        assert!((&doc.cratemod().structs()[0].sig).get().contains(\n+        assert!(doc.cratemod().structs()[0].sig.get().contains(\n             \"struct S {\"));\n     }\n \n     #[test]\n     fn should_not_serialize_struct_attrs() {\n         // All we care about are the fields\n         let doc = mk_doc(~\"#[wut] struct S { field: () }\");\n-        assert!(!(&doc.cratemod().structs()[0].sig).get().contains(\"wut\"));\n+        assert!(!doc.cratemod().structs()[0].sig.get().contains(\"wut\"));\n     }\n }"}, {"sha": "ba56d544880683ddfd54abb1bb19eb59089532ba", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -527,36 +527,31 @@ pub fn is_item_impl(item: @ast::item) -> bool {\n     }\n }\n \n-pub fn walk_pat(pat: @pat, it: &fn(@pat)) {\n-    it(pat);\n+pub fn walk_pat(pat: @pat, it: &fn(@pat) -> bool) -> bool {\n+    if !it(pat) {\n+        return false;\n+    }\n+\n     match pat.node {\n         pat_ident(_, _, Some(p)) => walk_pat(p, it),\n         pat_struct(_, ref fields, _) => {\n-            for fields.each |f| {\n-                walk_pat(f.pat, it)\n-            }\n+            fields.each(|f| walk_pat(f.pat, it))\n         }\n         pat_enum(_, Some(ref s)) | pat_tup(ref s) => {\n-            for s.each |p| {\n-                walk_pat(*p, it)\n-            }\n+            s.each(|&p| walk_pat(p, it))\n         }\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n         pat_vec(ref before, ref slice, ref after) => {\n-            for before.each |p| {\n-                walk_pat(*p, it)\n-            }\n-            for slice.each |p| {\n-                walk_pat(*p, it)\n-            }\n-            for after.each |p| {\n-                walk_pat(*p, it)\n-            }\n+            before.each(|&p| walk_pat(p, it)) &&\n+                slice.each(|&p| walk_pat(p, it)) &&\n+                after.each(|&p| walk_pat(p, it))\n         }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n-        pat_enum(_, _) => { }\n+        pat_enum(_, _) => {\n+            true\n+        }\n     }\n }\n "}, {"sha": "c51cf5b9538d9309a45cbcb2583e1dc2854f2071", "filename": "src/test/compile-fail/borrowck-alias-mut-base-ptr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-alias-mut-base-ptr.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,15 @@\n+// Test that attempt to alias `&mut` pointer while pointee is borrowed\n+// yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo(t0: &mut int) {\n+    let p: &int = &*t0; // Freezes `*t0`\n+    let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n+    **q = 22; //~ ERROR cannot assign to an `&mut` in a `&const` pointer\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "7e9c298ba4732582e7b4ed8799e59f5604290055", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,31 @@\n+// Test that attempt to reborrow an `&mut` pointer in an aliasable\n+// location yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo(t0: & &mut int) {\n+    let t1 = t0;\n+    let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&` pointer\n+    **t1 = 22; //~ ERROR cannot assign\n+}\n+\n+fn foo2(t0: &const &mut int) {\n+    // Note: reborrowing from an &const actually yields two errors, since it\n+    // is unsafe in two ways: we can't control the aliasing, and we can't\n+    // control the mutation.\n+    let t1 = t0;\n+    let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&const` pointer\n+    //~^ ERROR unsafe borrow of aliasable, const value\n+    **t1 = 22; //~ ERROR cannot assign\n+}\n+\n+fn foo3(t0: &mut &mut int) {\n+    let t1 = &mut *t0;\n+    let p: &int = &**t0; //~ ERROR cannot borrow\n+    **t1 = 22;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "0efde1df6c22be30d0a18cccad62a9f85ba916f8", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -7,8 +7,7 @@ fn main() {\n     //~^ ERROR cannot move `foo`\n \n     let bar = ~3;\n-    let _g = || {\n+    let _g = || { //~ ERROR capture of moved value\n         let _h: @fn() -> int = || *bar;\n-        //~^ ERROR illegal by-move capture\n     };\n }"}, {"sha": "6a3832d2304cf8d7a1879200b2e85ffdfc3d5ebc", "filename": "src/test/compile-fail/borrowck-move-mut-base-ptr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,15 @@\n+// Test that attempt to move `&mut` pointer while pointee is borrowed\n+// yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo(t0: &mut int) {\n+    let p: &int = &*t0; // Freezes `*t0`\n+    let t1 = t0;        //~ ERROR cannot move out of `t0`\n+    *t1 = 22;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "dec976e0a6068007ca2cfae60cff80420acc5964", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,31 @@\n+// Test that we do not permit moves from &[] matched by a vec pattern.\n+\n+struct Foo {\n+    string: ~str\n+}\n+\n+pub fn main() {\n+    let x = [\n+        Foo { string: ~\"foo\" },\n+        Foo { string: ~\"bar\" },\n+        Foo { string: ~\"baz\" }\n+    ];\n+    match x {\n+        [first, ..tail] => {\n+            match tail {\n+                [Foo { string: a }, Foo { string: b }] => {\n+                    //~^ ERROR cannot move out of dereference of & pointer\n+                    //~^^ ERROR cannot move out of dereference of & pointer\n+                }\n+                _ => {\n+                    ::std::util::unreachable();\n+                }\n+            }\n+            let z = copy tail[0];\n+            debug!(fmt!(\"%?\", z));\n+        }\n+        _ => {\n+            ::std::util::unreachable();\n+        }\n+    }\n+}"}, {"sha": "bea5f1f6ea765c08c880382646bda9964a43d31c", "filename": "src/test/compile-fail/borrowck-swap-mut-base-ptr.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,16 @@\n+// Test that attempt to swap `&mut` pointer while pointee is borrowed\n+// yields an error.\n+//\n+// Example from src/middle/borrowck/doc.rs\n+\n+use std::util::swap;\n+\n+fn foo<'a>(mut t0: &'a mut int,\n+           mut t1: &'a mut int) {\n+    let p: &int = &*t0;     // Freezes `*t0`\n+    swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+    *t1 = 22;\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "a67a12f9d0f7337bd7b00f366d36e85eb55d5d15", "filename": "src/test/compile-fail/borrowck-unary-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unary-move.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -10,7 +10,7 @@\n \n fn foo(x: ~int) -> int {\n     let y = &*x;\n-    free(x); //~ ERROR cannot move out of `*x` because it is borrowed\n+    free(x); //~ ERROR cannot move out of `x` because it is borrowed\n     *y\n }\n "}, {"sha": "dc42e28ec2523d5708f67bf8f965c6902d741825", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let s = S { x: Bar(~\"hello\") };\n     match &s.x {\n         &Foo => {}\n-        &Bar(identifier) => f(copy identifier)  //~ ERROR by-move pattern bindings may not occur\n+        &Bar(identifier) => f(copy identifier)  //~ ERROR cannot move\n     };\n     match &s.x {\n         &Foo => {}"}, {"sha": "478a56c03010aa4a909aa70bf442648886e5033f", "filename": "src/test/compile-fail/disallowed-deconstructing-destructing-struct-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdisallowed-deconstructing-destructing-struct-match.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -23,6 +23,6 @@ fn main() {\n \n     match x {\n         X { x: y } => error!(\"contents: %s\", y)\n-        //~^ ERROR cannot bind by-move within struct\n+        //~^ ERROR cannot move out of type `X`, which defines the `Drop` trait\n     }\n }"}, {"sha": "92f2e5ea689c182d6f9e13871ae0b8770f6cea2c", "filename": "src/test/compile-fail/issue-2590.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2590.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -18,7 +18,7 @@ trait parse {\n \n impl parse for parser {\n     fn parse(&self) -> ~[int] {\n-        self.tokens //~ ERROR cannot move out of field\n+        self.tokens //~ ERROR cannot move out of dereference of & pointer\n     }\n }\n "}, {"sha": "6fe59f0ca52d1776917e635631855bf0b1aa66bd", "filename": "src/test/compile-fail/liveness-move-in-loop.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-loop.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -16,10 +16,7 @@ fn main() {\n         loop {\n             loop {\n                 loop {\n-// tjc: Not sure why it prints the same error twice\n                     x = y; //~ ERROR use of moved value\n-                    //~^ ERROR use of moved value\n-\n                     copy x;\n                 }\n             }"}, {"sha": "26e82dd3673431349b9de60ecf86ba1600740dfb", "filename": "src/test/compile-fail/liveness-move-in-while.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-move-in-while.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -13,10 +13,8 @@ fn main() {\n     let y: ~int = ~42;\n     let mut x: ~int;\n     loop {\n-        debug!(y);\n-// tjc: not sure why it prints the same error twice\n+        debug!(y); //~ ERROR use of moved value: `y`\n         while true { while true { while true { x = y; copy x; } } }\n         //~^ ERROR use of moved value: `y`\n-        //~^^ ERROR use of moved value: `y`\n     }\n }"}, {"sha": "1a2beedff9306e9684f7b2142a714f8641e5553a", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -7,13 +7,13 @@ fn touch<A>(_a: &A) {}\n \n fn f10() {\n     let x = Foo { f: ~\"hi\", y: 3 };\n-    consume(x.f); //~ NOTE field of `x` moved here\n+    consume(x.f); //~ NOTE `x.f` moved here\n     touch(&x.y); //~ ERROR use of partially moved value: `x`\n }\n \n fn f20() {\n     let x = ~[~\"hi\"];\n-    consume(x[0]); //~ NOTE element of `x` moved here\n+    consume(x[0]); //~ NOTE `(*x)[]` moved here\n     touch(&x[0]); //~ ERROR use of partially moved value: `x`\n }\n "}, {"sha": "ca58097b555e1d5a777939af64a1904d5774a2f1", "filename": "src/test/compile-fail/moves-based-on-type-block-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-block-bad.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -16,9 +16,9 @@ fn main() {\n     let s = S { x: ~Bar(~42) };\n     loop {\n         do f(&s) |hellothere| {\n-            match hellothere.x {    //~ ERROR cannot move out\n+            match hellothere.x {\n                 ~Foo(_) => {}\n-                ~Bar(x) => io::println(x.to_str()),\n+                ~Bar(x) => io::println(x.to_str()), //~ ERROR cannot move out\n                 ~Baz => {}\n             }\n         }"}, {"sha": "40ee37fae78a82d434be6c582805ccdc1bfc6a75", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -86,7 +86,7 @@ fn f110() {\n }\n \n fn f120() {\n-    let x = ~[~\"hi\", ~\"ho\"];\n+    let mut x = ~[~\"hi\", ~\"ho\"];\n     vec::swap(x, 0, 1);\n     touch(&x[0]);\n     touch(&x[1]);"}, {"sha": "42944a206b360bb5d4bc2d6265dd7e766ec8fc2d", "filename": "src/test/compile-fail/moves-based-on-type-match-bindings.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-match-bindings.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,19 @@\n+// Tests that bindings to move-by-default values trigger moves of the\n+// discriminant. Also tests that the compiler explains the move in\n+// terms of the binding, not the discriminant.\n+\n+struct Foo<A> { f: A }\n+fn guard(_s: ~str) -> bool {fail!()}\n+fn touch<A>(_a: &A) {}\n+\n+fn f10() {\n+    let x = Foo {f: ~\"hi\"};\n+\n+    let y = match x {\n+        Foo {f} => {} //~ NOTE moved here\n+    };\n+\n+    touch(&x); //~ ERROR use of partially moved value: `x`\n+}\n+\n+fn main() {}"}, {"sha": "c9e5144557acceead68bd17148f5b5f338445ec7", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -15,12 +15,12 @@ fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = arc::ARC(v);\n \n-    do task::spawn() { //~ NOTE `arc_v` moved into closure environment here\n+    do task::spawn() {\n         let v = arc_v.get();\n         assert_eq!(v[3], 4);\n     };\n \n     assert_eq!((arc_v.get())[2], 3); //~ ERROR use of moved value: `arc_v`\n \n-    info!(arc_v);\n+    info!(arc_v); //~ ERROR use of moved value: `arc_v`\n }"}, {"sha": "da8e0c9f2b697cad84ce5fa58e2b6d5e9167649f", "filename": "src/test/compile-fail/use-after-move-self-based-on-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self-based-on-type.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -9,7 +9,7 @@ impl Drop for S {\n pub impl S {\n     fn foo(self) -> int {\n         self.bar();\n-        return self.x;  //~ ERROR use of partially moved value\n+        return self.x;  //~ ERROR use of moved value: `self`\n     }\n \n     fn bar(self) {}"}, {"sha": "37db40d14365eca8bfb4f9b1cc5fd301cdfae1b0", "filename": "src/test/compile-fail/use-after-move-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-move-self.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -5,7 +5,7 @@ struct S {\n pub impl S {\n     fn foo(self) -> int {\n         self.bar();\n-        return *self.x;  //~ ERROR use of partially moved value\n+        return *self.x;  //~ ERROR use of moved value: `self`\n     }\n \n     fn bar(self) {}"}, {"sha": "c74fd4a68e719807a438726931ea2ecdc1f7a103", "filename": "src/test/run-pass/borrowck-unary-move-2.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-unary-move-2.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -28,5 +28,5 @@ struct wrapper(noncopyable);\n \n fn main() {\n     let x1 = wrapper(noncopyable());\n-    let _x2 = *x1; //~ ERROR cannot move out\n+    let _x2 = *x1;\n }", "previous_filename": "src/test/compile-fail/borrowck-unary-move-2.rs"}, {"sha": "b6485348a51848cecef8be85450ef62d70645aeb", "filename": "src/test/run-pass/move-out-of-field.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -0,0 +1,23 @@\n+use std::str;\n+\n+struct StringBuffer {\n+    s: ~str\n+}\n+\n+impl StringBuffer {\n+    pub fn append(&mut self, v: &str) {\n+        str::push_str(&mut self.s, v);\n+    }\n+}\n+\n+fn to_str(sb: StringBuffer) -> ~str {\n+    sb.s\n+}\n+\n+fn main() {\n+    let mut sb = StringBuffer {s: ~\"\"};\n+    sb.append(\"Hello, \");\n+    sb.append(\"World!\");\n+    let str = to_str(sb);\n+    assert_eq!(str, ~\"Hello, World!\");\n+}\n\\ No newline at end of file"}, {"sha": "05a6dee06cc87bf582a53ae900de8c4e5ac03723", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -4,8 +4,8 @@ fn foldl<T, U: Copy+Clone>(\n     function: &fn(partial: U, element: &T) -> U\n ) -> U {\n     match values {\n-        [head, ..tail] =>\n-            foldl(tail, function(initial, &head), function),\n+        [ref head, ..tail] =>\n+            foldl(tail, function(initial, head), function),\n         [] => initial.clone()\n     }\n }\n@@ -16,8 +16,8 @@ fn foldr<T, U: Copy+Clone>(\n     function: &fn(element: &T, partial: U) -> U\n ) -> U {\n     match values {\n-        [..head, tail] =>\n-            foldr(head, function(&tail, initial), function),\n+        [..head, ref tail] =>\n+            foldr(head, function(tail, initial), function),\n         [] => initial.clone()\n     }\n }"}, {"sha": "6e1a47ad2dfd38c21f9b734ced837235f08daa8b", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d80642b5196497e3b90bdc3ed47c60aedece2c57/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=d80642b5196497e3b90bdc3ed47c60aedece2c57", "patch": "@@ -19,9 +19,9 @@ pub fn main() {\n                 [Foo { _ }, _, Foo { _ }, ..tail] => {\n                     ::std::util::unreachable();\n                 }\n-                [Foo { string: a }, Foo { string: b }] => {\n-                    assert_eq!(a, ~\"bar\");\n-                    assert_eq!(b, ~\"baz\");\n+                [Foo { string: ref a }, Foo { string: ref b }] => {\n+                    assert_eq!(\"bar\", a.slice(0, a.len()));\n+                    assert_eq!(\"baz\", b.slice(0, b.len()));\n                 }\n                 _ => {\n                     ::std::util::unreachable();"}]}