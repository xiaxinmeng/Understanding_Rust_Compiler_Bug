{"sha": "b621820dc4727677f14bee0ac5e2fa5e424ed22e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MjE4MjBkYzQ3Mjc2NzdmMTRiZWUwYWM1ZTJmYTVlNDI0ZWQyMmU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-30T19:02:56Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-20T18:49:20Z"}, "message": "detect unused attrs in one more place, allow parsing to continue for all\n\nchanged a bunch of fatal()'s into err()'s, to allow parsing to proceed.", "tree": {"sha": "c8fe97d98445582ec8d5b5a26670af77a30e0f52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8fe97d98445582ec8d5b5a26670af77a30e0f52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b621820dc4727677f14bee0ac5e2fa5e424ed22e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b621820dc4727677f14bee0ac5e2fa5e424ed22e", "html_url": "https://github.com/rust-lang/rust/commit/b621820dc4727677f14bee0ac5e2fa5e424ed22e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b621820dc4727677f14bee0ac5e2fa5e424ed22e/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05ab83eea80413ef4d7714cae93a30f24e2fff5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/05ab83eea80413ef4d7714cae93a30f24e2fff5c", "html_url": "https://github.com/rust-lang/rust/commit/05ab83eea80413ef4d7714cae93a30f24e2fff5c"}], "stats": {"total": 85, "additions": 57, "deletions": 28}, "files": [{"sha": "7aff9f6745cbfcfc951c2b0b4f61269f21da35a1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b621820dc4727677f14bee0ac5e2fa5e424ed22e", "patch": "@@ -612,4 +612,20 @@ mod test {\n         string_to_expr(@~\"3 + 4\");\n         string_to_expr(@~\"a::z.froob(b,@(987+3))\");\n     }\n+\n+    #[test] fn attrs_fix_bug () {\n+        string_to_item(@~\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+                   -> Result<@Writer, ~str> {\n+    #[cfg(windows)]\n+    fn wb() -> c_int {\n+      (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n+    }\n+\n+    #[cfg(unix)]\n+    fn wb() -> c_int { O_WRONLY as c_int }\n+\n+    let mut fflags: c_int = wb();\n+}\");\n+    }\n+\n }"}, {"sha": "fddeea9302414fa5b1a00822b855c5781b051fcf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b621820dc4727677f14bee0ac5e2fa5e424ed22e", "patch": "@@ -2588,20 +2588,22 @@ pub impl Parser {\n         })\n     }\n \n-    // parse a statement. may include decl\n-    fn parse_stmt(&self, first_item_attrs: ~[attribute]) -> @stmt {\n+    // parse a statement. may include decl.\n+    // precondition: any attributes are parsed already\n+    fn parse_stmt(&self, item_attrs: ~[attribute]) -> @stmt {\n         maybe_whole!(self, nt_stmt);\n \n         fn check_expected_item(p: &Parser, current_attrs: &[attribute]) {\n             // If we have attributes then we should have an item\n             if !current_attrs.is_empty() {\n-                p.fatal(~\"expected item after attrs\");\n+                p.span_err(*p.last_span,\n+                           ~\"expected item after attributes\");\n             }\n         }\n \n         let lo = self.span.lo;\n         if self.is_keyword(\"let\") {\n-            check_expected_item(self, first_item_attrs);\n+            check_expected_item(self, item_attrs);\n             self.expect_keyword(\"let\");\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n@@ -2614,7 +2616,7 @@ pub impl Parser {\n             // to the macro clause of parse_item_or_view_item. This\n             // could use some cleanup, it appears to me.\n \n-            check_expected_item(self, first_item_attrs);\n+            check_expected_item(self, item_attrs);\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -2650,9 +2652,6 @@ pub impl Parser {\n             }\n \n         } else {\n-            let item_attrs = vec::append(first_item_attrs,\n-                                         self.parse_outer_attributes());\n-\n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n                                                            false) {\n                 iovi_item(i) => {\n@@ -2727,6 +2726,7 @@ pub impl Parser {\n         let mut stmts = ~[];\n         let mut expr = None;\n \n+        // wouldn't it be more uniform to parse view items only, here?\n         let ParsedItemsAndViewItems {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n@@ -2741,23 +2741,29 @@ pub impl Parser {\n                                 stmt_decl(decl, self.get_id())));\n         }\n \n-        let mut initial_attrs = attrs_remaining;\n-\n-        if *self.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n-            self.fatal(~\"expected item\");\n-        }\n+        let mut attributes_box = attrs_remaining;\n \n-        while *self.token != token::RBRACE {\n+        while (*self.token != token::RBRACE) {\n+            // parsing items even when they're not allowed lets us give\n+            // better error messages and recover more gracefully.\n+            attributes_box.push_all(self.parse_outer_attributes());\n             match *self.token {\n                 token::SEMI => {\n+                    if !vec::is_empty(attributes_box) {\n+                        self.span_err(*self.last_span,~\"expected item after attributes\");\n+                        attributes_box = ~[];\n+                    }\n                     self.bump(); // empty\n                 }\n+                token::RBRACE => {\n+                    // fall through and out.\n+                }\n                 _ => {\n-                    let stmt = self.parse_stmt(initial_attrs);\n-                    initial_attrs = ~[];\n+                    let stmt = self.parse_stmt(attributes_box);\n+                    attributes_box = ~[];\n                     match stmt.node {\n                         stmt_expr(e, stmt_id) => {\n-                            // Expression without semicolon\n+                            // expression without semicolon\n                             match *self.token {\n                                 token::SEMI => {\n                                     self.bump();\n@@ -2773,7 +2779,7 @@ pub impl Parser {\n                                         self.fatal(\n                                             fmt!(\n                                                 \"expected `;` or `}` after \\\n-                                                expression but found `%s`\",\n+                                                 expression but found `%s`\",\n                                                 self.token_to_str(&t)\n                                             )\n                                         );\n@@ -2782,9 +2788,8 @@ pub impl Parser {\n                                 }\n                             }\n                         }\n-\n                         stmt_mac(ref m, _) => {\n-                            // Statement macro; might be an expr\n+                            // statement macro; might be an expr\n                             match *self.token {\n                                 token::SEMI => {\n                                     self.bump();\n@@ -2803,8 +2808,7 @@ pub impl Parser {\n                                 _ => { stmts.push(stmt); }\n                             }\n                         }\n-\n-                        _ => { // All other kinds of statements:\n+                        _ => { // all other kinds of statements:\n                             stmts.push(stmt);\n \n                             if classify::stmt_ends_with_semi(stmt) {\n@@ -2815,6 +2819,11 @@ pub impl Parser {\n                 }\n             }\n         }\n+\n+        if !vec::is_empty(attributes_box) {\n+            self.span_err(*self.last_span,~\"expected item after attributes\");\n+        }\n+\n         let hi = self.span.hi;\n         self.bump();\n         let bloc = ast::blk_ {\n@@ -3519,7 +3528,7 @@ pub impl Parser {\n \n         if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n-            self.fatal(~\"expected item\");\n+            self.span_err(*self.last_span,~\"expected item after attributes\");\n         }\n \n         ast::_mod { view_items: view_items, items: items }\n@@ -3724,11 +3733,15 @@ pub impl Parser {\n                                first_item_attrs: ~[attribute])\n                                -> foreign_mod {\n         let ParsedItemsAndViewItems {\n-            attrs_remaining: _,\n+            attrs_remaining: attrs_remaining,\n             view_items: view_items,\n             items: _,\n             foreign_items: foreign_items\n         } = self.parse_foreign_items(first_item_attrs, true);\n+        if (! attrs_remaining.is_empty()) {\n+            self.span_err(*self.last_span,\n+                          ~\"expected item after attributes\");\n+        }\n         assert!(*self.token == token::RBRACE);\n         ast::foreign_mod {\n             sort: sort,"}, {"sha": "cf0f4a6240e2b9f6ec15efbcf07649a4f942dda8", "filename": "src/test/compile-fail/attr-before-ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs?ref=b621820dc4727677f14bee0ac5e2fa5e424ed22e", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    #[attr]\n-    debug!(\"hi\"); //~ ERROR expected item after attrs\n+    #[attr] //~ ERROR expected item after attributes\n+    debug!(\"hi\");\n }"}, {"sha": "acc9aa8a9a13eee54b5715dd87b915601171bfb0", "filename": "src/test/compile-fail/attr-before-let.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b621820dc4727677f14bee0ac5e2fa5e424ed22e/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-let.rs?ref=b621820dc4727677f14bee0ac5e2fa5e424ed22e", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    #[attr]\n-    let _i = 0; //~ ERROR expected item\n+    #[attr] //~ ERROR expected item\n+    let _i = 0;\n }"}]}