{"sha": "550b34b7828622d6eb23e6bfbcc026c8b57e19fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MGIzNGI3ODI4NjIyZDZlYjIzZTZiZmJjYzAyNmM4YjU3ZTE5ZmE=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-01T04:59:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:15Z"}, "message": "std: impl for net::tcp::connect", "tree": {"sha": "7d6375b51515d280a2da6c2b951073e94a118bfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d6375b51515d280a2da6c2b951073e94a118bfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/550b34b7828622d6eb23e6bfbcc026c8b57e19fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/550b34b7828622d6eb23e6bfbcc026c8b57e19fa", "html_url": "https://github.com/rust-lang/rust/commit/550b34b7828622d6eb23e6bfbcc026c8b57e19fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/550b34b7828622d6eb23e6bfbcc026c8b57e19fa/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc846ce7e3a1333411ceeb9092032e6047c0b61e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc846ce7e3a1333411ceeb9092032e6047c0b61e", "html_url": "https://github.com/rust-lang/rust/commit/bc846ce7e3a1333411ceeb9092032e6047c0b61e"}], "stats": {"total": 215, "additions": 204, "deletions": 11}, "files": [{"sha": "3707851bedde25e78b3717d7494404dc9197e44a", "filename": "src/libstd/net.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/550b34b7828622d6eb23e6bfbcc026c8b57e19fa/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550b34b7828622d6eb23e6bfbcc026c8b57e19fa/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=550b34b7828622d6eb23e6bfbcc026c8b57e19fa", "patch": "@@ -2,6 +2,8 @@\n Top-level module for network-related functionality\n \"];\n \n+import tcp = net_tcp;\n+export tcp;\n \n import ip = net_ip;\n export ip; "}, {"sha": "af70938792922688b3aa8fa5f1cacbc8a9fde101", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 202, "deletions": 11, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/550b34b7828622d6eb23e6bfbcc026c8b57e19fa/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/550b34b7828622d6eb23e6bfbcc026c8b57e19fa/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=550b34b7828622d6eb23e6bfbcc026c8b57e19fa", "patch": "@@ -2,26 +2,212 @@\n High-level interface to libuv's TCP functionality\n \"];\n \n-#[cfg(ignore)]\n+import ip = net_ip;\n+\n+export tcp_connect_result;\n+export connect;\n+\n+enum tcp_socket {\n+    valid_tcp_socket(@tcp_socket_data)\n+}\n+\n+enum tcp_connect_result {\n+    tcp_connected(tcp_socket),\n+    tcp_connect_error(uv::ll::uv_err_data)\n+}\n+\n+#[doc=\"\n+Initiate a client connection over TCP/IP\n+\n+# Arguments\n+\n+* ip - The IP address (versions 4 or 6) of the remote host\n+* port - the unsigned integer of the desired remote host port\n+\n+# Returns\n+\n+A `tcp_connect_result` that can be used to determine the connection and,\n+if successful, send and receive data to/from the remote host\n+\"]\n+fn connect(input_ip: ip::ip_addr, port: uint) -> tcp_connect_result unsafe {\n+    let result_po = comm::port::<conn_attempt>();\n+    let closed_signal_po = comm::port::<()>();\n+    let conn_data = {\n+        result_ch: comm::chan(result_po),\n+        closed_signal_ch: comm::chan(closed_signal_po)\n+    };\n+    let conn_data_ptr = ptr::addr_of(conn_data);\n+    let socket_data = @{\n+        reader_port: comm::port::<[u8]>(),\n+        stream_handle : uv::ll::tcp_t(),\n+        connect_req : uv::ll::connect_t(),\n+        write_req : uv::ll::write_t()\n+    };\n+    log(debug, #fmt(\"tcp_connect result_ch %?\", conn_data.result_ch));\n+    // get an unsafe representation of our stream_handle_ptr that\n+    // we can send into the interact cb to be handled in libuv..\n+    let socket_data_ptr: *tcp_socket_data =\n+        ptr::addr_of(*socket_data);\n+    // in we go!\n+    let hl_loop = uv::global_loop::get();\n+    log(debug, #fmt(\"stream_handl_ptr outside interact %?\",\n+        ptr::addr_of((*socket_data_ptr).stream_handle)));\n+    uv::hl::interact(hl_loop) {|loop_ptr|\n+        log(debug, \"in interact cb for tcp client connect..\");\n+        let stream_handle_ptr =\n+            ptr::addr_of((*socket_data_ptr).stream_handle);\n+        log(debug, #fmt(\"stream_handl_ptr in interact %?\",\n+            stream_handle_ptr));\n+        alt uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n+          0i32 {\n+            log(debug, \"tcp_init successful\");\n+            alt input_ip {\n+              ipv4 {\n+                log(debug, \"dealing w/ ipv4 connection..\");\n+                let tcp_addr = ipv4_ip_addr_to_sockaddr_in(input_ip,\n+                                                           port);\n+                let tcp_addr_ptr = ptr::addr_of(tcp_addr);\n+                let connect_req_ptr =\n+                    ptr::addr_of((*socket_data_ptr).connect_req);\n+                alt uv::ll::tcp_connect(\n+                    connect_req_ptr,\n+                    stream_handle_ptr,\n+                    tcp_addr_ptr,\n+                    tcp_connect_on_connect_cb) {\n+                  0i32 {\n+                    log(debug, \"tcp_connect successful\");\n+                    // reusable data that we'll have for the\n+                    // duration..\n+                    uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                               socket_data_ptr);\n+                    // just so the connect_cb can send the\n+                    // outcome..\n+                    uv::ll::set_data_for_req(connect_req_ptr,\n+                                             conn_data_ptr);\n+                    log(debug, \"leaving tcp_connect interact cb...\");\n+                    // let tcp_connect_on_connect_cb send on\n+                    // the result_ch, now..\n+                  }\n+                  _ {\n+                    // immediate connect failure.. probably a garbage\n+                    // ip or somesuch\n+                    let err_data = uv::ll::get_last_err_data(loop_ptr);\n+                    comm::send((*conn_data_ptr).result_ch,\n+                               conn_failure(err_data));\n+                    uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                                   conn_data_ptr);\n+                    uv::ll::close(stream_handle_ptr, stream_error_close_cb);\n+                  }\n+                }\n+              }\n+            }\n+        }\n+          _ {\n+            // failure to create a tcp handle\n+            let err_data = uv::ll::get_last_err_data(loop_ptr);\n+            comm::send((*conn_data_ptr).result_ch,\n+                       conn_failure(err_data));\n+          }\n+        }\n+    };\n+    alt comm::recv(result_po) {\n+      conn_success {\n+        log(debug, \"tcp::connect - received success on result_po\");\n+        tcp_connected(valid_tcp_socket(socket_data))\n+      }\n+      conn_failure(err_data) {\n+        comm::recv(closed_signal_po);\n+        log(debug, \"tcp::connect - received failure on result_po\");\n+        tcp_connect_error(err_data)\n+      }\n+    }\n+}\n+// INTERNAL API\n+type connect_req_data = {\n+    result_ch: comm::chan<conn_attempt>,\n+    closed_signal_ch: comm::chan<()>\n+};\n+\n+crust fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n+    let data = uv::ll::get_data_for_uv_handle(handle) as\n+        *connect_req_data;\n+    comm::send((*data).closed_signal_ch, ());\n+    log(debug, #fmt(\"exiting steam_error_close_cb for %?\", handle));\n+}\n+\n+crust fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n+    log(debug, #fmt(\"closed client tcp handle %?\", handle));\n+}\n+\n+crust fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n+                                   status: libc::c_int) unsafe {\n+    let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n+                      as *connect_req_data);\n+    let result_ch = (*conn_data_ptr).result_ch;\n+    log(debug, #fmt(\"tcp_connect result_ch %?\", result_ch));\n+    let tcp_stream_ptr =\n+        uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n+    alt status {\n+      0i32 {\n+        log(debug, \"successful tcp connection!\");\n+        comm::send(result_ch, conn_success);\n+      }\n+      _ {\n+        log(debug, \"error in tcp_connect_on_connect_cb\");\n+        let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n+        let err_data = uv::ll::get_last_err_data(loop_ptr);\n+        log(debug, #fmt(\"err_data %? %?\", err_data.err_name,\n+                        err_data.err_msg));\n+        comm::send(result_ch, conn_failure(err_data));\n+        uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n+                                       conn_data_ptr);\n+        uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n+      }\n+    }\n+    log(debug, \"leaving tcp_connect_on_connect_cb\");\n+}\n+\n+enum conn_attempt {\n+    conn_success,\n+    conn_failure(uv::ll::uv_err_data)\n+}\n+\n+\n+type tcp_socket_data = {\n+    reader_port: comm::port<[u8]>,\n+    stream_handle: uv::ll::uv_tcp_t,\n+    connect_req: uv::ll::uv_connect_t,\n+    write_req: uv::ll::uv_write_t\n+};\n+\n+// convert rust ip_addr to libuv's native representation\n+fn ipv4_ip_addr_to_sockaddr_in(input: ip::ip_addr,\n+                               port: uint) -> uv::ll::sockaddr_in unsafe {\n+    uv::ll::ip4_addr(ip::format_addr(input), port as int)\n+}\n+\n+#[cfg(test)]\n mod test {\n     #[test]\n     fn test_gl_tcp_ipv4_request() {\n-        let ip = \"127.0.0.1\";\n+        let ip_str = \"127.0.0.1\";\n         let port = 80u;\n         let expected_read_msg = \"foo\";\n         let actual_write_msg = \"bar\";\n-        let addr = ipv4::address(ip, port);\n+        let host_ip = ip::v4::parse_addr(ip_str);\n \n         let data_po = comm::port::<[u8]>();\n         let data_ch = comm::chan(data_po);\n         \n-        alt connect(addr) {\n-          tcp_connected(tcp_stream) {\n+        alt connect(host_ip, port) {\n+          tcp_connected(sock) {\n+            log(debug, \"successful tcp connect\");\n+            /*\n             let write_data = str::as_buf(actual_write_msg);\n-            alt write(tcp_stream, [write_data]) {\n+            alt write(sock, [write_data]) {\n               tcp_write_success {\n-                let mut total_read_data: [u8] = []\n-                let reader_po = read_start(tcp_stream);\n+                let mut total_read_data: [u8] = [];\n+                let reader_po = read_start(sock);nyw\n                 loop {\n                     alt comm::recv(reader_po) {\n                       new_read_data(data) {\n@@ -36,7 +222,8 @@ mod test {\n                         break;\n                       }\n                       error {\n-                        fail \"erroring occured during read attempt.. FIXME need info\";\n+                        fail \"erroring occured during read attempt..\"\n+                            + \"FIXME need info\";\n                       }\n                     }\n                 }\n@@ -46,9 +233,13 @@ mod test {\n                 fail \"error during write attempt.. FIXME need err info\";\n               }\n             }\n+            */\n           }\n-          tcp_connect_error {\n-            fail \"error during connection attempt.. FIXME need err info..\";\n+          tcp_connect_error(err_data) {\n+            log(debug, \"tcp_connect_error received..\");\n+            log(debug, #fmt(\"tcp connect error: %? %?\", err_data.err_name,\n+                           err_data.err_msg));\n+            assert false;\n           }\n         }\n "}]}