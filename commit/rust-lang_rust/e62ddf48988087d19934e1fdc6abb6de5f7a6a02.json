{"sha": "e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MmRkZjQ4OTg4MDg3ZDE5OTM0ZTFmZGM2YWJiNmRlNWY3YTZhMDI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-15T12:57:29Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-16T15:37:33Z"}, "message": "More rigorous reuse of cleanup sequences\n\nIn both landing pads and break/cont/ret unwinding.\n\nCloses #300", "tree": {"sha": "3826341c37e2e0f0846d87e974a6207850229b01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3826341c37e2e0f0846d87e974a6207850229b01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "html_url": "https://github.com/rust-lang/rust/commit/e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea6bb5aafa1827718b143a3657a212cf28e2e08e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6bb5aafa1827718b143a3657a212cf28e2e08e", "html_url": "https://github.com/rust-lang/rust/commit/ea6bb5aafa1827718b143a3657a212cf28e2e08e"}], "stats": {"total": 325, "additions": 171, "deletions": 154}, "files": [{"sha": "158db8607941dda47e4f6953a241dc79ae4272c0", "filename": "src/comp/middle/trans/alt.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Falt.rs?ref=e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "patch": "@@ -691,14 +691,16 @@ fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms_: [ast::arm],\n                                                   a.pats[0])) {\n             let arm_dest = base::dup_for_join(dest);\n             arm_dests += [arm_dest];\n-            arm_cxs += [base::trans_block_dps(body_cx, a.body, arm_dest)];\n+            let arm_cx = base::trans_block(body_cx, a.body, arm_dest);\n+            arm_cx = base::trans_block_cleanups(arm_cx, body_cx);\n+            arm_cxs += [arm_cx];\n         }\n         i += 1u;\n     }\n-    let after_cx = base::join_returns(cx, arm_cxs, arm_dests, dest);\n-    after_cx = base::trans_block_cleanups(after_cx, alt_cx);\n-    let next_cx = new_sub_block_ctxt(after_cx, \"next\");\n-    Br(after_cx, next_cx.llbb);\n+    let after_cx = base::join_returns(alt_cx, arm_cxs, arm_dests, dest);\n+    let next_cx = new_sub_block_ctxt(cx, \"next\");\n+    if after_cx.unreachable { Unreachable(next_cx); }\n+    base::cleanup_and_Br(after_cx, alt_cx, next_cx.llbb);\n     ret next_cx;\n }\n "}, {"sha": "b562c726df4b33c074e42e730b69788e00056c92", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 137, "deletions": 134, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "patch": "@@ -2076,29 +2076,30 @@ fn trans_if(cx: @block_ctxt, cond: @ast::expr, thn: ast::blk,\n         _ { ast_util::dummy_sp() }\n     });\n     CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n-    then_cx = trans_block_dps(then_cx, thn, then_dest);\n+    let then_bcx = trans_block(then_cx, thn, then_dest);\n+    then_bcx = trans_block_cleanups(then_bcx, then_cx);\n     // Calling trans_block directly instead of trans_expr\n     // because trans_expr will create another scope block\n     // context for the block, but we've already got the\n     // 'else' context\n-    alt els {\n+    let else_bcx = alt els {\n       some(elexpr) {\n         alt elexpr.node {\n           ast::expr_if(_, _, _) {\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n-            else_cx = trans_block_dps(else_cx, elseif_blk, else_dest);\n+            trans_block(else_cx, elseif_blk, else_dest)\n           }\n           ast::expr_block(blk) {\n-            else_cx = trans_block_dps(else_cx, blk, else_dest);\n+            trans_block(else_cx, blk, else_dest)\n           }\n           // would be nice to have a constraint on ifs\n-          _ { bcx_tcx(cx).sess.bug(\"Strange alternative\\\n-                in if\"); }\n+          _ { bcx_tcx(cx).sess.bug(\"Strange alternative in if\"); }\n         }\n       }\n-      _ {}\n-    }\n-    ret join_returns(cx, [then_cx, else_cx], [then_dest, else_dest], dest);\n+      _ { else_cx }\n+    };\n+    else_bcx = trans_block_cleanups(else_bcx, else_cx);\n+    ret join_returns(cx, [then_bcx, else_bcx], [then_dest, else_dest], dest);\n }\n \n fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n@@ -2115,8 +2116,8 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n                                T_ptr(type_of_or_i8(bcx_ccx(bcx), t)));\n         let bcx = alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n                                                   curr, false);\n-        bcx = trans_block_dps(bcx, body, ignore);\n-        Br(bcx, next_cx.llbb);\n+        bcx = trans_block(bcx, body, ignore);\n+        cleanup_and_Br(bcx, scope_cx, next_cx.llbb);\n         ret next_cx;\n     }\n     let ccx = bcx_ccx(cx);\n@@ -2137,16 +2138,15 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n fn trans_while(cx: @block_ctxt, cond: @ast::expr, body: ast::blk)\n     -> @block_ctxt {\n     let next_cx = new_sub_block_ctxt(cx, \"while next\");\n-    let cond_cx =\n-        new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n-                                  \"while cond\", body.span);\n+    let cond_cx = new_loop_scope_block_ctxt(cx, none, next_cx,\n+                                            \"while cond\", body.span);\n     let body_cx = new_scope_block_ctxt(cond_cx, \"while loop body\");\n-    let body_end = trans_block(body_cx, body);\n+    Br(cx, cond_cx.llbb);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n-    Br(body_end, cond_cx.llbb);\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n     CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n-    Br(cx, cond_cx.llbb);\n+    let body_end = trans_block(body_cx, body, ignore);\n+    cleanup_and_Br(body_end, body_cx, cond_cx.llbb);\n     ret next_cx;\n }\n \n@@ -2156,9 +2156,9 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n     let body_cx =\n         new_loop_scope_block_ctxt(cx, option::none::<@block_ctxt>, next_cx,\n                                   \"do-while loop body\", body.span);\n-    let body_end = trans_block(body_cx, body);\n+    let body_end = trans_block(body_cx, body, ignore);\n     let cond_cx = new_scope_block_ctxt(body_cx, \"do-while cond\");\n-    Br(body_end, cond_cx.llbb);\n+    cleanup_and_Br(body_end, body_cx, cond_cx.llbb);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n     let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n     CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n@@ -2965,12 +2965,11 @@ fn trans_call_inner(in_cx: @block_ctxt, fn_expr_ty: ty::t,\n       }\n     }\n \n-    bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n     if bcx.unreachable || ty::type_is_bot(ret_ty) {\n         Unreachable(next_cx);\n     }\n-    Br(bcx, next_cx.llbb);\n+    cleanup_and_Br(bcx, cx, next_cx.llbb);\n     ret next_cx;\n }\n \n@@ -2996,36 +2995,27 @@ fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n }\n \n fn get_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n-    let scope_bcx = find_scope_for_lpad(bcx);\n-    if scope_bcx.lpad_dirty {\n-        let unwind_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n-        trans_landing_pad(unwind_bcx);\n-        scope_bcx.lpad = some(unwind_bcx.llbb);\n-        scope_bcx.lpad_dirty = false;\n-    }\n-    assert option::is_some(scope_bcx.lpad);\n-    ret option::get(scope_bcx.lpad);\n-\n     fn find_scope_for_lpad(bcx: @block_ctxt) -> @block_ctxt {\n         let scope_bcx = bcx;\n         while true {\n-            scope_bcx = find_scope_cx(scope_bcx);\n-            if vec::is_not_empty(scope_bcx.cleanups) {\n-                ret scope_bcx;\n-            } else {\n-                scope_bcx = alt scope_bcx.parent {\n-                  parent_some(b) { b }\n-                  parent_none {\n-                    ret scope_bcx;\n-                  }\n-                };\n-            }\n+            if vec::is_not_empty(scope_bcx.cleanups) { break; }\n+            scope_bcx = alt scope_bcx.parent {\n+              parent_some(b) { b }\n+              parent_none { break; }\n+            };\n         }\n-        fail;\n+        scope_bcx\n     }\n-}\n \n-fn trans_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n+    let scope_bcx = find_scope_for_lpad(bcx);\n+    // If there is a valid landing pad still around, use it\n+    alt scope_bcx.landing_pad {\n+      some(target) { ret target; }\n+      none {}\n+    }\n+\n+    let pad_bcx = new_sub_block_ctxt(bcx, \"unwind\");\n+    scope_bcx.landing_pad = some(pad_bcx.llbb);\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n@@ -3035,36 +3025,29 @@ fn trans_landing_pad(bcx: @block_ctxt) -> BasicBlockRef {\n     // convention.\n     let personality = bcx_ccx(bcx).upcalls.rust_personality;\n     // The only landing pad clause will be 'cleanup'\n-    let clauses = 1u;\n-    let llpad = LandingPad(bcx, llretty, personality, clauses);\n-    // The landing pad result is used both for modifying the landing pad\n-    // in the C API and as the exception value\n-    let llretval = llpad;\n+    let llretval = LandingPad(pad_bcx, llretty, personality, 1u);\n     // The landing pad block is a cleanup\n-    SetCleanup(bcx, llpad);\n+    SetCleanup(pad_bcx, llretval);\n \n     // Because we may have unwound across a stack boundary, we must call into\n     // the runtime to figure out which stack segment we are on and place the\n     // stack limit back into the TLS.\n-    Call(bcx, bcx_ccx(bcx).upcalls.reset_stack_limit, []);\n+    Call(pad_bcx, bcx_ccx(bcx).upcalls.reset_stack_limit, []);\n \n-    // FIXME: This seems like a very naive and redundant way to generate the\n-    // landing pads, as we're re-generating all in-scope cleanups for each\n-    // function call. Probably good optimization opportunities here.\n-    let bcx = bcx;\n-    let scope_cx = bcx;\n-    while true {\n-        scope_cx = find_scope_cx(scope_cx);\n-        bcx = trans_block_cleanups(bcx, scope_cx);\n-        scope_cx = alt scope_cx.parent {\n-          parent_some(b) { b }\n-          parent_none { break; }\n-        };\n+    // We store the retval in a function-central alloca, so that calls to\n+    // Resume can find it.\n+    alt bcx.fcx.personality {\n+      some(addr) { Store(pad_bcx, llretval, addr); }\n+      none {\n+        let addr = alloca(pad_bcx, val_ty(llretval));\n+        bcx.fcx.personality = some(addr);\n+        Store(pad_bcx, llretval, addr);\n+      }\n     }\n \n-    // Continue unwinding\n-    Resume(bcx, llretval);\n-    ret bcx.llbb;\n+    // Unwind all parent scopes, and finish with a Resume instr\n+    cleanup_and_leave(pad_bcx, none, none);\n+    ret pad_bcx.llbb;\n }\n \n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n@@ -3215,13 +3198,12 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret alt::trans_alt(bcx, expr, arms, dest);\n       }\n       ast::expr_block(blk) {\n-        let sub_cx = new_real_block_ctxt(bcx, \"block-expr body\",\n-                                          blk.span);\n+        let sub_cx = new_real_block_ctxt(bcx, \"block-expr body\", blk.span);\n         Br(bcx, sub_cx.llbb);\n-        sub_cx = trans_block_dps(sub_cx, blk, dest);\n+        let sub_bcx = trans_block(sub_cx, blk, dest);\n         let next_cx = new_sub_block_ctxt(bcx, \"next\");\n-        Br(sub_cx, next_cx.llbb);\n-        if sub_cx.unreachable { Unreachable(next_cx); }\n+        if sub_bcx.unreachable { Unreachable(next_cx); }\n+        cleanup_and_Br(sub_bcx, sub_cx, next_cx.llbb);\n         ret next_cx;\n       }\n       ast::expr_rec(args, base) {\n@@ -3495,8 +3477,9 @@ fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let level_res = trans_temp_expr(level_cx, lvl);\n     let test = ICmp(level_res.bcx, lib::llvm::IntUGE,\n                     load, level_res.val);\n+    let level_bcx = trans_block_cleanups(level_res.bcx, level_cx);\n \n-    CondBr(level_res.bcx, test, log_cx.llbb, after_cx.llbb);\n+    CondBr(level_bcx, test, log_cx.llbb, after_cx.llbb);\n     let sub = trans_temp_expr(log_cx, e);\n     let e_ty = expr_ty(cx, e);\n     let log_bcx = sub.bcx;\n@@ -3515,9 +3498,8 @@ fn trans_log(lvl: @ast::expr, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     Call(log_bcx, ccx.upcalls.log_type,\n          [lltydesc, llval_i8, level_res.val]);\n \n-    log_bcx = trans_block_cleanups(log_bcx, log_cx);\n-    Br(log_bcx, after_cx.llbb);\n-    ret trans_block_cleanups(after_cx, level_cx);\n+    cleanup_and_Br(log_bcx, log_cx, after_cx.llbb);\n+    ret after_cx;\n }\n \n fn trans_check_expr(cx: @block_ctxt, e: @ast::expr, s: str) -> @block_ctxt {\n@@ -3588,36 +3570,33 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option<span>,\n fn trans_break_cont(bcx: @block_ctxt, to_end: bool)\n     -> @block_ctxt {\n     // Locate closest loop block, outputting cleanup as we go.\n-    let cleanup_cx = bcx, bcx = bcx;\n+    let unwind = bcx, target = bcx;\n     while true {\n-        bcx = trans_block_cleanups(bcx, cleanup_cx);\n-        alt copy cleanup_cx.kind {\n+        alt unwind.kind {\n           LOOP_SCOPE_BLOCK(_cont, _break) {\n-            if to_end {\n-                Br(bcx, _break.llbb);\n+            target = if to_end {\n+                _break\n             } else {\n                 alt _cont {\n-                  option::some(_cont) { Br(bcx, _cont.llbb); }\n-                  _ { Br(bcx, cleanup_cx.llbb); }\n+                  option::some(_cont) { _cont }\n+                  _ { unwind }\n                 }\n-            }\n-            Unreachable(bcx);\n-            ret bcx;\n-          }\n-          _ {\n-            alt cleanup_cx.parent {\n-              parent_some(cx) { cleanup_cx = cx; }\n-              parent_none {\n-                bcx_ccx(bcx).sess.bug\n-                    (if to_end { \"Break\" } else { \"Cont\" } +\n-                     \" outside a loop\");\n-              }\n-            }\n+            };\n+            break;\n           }\n+          _ {}\n         }\n+        unwind = alt check unwind.parent {\n+          parent_some(cx) { cx }\n+          parent_none {\n+            bcx_ccx(bcx).sess.bug\n+                (if to_end { \"break\" } else { \"cont\" } + \" outside a loop\");\n+          }\n+        };\n     }\n-    // If we get here without returning, it's a bug\n-    bcx_ccx(bcx).sess.bug(\"in trans::trans_break_cont()\");\n+    cleanup_and_Br(bcx, unwind, target.llbb);\n+    Unreachable(bcx);\n+    ret bcx;\n }\n \n fn trans_break(cx: @block_ctxt) -> @block_ctxt {\n@@ -3629,22 +3608,12 @@ fn trans_cont(cx: @block_ctxt) -> @block_ctxt {\n }\n \n fn trans_ret(bcx: @block_ctxt, e: option<@ast::expr>) -> @block_ctxt {\n-    let cleanup_cx = bcx, bcx = bcx;\n+    let bcx = bcx;\n     alt e {\n       some(x) { bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr); }\n       _ {}\n     }\n-    // run all cleanups and back out.\n-\n-    let more_cleanups: bool = true;\n-    while more_cleanups {\n-        bcx = trans_block_cleanups(bcx, cleanup_cx);\n-        alt cleanup_cx.parent {\n-          parent_some(b) { cleanup_cx = b; }\n-          parent_none { more_cleanups = false; }\n-        }\n-    }\n-    build_return(bcx);\n+    cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n     Unreachable(bcx);\n     ret bcx;\n }\n@@ -3777,8 +3746,8 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n                 parent: parent,\n                 kind: kind,\n                 mutable cleanups: [],\n-                mutable lpad_dirty: true,\n-                mutable lpad: none,\n+                mutable cleanup_paths: [],\n+                mutable landing_pad: none,\n                 block_span: block_span,\n                 fcx: cx};\n     alt parent {\n@@ -3827,8 +3796,8 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n           parent: parent_none,\n           kind: NON_SCOPE_BLOCK,\n           mutable cleanups: [],\n-          mutable lpad_dirty: true,\n-          mutable lpad: none,\n+          mutable cleanup_paths: [],\n+          mutable landing_pad: none,\n           block_span: none,\n           fcx: fcx};\n }\n@@ -3848,15 +3817,53 @@ fn trans_block_cleanups(bcx: @block_ctxt, cleanup_cx: @block_ctxt) ->\n     if cleanup_cx.kind == NON_SCOPE_BLOCK { assert i == 0u; }\n     while i > 0u {\n         i -= 1u;\n-        let c = cleanup_cx.cleanups[i];\n-        alt c {\n-          clean(cfn) { bcx = cfn(bcx); }\n-          clean_temp(_, cfn) { bcx = cfn(bcx); }\n+        alt cleanup_cx.cleanups[i] {\n+          clean(cfn) | clean_temp(_, cfn) { bcx = cfn(bcx); }\n         }\n     }\n     ret bcx;\n }\n \n+// In the last argument, some(block) mean jump to this block, and none means\n+// this is a landing pad and leaving should be accomplished with a resume\n+// instruction.\n+fn cleanup_and_leave(bcx: @block_ctxt, upto: option<BasicBlockRef>,\n+                     leave: option<BasicBlockRef>) {\n+    let cur = bcx, bcx = bcx;\n+    while true {\n+        if cur.cleanups.len() > 0u {\n+            assert cur.kind != NON_SCOPE_BLOCK;\n+            for exists in cur.cleanup_paths {\n+                if exists.target == leave {\n+                    Br(bcx, exists.dest);\n+                    ret;\n+                }\n+            }\n+            let sub_cx = new_sub_block_ctxt(bcx, \"cleanup\");\n+            Br(bcx, sub_cx.llbb);\n+            cur.cleanup_paths += [{target: leave, dest: sub_cx.llbb}];\n+            bcx = trans_block_cleanups(sub_cx, cur);\n+        }\n+        alt upto {\n+          some(bb) { if cur.llbb == bb { break; } }\n+          _ {}\n+        }\n+        cur = alt cur.parent {\n+          parent_some(next) { next }\n+          parent_none { assert option::is_none(upto); break; }\n+        };\n+    }\n+    alt leave {\n+      some(target) { Br(bcx, target); }\n+      none { Resume(bcx, Load(bcx, option::get(bcx.fcx.personality))); }\n+    }\n+}\n+\n+fn cleanup_and_Br(bcx: @block_ctxt, upto: @block_ctxt,\n+                  target: BasicBlockRef) {\n+    cleanup_and_leave(bcx, some(upto.llbb), some(target));\n+}\n+\n fn trans_fn_cleanups(fcx: @fn_ctxt, cx: @block_ctxt) {\n     alt fcx.llobstacktoken {\n       some(lltoken_) {\n@@ -3890,8 +3897,8 @@ fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n-          mutable lpad_dirty: true,\n-          mutable lpad: none,\n+          mutable cleanup_paths: [],\n+          mutable landing_pad: none,\n           block_span: none,\n           fcx: fcx};\n }\n@@ -3903,8 +3910,8 @@ fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           parent: parent_none,\n           kind: SCOPE_BLOCK,\n           mutable cleanups: [],\n-          mutable lpad_dirty: true,\n-          mutable lpad: none,\n+          mutable cleanup_paths: [],\n+          mutable landing_pad: none,\n           block_span: none,\n           fcx: fcx};\n }\n@@ -3966,11 +3973,7 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     ret r.bcx;\n }\n \n-fn trans_block(bcx: @block_ctxt, b: ast::blk) -> @block_ctxt {\n-    trans_block_dps(bcx, b, ignore)\n-}\n-\n-fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n+fn trans_block(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     -> @block_ctxt {\n     let bcx = bcx;\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n@@ -3986,8 +3989,7 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n       }\n       _ { assert dest == ignore || bcx.unreachable; }\n     }\n-    let rv = trans_block_cleanups(bcx, find_scope_cx(bcx));\n-    ret rv;\n+    ret bcx;\n }\n \n // Creates the standard quartet of basic blocks: static allocas, copy args,\n@@ -4032,7 +4034,8 @@ fn new_fn_ctxt_w_id(ccx: @crate_ctxt, path: path,\n           mutable lldynamicallocas: llbbs.da,\n           mutable llreturn: llbbs.rt,\n           mutable llobstacktoken: none::<ValueRef>,\n-          mutable llself: none::<val_self_pair>,\n+          mutable llself: none,\n+          mutable personality: none,\n           llargs: new_int_hash::<local_val>(),\n           lllocals: new_int_hash::<local_val>(),\n           llupvars: new_int_hash::<ValueRef>(),\n@@ -4179,7 +4182,7 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx = new_top_block_ctxt(fcx, some(body.span));\n+    let bcx_top = new_top_block_ctxt(fcx, some(body.span)), bcx = bcx_top;\n     let lltop = bcx.llbb;\n     let block_ty = node_id_type(bcx, body.node.id);\n \n@@ -4195,12 +4198,12 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n     if option::is_none(body.node.expr) ||\n        ty::type_is_bot(block_ty) ||\n        ty::type_is_nil(block_ty) {\n-        bcx = trans_block(bcx, body);\n+        bcx = trans_block(bcx, body, ignore);\n     } else {\n-        bcx = trans_block_dps(bcx, body, save_in(fcx.llretptr));\n+        bcx = trans_block(bcx, body, save_in(fcx.llretptr));\n     }\n+    cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n \n-    if !bcx.unreachable { build_return(bcx); }\n     // Insert the mandatory first few basic blocks before lltop.\n     finish_fn(fcx, lltop);\n }"}, {"sha": "0ed6e33886fa3116dcd4848c6b569c760426e110", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "patch": "@@ -173,6 +173,9 @@ type fn_ctxt = {\n     // The 'self' value currently in use in this function, if there\n     // is one.\n     mutable llself: option<val_self_pair>,\n+    // The a value alloca'd for calls to upcalls.rust_personality. Used when\n+    // outputting the resume instruction.\n+    mutable personality: option<ValueRef>,\n \n     // Maps arguments to allocas created for them in llallocas.\n     llargs: hashmap<ast::node_id, local_val>,\n@@ -225,11 +228,21 @@ enum cleanup {\n     clean_temp(ValueRef, fn@(@block_ctxt) -> @block_ctxt),\n }\n \n+// Used to remember and reuse existing cleanup paths\n+// target: none means the path ends in an resume instruction\n+type cleanup_path = {target: option<BasicBlockRef>,\n+                     dest: BasicBlockRef};\n+\n+fn scope_clean_changed(cx: @block_ctxt) {\n+    cx.cleanup_paths = [];\n+    cx.landing_pad = none;\n+}\n+\n fn add_clean(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n     let scope_cx = find_scope_cx(cx);\n     scope_cx.cleanups += [clean(bind drop_ty(_, val, ty))];\n-    scope_cx.lpad_dirty = true;\n+    scope_clean_changed(scope_cx);\n }\n fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n@@ -244,20 +257,20 @@ fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     let scope_cx = find_scope_cx(cx);\n     scope_cx.cleanups +=\n         [clean_temp(val, bind do_drop(_, val, ty))];\n-    scope_cx.lpad_dirty = true;\n+    scope_clean_changed(scope_cx);\n }\n fn add_clean_temp_mem(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(bcx_tcx(cx), ty) { ret; }\n     let scope_cx = find_scope_cx(cx);\n     scope_cx.cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n-    scope_cx.lpad_dirty = true;\n+    scope_clean_changed(scope_cx);\n }\n fn add_clean_free(cx: @block_ctxt, ptr: ValueRef, shared: bool) {\n     let scope_cx = find_scope_cx(cx);\n     let free_fn = if shared { bind base::trans_shared_free(_, ptr) }\n                   else { bind base::trans_free(_, ptr) };\n     scope_cx.cleanups += [clean_temp(ptr, free_fn)];\n-    scope_cx.lpad_dirty = true;\n+    scope_clean_changed(scope_cx);\n }\n \n // Note that this only works for temporaries. We should, at some point, move\n@@ -284,7 +297,7 @@ fn revoke_clean(cx: @block_ctxt, val: ValueRef) {\n         vec::slice(sc_cx.cleanups, 0u, found as uint) +\n             vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n                             sc_cx.cleanups.len());\n-    sc_cx.lpad_dirty = true;\n+    scope_clean_changed(sc_cx);\n     ret;\n }\n \n@@ -323,7 +336,6 @@ enum block_kind {\n     NON_SCOPE_BLOCK\n }\n \n-\n // Basic block context.  We create a block context for each basic block\n // (single-entry, single-exit sequence of instructions) we generate from Rust\n // code.  Each basic block we generate is attached to a function, typically\n@@ -348,9 +360,10 @@ type block_ctxt =\n      mutable unreachable: bool,\n      parent: block_parent,\n      kind: block_kind,\n+     // FIXME the next five fields should probably only appear in scope blocks\n      mutable cleanups: [cleanup],\n-     mutable lpad_dirty: bool,\n-     mutable lpad: option<BasicBlockRef>,\n+     mutable cleanup_paths: [cleanup_path],\n+     mutable landing_pad: option<BasicBlockRef>,\n      block_span: option<span>,\n      fcx: @fn_ctxt};\n \n@@ -383,13 +396,12 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n }\n \n fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n-    if cx.kind != NON_SCOPE_BLOCK { ret cx; }\n-    alt cx.parent {\n-      parent_some(b) { ret find_scope_cx(b); }\n-      _ {\n-          bcx_tcx(cx).sess.bug(\"find_scope_cx: empty scope\");\n-      }\n+    let cur = cx;\n+    while true {\n+        if cur.kind != NON_SCOPE_BLOCK { break; }\n+        cur = alt check cur.parent { parent_some(b) { b } };\n     }\n+    cur\n }\n \n // Accessors"}, {"sha": "8f683978bf5b2d8d0cf24a21c7b559458f5be5fb", "filename": "src/test/compile-fail/break-outside-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e62ddf48988087d19934e1fdc6abb6de5f7a6a02/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbreak-outside-loop.rs?ref=e62ddf48988087d19934e1fdc6abb6de5f7a6a02", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:Break outside a loop\n+// error-pattern:break outside a loop\n fn main() {\n     let pth = break;\n "}]}