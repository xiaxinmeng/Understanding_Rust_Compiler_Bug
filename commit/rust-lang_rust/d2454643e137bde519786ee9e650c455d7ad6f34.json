{"sha": "d2454643e137bde519786ee9e650c455d7ad6f34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNDU0NjQzZTEzN2JkZTUxOTc4NmVlOWU2NTBjNDU1ZDdhZDZmMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-04T17:07:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-04T17:07:39Z"}, "message": "Auto merge of #75077 - LeSeulArtichaut:tys-kind, r=nikomatsakis\n\nRefractor ty.kind -> ty.kind() and ty.flags -> ty.flags()\n\nFirst step for the [\"shared library to represent Rust types\"](https://rust-lang.github.io/compiler-team/minutes/design-meeting/2020-03-12-shared-library-for-types/) work (rust-lang/wg-traits#16).\n\nThis PR makes the `TyS::kind` field private and adds a `kind()` method to access it.\nAs noted [on Zulip](https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/Looking.20to.20contribute/near/205185412), this refractoring might require a MCP. I am perfectly fine with having to wait until MCP is accepted and resolving the conflicts that pop up afterwards.\n\nr? @nikomatsakis", "tree": {"sha": "ce7c0a9de68030f6e3ec440400065cbaa51adfa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce7c0a9de68030f6e3ec440400065cbaa51adfa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2454643e137bde519786ee9e650c455d7ad6f34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2454643e137bde519786ee9e650c455d7ad6f34", "html_url": "https://github.com/rust-lang/rust/commit/d2454643e137bde519786ee9e650c455d7ad6f34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2454643e137bde519786ee9e650c455d7ad6f34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80cacd77954b39a6bc205213faa8c82c97eb0055", "url": "https://api.github.com/repos/rust-lang/rust/commits/80cacd77954b39a6bc205213faa8c82c97eb0055", "html_url": "https://github.com/rust-lang/rust/commit/80cacd77954b39a6bc205213faa8c82c97eb0055"}, {"sha": "4d28a82c590aa77fbd1e5e0f8a0fe611c93b5a71", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d28a82c590aa77fbd1e5e0f8a0fe611c93b5a71", "html_url": "https://github.com/rust-lang/rust/commit/4d28a82c590aa77fbd1e5e0f8a0fe611c93b5a71"}], "stats": {"total": 2287, "additions": 1174, "deletions": 1113}, "files": [{"sha": "23a3be1a2f2e8dca354620c2fe419d6c890e27ad", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -306,10 +306,10 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         use rustc_ast::UintTy::*;\n         use rustc_middle::ty::{Int, Uint};\n \n-        let new_kind = match ty.kind {\n+        let new_kind = match ty.kind() {\n             Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.ptr_width)),\n             Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.ptr_width)),\n-            ref t @ (Uint(_) | Int(_)) => t.clone(),\n+            t @ (Uint(_) | Int(_)) => t.clone(),\n             _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n         };\n "}, {"sha": "2b2bcd979999f42b1be559b714d30fed9ffc71a0", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -125,7 +125,7 @@ fn check_and_apply_linkage(\n         // extern \"C\" fn() from being non-null, so we can't just declare a\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n-        let llty2 = if let ty::RawPtr(ref mt) = ty.kind {\n+        let llty2 = if let ty::RawPtr(ref mt) = ty.kind() {\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n             cx.sess().span_fatal("}, {"sha": "868eb74cf09cd010ebf40f70ecec1460685e4331", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -343,7 +343,7 @@ fn fixed_vec_metadata(\n \n     let (size, align) = cx.size_and_align_of(array_or_slice_type);\n \n-    let upper_bound = match array_or_slice_type.kind {\n+    let upper_bound = match array_or_slice_type.kind() {\n         ty::Array(_, len) => len.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()) as c_longlong,\n         _ => -1,\n     };\n@@ -432,7 +432,7 @@ fn subroutine_type_metadata(\n \n     let signature_metadata: Vec<_> = iter::once(\n         // return type\n-        match signature.output().kind {\n+        match signature.output().kind() {\n             ty::Tuple(ref tys) if tys.is_empty() => None,\n             _ => Some(type_metadata(cx, signature.output(), span)),\n         },\n@@ -472,7 +472,7 @@ fn trait_pointer_metadata(\n     // type is assigned the correct name, size, namespace, and source location.\n     // However, it does not describe the trait's methods.\n \n-    let containing_scope = match trait_type.kind {\n+    let containing_scope = match trait_type.kind() {\n         ty::Dynamic(ref data, ..) => {\n             data.principal_def_id().map(|did| get_namespace_for_item(cx, did))\n         }\n@@ -572,7 +572,7 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n \n     debug!(\"type_metadata: {:?}\", t);\n \n-    let ptr_metadata = |ty: Ty<'tcx>| match ty.kind {\n+    let ptr_metadata = |ty: Ty<'tcx>| match *ty.kind() {\n         ty::Slice(typ) => Ok(vec_slice_metadata(cx, t, typ, unique_type_id, usage_site_span)),\n         ty::Str => Ok(vec_slice_metadata(cx, t, cx.tcx.types.u8, unique_type_id, usage_site_span)),\n         ty::Dynamic(..) => Ok(MetadataCreationResult::new(\n@@ -592,7 +592,7 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n         }\n     };\n \n-    let MetadataCreationResult { metadata, already_stored_in_typemap } = match t.kind {\n+    let MetadataCreationResult { metadata, already_stored_in_typemap } = match *t.kind() {\n         ty::Never | ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n@@ -876,7 +876,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let msvc_like_names = cx.tcx.sess.target.target.options.is_like_msvc;\n \n-    let (name, encoding) = match t.kind {\n+    let (name, encoding) = match t.kind() {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n         ty::Tuple(ref elements) if elements.is_empty() => (\"()\", DW_ATE_unsigned),\n         ty::Bool => (\"bool\", DW_ATE_boolean),\n@@ -904,7 +904,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n         return ty_metadata;\n     }\n \n-    let typedef_name = match t.kind {\n+    let typedef_name = match t.kind() {\n         ty::Int(int_ty) => int_ty.name_str(),\n         ty::Uint(uint_ty) => uint_ty.name_str(),\n         ty::Float(float_ty) => float_ty.name_str(),\n@@ -1239,7 +1239,7 @@ fn prepare_struct_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx.tcx, struct_type, false);\n \n-    let (struct_def_id, variant) = match struct_type.kind {\n+    let (struct_def_id, variant) = match struct_type.kind() {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_struct_metadata on a non-ADT\"),\n     };\n@@ -1373,7 +1373,7 @@ fn prepare_union_metadata(\n ) -> RecursiveTypeDescription<'ll, 'tcx> {\n     let union_name = compute_debuginfo_type_name(cx.tcx, union_type, false);\n \n-    let (union_def_id, variant) = match union_type.kind {\n+    let (union_def_id, variant) = match union_type.kind() {\n         ty::Adt(def, _) => (def.did, def.non_enum_variant()),\n         _ => bug!(\"prepare_union_metadata on a non-ADT\"),\n     };\n@@ -1457,14 +1457,14 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n     fn create_member_descriptions(&self, cx: &CodegenCx<'ll, 'tcx>) -> Vec<MemberDescription<'ll>> {\n-        let generator_variant_info_data = match self.enum_type.kind {\n+        let generator_variant_info_data = match *self.enum_type.kind() {\n             ty::Generator(def_id, ..) => {\n                 Some(generator_layout_and_saved_local_names(cx.tcx, def_id))\n             }\n             _ => None,\n         };\n \n-        let variant_info_for = |index: VariantIdx| match self.enum_type.kind {\n+        let variant_info_for = |index: VariantIdx| match *self.enum_type.kind() {\n             ty::Adt(adt, _) => VariantInfo::Adt(&adt.variants[index]),\n             ty::Generator(def_id, _, _) => {\n                 let (generator_layout, generator_saved_local_names) =\n@@ -1486,14 +1486,14 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n         } else {\n             type_metadata(cx, self.enum_type, self.span)\n         };\n-        let flags = match self.enum_type.kind {\n+        let flags = match self.enum_type.kind() {\n             ty::Generator(..) => DIFlags::FlagArtificial,\n             _ => DIFlags::FlagZero,\n         };\n \n         match self.layout.variants {\n             Variants::Single { index } => {\n-                if let ty::Adt(adt, _) = &self.enum_type.kind {\n+                if let ty::Adt(adt, _) = self.enum_type.kind() {\n                     if adt.variants.is_empty() {\n                         return vec![];\n                     }\n@@ -1942,7 +1942,7 @@ fn prepare_enum_metadata(\n     let tcx = cx.tcx;\n     let enum_name = compute_debuginfo_type_name(tcx, enum_type, false);\n     // FIXME(tmandry): This doesn't seem to have any effect.\n-    let enum_flags = match enum_type.kind {\n+    let enum_flags = match enum_type.kind() {\n         ty::Generator(..) => DIFlags::FlagArtificial,\n         _ => DIFlags::FlagZero,\n     };\n@@ -1957,13 +1957,13 @@ fn prepare_enum_metadata(\n     let file_metadata = unknown_file_metadata(cx);\n \n     let discriminant_type_metadata = |discr: Primitive| {\n-        let enumerators_metadata: Vec<_> = match enum_type.kind {\n+        let enumerators_metadata: Vec<_> = match enum_type.kind() {\n             ty::Adt(def, _) => def\n                 .discriminants(tcx)\n                 .zip(&def.variants)\n                 .map(|((_, discr), v)| {\n                     let name = v.ident.as_str();\n-                    let is_unsigned = match discr.ty.kind {\n+                    let is_unsigned = match discr.ty.kind() {\n                         ty::Int(_) => false,\n                         ty::Uint(_) => true,\n                         _ => bug!(\"non integer discriminant\"),\n@@ -2012,7 +2012,7 @@ fn prepare_enum_metadata(\n                     type_metadata(cx, discr.to_ty(tcx), rustc_span::DUMMY_SP);\n \n                 let item_name;\n-                let discriminant_name = match enum_type.kind {\n+                let discriminant_name = match enum_type.kind() {\n                     ty::Adt(..) => {\n                         item_name = tcx.item_name(enum_def_id).as_str();\n                         &*item_name\n@@ -2105,7 +2105,7 @@ fn prepare_enum_metadata(\n         );\n     }\n \n-    let discriminator_name = match &enum_type.kind {\n+    let discriminator_name = match enum_type.kind() {\n         ty::Generator(..) => \"__state\",\n         _ => \"\",\n     };\n@@ -2328,7 +2328,7 @@ fn set_members_of_composite_type(\n \n /// Computes the type parameters for a type, if any, for the given metadata.\n fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'ll DIArray> {\n-    if let ty::Adt(def, substs) = ty.kind {\n+    if let ty::Adt(def, substs) = *ty.kind() {\n         if substs.types().next().is_some() {\n             let generics = cx.tcx.generics_of(def.did);\n             let names = get_parameter_names(cx, generics);"}, {"sha": "7cdd366175dadea25fb410fc38272620dd61ec5d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -361,9 +361,9 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 // already inaccurate due to ABI adjustments (see #42800).\n                 signature.extend(fn_abi.args.iter().map(|arg| {\n                     let t = arg.layout.ty;\n-                    let t = match t.kind {\n+                    let t = match t.kind() {\n                         ty::Array(ct, _)\n-                            if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() =>\n+                            if (*ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() =>\n                         {\n                             cx.tcx.mk_imm_ptr(ct)\n                         }\n@@ -467,7 +467,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n                     // Only \"class\" methods are generally understood by LLVM,\n                     // so avoid methods on other types (e.g., `<*mut T>::null`).\n-                    match impl_self_ty.kind {\n+                    match impl_self_ty.kind() {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             // Again, only create type information if full debuginfo is enabled\n                             if cx.sess().opts.debuginfo == DebugInfo::Full"}, {"sha": "2208ceca00c83483e54628323b523b9b7355ef71", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -90,7 +90,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let tcx = self.tcx;\n         let callee_ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n \n-        let (def_id, substs) = match callee_ty.kind {\n+        let (def_id, substs) = match *callee_ty.kind() {\n             ty::FnDef(def_id, substs) => (def_id, substs),\n             _ => bug!(\"expected fn item type, found {}\", callee_ty),\n         };\n@@ -1271,7 +1271,7 @@ fn generic_simd_intrinsic(\n \n     if name == sym::simd_select_bitmask {\n         let in_ty = arg_tys[0];\n-        let m_len = match in_ty.kind {\n+        let m_len = match in_ty.kind() {\n             // Note that this `.unwrap()` crashes for isize/usize, that's sort\n             // of intentional as there's not currently a use case for that.\n             ty::Int(i) => i.bit_width().unwrap(),\n@@ -1436,7 +1436,7 @@ fn generic_simd_intrinsic(\n             m_len,\n             v_len\n         );\n-        match m_elem_ty.kind {\n+        match m_elem_ty.kind() {\n             ty::Int(_) => {}\n             _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n         }\n@@ -1455,13 +1455,13 @@ fn generic_simd_intrinsic(\n         // If the vector has less than 8 lanes, an u8 is returned with zeroed\n         // trailing bits.\n         let expected_int_bits = in_len.max(8);\n-        match ret_ty.kind {\n+        match ret_ty.kind() {\n             ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => (),\n             _ => return_error!(\"bitmask `{}`, expected `u{}`\", ret_ty, expected_int_bits),\n         }\n \n         // Integer vector <i{in_bitwidth} x in_len>:\n-        let (i_xn, in_elem_bitwidth) = match in_elem.kind {\n+        let (i_xn, in_elem_bitwidth) = match in_elem.kind() {\n             ty::Int(i) => {\n                 (args[0].immediate(), i.bit_width().unwrap_or(bx.data_layout().pointer_size.bits()))\n             }\n@@ -1518,7 +1518,7 @@ fn generic_simd_intrinsic(\n                 }\n             }\n         }\n-        let ety = match in_elem.kind {\n+        let ety = match in_elem.kind() {\n             ty::Float(f) if f.bit_width() == 32 => {\n                 if in_len < 2 || in_len > 16 {\n                     return_error!(\n@@ -1612,7 +1612,7 @@ fn generic_simd_intrinsic(\n     //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Intrinsics.h#L81\n     fn llvm_vector_str(elem_ty: Ty<'_>, vec_len: u64, no_pointers: usize) -> String {\n         let p0s: String = \"p0\".repeat(no_pointers);\n-        match elem_ty.kind {\n+        match *elem_ty.kind() {\n             ty::Int(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n             ty::Uint(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n             ty::Float(v) => format!(\"v{}{}f{}\", vec_len, p0s, v.bit_width()),\n@@ -1627,7 +1627,7 @@ fn generic_simd_intrinsic(\n         mut no_pointers: usize,\n     ) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n-        let mut elem_ty = match elem_ty.kind {\n+        let mut elem_ty = match *elem_ty.kind() {\n             ty::Int(v) => cx.type_int_from_ty(v),\n             ty::Uint(v) => cx.type_uint_from_ty(v),\n             ty::Float(v) => cx.type_float_from_ty(v),\n@@ -1680,23 +1680,23 @@ fn generic_simd_intrinsic(\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n-            match t.kind {\n+            match t.kind() {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n-            match t.kind {\n+            match t.kind() {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind() {\n             ty::RawPtr(p) if p.ty == in_elem => {\n                 (ptr_count(arg_tys[1].simd_type(tcx)), non_ptr(arg_tys[1].simd_type(tcx)))\n             }\n@@ -1721,7 +1721,7 @@ fn generic_simd_intrinsic(\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:\n-        match arg_tys[2].simd_type(tcx).kind {\n+        match arg_tys[2].simd_type(tcx).kind() {\n             ty::Int(_) => (),\n             _ => {\n                 require!(\n@@ -1803,23 +1803,23 @@ fn generic_simd_intrinsic(\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n-            match t.kind {\n+            match t.kind() {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n         fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n-            match t.kind {\n+            match t.kind() {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n             }\n         }\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n+        let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind() {\n             ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n                 (ptr_count(arg_tys[1].simd_type(tcx)), non_ptr(arg_tys[1].simd_type(tcx)))\n             }\n@@ -1844,7 +1844,7 @@ fn generic_simd_intrinsic(\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:\n-        match arg_tys[2].simd_type(tcx).kind {\n+        match arg_tys[2].simd_type(tcx).kind() {\n             ty::Int(_) => (),\n             _ => {\n                 require!(\n@@ -1900,7 +1900,7 @@ fn generic_simd_intrinsic(\n                     in_ty,\n                     ret_ty\n                 );\n-                return match in_elem.kind {\n+                return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.$integer_reduce(args[0].immediate());\n                         if $ordered {\n@@ -1972,7 +1972,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     in_ty,\n                     ret_ty\n                 );\n-                return match in_elem.kind {\n+                return match in_elem.kind() {\n                     ty::Int(_i) => Ok(bx.$int_red(args[0].immediate(), true)),\n                     ty::Uint(_u) => Ok(bx.$int_red(args[0].immediate(), false)),\n                     ty::Float(_f) => Ok(bx.$float_red(args[0].immediate())),\n@@ -2007,7 +2007,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     );\n                     args[0].immediate()\n                 } else {\n-                    match in_elem.kind {\n+                    match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n                         _ => return_error!(\n                             \"unsupported {} from `{}` with element `{}` to `{}`\",\n@@ -2023,7 +2023,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     let i1xn = bx.type_vector(i1, in_len as u64);\n                     bx.trunc(args[0].immediate(), i1xn)\n                 };\n-                return match in_elem.kind {\n+                return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.$red(input);\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n@@ -2071,15 +2071,15 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             Unsupported,\n         }\n \n-        let (in_style, in_width) = match in_elem.kind {\n+        let (in_style, in_width) = match in_elem.kind() {\n             // vectors of pointer-sized integers should've been\n             // disallowed before here, so this unwrap is safe.\n             ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n             ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n             ty::Float(f) => (Style::Float, f.bit_width()),\n             _ => (Style::Unsupported, 0),\n         };\n-        let (out_style, out_width) = match out_elem.kind {\n+        let (out_style, out_width) = match out_elem.kind() {\n             ty::Int(i) => (Style::Int(true), i.bit_width().unwrap()),\n             ty::Uint(u) => (Style::Int(false), u.bit_width().unwrap()),\n             ty::Float(f) => (Style::Float, f.bit_width()),\n@@ -2135,7 +2135,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     macro_rules! arith {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n             $(if name == sym::$name {\n-                match in_elem.kind {\n+                match in_elem.kind() {\n                     $($(ty::$p(_))|* => {\n                         return Ok(bx.$call(args[0].immediate(), args[1].immediate()))\n                     })*\n@@ -2169,7 +2169,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         let rhs = args[1].immediate();\n         let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match in_elem.kind {\n+        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n@@ -2204,7 +2204,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Int(t) => Some((\n             match t {\n                 ast::IntTy::Isize => u64::from(cx.tcx.sess.target.ptr_width),\n@@ -2234,7 +2234,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n // Returns the width of a float Ty\n // Returns None if the type is not a float\n fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Float(t) => Some(t.bit_width()),\n         _ => None,\n     }"}, {"sha": "12901de6048ac4cdcd55013b612c9c9c7f04e4d9", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -51,7 +51,7 @@ fn uncached_llvm_type<'a, 'tcx>(\n         Abi::Uninhabited | Abi::Aggregate { .. } => {}\n     }\n \n-    let name = match layout.ty.kind {\n+    let name = match layout.ty.kind() {\n         // FIXME(eddyb) producing readable type names for trait objects can result\n         // in problematically distinct types due to HRTB and subtyping (see #47638).\n         // ty::Dynamic(..) |\n@@ -60,14 +60,14 @@ fn uncached_llvm_type<'a, 'tcx>(\n         {\n             let mut name = with_no_trimmed_paths(|| layout.ty.to_string());\n             if let (&ty::Adt(def, _), &Variants::Single { index }) =\n-                (&layout.ty.kind, &layout.variants)\n+                (layout.ty.kind(), &layout.variants)\n             {\n                 if def.is_enum() && !def.variants.is_empty() {\n                     write!(&mut name, \"::{}\", def.variants[index].ident).unwrap();\n                 }\n             }\n             if let (&ty::Generator(_, _, _), &Variants::Single { index }) =\n-                (&layout.ty.kind, &layout.variants)\n+                (layout.ty.kind(), &layout.variants)\n             {\n                 write!(&mut name, \"::{}\", ty::GeneratorSubsts::variant_name(index)).unwrap();\n             }\n@@ -238,7 +238,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             if let Some(&llty) = cx.scalar_lltypes.borrow().get(&self.ty) {\n                 return llty;\n             }\n-            let llty = match self.ty.kind {\n+            let llty = match *self.ty.kind() {\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     cx.type_ptr_to(cx.layout_of(ty).llvm_type(cx))\n                 }\n@@ -331,7 +331,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     ) -> &'a Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n-        match self.ty.kind {\n+        match self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n                 return self.field(cx, index).llvm_type(cx);\n             }"}, {"sha": "6fc849969a4d6d598e9eebab9aced959a48e0399", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -120,7 +120,7 @@ pub fn compare_simd_types<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     ret_ty: Bx::Type,\n     op: hir::BinOpKind,\n ) -> Bx::Value {\n-    let signed = match t.kind {\n+    let signed = match t.kind() {\n         ty::Float(_) => {\n             let cmp = bin_op_to_fcmp_predicate(op);\n             let cmp = bx.fcmp(cmp, lhs, rhs);\n@@ -153,7 +153,7 @@ pub fn unsized_info<'tcx, Cx: CodegenMethods<'tcx>>(\n ) -> Cx::Value {\n     let (source, target) =\n         cx.tcx().struct_lockstep_tails_erasing_lifetimes(source, target, cx.param_env());\n-    match (&source.kind, &target.kind) {\n+    match (source.kind(), target.kind()) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n@@ -182,7 +182,7 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     dst_ty: Ty<'tcx>,\n ) -> (Bx::Value, Bx::Value) {\n     debug!(\"unsize_thin_ptr: {:?} => {:?}\", src_ty, dst_ty);\n-    match (&src_ty.kind, &dst_ty.kind) {\n+    match (src_ty.kind(), dst_ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _) | &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             assert!(bx.cx().type_is_sized(a));\n@@ -231,7 +231,7 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n-    match (&src_ty.kind, &dst_ty.kind) {\n+    match (src_ty.kind(), dst_ty.kind()) {\n         (&ty::Ref(..), &ty::Ref(..) | &ty::RawPtr(..)) | (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n             let (base, info) = match bx.load_operand(src).val {\n                 OperandValue::Pair(base, info) => {"}, {"sha": "54e5d4d00f6e44bfe03e1d2f790609cf62cb92ed", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -33,7 +33,7 @@ pub fn push_debuginfo_type_name<'tcx>(\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = tcx.sess.target.target.options.is_like_msvc;\n \n-    match t.kind {\n+    match *t.kind() {\n         ty::Bool => output.push_str(\"bool\"),\n         ty::Char => output.push_str(\"char\"),\n         ty::Str => output.push_str(\"str\"),"}, {"sha": "b88de0b2411414ca9da2dd091737f15494c202f3", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -19,7 +19,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let align = bx.const_usize(layout.align.abi.bytes());\n         return (size, align);\n     }\n-    match t.kind {\n+    match t.kind() {\n         ty::Dynamic(..) => {\n             // load size/align from vtable\n             let vtable = info.unwrap();\n@@ -64,7 +64,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let size = bx.add(sized_size, unsized_size);\n \n             // Packed types ignore the alignment of their fields.\n-            if let ty::Adt(def, _) = t.kind {\n+            if let ty::Adt(def, _) = t.kind() {\n                 if def.repr.packed() {\n                     unsized_align = sized_align;\n                 }"}, {"sha": "bdde07d3fa9b0f1759f4c9a699f3dfeaa63e4686", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -236,7 +236,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n     fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n         let check = match terminator.kind {\n             mir::TerminatorKind::Call { func: mir::Operand::Constant(ref c), ref args, .. } => {\n-                match c.literal.ty.kind {\n+                match *c.literal.ty.kind() {\n                     ty::FnDef(did, _) => Some((did, args)),\n                     _ => None,\n                 }"}, {"sha": "4639ce4a5ab5bc2a696135e960c00d5442d57270", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             args1 = [place.llval];\n             &args1[..]\n         };\n-        let (drop_fn, fn_abi) = match ty.kind {\n+        let (drop_fn, fn_abi) = match ty.kind() {\n             // FIXME(eddyb) perhaps move some of this logic into\n             // `Instance::resolve_drop_in_place`?\n             ty::Dynamic(..) => {\n@@ -540,7 +540,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n         let callee = self.codegen_operand(&mut bx, func);\n \n-        let (instance, mut llfn) = match callee.layout.ty.kind {\n+        let (instance, mut llfn) = match *callee.layout.ty.kind() {\n             ty::FnDef(def_id, substs) => (\n                 Some(\n                     ty::Instance::resolve(bx.tcx(), ty::ParamEnv::reveal_all(), def_id, substs)\n@@ -887,7 +887,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             _ => span_bug!(span, \"expected ByRef for promoted asm const\"),\n                         };\n                         let value = scalar.assert_bits(size);\n-                        let string = match ty.kind {\n+                        let string = match ty.kind() {\n                             ty::Uint(_) => value.to_string(),\n                             ty::Int(int_ty) => {\n                                 match int_ty.normalize(bx.tcx().sess.target.ptr_width) {\n@@ -914,7 +914,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n                 mir::InlineAsmOperand::SymFn { ref value } => {\n                     let literal = self.monomorphize(&value.literal);\n-                    if let ty::FnDef(def_id, substs) = literal.ty.kind {\n+                    if let ty::FnDef(def_id, substs) = *literal.ty.kind() {\n                         let instance = ty::Instance::resolve_for_fn_ptr(\n                             bx.tcx(),\n                             ty::ParamEnv::reveal_all(),"}, {"sha": "c1e7cfd80ef101e2b8930a7af3412212ed50baeb", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -369,8 +369,8 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // individual LLVM function arguments.\n \n                 let arg_ty = fx.monomorphize(&arg_decl.ty);\n-                let tupled_arg_tys = match arg_ty.kind {\n-                    ty::Tuple(ref tys) => tys,\n+                let tupled_arg_tys = match arg_ty.kind() {\n+                    ty::Tuple(tys) => tys,\n                     _ => bug!(\"spread argument isn't a tuple?!\"),\n                 };\n "}, {"sha": "7c3b80c9c8fdfc4b6d8ff994c17faa66222f6c90", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         //   * no metadata available - just log the case\n         //   * known alignment - sized types, `[T]`, `str` or a foreign type\n         //   * packed struct - there is no alignment padding\n-        match field.ty.kind {\n+        match field.ty.kind() {\n             _ if self.llextra.is_none() => {\n                 debug!(\n                     \"unsized field `{}`, of `{:?}` has no metadata for adjustment\","}, {"sha": "7ce110dcbfc48d5c5b7e43f51ce41f8f1588fd60", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -185,7 +185,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                 let val = match *kind {\n                     mir::CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        match operand.layout.ty.kind {\n+                        match *operand.layout.ty.kind() {\n                             ty::FnDef(def_id, substs) => {\n                                 if bx.cx().tcx().has_attr(def_id, sym::rustc_args_required_const) {\n                                     bug!(\"reifying a fn ptr that requires const arguments\");\n@@ -204,7 +204,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::Pointer(PointerCast::ClosureFnPointer(_)) => {\n-                        match operand.layout.ty.kind {\n+                        match *operand.layout.ty.kind() {\n                             ty::Closure(def_id, substs) => {\n                                 let instance = Instance::resolve_closure(\n                                     bx.cx().tcx(),\n@@ -564,7 +564,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // because codegen_place() panics if Local is operand.\n         if let Some(index) = place.as_local() {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n-                if let ty::Array(_, n) = op.layout.ty.kind {\n+                if let ty::Array(_, n) = op.layout.ty.kind() {\n                     let n = n.eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n                     return bx.cx().const_usize(n);\n                 }"}, {"sha": "cec07b977e6851a9c40b317d8656396bb853d2cb", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -89,7 +89,7 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n         }\n \n         let tail = self.tcx().struct_tail_erasing_lifetimes(ty, param_env);\n-        match tail.kind {\n+        match tail.kind() {\n             ty::Foreign(..) => false,\n             ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n             _ => bug!(\"unexpected unsized tail: {:?}\", tail),"}, {"sha": "871fc4fafe269f02f7bcea52454b2d1c4e2563b8", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -340,7 +340,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind {\n+        match *t.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 debug!(\"canonical: type var found with vid {:?}\", vid);\n                 match self.infcx.unwrap().probe_ty_var(vid) {\n@@ -418,7 +418,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::Foreign(..)\n             | ty::Param(..)\n             | ty::Opaque(..) => {\n-                if t.flags.intersects(self.needs_canonical_flags) {\n+                if t.flags().intersects(self.needs_canonical_flags) {\n                     t.super_fold_with(self)\n                 } else {\n                     t"}, {"sha": "93e19521893efd2037b5180e55f9db5d70fa31bb", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -422,7 +422,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             match result_value.unpack() {\n                 GenericArgKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n-                    if let ty::Bound(debruijn, b) = result_value.kind {\n+                    if let ty::Bound(debruijn, b) = *result_value.kind() {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(?U)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions."}, {"sha": "ae4612a89f277be695115423a79cf1014aa9faf0", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -72,7 +72,7 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     {\n         let a_is_expected = relation.a_is_expected();\n \n-        match (&a.kind, &b.kind) {\n+        match (a.kind(), b.kind()) {\n             // Relate integral variables to other types\n             (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n                 self.inner\n@@ -541,7 +541,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n         // us from creating infinitely sized types.\n-        match t.kind {\n+        match *t.kind() {\n             ty::Infer(ty::TyVar(vid)) => {\n                 let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n                 let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);"}, {"sha": "7c388b5503ee39272ed6fe4efd97da508cc53ee0", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -77,7 +77,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n         debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n \n-        match (&a.kind, &b.kind) {\n+        match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n                 infcx.inner.borrow_mut().type_variables().equate(a_id, b_id);\n             }"}, {"sha": "b53605b0796c9627a62b30fa36d0f68504a1e4a9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -570,7 +570,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // if they are both \"path types\", there's a chance of ambiguity\n                 // due to different versions of the same crate\n                 if let (&ty::Adt(exp_adt, _), &ty::Adt(found_adt, _)) =\n-                    (&exp_found.expected.kind, &exp_found.found.kind)\n+                    (exp_found.expected.kind(), exp_found.found.kind())\n                 {\n                     report_path_match(err, exp_adt.did, found_adt.did);\n                 }\n@@ -796,7 +796,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n                 return Some(());\n             }\n-            if let &ty::Adt(def, _) = &ta.kind {\n+            if let &ty::Adt(def, _) = ta.kind() {\n                 let path_ = self.tcx.def_path_str(def.did);\n                 if path_ == other_path {\n                     self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n@@ -977,11 +977,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Compares two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n     fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n-        debug!(\"cmp(t1={}, t1.kind={:?}, t2={}, t2.kind={:?})\", t1, t1.kind, t2, t2.kind);\n+        debug!(\"cmp(t1={}, t1.kind={:?}, t2={}, t2.kind={:?})\", t1, t1.kind(), t2, t2.kind());\n \n         // helper functions\n         fn equals<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-            match (&a.kind, &b.kind) {\n+            match (a.kind(), b.kind()) {\n                 (a, b) if *a == *b => true,\n                 (&ty::Int(_), &ty::Infer(ty::InferTy::IntVar(_)))\n                 | (\n@@ -1014,7 +1014,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         // process starts here\n-        match (&t1.kind, &t2.kind) {\n+        match (t1.kind(), t2.kind()) {\n             (&ty::Adt(def1, sub1), &ty::Adt(def2, sub2)) => {\n                 let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n                 let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n@@ -1476,7 +1476,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             };\n             match (&terr, expected == found) {\n                 (TypeError::Sorts(values), extra) => {\n-                    let sort_string = |ty: Ty<'tcx>| match (extra, &ty.kind) {\n+                    let sort_string = |ty: Ty<'tcx>| match (extra, ty.kind()) {\n                         (true, ty::Opaque(def_id, _)) => format!(\n                             \" (opaque type at {})\",\n                             self.tcx\n@@ -1563,7 +1563,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             exp_span, exp_found.expected, exp_found.found\n         );\n \n-        if let ty::Opaque(def_id, _) = exp_found.expected.kind {\n+        if let ty::Opaque(def_id, _) = *exp_found.expected.kind() {\n             let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n             // Future::Output\n             let item_def_id = self\n@@ -1616,9 +1616,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         diag: &mut DiagnosticBuilder<'tcx>,\n     ) {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n-            (&exp_found.expected.kind, &exp_found.found.kind)\n+            (exp_found.expected.kind(), exp_found.found.kind())\n         {\n-            if let ty::Adt(found_def, found_substs) = found_ty.kind {\n+            if let ty::Adt(found_def, found_substs) = *found_ty.kind() {\n                 let path_str = format!(\"{:?}\", exp_def);\n                 if exp_def == &found_def {\n                     let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n@@ -1637,9 +1637,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     {\n                         let mut show_suggestion = true;\n                         for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n-                            match exp_ty.kind {\n+                            match *exp_ty.kind() {\n                                 ty::Ref(_, exp_ty, _) => {\n-                                    match (&exp_ty.kind, &found_ty.kind) {\n+                                    match (exp_ty.kind(), found_ty.kind()) {\n                                         (_, ty::Param(_))\n                                         | (_, ty::Infer(_))\n                                         | (ty::Param(_), _)\n@@ -1989,7 +1989,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n                 if let Some(infer::RelateParamBound(_, t)) = origin {\n                     let t = self.resolve_vars_if_possible(&t);\n-                    match t.kind {\n+                    match t.kind() {\n                         // We've got:\n                         // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n                         // suggest:\n@@ -2231,7 +2231,7 @@ impl TyCategory {\n     }\n \n     pub fn from_ty(ty: Ty<'_>) -> Option<(Self, DefId)> {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Closure(def_id, _) => Some((Self::Closure, def_id)),\n             ty::Opaque(def_id, _) => Some((Self::Opaque, def_id)),\n             ty::Generator(def_id, ..) => Some((Self::Generator, def_id)),"}, {"sha": "4de84e5ba399c2dd243a9c90040049933ebc01c7", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n                     inner == self.target\n                         || match (inner.unpack(), self.target.unpack()) {\n                             (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n-                                match (&inner_ty.kind, &target_ty.kind) {\n+                                match (inner_ty.kind(), target_ty.kind()) {\n                                     (\n                                         &ty::Infer(ty::TyVar(a_vid)),\n                                         &ty::Infer(ty::TyVar(b_vid)),\n@@ -222,7 +222,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n-        if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n+        if let ty::Infer(ty::TyVar(ty_vid)) = *ty.kind() {\n             let mut inner = self.inner.borrow_mut();\n             let ty_vars = &inner.type_variables();\n             let var_origin = ty_vars.var_origin(ty_vid);\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 None\n             };\n             printer.name_resolver = Some(Box::new(&getter));\n-            let _ = if let ty::FnDef(..) = ty.kind {\n+            let _ = if let ty::FnDef(..) = ty.kind() {\n                 // We don't want the regular output for `fn`s because it includes its path in\n                 // invalid pseudo-syntax, we want the `fn`-pointer output instead.\n                 ty.fn_sig(self.tcx).print(printer)\n@@ -336,7 +336,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let ty_msg = match (local_visitor.found_node_ty, local_visitor.found_exact_method_call) {\n             (_, Some(_)) => String::new(),\n-            (Some(ty::TyS { kind: ty::Closure(_, substs), .. }), _) => {\n+            (Some(ty), _) if ty.is_closure() => {\n+                let substs =\n+                    if let ty::Closure(_, substs) = *ty.kind() { substs } else { unreachable!() };\n                 let fn_sig = substs.as_closure().sig();\n                 let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n@@ -370,7 +372,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n \n         let suffix = match local_visitor.found_node_ty {\n-            Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n+            Some(ty) if ty.is_closure() => {\n+                let substs =\n+                    if let ty::Closure(_, substs) = *ty.kind() { substs } else { unreachable!() };\n                 let fn_sig = substs.as_closure().sig();\n                 let ret = fn_sig.output().skip_binder().to_string();\n \n@@ -612,7 +616,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let bound_output = sig.output();\n                     let output = bound_output.skip_binder();\n                     err.span_label(e.span, &format!(\"this method call resolves to `{}`\", output));\n-                    let kind = &output.kind;\n+                    let kind = output.kind();\n                     if let ty::Projection(proj) = kind {\n                         if let Some(span) = self.tcx.hir().span_if_local(proj.item_def_id) {\n                             err.span_label(span, &format!(\"`{}` defined here\", output));"}, {"sha": "975b9d4f0863140a4187066f0f178139cc5167fe", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -465,7 +465,7 @@ struct TraitObjectVisitor(Vec<DefId>);\n \n impl TypeVisitor<'_> for TraitObjectVisitor {\n     fn visit_ty(&mut self, t: Ty<'_>) -> bool {\n-        match t.kind {\n+        match t.kind() {\n             ty::Dynamic(preds, RegionKind::ReStatic) => {\n                 if let Some(def_id) = preds.principal_def_id() {\n                     self.0.push(def_id);"}, {"sha": "c055fed43f6d52f643a05f9f263b2f92054fe4d7", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         decl: &hir::FnDecl<'_>,\n     ) -> Option<Span> {\n         let ret_ty = self.tcx().type_of(scope_def_id);\n-        if let ty::FnDef(_, _) = ret_ty.kind {\n+        if let ty::FnDef(_, _) = ret_ty.kind() {\n             let sig = ret_ty.fn_sig(self.tcx());\n             let late_bound_regions =\n                 self.tcx().collect_referenced_late_bound_regions(&sig.output());"}, {"sha": "b3d7876c6e81922c91e25ea4ea10bd911b2cdd40", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -144,7 +144,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         let tcx = self.infcx.tcx;\n \n-        match t.kind {\n+        match *t.kind() {\n             ty::Infer(ty::TyVar(v)) => {\n                 let opt_ty = self.infcx.inner.borrow_mut().type_variables().probe(v).known();\n                 self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)"}, {"sha": "d7bc636db8f8f30bc64a88a8785d8ae8b696f6cd", "filename": "compiler/rustc_infer/src/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffudge.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Infer(ty::InferTy::TyVar(vid)) => {\n                 if self.type_vars.0.contains(&vid) {\n                     // This variable was created during the fudging."}, {"sha": "c47d476963772e2adda260bca51b6a4f3e1f1c97", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -58,7 +58,7 @@ where\n     let infcx = this.infcx();\n     let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n     let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n-    match (&a.kind, &b.kind) {\n+    match (a.kind(), b.kind()) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to\n         // relate `v` to the non-type-variable first (by passing it"}, {"sha": "685d2bac94ee37af716ce6b7606dec726b2482e5", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -680,7 +680,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Infer(ty::TyVar(vid)) => self.inner.borrow_mut().type_variables().var_diverges(vid),\n             _ => false,\n         }\n@@ -693,7 +693,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n         use rustc_middle::ty::error::UnconstrainedNumeric::Neither;\n         use rustc_middle::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Infer(ty::IntVar(vid)) => {\n                 if self.inner.borrow_mut().int_unification_table().probe_value(vid).is_some() {\n                     Neither\n@@ -1557,7 +1557,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// not a type variable, just return it unmodified.\n     // FIXME(eddyb) inline into `ShallowResolver::visit_ty`.\n     fn shallow_resolve_ty(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match typ.kind {\n+        match *typ.kind() {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n                 // it can be resolved to an int/float variable, which\n@@ -1677,7 +1677,7 @@ impl TyOrConstInferVar<'tcx> {\n     /// Tries to extract an inference variable from a type, returns `None`\n     /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`).\n     pub fn maybe_from_ty(ty: Ty<'tcx>) -> Option<Self> {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Infer(ty::TyVar(v)) => Some(TyOrConstInferVar::Ty(v)),\n             ty::Infer(ty::IntVar(v)) => Some(TyOrConstInferVar::TyInt(v)),\n             ty::Infer(ty::FloatVar(v)) => Some(TyOrConstInferVar::TyFloat(v)),"}, {"sha": "839891f322c81ffffbe8ea307fec8af50c8af183", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -265,7 +265,7 @@ where\n         use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n         use rustc_span::DUMMY_SP;\n \n-        match value_ty.kind {\n+        match *value_ty.kind() {\n             ty::Projection(other_projection_ty) => {\n                 let var = self.infcx.next_ty_var(TypeVariableOrigin {\n                     kind: TypeVariableOriginKind::MiscVariable,\n@@ -311,7 +311,7 @@ where\n         // This only presently applies to chalk integration, as NLL\n         // doesn't permit type variables to appear on both sides (and\n         // doesn't use lazy norm).\n-        match value_ty.kind {\n+        match *value_ty.kind() {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n                 self.infcx.inner.borrow_mut().type_variables().equate(vid, value_vid);\n@@ -531,7 +531,7 @@ where\n             }\n         }\n \n-        match (&a.kind, &b.kind) {\n+        match (a.kind(), b.kind()) {\n             (_, &ty::Infer(ty::TyVar(vid))) => {\n                 if D::forbid_inference_vars() {\n                     // Forbid inference variables in the RHS.\n@@ -868,7 +868,7 @@ where\n \n         debug!(\"TypeGeneralizer::tys(a={:?})\", a);\n \n-        match a.kind {\n+        match *a.kind() {\n             ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n                 if D::forbid_inference_vars() =>\n             {"}, {"sha": "2851da89ab2db0359294e5305669ac0eacedae91", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -383,7 +383,7 @@ where\n         // #55756) in cases where you have e.g., `<T as Foo<'a>>::Item:\n         // 'a` in the environment but `trait Foo<'b> { type Item: 'b\n         // }` in the trait definition.\n-        approx_env_bounds.retain(|bound| match bound.0.kind {\n+        approx_env_bounds.retain(|bound| match *bound.0.kind() {\n             ty::Projection(projection_ty) => self\n                 .verify_bound\n                 .projection_declared_bounds_from_trait(projection_ty)"}, {"sha": "d6f1ca3cf95360bc1ccb8df8ddfe1c35a2ec527b", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -38,7 +38,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     }\n \n     fn type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Param(p) => self.param_bound(p),\n             ty::Projection(data) => self.projection_bound(data),\n             ty::FnDef(_, substs) => {\n@@ -118,7 +118,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         let projection_ty = GenericKind::Projection(projection_ty).to_ty(self.tcx);\n         let erased_projection_ty = self.tcx.erase_regions(&projection_ty);\n         self.declared_generic_bounds_from_env_with_compare_fn(|ty| {\n-            if let ty::Projection(..) = ty.kind {\n+            if let ty::Projection(..) = ty.kind() {\n                 let erased_ty = self.tcx.erase_regions(&ty);\n                 erased_ty == erased_projection_ty\n             } else {"}, {"sha": "337772d70b8231011ad5892f9bd1132f7234d684", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {\n-            if let ty::Infer(infer_ty) = t.kind {\n+            if let ty::Infer(infer_ty) = *t.kind() {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n-            match t.kind {\n+            match *t.kind() {\n                 ty::Infer(ty::TyVar(vid)) => {\n                     self.err = Some(FixupError::UnresolvedTy(vid));\n                     self.tcx().ty_error()"}, {"sha": "a676c5e65a73bb84bd9e3d9bf68ed086f479ad98", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -83,7 +83,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         let infcx = self.fields.infcx;\n         let a = infcx.inner.borrow_mut().type_variables().replace_if_possible(a);\n         let b = infcx.inner.borrow_mut().type_variables().replace_if_possible(b);\n-        match (&a.kind, &b.kind) {\n+        match (a.kind(), b.kind()) {\n             (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental"}, {"sha": "35b97fff3da1f0866b2f1140c83421cb47f2fc2b", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -306,7 +306,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n     /// instantiated, then return the with which it was\n     /// instantiated. Otherwise, returns `t`.\n     pub fn replace_if_possible(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind {\n+        match *t.kind() {\n             ty::Infer(ty::TyVar(v)) => match self.probe(v) {\n                 TypeVariableValue::Unknown { .. } => t,\n                 TypeVariableValue::Known { value } => value,"}, {"sha": "1d27bdcb28261d7e26cf270353ded50675343910", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             }\n \n             // Make sure we found an array after peeling the boxes.\n-            if !matches!(recv_ty.kind, ty::Array(..)) {\n+            if !matches!(recv_ty.kind(), ty::Array(..)) {\n                 return;\n             }\n \n@@ -66,9 +66,9 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             }\n \n             // Emit lint diagnostic.\n-            let target = match cx.typeck_results().expr_ty_adjusted(receiver_arg).kind {\n-                ty::Ref(_, ty::TyS { kind: ty::Array(..), .. }, _) => \"[T; N]\",\n-                ty::Ref(_, ty::TyS { kind: ty::Slice(..), .. }, _) => \"[T]\",\n+            let target = match *cx.typeck_results().expr_ty_adjusted(receiver_arg).kind() {\n+                ty::Ref(_, inner_ty, _) if inner_ty.is_array() => \"[T; N]\",\n+                ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), ty::Slice(..)) => \"[T]\",\n \n                 // We know the original first argument type is an array type,\n                 // we know that the first adjustment was an autoref coercion"}, {"sha": "d18d89ed641b2666c2a903eb062ce60f2f6f9fff", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -893,7 +893,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n         if let Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) =\n-            get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind))\n+            get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n             if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n                 let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n@@ -1940,13 +1940,13 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             init: InitKind,\n         ) -> Option<InitError> {\n             use rustc_middle::ty::TyKind::*;\n-            match ty.kind {\n+            match ty.kind() {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((\"references must be non-null\".to_string(), None)),\n                 Adt(..) if ty.is_box() => Some((\"`Box` must be non-null\".to_string(), None)),\n                 FnPtr(..) => Some((\"function pointers must be non-null\".to_string(), None)),\n                 Never => Some((\"the `!` type has no valid value\".to_string(), None)),\n-                RawPtr(tm) if matches!(tm.ty.kind, Dynamic(..)) =>\n+                RawPtr(tm) if matches!(tm.ty.kind(), Dynamic(..)) =>\n                 // raw ptr to dyn Trait\n                 {\n                     Some((\"the vtable of a wide raw pointer must be non-null\".to_string(), None))\n@@ -2173,7 +2173,7 @@ impl ClashingExternDeclarations {\n             let non_transparent_ty = |ty: Ty<'tcx>| -> Ty<'tcx> {\n                 let mut ty = ty;\n                 loop {\n-                    if let ty::Adt(def, substs) = ty.kind {\n+                    if let ty::Adt(def, substs) = *ty.kind() {\n                         let is_transparent = def.subst(tcx, substs).repr.transparent();\n                         let is_non_null = crate::types::nonnull_optimization_guaranteed(tcx, &def);\n                         debug!(\n@@ -2212,8 +2212,8 @@ impl ClashingExternDeclarations {\n             } else {\n                 // Do a full, depth-first comparison between the two.\n                 use rustc_middle::ty::TyKind::*;\n-                let a_kind = &a.kind;\n-                let b_kind = &b.kind;\n+                let a_kind = a.kind();\n+                let b_kind = b.kind();\n \n                 let compare_layouts = |a, b| -> Result<bool, LayoutError<'tcx>> {\n                     debug!(\"compare_layouts({:?}, {:?})\", a, b);\n@@ -2335,7 +2335,7 @@ impl ClashingExternDeclarations {\n                             if is_primitive_or_pointer(other_kind) =>\n                         {\n                             let (primitive, adt) =\n-                                if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                                if is_primitive_or_pointer(a.kind()) { (a, b) } else { (b, a) };\n                             if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n                                 ty == primitive\n                             } else {"}, {"sha": "f0342b69c9261158fc9214802b645c367903625c", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -790,7 +790,7 @@ impl<'tcx> LateContext<'tcx> {\n                 trait_ref: Option<ty::TraitRef<'tcx>>,\n             ) -> Result<Self::Path, Self::Error> {\n                 if trait_ref.is_none() {\n-                    if let ty::Adt(def, substs) = self_ty.kind {\n+                    if let ty::Adt(def, substs) = self_ty.kind() {\n                         return self.print_def_path(def.did, substs);\n                     }\n                 }"}, {"sha": "af32c16bfe8dd9a6fcb81ab7e36aa8d8c05ca860", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -217,7 +217,7 @@ fn get_type_suggestion(t: Ty<'_>, val: u128, negative: bool) -> Option<&'static\n             }\n         }\n     }\n-    match t.kind {\n+    match t.kind() {\n         ty::Int(i) => find_fit!(i, val, negative,\n                       I8 => [U8] => [I16, I32, I64, I128],\n                       I16 => [U16] => [I32, I64, I128],\n@@ -303,7 +303,7 @@ fn lint_uint_literal<'tcx>(\n         if let Node::Expr(par_e) = cx.tcx.hir().get(parent_id) {\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n-                    if let ty::Char = cx.typeck_results().expr_ty(par_e).kind {\n+                    if let ty::Char = cx.typeck_results().expr_ty(par_e).kind() {\n                         cx.struct_span_lint(OVERFLOWING_LITERALS, par_e.span, |lint| {\n                             lint.build(\"only `u8` can be cast into `char`\")\n                                 .span_suggestion(\n@@ -354,7 +354,7 @@ fn lint_literal<'tcx>(\n     e: &'tcx hir::Expr<'tcx>,\n     lit: &hir::Lit,\n ) {\n-    match cx.typeck_results().node_type(e.hir_id).kind {\n+    match *cx.typeck_results().node_type(e.hir_id).kind() {\n         ty::Int(t) => {\n             match lit.node {\n                 ast::LitKind::Int(v, ast::LitIntType::Signed(_) | ast::LitIntType::Unsuffixed) => {\n@@ -450,7 +450,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match cx.typeck_results().node_type(expr.hir_id).kind {\n+            match *cx.typeck_results().node_type(expr.hir_id).kind() {\n                 ty::Int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.kind {\n@@ -536,7 +536,7 @@ crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: &ty::AdtD\n /// Is type known to be non-null?\n crate fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n     let tcx = cx.tcx;\n-    match ty.kind {\n+    match ty.kind() {\n         ty::FnPtr(_) => true,\n         ty::Ref(..) => true,\n         ty::Adt(def, _) if def.is_box() && matches!(mode, CItemKind::Definition) => true,\n@@ -565,7 +565,7 @@ crate fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: C\n /// If the type passed in was not scalar, returns None.\n fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     let tcx = cx.tcx;\n-    Some(match ty.kind {\n+    Some(match *ty.kind() {\n         ty::Adt(field_def, field_substs) => {\n             let inner_field_ty = {\n                 let first_non_zst_ty =\n@@ -617,7 +617,7 @@ crate fn repr_nullable_ptr<'tcx>(\n     ckind: CItemKind,\n ) -> Option<Ty<'tcx>> {\n     debug!(\"is_repr_nullable_ptr(cx, ty = {:?})\", ty);\n-    if let ty::Adt(ty_def, substs) = ty.kind {\n+    if let ty::Adt(ty_def, substs) = ty.kind() {\n         if ty_def.variants.len() != 2 {\n             return None;\n         }\n@@ -667,7 +667,7 @@ crate fn repr_nullable_ptr<'tcx>(\n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the type is array and emit an unsafe type lint.\n     fn check_for_array_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n-        if let ty::Array(..) = ty.kind {\n+        if let ty::Array(..) = ty.kind() {\n             self.emit_ffi_unsafe_type_lint(\n                 ty,\n                 sp,\n@@ -755,7 +755,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             return FfiSafe;\n         }\n \n-        match ty.kind {\n+        match ty.kind() {\n             ty::Adt(def, _) if def.is_box() && matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n@@ -994,7 +994,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 diag.help(help);\n             }\n             diag.note(note);\n-            if let ty::Adt(def, _) = ty.kind {\n+            if let ty::Adt(def, _) = ty.kind() {\n                 if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n                     diag.span_note(sp, \"the type is defined here\");\n                 }\n@@ -1011,7 +1011,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         impl<'a, 'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'a, 'tcx> {\n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-                match ty.kind {\n+                match ty.kind() {\n                     ty::Opaque(..) => {\n                         self.ty = Some(ty);\n                         true"}, {"sha": "0c06b063e41fa0958058ace160a8c585e4f8375d", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -135,7 +135,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n \n             let plural_suffix = pluralize!(plural_len);\n \n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Adt(..) if ty.is_box() => {\n                     let boxed_ty = ty.boxed_ty();\n                     let descr_pre = &format!(\"{}boxed \", descr_pre);"}, {"sha": "deca80f590f2fecc58f168d747b2089b6238f032", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -1418,7 +1418,7 @@ impl EncodeContext<'a, 'tcx> {\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = self.tcx.typeck(def_id).node_type(hir_id);\n \n-        record!(self.tables.kind[def_id.to_def_id()] <- match ty.kind {\n+        record!(self.tables.kind[def_id.to_def_id()] <- match ty.kind() {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n                 EntryKind::Generator(data)\n@@ -1432,7 +1432,7 @@ impl EncodeContext<'a, 'tcx> {\n         record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id.to_def_id()] <- &self.tcx.get_attrs(def_id.to_def_id())[..]);\n         self.encode_item_type(def_id.to_def_id());\n-        if let ty::Closure(def_id, substs) = ty.kind {\n+        if let ty::Closure(def_id, substs) = *ty.kind() {\n             record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n         self.encode_generics(def_id.to_def_id());"}, {"sha": "1181ba6bbf9466ccf64b59207e351707ebd97910", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -2482,7 +2482,7 @@ impl<'tcx> Debug for Constant<'tcx> {\n \n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        match self.literal.ty.kind {\n+        match self.literal.ty.kind() {\n             ty::FnDef(..) => {}\n             _ => write!(fmt, \"const \")?,\n         }"}, {"sha": "b9e4f6fb12eb1dc4cdf705dcb697df5a9f9e6aaa", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     ///\n     /// Note that the resulting type has not been normalized.\n     pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: &Field) -> Ty<'tcx> {\n-        let answer = match self.ty.kind {\n+        let answer = match self.ty.kind() {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n                     None => adt_def.non_enum_variant(),\n@@ -90,7 +90,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                 PlaceTy::from_ty(self.ty.builtin_index().unwrap())\n             }\n             ProjectionElem::Subslice { from, to, from_end } => {\n-                PlaceTy::from_ty(match self.ty.kind {\n+                PlaceTy::from_ty(match self.ty.kind() {\n                     ty::Slice(..) => self.ty,\n                     ty::Array(inner, _) if !from_end => tcx.mk_array(inner, (to - from) as u64),\n                     ty::Array(inner, size) if from_end => {"}, {"sha": "ffa6e6f53241ecc15d6ac75db6199df545973c82", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's\n         // execution."}, {"sha": "27bccc0bcafa4a1bbd8efc65d50e176b60613f06", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -67,7 +67,7 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n             return Ok(a);\n         }\n \n-        match (&a.kind, &b.kind) {\n+        match (a.kind(), b.kind()) {\n             (\n                 _,\n                 &ty::Infer(ty::FreshTy(_))"}, {"sha": "b47d9c50e1d0aa14b22a7864b232f5b2a2480159", "filename": "compiler/rustc_middle/src/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcast.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> CastTy<'tcx> {\n     /// Returns `Some` for integral/pointer casts.\n     /// casts like unsizing casts will return `None`\n     pub fn from_ty(t: Ty<'tcx>) -> Option<CastTy<'tcx>> {\n-        match t.kind {\n+        match *t.kind() {\n             ty::Bool => Some(CastTy::Int(IntTy::Bool)),\n             ty::Char => Some(CastTy::Int(IntTy::Char)),\n             ty::Int(_) => Some(CastTy::Int(IntTy::I)),"}, {"sha": "e2e5f08462f7231139c30befcf0201f0c146e559", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -36,8 +36,10 @@ pub trait EncodableWithShorthand<'tcx, E: TyEncoder<'tcx>>: Copy + Eq + Hash {\n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n+\n+    #[inline]\n     fn variant(&self) -> &Self::Variant {\n-        &self.kind\n+        self.kind()\n     }\n }\n "}, {"sha": "aa34dedc4b286b74b02fc5e905e820b7675acc94", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -759,10 +759,10 @@ impl CanonicalUserType<'tcx> {\n \n                 user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n                     match kind.unpack() {\n-                        GenericArgKind::Type(ty) => match ty.kind {\n+                        GenericArgKind::Type(ty) => match ty.kind() {\n                             ty::Bound(debruijn, b) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n-                                assert_eq!(debruijn, ty::INNERMOST);\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n                                 cvar == b.var\n                             }\n                             _ => false,\n@@ -1498,7 +1498,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         let ret_ty = self.type_of(scope_def_id);\n-        match ret_ty.kind {\n+        match ret_ty.kind() {\n             ty::FnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(*self);\n                 let output = self.erase_late_bound_regions(&sig.output());\n@@ -1822,15 +1822,15 @@ macro_rules! sty_debug_print {\n                 let shards = tcx.interners.type_.lock_shards();\n                 let types = shards.iter().flat_map(|shard| shard.keys());\n                 for &Interned(t) in types {\n-                    let variant = match t.kind {\n+                    let variant = match t.kind() {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n                         ty::Error(_) => /* unimportant */ continue,\n                         $(ty::$variant(..) => &mut $variant,)*\n                     };\n-                    let lt = t.flags.intersects(ty::TypeFlags::HAS_RE_INFER);\n-                    let ty = t.flags.intersects(ty::TypeFlags::HAS_TY_INFER);\n-                    let ct = t.flags.intersects(ty::TypeFlags::HAS_CT_INFER);\n+                    let lt = t.flags().intersects(ty::TypeFlags::HAS_RE_INFER);\n+                    let ty = t.flags().intersects(ty::TypeFlags::HAS_TY_INFER);\n+                    let ct = t.flags().intersects(ty::TypeFlags::HAS_CT_INFER);\n \n                     variant.total += 1;\n                     total.total += 1;\n@@ -1931,22 +1931,22 @@ impl<'tcx, T: 'tcx + ?Sized> IntoPointer for Interned<'tcx, T> {\n // N.B., an `Interned<Ty>` compares and hashes as a `TyKind`.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n-        self.0.kind == other.0.kind\n+        self.0.kind() == other.0.kind()\n     }\n }\n \n impl<'tcx> Eq for Interned<'tcx, TyS<'tcx>> {}\n \n impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.0.kind.hash(s)\n+        self.0.kind().hash(s)\n     }\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Borrow<TyKind<'tcx>> for Interned<'tcx, TyS<'tcx>> {\n     fn borrow<'a>(&'a self) -> &'a TyKind<'tcx> {\n-        &self.0.kind\n+        &self.0.kind()\n     }\n }\n // N.B., an `Interned<PredicateInner>` compares and hashes as a `PredicateKind`.\n@@ -2086,7 +2086,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         unsafety: hir::Unsafety,\n     ) -> PolyFnSig<'tcx> {\n         sig.map_bound(|s| {\n-            let params_iter = match s.inputs()[0].kind {\n+            let params_iter = match s.inputs()[0].kind() {\n                 ty::Tuple(params) => params.into_iter().map(|k| k.expect_ty()),\n                 _ => bug!(),\n             };"}, {"sha": "bc51c8b6cd41c6e1b3f9054678d9987d29f7d471", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n impl<'tcx> TyS<'tcx> {\n     /// Similar to `TyS::is_primitive`, but also considers inferred numeric values to be primitive.\n     pub fn is_primitive_ty(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Bool\n             | Char\n             | Str\n@@ -31,7 +31,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Whether the type is succinctly representable as a type instead of just referred to with a\n     /// description in error messages. This is used in the main error message.\n     pub fn is_simple_ty(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Bool\n             | Char\n             | Str\n@@ -55,7 +55,7 @@ impl<'tcx> TyS<'tcx> {\n     /// `is_simple_ty` includes, it also accepts ADTs with no type arguments and references to\n     /// ADTs with no type arguments.\n     pub fn is_simple_text(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Adt(_, substs) => substs.types().next().is_none(),\n             Ref(_, ty, _) => ty.is_simple_text(),\n             _ => self.is_simple_ty(),\n@@ -64,7 +64,7 @@ impl<'tcx> TyS<'tcx> {\n \n     /// Whether the type can be safely suggested during error recovery.\n     pub fn is_suggestable(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Opaque(..) | FnDef(..) | FnPtr(..) | Dynamic(..) | Closure(..) | Infer(..)\n             | Projection(..) => false,\n             _ => true,"}, {"sha": "7226a906e5c979c12166736d3a6a98b2a7d71f15", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -218,7 +218,7 @@ impl<'tcx> TypeError<'tcx> {\n \n impl<'tcx> ty::TyS<'tcx> {\n     pub fn sort_string(&self, tcx: TyCtxt<'_>) -> Cow<'static, str> {\n-        match self.kind {\n+        match *self.kind() {\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => {\n                 format!(\"`{}`\", self).into()\n             }\n@@ -282,7 +282,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn prefix_string(&self) -> Cow<'static, str> {\n-        match self.kind {\n+        match *self.kind() {\n             ty::Infer(_)\n             | ty::Error(_)\n             | ty::Bool\n@@ -351,7 +351,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         );\n                     }\n                 }\n-                match (&values.expected.kind, &values.found.kind) {\n+                match (values.expected.kind(), values.found.kind()) {\n                     (ty::Float(_), ty::Infer(ty::IntVar(_))) => {\n                         if let Ok(\n                             // Issue #53280\n@@ -512,7 +512,10 @@ impl<T> Trait<T> for X {\n                 }\n                 debug!(\n                     \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n-                    values.expected, values.expected.kind, values.found, values.found.kind,\n+                    values.expected,\n+                    values.expected.kind(),\n+                    values.found,\n+                    values.found.kind(),\n                 );\n             }\n             CyclicTy(ty) => {\n@@ -556,7 +559,7 @@ impl<T> Trait<T> for X {\n             if let Some(hir_generics) = item.generics() {\n                 // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n                 // This will also work for `impl Trait`.\n-                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind {\n+                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n                     let generics = self.generics_of(body_owner_def_id);\n                     generics.type_param(&param_ty, *self).def_id\n                 } else {\n@@ -680,7 +683,7 @@ impl<T> Trait<T> for X {\n             }\n         }\n \n-        if let ty::Opaque(def_id, _) = proj_ty.self_ty().kind {\n+        if let ty::Opaque(def_id, _) = *proj_ty.self_ty().kind() {\n             // When the expected `impl Trait` is not defined in the current item, it will come from\n             // a return type. This can occur when dealing with `TryStream` (#71035).\n             if self.constrain_associated_type_structured_suggestion(\n@@ -750,7 +753,7 @@ fn foo(&self) -> Self::T { String::new() }\n             })\n             .filter_map(|(_, item)| {\n                 let method = self.fn_sig(item.def_id);\n-                match method.output().skip_binder().kind {\n+                match *method.output().skip_binder().kind() {\n                     ty::Projection(ty::ProjectionTy { item_def_id, .. })\n                         if item_def_id == proj_ty_item_def_id =>\n                     {"}, {"sha": "860f91db2bf7aef105e8f2e5d144cd33f3677f5f", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -60,7 +60,7 @@ pub fn simplify_type(\n     ty: Ty<'_>,\n     can_simplify_params: bool,\n ) -> Option<SimplifiedType> {\n-    match ty.kind {\n+    match *ty.kind() {\n         ty::Bool => Some(BoolSimplifiedType),\n         ty::Char => Some(CharSimplifiedType),\n         ty::Int(int_type) => Some(IntSimplifiedType(int_type)),"}, {"sha": "f7871c4fffddbb76154d3102c1f94aa05b0f7c51", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -253,7 +253,7 @@ impl FlagComputation {\n     }\n \n     fn add_ty(&mut self, ty: Ty<'_>) {\n-        self.add_flags(ty.flags);\n+        self.add_flags(ty.flags());\n         self.add_exclusive_binder(ty.outer_exclusive_binder);\n     }\n "}, {"sha": "5e8fb95dc298567c0943fbffb45e8cc5afe78eff", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -352,7 +352,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n                 // We're only interested in types involving regions\n-                if ty.flags.intersects(TypeFlags::HAS_FREE_REGIONS) {\n+                if ty.flags().intersects(TypeFlags::HAS_FREE_REGIONS) {\n                     ty.super_visit_with(self)\n                 } else {\n                     false // keep visiting\n@@ -471,7 +471,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind {\n+        match *t.kind() {\n             ty::Bound(debruijn, bound_ty) => {\n                 if debruijn == self.current_index {\n                     let fld_t = &mut self.fld_t;\n@@ -771,7 +771,7 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Bound(debruijn, bound_ty) => {\n                 if self.amount == 0 || debruijn < self.current_index {\n                     ty\n@@ -922,8 +922,13 @@ struct HasTypeFlagsVisitor {\n \n impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     fn visit_ty(&mut self, t: Ty<'_>) -> bool {\n-        debug!(\"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\", t, t.flags, self.flags);\n-        t.flags.intersects(self.flags)\n+        debug!(\n+            \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n+            t,\n+            t.flags(),\n+            self.flags\n+        );\n+        t.flags().intersects(self.flags)\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n@@ -987,7 +992,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // ignore the inputs to a projection, as they may not appear\n         // in the normalized form\n         if self.just_constrained {\n-            if let ty::Projection(..) | ty::Opaque(..) = t.kind {\n+            if let ty::Projection(..) | ty::Opaque(..) = t.kind() {\n                 return false;\n             }\n         }"}, {"sha": "2c1179c21fb6a801423476a9551022305450dae6", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -196,7 +196,7 @@ impl<'tcx> FieldDef {\n impl<'tcx> TyS<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> DefIdForest {\n-        match self.kind {\n+        match *self.kind() {\n             Adt(def, substs) => {\n                 ensure_sufficient_stack(|| def.uninhabited_from(tcx, substs, param_env))\n             }"}, {"sha": "b0a1413a9d62fb1e369aa92299372356e60d168e", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -495,7 +495,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n         debug_assert!(!ty.has_infer_types_or_consts());\n \n-        Ok(match ty.kind {\n+        Ok(match *ty.kind() {\n             // Basic scalars.\n             ty::Bool => tcx.intern_layout(Layout::scalar(\n                 self,\n@@ -540,7 +540,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n \n                 let unsized_part = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n-                let metadata = match unsized_part.kind {\n+                let metadata = match unsized_part.kind() {\n                     ty::Foreign(..) => {\n                         return Ok(tcx.intern_layout(Layout::scalar(self, data_ptr)));\n                     }\n@@ -1624,7 +1624,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             );\n         };\n \n-        let adt_def = match layout.ty.kind {\n+        let adt_def = match *layout.ty.kind() {\n             ty::Adt(ref adt_def, _) => {\n                 debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n                 adt_def\n@@ -1767,11 +1767,11 @@ impl<'tcx> SizeSkeleton<'tcx> {\n             Err(err) => err,\n         };\n \n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Ref(_, pointee, _) | ty::RawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n-                match tail.kind {\n+                match tail.kind() {\n                     ty::Param(_) | ty::Projection(_) => {\n                         debug_assert!(tail.has_param_types_or_consts());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(&tail) })\n@@ -2018,7 +2018,7 @@ where\n                     assert_eq!(original_layout.variants, Variants::Single { index });\n                 }\n \n-                let fields = match this.ty.kind {\n+                let fields = match this.ty.kind() {\n                     ty::Adt(def, _) if def.variants.is_empty() =>\n                         bug!(\"for_variant called on zero-variant enum\"),\n                     ty::Adt(def, _) => def.variants[variant_index].fields.len(),\n@@ -2056,7 +2056,7 @@ where\n             }))\n         };\n \n-        cx.layout_of(match this.ty.kind {\n+        cx.layout_of(match *this.ty.kind() {\n             ty::Bool\n             | ty::Char\n             | ty::Int(_)\n@@ -2092,7 +2092,7 @@ where\n                     ));\n                 }\n \n-                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind {\n+                match tcx.struct_tail_erasing_lifetimes(pointee, cx.param_env()).kind() {\n                     ty::Slice(_) | ty::Str => tcx.types.usize,\n                     ty::Dynamic(_, _) => {\n                         tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_array(tcx.types.usize, 3))\n@@ -2170,7 +2170,7 @@ where\n             if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n         };\n \n-        let pointee_info = match this.ty.kind {\n+        let pointee_info = match *this.ty.kind() {\n             ty::RawPtr(mt) if offset.bytes() == 0 => {\n                 cx.layout_of(mt.ty).to_result().ok().map(|layout| PointeeInfo {\n                     size: layout.size,\n@@ -2286,7 +2286,7 @@ where\n \n                 // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n                 if let Some(ref mut pointee) = result {\n-                    if let ty::Adt(def, _) = this.ty.kind {\n+                    if let ty::Adt(def, _) = this.ty.kind() {\n                         if def.is_box() && offset.bytes() == 0 {\n                             pointee.safe = Some(PointerKind::UniqueOwned);\n                         }\n@@ -2299,7 +2299,9 @@ where\n \n         debug!(\n             \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\",\n-            offset, this.ty.kind, pointee_info\n+            offset,\n+            this.ty.kind(),\n+            pointee_info\n         );\n \n         pointee_info\n@@ -2326,14 +2328,14 @@ impl<'tcx> ty::Instance<'tcx> {\n     fn fn_sig_for_fn_abi(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n         let ty = self.ty(tcx, ty::ParamEnv::reveal_all());\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::FnDef(..) => {\n                 // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n                 // parameters unused if they show up in the signature, but not in the `mir::Body`\n                 // (i.e. due to being inside a projection that got normalized, see\n                 // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n                 // track of a polymorphization `ParamEnv` to allow normalizing later.\n-                let mut sig = match ty.kind {\n+                let mut sig = match *ty.kind() {\n                     ty::FnDef(def_id, substs) => tcx\n                         .normalize_erasing_regions(tcx.param_env(def_id), tcx.fn_sig(def_id))\n                         .subst(tcx, substs),\n@@ -2596,7 +2598,7 @@ where\n             assert!(!sig.c_variadic && extra_args.is_empty());\n \n             if let Some(input) = sig.inputs().last() {\n-                if let ty::Tuple(tupled_arguments) = input.kind {\n+                if let ty::Tuple(tupled_arguments) = input.kind() {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n                     tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n                 } else {"}, {"sha": "29fa3f9bb65e05c5824a6141fdaab2fc6c3caa7e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -580,8 +580,12 @@ bitflags! {\n \n #[allow(rustc::usage_of_ty_tykind)]\n pub struct TyS<'tcx> {\n-    pub kind: TyKind<'tcx>,\n-    pub flags: TypeFlags,\n+    /// This field shouldn't be used directly and may be removed in the future.\n+    /// Use `TyS::kind()` instead.\n+    kind: TyKind<'tcx>,\n+    /// This field shouldn't be used directly and may be removed in the future.\n+    /// Use `TyS::flags()` instead.\n+    flags: TypeFlags,\n \n     /// This is a kind of confusing thing: it stores the smallest\n     /// binder such that\n@@ -609,13 +613,13 @@ static_assert_size!(TyS<'_>, 32);\n \n impl<'tcx> Ord for TyS<'tcx> {\n     fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n-        self.kind.cmp(&other.kind)\n+        self.kind().cmp(other.kind())\n     }\n }\n \n impl<'tcx> PartialOrd for TyS<'tcx> {\n     fn partial_cmp(&self, other: &TyS<'tcx>) -> Option<Ordering> {\n-        Some(self.kind.cmp(&other.kind))\n+        Some(self.kind().cmp(other.kind()))\n     }\n }\n "}, {"sha": "783f116a87d385ecc7786c464ebc0c013da8443b", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -61,7 +61,7 @@ fn compute_components(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, out: &mut SmallVec<[Compo\n     // with `collect()` because of the need to sometimes skip subtrees\n     // in the `subtys` iterator (e.g., when encountering a\n     // projection).\n-    match ty.kind {\n+    match *ty.kind() {\n             ty::FnDef(_, substs) => {\n                 // HACK(eddyb) ignore lifetimes found shallowly in `substs`.\n                 // This is inconsistent with `ty::Adt` (including all substs)"}, {"sha": "709a4018d809c66b8544b75f40c2312412883f43", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -264,7 +264,7 @@ pub trait Printer<'tcx>: Sized {\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n-    match ty.kind {\n+    match *ty.kind() {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n \n         ty::Dynamic(data, ..) => data.principal_def_id(),"}, {"sha": "538c07b9bde5ff46c1ebc01535731a1ff2634f92", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -457,7 +457,7 @@ pub trait PrettyPrinter<'tcx>:\n             // Inherent impls. Try to print `Foo::bar` for an inherent\n             // impl on `Foo`, but fallback to `<Foo>::bar` if self-type is\n             // anything other than a simple path.\n-            match self_ty.kind {\n+            match self_ty.kind() {\n                 ty::Adt(..)\n                 | ty::Foreign(_)\n                 | ty::Bool\n@@ -508,7 +508,7 @@ pub trait PrettyPrinter<'tcx>:\n     fn pretty_print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n         define_scoped_cx!(self);\n \n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Bool => p!(write(\"bool\")),\n             ty::Char => p!(write(\"char\")),\n             ty::Int(t) => p!(write(\"{}\", t.name_str())),\n@@ -797,7 +797,7 @@ pub trait PrettyPrinter<'tcx>:\n             // Special-case `Fn(...) -> ...` and resugar it.\n             let fn_trait_kind = self.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n             if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n-                if let ty::Tuple(ref args) = principal.substs.type_at(0).kind {\n+                if let ty::Tuple(ref args) = principal.substs.type_at(0).kind() {\n                     let mut projections = predicates.projection_bounds();\n                     if let (Some(proj), None) = (projections.next(), projections.next()) {\n                         let tys: Vec<_> = args.iter().map(|k| k.expect_ty()).collect();\n@@ -976,7 +976,7 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n \n-        match (scalar, &ty.kind) {\n+        match (scalar, &ty.kind()) {\n             // Byte strings (&[u8; N])\n             (\n                 Scalar::Ptr(ptr),\n@@ -1136,7 +1136,7 @@ pub trait PrettyPrinter<'tcx>:\n \n         let u8_type = self.tcx().types.u8;\n \n-        match (ct, &ty.kind) {\n+        match (ct, ty.kind()) {\n             // Byte/string slices, printed as (byte) string literals.\n             (\n                 ConstValue::Slice { data, start, end },\n@@ -1189,7 +1189,7 @@ pub trait PrettyPrinter<'tcx>:\n                 );\n                 let fields = contents.fields.iter().copied();\n \n-                match ty.kind {\n+                match *ty.kind() {\n                     ty::Array(..) => {\n                         p!(write(\"[\"), comma_sep(fields), write(\"]\"));\n                     }"}, {"sha": "7d3634a75b0a7c9c41cddf26adaccf0493d0da41", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -325,7 +325,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n ) -> RelateResult<'tcx, Ty<'tcx>> {\n     let tcx = relation.tcx();\n     debug!(\"super_relate_tys: a={:?} b={:?}\", a, b);\n-    match (&a.kind, &b.kind) {\n+    match (a.kind(), b.kind()) {\n         (&ty::Infer(_), _) | (_, &ty::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_tys\")\n@@ -516,7 +516,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                 (ConstValue::Scalar(a_val), ConstValue::Scalar(b_val)) if a.ty == b.ty => {\n                     if a_val == b_val {\n                         Ok(ConstValue::Scalar(a_val))\n-                    } else if let ty::FnPtr(_) = a.ty.kind {\n+                    } else if let ty::FnPtr(_) = a.ty.kind() {\n                         let a_instance = tcx.global_alloc(a_val.assert_ptr().alloc_id).unwrap_fn();\n                         let b_instance = tcx.global_alloc(b_val.assert_ptr().alloc_id).unwrap_fn();\n                         if a_instance == b_instance {\n@@ -540,7 +540,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                 }\n \n                 (ConstValue::ByRef { .. }, ConstValue::ByRef { .. }) => {\n-                    match a.ty.kind {\n+                    match a.ty.kind() {\n                         ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n                             let a_destructured = tcx.destructure_const(relation.param_env().and(a));\n                             let b_destructured = tcx.destructure_const(relation.param_env().and(b));"}, {"sha": "f8627e2f1b6461609144438d4de857730ed2faf0", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -923,25 +923,25 @@ impl<'tcx> TypeFoldable<'tcx> for interpret::GlobalId<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let kind = match self.kind {\n+        let kind = match self.kind() {\n             ty::RawPtr(tm) => ty::RawPtr(tm.fold_with(folder)),\n             ty::Array(typ, sz) => ty::Array(typ.fold_with(folder), sz.fold_with(folder)),\n             ty::Slice(typ) => ty::Slice(typ.fold_with(folder)),\n-            ty::Adt(tid, substs) => ty::Adt(tid, substs.fold_with(folder)),\n+            ty::Adt(tid, substs) => ty::Adt(*tid, substs.fold_with(folder)),\n             ty::Dynamic(ref trait_ty, ref region) => {\n                 ty::Dynamic(trait_ty.fold_with(folder), region.fold_with(folder))\n             }\n             ty::Tuple(ts) => ty::Tuple(ts.fold_with(folder)),\n-            ty::FnDef(def_id, substs) => ty::FnDef(def_id, substs.fold_with(folder)),\n+            ty::FnDef(def_id, substs) => ty::FnDef(*def_id, substs.fold_with(folder)),\n             ty::FnPtr(f) => ty::FnPtr(f.fold_with(folder)),\n-            ty::Ref(ref r, ty, mutbl) => ty::Ref(r.fold_with(folder), ty.fold_with(folder), mutbl),\n+            ty::Ref(ref r, ty, mutbl) => ty::Ref(r.fold_with(folder), ty.fold_with(folder), *mutbl),\n             ty::Generator(did, substs, movability) => {\n-                ty::Generator(did, substs.fold_with(folder), movability)\n+                ty::Generator(*did, substs.fold_with(folder), *movability)\n             }\n             ty::GeneratorWitness(types) => ty::GeneratorWitness(types.fold_with(folder)),\n-            ty::Closure(did, substs) => ty::Closure(did, substs.fold_with(folder)),\n+            ty::Closure(did, substs) => ty::Closure(*did, substs.fold_with(folder)),\n             ty::Projection(ref data) => ty::Projection(data.fold_with(folder)),\n-            ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)),\n+            ty::Opaque(did, substs) => ty::Opaque(*did, substs.fold_with(folder)),\n \n             ty::Bool\n             | ty::Char\n@@ -958,15 +958,15 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             | ty::Foreign(..) => return self,\n         };\n \n-        if self.kind == kind { self } else { folder.tcx().mk_ty(kind) }\n+        if *self.kind() == kind { self } else { folder.tcx().mk_ty(kind) }\n     }\n \n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_ty(*self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             ty::RawPtr(ref tm) => tm.visit_with(visitor),\n             ty::Array(typ, sz) => typ.visit_with(visitor) || sz.visit_with(visitor),\n             ty::Slice(typ) => typ.visit_with(visitor),"}, {"sha": "9f5fc5a2d3fbccc428e429954403ada0e344e791", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 96, "deletions": 60, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -367,7 +367,8 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Used primarily by `ty::print::pretty` to be able to handle closure\n     /// types that haven't had their synthetic types substituted in.\n     pub fn is_valid(self) -> bool {\n-        self.substs.len() >= 3 && matches!(self.split().tupled_upvars_ty.expect_ty().kind, Tuple(_))\n+        self.substs.len() >= 3\n+            && matches!(self.split().tupled_upvars_ty.expect_ty().kind(), Tuple(_))\n     }\n \n     /// Returns the substitutions of the closure's parent.\n@@ -414,9 +415,9 @@ impl<'tcx> ClosureSubsts<'tcx> {\n     /// Extracts the signature from the closure.\n     pub fn sig(self) -> ty::PolyFnSig<'tcx> {\n         let ty = self.sig_as_fn_ptr_ty();\n-        match ty.kind {\n-            ty::FnPtr(sig) => sig,\n-            _ => bug!(\"closure_sig_as_fn_ptr_ty is not a fn-ptr: {:?}\", ty.kind),\n+        match ty.kind() {\n+            ty::FnPtr(sig) => *sig,\n+            _ => bug!(\"closure_sig_as_fn_ptr_ty is not a fn-ptr: {:?}\", ty.kind()),\n         }\n     }\n }\n@@ -484,7 +485,8 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     /// Used primarily by `ty::print::pretty` to be able to handle generator\n     /// types that haven't had their synthetic types substituted in.\n     pub fn is_valid(self) -> bool {\n-        self.substs.len() >= 5 && matches!(self.split().tupled_upvars_ty.expect_ty().kind, Tuple(_))\n+        self.substs.len() >= 5\n+            && matches!(self.split().tupled_upvars_ty.expect_ty().kind(), Tuple(_))\n     }\n \n     /// Returns the substitutions of the generator's parent.\n@@ -1741,17 +1743,27 @@ impl RegionKind {\n \n /// Type utilities\n impl<'tcx> TyS<'tcx> {\n+    #[inline(always)]\n+    pub fn kind(&self) -> &TyKind<'tcx> {\n+        &self.kind\n+    }\n+\n+    #[inline(always)]\n+    pub fn flags(&self) -> TypeFlags {\n+        self.flags\n+    }\n+\n     #[inline]\n     pub fn is_unit(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Tuple(ref tys) => tys.is_empty(),\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_never(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Never => true,\n             _ => false,\n         }\n@@ -1766,7 +1778,7 @@ impl<'tcx> TyS<'tcx> {\n     pub fn conservative_is_privately_uninhabited(&self, tcx: TyCtxt<'tcx>) -> bool {\n         // FIXME(varkor): we can make this less conversative by substituting concrete\n         // type arguments.\n-        match self.kind {\n+        match self.kind() {\n             ty::Never => true,\n             ty::Adt(def, _) if def.is_union() => {\n                 // For now, `union`s are never considered uninhabited.\n@@ -1806,78 +1818,102 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_primitive(&self) -> bool {\n-        self.kind.is_primitive()\n+        self.kind().is_primitive()\n+    }\n+\n+    #[inline]\n+    pub fn is_adt(&self) -> bool {\n+        match self.kind() {\n+            Adt(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_ref(&self) -> bool {\n+        match self.kind() {\n+            Ref(..) => true,\n+            _ => false,\n+        }\n     }\n \n     #[inline]\n     pub fn is_ty_var(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Infer(TyVar(_)) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_ty_infer(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Infer(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n-        if let Adt(def, _) = self.kind { def.is_phantom_data() } else { false }\n+        if let Adt(def, _) = self.kind() { def.is_phantom_data() } else { false }\n     }\n \n     #[inline]\n     pub fn is_bool(&self) -> bool {\n-        self.kind == Bool\n+        *self.kind() == Bool\n     }\n \n     /// Returns `true` if this type is a `str`.\n     #[inline]\n     pub fn is_str(&self) -> bool {\n-        self.kind == Str\n+        *self.kind() == Str\n     }\n \n     #[inline]\n     pub fn is_param(&self, index: u32) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             ty::Param(ref data) => data.index == index,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_slice(&self) -> bool {\n-        match self.kind {\n-            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.kind {\n+        match self.kind() {\n+            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => match ty.kind() {\n                 Slice(_) | Str => true,\n                 _ => false,\n             },\n             _ => false,\n         }\n     }\n \n+    #[inline]\n+    pub fn is_array(&self) -> bool {\n+        match self.kind() {\n+            Array(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n     #[inline]\n     pub fn is_simd(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Adt(def, _) => def.repr.simd(),\n             _ => false,\n         }\n     }\n \n     pub fn sequence_element_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self.kind {\n+        match self.kind() {\n             Array(ty, _) | Slice(ty) => ty,\n             Str => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"`sequence_element_type` called on non-sequence value: {}\", self),\n         }\n     }\n \n     pub fn simd_type(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self.kind {\n+        match self.kind() {\n             Adt(def, substs) => def.non_enum_variant().fields[0].ty(tcx, substs),\n             _ => bug!(\"`simd_type` called on invalid type\"),\n         }\n@@ -1886,14 +1922,14 @@ impl<'tcx> TyS<'tcx> {\n     pub fn simd_size(&self, _tcx: TyCtxt<'tcx>) -> u64 {\n         // Parameter currently unused, but probably needed in the future to\n         // allow `#[repr(simd)] struct Simd<T, const N: usize>([T; N]);`.\n-        match self.kind {\n+        match self.kind() {\n             Adt(def, _) => def.non_enum_variant().fields.len() as u64,\n             _ => bug!(\"`simd_size` called on invalid type\"),\n         }\n     }\n \n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n-        match self.kind {\n+        match self.kind() {\n             Adt(def, substs) => {\n                 let variant = def.non_enum_variant();\n                 (variant.fields.len() as u64, variant.fields[0].ty(tcx, substs))\n@@ -1904,15 +1940,15 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_region_ptr(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Ref(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_mutable_ptr(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             RawPtr(TypeAndMut { mutbl: hir::Mutability::Mut, .. })\n             | Ref(_, _, hir::Mutability::Mut) => true,\n             _ => false,\n@@ -1921,7 +1957,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_unsafe_ptr(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             RawPtr(_) => true,\n             _ => false,\n         }\n@@ -1935,15 +1971,15 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_box(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Adt(def, _) => def.is_box(),\n             _ => false,\n         }\n     }\n \n     /// Panics if called on any type other than `Box<T>`.\n     pub fn boxed_ty(&self) -> Ty<'tcx> {\n-        match self.kind {\n+        match self.kind() {\n             Adt(def, substs) if def.is_box() => substs.type_at(0),\n             _ => bug!(\"`boxed_ty` is called on non-box type {:?}\", self),\n         }\n@@ -1954,7 +1990,7 @@ impl<'tcx> TyS<'tcx> {\n     /// contents are abstract to rustc.)\n     #[inline]\n     pub fn is_scalar(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Bool\n             | Char\n             | Int(_)\n@@ -1971,63 +2007,63 @@ impl<'tcx> TyS<'tcx> {\n     /// Returns `true` if this type is a floating point type.\n     #[inline]\n     pub fn is_floating_point(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Float(_) | Infer(FloatVar(_)) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_trait(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Dynamic(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_enum(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Adt(adt_def, _) => adt_def.is_enum(),\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_closure(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Closure(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_generator(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Generator(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_integral(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Infer(IntVar(_)) | Int(_) | Uint(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_fresh_ty(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Infer(FreshTy(_)) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_fresh(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Infer(FreshTy(_)) => true,\n             Infer(FreshIntTy(_)) => true,\n             Infer(FreshFloatTy(_)) => true,\n@@ -2037,7 +2073,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_char(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Char => true,\n             _ => false,\n         }\n@@ -2050,31 +2086,31 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_signed(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Int(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_ptr_sized_integral(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Int(ast::IntTy::Isize) | Uint(ast::UintTy::Usize) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_machine(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Int(..) | Uint(..) | Float(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn has_concrete_skeleton(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Param(_) | Infer(_) | Error(_) => false,\n             _ => true,\n         }\n@@ -2085,28 +2121,28 @@ impl<'tcx> TyS<'tcx> {\n     /// The parameter `explicit` indicates if this is an *explicit* dereference.\n     /// Some types -- notably unsafe ptrs -- can only be dereferenced explicitly.\n     pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n-        match self.kind {\n+        match self.kind() {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut { ty: self.boxed_ty(), mutbl: hir::Mutability::Not })\n             }\n-            Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),\n-            RawPtr(mt) if explicit => Some(mt),\n+            Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl: *mutbl }),\n+            RawPtr(mt) if explicit => Some(*mt),\n             _ => None,\n         }\n     }\n \n     /// Returns the type of `ty[i]`.\n     pub fn builtin_index(&self) -> Option<Ty<'tcx>> {\n-        match self.kind {\n+        match self.kind() {\n             Array(ty, _) | Slice(ty) => Some(ty),\n             _ => None,\n         }\n     }\n \n     pub fn fn_sig(&self, tcx: TyCtxt<'tcx>) -> PolyFnSig<'tcx> {\n-        match self.kind {\n-            FnDef(def_id, substs) => tcx.fn_sig(def_id).subst(tcx, substs),\n-            FnPtr(f) => f,\n+        match self.kind() {\n+            FnDef(def_id, substs) => tcx.fn_sig(*def_id).subst(tcx, substs),\n+            FnPtr(f) => *f,\n             Error(_) => {\n                 // ignore errors (#54954)\n                 ty::Binder::dummy(FnSig::fake())\n@@ -2120,31 +2156,31 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_fn(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             FnDef(..) | FnPtr(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_fn_ptr(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             FnPtr(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn is_impl_trait(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             Opaque(..) => true,\n             _ => false,\n         }\n     }\n \n     #[inline]\n     pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n-        match self.kind {\n+        match self.kind() {\n             Adt(adt, _) => Some(adt),\n             _ => None,\n         }\n@@ -2153,7 +2189,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Iterates over tuple fields.\n     /// Panics when called on anything but a tuple.\n     pub fn tuple_fields(&self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> {\n-        match self.kind {\n+        match self.kind() {\n             Tuple(substs) => substs.iter().map(|field| field.expect_ty()),\n             _ => bug!(\"tuple_fields called on non-tuple\"),\n         }\n@@ -2164,10 +2200,10 @@ impl<'tcx> TyS<'tcx> {\n     // FIXME: This requires the optimized MIR in the case of generators.\n     #[inline]\n     pub fn variant_range(&self, tcx: TyCtxt<'tcx>) -> Option<Range<VariantIdx>> {\n-        match self.kind {\n+        match self.kind() {\n             TyKind::Adt(adt, _) => Some(adt.variant_range()),\n             TyKind::Generator(def_id, substs, _) => {\n-                Some(substs.as_generator().variant_range(def_id, tcx))\n+                Some(substs.as_generator().variant_range(*def_id, tcx))\n             }\n             _ => None,\n         }\n@@ -2183,23 +2219,23 @@ impl<'tcx> TyS<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n-        match self.kind {\n+        match self.kind() {\n             TyKind::Adt(adt, _) if adt.variants.is_empty() => {\n                 bug!(\"discriminant_for_variant called on zero variant enum\");\n             }\n             TyKind::Adt(adt, _) if adt.is_enum() => {\n                 Some(adt.discriminant_for_variant(tcx, variant_index))\n             }\n             TyKind::Generator(def_id, substs, _) => {\n-                Some(substs.as_generator().discriminant_for_variant(def_id, tcx, variant_index))\n+                Some(substs.as_generator().discriminant_for_variant(*def_id, tcx, variant_index))\n             }\n             _ => None,\n         }\n     }\n \n     /// Returns the type of the discriminant of this type.\n     pub fn discriminant_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        match self.kind {\n+        match self.kind() {\n             ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n             ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n             _ => {\n@@ -2222,7 +2258,7 @@ impl<'tcx> TyS<'tcx> {\n     /// inferred. Once upvar inference (in `src/librustc_typeck/check/upvar.rs`)\n     /// is complete, that type variable will be unified.\n     pub fn to_opt_closure_kind(&self) -> Option<ty::ClosureKind> {\n-        match self.kind {\n+        match self.kind() {\n             Int(int_ty) => match int_ty {\n                 ast::IntTy::I8 => Some(ty::ClosureKind::Fn),\n                 ast::IntTy::I16 => Some(ty::ClosureKind::FnMut),\n@@ -2245,7 +2281,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Returning true means the type is known to be sized. Returning\n     /// `false` means nothing -- could be sized, might not be.\n     pub fn is_trivially_sized(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Uint(_)\n             | ty::Int(_)"}, {"sha": "1bd3bcb6a4d6db631e0f1d949829c3153e1c7b9a", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n             return t;\n         }\n \n-        match t.kind {\n+        match *t.kind() {\n             ty::Param(p) => self.ty_for_param(p, t),\n             _ => t.super_fold_with(self),\n         }"}, {"sha": "f3eb7c35f04943148cafc9a21f0ae86dd9135179", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -33,7 +33,7 @@ pub struct Discr<'tcx> {\n \n impl<'tcx> fmt::Display for Discr<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.ty.kind {\n+        match *self.ty.kind() {\n             ty::Int(ity) => {\n                 let size = ty::tls::with(|tcx| Integer::from_attr(&tcx, SignedInt(ity)).size());\n                 let x = self.val;\n@@ -59,7 +59,7 @@ fn unsigned_max(size: Size) -> u128 {\n }\n \n fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n-    let (int, signed) = match ty.kind {\n+    let (int, signed) = match *ty.kind() {\n         Int(ity) => (Integer::from_attr(&tcx, SignedInt(ity)), true),\n         Uint(uty) => (Integer::from_attr(&tcx, UnsignedInt(uty)), false),\n         _ => bug!(\"non integer discriminant\"),\n@@ -174,10 +174,10 @@ impl<'tcx> TyCtxt<'tcx> {\n \n impl<'tcx> TyCtxt<'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n-        if let ty::Adt(def, substs) = ty.kind {\n+        if let ty::Adt(def, substs) = *ty.kind() {\n             for field in def.all_fields() {\n                 let field_ty = field.ty(self, substs);\n-                if let Error(_) = field_ty.kind {\n+                if let Error(_) = field_ty.kind() {\n                     return true;\n                 }\n             }\n@@ -225,7 +225,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         normalize: impl Fn(Ty<'tcx>) -> Ty<'tcx>,\n     ) -> Ty<'tcx> {\n         loop {\n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Adt(def, substs) => {\n                     if !def.is_struct() {\n                         break;\n@@ -298,7 +298,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n         loop {\n-            match (&a.kind, &b.kind) {\n+            match (&a.kind(), &b.kind()) {\n                 (&Adt(a_def, a_substs), &Adt(b_def, b_substs))\n                     if a_def == b_def && a_def.is_struct() =>\n                 {\n@@ -401,12 +401,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         // <P1, P2, P0>, and then look up which of the impl substs refer to\n         // parameters marked as pure.\n \n-        let impl_substs = match self.type_of(impl_def_id).kind {\n+        let impl_substs = match *self.type_of(impl_def_id).kind() {\n             ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!(),\n         };\n \n-        let item_substs = match self.type_of(def.did).kind {\n+        let item_substs = match *self.type_of(def.did).kind() {\n             ty::Adt(def_, substs) if def_ == def => substs,\n             _ => bug!(),\n         };\n@@ -640,7 +640,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n     pub fn numeric_max_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n-        let val = match self.kind {\n+        let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n                 let val = if signed { signed_max(size) as u128 } else { unsigned_max(size) };\n@@ -659,7 +659,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Returns the minimum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n     pub fn numeric_min_val(&'tcx self, tcx: TyCtxt<'tcx>) -> Option<&'tcx ty::Const<'tcx>> {\n-        let val = match self.kind {\n+        let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n                 let (size, signed) = int_size_and_signed(tcx, self);\n                 let val = if signed { truncate(signed_min(size) as u128, size) } else { 0 };\n@@ -717,7 +717,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Returning true means the type is known to be `Freeze`. Returning\n     /// `false` means nothing -- could be `Freeze`, might not be.\n     fn is_trivially_freeze(&self) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             ty::Int(_)\n             | ty::Uint(_)\n             | ty::Float(_)\n@@ -793,7 +793,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// down, you will need to use a type visitor.\n     #[inline]\n     pub fn is_structural_eq_shallow(&'tcx self, tcx: TyCtxt<'tcx>) -> bool {\n-        match self.kind {\n+        match self.kind() {\n             // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n             Adt(..) => tcx.has_structural_eq_impls(self),\n \n@@ -828,7 +828,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match (&a.kind, &b.kind) {\n+        match (&a.kind(), &b.kind()) {\n             (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {\n                 if did_a != did_b {\n                     return false;\n@@ -860,7 +860,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n             ty: Ty<'tcx>,\n         ) -> Representability {\n-            match ty.kind {\n+            match ty.kind() {\n                 Tuple(..) => {\n                     // Find non representable\n                     fold_repr(ty.tuple_fields().map(|ty| {\n@@ -909,7 +909,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n \n         fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n-            match ty.kind {\n+            match *ty.kind() {\n                 Adt(ty_def, _) => ty_def == def,\n                 _ => false,\n             }\n@@ -947,7 +947,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n             ty: Ty<'tcx>,\n         ) -> Representability {\n-            match ty.kind {\n+            match ty.kind() {\n                 Adt(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n@@ -962,7 +962,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                         // struct Bar<T> { x: Bar<Foo> }\n \n                         if let Some(&seen_type) = iter.next() {\n-                            if same_struct_or_enum(seen_type, def) {\n+                            if same_struct_or_enum(seen_type, *def) {\n                                 debug!(\"SelfRecursive: {:?} contains {:?}\", seen_type, ty);\n                                 return Representability::SelfRecursive(vec![sp]);\n                             }\n@@ -1024,7 +1024,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// - `&'a *const &'b u8 -> *const &'b u8`\n     pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n         let mut ty = self;\n-        while let Ref(_, inner_ty, _) = ty.kind {\n+        while let Ref(_, inner_ty, _) = ty.kind() {\n             ty = inner_ty;\n         }\n         ty\n@@ -1070,7 +1070,7 @@ impl<'tcx> ExplicitSelf<'tcx> {\n     {\n         use self::ExplicitSelf::*;\n \n-        match self_arg_ty.kind {\n+        match *self_arg_ty.kind() {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n             ty::Ref(region, ty, mutbl) if is_self_ty(ty) => ByReference(region, mutbl),\n             ty::RawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => ByRawPointer(mutbl),\n@@ -1087,7 +1087,7 @@ pub fn needs_drop_components(\n     ty: Ty<'tcx>,\n     target_layout: &TargetDataLayout,\n ) -> Result<SmallVec<[Ty<'tcx>; 2]>, AlwaysRequiresDrop> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Infer(ty::FreshIntTy(_))\n         | ty::Infer(ty::FreshFloatTy(_))\n         | ty::Bool"}, {"sha": "4f55517c6f4357d320acea7bb959d9555fd169b5", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -98,7 +98,7 @@ impl<'tcx> super::TyS<'tcx> {\n // types as they are written).\n fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>) {\n     match parent.unpack() {\n-        GenericArgKind::Type(parent_ty) => match parent_ty.kind {\n+        GenericArgKind::Type(parent_ty) => match *parent_ty.kind() {\n             ty::Bool\n             | ty::Char\n             | ty::Int(_)"}, {"sha": "676065007b7ef5cf107c8771e929e33306812359", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -291,7 +291,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty =\n                 Place::ty_from(used_place.local, used_place.projection, self.body, self.infcx.tcx)\n                     .ty;\n-            let needs_note = match ty.kind {\n+            let needs_note = match ty.kind() {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck(id.expect_local());\n                     let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(id.expect_local());\n@@ -306,7 +306,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = place.ty(self.body, self.infcx.tcx).ty;\n \n             if is_loop_move {\n-                if let ty::Ref(_, _, hir::Mutability::Mut) = ty.kind {\n+                if let ty::Ref(_, _, hir::Mutability::Mut) = ty.kind() {\n                     // We have a `&mut` ref, we need to reborrow on each iteration (#62112).\n                     err.span_suggestion_verbose(\n                         span.shrink_to_lo(),\n@@ -329,7 +329,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     Some(ref name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n                 };\n-                if let ty::Param(param_ty) = ty.kind {\n+                if let ty::Param(param_ty) = ty.kind() {\n                     let tcx = self.infcx.tcx;\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n@@ -997,7 +997,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .opt_name(fn_hir_id)\n                         .map(|name| format!(\"function `{}`\", name))\n                         .unwrap_or_else(|| {\n-                            match &self.infcx.tcx.typeck(self.mir_def_id).node_type(fn_hir_id).kind\n+                            match &self\n+                                .infcx\n+                                .tcx\n+                                .typeck(self.mir_def_id)\n+                                .node_type(fn_hir_id)\n+                                .kind()\n                             {\n                                 ty::Closure(..) => \"enclosing closure\",\n                                 ty::Generator(..) => \"enclosing generator\",\n@@ -1625,7 +1630,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n                         let base_ty = Place::ty_from(place.local, proj_base, self.body, tcx).ty;\n-                        match base_ty.kind {\n+                        match base_ty.kind() {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n                                 match base_access {\n@@ -1689,7 +1694,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 None\n             } else {\n                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n-                match ty.kind {\n+                match ty.kind() {\n                     ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n                         self.mir_def_id.to_def_id(),\n                         self.infcx.tcx.fn_sig(self.mir_def_id),\n@@ -1924,13 +1929,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // 3. The return type is not a reference. In this case, we don't highlight\n         //    anything.\n         let return_ty = sig.output();\n-        match return_ty.skip_binder().kind {\n+        match return_ty.skip_binder().kind() {\n             ty::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n                 // This is case 1 from above, return type is a named reference so we need to\n                 // search for relevant arguments.\n                 let mut arguments = Vec::new();\n                 for (index, argument) in sig.inputs().skip_binder().iter().enumerate() {\n-                    if let ty::Ref(argument_region, _, _) = argument.kind {\n+                    if let ty::Ref(argument_region, _, _) = argument.kind() {\n                         if argument_region == return_region {\n                             // Need to use the `rustc_middle::ty` types to compare against the\n                             // `return_region`. Then use the `rustc_hir` type to get only\n@@ -1976,9 +1981,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // Closure arguments are wrapped in a tuple, so we need to get the first\n                 // from that.\n-                if let ty::Tuple(elems) = argument_ty.kind {\n+                if let ty::Tuple(elems) = argument_ty.kind() {\n                     let argument_ty = elems.first()?.expect_ty();\n-                    if let ty::Ref(_, _, _) = argument_ty.kind {\n+                    if let ty::Ref(_, _, _) = argument_ty.kind() {\n                         return Some(AnnotatedBorrowFnSignature::Closure {\n                             argument_ty,\n                             argument_span,\n@@ -1998,7 +2003,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let return_ty = sig.output().skip_binder();\n \n                 // We expect the first argument to be a reference.\n-                match argument_ty.kind {\n+                match argument_ty.kind() {\n                     ty::Ref(_, _, _) => {}\n                     _ => return None,\n                 }"}, {"sha": "eaaf202f3bd13484a1bc7b3459d1c34189e79485", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -102,7 +102,7 @@ impl BorrowExplanation {\n                 should_note_order,\n             } => {\n                 let local_decl = &body.local_decls[dropped_local];\n-                let (dtor_desc, type_desc) = match local_decl.ty.kind {\n+                let (dtor_desc, type_desc) = match local_decl.ty.kind() {\n                     // If type is an ADT that implements Drop, then\n                     // simplify output by reporting just the ADT name.\n                     ty::Adt(adt, _substs) if adt.has_dtor(tcx) && !adt.is_box() => {\n@@ -626,7 +626,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                         if from == target {\n                                             debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n                                             // Check the type for a trait object.\n-                                            return match ty.kind {\n+                                            return match ty.kind() {\n                                                 // `&dyn Trait`\n                                                 ty::Ref(_, ty, _) if ty.is_trait() => true,\n                                                 // `Box<dyn Trait>`"}, {"sha": "88ff0271228e0b9c3122a8f542c7c2d27e91a12e", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -81,51 +81,49 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let terminator = self.body[location.block].terminator();\n         debug!(\"add_moved_or_invoked_closure_note: terminator={:?}\", terminator);\n         if let TerminatorKind::Call {\n-            func:\n-                Operand::Constant(box Constant {\n-                    literal: ty::Const { ty: &ty::TyS { kind: ty::FnDef(id, _), .. }, .. },\n-                    ..\n-                }),\n+            func: Operand::Constant(box Constant { literal: ty::Const { ty: const_ty, .. }, .. }),\n             args,\n             ..\n         } = &terminator.kind\n         {\n-            debug!(\"add_moved_or_invoked_closure_note: id={:?}\", id);\n-            if self.infcx.tcx.parent(id) == self.infcx.tcx.lang_items().fn_once_trait() {\n-                let closure = match args.first() {\n-                    Some(Operand::Copy(ref place)) | Some(Operand::Move(ref place))\n-                        if target == place.local_or_deref_local() =>\n-                    {\n-                        place.local_or_deref_local().unwrap()\n-                    }\n-                    _ => return,\n-                };\n+            if let ty::FnDef(id, _) = *const_ty.kind() {\n+                debug!(\"add_moved_or_invoked_closure_note: id={:?}\", id);\n+                if self.infcx.tcx.parent(id) == self.infcx.tcx.lang_items().fn_once_trait() {\n+                    let closure = match args.first() {\n+                        Some(Operand::Copy(ref place)) | Some(Operand::Move(ref place))\n+                            if target == place.local_or_deref_local() =>\n+                        {\n+                            place.local_or_deref_local().unwrap()\n+                        }\n+                        _ => return,\n+                    };\n \n-                debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n-                if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n-                    let did = did.expect_local();\n-                    let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n+                    debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n+                    if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind() {\n+                        let did = did.expect_local();\n+                        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n \n-                    if let Some((span, name)) =\n-                        self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n-                    {\n-                        diag.span_note(\n-                            *span,\n-                            &format!(\n-                                \"closure cannot be invoked more than once because it moves the \\\n-                                 variable `{}` out of its environment\",\n-                                name,\n-                            ),\n-                        );\n-                        return;\n+                        if let Some((span, name)) =\n+                            self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n+                        {\n+                            diag.span_note(\n+                                *span,\n+                                &format!(\n+                                    \"closure cannot be invoked more than once because it moves the \\\n+                                    variable `{}` out of its environment\",\n+                                    name,\n+                                ),\n+                            );\n+                            return;\n+                        }\n                     }\n                 }\n             }\n         }\n \n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n-            if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n+            if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind() {\n                 let did = did.expect_local();\n                 let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n \n@@ -365,7 +363,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // If the type is a box, the field is described from the boxed type\n             self.describe_field_from_ty(&ty.boxed_ty(), field, variant_index)\n         } else {\n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Adt(def, _) => {\n                     let variant = if let Some(idx) = variant_index {\n                         assert!(def.is_enum());\n@@ -496,7 +494,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // We need to add synthesized lifetimes where appropriate. We do\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Ref(\n                 ty::RegionKind::ReLateBound(_, br)\n                 | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n@@ -516,7 +514,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut s = String::new();\n         let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n-        let region = match ty.kind {\n+        let region = match ty.kind() {\n             ty::Ref(region, _, _) => {\n                 match region {\n                     ty::RegionKind::ReLateBound(_, br)\n@@ -680,7 +678,7 @@ impl BorrowedContentSource<'tcx> {\n             BorrowedContentSource::DerefRawPointer => \"a raw pointer\".to_string(),\n             BorrowedContentSource::DerefSharedRef => \"a shared reference\".to_string(),\n             BorrowedContentSource::DerefMutableRef => \"a mutable reference\".to_string(),\n-            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind {\n+            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind() {\n                 ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n                     \"an `Rc`\".to_string()\n                 }\n@@ -712,7 +710,7 @@ impl BorrowedContentSource<'tcx> {\n             BorrowedContentSource::DerefMutableRef => {\n                 bug!(\"describe_for_immutable_place: DerefMutableRef isn't immutable\")\n             }\n-            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind {\n+            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind() {\n                 ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n                     \"an `Rc`\".to_string()\n                 }\n@@ -726,7 +724,7 @@ impl BorrowedContentSource<'tcx> {\n     }\n \n     fn from_call(func: Ty<'tcx>, tcx: TyCtxt<'tcx>) -> Option<Self> {\n-        match func.kind {\n+        match *func.kind() {\n             ty::FnDef(def_id, substs) => {\n                 let trait_id = tcx.trait_of_item(def_id)?;\n \n@@ -812,7 +810,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         {\n             let mut method_did = None;\n             if let Operand::Constant(box Constant { literal: ty::Const { ty, .. }, .. }) = func {\n-                if let ty::FnDef(def_id, _) = ty.kind {\n+                if let ty::FnDef(def_id, _) = *ty.kind() {\n                     debug!(\"move_spans: fn = {:?}\", def_id);\n                     if let Some(ty::AssocItem { fn_has_self_parameter, .. }) =\n                         self.infcx.tcx.opt_associated_item(def_id)"}, {"sha": "6cf1cf20b5afd0f3a5183950d9a44e0acf564a36", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n \n         debug!(\"report: ty={:?}\", ty);\n-        let mut err = match ty.kind {\n+        let mut err = match ty.kind() {\n             ty::Array(..) | ty::Slice(..) => {\n                 self.cannot_move_out_of_interior_noncopy(span, ty, None)\n             }\n@@ -385,7 +385,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         };\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-            let def_id = match move_place.ty(self.body, self.infcx.tcx).ty.kind {\n+            let def_id = match *move_place.ty(self.body, self.infcx.tcx).ty.kind() {\n                 ty::Adt(self_def, _) => self_def.did,\n                 ty::Foreign(def_id)\n                 | ty::FnDef(def_id, _)"}, {"sha": "8b0121cf360e0f24130e9629f5c6ed5523e12d10", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -230,7 +230,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 // Otherwise, check if the name is the self kewyord - in which case\n                                 // we have an explicit self. Do the same thing in this case and check\n                                 // for a `self: &mut Self` to suggest removing the `&mut`.\n-                                if let ty::Ref(_, _, hir::Mutability::Mut) = local_decl.ty.kind {\n+                                if let ty::Ref(_, _, hir::Mutability::Mut) = local_decl.ty.kind() {\n                                     true\n                                 } else {\n                                     false\n@@ -509,7 +509,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let def_id = hir.local_def_id(item_id);\n             let tables = self.infcx.tcx.typeck(def_id);\n             if let Some(ty::FnDef(def_id, _)) =\n-                tables.node_type_opt(func.hir_id).as_ref().map(|ty| &ty.kind)\n+                tables.node_type_opt(func.hir_id).as_ref().map(|ty| ty.kind())\n             {\n                 let arg = match hir.get_if_local(*def_id) {\n                     Some(\n@@ -687,8 +687,8 @@ fn annotate_struct_field(\n     field: &mir::Field,\n ) -> Option<(Span, String)> {\n     // Expect our local to be a reference to a struct of some kind.\n-    if let ty::Ref(_, ty, _) = ty.kind {\n-        if let ty::Adt(def, _) = ty.kind {\n+    if let ty::Ref(_, ty, _) = ty.kind() {\n+        if let ty::Adt(def, _) = ty.kind() {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n             let hir_id = tcx.hir().local_def_id_to_hir_id(field.did.as_local()?);"}, {"sha": "639428ff07d9deb2d136a9aab4a3d5e2c7e62252", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -364,13 +364,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n         let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n-        if let ty::Opaque(def_id, _) = output_ty.kind {\n+        if let ty::Opaque(def_id, _) = *output_ty.kind() {\n             output_ty = self.infcx.tcx.type_of(def_id)\n         };\n \n         debug!(\"report_fnmut_error: output_ty={:?}\", output_ty);\n \n-        let message = match output_ty.kind {\n+        let message = match output_ty.kind() {\n             ty::Closure(_, _) => {\n                 \"returns a closure that contains a reference to a captured variable, which then \\\n                  escapes the closure body\"\n@@ -571,13 +571,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some((&ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n+            if let Some(&ty::Opaque(did, substs)) = self\n                 .infcx\n                 .tcx\n                 .is_suitable_region(f)\n                 .map(|r| r.def_id)\n-                .map(|id| self.infcx.tcx.return_type_impl_trait(id))\n-                .unwrap_or(None)\n+                .and_then(|id| self.infcx.tcx.return_type_impl_trait(id))\n+                .map(|(ty, _)| ty.kind())\n             {\n                 // Check whether or not the impl trait return type is intended to capture\n                 // data with the static lifetime."}, {"sha": "da7bc1564c013d6cca2c4be97f7cbaf3c47e476c", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -441,7 +441,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> = &mut vec![(ty, hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n-            match (&ty.kind, &hir_ty.kind) {\n+            match (&ty.kind(), &hir_ty.kind) {\n                 // Check if the `ty` is `&'X ..` where `'X`\n                 // is the region we are looking for -- if so, and we have a `&T`\n                 // on the RHS, then we want to highlight the `&` like so:"}, {"sha": "acd9e3dcf3fcd44a40343908ad7d71c80c192482", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -1758,7 +1758,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         {\n             let place_ty =\n                 Place::ty_from(place_span.0.local, base_proj, self.body(), self.infcx.tcx);\n-            if let ty::Array(..) = place_ty.ty.kind {\n+            if let ty::Array(..) = place_ty.ty.kind() {\n                 let array_place = PlaceRef { local: place_span.0.local, projection: base_proj };\n                 self.check_if_subslice_element_is_moved(\n                     location,\n@@ -1876,7 +1876,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n                     let base_ty = Place::ty_from(place.local, proj_base, self.body(), tcx).ty;\n-                    match base_ty.kind {\n+                    match base_ty.kind() {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n@@ -1979,7 +1979,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n                 if let ty::Adt(def, _) =\n-                    Place::ty_from(base.local, base.projection, this.body(), tcx).ty.kind\n+                    Place::ty_from(base.local, base.projection, this.body(), tcx).ty.kind()\n                 {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n@@ -2206,7 +2206,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Place::ty_from(place.local, proj_base, self.body(), self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n-                        match base_ty.kind {\n+                        match base_ty.kind() {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable"}, {"sha": "52fac3e53ee659fc3be18978d66cbd410be9fea1", "filename": "compiler/rustc_mir/src/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplace_ext.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n \n             if elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(self.local, proj_base, body, tcx).ty;\n-                match ty.kind {\n+                match ty.kind() {\n                     ty::Ref(_, _, hir::Mutability::Not) if i == 0 => {\n                         // For references to thread-local statics, we do need\n                         // to track the borrow."}, {"sha": "02c7b7dc200c34c5bbffac84c183f3a34b766240", "filename": "compiler/rustc_mir/src/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fplaces_conflict.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -210,7 +210,7 @@ fn place_components_conflict<'tcx>(\n             let proj_base = &borrow_place.projection[..access_place.projection.len() + i];\n             let base_ty = Place::ty_from(borrow_local, proj_base, body, tcx).ty;\n \n-            match (elem, &base_ty.kind, access) {\n+            match (elem, &base_ty.kind(), access) {\n                 (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n                 | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n                     // The array length is like  additional fields on the\n@@ -330,7 +330,7 @@ fn place_projection_conflict<'tcx>(\n                 Overlap::EqualOrDisjoint\n             } else {\n                 let ty = Place::ty_from(pi1_local, pi1_proj_base, body, tcx).ty;\n-                match ty.kind {\n+                match ty.kind() {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck.\n                         debug!(\"place_element_conflict: STUCK-UNION\");"}, {"sha": "5bfe02ff3b04e6807a43ed013070fad713b2fae1", "filename": "compiler/rustc_mir/src/borrow_check/prefixes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fprefixes.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -121,7 +121,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                     // reference.\n \n                     let ty = Place::ty_from(cursor.local, proj_base, self.body, self.tcx).ty;\n-                    match ty.kind {\n+                    match ty.kind() {\n                         ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n                             // borrows."}, {"sha": "3ace14610e2a7135f22464e5b65ca0bf52e6cf62", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 }\n             }\n \n-            if let ty::FnDef(def_id, substs) = constant.literal.ty.kind {\n+            if let ty::FnDef(def_id, substs) = *constant.literal.ty.kind() {\n                 let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n                 self.cx.normalize_and_prove_instantiated_predicates(\n                     instantiated_predicates,\n@@ -412,7 +412,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     // If we have a binding of the form `let ref x: T = ..`\n                     // then remove the outermost reference so we can check the\n                     // type annotation for the remaining type.\n-                    if let ty::Ref(_, rty, _) = local_decl.ty.kind {\n+                    if let ty::Ref(_, rty, _) = local_decl.ty.kind() {\n                         rty\n                     } else {\n                         bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n@@ -646,7 +646,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }))\n             }\n             ProjectionElem::Subslice { from, to, from_end } => {\n-                PlaceTy::from_ty(match base_ty.kind {\n+                PlaceTy::from_ty(match base_ty.kind() {\n                     ty::Array(inner, _) => {\n                         assert!(!from_end, \"array subslices should not use from_end\");\n                         tcx.mk_array(inner, to - from)\n@@ -658,7 +658,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     _ => span_mirbug_and_err!(self, place, \"slice of non-array {:?}\", base_ty),\n                 })\n             }\n-            ProjectionElem::Downcast(maybe_name, index) => match base_ty.kind {\n+            ProjectionElem::Downcast(maybe_name, index) => match base_ty.kind() {\n                 ty::Adt(adt_def, _substs) if adt_def.is_enum() => {\n                     if index.as_usize() >= adt_def.variants.len() {\n                         PlaceTy::from_ty(span_mirbug_and_err!(\n@@ -738,7 +738,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         let tcx = self.tcx();\n \n         let (variant, substs) = match base_ty {\n-            PlaceTy { ty, variant_index: Some(variant_index) } => match ty.kind {\n+            PlaceTy { ty, variant_index: Some(variant_index) } => match *ty.kind() {\n                 ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n                 ty::Generator(def_id, substs, _) => {\n                     let mut variants = substs.as_generator().state_tys(def_id, tcx);\n@@ -757,7 +757,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }\n                 _ => bug!(\"can't have downcast of non-adt non-generator type\"),\n             },\n-            PlaceTy { ty, variant_index: None } => match ty.kind {\n+            PlaceTy { ty, variant_index: None } => match *ty.kind() {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() => {\n                     (&adt_def.variants[VariantIdx::new(0)], substs)\n                 }\n@@ -1140,7 +1140,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n         if let Err(terr) = self.sub_types(sub, sup, locations, category) {\n-            if let ty::Opaque(..) = sup.kind {\n+            if let ty::Opaque(..) = sup.kind() {\n                 // When you have `let x: impl Foo = ...` in a closure,\n                 // the resulting inferend values are stored with the\n                 // def-id of the base function.\n@@ -1283,8 +1283,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                     for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n                         let resolved_ty = infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty);\n-                        let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind {\n-                            def_id == opaque_def_id\n+                        let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind() {\n+                            *def_id == opaque_def_id\n                         } else {\n                             false\n                         };\n@@ -1486,7 +1486,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             StatementKind::SetDiscriminant { ref place, variant_index } => {\n                 let place_type = place.ty(body, tcx).ty;\n-                let adt = match place_type.kind {\n+                let adt = match place_type.kind() {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n                         span_bug!(\n@@ -1602,7 +1602,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             TerminatorKind::Call { ref func, ref args, ref destination, from_hir_call, .. } => {\n                 let func_ty = func.ty(body, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n-                let sig = match func_ty.kind {\n+                let sig = match func_ty.kind() {\n                     ty::FnDef(..) | ty::FnPtr(_) => func_ty.fn_sig(tcx),\n                     _ => {\n                         span_mirbug!(self, term, \"call to non-function {:?}\", func_ty);\n@@ -2093,7 +2093,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(body, tcx).kind {\n+                        let sig = match op.ty(body, tcx).kind() {\n                             ty::Closure(_, substs) => substs.as_closure().sig(),\n                             _ => bug!(),\n                         };\n@@ -2161,7 +2161,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(body, tcx).kind {\n+                        let ty_from = match op.ty(body, tcx).kind() {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::Mutability::Mut,\n@@ -2176,7 +2176,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 return;\n                             }\n                         };\n-                        let ty_to = match ty.kind {\n+                        let ty_to = match ty.kind() {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n                                 mutbl: hir::Mutability::Not,\n@@ -2211,11 +2211,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     CastKind::Pointer(PointerCast::ArrayToPointer) => {\n                         let ty_from = op.ty(body, tcx);\n \n-                        let opt_ty_elem = match ty_from.kind {\n+                        let opt_ty_elem = match ty_from.kind() {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 mutbl: hir::Mutability::Not,\n                                 ty: array_ty,\n-                            }) => match array_ty.kind {\n+                            }) => match array_ty.kind() {\n                                 ty::Array(ty_elem, _) => Some(ty_elem),\n                                 _ => None,\n                             },\n@@ -2235,7 +2235,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         };\n \n-                        let ty_to = match ty.kind {\n+                        let ty_to = match ty.kind() {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 mutbl: hir::Mutability::Not,\n                                 ty: ty_to,\n@@ -2301,7 +2301,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 right,\n             ) => {\n                 let ty_left = left.ty(body, tcx);\n-                match ty_left.kind {\n+                match ty_left.kind() {\n                     // Types with regions are comparable if they have a common super-type.\n                     ty::RawPtr(_) | ty::FnPtr(_) => {\n                         let ty_right = right.ty(body, tcx);\n@@ -2512,7 +2512,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     let base_ty = Place::ty_from(borrowed_place.local, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n-                    match base_ty.kind {\n+                    match base_ty.kind() {\n                         ty::Ref(ref_region, _, mutbl) => {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n                                 sup: ref_region.to_region_vid(),"}, {"sha": "4742113b1a552c9c7c34df654590db373f67f70e", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -524,7 +524,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let defining_ty =\n                     self.infcx.replace_free_regions_with_nll_infer_vars(FR, &defining_ty);\n \n-                match defining_ty.kind {\n+                match *defining_ty.kind() {\n                     ty::Closure(def_id, substs) => DefiningTy::Closure(def_id, substs),\n                     ty::Generator(def_id, substs, movability) => {\n                         DefiningTy::Generator(def_id, substs, movability)\n@@ -603,7 +603,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     // flattens this tuple.\n                     let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n                     assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n-                    let inputs = match tuplized_inputs[0].kind {\n+                    let inputs = match tuplized_inputs[0].kind() {\n                         ty::Tuple(inputs) => inputs,\n                         _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n                     };"}, {"sha": "72151df7230be2df821d4720625863bc59a671c6", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -117,8 +117,8 @@ pub(super) fn op_to_const<'tcx>(\n     // `Undef` situation.\n     let try_as_immediate = match op.layout.abi {\n         Abi::Scalar(..) => true,\n-        Abi::ScalarPair(..) => match op.layout.ty.kind {\n-            ty::Ref(_, inner, _) => match inner.kind {\n+        Abi::ScalarPair(..) => match op.layout.ty.kind() {\n+            ty::Ref(_, inner, _) => match *inner.kind() {\n                 ty::Slice(elem) => elem == ecx.tcx.types.u8,\n                 ty::Str => true,\n                 _ => false,\n@@ -250,7 +250,7 @@ pub fn const_eval_validated_provider<'tcx>(\n     // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n     if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n         let ty = key.value.instance.ty(tcx, key.param_env);\n-        let substs = match ty.kind {\n+        let substs = match ty.kind() {\n             ty::FnDef(_, substs) => substs,\n             _ => bug!(\"intrinsic with type {:?}\", ty),\n         };"}, {"sha": "c93feb5096bf7df8a4b66c2e7407d6a2919f4f66", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -44,7 +44,7 @@ pub(crate) fn destructure_const<'tcx>(\n     let op = ecx.const_to_op(val, None).unwrap();\n \n     // We go to `usize` as we cannot allocate anything bigger anyway.\n-    let (field_count, variant, down) = match val.ty.kind {\n+    let (field_count, variant, down) = match val.ty.kind() {\n         ty::Array(_, len) => (usize::try_from(len.eval_usize(tcx, param_env)).unwrap(), None, op),\n         ty::Adt(def, _) if def.variants.is_empty() => {\n             return mir::DestructuredConst { variant: None, fields: tcx.arena.alloc_slice(&[]) };"}, {"sha": "d1d507e54ef5fc787e38b5d620fbed7b68cb5bb4", "filename": "compiler/rustc_mir/src/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fdrop_flag_effects.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -53,7 +53,7 @@ fn place_contents_drop_state_cannot_differ<'tcx>(\n     place: mir::Place<'tcx>,\n ) -> bool {\n     let ty = place.ty(body, tcx).ty;\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Array(..) => {\n             debug!(\n                 \"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\","}, {"sha": "1a3b13f0d1f486a9b00b089292ce9c942442d159", "filename": "compiler/rustc_mir/src/dataflow/framework/direction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fdirection.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -559,7 +559,7 @@ fn switch_on_enum_discriminant(\n         Some(mir::StatementKind::Assign(box (lhs, mir::Rvalue::Discriminant(discriminated))))\n             if *lhs == switch_on =>\n         {\n-            match &discriminated.ty(body, tcx).ty.kind {\n+            match &discriminated.ty(body, tcx).ty.kind() {\n                 ty::Adt(def, _) => Some((*discriminated, def)),\n \n                 // `Rvalue::Discriminant` is also used to get the active yield point for a"}, {"sha": "b083044a9c6d9a4e6f955137b85def97de4270b3", "filename": "compiler/rustc_mir/src/dataflow/move_paths/builder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -110,7 +110,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             let body = self.builder.body;\n             let tcx = self.builder.tcx;\n             let place_ty = Place::ty_from(place.local, proj_base, body, tcx).ty;\n-            match place_ty.kind {\n+            match place_ty.kind() {\n                 ty::Ref(..) | ty::RawPtr(..) => {\n                     let proj = &place.projection[..i + 1];\n                     return Err(MoveError::cannot_move_out_of(\n@@ -480,7 +480,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 }\n             };\n             let base_ty = base_place.ty(self.builder.body, self.builder.tcx).ty;\n-            let len: u64 = match base_ty.kind {\n+            let len: u64 = match base_ty.kind() {\n                 ty::Array(_, size) => {\n                     let length = size.eval_usize(self.builder.tcx, self.builder.param_env);\n                     length\n@@ -525,7 +525,9 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         // of the union so it is marked as initialized again.\n         if let [proj_base @ .., ProjectionElem::Field(_, _)] = place.projection {\n             if let ty::Adt(def, _) =\n-                Place::ty_from(place.local, proj_base, self.builder.body, self.builder.tcx).ty.kind\n+                Place::ty_from(place.local, proj_base, self.builder.body, self.builder.tcx)\n+                    .ty\n+                    .kind()\n             {\n                 if def.is_union() {\n                     place = PlaceRef { local: place.local, projection: proj_base }"}, {"sha": "0e16b0caefafa5f572e9f2bdab884c198ad499d2", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -47,7 +47,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::ReifyFnPointer) => {\n                 // The src operand does not matter, just its type\n-                match src.layout.ty.kind {\n+                match *src.layout.ty.kind() {\n                     ty::FnDef(def_id, substs) => {\n                         // All reifications must be monomorphic, bail out otherwise.\n                         ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n@@ -76,7 +76,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::UnsafeFnPointer) => {\n                 let src = self.read_immediate(src)?;\n-                match cast_ty.kind {\n+                match cast_ty.kind() {\n                     ty::FnPtr(_) => {\n                         // No change to value\n                         self.write_immediate(*src, dest)?;\n@@ -87,7 +87,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Pointer(PointerCast::ClosureFnPointer(_)) => {\n                 // The src operand does not matter, just its type\n-                match src.layout.ty.kind {\n+                match *src.layout.ty.kind() {\n                     ty::Closure(def_id, substs) => {\n                         // All reifications must be monomorphic, bail out otherwise.\n                         ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n@@ -116,7 +116,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n-        match src.layout.ty.kind {\n+        match src.layout.ty.kind() {\n             // Floating point\n             Float(FloatTy::F32) => {\n                 return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, cast_ty).into());\n@@ -196,9 +196,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n         trace!(\"cast_from_scalar: {}, {} -> {}\", v, src_layout.ty, cast_ty);\n         use rustc_middle::ty::TyKind::*;\n-        match cast_ty.kind {\n+        match *cast_ty.kind() {\n             Int(_) | Uint(_) | RawPtr(_) => {\n-                let size = match cast_ty.kind {\n+                let size = match *cast_ty.kind() {\n                     Int(t) => Integer::from_attr(self, attr::IntType::SignedInt(t)).size(),\n                     Uint(t) => Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size(),\n                     RawPtr(_) => self.pointer_size(),\n@@ -228,7 +228,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>,\n     {\n         use rustc_middle::ty::TyKind::*;\n-        match dest_ty.kind {\n+        match *dest_ty.kind() {\n             // float -> uint\n             Uint(t) => {\n                 let size = Integer::from_attr(self, attr::IntType::UnsignedInt(t)).size();\n@@ -267,7 +267,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (src_pointee_ty, dest_pointee_ty) =\n             self.tcx.struct_lockstep_tails_erasing_lifetimes(source_ty, cast_ty, self.param_env);\n \n-        match (&src_pointee_ty.kind, &dest_pointee_ty.kind) {\n+        match (&src_pointee_ty.kind(), &dest_pointee_ty.kind()) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n                 let ptr = self.read_immediate(src)?.to_scalar()?;\n                 // u64 cast is from usize to u64, which is always good\n@@ -303,7 +303,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"Unsizing {:?} of type {} into {:?}\", *src, src.layout.ty, cast_ty.ty);\n-        match (&src.layout.ty.kind, &cast_ty.ty.kind) {\n+        match (&src.layout.ty.kind(), &cast_ty.ty.kind()) {\n             (&ty::Ref(_, s, _), &ty::Ref(_, c, _) | &ty::RawPtr(TypeAndMut { ty: c, .. }))\n             | (&ty::RawPtr(TypeAndMut { ty: s, .. }), &ty::RawPtr(TypeAndMut { ty: c, .. })) => {\n                 self.unsize_into_ptr(src, dest, s, c)"}, {"sha": "f2f6c893eda4e912647e0153ef6ca20548918e12", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -534,7 +534,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if !layout.is_unsized() {\n             return Ok(Some((layout.size, layout.align.abi)));\n         }\n-        match layout.ty.kind {\n+        match layout.ty.kind() {\n             ty::Adt(..) | ty::Tuple(..) => {\n                 // First get the size of all statically known fields.\n                 // Don't use type_of::sizing_type_of because that expects t to be sized,"}, {"sha": "dd5e9c99774375a60d50864c07eb2189dc8ad2b4", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -195,13 +195,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n         // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n         let tcx = self.ecx.tcx;\n         let ty = mplace.layout.ty;\n-        if let ty::Ref(_, referenced_ty, ref_mutability) = ty.kind {\n+        if let ty::Ref(_, referenced_ty, ref_mutability) = *ty.kind() {\n             let value = self.ecx.read_immediate(mplace.into())?;\n             let mplace = self.ecx.ref_to_mplace(value)?;\n             assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n             if let ty::Dynamic(..) =\n-                tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n+                tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n                 // Validation will error (with a better message) on an invalid vtable pointer\n                 // so we can safely not do anything if this is not a real pointer.\n@@ -253,7 +253,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                         // This helps to prevent users from accidentally exploiting UB that they\n                         // caused (by somehow getting a mutable reference in a `const`).\n                         if ref_mutability == Mutability::Mut {\n-                            match referenced_ty.kind {\n+                            match referenced_ty.kind() {\n                                 ty::Array(_, n) if n.eval_usize(*tcx, self.ecx.param_env) == 0 => {}\n                                 ty::Slice(_)\n                                     if mplace.meta.unwrap_meta().to_machine_usize(self.ecx)?"}, {"sha": "3e0a7886f0835704570629bf134946d9acab72fa", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -76,7 +76,7 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             ConstValue::from_u64(tcx.type_id_hash(tp_ty))\n         }\n         sym::variant_count => {\n-            if let ty::Adt(ref adt, _) = tp_ty.kind {\n+            if let ty::Adt(ref adt, _) = tp_ty.kind() {\n                 ConstValue::from_machine_usize(adt.variants.len() as u64, &tcx)\n             } else {\n                 ConstValue::from_machine_usize(0u64, &tcx)"}, {"sha": "8c0014e10d0e61f7ceda9e0d4e52bb89590476ad", "filename": "compiler/rustc_mir/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     }\n \n     fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-        match ty.kind {\n+        match *ty.kind() {\n             // Types without identity.\n             ty::Bool\n             | ty::Char"}, {"sha": "57245696e576e601320c36663f2f79582b2c0d1d", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -662,7 +662,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let discr_val = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n                 let discr_bits = discr_val.assert_bits(discr_layout.size);\n                 // Convert discriminant to variant index, and catch invalid discriminants.\n-                let index = match op.layout.ty.kind {\n+                let index = match *op.layout.ty.kind() {\n                     ty::Adt(adt, _) => {\n                         adt.discriminants(*self.tcx).find(|(_, var)| var.val == discr_bits)\n                     }"}, {"sha": "fc266fa74bfa9d04765d298ce531fde5e9c2143e", "filename": "compiler/rustc_mir/src/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -282,7 +282,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             right.layout.ty\n         );\n \n-        match left.layout.ty.kind {\n+        match left.layout.ty.kind() {\n             ty::Char => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n                 let left = left.to_scalar()?;\n@@ -368,7 +368,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let val = val.to_scalar()?;\n         trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty);\n \n-        match layout.ty.kind {\n+        match layout.ty.kind() {\n             ty::Bool => {\n                 let val = val.to_bool()?;\n                 let res = match un_op {"}, {"sha": "9e16063bd21af2a0ca6bd656d273404914e58e7f", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -202,7 +202,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n     pub(super) fn len(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n         if self.layout.is_unsized() {\n             // We need to consult `meta` metadata\n-            match self.layout.ty.kind {\n+            match self.layout.ty.kind() {\n                 ty::Slice(..) | ty::Str => self.mplace.meta.unwrap_meta().to_machine_usize(cx),\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n@@ -218,7 +218,7 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n     #[inline]\n     pub(super) fn vtable(self) -> Scalar<Tag> {\n-        match self.layout.ty.kind {\n+        match self.layout.ty.kind() {\n             ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n             _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n         }\n@@ -498,7 +498,7 @@ where\n \n         // Compute meta and new layout\n         let inner_len = actual_to.checked_sub(from).unwrap();\n-        let (meta, ty) = match base.layout.ty.kind {\n+        let (meta, ty) = match base.layout.ty.kind() {\n             // It is not nice to match on the type, but that seems to be the only way to\n             // implement this.\n             ty::Array(inner, _) => (MemPlaceMeta::None, self.tcx.mk_array(inner, inner_len)),"}, {"sha": "d3c0b497a16755fbb4f477121e979ba4562666f0", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -55,7 +55,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n-                let (fn_val, abi) = match func.layout.ty.kind {\n+                let (fn_val, abi) = match *func.layout.ty.kind() {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n                         let fn_ptr = self.read_scalar(func)?.check_init()?;\n@@ -222,7 +222,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         {\n             let callee_abi = {\n                 let instance_ty = instance.ty(*self.tcx, self.param_env);\n-                match instance_ty.kind {\n+                match instance_ty.kind() {\n                     ty::FnDef(..) => instance_ty.fn_sig(*self.tcx).abi(),\n                     ty::Closure(..) => Abi::RustCall,\n                     ty::Generator(..) => Abi::Rust,\n@@ -431,7 +431,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // implementation fail -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n \n-        let (instance, place) = match place.layout.ty.kind {\n+        let (instance, place) = match place.layout.ty.kind() {\n             ty::Dynamic(..) => {\n                 // Dropping a trait object.\n                 self.unpack_dyn_trait(place)?"}, {"sha": "fc5a25ffbf251ab220864762960b38641b9adafe", "filename": "compiler/rustc_mir/src/interpret/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -33,7 +33,7 @@ where\n                 return false;\n             }\n \n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Param(_) => true,\n                 ty::Closure(def_id, substs)\n                 | ty::Generator(def_id, substs, ..)\n@@ -59,7 +59,7 @@ where\n                             // `ty::Param`/`ty::ConstKind::Param`.\n                             (false, true) if cfg!(debug_assertions) => match subst.unpack() {\n                                 ty::subst::GenericArgKind::Type(ty) => {\n-                                    assert!(matches!(ty.kind, ty::Param(_)))\n+                                    assert!(matches!(ty.kind(), ty::Param(_)))\n                                 }\n                                 ty::subst::GenericArgKind::Const(ct) => {\n                                     assert!(matches!(ct.val, ty::ConstKind::Param(_)))"}, {"sha": "ca62f0347ffacc6aef380e43e0f3c611d53ee80e", "filename": "compiler/rustc_mir/src/interpret/validity.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvalidity.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -214,7 +214,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         match layout.variants {\n             Variants::Multiple { tag_field, .. } => {\n                 if tag_field == field {\n-                    return match layout.ty.kind {\n+                    return match layout.ty.kind() {\n                         ty::Adt(def, ..) if def.is_enum() => PathElem::EnumTag,\n                         ty::Generator(..) => PathElem::GeneratorTag,\n                         _ => bug!(\"non-variant type {:?}\", layout.ty),\n@@ -225,7 +225,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         }\n \n         // Now we know we are projecting to a field, so figure out which one.\n-        match layout.ty.kind {\n+        match layout.ty.kind() {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let mut name = None;\n@@ -303,7 +303,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         pointee: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n-        match tail.kind {\n+        match tail.kind() {\n             ty::Dynamic(..) => {\n                 let vtable = meta.unwrap_meta();\n                 // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n@@ -477,7 +477,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     ) -> InterpResult<'tcx, bool> {\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Bool => {\n                 let value = self.ecx.read_scalar(value)?;\n                 try_validation!(\n@@ -692,7 +692,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         variant_id: VariantIdx,\n         new_op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        let name = match old_op.layout.ty.kind {\n+        let name = match old_op.layout.ty.kind() {\n             ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n             // Generators also have variants\n             ty::Generator(..) => PathElem::GeneratorState(variant_id),\n@@ -762,7 +762,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         op: OpTy<'tcx, M::PointerTag>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n-        match op.layout.ty.kind {\n+        match op.layout.ty.kind() {\n             ty::Str => {\n                 let mplace = op.assert_mem_place(self.ecx); // strings are never immediate\n                 let len = mplace.len(self.ecx)?;\n@@ -779,7 +779,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     // FIXME(wesleywiser) This logic could be extended further to arbitrary structs\n                     // or tuples made up of integer/floating point types or inhabited ZSTs with no\n                     // padding.\n-                    match tys.kind {\n+                    match tys.kind() {\n                         ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n                         _ => false,\n                     }"}, {"sha": "097b9ae6ca1cd43c53ecd2f5965265bf7234304d", "filename": "compiler/rustc_mir/src/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fvisitor.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -203,7 +203,7 @@ macro_rules! make_value_visitor {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n \n                 // Special treatment for special types, where the (static) layout is not sufficient.\n-                match v.layout().ty.kind {\n+                match *v.layout().ty.kind() {\n                     // If it is a trait object, switch to the real type that was used to create it.\n                     ty::Dynamic(..) => {\n                         // immediate trait objects are not a thing"}, {"sha": "9ea103463d5ebd8b63656f2b0d7f9ad6f58cb105", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -575,7 +575,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             ) => {\n                 let source_ty = operand.ty(self.body, self.tcx);\n                 let source_ty = self.monomorphize(source_ty);\n-                match source_ty.kind {\n+                match *source_ty.kind() {\n                     ty::Closure(def_id, substs) => {\n                         let instance = Instance::resolve_closure(\n                             self.tcx,\n@@ -716,7 +716,7 @@ fn visit_fn_use<'tcx>(\n     source: Span,\n     output: &mut Vec<Spanned<MonoItem<'tcx>>>,\n ) {\n-    if let ty::FnDef(def_id, substs) = ty.kind {\n+    if let ty::FnDef(def_id, substs) = *ty.kind() {\n         let instance = if is_direct_call {\n             ty::Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap().unwrap()\n         } else {\n@@ -853,7 +853,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n                 return false;\n             }\n             let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);\n-            match tail.kind {\n+            match tail.kind() {\n                 ty::Foreign(..) => false,\n                 ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n                 _ => bug!(\"unexpected unsized tail: {:?}\", tail),\n@@ -866,7 +866,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n         }\n     };\n \n-    match (&source_ty.kind, &target_ty.kind) {\n+    match (&source_ty.kind(), &target_ty.kind()) {\n         (&ty::Ref(_, a, _), &ty::Ref(_, b, _) | &ty::RawPtr(ty::TypeAndMut { ty: b, .. }))\n         | (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }), &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n             ptr_vtable(a, b)\n@@ -922,7 +922,7 @@ fn create_mono_items_for_vtable_methods<'tcx>(\n ) {\n     assert!(!trait_ty.has_escaping_bound_vars() && !impl_ty.has_escaping_bound_vars());\n \n-    if let ty::Dynamic(ref trait_ty, ..) = trait_ty.kind {\n+    if let ty::Dynamic(ref trait_ty, ..) = trait_ty.kind() {\n         if let Some(principal) = trait_ty.principal() {\n             let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n             assert!(!poly_trait_ref.has_escaping_bound_vars());"}, {"sha": "3f6f117acdc1c2a95d93837575e007026f3a3469", "filename": "compiler/rustc_mir/src/monomorphize/polymorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n             return false;\n         }\n \n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Closure(def_id, substs) | ty::Generator(def_id, substs, ..) => {\n                 debug!(\"visit_ty: def_id={:?}\", def_id);\n                 // Avoid cycle errors with generators.\n@@ -337,7 +337,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n             return false;\n         }\n \n-        match ty.kind {\n+        match ty.kind() {\n             ty::Param(param) => !self.unused_parameters.contains(param.index).unwrap_or(false),\n             _ => ty.super_visit_with(self),\n         }"}, {"sha": "bfe0b85b5b1e2abd292adc0067742a0282f872ad", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -149,7 +149,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n     // Check if this is a generator, if so, return the drop glue for it\n-    if let Some(&ty::TyS { kind: ty::Generator(gen_def_id, substs, _), .. }) = ty {\n+    if let Some(&ty::Generator(gen_def_id, substs, _)) = ty.map(|ty| ty.kind()) {\n         let body = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n         return body.subst(tcx, substs);\n     }\n@@ -312,7 +312,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let dest = Place::return_place();\n     let src = tcx.mk_place_deref(Place::from(Local::new(1 + 0)));\n \n-    match self_ty.kind {\n+    match self_ty.kind() {\n         _ if is_copy => builder.copy_shim(),\n         ty::Array(ty, len) => {\n             let len = len.eval_usize(tcx, param_env);\n@@ -853,7 +853,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n     let sig = tcx.fn_sig(ctor_id).no_bound_vars().expect(\"LBR in ADT constructor signature\");\n     let sig = tcx.normalize_erasing_regions(param_env, sig);\n \n-    let (adt_def, substs) = match sig.output().kind {\n+    let (adt_def, substs) = match sig.output().kind() {\n         ty::Adt(adt_def, substs) => (adt_def, substs),\n         _ => bug!(\"unexpected type for ADT ctor {:?}\", sig.output()),\n     };"}, {"sha": "0c596ba71549f93a91053d534a58188670da66ca", "filename": "compiler/rustc_mir/src/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -35,7 +35,7 @@ fn is_stable(place: PlaceRef<'_>) -> bool {\n \n /// Determine whether this type may be a reference (or box), and thus needs retagging.\n fn may_be_reference(ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         // Primitive types that are not references\n         ty::Bool\n         | ty::Char"}, {"sha": "3f4b3ca2eedb464748edb3c6bcf807a954144457", "filename": "compiler/rustc_mir/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -170,7 +170,7 @@ where\n             // Special-case reborrows to be more like a copy of the reference.\n             if let &[ref proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n                 let base_ty = Place::ty_from(place.local, proj_base, cx.body, cx.tcx).ty;\n-                if let ty::Ref(..) = base_ty.kind {\n+                if let ty::Ref(..) = base_ty.kind() {\n                     return in_place::<Q, _>(\n                         cx,\n                         in_local,"}, {"sha": "e8411b121e394b59e81aa1f49a17c49e346a46e0", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -321,7 +321,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n             | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place) => {\n                 let ty = place.ty(self.body, self.tcx).ty;\n-                let is_allowed = match ty.kind {\n+                let is_allowed = match ty.kind() {\n                     // Inside a `static mut`, `&mut [...]` is allowed.\n                     ty::Array(..) | ty::Slice(_)\n                         if self.const_kind() == hir::ConstContext::Static(hir::Mutability::Mut) =>\n@@ -374,7 +374,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -426,7 +426,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n         match elem {\n             ProjectionElem::Deref => {\n                 let base_ty = Place::ty_from(place_local, proj_base, self.body, self.tcx).ty;\n-                if let ty::RawPtr(_) = base_ty.kind {\n+                if let ty::RawPtr(_) = base_ty.kind() {\n                     if proj_base.is_empty() {\n                         if let (local, []) = (place_local, proj_base) {\n                             let decl = &self.body.local_decls[local];\n@@ -498,7 +498,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             TerminatorKind::Call { func, .. } => {\n                 let fn_ty = func.ty(self.body, self.tcx);\n \n-                let (def_id, substs) = match fn_ty.kind {\n+                let (def_id, substs) = match *fn_ty.kind() {\n                     ty::FnDef(def_id, substs) => (def_id, substs),\n \n                     ty::FnPtr(_) => {\n@@ -647,7 +647,7 @@ fn place_as_reborrow(\n         // This is sufficient to prevent an access to a `static mut` from being marked as a\n         // reborrow, even if the check above were to disappear.\n         let inner_ty = Place::ty_from(place.local, inner, body, tcx).ty;\n-        match inner_ty.kind {\n+        match inner_ty.kind() {\n             ty::Ref(..) => Some(inner),\n             _ => None,\n         }"}, {"sha": "7309a4129e46895954d17eb2b43b5fc8f8303628", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -91,8 +91,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     )\n                 }\n \n-                if let ty::FnDef(func_id, _) = func_ty.kind {\n-                    self.check_target_features(func_id);\n+                if let ty::FnDef(func_id, _) = func_ty.kind() {\n+                    self.check_target_features(*func_id);\n                 }\n             }\n \n@@ -227,7 +227,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n             }\n             let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n-            match base_ty.kind {\n+            match base_ty.kind() {\n                 ty::RawPtr(..) => self.require_unsafe(\n                     UnsafetyViolationKind::GeneralAndConstFn,\n                     UnsafetyViolationDetails::DerefOfRawPointer,\n@@ -394,7 +394,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 ProjectionElem::Field(..) => {\n                     let ty =\n                         Place::ty_from(place.local, proj_base, &self.body.local_decls, self.tcx).ty;\n-                    if let ty::Adt(def, _) = ty.kind {\n+                    if let ty::Adt(def, _) = ty.kind() {\n                         if self.tcx.layout_scalar_valid_range(def.did)\n                             != (Bound::Unbounded, Bound::Unbounded)\n                         {"}, {"sha": "aa88719c26a4936d386e55a03400d8555fb334af", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -832,7 +832,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // FIXME: enable the general case stated above ^.\n                     let ty = &value.layout.ty;\n                     // Only do it for tuples\n-                    if let ty::Tuple(substs) = ty.kind {\n+                    if let ty::Tuple(substs) = ty.kind() {\n                         // Only do it if tuple is also a pair with two scalars\n                         if substs.len() == 2 {\n                             let alloc = self.use_ecx(|this| {"}, {"sha": "78cedec502007a697e357a144e3e5cea8ce403e8", "filename": "compiler/rustc_mir/src/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fgenerator.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -726,12 +726,12 @@ fn sanitize_witness<'tcx>(\n     saved_locals: &GeneratorSavedLocals,\n ) {\n     let allowed_upvars = tcx.erase_regions(upvars);\n-    let allowed = match witness.kind {\n+    let allowed = match witness.kind() {\n         ty::GeneratorWitness(s) => tcx.erase_late_bound_regions(&s),\n         _ => {\n             tcx.sess.delay_span_bug(\n                 body.span,\n-                &format!(\"unexpected generator witness type {:?}\", witness.kind),\n+                &format!(\"unexpected generator witness type {:?}\", witness.kind()),\n             );\n             return;\n         }\n@@ -1252,7 +1252,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         let gen_ty = body.local_decls.raw[1].ty;\n \n         // Get the interior types and substs which typeck computed\n-        let (upvars, interior, discr_ty, movable) = match gen_ty.kind {\n+        let (upvars, interior, discr_ty, movable) = match *gen_ty.kind() {\n             ty::Generator(_, substs, movability) => {\n                 let substs = substs.as_generator();\n                 ("}, {"sha": "0a3424bb94452f0ab9c68c1f007496cc5615a80c", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -197,7 +197,7 @@ impl Inliner<'tcx> {\n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n-            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_body, self.tcx).kind {\n+            if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n                 let instance =\n                     Instance::resolve(self.tcx, param_env, callee_def_id, substs).ok().flatten()?;\n \n@@ -342,7 +342,7 @@ impl Inliner<'tcx> {\n                 }\n \n                 TerminatorKind::Call { func: Operand::Constant(ref f), cleanup, .. } => {\n-                    if let ty::FnDef(def_id, _) = f.literal.ty.kind {\n+                    if let ty::FnDef(def_id, _) = *f.literal.ty.kind() {\n                         // Don't give intrinsics the extra penalty for calls\n                         let f = tcx.fn_sig(def_id);\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {\n@@ -574,7 +574,7 @@ impl Inliner<'tcx> {\n             assert!(args.next().is_none());\n \n             let tuple = Place::from(tuple);\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.kind {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.kind() {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");"}, {"sha": "c6474ba2d7328f85d8b43e77f257d1f5b67f0a93", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -91,15 +91,15 @@ impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n             {\n                 // The dereferenced place must have type `&_`.\n                 let ty = Place::ty_from(local, proj_base, self.body, self.tcx).ty;\n-                if let ty::Ref(_, _, Mutability::Not) = ty.kind {\n+                if let ty::Ref(_, _, Mutability::Not) = ty.kind() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }\n         }\n \n         if let Rvalue::Len(ref place) = *rvalue {\n             let place_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-            if let ty::Array(_, len) = place_ty.kind {\n+            if let ty::Array(_, len) = place_ty.kind() {\n                 let span = self.body.source_info(location).span;\n                 let constant = Constant { span, literal: len, user_ty: None };\n                 self.optimizations.arrays_lengths.insert(location, constant);"}, {"sha": "852629a45f7a01662e0ac11526870d62cf674223", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -220,7 +220,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n \n         match terminator.kind {\n             TerminatorKind::Call { ref func, .. } => {\n-                if let ty::FnDef(def_id, _) = func.ty(self.ccx.body, self.ccx.tcx).kind {\n+                if let ty::FnDef(def_id, _) = *func.ty(self.ccx.body, self.ccx.tcx).kind() {\n                     let fn_sig = self.ccx.tcx.fn_sig(def_id);\n                     if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = fn_sig.abi() {\n                         let name = self.ccx.tcx.item_name(def_id);\n@@ -368,11 +368,11 @@ impl<'tcx> Validator<'_, 'tcx> {\n                                 == Some(hir::ConstContext::Static(hir::Mutability::Mut))\n                             {\n                                 // Inside a `static mut`, &mut [...] is also allowed.\n-                                match ty.kind {\n+                                match ty.kind() {\n                                     ty::Array(..) | ty::Slice(_) => {}\n                                     _ => return Err(Unpromotable),\n                                 }\n-                            } else if let ty::Array(_, len) = ty.kind {\n+                            } else if let ty::Array(_, len) = ty.kind() {\n                                 // FIXME(eddyb) the `self.is_non_const_fn` condition\n                                 // seems unnecessary, given that this is merely a ZST.\n                                 match len.try_eval_usize(self.tcx, self.param_env) {\n@@ -613,7 +613,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if self.const_kind.is_none() => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n                     assert!(\n                         op == BinOp::Eq\n                             || op == BinOp::Ne\n@@ -656,7 +656,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // so are allowed.\n                 if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n                     let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n+                    if let ty::Ref(..) = base_ty.kind() {\n                         return self.validate_place(PlaceRef {\n                             local: place.local,\n                             projection: proj_base,\n@@ -675,11 +675,11 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // is allowed right now, and only in functions.\n                     if self.const_kind == Some(hir::ConstContext::Static(hir::Mutability::Mut)) {\n                         // Inside a `static mut`, &mut [...] is also allowed.\n-                        match ty.kind {\n+                        match ty.kind() {\n                             ty::Array(..) | ty::Slice(_) => {}\n                             _ => return Err(Unpromotable),\n                         }\n-                    } else if let ty::Array(_, len) = ty.kind {\n+                    } else if let ty::Array(_, len) = ty.kind() {\n                         // FIXME(eddyb): We only return `Unpromotable` for `&mut []` inside a\n                         // const context which seems unnecessary given that this is merely a ZST.\n                         match len.try_eval_usize(self.tcx, self.param_env) {\n@@ -695,7 +695,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let mut place = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place.projection {\n                     let base_ty = Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n+                    if let ty::Ref(..) = base_ty.kind() {\n                         place = PlaceRef { local: place.local, projection: proj_base };\n                     }\n                 }\n@@ -749,7 +749,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n         if !self.explicit && self.const_kind.is_none() {\n-            if let ty::FnDef(def_id, _) = fn_ty.kind {\n+            if let ty::FnDef(def_id, _) = *fn_ty.kind() {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n                 if !self.tcx.is_promotable_const_fn(def_id) {\n@@ -758,7 +758,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             }\n         }\n \n-        let is_const_fn = match fn_ty.kind {\n+        let is_const_fn = match *fn_ty.kind() {\n             ty::FnDef(def_id, _) => {\n                 is_const_fn(self.tcx, def_id)\n                     || is_unstable_const_fn(self.tcx, def_id).is_some()"}, {"sha": "7d9611e07311dd18d44d711d5fd3cdbafb7dfcd3", "filename": "compiler/rustc_mir/src/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -44,7 +44,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n-                    match pred.self_ty().kind {\n+                    match pred.self_ty().kind() {\n                         ty::Param(ref p) => {\n                             // Allow `T: ?const Trait`\n                             if constness == hir::Constness::NotConst\n@@ -106,7 +106,7 @@ fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> Mc\n             GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n         };\n \n-        match ty.kind {\n+        match ty.kind() {\n             ty::Ref(_, _, hir::Mutability::Mut) => {\n                 if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {\n                     return Err((span, \"mutable references in const fn are unstable\".into()));\n@@ -203,7 +203,7 @@ fn check_rvalue(\n                 ));\n             };\n             let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n-            if let ty::Slice(_) | ty::Str = unsized_ty.kind {\n+            if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n                 check_operand(tcx, op, span, def_id, body)?;\n                 // Casting/coercing things to slices is fine.\n                 Ok(())\n@@ -406,7 +406,7 @@ fn check_terminator(\n             fn_span: _,\n         } => {\n             let fn_ty = func.ty(body, tcx);\n-            if let ty::FnDef(fn_def_id, _) = fn_ty.kind {\n+            if let ty::FnDef(fn_def_id, _) = *fn_ty.kind() {\n                 // Allow unstable const if we opt in by using #[allow_internal_unstable]\n                 // on function or macro declaration.\n                 if !crate::const_eval::is_min_const_fn(tcx, fn_def_id)"}, {"sha": "242192e75b4b77621d04254d3a99fe10707653ea", "filename": "compiler/rustc_mir/src/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Frustc_peek.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -180,7 +180,7 @@ enum PeekCallKind {\n \n impl PeekCallKind {\n     fn from_arg_ty(arg: Ty<'_>) -> Self {\n-        match arg.kind {\n+        match arg.kind() {\n             ty::Ref(_, _, _) => PeekCallKind::ByRef,\n             _ => PeekCallKind::ByVal,\n         }\n@@ -205,7 +205,7 @@ impl PeekCall {\n         if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n             &terminator.kind\n         {\n-            if let ty::FnDef(def_id, substs) = func.literal.ty.kind {\n+            if let ty::FnDef(def_id, substs) = *func.literal.ty.kind() {\n                 let sig = tcx.fn_sig(def_id);\n                 let name = tcx.item_name(def_id);\n                 if sig.abi() != Abi::RustIntrinsic || name != sym::rustc_peek {"}, {"sha": "5c9a191e9053596dc6f59e2216241821258a8b53", "filename": "compiler/rustc_mir/src/transform/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_try.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -682,7 +682,7 @@ impl<'a, 'tcx> SimplifyBranchSameOptimizationFinder<'a, 'tcx> {\n                       variant_index: &VariantIdx,\n                       side_to_choose| {\n             let place_type = place.ty(self.body, self.tcx).ty;\n-            let adt = match place_type.kind {\n+            let adt = match *place_type.kind() {\n                 ty::Adt(adt, _) if adt.is_enum() => adt,\n                 _ => return StatementEquality::NotEqual,\n             };"}, {"sha": "8f01e9428011663ccf7fc237ef4588fe10558e43", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Call { func, destination, cleanup, .. } => {\n                 let func_ty = func.ty(&self.body.local_decls, self.tcx);\n-                match func_ty.kind {\n+                match func_ty.kind() {\n                     ty::FnPtr(..) | ty::FnDef(..) => {}\n                     _ => self.fail(\n                         location,"}, {"sha": "a0728a6a6301504bdb85d4498159ce3ae185c4eb", "filename": "compiler/rustc_mir/src/util/alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Falignment.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -47,7 +47,7 @@ where\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n                 let ty = Place::ty_from(place.local, proj_base, local_decls, tcx).ty;\n-                match ty.kind {\n+                match ty.kind() {\n                     ty::Adt(def, _) if def.repr.packed() => return true,\n                     _ => {}\n                 }"}, {"sha": "83bf7584f2e2fc84f0e314e603155904bdb474f1", "filename": "compiler/rustc_mir/src/util/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fborrowck_errors.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -287,7 +287,7 @@ impl<'cx, 'tcx> crate::borrow_check::MirBorrowckCtxt<'cx, 'tcx> {\n         ty: Ty<'_>,\n         is_index: Option<bool>,\n     ) -> DiagnosticBuilder<'cx> {\n-        let type_name = match (&ty.kind, is_index) {\n+        let type_name = match (&ty.kind(), is_index) {\n             (&ty::Array(_, _), Some(true)) | (&ty::Array(_, _), None) => \"array\",\n             (&ty::Slice(_), _) => \"slice\",\n             _ => span_bug!(move_from_span, \"this path should not cause illegal move\"),"}, {"sha": "bf0a6be9a7d8e54ad0e87a770cd9d4f83036b8fb", "filename": "compiler/rustc_mir/src/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Felaborate_drops.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -858,7 +858,7 @@ where\n     /// ADT, both in the success case or if one of the destructors fail.\n     fn open_drop(&mut self) -> BasicBlock {\n         let ty = self.place_ty(self.place);\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Closure(_, substs) => {\n                 let tys: Vec<_> = substs.as_closure().upvar_tys().collect();\n                 self.open_drop_for_tuple(&tys)"}, {"sha": "54bc248bc5b4a52c9278f278bc4b279cc7f9a0ae", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -398,7 +398,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n         self.super_constant(constant, location);\n         let Constant { span, user_ty, literal } = constant;\n-        match literal.ty.kind {\n+        match literal.ty.kind() {\n             ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char => {}\n             // Unit type\n             ty::Tuple(tys) if tys.is_empty() => {}\n@@ -416,7 +416,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n     fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n         self.super_const(constant);\n         let ty::Const { ty, val, .. } = constant;\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => {}\n             // Unit type\n             ty::Tuple(tys) if tys.is_empty() => {}"}, {"sha": "39dbb6dd3ff924a6e4a84e6ff7a5cbac50e2b4cc", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let tcx = self.hir.tcx();\n         let place_ty =\n             Place::ty_from(base_place.local, &base_place.projection, &self.local_decls, tcx);\n-        if let ty::Slice(_) = place_ty.ty.kind {\n+        if let ty::Slice(_) = place_ty.ty.kind() {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n             // unsized values, we only need to ensure that none of the\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             &self.local_decls,\n                             tcx,\n                         );\n-                        match index_ty.ty.kind {\n+                        match index_ty.ty.kind() {\n                             // The previous index expression has already\n                             // done any index expressions needed here.\n                             ty::Slice(_) => break,"}, {"sha": "319fae5009e099624804b8ad3bb12521dc9e0f2d", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 exit_block.unit()\n             }\n             ExprKind::Call { ty, fun, args, from_hir_call, fn_span } => {\n-                let intrinsic = match ty.kind {\n+                let intrinsic = match *ty.kind() {\n                     ty::FnDef(def_id, _) => {\n                         let f = ty.fn_sig(this.hir.tcx());\n                         if f.abi() == Abi::RustIntrinsic || f.abi() == Abi::PlatformIntrinsic {"}, {"sha": "a28a181e93504a2acb27c88720931a1241b10540", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Range(PatRange { lo, hi, end }) => {\n-                let (range, bias) = match lo.ty.kind {\n+                let (range, bias) = match *lo.ty.kind() {\n                     ty::Char => {\n                         (Some(('\\u{0000}' as u128, '\\u{10FFFF}' as u128, Size::from_bits(32))), 0)\n                     }"}, {"sha": "d81c3b68f4853d27f3c1ce63d821a9b3f64013d4", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -215,7 +215,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             TestKind::SwitchInt { switch_ty, ref options } => {\n                 let target_blocks = make_target_blocks(self);\n-                let terminator = if switch_ty.kind == ty::Bool {\n+                let terminator = if *switch_ty.kind() == ty::Bool {\n                     assert!(!options.is_empty() && options.len() <= 2);\n                     if let [first_bb, second_bb] = *target_blocks {\n                         let (true_bb, false_bb) = match options[0] {\n@@ -368,8 +368,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // We want to do this even when the scrutinee is a reference to an\n         // array, so we can call `<[u8]>::eq` rather than having to find an\n         // `<[u8; N]>::eq`.\n-        let unsize = |ty: Ty<'tcx>| match ty.kind {\n-            ty::Ref(region, rty, _) => match rty.kind {\n+        let unsize = |ty: Ty<'tcx>| match ty.kind() {\n+            ty::Ref(region, rty, _) => match rty.kind() {\n                 ty::Array(inner_ty, n) => Some((region, inner_ty, n)),\n                 _ => None,\n             },\n@@ -407,7 +407,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let deref_ty = match ty.kind {\n+        let deref_ty = match *ty.kind() {\n             ty::Ref(_, deref_ty, _) => deref_ty,\n             _ => bug!(\"non_scalar_compare called on non-reference type: {}\", ty),\n         };"}, {"sha": "d6e828c966a95de5b28eb875b8d1f50c4d067eb1", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         suffix: &'pat [Pat<'tcx>],\n     ) {\n         let tcx = self.hir.tcx();\n-        let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind {\n+        let (min_length, exact_size) = match place.ty(&self.local_decls, tcx).ty.kind() {\n             ty::Array(_, length) => {\n                 (length.eval_usize(tcx, self.hir.param_env).try_into().unwrap(), true)\n             }"}, {"sha": "aa96ae8759154c66b6f17841157dde7158335b5c", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -96,7 +96,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             let body = tcx.hir().body(body_id);\n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n-            let implicit_argument = match ty.kind {\n+            let implicit_argument = match ty.kind() {\n                 ty::Closure(..) => {\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n@@ -159,7 +159,7 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n \n             let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n                 let gen_ty = tcx.typeck_body(body_id).node_type(id);\n-                let gen_sig = match gen_ty.kind {\n+                let gen_sig = match gen_ty.kind() {\n                     ty::Generator(_, gen_substs, ..) => gen_substs.as_generator().sig(),\n                     _ => span_bug!(tcx.hir().span(id), \"generator w/o generator type: {:?}\", ty),\n                 };\n@@ -228,7 +228,7 @@ fn liberated_closure_env_ty(\n ) -> Ty<'_> {\n     let closure_ty = tcx.typeck_body(body_id).node_type(closure_expr_id);\n \n-    let (closure_def_id, closure_substs) = match closure_ty.kind {\n+    let (closure_def_id, closure_substs) = match *closure_ty.kind() {\n         ty::Closure(closure_def_id, closure_substs) => (closure_def_id, closure_substs),\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty),\n     };\n@@ -840,11 +840,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let closure_env_arg = Local::new(1);\n             let mut closure_env_projs = vec![];\n             let mut closure_ty = self.local_decls[closure_env_arg].ty;\n-            if let ty::Ref(_, ty, _) = closure_ty.kind {\n+            if let ty::Ref(_, ty, _) = closure_ty.kind() {\n                 closure_env_projs.push(ProjectionElem::Deref);\n                 closure_ty = ty;\n             }\n-            let upvar_substs = match closure_ty.kind {\n+            let upvar_substs = match closure_ty.kind() {\n                 ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n                 ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n                 _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),"}, {"sha": "22ce278cee02cbe91c51c227c9bf840aead58522", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -70,7 +70,7 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n         let param_env = tcx.param_env(def_id);\n \n         let func_ty = func.ty(body, tcx);\n-        if let ty::FnDef(fn_def_id, substs) = func_ty.kind {\n+        if let ty::FnDef(fn_def_id, substs) = *func_ty.kind() {\n             let (call_fn_id, call_substs) =\n                 if let Ok(Some(instance)) = Instance::resolve(tcx, param_env, fn_def_id, substs) {\n                     (instance.def_id(), instance.substs)"}, {"sha": "a7bb2864dafa0d032794af755a03ac01de4596e9", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -2,7 +2,7 @@ use rustc_ast as ast;\n use rustc_middle::mir::interpret::{\n     truncate, Allocation, ConstValue, LitToConstError, LitToConstInput, Scalar,\n };\n-use rustc_middle::ty::{self, ParamEnv, TyCtxt, TyS};\n+use rustc_middle::ty::{self, ParamEnv, TyCtxt};\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::Size;\n \n@@ -21,19 +21,21 @@ crate fn lit_to_const<'tcx>(\n         Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n     };\n \n-    let lit = match (lit, &ty.kind) {\n-        (ast::LitKind::Str(s, _), ty::Ref(_, TyS { kind: ty::Str, .. }, _)) => {\n+    let lit = match (lit, &ty.kind()) {\n+        (ast::LitKind::Str(s, _), ty::Ref(_, inner_ty, _)) if inner_ty.is_str() => {\n             let s = s.as_str();\n             let allocation = Allocation::from_byte_aligned_bytes(s.as_bytes());\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: s.len() }\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, TyS { kind: ty::Slice(_), .. }, _)) => {\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _))\n+            if matches!(inner_ty.kind(), ty::Slice(_)) =>\n+        {\n             let allocation = Allocation::from_byte_aligned_bytes(data as &Vec<u8>);\n             let allocation = tcx.intern_const_alloc(allocation);\n             ConstValue::Slice { data: allocation, start: 0, end: data.len() }\n         }\n-        (ast::LitKind::ByteStr(data), ty::Ref(_, TyS { kind: ty::Array(_, _), .. }, _)) => {\n+        (ast::LitKind::ByteStr(data), ty::Ref(_, inner_ty, _)) if inner_ty.is_array() => {\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n         }"}, {"sha": "e9e49d054b88db47ea364004b429994b8bfed481", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -313,7 +313,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             }\n         }\n \n-        hir::ExprKind::Struct(ref qpath, ref fields, ref base) => match expr_ty.kind {\n+        hir::ExprKind::Struct(ref qpath, ref fields, ref base) => match expr_ty.kind() {\n             ty::Adt(adt, substs) => match adt.adt_kind() {\n                 AdtKind::Struct | AdtKind::Union => {\n                     let user_provided_types = cx.typeck_results().user_provided_types();\n@@ -363,7 +363,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         hir::ExprKind::Closure(..) => {\n             let closure_ty = cx.typeck_results().expr_ty(expr);\n-            let (def_id, substs, movability) = match closure_ty.kind {\n+            let (def_id, substs, movability) = match *closure_ty.kind() {\n                 ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs), None),\n                 ty::Generator(def_id, substs, movability) => {\n                     (def_id, UpvarSubsts::Generator(substs), Some(movability))\n@@ -818,7 +818,7 @@ fn convert_path_expr<'a, 'tcx>(\n             let user_provided_type = user_provided_types.get(expr.hir_id).copied();\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n             let ty = cx.typeck_results().node_type(expr.hir_id);\n-            match ty.kind {\n+            match ty.kind() {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::Adt(adt_def, substs) => ExprKind::Adt {\n@@ -899,7 +899,7 @@ fn convert_var<'tcx>(\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.kind {\n+            let self_expr = if let ty::Closure(_, closure_substs) = closure_ty.kind() {\n                 match cx.infcx.closure_kind(closure_substs).unwrap() {\n                     ty::ClosureKind::Fn => {\n                         let ref_closure_ty = cx.tcx.mk_ref(\n@@ -1027,7 +1027,7 @@ fn overloaded_place<'a, 'tcx>(\n     // Reconstruct the output assuming it's a reference with the\n     // same region and mutability as the receiver. This holds for\n     // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-    let (region, mutbl) = match recv_ty.kind {\n+    let (region, mutbl) = match *recv_ty.kind() {\n         ty::Ref(region, _, mutbl) => (region, mutbl),\n         _ => span_bug!(expr.span, \"overloaded_place: receiver is not a reference\"),\n     };"}, {"sha": "ad94740c160669f157ceeb6d0af32c454e733108", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> LiteralExpander<'tcx> {\n         crty: Ty<'tcx>,\n     ) -> ConstValue<'tcx> {\n         debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n-        match (val, &crty.kind, &rty.kind) {\n+        match (val, &crty.kind(), &rty.kind()) {\n             // the easy case, deref a reference\n             (ConstValue::Scalar(p), x, y) if x == y => {\n                 match p {\n@@ -368,41 +368,35 @@ impl<'tcx> LiteralExpander<'tcx> {\n \n impl<'tcx> PatternFolder<'tcx> for LiteralExpander<'tcx> {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n-        debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind, pat.kind);\n-        match (&pat.ty.kind, &*pat.kind) {\n-            (\n-                &ty::Ref(_, rty, _),\n-                &PatKind::Constant {\n-                    value:\n-                        Const {\n-                            val: ty::ConstKind::Value(val),\n-                            ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n-                        },\n-                },\n-            ) => Pat {\n-                ty: pat.ty,\n-                span: pat.span,\n-                kind: box PatKind::Deref {\n-                    subpattern: Pat {\n-                        ty: rty,\n+        debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n+        match (pat.ty.kind(), &*pat.kind) {\n+            (&ty::Ref(_, rty, _), &PatKind::Constant { value: Const { val, ty: const_ty } })\n+                if const_ty.is_ref() =>\n+            {\n+                let crty =\n+                    if let ty::Ref(_, crty, _) = const_ty.kind() { crty } else { unreachable!() };\n+                if let ty::ConstKind::Value(val) = val {\n+                    Pat {\n+                        ty: pat.ty,\n                         span: pat.span,\n-                        kind: box PatKind::Constant {\n-                            value: Const::from_value(\n-                                self.tcx,\n-                                self.fold_const_value_deref(*val, rty, crty),\n-                                rty,\n-                            ),\n+                        kind: box PatKind::Deref {\n+                            subpattern: Pat {\n+                                ty: rty,\n+                                span: pat.span,\n+                                kind: box PatKind::Constant {\n+                                    value: Const::from_value(\n+                                        self.tcx,\n+                                        self.fold_const_value_deref(*val, rty, crty),\n+                                        rty,\n+                                    ),\n+                                },\n+                            },\n                         },\n-                    },\n-                },\n-            },\n-\n-            (\n-                &ty::Ref(_, rty, _),\n-                &PatKind::Constant {\n-                    value: Const { val, ty: ty::TyS { kind: ty::Ref(_, crty, _), .. } },\n-                },\n-            ) => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n+                    }\n+                } else {\n+                    bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty)\n+                }\n+            }\n \n             (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n             (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n@@ -639,7 +633,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n     crate fn is_foreign_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Adt(def, ..) => {\n                 def.is_enum() && def.is_variant_list_non_exhaustive() && !def.did.is_local()\n             }\n@@ -920,14 +914,14 @@ impl<'tcx> Constructor<'tcx> {\n         let mut subpatterns = fields.all_patterns();\n \n         let pat = match self {\n-            Single | Variant(_) => match ty.kind {\n+            Single | Variant(_) => match ty.kind() {\n                 ty::Adt(..) | ty::Tuple(..) => {\n                     let subpatterns = subpatterns\n                         .enumerate()\n                         .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n                         .collect();\n \n-                    if let ty::Adt(adt, substs) = ty.kind {\n+                    if let ty::Adt(adt, substs) = ty.kind() {\n                         if adt.is_enum() {\n                             PatKind::Variant {\n                                 adt_def: adt,\n@@ -1074,7 +1068,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         let wildcard_from_ty = |ty| &*cx.pattern_arena.alloc(Pat::wildcard_from_ty(ty));\n \n         let ret = match constructor {\n-            Single | Variant(_) => match ty.kind {\n+            Single | Variant(_) => match ty.kind() {\n                 ty::Tuple(ref fs) => {\n                     Fields::wildcards_from_tys(cx, fs.into_iter().map(|ty| ty.expect_ty()))\n                 }\n@@ -1125,7 +1119,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => Fields::empty(),\n             },\n-            Slice(slice) => match ty.kind {\n+            Slice(slice) => match *ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n                     Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n@@ -1443,7 +1437,7 @@ fn all_constructors<'a, 'tcx>(\n                 .unwrap(),\n         )\n     };\n-    match pcx.ty.kind {\n+    match *pcx.ty.kind() {\n         ty::Bool => {\n             [true, false].iter().map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b))).collect()\n         }\n@@ -1558,7 +1552,7 @@ struct IntRange<'tcx> {\n impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn is_integral(ty: Ty<'_>) -> bool {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Char | ty::Int(_) | ty::Uint(_) => true,\n             _ => false,\n         }\n@@ -1580,7 +1574,7 @@ impl<'tcx> IntRange<'tcx> {\n \n     #[inline]\n     fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Char => Some((Size::from_bytes(4), 0)),\n             ty::Int(ity) => {\n                 let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n@@ -1658,7 +1652,7 @@ impl<'tcx> IntRange<'tcx> {\n \n     // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n     fn signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> u128 {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Int(ity) => {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n                 1u128 << (bits - 1)\n@@ -2070,7 +2064,7 @@ fn pat_constructor<'tcx>(\n             if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n                 Some(IntRange(int_range))\n             } else {\n-                match (value.val, &value.ty.kind) {\n+                match (value.val, &value.ty.kind()) {\n                     (_, ty::Array(_, n)) => {\n                         let len = n.eval_usize(tcx, param_env);\n                         Some(Slice(Slice { array_len: Some(len), kind: FixedLen(len) }))\n@@ -2102,7 +2096,7 @@ fn pat_constructor<'tcx>(\n         }\n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let array_len = match pat.ty.kind {\n+            let array_len = match pat.ty.kind() {\n                 ty::Array(_, length) => Some(length.eval_usize(tcx, param_env)),\n                 ty::Slice(_) => None,\n                 _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n@@ -2141,7 +2135,7 @@ fn slice_pat_covered_by_const<'tcx>(\n         )\n     };\n \n-    let data: &[u8] = match (const_val_val, &const_val.ty.kind) {\n+    let data: &[u8] = match (const_val_val, &const_val.ty.kind()) {\n         (ConstValue::ByRef { offset, alloc, .. }, ty::Array(t, n)) => {\n             assert_eq!(*t, tcx.types.u8);\n             let n = n.eval_usize(tcx, param_env);\n@@ -2561,7 +2555,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n             // elements don't necessarily point to memory, they are usually\n             // just integers. The only time they should be pointing to memory\n             // is when they are subslices of nonzero slices.\n-            let (alloc, offset, n, ty) = match value.ty.kind {\n+            let (alloc, offset, n, ty) = match value.ty.kind() {\n                 ty::Array(t, n) => {\n                     let n = n.eval_usize(cx.tcx, cx.param_env);\n                     // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,"}, {"sha": "047bf7db4c8677ffcff0b6d433af1a614163b5e2", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -289,7 +289,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                 cx.typeck_results.extract_binding_mode(cx.tcx.sess, p.hir_id, p.span)\n             {\n                 let pat_ty = cx.typeck_results.pat_ty(p).peel_refs();\n-                if let ty::Adt(edef, _) = pat_ty.kind {\n+                if let ty::Adt(edef, _) = pat_ty.kind() {\n                     if edef.is_enum()\n                         && edef.variants.iter().any(|variant| {\n                             variant.ident == ident && variant.ctor_kind == CtorKind::Const\n@@ -442,7 +442,7 @@ fn check_exhaustive<'p, 'tcx>(\n     // In the absence of the `exhaustive_patterns` feature, empty matches are not detected by\n     // `is_useful` to exhaustively match uninhabited types, so we manually check here.\n     if is_empty_match && !cx.tcx.features().exhaustive_patterns {\n-        let scrutinee_is_visibly_uninhabited = match scrut_ty.kind {\n+        let scrutinee_is_visibly_uninhabited = match scrut_ty.kind() {\n             ty::Never => true,\n             ty::Adt(def, _) => {\n                 def.is_enum()\n@@ -462,7 +462,7 @@ fn check_exhaustive<'p, 'tcx>(\n         Err(err) => err,\n     };\n \n-    let non_empty_enum = match scrut_ty.kind {\n+    let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants.is_empty(),\n         _ => false,\n     };\n@@ -541,7 +541,7 @@ fn adt_defined_here(\n     witnesses: &[super::Pat<'_>],\n ) {\n     let ty = ty.peel_refs();\n-    if let ty::Adt(def, _) = ty.kind {\n+    if let ty::Adt(def, _) = ty.kind() {\n         if let Some(sp) = cx.tcx.hir().span_if_local(def.did) {\n             err.span_label(sp, format!(\"`{}` defined here\", ty));\n         }\n@@ -556,7 +556,7 @@ fn adt_defined_here(\n \n fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span> {\n     let mut covered = vec![];\n-    if let ty::Adt(def, _) = ty.kind {\n+    if let ty::Adt(def, _) = ty.kind() {\n         // Don't point at variants that have already been covered due to other patterns to avoid\n         // visual clutter.\n         for pattern in patterns {"}, {"sha": "2816bad7eabc1cc0c8bd16f7c46c7e085b65d24d", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 .collect()\n         };\n \n-        let kind = match cv.ty.kind {\n+        let kind = match cv.ty.kind() {\n             ty::Float(_) => {\n                 tcx.struct_span_lint_hir(\n                     lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n@@ -247,11 +247,9 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 PatKind::Wild\n             }\n             // keep old code until future-compat upgraded to errors.\n-            ty::Ref(_, adt_ty @ ty::TyS { kind: ty::Adt(_, _), .. }, _)\n-                if !self.type_marked_structural(adt_ty) =>\n-            {\n+            ty::Ref(_, adt_ty, _) if adt_ty.is_adt() && !self.type_marked_structural(adt_ty) => {\n                 let adt_def =\n-                    if let ty::Adt(adt_def, _) = adt_ty.kind { adt_def } else { unreachable!() };\n+                    if let ty::Adt(adt_def, _) = adt_ty.kind() { adt_def } else { unreachable!() };\n \n                 debug!(\n                     \"adt_def {:?} has !type_marked_structural for adt_ty: {:?}\","}, {"sha": "d617f4a6aa68488d4cf92583c08c9089132e976a", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -237,7 +237,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                         Some(&adt_def.variants[variant_index])\n                     }\n                     _ => {\n-                        if let ty::Adt(adt, _) = self.ty.kind {\n+                        if let ty::Adt(adt, _) = self.ty.kind() {\n                             if !adt.is_enum() {\n                                 Some(&adt.variants[VariantIdx::new(0)])\n                             } else {\n@@ -302,7 +302,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                 Ok(())\n             }\n             PatKind::Deref { ref subpattern } => {\n-                match self.ty.kind {\n+                match self.ty.kind() {\n                     ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n                     ty::Ref(_, _, mutbl) => {\n                         write!(f, \"&{}\", mutbl.prefix_str())?;\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             hir::PatKind::Tuple(ref pats, ddpos) => {\n-                let tys = match ty.kind {\n+                let tys = match ty.kind() {\n                     ty::Tuple(ref tys) => tys,\n                     _ => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", ty),\n                 };\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 // x's type, which is &T, where we want T (the type being matched).\n                 let var_ty = ty;\n                 if let ty::BindByReference(_) = bm {\n-                    if let ty::Ref(_, rty, _) = ty.kind {\n+                    if let ty::Ref(_, rty, _) = ty.kind() {\n                         ty = rty;\n                     } else {\n                         bug!(\"`ref {}` has wrong type {}\", ident, ty);\n@@ -608,7 +608,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n             hir::PatKind::TupleStruct(ref qpath, ref pats, ddpos) => {\n                 let res = self.typeck_results.qpath_res(qpath, pat.hir_id);\n-                let adt_def = match ty.kind {\n+                let adt_def = match ty.kind() {\n                     ty::Adt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT {:?}\", ty),\n                 };\n@@ -670,7 +670,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let prefix = self.lower_patterns(prefix);\n         let slice = self.lower_opt_pattern(slice);\n         let suffix = self.lower_patterns(suffix);\n-        match ty.kind {\n+        match ty.kind() {\n             // Matching a slice, `[T]`.\n             ty::Slice(..) => PatKind::Slice { prefix, slice, suffix },\n             // Fixed-length array, `[T; len]`.\n@@ -704,7 +704,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n-                    let substs = match ty.kind {\n+                    let substs = match ty.kind() {\n                         ty::Adt(_, substs) | ty::FnDef(_, substs) => substs,\n                         ty::Error(_) => {\n                             // Avoid ICE (#50585)\n@@ -1058,7 +1058,7 @@ crate fn compare_const_vals<'tcx>(\n \n     if let (Some(a), Some(b)) = (a_bits, b_bits) {\n         use rustc_apfloat::Float;\n-        return match ty.kind {\n+        return match *ty.kind() {\n             ty::Float(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n@@ -1081,7 +1081,7 @@ crate fn compare_const_vals<'tcx>(\n         };\n     }\n \n-    if let ty::Str = ty.kind {\n+    if let ty::Str = ty.kind() {\n         if let (\n             ty::ConstKind::Value(a_val @ ConstValue::Slice { .. }),\n             ty::ConstKind::Value(b_val @ ConstValue::Slice { .. }),"}, {"sha": "aea8667314f485de7da65c35a936efe235e8adf4", "filename": "compiler/rustc_mir_build/src/thir/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -17,7 +17,7 @@ crate trait UserAnnotatedTyHelpers<'tcx> {\n         let mut user_ty = *user_provided_types.get(hir_id)?;\n         debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n         let ty = self.typeck_results().node_type(hir_id);\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Adt(adt_def, ..) => {\n                 if let UserType::TypeOf(ref mut did, _) = &mut user_ty.value {\n                     *did = adt_def.did;"}, {"sha": "c79542342ba78ba5a58a1a97abe0a42e028c7608", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr<'_>, hir_id: hir::HirId) {\n-        match self.typeck_results().expr_ty_adjusted(lhs).kind {\n+        match self.typeck_results().expr_ty_adjusted(lhs).kind() {\n             ty::Adt(def, _) => {\n                 let index = self.tcx.field_index(hir_id, self.typeck_results());\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n@@ -140,7 +140,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         res: Res,\n         pats: &[hir::FieldPat<'_>],\n     ) {\n-        let variant = match self.typeck_results().node_type(lhs.hir_id).kind {\n+        let variant = match self.typeck_results().node_type(lhs.hir_id).kind() {\n             ty::Adt(adt, _) => adt.variant_of_res(res),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\"),\n         };\n@@ -269,7 +269,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n             hir::ExprKind::Struct(ref qpath, ref fields, _) => {\n                 let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n                 self.handle_res(res);\n-                if let ty::Adt(ref adt, _) = self.typeck_results().expr_ty(expr).kind {\n+                if let ty::Adt(ref adt, _) = self.typeck_results().expr_ty(expr).kind() {\n                     self.mark_as_used_if_union(adt, fields);\n                 }\n             }"}, {"sha": "79f1c2b9da8dac442f92c39f7b0665def81fe979", "filename": "compiler/rustc_passes/src/intrinsicck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fintrinsicck.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -35,7 +35,7 @@ struct ExprVisitor<'tcx> {\n /// If the type is `Option<T>`, it will return `T`, otherwise\n /// the type itself. Works on most `Option`-like types.\n fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let (def, substs) = match ty.kind {\n+    let (def, substs) = match *ty.kind() {\n         ty::Adt(def, substs) => (def, substs),\n         _ => return ty,\n     };\n@@ -81,7 +81,7 @@ impl ExprVisitor<'tcx> {\n             // Special-case transmutting from `typeof(function)` and\n             // `Option<typeof(function)>` to present a clearer error.\n             let from = unpack_option_like(self.tcx, from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (&from.kind, sk_to) {\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) {\n                 if size_to == Pointer.size(&self.tcx) {\n                     struct_span_err!(self.tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n                         .note(&format!(\"source type: {}\", from))\n@@ -127,7 +127,7 @@ impl ExprVisitor<'tcx> {\n         if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n             return true;\n         }\n-        if let ty::Foreign(..) = ty.kind {\n+        if let ty::Foreign(..) = ty.kind() {\n             return true;\n         }\n         false\n@@ -149,7 +149,7 @@ impl ExprVisitor<'tcx> {\n             64 => InlineAsmType::I64,\n             _ => unreachable!(),\n         };\n-        let asm_ty = match ty.kind {\n+        let asm_ty = match *ty.kind() {\n             ty::Never | ty::Error(_) => return None,\n             ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => Some(InlineAsmType::I8),\n             ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => Some(InlineAsmType::I16),\n@@ -166,7 +166,7 @@ impl ExprVisitor<'tcx> {\n             ty::Adt(adt, substs) if adt.repr.simd() => {\n                 let fields = &adt.non_enum_variant().fields;\n                 let elem_ty = fields[0].ty(self.tcx, substs);\n-                match elem_ty.kind {\n+                match elem_ty.kind() {\n                     ty::Never | ty::Error(_) => return None,\n                     ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => {\n                         Some(InlineAsmType::VecI8(fields.len() as u64))\n@@ -374,7 +374,7 @@ impl ExprVisitor<'tcx> {\n                 }\n                 hir::InlineAsmOperand::Const { ref expr } => {\n                     let ty = self.typeck_results.expr_ty_adjusted(expr);\n-                    match ty.kind {\n+                    match ty.kind() {\n                         ty::Int(_) | ty::Uint(_) | ty::Float(_) => {}\n                         _ => {\n                             let msg ="}, {"sha": "db9495201cf300633ea57f1df7b49ee10db36a81", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -958,7 +958,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n \n         let ty = self.typeck_results.node_type(id);\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Closure(_def_id, substs) => match substs.as_closure().kind() {\n                 ty::ClosureKind::Fn => {}\n                 ty::ClosureKind::FnMut => {}"}, {"sha": "03cc718b8995d0fe82aed76fc147d3754e6b6665", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -119,7 +119,7 @@ where\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         let tcx = self.def_id_visitor.tcx();\n         // InternalSubsts are not visited here because they are visited below in `super_visit_with`.\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Adt(&ty::AdtDef { did: def_id, .. }, ..)\n             | ty::Foreign(def_id)\n             | ty::FnDef(def_id, ..)\n@@ -134,7 +134,7 @@ where\n                 // Default type visitor doesn't visit signatures of fn types.\n                 // Something like `fn() -> Priv {my_func}` is considered a private type even if\n                 // `my_func` is public, so we need to visit signatures.\n-                if let ty::FnDef(..) = ty.kind {\n+                if let ty::FnDef(..) = ty.kind() {\n                     if tcx.fn_sig(def_id).visit_with(self) {\n                         return true;\n                     }"}, {"sha": "c95e7e193be300cf148facc73135c2d6a101133d", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -524,12 +524,12 @@ impl<'tcx> SaveContext<'tcx> {\n \n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n         let ty = self.typeck_results().expr_ty_adjusted_opt(expr)?;\n-        if matches!(ty.kind, ty::Error(_)) {\n+        if matches!(ty.kind(), ty::Error(_)) {\n             return None;\n         }\n         match expr.kind {\n             hir::ExprKind::Field(ref sub_ex, ident) => {\n-                match self.typeck_results().expr_ty_adjusted(&sub_ex).kind {\n+                match self.typeck_results().expr_ty_adjusted(&sub_ex).kind() {\n                     ty::Adt(def, _) if !def.is_enum() => {\n                         let variant = &def.non_enum_variant();\n                         filter!(self.span_utils, ident.span);\n@@ -551,7 +551,7 @@ impl<'tcx> SaveContext<'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprKind::Struct(qpath, ..) => match ty.kind {\n+            hir::ExprKind::Struct(qpath, ..) => match ty.kind() {\n                 ty::Adt(def, _) => {\n                     let sub_span = qpath.last_segment_span();\n                     filter!(self.span_utils, sub_span);"}, {"sha": "6f9fc115cae9b1a390e48dc3604ec3282c30cae9", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -110,7 +110,7 @@ fn get_symbol_hash<'tcx>(\n         // If this is a function, we hash the signature as well.\n         // This is not *strictly* needed, but it may help in some\n         // situations, see the `run-make/a-b-a-linker-guard` test.\n-        if let ty::FnDef(..) = item_type.kind {\n+        if let ty::FnDef(..) = item_type.kind() {\n             item_type.fn_sig(tcx).hash_stable(&mut hcx, &mut hasher);\n         }\n \n@@ -210,7 +210,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     }\n \n     fn print_type(self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-        match ty.kind {\n+        match *ty.kind() {\n             // Print all nominal types as paths (unlike `pretty_print_type`).\n             ty::FnDef(def_id, substs)\n             | ty::Opaque(def_id, substs)\n@@ -258,7 +258,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n     ) -> Result<Self::Path, Self::Error> {\n         // Similar to `pretty_path_qualified`, but for the other\n         // types that are printed as paths (see `print_type` above).\n-        match self_ty.kind {\n+        match self_ty.kind() {\n             ty::FnDef(..)\n             | ty::Opaque(..)\n             | ty::Projection(_)"}, {"sha": "619edf06aa6e69820b27cafdfa3defbd73bbae85", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -323,7 +323,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n     fn print_type(mut self, ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n         // Basic types, never cached (single-character).\n-        let basic_type = match ty.kind {\n+        let basic_type = match ty.kind() {\n             ty::Bool => \"b\",\n             ty::Char => \"c\",\n             ty::Str => \"e\",\n@@ -359,7 +359,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         }\n         let start = self.out.len();\n \n-        match ty.kind {\n+        match *ty.kind() {\n             // Basic types, handled above.\n             ty::Bool | ty::Char | ty::Str | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Never => {\n                 unreachable!()\n@@ -505,7 +505,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         }\n         let start = self.out.len();\n \n-        match ct.ty.kind {\n+        match ct.ty.kind() {\n             ty::Uint(_) => {}\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty, ct);"}, {"sha": "9cf3bbd94e03d4031214d15d25fd3c4dd7ccbc3c", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -708,11 +708,11 @@ where\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         // We're only interested in types involving regions\n-        if !ty.flags.intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n+        if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n             return false; // keep visiting\n         }\n \n-        match ty.kind {\n+        match ty.kind() {\n             ty::Closure(_, ref substs) => {\n                 // Skip lifetime parameters of the enclosing item(s)\n \n@@ -866,7 +866,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Closure(def_id, substs) => {\n                 // I am a horrible monster and I pray for death. When\n                 // we encounter a closure here, it is always a closure\n@@ -1003,7 +1003,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n             ty_op: |ty| {\n                 if ty.references_error() {\n                     return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind {\n+                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n                     // Check that this is `impl Trait` type is\n                     // declared by `parent_def_id` -- i.e., one whose\n                     // value we are inferring.  At present, this is"}, {"sha": "ad8e9d9faa6fc995776e83aa4af83d0222b70ba5", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -598,15 +598,15 @@ impl AutoTraitFinder<'tcx> {\n     }\n \n     pub fn is_of_param(&self, ty: Ty<'_>) -> bool {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Param(_) => true,\n             ty::Projection(p) => self.is_of_param(p.self_ty()),\n             _ => false,\n         }\n     }\n \n     fn is_self_referential_projection(&self, p: ty::PolyProjectionPredicate<'_>) -> bool {\n-        match p.ty().skip_binder().kind {\n+        match *p.ty().skip_binder().kind() {\n             ty::Projection(proj) if proj == p.skip_binder().projection_ty => true,\n             _ => false,\n         }"}, {"sha": "c27d2fcc14998d8e4ccf24c82d8d8c02b237c456", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -412,7 +412,7 @@ fn orphan_check_trait_ref<'tcx>(\n         if non_local_tys.is_empty() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n-        } else if let ty::Param(_) = input_ty.kind {\n+        } else if let ty::Param(_) = input_ty.kind() {\n             debug!(\"orphan_check_trait_ref: uncovered ty: `{:?}`\", input_ty);\n             let local_type = trait_ref\n                 .substs\n@@ -467,7 +467,7 @@ fn fundamental_ty_inner_tys(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<impl Iterator<Item = Ty<'tcx>>> {\n-    let (first_ty, rest_tys) = match ty.kind {\n+    let (first_ty, rest_tys) = match *ty.kind() {\n         ty::Ref(_, ty, _) => (ty, ty::subst::InternalSubsts::empty().types()),\n         ty::Adt(def, substs) if def.is_fundamental() => {\n             let mut types = substs.types();\n@@ -504,7 +504,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n-    match ty.kind {\n+    match *ty.kind() {\n         ty::Bool\n         | ty::Char\n         | ty::Int(..)"}, {"sha": "dcd8379803319b2e673b748db2488e0a55c2fddc", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -382,7 +382,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // If it has a custom `#[rustc_on_unimplemented]`\n                             // error message, let's display it as the label!\n                             err.span_label(span, s.as_str());\n-                            if !matches!(trait_ref.skip_binder().self_ty().kind, ty::Param(_)) {\n+                            if !matches!(trait_ref.skip_binder().self_ty().kind(), ty::Param(_)) {\n                                 // When the self type is a type param We don't need to \"the trait\n                                 // `std::marker::Sized` is not implemented for `T`\" as we will point\n                                 // at the type param with a label to suggest constraining it.\n@@ -446,12 +446,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.tcx.lang_items().fn_once_trait(),\n                         ]\n                         .contains(&Some(trait_ref.def_id()));\n-                        let is_target_feature_fn =\n-                            if let ty::FnDef(def_id, _) = trait_ref.skip_binder().self_ty().kind {\n-                                !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n-                            } else {\n-                                false\n-                            };\n+                        let is_target_feature_fn = if let ty::FnDef(def_id, _) =\n+                            *trait_ref.skip_binder().self_ty().kind()\n+                        {\n+                            !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n+                        } else {\n+                            false\n+                        };\n                         if is_fn_trait && is_target_feature_fn {\n                             err.note(\n                                 \"`#[target_feature]` functions do not implement the `Fn` traits\",\n@@ -678,7 +679,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     None => return,\n                 };\n \n-                let found_did = match found_trait_ty.kind {\n+                let found_did = match *found_trait_ty.kind() {\n                     ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n                     ty::Adt(def, _) => Some(def.did),\n                     _ => None,\n@@ -696,13 +697,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n \n-                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind() {\n                     ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n                     _ => vec![ArgKind::empty()],\n                 };\n \n                 let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n-                let expected = match expected_ty.kind {\n+                let expected = match expected_ty.kind() {\n                     ty::Tuple(ref tys) => tys\n                         .iter()\n                         .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n@@ -1252,7 +1253,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         /// returns the fuzzy category of a given type, or None\n         /// if the type can be equated to any type.\n         fn type_category(t: Ty<'_>) -> Option<u32> {\n-            match t.kind {\n+            match t.kind() {\n                 ty::Bool => Some(0),\n                 ty::Char => Some(1),\n                 ty::Str => Some(2),\n@@ -1281,7 +1282,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         match (type_category(a), type_category(b)) {\n-            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n+            (Some(cat_a), Some(cat_b)) => match (a.kind(), b.kind()) {\n                 (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n                 _ => cat_a == cat_b,\n             },\n@@ -1476,7 +1477,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ty::PredicateAtom::Trait(data, _) => {\n                 let trait_ref = ty::Binder::bind(data.trait_ref);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n-                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind(), trait_ref);\n \n                 if predicate.references_error() {\n                     return;\n@@ -1664,7 +1665,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n+                if let ty::Param(ty::ParamTy { name, .. }) = *ty.kind() {\n                     let infcx = self.infcx;\n                     self.var_map.entry(ty).or_insert_with(|| {\n                         infcx.next_ty_var(TypeVariableOrigin {\n@@ -1938,8 +1939,8 @@ impl ArgKind {\n     /// Creates an `ArgKind` from the expected type of an\n     /// argument. It has no name (`_`) and an optional source span.\n     pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n-        match t.kind {\n-            ty::Tuple(ref tys) => ArgKind::Tuple(\n+        match t.kind() {\n+            ty::Tuple(tys) => ArgKind::Tuple(\n                 span,\n                 tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n             ),"}, {"sha": "0f5aad5af1229955bf75ac3ca6911bd682c78866", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n         }\n \n-        if let ty::Array(aty, len) = self_ty.kind {\n+        if let ty::Array(aty, len) = self_ty.kind() {\n             flags.push((sym::_Self, Some(\"[]\".to_owned())));\n             flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n             if let Some(def) = aty.ty_adt_def() {\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-        if let ty::Dynamic(traits, _) = self_ty.kind {\n+        if let ty::Dynamic(traits, _) = self_ty.kind() {\n             for t in traits.skip_binder() {\n                 if let ty::ExistentialPredicate::Trait(trait_ref) = t {\n                     flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))"}, {"sha": "82e809d014dd06050a1a750e107d9d81c1414b82", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -207,7 +207,7 @@ fn suggest_restriction(\n     }\n     // Given `fn foo(t: impl Trait)` where `Trait` requires assoc type `A`...\n     if let Some((bound_str, fn_sig)) =\n-        fn_sig.zip(projection).and_then(|(sig, p)| match p.self_ty().kind {\n+        fn_sig.zip(projection).and_then(|(sig, p)| match p.self_ty().kind() {\n             // Shenanigans to get the `Trait` from the `impl Trait`.\n             ty::Param(param) => {\n                 // `fn foo(t: impl Trait)`\n@@ -323,7 +323,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         body_id: hir::HirId,\n     ) {\n         let self_ty = trait_ref.skip_binder().self_ty();\n-        let (param_ty, projection) = match &self_ty.kind {\n+        let (param_ty, projection) = match self_ty.kind() {\n             ty::Param(_) => (true, None),\n             ty::Projection(projection) => (false, Some(projection)),\n             _ => return,\n@@ -482,7 +482,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             None => return,\n         };\n \n-        if let ty::Ref(region, base_ty, mutbl) = real_ty.kind {\n+        if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n             let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty);\n             if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n                 // Re-add the `&`\n@@ -563,7 +563,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             Some(ty) => ty,\n         };\n \n-        let (def_id, output_ty, callable) = match self_ty.kind {\n+        let (def_id, output_ty, callable) = match *self_ty.kind() {\n             ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig().output(), \"closure\"),\n             ty::FnDef(def_id, _) => (def_id, self_ty.fn_sig(self.tcx).output(), \"function\"),\n             _ => return,\n@@ -751,7 +751,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             };\n \n             for refs_remaining in 0..refs_number {\n-                if let ty::Ref(_, inner_ty, _) = suggested_ty.kind {\n+                if let ty::Ref(_, inner_ty, _) = suggested_ty.kind() {\n                     suggested_ty = inner_ty;\n \n                     let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n@@ -814,7 +814,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n \n-            if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+            if let ty::Ref(region, t_type, mutability) = *trait_ref.skip_binder().self_ty().kind() {\n                 if region.is_late_bound() || t_type.has_escaping_bound_vars() {\n                     // Avoid debug assertion in `mk_obligation_for_def_id`.\n                     //\n@@ -871,7 +871,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let is_empty_tuple =\n-            |ty: ty::Binder<Ty<'_>>| ty.skip_binder().kind == ty::Tuple(ty::List::empty());\n+            |ty: ty::Binder<Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n \n         let hir = self.tcx.hir();\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let body = hir.body(*body_id);\n         let trait_ref = self.resolve_vars_if_possible(trait_ref);\n         let ty = trait_ref.skip_binder().self_ty();\n-        let is_object_safe = match ty.kind {\n+        let is_object_safe = match ty.kind() {\n             ty::Dynamic(predicates, _) => {\n                 // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n                 predicates\n@@ -982,11 +982,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n              ty| {\n                 let ty = self.resolve_vars_if_possible(&ty);\n                 same &=\n-                    !matches!(ty.kind, ty::Error(_))\n+                    !matches!(ty.kind(), ty::Error(_))\n                         && last_ty.map_or(true, |last_ty| {\n                             // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n                             // *after* in the dependency graph.\n-                            match (&ty.kind, &last_ty.kind) {\n+                            match (ty.kind(), last_ty.kind()) {\n                                 (Infer(InferTy::IntVar(_)), Infer(InferTy::IntVar(_)))\n                                 | (Infer(InferTy::FloatVar(_)), Infer(InferTy::FloatVar(_)))\n                                 | (Infer(InferTy::FreshIntTy(_)), Infer(InferTy::FreshIntTy(_)))\n@@ -997,12 +997,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 _ => ty == last_ty,\n                             }\n                         });\n-                (Some(ty), same, only_never_return && matches!(ty.kind, ty::Never))\n+                (Some(ty), same, only_never_return && matches!(ty.kind(), ty::Never))\n             },\n         );\n         let all_returns_conform_to_trait =\n             if let Some(ty_ret_ty) = typeck_results.node_type_opt(ret_ty.hir_id) {\n-                match ty_ret_ty.kind {\n+                match ty_ret_ty.kind() {\n                     ty::Dynamic(predicates, _) => {\n                         let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n                         let param_env = ty::ParamEnv::empty();\n@@ -1151,7 +1151,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             trait_ref: ty::TraitRef<'tcx>,\n         ) -> String {\n             let inputs = trait_ref.substs.type_at(1);\n-            let sig = if let ty::Tuple(inputs) = inputs.kind {\n+            let sig = if let ty::Tuple(inputs) = inputs.kind() {\n                 tcx.mk_fn_sig(\n                     inputs.iter().map(|k| k.expect_ty()),\n                     tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n@@ -1317,10 +1317,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     debug!(\n                         \"maybe_note_obligation_cause_for_async_await: \\\n                             parent_trait_ref={:?} self_ty.kind={:?}\",\n-                        derived_obligation.parent_trait_ref, ty.kind\n+                        derived_obligation.parent_trait_ref,\n+                        ty.kind()\n                     );\n \n-                    match ty.kind {\n+                    match *ty.kind() {\n                         ty::Generator(did, ..) => {\n                             generator = generator.or(Some(did));\n                             outer_generator = Some(did);"}, {"sha": "e23f5a583b23bc2394593b083979d4b9e9fea557", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -23,7 +23,7 @@ pub fn can_type_implement_copy(\n ) -> Result<(), CopyImplementationError<'tcx>> {\n     // FIXME: (@jroesch) float this code up\n     tcx.infer_ctxt().enter(|infcx| {\n-        let (adt, substs) = match self_type.kind {\n+        let (adt, substs) = match self_type.kind() {\n             // These types used to have a builtin impl.\n             // Now libcore provides that impl.\n             ty::Uint(_)"}, {"sha": "6c0c33d3dad2eaafd9083447febb0aedf6b3f09b", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -732,7 +732,7 @@ fn contains_illegal_self_type_reference<'tcx>(\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-            match t.kind {\n+            match t.kind() {\n                 ty::Param(_) => t == self.self_ty,\n                 ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`."}, {"sha": "d37f819f376d3c31e2c864c97964d580c3ed7bec", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -345,7 +345,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n         // should occur eventually).\n \n         let ty = ty.super_fold_with(self);\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Opaque(def_id, substs) => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {\n@@ -908,7 +908,7 @@ fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n     // Check whether the self-type is itself a projection.\n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let bounds = match obligation_trait_ref.self_ty().kind {\n+    let bounds = match *obligation_trait_ref.self_ty().kind() {\n         ty::Projection(ref data) => {\n             tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n         }\n@@ -1067,7 +1067,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // Any type with multiple potential discriminant types is therefore not eligible.\n                 let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n \n-                match self_ty.kind {\n+                match self_ty.kind() {\n                     ty::Bool\n                     | ty::Char\n                     | ty::Int(_)\n@@ -1219,8 +1219,8 @@ fn confirm_object_candidate<'cx, 'tcx>(\n     let self_ty = obligation_trait_ref.self_ty();\n     let object_ty = selcx.infcx().shallow_resolve(self_ty);\n     debug!(\"confirm_object_candidate(object_ty={:?})\", object_ty);\n-    let data = match object_ty.kind {\n-        ty::Dynamic(ref data, ..) => data,\n+    let data = match object_ty.kind() {\n+        ty::Dynamic(data, ..) => data,\n         _ => span_bug!(\n             obligation.cause.span,\n             \"confirm_object_candidate called with non-object: {:?}\","}, {"sha": "424b3bd67ffade88c12b69cbce80c8a2bb06662d", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -82,7 +82,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         // None of these types have a destructor and hence they do not\n         // require anything in particular to outlive the dtor's\n         // execution."}, {"sha": "323063b958447195f19a52a1034853040d3149ab", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         }\n \n         let ty = ty.super_fold_with(self);\n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Opaque(def_id, substs) => {\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal() {"}, {"sha": "a4943231dfdff94c52d5cf12cd58a02e07048506", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -152,7 +152,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n-        match obligation.predicate.skip_binder().trait_ref.self_ty().kind {\n+        match obligation.predicate.skip_binder().trait_ref.self_ty().kind() {\n             ty::Projection(_) | ty::Opaque(..) => {}\n             ty::Infer(ty::TyVar(_)) => {\n                 span_bug!(\n@@ -221,7 +221,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = obligation.self_ty().skip_binder();\n-        match self_ty.kind {\n+        match self_ty.kind() {\n             ty::Generator(..) => {\n                 debug!(\n                     \"assemble_generator_candidates: self_ty={:?} obligation={:?}\",\n@@ -261,7 +261,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Okay to skip binder because the substs on closure types never\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n-        match obligation.self_ty().skip_binder().kind {\n+        match *obligation.self_ty().skip_binder().kind() {\n             ty::Closure(_, closure_substs) => {\n                 debug!(\"assemble_unboxed_candidates: kind={:?} obligation={:?}\", kind, obligation);\n                 match self.infcx.closure_kind(closure_substs) {\n@@ -300,7 +300,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n         let self_ty = obligation.self_ty().skip_binder();\n-        match self_ty.kind {\n+        match *self_ty.kind() {\n             ty::Infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // Could wind up being a fn() type.\n@@ -382,7 +382,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let def_id = obligation.predicate.def_id();\n \n         if self.tcx().trait_is_auto(def_id) {\n-            match self_ty.kind {\n+            match self_ty.kind() {\n                 ty::Dynamic(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. This means we conservatively\n@@ -453,7 +453,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // self-ty here doesn't escape this probe, so just erase\n             // any LBR.\n             let self_ty = self.tcx().erase_late_bound_regions(&obligation.self_ty());\n-            let poly_trait_ref = match self_ty.kind {\n+            let poly_trait_ref = match self_ty.kind() {\n                 ty::Dynamic(ref data, ..) => {\n                     if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n                         debug!(\n@@ -539,7 +539,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"assemble_candidates_for_unsizing(source={:?}, target={:?})\", source, target);\n \n-        let may_apply = match (&source.kind, &target.kind) {\n+        let may_apply = match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:"}, {"sha": "9906c1f325f3d3cf1a2a844d0d4c59945ff75f4c", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -327,8 +327,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // from the object. Have to try to make a broken test case that\n         // results.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let poly_trait_ref = match self_ty.kind {\n-            ty::Dynamic(ref data, ..) => data\n+        let poly_trait_ref = match self_ty.kind() {\n+            ty::Dynamic(data, ..) => data\n                 .principal()\n                 .unwrap_or_else(|| {\n                     span_bug!(obligation.cause.span, \"object candidate with no principal\")\n@@ -449,7 +449,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let (generator_def_id, substs) = match self_ty.kind {\n+        let (generator_def_id, substs) = match *self_ty.kind() {\n             ty::Generator(id, substs, _) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n@@ -498,7 +498,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let (closure_def_id, substs) = match self_ty.kind {\n+        let (closure_def_id, substs) = match *self_ty.kind() {\n             ty::Closure(id, substs) => (id, substs),\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n@@ -594,7 +594,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"confirm_builtin_unsize_candidate(source={:?}, target={:?})\", source, target);\n \n         let mut nested = vec![];\n-        match (&source.kind, &target.kind) {\n+        match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n                 // See `assemble_candidates_for_unsizing` for more info.\n@@ -693,7 +693,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // `Struct<T>` -> `Struct<U>`\n             (&ty::Adt(def, substs_a), &ty::Adt(_, substs_b)) => {\n                 let maybe_unsizing_param_idx = |arg: GenericArg<'tcx>| match arg.unpack() {\n-                    GenericArgKind::Type(ty) => match ty.kind {\n+                    GenericArgKind::Type(ty) => match ty.kind() {\n                         ty::Param(p) => Some(p.index),\n                         _ => None,\n                     },"}, {"sha": "4258d8e3010a4b48b7901608642c5b2a20d87841", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -1307,7 +1307,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n \n         let tcx = self.infcx.tcx;\n-        let predicates = match placeholder_trait_predicate.trait_ref.self_ty().kind {\n+        let predicates = match *placeholder_trait_predicate.trait_ref.self_ty().kind() {\n             ty::Projection(ref data) => {\n                 tcx.projection_predicates(data.item_def_id).subst(tcx, data.substs)\n             }\n@@ -1566,7 +1566,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // NOTE: binder moved to (*)\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n \n-        match self_ty.kind {\n+        match self_ty.kind() {\n             ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n             | ty::Uint(_)\n             | ty::Int(_)\n@@ -1621,7 +1621,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n-        match self_ty.kind {\n+        match self_ty.kind() {\n             ty::Infer(ty::IntVar(_))\n             | ty::Infer(ty::FloatVar(_))\n             | ty::FnDef(..)\n@@ -1695,7 +1695,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n     /// ```\n     fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n-        match t.kind {\n+        match *t.kind() {\n             ty::Uint(_)\n             | ty::Int(_)\n             | ty::Bool"}, {"sha": "4f7fa2c3988ff883fdb752d71e882e9666aa99c5", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         debug!(\"Search visiting ty: {:?}\", ty);\n \n-        let (adt_def, substs) = match ty.kind {\n+        let (adt_def, substs) = match *ty.kind() {\n             ty::Adt(adt_def, substs) => (adt_def, substs),\n             ty::Param(_) => {\n                 self.found = Some(NonStructuralMatchTy::Param);"}, {"sha": "eb9ee2868f93d48ea0e4501b127c2cd53730fd04", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -25,7 +25,7 @@ pub fn obligations<'a, 'tcx>(\n     // Handle the \"livelock\" case (see comment above) by bailing out if necessary.\n     let arg = match arg.unpack() {\n         GenericArgKind::Type(ty) => {\n-            match ty.kind {\n+            match ty.kind() {\n                 ty::Infer(ty::TyVar(_)) => {\n                     let resolved_ty = infcx.shallow_resolve(ty);\n                     if resolved_ty == ty {\n@@ -200,7 +200,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            if let ty::Projection(projection_ty) = proj.ty.kind {\n+            if let ty::Projection(projection_ty) = proj.ty.kind() {\n                 let trait_assoc_item = tcx.associated_item(projection_ty.item_def_id);\n                 if let Some(impl_item_span) =\n                     items.iter().find(|item| item.ident == trait_assoc_item.ident).map(fix_span)\n@@ -213,7 +213,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n-            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = pred.self_ty().kind {\n+            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = *pred.self_ty().kind() {\n                 if let Some(impl_item_span) = trait_assoc_items\n                     .find(|i| i.def_id == item_def_id)\n                     .and_then(|trait_assoc_item| {\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 }\n             };\n \n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Bool\n                 | ty::Char\n                 | ty::Int(..)\n@@ -590,7 +590,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 // prevention, which happens before this can be reached.\n                 ty::Infer(_) => {\n                     let ty = self.infcx.shallow_resolve(ty);\n-                    if let ty::Infer(ty::TyVar(_)) = ty.kind {\n+                    if let ty::Infer(ty::TyVar(_)) = ty.kind() {\n                         // Not yet resolved, but we've made progress.\n                         let cause = self.cause(traits::MiscObligation);\n                         self.out.push(traits::Obligation::new("}, {"sha": "c2f2469a1408db339f5ca704be15b0e3ab518fc5", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         for impl_def_id in all_impls {\n             let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n-            match self_ty.kind {\n+            match *self_ty.kind() {\n                 ty::Adt(impl_adt_def, _) => {\n                     if impl_adt_def == adt_def {\n                         return true;"}, {"sha": "779540ecd249351411a3dcba41d798f75dce09cf", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -217,7 +217,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 ty::Binder::bind(predicate).lower_into(interner)\n             }\n             ty::PredicateAtom::WellFormed(arg) => match arg.unpack() {\n-                GenericArgKind::Type(ty) => match ty.kind {\n+                GenericArgKind::Type(ty) => match ty.kind() {\n                     // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n                     // `FromEnv`. However, when we \"lower\" Params, we don't update\n                     // the environment.\n@@ -340,7 +340,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n         let uint = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Uint(i)), empty());\n         let float = |f| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Float(f)), empty());\n \n-        match self.kind {\n+        match *self.kind() {\n             Bool => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Bool), empty()),\n             Char => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Char), empty()),\n             Int(ty) => match ty {\n@@ -692,7 +692,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.kind {\n+        match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 match self.parameters.entry(bound_ty.var.as_u32()) {\n                     Entry::Vacant(entry) => {\n@@ -836,7 +836,7 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.kind {\n+        match *t.kind() {\n             // FIXME(chalk): currently we convert params to placeholders starting at\n             // index `0`. To support placeholders, we'll actually need to do a\n             // first pass to collect placeholders. Then we can insert params after."}, {"sha": "3ee391d6dc7143ca6ff278b223293ce5ca76fe49", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -112,7 +112,7 @@ fn dropck_outlives<'tcx>(\n \n                             debug!(\"dropck_outlives: ty from dtorck_types = {:?}\", ty);\n \n-                            match ty.kind {\n+                            match ty.kind() {\n                                 // All parameters live for the duration of the\n                                 // function.\n                                 ty::Param(..) => {}\n@@ -172,7 +172,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n         return Ok(());\n     }\n \n-    match ty.kind {\n+    match ty.kind() {\n         ty::Bool\n         | ty::Char\n         | ty::Int(_)"}, {"sha": "75bf8ea0bb8168fe71d66cf88d4b4fe7a0f88770", "filename": "compiler/rustc_ty/src/instance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_ty%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_ty%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Finstance.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -53,7 +53,7 @@ fn inner_resolve_instance<'tcx>(\n         let ty = tcx.type_of(def.def_id_for_type_of());\n         let item_type = tcx.subst_and_normalize_erasing_regions(substs, param_env, &ty);\n \n-        let def = match item_type.kind {\n+        let def = match *item_type.kind() {\n             ty::FnDef(..)\n                 if {\n                     let f = item_type.fn_sig(tcx);\n@@ -68,7 +68,7 @@ fn inner_resolve_instance<'tcx>(\n \n                 if ty.needs_drop(tcx, param_env) {\n                     debug!(\" => nontrivial drop glue\");\n-                    match ty.kind {\n+                    match *ty.kind() {\n                         ty::Closure(..)\n                         | ty::Generator(..)\n                         | ty::Tuple(..)\n@@ -231,7 +231,7 @@ fn resolve_associated_item<'tcx>(\n                 trait_closure_kind,\n             ))\n         }\n-        traits::ImplSourceFnPointer(ref data) => match data.fn_ty.kind {\n+        traits::ImplSourceFnPointer(ref data) => match data.fn_ty.kind() {\n             ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n                 def: ty::InstanceDef::FnPtrShim(trait_item.def_id, data.fn_ty),\n                 substs: rcvr_substs,\n@@ -250,7 +250,7 @@ fn resolve_associated_item<'tcx>(\n                     let self_ty = trait_ref.self_ty();\n \n                     let is_copy = self_ty.is_copy_modulo_regions(tcx.at(DUMMY_SP), param_env);\n-                    match self_ty.kind {\n+                    match self_ty.kind() {\n                         _ if is_copy => (),\n                         ty::Array(..) | ty::Closure(..) | ty::Tuple(..) => {}\n                         _ => return Ok(None),"}, {"sha": "0356bcec5498b96a82fc3b5c59ab6523505063f2", "filename": "compiler/rustc_ty/src/needs_drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_ty%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_ty%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fneeds_drop.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -90,7 +90,7 @@ where\n             };\n \n             for component in components {\n-                match component.kind {\n+                match *component.kind() {\n                     _ if component.is_copy_modulo_regions(tcx.at(DUMMY_SP), self.param_env) => (),\n \n                     ty::Closure(_, substs) => {\n@@ -106,7 +106,7 @@ where\n                         }\n \n                         let witness = substs.witness();\n-                        let interior_tys = match &witness.kind {\n+                        let interior_tys = match witness.kind() {\n                             ty::GeneratorWitness(tys) => tcx.erase_late_bound_regions(tys),\n                             _ => {\n                                 tcx.sess.delay_span_bug("}, {"sha": "a0235444ac4fc3be6bd5f0bd39d0df032897625c", "filename": "compiler/rustc_ty/src/ty.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fty.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -18,7 +18,7 @@ fn sized_constraint_for_ty<'tcx>(\n ) -> Vec<Ty<'tcx>> {\n     use ty::TyKind::*;\n \n-    let result = match ty.kind {\n+    let result = match ty.kind() {\n         Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)\n         | FnPtr(_) | Array(..) | Closure(..) | Generator(..) | Never => vec![],\n \n@@ -344,7 +344,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n     }\n \n     let self_ty = trait_ref.self_ty();\n-    let self_ty_matches = match self_ty.kind {\n+    let self_ty_matches = match self_ty.kind() {\n         ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n         _ => false,\n     };\n@@ -398,21 +398,21 @@ fn associated_type_projection_predicates(\n         let pred = obligation.predicate;\n         match pred.skip_binders() {\n             ty::PredicateAtom::Trait(tr, _) => {\n-                if let ty::Projection(p) = tr.self_ty().kind {\n+                if let ty::Projection(p) = *tr.self_ty().kind() {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateAtom::Projection(proj) => {\n-                if let ty::Projection(p) = proj.projection_ty.self_ty().kind {\n+                if let ty::Projection(p) = *proj.projection_ty.self_ty().kind() {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateAtom::TypeOutlives(outlives) => {\n-                if let ty::Projection(p) = outlives.0.kind {\n+                if let ty::Projection(p) = *outlives.0.kind() {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n@@ -449,22 +449,23 @@ fn opaque_type_projection_predicates(\n         let pred = obligation.predicate;\n         match pred.skip_binders() {\n             ty::PredicateAtom::Trait(tr, _) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = tr.self_ty().kind {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = *tr.self_ty().kind() {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateAtom::Projection(proj) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = proj.projection_ty.self_ty().kind\n+                if let ty::Opaque(opaque_def_id, opaque_substs) =\n+                    *proj.projection_ty.self_ty().kind()\n                 {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n             ty::PredicateAtom::TypeOutlives(outlives) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = outlives.0.kind {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = *outlives.0.kind() {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }"}, {"sha": "bb79a1258fb658201ffcc3f2554324694ebc2548", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -1454,7 +1454,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n-        if let ty::Adt(adt_def, _) = qself_ty.kind {\n+        if let ty::Adt(adt_def, _) = qself_ty.kind() {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants\n@@ -1474,7 +1474,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n-        let bound = match (&qself_ty.kind, qself_res) {\n+        let bound = match (&qself_ty.kind(), qself_res) {\n             (_, Res::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference."}, {"sha": "17364897bde13a75671d4c7f5ba33add21174ecf", "filename": "compiler/rustc_typeck/src/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fautoderef.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.try_overloaded_deref(autoderef.span(), source).and_then(\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n+                            if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n                                 Some(OverloadedDeref { region, mutbl })\n                             } else {\n                                 None"}, {"sha": "740783aeb9d1e64b58b02b53ab2f4ff66c41cfef", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         // If the callee is a bare function or a closure, then we're all set.\n-        match adjusted_ty.kind {\n+        match *adjusted_ty.kind() {\n             ty::FnDef(..) | ty::FnPtr(_) => {\n                 let adjustments = self.adjust_steps(autoderef);\n                 self.apply_adjustments(callee_expr, adjustments);\n@@ -223,12 +223,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if borrow {\n                     // Check for &self vs &mut self in the method signature. Since this is either\n                     // the Fn or FnMut trait, it should be one of those.\n-                    let (region, mutbl) = if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind\n-                    {\n-                        (r, mutbl)\n-                    } else {\n-                        span_bug!(call_expr.span, \"input to call/call_mut is not a ref?\");\n-                    };\n+                    let (region, mutbl) =\n+                        if let ty::Ref(r, _, mutbl) = method.sig.inputs()[0].kind() {\n+                            (r, mutbl)\n+                        } else {\n+                            span_bug!(call_expr.span, \"input to call/call_mut is not a ref?\");\n+                        };\n \n                     let mutbl = match mutbl {\n                         hir::Mutability::Not => AutoBorrowMutability::Not,\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         arg_exprs: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let (fn_sig, def_span) = match callee_ty.kind {\n+        let (fn_sig, def_span) = match *callee_ty.kind() {\n             ty::FnDef(def_id, _) => {\n                 (callee_ty.fn_sig(self.tcx), self.tcx.hir().span_if_local(def_id))\n             }"}, {"sha": "5c2bdb86f76c96cc15d2954006caacd684aa2a96", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return Ok(Some(PointerKind::Thin));\n         }\n \n-        Ok(match t.kind {\n+        Ok(match *t.kind() {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n             ty::Dynamic(ref tty, ..) => Some(PointerKind::Vtable(tty.principal_def_id())),\n             ty::Adt(def, substs) if def.is_struct() => match def.non_enum_variant().fields.last() {\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         // For better error messages, check for some obviously unsized\n         // cases now. We do a more thorough check at the end, once\n         // inference is more completely known.\n-        match cast_ty.kind {\n+        match cast_ty.kind() {\n             ty::Dynamic(..) | ty::Slice(..) => {\n                 check.report_cast_to_unsized_type(fcx);\n                 Err(ErrorReported)\n@@ -348,7 +348,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     fcx.ty_to_string(self.cast_ty)\n                 );\n                 let mut sugg = None;\n-                if let ty::Ref(reg, _, mutbl) = self.cast_ty.kind {\n+                if let ty::Ref(reg, _, mutbl) = *self.cast_ty.kind() {\n                     if fcx\n                         .try_coerce(\n                             self.expr,\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 } else if !matches!(\n-                    self.cast_ty.kind,\n+                    self.cast_ty.kind(),\n                     ty::FnDef(..) | ty::FnPtr(..) | ty::Closure(..)\n                 ) {\n                     let mut label = true;\n@@ -474,7 +474,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             fcx.resolve_vars_if_possible(&self.expr_ty),\n             tstr\n         );\n-        match self.expr_ty.kind {\n+        match self.expr_ty.kind() {\n             ty::Ref(_, _, mt) => {\n                 let mtstr = mt.prefix_str();\n                 if self.cast_ty.is_trait() {\n@@ -602,7 +602,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             // Function item types may need to be reified before casts.\n             (None, Some(t_cast)) => {\n-                match self.expr_ty.kind {\n+                match *self.expr_ty.kind() {\n                     ty::FnDef(..) => {\n                         // Attempt a coercion to a fn pointer type.\n                         let f = fcx.normalize_associated_types_in(\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     // a cast.\n                     ty::Ref(_, inner_ty, mutbl) => {\n                         return match t_cast {\n-                            Int(_) | Float => match inner_ty.kind {\n+                            Int(_) | Float => match *inner_ty.kind() {\n                                 ty::Int(_)\n                                 | ty::Uint(_)\n                                 | ty::Float(_)\n@@ -768,7 +768,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         // array-ptr-cast.\n \n         if m_expr.mutbl == hir::Mutability::Not && m_cast.mutbl == hir::Mutability::Not {\n-            if let ty::Array(ety, _) = m_expr.ty.kind {\n+            if let ty::Array(ety, _) = m_expr.ty.kind() {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of\n                 // vector elements instead of the original values.\n@@ -817,7 +817,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn cenum_impl_drop_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n-        if let ty::Adt(d, _) = self.expr_ty.kind {\n+        if let ty::Adt(d, _) = self.expr_ty.kind() {\n             if d.has_dtor(fcx.tcx) {\n                 fcx.tcx.struct_span_lint_hir(\n                     lint::builtin::CENUM_IMPL_DROP_CAST,"}, {"sha": "8898a5452282cfde065ae3fcea167e7ec59276eb", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\", expected_ty);\n \n-        match expected_ty.kind {\n+        match *expected_ty.kind() {\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let arg_param_ty = self.resolve_vars_if_possible(&arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n-            match arg_param_ty.kind {\n+            match arg_param_ty.kind() {\n                 ty::Tuple(tys) => tys.into_iter().map(|k| k.expect_ty()).collect::<Vec<_>>(),\n                 _ => return None,\n             }\n@@ -611,7 +611,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // be inferring.\n         let ret_ty = ret_coercion.borrow().expected_ty();\n         let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-        let ret_vid = match ret_ty.kind {\n+        let ret_vid = match *ret_ty.kind() {\n             ty::Infer(ty::TyVar(ret_vid)) => ret_vid,\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),"}, {"sha": "e19130112970d6fb87f65901e2c9737cfef846d0", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -197,7 +197,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         //\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n-        match b.kind {\n+        match *b.kind() {\n             ty::RawPtr(mt_b) => {\n                 return self.coerce_unsafe_ptr(a, b, mt_b.mutbl);\n             }\n@@ -207,7 +207,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => {}\n         }\n \n-        match a.kind {\n+        match *a.kind() {\n             ty::FnDef(..) => {\n                 // Function items are coercible to any closure\n                 // type; function pointers are not (that would\n@@ -252,7 +252,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let (r_a, mt_a) = match a.kind {\n+        let (r_a, mt_a) = match *a.kind() {\n             ty::Ref(r_a, ty, mutbl) => {\n                 let mt_a = ty::TypeAndMut { ty, mutbl };\n                 coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n@@ -415,7 +415,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n-        let r_borrow = match ty.kind {\n+        let r_borrow = match ty.kind() {\n             ty::Ref(r_borrow, _, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n@@ -490,7 +490,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // that, at which point we will need extra checks on the target here.\n \n         // Handle reborrows before selecting `Source: CoerceUnsized<Target>`.\n-        let reborrow = match (&source.kind, &target.kind) {\n+        let reborrow = match (source.kind(), target.kind()) {\n             (&ty::Ref(_, ty_a, mutbl_a), &ty::Ref(_, _, mutbl_b)) => {\n                 coerce_mutbls(mutbl_a, mutbl_b)?;\n \n@@ -588,7 +588,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 {\n                     if unsize_did == trait_pred.def_id() {\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n-                        if let ty::Tuple(..) = unsize_ty.kind {\n+                        if let ty::Tuple(..) = unsize_ty.kind() {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n@@ -608,7 +608,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let self_ty = trait_pred.skip_binder().self_ty();\n                         let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_pred);\n-                        match (&self_ty.kind, &unsize_ty.kind) {\n+                        match (&self_ty.kind(), &unsize_ty.kind()) {\n                             (ty::Infer(ty::TyVar(v)), ty::Dynamic(..))\n                                 if self.type_var_is_sized(*v) =>\n                             {\n@@ -672,7 +672,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         F: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n         G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n-        if let ty::FnPtr(fn_ty_b) = b.kind {\n+        if let ty::FnPtr(fn_ty_b) = b.kind() {\n             if let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n                 (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n             {\n@@ -712,7 +712,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n-        match b.kind {\n+        match b.kind() {\n             ty::FnPtr(b_sig) => {\n                 let a_sig = a.fn_sig(self.tcx);\n                 // Intrinsics are not coercible to function pointers\n@@ -721,7 +721,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n \n                 // Safe `#[target_feature]` functions are not assignable to safe fn pointers (RFC 2396).\n-                if let ty::FnDef(def_id, _) = a.kind {\n+                if let ty::FnDef(def_id, _) = *a.kind() {\n                     if b_sig.unsafety() == hir::Unsafety::Normal\n                         && !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n                     {\n@@ -771,7 +771,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         let b = self.shallow_resolve(b);\n \n-        match b.kind {\n+        match b.kind() {\n             ty::FnPtr(fn_ty) if substs_a.as_closure().upvar_tys().next().is_none() => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n@@ -802,7 +802,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     ) -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={:?}, b={:?})\", a, b);\n \n-        let (is_ref, mt_a) = match a.kind {\n+        let (is_ref, mt_a) = match *a.kind() {\n             ty::Ref(_, ty, mutbl) => (true, ty::TypeAndMut { ty, mutbl }),\n             ty::RawPtr(mt) => (false, mt),\n             _ => return self.unify_and(a, b, identity),\n@@ -912,10 +912,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     false\n                 }\n             };\n-            if is_capturing_closure(&prev_ty.kind) || is_capturing_closure(&new_ty.kind) {\n+            if is_capturing_closure(&prev_ty.kind()) || is_capturing_closure(&new_ty.kind()) {\n                 (None, None)\n             } else {\n-                match (&prev_ty.kind, &new_ty.kind) {\n+                match (&prev_ty.kind(), &new_ty.kind()) {\n                     (&ty::FnDef(..), &ty::FnDef(..)) => {\n                         // Don't reify if the function types have a LUB, i.e., they\n                         // are the same function and their parameters have a LUB.\n@@ -969,12 +969,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Reify both sides and return the reified fn pointer type.\n             let fn_ptr = self.tcx.mk_fn_ptr(sig);\n-            let prev_adjustment = match prev_ty.kind {\n+            let prev_adjustment = match prev_ty.kind() {\n                 ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(a_sig.unsafety())),\n                 ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n                 _ => unreachable!(),\n             };\n-            let next_adjustment = match new_ty.kind {\n+            let next_adjustment = match new_ty.kind() {\n                 ty::Closure(..) => Adjust::Pointer(PointerCast::ClosureFnPointer(b_sig.unsafety())),\n                 ty::FnDef(..) => Adjust::Pointer(PointerCast::ReifyFnPointer),\n                 _ => unreachable!(),\n@@ -1024,7 +1024,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let noop = match self.typeck_results.borrow().expr_adjustments(expr) {\n                 &[Adjustment { kind: Adjust::Deref(_), .. }, Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }] =>\n                 {\n-                    match self.node_ty(expr.hir_id).kind {\n+                    match *self.node_ty(expr.hir_id).kind() {\n                         ty::Ref(_, _, mt_orig) => {\n                             let mutbl_adj: hir::Mutability = mutbl_adj.into();\n                             // Reborrow that we can safely ignore, because\n@@ -1501,7 +1501,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             if let hir::TyKind::OpaqueDef(..) = ty.kind {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n                 // Get the `impl Trait`'s `DefId`.\n-                if let ty::Opaque(def_id, _) = ty.kind {\n+                if let ty::Opaque(def_id, _) = ty.kind() {\n                     let hir_id = fcx.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n                     // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                     // get the `Trait`'s `DefId`.\n@@ -1542,7 +1542,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id) {\n             if let hir::FnRetTy::Return(ty) = fn_decl.output {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n-                if let ty::Dynamic(..) = ty.kind {\n+                if let ty::Dynamic(..) = ty.kind() {\n                     return true;\n                 }\n             }"}, {"sha": "f6b768bb1222005233b3be4dc6853ea42ba64d33", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         expr_ty: Ty<'tcx>,\n     ) {\n-        if let ty::Adt(expected_adt, substs) = expected.kind {\n+        if let ty::Adt(expected_adt, substs) = expected.kind() {\n             if !expected_adt.is_enum() {\n                 return;\n             }\n@@ -413,8 +413,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // `ExprKind::DropTemps` is semantically irrelevant for these suggestions.\n         let expr = expr.peel_drop_temps();\n \n-        match (&expr.kind, &expected.kind, &checked_ty.kind) {\n-            (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (&exp.kind, &check.kind) {\n+        match (&expr.kind, expected.kind(), checked_ty.kind()) {\n+            (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (exp.kind(), check.kind()) {\n                 (&ty::Str, &ty::Array(arr, _) | &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n                     if let hir::ExprKind::Lit(_) = expr.kind {\n                         if let Ok(src) = sm.span_to_snippet(sp) {\n@@ -774,7 +774,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let suffix_suggestion = with_opt_paren(&format_args!(\n             \"{}{}\",\n             if matches!(\n-                (&expected_ty.kind, &checked_ty.kind),\n+                (&expected_ty.kind(), &checked_ty.kind()),\n                 (ty::Int(_) | ty::Uint(_), ty::Float(_))\n             ) {\n                 // Remove fractional part from literal, for example `42.0f32` into `42`\n@@ -790,7 +790,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let is_negative_int =\n             |expr: &hir::Expr<'_>| matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::UnNeg, ..));\n-        let is_uint = |ty: Ty<'_>| matches!(ty.kind, ty::Uint(..));\n+        let is_uint = |ty: Ty<'_>| matches!(ty.kind(), ty::Uint(..));\n \n         let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n \n@@ -857,7 +857,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_suggestion(expr.span, msg, suggestion, Applicability::MachineApplicable);\n             };\n \n-        match (&expected_ty.kind, &checked_ty.kind) {\n+        match (&expected_ty.kind(), &checked_ty.kind()) {\n             (&ty::Int(ref exp), &ty::Int(ref found)) => {\n                 let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n                 {"}, {"sha": "ae94a6df5fd4768e4319eaa73e33073ae747d780", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -34,7 +34,7 @@ use rustc_trait_selection::traits::{ObligationCause, TraitEngine, TraitEngineExt\n pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), ErrorReported> {\n     let dtor_self_type = tcx.type_of(drop_impl_did);\n     let dtor_predicates = tcx.predicates_of(drop_impl_did);\n-    match dtor_self_type.kind {\n+    match dtor_self_type.kind() {\n         ty::Adt(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,"}, {"sha": "05fd957e1f4ef6299dd2b80e3f724aa6abc9d026", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn check_expr_box(&self, expr: &'tcx hir::Expr<'tcx>, expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| match ty.kind {\n+        let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| match ty.kind() {\n             ty::Adt(def, _) if def.is_box() => Expectation::rvalue_hint(self, ty.boxed_ty()),\n             _ => NoExpectation,\n         });\n@@ -346,7 +346,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 hir::UnOp::UnNot => {\n                     let result = self.check_user_unop(expr, oprnd_t, unop);\n                     // If it's builtin, we can reuse the type, this helps inference.\n-                    if !(oprnd_t.is_integral() || oprnd_t.kind == ty::Bool) {\n+                    if !(oprnd_t.is_integral() || *oprnd_t.kind() == ty::Bool) {\n                         oprnd_t = result;\n                     }\n                 }\n@@ -371,7 +371,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n-            match ty.kind {\n+            match ty.kind() {\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n                     if oprnd.is_syntactic_place_expr() {\n                         // Places may legitimately have unsized types.\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n         };\n \n-        if let ty::FnDef(..) = ty.kind {\n+        if let ty::FnDef(..) = ty.kind() {\n             let fn_sig = ty.fn_sig(tcx);\n             if !tcx.features().unsized_locals {\n                 // We want to remove some Sized bounds from std functions,\n@@ -951,7 +951,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             error,\n             Some(args),\n         ) {\n-            if let ty::Adt(..) = rcvr_t.kind {\n+            if let ty::Adt(..) = rcvr_t.kind() {\n                 // Try alternative arbitrary self types that could fulfill this call.\n                 // FIXME: probe for all types that *could* be arbitrary self-types, not\n                 // just this list.\n@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let element_ty = if !args.is_empty() {\n             let coerce_to = expected\n                 .to_option(self)\n-                .and_then(|uty| match uty.kind {\n+                .and_then(|uty| match *uty.kind() {\n                     ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                     _ => None,\n                 })\n@@ -1040,7 +1040,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let count = self.to_const(count);\n \n         let uty = match expected {\n-            ExpectHasType(uty) => match uty.kind {\n+            ExpectHasType(uty) => match *uty.kind() {\n                 ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n                 _ => None,\n             },\n@@ -1077,7 +1077,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n             let ty = self.resolve_vars_with_obligations(ty);\n-            match ty.kind {\n+            match ty.kind() {\n                 ty::Tuple(ref flds) => Some(&flds[..]),\n                 _ => None,\n             }\n@@ -1145,7 +1145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // when certain fields are assumed to exist that in fact do not.\n             if !error_happened {\n                 self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {});\n-                match adt_ty.kind {\n+                match adt_ty.kind() {\n                     ty::Adt(adt, substs) if adt.is_struct() => {\n                         let fru_field_types = adt\n                             .non_enum_variant()\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // re-link the regions that EIfEO can erase.\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n-        let (substs, adt_kind, kind_name) = match &adt_ty.kind {\n+        let (substs, adt_kind, kind_name) = match &adt_ty.kind() {\n             &ty::Adt(adt, substs) => (substs, adt.adt_kind(), adt.variant_descr()),\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\"),\n         };\n@@ -1331,7 +1331,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let mut err = self.type_error_struct_with_diag(\n             field.ident.span,\n-            |actual| match ty.kind {\n+            |actual| match ty.kind() {\n                 ty::Adt(adt, ..) if adt.is_enum() => struct_span_err!(\n                     self.tcx.sess,\n                     field.ident.span,\n@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    match ty.kind {\n+                    match ty.kind() {\n                         ty::Adt(adt, ..) => {\n                             if adt.is_enum() {\n                                 err.span_label(\n@@ -1468,7 +1468,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, _)) = autoderef.next() {\n-            match base_t.kind {\n+            match base_t.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\", base_t);\n                     let (ident, def_scope) =\n@@ -1571,9 +1571,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\n                 \"suggest_await_on_field_access: normalized_ty={:?}, ty_kind={:?}\",\n                 self.resolve_vars_if_possible(&normalized_ty),\n-                normalized_ty.kind,\n+                normalized_ty.kind(),\n             );\n-            if let ty::Adt(def, _) = normalized_ty.kind {\n+            if let ty::Adt(def, _) = normalized_ty.kind() {\n                 // no field access on enum type\n                 if !def.is_enum() {\n                     if def.non_enum_variant().fields.iter().any(|field| field.ident == field_ident)\n@@ -1603,7 +1603,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         let mut err = self.no_such_field_err(field.span, field, expr_t);\n \n-        match expr_t.peel_refs().kind {\n+        match *expr_t.peel_refs().kind() {\n             ty::Array(_, len) => {\n                 self.maybe_suggest_array_indexing(&mut err, expr, base, field, len);\n             }\n@@ -1823,7 +1823,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         base_t\n                     );\n                     // Try to give some advice about indexing tuples.\n-                    if let ty::Tuple(..) = base_t.kind {\n+                    if let ty::Tuple(..) = base_t.kind() {\n                         let mut needs_note = true;\n                         // If the index is an integer, we can show the actual\n                         // fixed expression:\n@@ -1908,7 +1908,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // function.\n         if is_input {\n             let ty = self.structurally_resolved_type(expr.span, &ty);\n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::FnDef(..) => {\n                     let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));\n                     self.demand_coerce(expr, ty, fnptr_ty, None, AllowTwoPhase::No);\n@@ -1956,7 +1956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n-    Some(match ty.kind {\n+    Some(match ty.kind() {\n         ty::Bool => \"true\",\n         ty::Char => \"'a'\",\n         ty::Int(_) | ty::Uint(_) => \"42\","}, {"sha": "ae338cccf797791ab1e77e881f37d0f279557a17", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         self.fcx\n             .autoderef(self.span, self_ty)\n             .include_raw_pointers()\n-            .find_map(|(ty, _)| match ty.kind {\n+            .find_map(|(ty, _)| match ty.kind() {\n                 ty::Dynamic(ref data, ..) => Some(closure(\n                     self,\n                     ty,\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 }\n                 _ => None,\n             })\n-            .find_map(|(trait_pred, span)| match trait_pred.self_ty().kind {\n+            .find_map(|(trait_pred, span)| match trait_pred.self_ty().kind() {\n                 ty::Dynamic(..) => Some(span),\n                 _ => None,\n             })"}, {"sha": "84bc3979e1229fe7f531b32e49d76cc1478119b7", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(span) = result.illegal_sized_bound {\n             let mut needs_mut = false;\n-            if let ty::Ref(region, t_type, mutability) = self_ty.kind {\n+            if let ty::Ref(region, t_type, mutability) = self_ty.kind() {\n                 let trait_type = self\n                     .tcx\n                     .mk_ref(region, ty::TypeAndMut { ty: t_type, mutbl: mutability.invert() });\n@@ -424,7 +424,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         // Check if we have an enum variant.\n-        if let ty::Adt(adt_def, _) = self_ty.kind {\n+        if let ty::Adt(adt_def, _) = self_ty.kind() {\n             if adt_def.is_enum() {\n                 let variant_def = adt_def\n                     .variants"}, {"sha": "7645ea4ff8cd7e1f2c0336169823d5bec7107795", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .probe_instantiate_query_response(span, &orig_values, ty)\n                     .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n                 let ty = self.structurally_resolved_type(span, ty.value);\n-                assert!(matches!(ty.kind, ty::Error(_)));\n+                assert!(matches!(ty.kind(), ty::Error(_)));\n                 return Err(MethodError::NoMatch(NoMatchData::new(\n                     Vec::new(),\n                     Vec::new(),\n@@ -469,7 +469,7 @@ fn method_autoderef_steps<'tcx>(\n                     from_unsafe_deref: reached_raw_pointer,\n                     unsize: false,\n                 };\n-                if let ty::RawPtr(_) = ty.kind {\n+                if let ty::RawPtr(_) = ty.kind() {\n                     // all the subsequent steps will be from_unsafe_deref\n                     reached_raw_pointer = true;\n                 }\n@@ -478,7 +478,7 @@ fn method_autoderef_steps<'tcx>(\n             .collect();\n \n         let final_ty = autoderef.final_ty(true);\n-        let opt_bad_ty = match final_ty.kind {\n+        let opt_bad_ty = match final_ty.kind() {\n             ty::Infer(ty::TyVar(_)) | ty::Error(_) => Some(MethodAutoderefBadTy {\n                 reached_raw_pointer,\n                 ty: infcx\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n         let lang_items = self.tcx.lang_items();\n \n-        match self_ty.value.value.kind {\n+        match *self_ty.value.value.kind() {\n             ty::Dynamic(ref data, ..) => {\n                 if let Some(p) = data.principal() {\n                     // Subtle: we can't use `instantiate_query_response` here: using it will\n@@ -759,7 +759,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     fn assemble_inherent_candidates_from_object(&mut self, self_ty: Ty<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={:?})\", self_ty);\n \n-        let principal = match self_ty.kind {\n+        let principal = match self_ty.kind() {\n             ty::Dynamic(ref data, ..) => Some(data),\n             _ => None,\n         }\n@@ -806,7 +806,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(\n                 |predicate| match predicate {\n                     ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        match trait_predicate.trait_ref.self_ty().kind {\n+                        match trait_predicate.trait_ref.self_ty().kind() {\n                             ty::Param(ref p) if *p == param_ty => {\n                                 Some(ty::Binder::bind(trait_predicate.trait_ref))\n                             }\n@@ -1125,7 +1125,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 pick.autoderefs = step.autoderefs;\n \n                 // Insert a `&*` or `&mut *` if this is a reference type:\n-                if let ty::Ref(_, _, mutbl) = step.self_ty.value.value.kind {\n+                if let ty::Ref(_, _, mutbl) = *step.self_ty.value.value.kind() {\n                     pick.autoderefs += 1;\n                     pick.autoref = Some(mutbl);\n                 }"}, {"sha": "e33a4e98c593aecc34a220d353d045b13998242d", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -31,7 +31,7 @@ use super::{CandidateSource, MethodError, NoMatchData};\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn is_fn_ty(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let tcx = self.tcx;\n-        match ty.kind {\n+        match ty.kind() {\n             // Not all of these (e.g., unsafe fns) implement `FnOnce`,\n             // so we look for these beforehand.\n             ty::Closure(..) | ty::FnDef(..) | ty::FnPtr(_) => true,\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 );\n                             }\n                         }\n-                        if let ty::RawPtr(_) = &actual.kind {\n+                        if let ty::RawPtr(_) = &actual.kind() {\n                             err.note(\n                                 \"try using `<*const T>::as_ref()` to get a reference to the \\\n                                       type behind the pointer: https://doc.rust-lang.org/std/\\\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let SelfSource::MethodCall(expr) = source {\n                     let field_receiver =\n-                        self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind {\n+                        self.autoderef(span, rcvr_ty).find_map(|(ty, _)| match ty.kind() {\n                             ty::Adt(def, substs) if !def.is_enum() => {\n                                 let variant = &def.non_enum_variant();\n                                 self.tcx.find_field_index(item_name, variant).map(|index| {\n@@ -545,7 +545,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // original type that has the associated function for accurate suggestions.\n                         // (#61411)\n                         let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind, &actual.peel_refs().kind) {\n+                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n                             (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n                                 // Use `actual` as it will have more `substs` filled in.\n                                 self.ty_to_value_string(actual.peel_refs())\n@@ -583,9 +583,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         |self_ty: Ty<'tcx>, parent_pred: &ty::Predicate<'tcx>, obligation: &str| {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n                             if let (ty::Param(_), ty::PredicateAtom::Trait(p, _)) =\n-                                (&self_ty.kind, parent_pred.skip_binders())\n+                                (self_ty.kind(), parent_pred.skip_binders())\n                             {\n-                                if let ty::Adt(def, _) = p.trait_ref.self_ty().kind {\n+                                if let ty::Adt(def, _) = p.trait_ref.self_ty().kind() {\n                                     let node = def.did.as_local().map(|def_id| {\n                                         self.tcx\n                                             .hir()\n@@ -615,7 +615,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             \"doesn't satisfy `{}`\",\n                             if obligation.len() > 50 { quiet } else { obligation }\n                         );\n-                        match &self_ty.kind {\n+                        match &self_ty.kind() {\n                             // Point at the type that couldn't satisfy the bound.\n                             ty::Adt(def, _) => bound_spans.push((def_span(def.did), msg)),\n                             // Point at the trait object that couldn't satisfy the bound.\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                     self.suggest_use_candidates(&mut err, help, candidates);\n                 }\n-                if let ty::Ref(region, t_type, mutability) = rcvr_ty.kind {\n+                if let ty::Ref(region, t_type, mutability) = rcvr_ty.kind() {\n                     if needs_mut {\n                         let trait_type = self.tcx.mk_ref(\n                             region,\n@@ -856,7 +856,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Print out the type for use in value namespace.\n     fn ty_to_value_string(&self, ty: Ty<'tcx>) -> String {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Adt(def, substs) => format!(\"{}\", ty::Instance::new(def.did, substs)),\n             _ => self.ty_to_string(ty),\n         }\n@@ -870,7 +870,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         call: &hir::Expr<'_>,\n         span: Span,\n     ) {\n-        if let ty::Opaque(def_id, _) = ty.kind {\n+        if let ty::Opaque(def_id, _) = *ty.kind() {\n             let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n             // Future::Output\n             let item_def_id = self\n@@ -897,7 +897,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 debug!(\n                     \"suggest_await_before_method: normalized_ty={:?}, ty_kind={:?}\",\n                     self.resolve_vars_if_possible(&normalized_ty),\n-                    normalized_ty.kind,\n+                    normalized_ty.kind(),\n                 );\n                 let method_exists = self.method_exists(item_name, normalized_ty, call.hir_id, true);\n                 debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n@@ -1089,9 +1089,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             candidates.sort_by(|a, b| a.cmp(b).reverse());\n             candidates.dedup();\n \n-            let param_type = match rcvr_ty.kind {\n+            let param_type = match rcvr_ty.kind() {\n                 ty::Param(param) => Some(param),\n-                ty::Ref(_, ty, _) => match ty.kind {\n+                ty::Ref(_, ty, _) => match ty.kind() {\n                     ty::Param(param) => Some(param),\n                     _ => None,\n                 },\n@@ -1243,7 +1243,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// autoderefs of `rcvr_ty`.\n     fn type_derefs_to_local(&self, span: Span, rcvr_ty: Ty<'tcx>, source: SelfSource<'_>) -> bool {\n         fn is_local(ty: Ty<'_>) -> bool {\n-            match ty.kind {\n+            match ty.kind() {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n "}, {"sha": "cb5f5731aa6117f8ae716b3c3aa36cd5331a2676", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// See the test case `test/ui/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match fcx.tcx.struct_tail_without_normalization(ty).kind {\n+        match fcx.tcx.struct_tail_without_normalization(ty).kind() {\n             ty::Slice(_) | ty::Str | ty::Dynamic(..) => ExpectRvalueLikeUnsized(ty),\n             _ => ExpectHasType(ty),\n         }\n@@ -884,7 +884,7 @@ where\n         }\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Opaque(def_id, substs) => {\n                     debug!(\"fixup_opaque_types: found type {:?}\", ty);\n                     // Here, we replace any inference variables that occur within\n@@ -900,7 +900,7 @@ where\n                             let old_param = substs[param.index as usize];\n                             match old_param.unpack() {\n                                 GenericArgKind::Type(old_ty) => {\n-                                    if let ty::Infer(_) = old_ty.kind {\n+                                    if let ty::Infer(_) = old_ty.kind() {\n                                         // Replace inference type with a generic parameter\n                                         self.tcx.mk_param_from_def(param)\n                                     } else {\n@@ -1366,7 +1366,7 @@ fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    if let ty::Dynamic(..) = declared_ret_ty.kind {\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n         // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n@@ -1465,15 +1465,15 @@ fn check_fn<'a, 'tcx>(\n     if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n         if panic_impl_did == hir.local_def_id(fn_id).to_def_id() {\n             if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n-                if declared_ret_ty.kind != ty::Never {\n+                if *declared_ret_ty.kind() != ty::Never {\n                     sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n                 let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n-                    let arg_is_panic_info = match inputs[0].kind {\n-                        ty::Ref(region, ty, mutbl) => match ty.kind {\n+                    let arg_is_panic_info = match *inputs[0].kind() {\n+                        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n                             ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did\n                                     && mutbl == hir::Mutability::Not\n@@ -1509,14 +1509,14 @@ fn check_fn<'a, 'tcx>(\n     if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n         if alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id() {\n             if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n-                if declared_ret_ty.kind != ty::Never {\n+                if *declared_ret_ty.kind() != ty::Never {\n                     sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n                 let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n-                    let arg_is_alloc_layout = match inputs[0].kind {\n+                    let arg_is_alloc_layout = match inputs[0].kind() {\n                         ty::Adt(ref adt, _) => adt.did == alloc_layout_did,\n                         _ => false,\n                     };\n@@ -1577,7 +1577,7 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n /// check that the fields of the `union` does not contain fields that need dropping.\n fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n     let item_type = tcx.type_of(item_def_id);\n-    if let ty::Adt(def, substs) = item_type.kind {\n+    if let ty::Adt(def, substs) = item_type.kind() {\n         assert!(def.is_union());\n         let fields = &def.non_enum_variant().fields;\n         let param_env = tcx.param_env(item_def_id);\n@@ -1598,7 +1598,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n             }\n         }\n     } else {\n-        span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind);\n+        span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind());\n     }\n     true\n }\n@@ -1758,7 +1758,7 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n             .returns\n             .iter()\n             .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n-            .all(|ty| matches!(ty.kind, ty::Never))\n+            .all(|ty| matches!(ty.kind(), ty::Never))\n         {\n             let spans = visitor\n                 .returns\n@@ -1787,12 +1787,12 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n                 .returns\n                 .iter()\n                 .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n-                .filter(|(_, ty)| !matches!(ty.kind, ty::Never))\n+                .filter(|(_, ty)| !matches!(ty.kind(), ty::Never))\n             {\n                 struct VisitTypes(Vec<DefId>);\n                 impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-                        match t.kind {\n+                        match *t.kind() {\n                             ty::Opaque(def, _) => {\n                                 self.0.push(def);\n                                 false\n@@ -2426,7 +2426,7 @@ fn bounds_from_generic_predicates<'tcx>(\n             \"<{}>\",\n             types\n                 .keys()\n-                .filter_map(|t| match t.kind {\n+                .filter_map(|t| match t.kind() {\n                     ty::Param(_) => Some(t.to_string()),\n                     // Avoid suggesting the following:\n                     // fn foo<T, <T as Trait>::Bar>(_: T) where T: Trait, <T as Trait>::Bar: Other {}\n@@ -2471,15 +2471,15 @@ fn fn_sig_suggestion<'tcx>(\n         .iter()\n         .enumerate()\n         .map(|(i, ty)| {\n-            Some(match ty.kind {\n+            Some(match ty.kind() {\n                 ty::Param(_) if assoc.fn_has_self_parameter && i == 0 => \"self\".to_string(),\n                 ty::Ref(reg, ref_ty, mutability) if i == 0 => {\n                     let reg = match &format!(\"{}\", reg)[..] {\n                         \"'_\" | \"\" => String::new(),\n                         reg => format!(\"{} \", reg),\n                     };\n                     if assoc.fn_has_self_parameter {\n-                        match ref_ty.kind {\n+                        match ref_ty.kind() {\n                             ty::Param(param) if param.name == kw::SelfUpper => {\n                                 format!(\"&{}{}self\", reg, mutability.prefix_str())\n                             }\n@@ -2570,7 +2570,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bo\n \n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     let t = tcx.type_of(def_id);\n-    if let ty::Adt(def, substs) = t.kind {\n+    if let ty::Adt(def, substs) = t.kind() {\n         if def.is_struct() {\n             let fields = &def.non_enum_variant().fields;\n             if fields.is_empty() {\n@@ -2584,7 +2584,7 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n                     .emit();\n                 return;\n             }\n-            match e.kind {\n+            match e.kind() {\n                 ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n                 _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }\n                 _ => {\n@@ -2678,15 +2678,15 @@ fn check_packed_inner(\n     def_id: DefId,\n     stack: &mut Vec<DefId>,\n ) -> Option<Vec<(DefId, Span)>> {\n-    if let ty::Adt(def, substs) = tcx.type_of(def_id).kind {\n+    if let ty::Adt(def, substs) = tcx.type_of(def_id).kind() {\n         if def.is_struct() || def.is_union() {\n             if def.repr.align.is_some() {\n                 return Some(vec![(def.did, DUMMY_SP)]);\n             }\n \n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n-                if let ty::Adt(def, _) = field.ty(tcx, substs).kind {\n+                if let ty::Adt(def, _) = field.ty(tcx, substs).kind() {\n                     if !stack.contains(&def.did) {\n                         if let Some(mut defs) = check_packed_inner(tcx, def.did, stack) {\n                             defs.push((def.did, field.ident.span));\n@@ -3862,7 +3862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n             trait_ref, self_ty, expected_vid\n         );\n-        match self_ty.kind {\n+        match *self_ty.kind() {\n             ty::Infer(ty::TyVar(found_vid)) => {\n                 // FIXME: consider using `sub_root_var` here so we\n                 // can see through subtyping.\n@@ -4042,15 +4042,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let formal_tys = if tuple_arguments == TupleArguments {\n             let tuple_type = self.structurally_resolved_type(sp, fn_inputs[0]);\n-            match tuple_type.kind {\n+            match tuple_type.kind() {\n                 ty::Tuple(arg_types) if arg_types.len() != args.len() => {\n                     param_count_error(arg_types.len(), args.len(), \"E0057\", false, false);\n                     expected_arg_tys = vec![];\n                     self.err_args(args.len())\n                 }\n                 ty::Tuple(arg_types) => {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n-                        Some(&ty) => match ty.kind {\n+                        Some(&ty) => match ty.kind() {\n                             ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n                             _ => vec![],\n                         },\n@@ -4195,7 +4195,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // There are a few types which get autopromoted when passed via varargs\n                 // in C but we just error out instead and require explicit casts.\n                 let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n-                match arg_ty.kind {\n+                match arg_ty.kind() {\n                     ty::Float(ast::FloatTy::F32) => {\n                         variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n                     }\n@@ -4345,7 +4345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ast::LitKind::Int(_, ast::LitIntType::Signed(t)) => tcx.mk_mach_int(t),\n             ast::LitKind::Int(_, ast::LitIntType::Unsigned(t)) => tcx.mk_mach_uint(t),\n             ast::LitKind::Int(_, ast::LitIntType::Unsuffixed) => {\n-                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind {\n+                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n                     ty::Int(_) | ty::Uint(_) => Some(ty),\n                     ty::Char => Some(tcx.types.u8),\n                     ty::RawPtr(..) => Some(tcx.types.usize),\n@@ -4356,7 +4356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ast::LitKind::Float(_, ast::LitFloatType::Suffixed(t)) => tcx.mk_mach_float(t),\n             ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n-                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind {\n+                let opt_ty = expected.to_option(self).and_then(|ty| match ty.kind() {\n                     ty::Float(_) => Some(ty),\n                     _ => None,\n                 });\n@@ -4434,12 +4434,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Res::Def(DefKind::Variant, _) => match ty.kind {\n+            Res::Def(DefKind::Variant, _) => match ty.kind() {\n                 ty::Adt(adt, substs) => Some((adt.variant_of_res(def), adt.did, substs)),\n                 _ => bug!(\"unexpected type: {:?}\", ty),\n             },\n             Res::Def(DefKind::Struct | DefKind::Union | DefKind::TyAlias | DefKind::AssocTy, _)\n-            | Res::SelfTy(..) => match ty.kind {\n+            | Res::SelfTy(..) => match ty.kind() {\n                 ty::Adt(adt, substs) if !adt.is_enum() => {\n                     Some((adt.non_enum_variant(), adt.did, substs))\n                 }\n@@ -4976,7 +4976,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n     ) -> bool {\n         let hir = self.tcx.hir();\n-        let (def_id, sig) = match found.kind {\n+        let (def_id, sig) = match *found.kind() {\n             ty::FnDef(def_id, _) => (def_id, found.fn_sig(self.tcx)),\n             ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig()),\n             _ => return false,\n@@ -5109,7 +5109,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n             err.span_suggestion(sp, msg, suggestion, applicability);\n         } else if let (ty::FnDef(def_id, ..), true) =\n-            (&found.kind, self.suggest_fn_call(err, expr, expected, found))\n+            (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n         {\n             if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n                 let sp = self.sess().source_map().guess_head_span(sp);\n@@ -5256,7 +5256,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return false;\n         }\n         let pin_did = self.tcx.lang_items().pin_type();\n-        match expected.kind {\n+        match expected.kind() {\n             ty::Adt(def, _) if Some(def.did) != pin_did => return false,\n             // This guards the `unwrap` and `mk_box` below.\n             _ if pin_did.is_none() || self.tcx.lang_items().owned_box().is_none() => return false,\n@@ -5268,7 +5268,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.can_coerce(new_found, expected),\n             self.sess().source_map().span_to_snippet(expr.span),\n         ) {\n-            match found.kind {\n+            match found.kind() {\n                 ty::Adt(def, _) if def.is_box() => {\n                     err.help(\"use `Box::pin`\");\n                 }\n@@ -5376,7 +5376,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let ty = AstConv::ast_ty_to_ty(self, ty);\n                 debug!(\"suggest_missing_return_type: return type {:?}\", ty);\n                 debug!(\"suggest_missing_return_type: expected type {:?}\", ty);\n-                if ty.kind == expected.kind {\n+                if ty.kind() == expected.kind() {\n                     err.span_label(sp, format!(\"expected `{}` because of return type\", expected));\n                     return true;\n                 }\n@@ -5480,7 +5480,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n-        let (sig, did, substs) = match (&expected.kind, &found.kind) {\n+        let (sig, did, substs) = match (&expected.kind(), &found.kind()) {\n             (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n                 let sig1 = self.tcx.fn_sig(*did1).subst(self.tcx, substs1);\n                 let sig2 = self.tcx.fn_sig(*did2).subst(self.tcx, substs2);\n@@ -5551,7 +5551,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        if matches!(last_expr_ty.kind, ty::Error(_))\n+        if matches!(last_expr_ty.kind(), ty::Error(_))\n             || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err()\n         {\n             return None;\n@@ -5680,7 +5680,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n             let ty = self.normalize_ty(span, tcx.at(span).type_of(impl_def_id));\n-            match ty.kind {\n+            match *ty.kind() {\n                 ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n                     let ctor_def_id = variant.ctor_def_id.unwrap();\n@@ -5992,7 +5992,7 @@ fn check_type_params_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics,\n \n     for leaf in ty.walk() {\n         if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n-            if let ty::Param(param) = leaf_ty.kind {\n+            if let ty::Param(param) = leaf_ty.kind() {\n                 debug!(\"found use of ty param {:?}\", param);\n                 params_used.insert(param.index);\n             }"}, {"sha": "529b8525a4a8d8e2d68e4e48b43519c12c110648", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Ok(method) => {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind() {\n                         let mutbl = match mutbl {\n                             hir::Mutability::Not => AutoBorrowMutability::Not,\n                             hir::Mutability::Mut => AutoBorrowMutability::Mut {\n@@ -223,7 +223,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 if by_ref_binop {\n-                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind {\n+                    if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind() {\n                         let mutbl = match mutbl {\n                             hir::Mutability::Not => AutoBorrowMutability::Not,\n                             hir::Mutability::Mut => AutoBorrowMutability::Mut {\n@@ -395,7 +395,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n                 let mut suggested_deref = false;\n-                if let Ref(_, rty, _) = lhs_ty.kind {\n+                if let Ref(_, rty, _) = lhs_ty.kind() {\n                     if {\n                         self.infcx.type_is_copy_modulo_regions(self.param_env, rty, lhs_expr.span)\n                             && self\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                         // we don't want the note in the else clause to be emitted\n                     } else if let [ty] = &visitor.0[..] {\n-                        if let ty::Param(p) = ty.kind {\n+                        if let ty::Param(p) = *ty.kind() {\n                             // Check if the method would be found if the type param wasn't\n                             // involved. If so, it means that adding a trait bound to the param is\n                             // enough. Otherwise we do not give the suggestion.\n@@ -468,7 +468,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ));\n                             }\n                         } else {\n-                            bug!(\"type param visitor stored a non type param: {:?}\", ty.kind);\n+                            bug!(\"type param visitor stored a non type param: {:?}\", ty.kind());\n                         }\n                     } else if !suggested_deref && !involves_fn {\n                         suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n@@ -494,15 +494,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         is_assign: IsAssign,\n     ) -> bool /* did we suggest to call a function because of missing parenthesis? */ {\n         err.span_label(span, ty.to_string());\n-        if let FnDef(def_id, _) = ty.kind {\n+        if let FnDef(def_id, _) = *ty.kind() {\n             let source_map = self.tcx.sess.source_map();\n             if !self.tcx.has_typeck_results(def_id) {\n                 return false;\n             }\n             // We're emitting a suggestion, so we can just ignore regions\n             let fn_sig = self.tcx.fn_sig(def_id).skip_binder();\n \n-            let other_ty = if let FnDef(def_id, _) = other_ty.kind {\n+            let other_ty = if let FnDef(def_id, _) = *other_ty.kind() {\n                 if !self.tcx.has_typeck_results(def_id) {\n                     return false;\n                 }\n@@ -568,10 +568,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => false,\n         };\n \n-        match (&lhs_ty.kind, &rhs_ty.kind) {\n+        match (lhs_ty.kind(), rhs_ty.kind()) {\n             (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str\n-                if (l_ty.kind == Str || is_std_string(l_ty)) && (\n-                        r_ty.kind == Str || is_std_string(r_ty) ||\n+                if (*l_ty.kind() == Str || is_std_string(l_ty)) && (\n+                        *r_ty.kind() == Str || is_std_string(r_ty) ||\n                         &format!(\"{:?}\", rhs_ty) == \"&&str\"\n                     ) =>\n             {\n@@ -605,7 +605,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 true\n             }\n             (&Ref(_, l_ty, _), &Adt(..)) // Handle `&str` & `&String` + `String`\n-                if (l_ty.kind == Str || is_std_string(l_ty)) && is_std_string(rhs_ty) =>\n+                if (*l_ty.kind() == Str || is_std_string(l_ty)) && is_std_string(rhs_ty) =>\n             {\n                 err.span_label(\n                     op.span,\n@@ -670,12 +670,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ex.span,\n                         format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n-                    match actual.kind {\n+                    match actual.kind() {\n                         Uint(_) if op == hir::UnOp::UnNeg => {\n                             err.note(\"unsigned values cannot be negated\");\n                         }\n                         Str | Never | Char | Tuple(_) | Array(_, _) => {}\n-                        Ref(_, ref lty, _) if lty.kind == Str => {}\n+                        Ref(_, ref lty, _) if *lty.kind() == Str => {}\n                         _ => {\n                             let missing_trait = match op {\n                                 hir::UnOp::UnNeg => \"std::ops::Neg\",\n@@ -844,7 +844,7 @@ enum Op {\n \n /// Dereferences a single level of immutable referencing.\n fn deref_ty_if_possible(ty: Ty<'tcx>) -> Ty<'tcx> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Ref(_, ty, hir::Mutability::Not) => ty,\n         _ => ty,\n     }\n@@ -903,7 +903,7 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n \n /// If applicable, note that an implementation of `trait` for `ty` may fix the error.\n fn suggest_impl_missing(err: &mut DiagnosticBuilder<'_>, ty: Ty<'_>, missing_trait: &str) {\n-    if let Adt(def, _) = ty.peel_refs().kind {\n+    if let Adt(def, _) = ty.peel_refs().kind() {\n         if def.did.is_local() {\n             err.note(&format!(\n                 \"an implementation of `{}` might be missing for `{}`\",\n@@ -957,7 +957,7 @@ struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n \n impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        if let ty::Param(_) = ty.kind {\n+        if let ty::Param(_) = ty.kind() {\n             self.0.push(ty);\n         }\n         ty.super_visit_with(self)\n@@ -972,7 +972,7 @@ impl TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Param(_) => self.0.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::MiscVariable,\n                 span: self.1,"}, {"sha": "f06929aa98ff420b5aace85017d18947b223113c", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -281,7 +281,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // String and byte-string literals result in types `&str` and `&[u8]` respectively.\n             // All other literals result in non-reference types.\n             // As a result, we allow `if let 0 = &&0 {}` but not `if let \"foo\" = &&\"foo {}`.\n-            PatKind::Lit(lt) => match self.check_expr(lt).kind {\n+            PatKind::Lit(lt) => match self.check_expr(lt).kind() {\n                 ty::Ref(..) => AdjustMode::Pass,\n                 _ => AdjustMode::Peel,\n             },\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // See the examples in `ui/match-defbm*.rs`.\n         let mut pat_adjustments = vec![];\n-        while let ty::Ref(_, inner_ty, inner_mutability) = expected.kind {\n+        while let ty::Ref(_, inner_ty, inner_mutability) = *expected.kind() {\n             debug!(\"inspecting {:?}\", expected);\n \n             debug!(\"current discriminant is Ref, inserting implicit deref\");\n@@ -389,9 +389,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut pat_ty = ty;\n         if let hir::ExprKind::Lit(Spanned { node: ast::LitKind::ByteStr(_), .. }) = lt.kind {\n             let expected = self.structurally_resolved_type(span, expected);\n-            if let ty::Ref(_, ty::TyS { kind: ty::Slice(_), .. }, _) = expected.kind {\n-                let tcx = self.tcx;\n-                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n+            if let ty::Ref(_, inner_ty, _) = expected.kind() {\n+                if matches!(inner_ty.kind(), ty::Slice(_)) {\n+                    let tcx = self.tcx;\n+                    pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n+                }\n             }\n         }\n \n@@ -639,7 +641,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n         if let PatKind::Binding(..) = inner.kind {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::Dynamic(..) = mt.ty.kind {\n+                if let ty::Dynamic(..) = mt.ty.kind() {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);\n@@ -871,7 +873,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if subpats.len() == variant.fields.len()\n             || subpats.len() < variant.fields.len() && ddpos.is_some()\n         {\n-            let substs = match pat_ty.kind {\n+            let substs = match pat_ty.kind() {\n                 ty::Adt(_, substs) => substs,\n                 _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n             };\n@@ -924,13 +926,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // More generally, the expected type wants a tuple variant with one field of an\n         // N-arity-tuple, e.g., `V_i((p_0, .., p_N))`. Meanwhile, the user supplied a pattern\n         // with the subpatterns directly in the tuple variant pattern, e.g., `V_i(p_0, .., p_N)`.\n-        let missing_parenthesis = match (&expected.kind, fields, had_err) {\n+        let missing_parenthesis = match (&expected.kind(), fields, had_err) {\n             // #67037: only do this if we could successfully type-check the expected type against\n             // the tuple struct pattern. Otherwise the substs could get out of range on e.g.,\n             // `let P() = U;` where `P != U` with `struct P<T>(T);`.\n             (ty::Adt(_, substs), [field], false) => {\n                 let field_ty = self.field_ty(pat_span, field, substs);\n-                match field_ty.kind {\n+                match field_ty.kind() {\n                     ty::Tuple(_) => field_ty.tuple_fields().count() == subpats.len(),\n                     _ => false,\n                 }\n@@ -981,7 +983,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_len = elements.len();\n         if ddpos.is_some() {\n             // Require known type only when `..` is present.\n-            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).kind {\n+            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).kind() {\n                 expected_len = tys.len();\n             }\n         }\n@@ -1025,7 +1027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> bool {\n         let tcx = self.tcx;\n \n-        let (substs, adt) = match adt_ty.kind {\n+        let (substs, adt) = match adt_ty.kind() {\n             ty::Adt(adt, substs) => (substs, adt),\n             _ => span_bug!(pat.span, \"struct pattern is not an ADT\"),\n         };\n@@ -1378,7 +1380,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // to avoid creating needless variables. This also helps with\n             // the bad  interactions of the given hack detailed in (note_1).\n             debug!(\"check_pat_ref: expected={:?}\", expected);\n-            match expected.kind {\n+            match *expected.kind() {\n                 ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n                 _ => {\n                     let inner_ty = self.next_ty_var(TypeVariableOrigin {\n@@ -1434,7 +1436,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let expected = self.structurally_resolved_type(span, expected);\n-        let (element_ty, opt_slice_ty, inferred) = match expected.kind {\n+        let (element_ty, opt_slice_ty, inferred) = match *expected.kind() {\n             // An array, so we might have something like `let [a, b, c] = [0, 1, 2];`.\n             ty::Array(element_ty, len) => {\n                 let min = before.len() as u64 + after.len() as u64;\n@@ -1570,8 +1572,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"expected an array or slice, found `{}`\",\n             expected_ty\n         );\n-        if let ty::Ref(_, ty, _) = expected_ty.kind {\n-            if let ty::Array(..) | ty::Slice(..) = ty.kind {\n+        if let ty::Ref(_, ty, _) = expected_ty.kind() {\n+            if let ty::Array(..) | ty::Slice(..) = ty.kind() {\n                 err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n             }\n         }"}, {"sha": "cdbed28f754b1bf48faa6d2d3c7103541a5e71ae", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ok = self.try_overloaded_deref(expr.span, oprnd_ty)?;\n         let method = self.register_infer_ok_obligations(ok);\n-        if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+        if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind() {\n             self.apply_adjustments(\n                 oprnd_expr,\n                 vec![Adjustment {\n@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let mut self_ty = adjusted_ty;\n             if unsize {\n                 // We only unsize arrays here.\n-                if let ty::Array(element_ty, _) = adjusted_ty.kind {\n+                if let ty::Array(element_ty, _) = adjusted_ty.kind() {\n                     self_ty = self.tcx.mk_slice(element_ty);\n                 } else {\n                     continue;\n@@ -108,7 +108,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let method = self.register_infer_ok_obligations(ok);\n \n                 let mut adjustments = self.adjust_steps(autoderef);\n-                if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind {\n+                if let ty::Ref(region, _, hir::Mutability::Not) = method.sig.inputs()[0].kind() {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, AutoBorrowMutability::Not)),\n                         target: self.tcx.mk_ref(\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             PlaceOp::Deref,\n                         ) {\n                             let method = self.register_infer_ok_obligations(ok);\n-                            if let ty::Ref(region, _, mutbl) = method.sig.output().kind {\n+                            if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n                                 *deref = OverloadedDeref { region, mutbl };\n                             }\n                         }\n@@ -305,7 +305,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n-        let region = if let ty::Ref(r, _, hir::Mutability::Mut) = method.sig.inputs()[0].kind {\n+        let region = if let ty::Ref(r, _, hir::Mutability::Mut) = method.sig.inputs()[0].kind() {\n             r\n         } else {\n             span_bug!(expr.span, \"input to mutable place op is not a mut ref?\");"}, {"sha": "ba0f22513a146f6cce46c68c47707287711867bd", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -624,7 +624,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::Ref(r, _, _) = rptr_ty.kind {\n+        if let ty::Ref(r, _, _) = rptr_ty.kind() {\n             debug!(\"rptr_ty={}\", rptr_ty);\n             self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n         }\n@@ -649,7 +649,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 \"link_region(borrow_region={:?}, borrow_kind={:?}, pointer_ty={:?})\",\n                 borrow_region, borrow_kind, borrow_place\n             );\n-            match pointer_ty.kind {\n+            match *pointer_ty.kind() {\n                 ty::RawPtr(_) => return,\n                 ty::Ref(ref_region, _, ref_mutability) => {\n                     if self.link_reborrowed_region(span, borrow_region, ref_region, ref_mutability)\n@@ -794,7 +794,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         // A closure capture can't be borrowed for longer than the\n         // reference to the closure.\n-        if let ty::Closure(_, substs) = ty.kind {\n+        if let ty::Closure(_, substs) = ty.kind() {\n             match self.infcx.closure_kind(substs) {\n                 Some(ty::ClosureKind::Fn | ty::ClosureKind::FnMut) => {\n                     // Region of environment pointer"}, {"sha": "2c3be0da5ddd0e71ed1dce8f78a608df32410f73", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Extract the type of the closure.\n         let ty = self.node_ty(closure_hir_id);\n-        let (closure_def_id, substs) = match ty.kind {\n+        let (closure_def_id, substs) = match *ty.kind() {\n             ty::Closure(def_id, substs) => (def_id, UpvarSubsts::Closure(substs)),\n             ty::Generator(def_id, substs, _) => (def_id, UpvarSubsts::Generator(substs)),\n             ty::Error(_) => {\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             let mut borrow_kind = ty::MutBorrow;\n             for pointer_ty in place_with_id.place.deref_tys() {\n-                match pointer_ty.kind {\n+                match pointer_ty.kind() {\n                     // Raw pointers don't inherit mutability.\n                     ty::RawPtr(_) => return,\n                     // assignment to deref of an `&mut`"}, {"sha": "5203f3fa8f1d5b0ddad3eefaa03991558871f856", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -291,7 +291,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n             let err_ty_str;\n             let mut is_ptr = true;\n             let err = if tcx.features().min_const_generics {\n-                match ty.kind {\n+                match ty.kind() {\n                     ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Error(_) => None,\n                     ty::FnPtr(_) => Some(\"function pointers\"),\n                     ty::RawPtr(_) => Some(\"raw pointers\"),\n@@ -302,7 +302,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                     }\n                 }\n             } else {\n-                match ty.peel_refs().kind {\n+                match ty.peel_refs().kind() {\n                     ty::FnPtr(_) => Some(\"function pointers\"),\n                     ty::RawPtr(_) => Some(\"raw pointers\"),\n                     _ => None,\n@@ -338,7 +338,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                 // We use the same error code in both branches, because this is really the same\n                 // issue: we just special-case the message for type parameters to make it\n                 // clearer.\n-                if let ty::Param(_) = ty.peel_refs().kind {\n+                if let ty::Param(_) = ty.peel_refs().kind() {\n                     // Const parameters may not have type parameters as their types,\n                     // because we cannot be sure that the type parameter derives `PartialEq`\n                     // and `Eq` (just implementing them is not enough for `structural_match`).\n@@ -638,7 +638,7 @@ fn check_associated_type_defaults(fcx: &FnCtxt<'_, '_>, trait_def_id: DefId) {\n         }\n \n         fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-            match t.kind {\n+            match t.kind() {\n                 ty::Projection(proj_ty) => {\n                     if let Some(default) = self.map.get(&proj_ty) {\n                         default\n@@ -709,7 +709,7 @@ fn check_item_type(tcx: TyCtxt<'_>, item_id: hir::HirId, ty_span: Span, allow_fo\n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n             let tail = fcx.tcx.struct_tail_erasing_lifetimes(item_ty, fcx.param_env);\n-            if let ty::Foreign(_) = tail.kind {\n+            if let ty::Foreign(_) = tail.kind() {\n                 forbid_unsized = false;\n             }\n         }\n@@ -867,7 +867,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n             }\n             impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n                 fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-                    if let ty::Param(param) = t.kind {\n+                    if let ty::Param(param) = t.kind() {\n                         self.params.insert(param.index);\n                     }\n                     t.super_visit_with(self)\n@@ -1001,7 +1001,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n     ty.fold_with(&mut ty::fold::BottomUpFolder {\n         tcx: fcx.tcx,\n         ty_op: |ty| {\n-            if let ty::Opaque(def_id, substs) = ty.kind {\n+            if let ty::Opaque(def_id, substs) = *ty.kind() {\n                 trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n \n@@ -1044,7 +1044,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                 let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n                 for (i, arg) in substs.iter().enumerate() {\n                     let arg_is_param = match arg.unpack() {\n-                        GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n+                        GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n \n                         GenericArgKind::Lifetime(region) => {\n                             if let ty::ReStatic = region {"}, {"sha": "b55f62ee436e1ab7493bea047bee2f7ad01c60bd", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -193,7 +193,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n \n             // All valid indexing looks like this; might encounter non-valid indexes at this point.\n-            let base_ty = typeck_results.expr_ty_adjusted_opt(&base).map(|t| &t.kind);\n+            let base_ty = typeck_results.expr_ty_adjusted_opt(&base).map(|t| t.kind());\n             if base_ty.is_none() {\n                 // When encountering `return [0][0]` outside of a `fn` body we can encounter a base\n                 // that isn't in the type table. We assume more relevant errors have already been\n@@ -459,7 +459,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             let mut skip_add = false;\n \n-            if let ty::Opaque(defin_ty_def_id, _substs) = definition_ty.kind {\n+            if let ty::Opaque(defin_ty_def_id, _substs) = *definition_ty.kind() {\n                 if let hir::OpaqueTyOrigin::Misc = opaque_defn.origin {\n                     if def_id == defin_ty_def_id {\n                         debug!("}, {"sha": "bc316a45be6699546541db340cdecaf77956d614", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> Checker<'tcx> {\n \n fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     // Destructors only work on nominal types.\n-    if let ty::Adt(..) | ty::Error(_) = tcx.type_of(impl_did).kind {\n+    if let ty::Adt(..) | ty::Error(_) = tcx.type_of(impl_did).kind() {\n         return;\n     }\n \n@@ -168,7 +168,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n         let cause = ObligationCause::misc(span, impl_hir_id);\n \n         use ty::TyKind::*;\n-        match (&source.kind, &target.kind) {\n+        match (source.kind(), target.kind()) {\n             (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n                 if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok() && mutbl_a == *mutbl_b => {}\n             (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n@@ -352,7 +352,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n             }\n             (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n-        let (source, target, trait_def_id, kind) = match (&source.kind, &target.kind) {\n+        let (source, target, trait_def_id, kind) = match (source.kind(), target.kind()) {\n             (&ty::Ref(r_a, ty_a, mutbl_a), &ty::Ref(r_b, ty_b, mutbl_b)) => {\n                 infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                 let mt_a = ty::TypeAndMut { ty: ty_a, mutbl: mutbl_a };"}, {"sha": "042ecdbadc61b3dd8d7b1b1f4878da76c596974b", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -52,7 +52,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         let self_ty = self.tcx.type_of(def_id);\n         let lang_items = self.tcx.lang_items();\n-        match self_ty.kind {\n+        match *self_ty.kind() {\n             ty::Adt(def, _) => {\n                 self.check_def_id(item, def.did);\n             }\n@@ -123,7 +123,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                 );\n             }\n             ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Not })\n-                if matches!(inner.kind, ty::Slice(_)) =>\n+                if matches!(inner.kind(), ty::Slice(_)) =>\n             {\n                 self.check_primitive_impl(\n                     def_id,\n@@ -135,7 +135,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                 );\n             }\n             ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Mut })\n-                if matches!(inner.kind, ty::Slice(_)) =>\n+                if matches!(inner.kind(), ty::Slice(_)) =>\n             {\n                 self.check_primitive_impl(\n                     def_id,"}, {"sha": "4294450333ca3a506cb195e0091ddda6b84046b4", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -209,7 +209,7 @@ fn check_object_overlap<'tcx>(\n     }\n \n     // check for overlap with the automatic `impl Trait for dyn Trait`\n-    if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().kind {\n+    if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().kind() {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n "}, {"sha": "fa3137567ad08303aa155044f52895ca642c2f45", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -52,7 +52,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                             // Remove the lifetimes unnecessary for this error.\n                             ty = infcx.freshen(ty);\n                         });\n-                        ty = match ty.kind {\n+                        ty = match ty.kind() {\n                             // Remove the type arguments from the output, as they are not relevant.\n                             // You can think of this as the reverse of `resolve_vars_if_possible`.\n                             // That way if we had `Vec<MyType>`, we will properly attribute the\n@@ -62,7 +62,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                             _ => ty,\n                         };\n                         let this = \"this\".to_string();\n-                        let (ty, postfix) = match &ty.kind {\n+                        let (ty, postfix) = match &ty.kind() {\n                             ty::Slice(_) => (this, \" because slices are always foreign\"),\n                             ty::Array(..) => (this, \" because arrays are always foreign\"),\n                             ty::Tuple(..) => (this, \" because tuples are always foreign\"),\n@@ -185,7 +185,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n             );\n             if self.tcx.trait_is_auto(trait_def_id) && !trait_def_id.is_local() {\n                 let self_ty = trait_ref.self_ty();\n-                let opt_self_def_id = match self_ty.kind {\n+                let opt_self_def_id = match *self_ty.kind() {\n                     ty::Adt(self_def, _) => Some(self_def.did),\n                     ty::Foreign(did) => Some(did),\n                     _ => None,"}, {"sha": "94555e588bd39baf55664afbb34eee2110a026a6", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -1922,7 +1922,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                 // That way, `where Ty:` is not a complete noop (see #53696) and `Ty`\n                 // is still checked for WF.\n                 if bound_pred.bounds.is_empty() {\n-                    if let ty::Param(_) = ty.kind {\n+                    if let ty::Param(_) = ty.kind() {\n                         // This is a `where T:`, which can be in the HIR from the\n                         // transformation that moves `?Sized` to `T`'s declaration.\n                         // We can skip the predicate because type parameters are"}, {"sha": "f9668f1a0daf01c141062004aaa329d94ac5ff4f", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -382,7 +382,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n                 let mut used_params: FxHashSet<_> = FxHashSet::default();\n                 for (i, arg) in substs.iter().enumerate() {\n                     let arg_is_param = match arg.unpack() {\n-                        GenericArgKind::Type(ty) => matches!(ty.kind, ty::Param(_)),\n+                        GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n                         GenericArgKind::Lifetime(lt) => {\n                             matches!(lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n                         }\n@@ -607,7 +607,7 @@ fn infer_placeholder_type(\n         }\n         None => {\n             let mut diag = bad_placeholder_type(tcx, vec![span]);\n-            if !matches!(ty.kind, ty::Error(_)) {\n+            if !matches!(ty.kind(), ty::Error(_)) {\n                 diag.span_suggestion(\n                     span,\n                     \"replace `_` with the correct type\","}, {"sha": "09b5a9b0a65fc1580b785a5b917d35b2a2ecc77c", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -57,7 +57,7 @@ struct ParameterCollector {\n \n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.kind {\n+        match *t.kind() {\n             ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return false;"}, {"sha": "e16f26c3304014425b9fa481c19dc6cfad2d6ec5", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        match with_place.place.ty().kind {\n+        match with_place.place.ty().kind() {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {"}, {"sha": "b056582faf83d6477b4436a21704f75ae24df7d9", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -158,7 +158,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n     let main_id = tcx.hir().local_def_id_to_hir_id(main_def_id);\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n-    match main_t.kind {\n+    match main_t.kind() {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(main_id) {\n                 if let hir::ItemKind::Fn(ref sig, ref generics, _) = it.kind {\n@@ -254,7 +254,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n     let start_id = tcx.hir().local_def_id_to_hir_id(start_def_id);\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n-    match start_t.kind {\n+    match start_t.kind() {\n         ty::FnDef(..) => {\n             if let Some(Node::Item(it)) = tcx.hir().find(start_id) {\n                 if let hir::ItemKind::Fn(ref sig, ref generics, _) = it.kind {"}, {"sha": "04ead74936f88c25241855a5f46517076dac3031", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -482,7 +482,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let place_ty = self.expr_ty(expr)?;\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n-        let (region, mutbl) = match base_ty.kind {\n+        let (region, mutbl) = match *base_ty.kind() {\n             ty::Ref(region, _, mutbl) => (region, mutbl),\n             _ => span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\"),\n         };\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ) -> McResult<VariantIdx> {\n         let res = self.typeck_results.qpath_res(qpath, pat_hir_id);\n         let ty = self.typeck_results.node_type(pat_hir_id);\n-        let adt_def = match ty.kind {\n+        let adt_def = match ty.kind() {\n             ty::Adt(adt_def, _) => adt_def,\n             _ => {\n                 self.tcx()\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         span: Span,\n     ) -> McResult<usize> {\n         let ty = self.typeck_results.node_type(pat_hir_id);\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Adt(adt_def, _) => Ok(adt_def.variants[variant_index].fields.len()),\n             _ => {\n                 self.tcx()\n@@ -592,7 +592,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Here `pat_hir_id` is the HirId of the pattern itself.\n     fn total_fields_in_tuple(&self, pat_hir_id: hir::HirId, span: Span) -> McResult<usize> {\n         let ty = self.typeck_results.node_type(pat_hir_id);\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Tuple(substs) => Ok(substs.len()),\n             _ => {\n                 self.tcx().sess.delay_span_bug(span, \"tuple pattern not applied to a tuple\");"}, {"sha": "e7a9e078a737f8efdc93d945b14c1c8db4d68696", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -128,7 +128,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n             GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n         };\n \n-        match ty.kind {\n+        match *ty.kind() {\n             // The field is of type &'a T which means that we will have\n             // a predicate requirement of T: 'a (T outlives 'a).\n             //"}, {"sha": "b2b062e40951efc4683a504f253f3d2c2b18e55a", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n-        match tcx.type_of(def_id).kind {\n+        match tcx.type_of(def_id).kind() {\n             ty::Adt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n@@ -257,7 +257,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     ) {\n         debug!(\"add_constraints_from_ty(ty={:?}, variance={:?})\", ty, variance);\n \n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Bool\n             | ty::Char\n             | ty::Int(_)"}, {"sha": "2d3369cba7a1e9f2b37b02dcbb8a7cfca1740ce4", "filename": "compiler/rustc_typeck/src/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fsolve.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 self.enforce_const_invariance(generics, variances);\n \n                 // Functions are permitted to have unused generic parameters: make those invariant.\n-                if let ty::FnDef(..) = tcx.type_of(def_id).kind {\n+                if let ty::FnDef(..) = tcx.type_of(def_id).kind() {\n                     for variance in variances.iter_mut() {\n                         if *variance == ty::Bivariant {\n                             *variance = ty::Invariant;"}, {"sha": "de5a9a615557cf82282b51dfddbd1eb3efd84851", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                 );\n                 let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let may_apply = self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                    match trait_ref.self_ty().kind {\n+                    match trait_ref.self_ty().kind() {\n                         ty::Param(_) => {}\n                         _ => return false,\n                     }"}, {"sha": "1bdbad4675556781bfa3a513b7714ad952be1e58", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -764,17 +764,17 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                 let param_idx = (|| {\n                     match p.skip_binders() {\n                         ty::PredicateAtom::Trait(pred, _constness) => {\n-                            if let ty::Param(param) = pred.self_ty().kind {\n+                            if let ty::Param(param) = pred.self_ty().kind() {\n                                 return Some(param.index);\n                             }\n                         }\n                         ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n-                            if let ty::Param(param) = ty.kind {\n+                            if let ty::Param(param) = ty.kind() {\n                                 return Some(param.index);\n                             }\n                         }\n                         ty::PredicateAtom::Projection(p) => {\n-                            if let ty::Param(param) = p.projection_ty.self_ty().kind {\n+                            if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n                                 projection = Some(ty::Binder::bind(p));\n                                 return Some(param.index);\n                             }\n@@ -1206,7 +1206,7 @@ impl Clean<Item> for ty::AssocItem {\n                     let self_arg_ty = sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n                         decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n-                    } else if let ty::Ref(_, ty, _) = self_arg_ty.kind {\n+                    } else if let ty::Ref(_, ty, _) = *self_arg_ty.kind() {\n                         if ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n                                 BorrowedRef { ref mut type_, .. } => {\n@@ -1511,7 +1511,7 @@ impl Clean<Type> for hir::Ty<'_> {\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut res = Res::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n-                if let ty::Projection(proj) = ty.kind {\n+                if let ty::Projection(proj) = ty.kind() {\n                     res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n                 }\n                 let trait_path = hir::Path { span: self.span, res, segments: &[] };\n@@ -1554,7 +1554,7 @@ impl Clean<Type> for hir::Ty<'_> {\n impl<'tcx> Clean<Type> for Ty<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         debug!(\"cleaning type: {:?}\", self);\n-        match self.kind {\n+        match *self.kind() {\n             ty::Never => Never,\n             ty::Bool => Primitive(PrimitiveType::Bool),\n             ty::Char => Primitive(PrimitiveType::Char),"}, {"sha": "c577b771d6094815f0cae32d256965e7cf013965", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -130,7 +130,7 @@ pub fn external_generic_args(\n                 None\n             }\n             GenericArgKind::Type(ty) => {\n-                ty_kind = Some(&ty.kind);\n+                ty_kind = Some(ty.kind());\n                 Some(GenericArg::Type(ty.clean(cx)))\n             }\n             GenericArgKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n@@ -472,7 +472,7 @@ pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n pub fn print_evaluated_const(cx: &DocContext<'_>, def_id: DefId) -> Option<String> {\n     cx.tcx.const_eval_poly(def_id).ok().and_then(|val| {\n         let ty = cx.tcx.type_of(def_id);\n-        match (val, &ty.kind) {\n+        match (val, ty.kind()) {\n             (_, &ty::Ref(..)) => None,\n             (ConstValue::Scalar(_), &ty::Adt(_, _)) => None,\n             (ConstValue::Scalar(_), _) => {\n@@ -497,7 +497,7 @@ fn format_integer_with_underscore_sep(num: &str) -> String {\n fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const<'tcx>) -> String {\n     // Use a slightly different format for integer types which always shows the actual value.\n     // For all other types, fallback to the original `pretty_print_const`.\n-    match (ct.val, &ct.ty.kind) {\n+    match (ct.val, ct.ty.kind()) {\n         (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Uint(ui)) => {\n             format!(\"{}{}\", format_integer_with_underscore_sep(&data.to_string()), ui.name_str())\n         }"}, {"sha": "a4f5530815ce16b9d1ffa70731a8528ce0ff0f81", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 {\n                     return Err(ErrorKind::ResolutionFailure);\n                 }\n-                match cx.tcx.type_of(did).kind {\n+                match cx.tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n                         if def.all_fields().any(|item| item.ident.name == variant_field_name) {\n                             Ok((\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                         })\n                     } else if ns == Namespace::ValueNS {\n-                        match cx.tcx.type_of(did).kind {\n+                        match cx.tcx.type_of(did).kind() {\n                             ty::Adt(def, _) => {\n                                 let field = if def.is_enum() {\n                                     def.all_fields().find(|item| item.ident.name == item_name)\n@@ -538,17 +538,19 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n             let impl_type = trait_ref.self_ty();\n             debug!(\n                 \"comparing type {} with kind {:?} against type {:?}\",\n-                impl_type, impl_type.kind, type_\n+                impl_type,\n+                impl_type.kind(),\n+                type_\n             );\n             // Fast path: if this is a primitive simple `==` will work\n             saw_impl = impl_type == ty\n-                || match impl_type.kind {\n+                || match impl_type.kind() {\n                     // Check if these are the same def_id\n                     ty::Adt(def, _) => {\n                         debug!(\"adt def_id: {:?}\", def.did);\n                         def.did == type_\n                     }\n-                    ty::Foreign(def_id) => def_id == type_,\n+                    ty::Foreign(def_id) => *def_id == type_,\n                     _ => false,\n                 };\n         });"}, {"sha": "2d964ac2b9f64c7cae2f4a0bc511cfbb23ff5355", "filename": "src/tools/clippy/clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -53,7 +53,7 @@ const ATOMIC_TYPES: [&str; 12] = [\n ];\n \n fn type_is_atomic(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.typeck_results().expr_ty(expr).kind {\n+    if let ty::Adt(&ty::AdtDef { did, .. }, _) = cx.typeck_results().expr_ty(expr).kind() {\n         ATOMIC_TYPES\n             .iter()\n             .any(|ty| match_def_path(cx, did, &[\"core\", \"sync\", \"atomic\", ty]))"}, {"sha": "f18e7e5d99755d425d75ec2eab98574c409cb7a0", "filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -67,7 +67,7 @@ impl LateLintPass<'_> for AwaitHoldingLock {\n \n fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n     for ty_cause in ty_causes {\n-        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind {\n+        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n             if is_mutex_guard(cx, adt.did) {\n                 span_lint_and_note(\n                     cx,"}, {"sha": "189c07427ae99c82583ebab999557ebee40844f0", "filename": "src/tools/clippy/clippy_lints/src/bytecount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fbytecount.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                                 _ => { return; }\n                             }\n                         };\n-                        if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.typeck_results().expr_ty(needle)).kind {\n+                        if ty::Uint(UintTy::U8) != *walk_ptrs_ty(cx.typeck_results().expr_ty(needle)).kind() {\n                             return;\n                         }\n                         let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) ="}, {"sha": "3ee022e4e68a0e5d20357b081eedcb5225b47525", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -123,7 +123,7 @@ impl Constant {\n             (&Self::Str(ref ls), &Self::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Self::Char(ref l), &Self::Char(ref r)) => Some(l.cmp(r)),\n             (&Self::Int(l), &Self::Int(r)) => {\n-                if let ty::Int(int_ty) = cmp_type.kind {\n+                if let ty::Int(int_ty) = *cmp_type.kind() {\n                     Some(sext(tcx, l, int_ty).cmp(&sext(tcx, r, int_ty)))\n                 } else {\n                     Some(l.cmp(&r))\n@@ -162,7 +162,7 @@ pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n             FloatTy::F32 => Constant::F32(is.as_str().parse().unwrap()),\n             FloatTy::F64 => Constant::F64(is.as_str().parse().unwrap()),\n         },\n-        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind {\n+        LitKind::Float(ref is, LitFloatType::Unsuffixed) => match ty.expect(\"type of float is known\").kind() {\n             ty::Float(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n             ty::Float(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n             _ => bug!(),\n@@ -230,7 +230,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n             ExprKind::Array(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprKind::Tup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(ref value, _) => {\n-                let n = match self.typeck_results.expr_ty(e).kind {\n+                let n = match self.typeck_results.expr_ty(e).kind() {\n                     ty::Array(_, n) => n.try_eval_usize(self.lcx.tcx, self.lcx.param_env)?,\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n@@ -281,7 +281,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n             Bool(b) => Some(Bool(!b)),\n             Int(value) => {\n                 let value = !value;\n-                match ty.kind {\n+                match *ty.kind() {\n                     ty::Int(ity) => Some(Int(unsext(self.lcx.tcx, value as i128, ity))),\n                     ty::Uint(ity) => Some(Int(clip(self.lcx.tcx, value, ity))),\n                     _ => None,\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         use self::Constant::{Int, F32, F64};\n         match *o {\n             Int(value) => {\n-                let ity = match ty.kind {\n+                let ity = match *ty.kind() {\n                     ty::Int(ity) => ity,\n                     _ => return None,\n                 };\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         let l = self.expr(left)?;\n         let r = self.expr(right);\n         match (l, r) {\n-            (Constant::Int(l), Some(Constant::Int(r))) => match self.typeck_results.expr_ty_opt(left)?.kind {\n+            (Constant::Int(l), Some(Constant::Int(r))) => match *self.typeck_results.expr_ty_opt(left)?.kind() {\n                 ty::Int(ity) => {\n                     let l = sext(self.lcx.tcx, l, ity);\n                     let r = sext(self.lcx.tcx, r, ity);\n@@ -495,7 +495,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::{ConstValue, Scalar};\n     match result.val {\n         ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => {\n-            match result.ty.kind {\n+            match result.ty.kind() {\n                 ty::Bool => Some(Constant::Bool(d == 1)),\n                 ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n                 ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n@@ -505,7 +505,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                     d.try_into().expect(\"invalid f64 bit representation\"),\n                 ))),\n                 ty::RawPtr(type_and_mut) => {\n-                    if let ty::Uint(_) = type_and_mut.ty.kind {\n+                    if let ty::Uint(_) = type_and_mut.ty.kind() {\n                         return Some(Constant::RawPtr(d));\n                     }\n                     None\n@@ -514,8 +514,8 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                 _ => None,\n             }\n         },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind {\n-            ty::Ref(_, tam, _) => match tam.kind {\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n+            ty::Ref(_, tam, _) => match tam.kind() {\n                 ty::Str => String::from_utf8(\n                     data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n                         .to_owned(),\n@@ -526,8 +526,8 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n             },\n             _ => None,\n         },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind {\n-            ty::Array(sub_type, len) => match sub_type.kind {\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n+            ty::Array(sub_type, len) => match sub_type.kind() {\n                 ty::Float(FloatTy::F32) => match miri_to_const(len) {\n                     Some(Constant::Int(len)) => alloc\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))"}, {"sha": "1654df56a9a5bce1900592f941d11372c19a474e", "filename": "src/tools/clippy/clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultTraitAccess {\n                         // TODO: Work out a way to put \"whatever the imported way of referencing\n                         // this type in this file\" rather than a fully-qualified type.\n                         let expr_ty = cx.typeck_results().expr_ty(expr);\n-                        if let ty::Adt(..) = expr_ty.kind {\n+                        if let ty::Adt(..) = expr_ty.kind() {\n                             let replacement = format!(\"{}::default()\", expr_ty);\n                             span_lint_and_sugg(\n                                 cx,"}, {"sha": "bf8e030cc294b25d57699644c8cec428906dcb0e", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -299,20 +299,20 @@ fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &T\n             return;\n         }\n \n-        match ty.kind {\n+        match *ty.kind() {\n             ty::Adt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n             ty::Adt(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n-                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind {\n+                        if let ty::FnDef(..) = field.ty(cx.tcx, substs).kind() {\n                             return;\n                         }\n                     }\n                     for subst in substs {\n                         if let ty::subst::GenericArgKind::Type(subst) = subst.unpack() {\n-                            if let ty::Param(_) = subst.kind {\n+                            if let ty::Param(_) = subst.kind() {\n                                 return;\n                             }\n                         }\n@@ -353,7 +353,7 @@ fn check_unsafe_derive_deserialize<'tcx>(\n \n     if_chain! {\n         if match_path(&trait_ref.path, &paths::SERDE_DESERIALIZE);\n-        if let ty::Adt(def, _) = ty.kind;\n+        if let ty::Adt(def, _) = ty.kind();\n         if let Some(local_def_id) = def.did.as_local();\n         let adt_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         if !is_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);"}, {"sha": "50121a054c79830676aac61494779ce2445b1e66", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -239,9 +239,9 @@ fn lint_for_missing_headers<'tcx>(\n                 let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n                 let ret_ty = mir.return_ty();\n                 if implements_trait(cx, ret_ty, future, &[]);\n-                if let ty::Opaque(_, subs) = ret_ty.kind;\n+                if let ty::Opaque(_, subs) = ret_ty.kind();\n                 if let Some(gen) = subs.types().next();\n-                if let ty::Generator(_, subs, _) = gen.kind;\n+                if let ty::Generator(_, subs, _) = gen.kind();\n                 if is_type_diagnostic_item(cx, subs.as_generator().return_ty(), sym!(result_type));\n                 then {\n                     span_lint("}, {"sha": "cf528d189b4b14220833a1eac46f54c58e666c14", "filename": "src/tools/clippy/clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> LateLintPass<'tcx> for DropForgetRef {\n                 let arg = &args[0];\n                 let arg_ty = cx.typeck_results().expr_ty(arg);\n \n-                if let ty::Ref(..) = arg_ty.kind {\n+                if let ty::Ref(..) = arg_ty.kind() {\n                     if match_def_path(cx, def_id, &paths::DROP) {\n                         lint = DROP_REF;\n                         msg = DROP_REF_SUMMARY.to_string();"}, {"sha": "fb80f48a9ccf361bbb36bf55ce421bfde402a008", "filename": "src/tools/clippy/clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_clike.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -53,12 +53,12 @@ impl<'tcx> LateLintPass<'tcx> for UnportableVariant {\n                         .ok()\n                         .map(|val| rustc_middle::ty::Const::from_value(cx.tcx, val, ty));\n                     if let Some(Constant::Int(val)) = constant.and_then(miri_to_const) {\n-                        if let ty::Adt(adt, _) = ty.kind {\n+                        if let ty::Adt(adt, _) = ty.kind() {\n                             if adt.is_enum() {\n                                 ty = adt.repr.discr_type().to_ty(cx.tcx);\n                             }\n                         }\n-                        match ty.kind {\n+                        match ty.kind() {\n                             ty::Int(IntTy::Isize) => {\n                                 let val = ((val as i128) << 64) >> 64;\n                                 if i32::try_from(val).is_ok() {"}, {"sha": "53df3abbf543744ef1300c6b80ddaef834a2afdb", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -99,7 +99,7 @@ fn check_closure(cx: &LateContext<'_>, expr: &Expr<'_>) {\n \n             let fn_ty = cx.typeck_results().expr_ty(caller);\n \n-            if matches!(fn_ty.kind, ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n+            if matches!(fn_ty.kind(), ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n \n             if !type_is_unsafe_function(cx, fn_ty);\n \n@@ -173,14 +173,14 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n }\n \n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind, &rhs.kind) {\n+    match (&lhs.kind(), &rhs.kind()) {\n         (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n         (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n     }\n }\n \n fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind, &rhs.kind) {\n+    match (&lhs.kind(), &rhs.kind()) {\n         (ty::Bool, ty::Bool)\n         | (ty::Char, ty::Char)\n         | (ty::Int(_), ty::Int(_))\n@@ -194,7 +194,7 @@ fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n }\n \n fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n         ty::Ref(_, r, _) => get_type_name(cx, &r),\n         _ => ty.to_string(),"}, {"sha": "4240147f498db43a2742f0eb69171043f1ccd970", "filename": "src/tools/clippy/clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -138,10 +138,10 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n                 let typ = self.cx.typeck_results().expr_ty(func);\n-                match typ.kind {\n+                match typ.kind() {\n                     ty::FnDef(..) | ty::FnPtr(_) => {\n                         let sig = typ.fn_sig(self.cx.tcx);\n-                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().kind {\n+                        if let ty::Never = self.cx.tcx.erase_late_bound_regions(&sig).output().kind() {\n                             self.report_diverging_sub_expr(e);\n                         }\n                     },"}, {"sha": "69818b4d3c642e1e5c29853c3713aee959473c2e", "filename": "src/tools/clippy/clippy_lints/src/float_equality_without_abs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_equality_without_abs.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -81,8 +81,8 @@ impl<'tcx> LateLintPass<'tcx> for FloatEqualityWithoutAbs {\n             // values of the substractions on the left hand side are of the type float\n             let t_val_l = cx.typeck_results().expr_ty(val_l);\n             let t_val_r = cx.typeck_results().expr_ty(val_r);\n-            if let ty::Float(_) = t_val_l.kind;\n-            if let ty::Float(_) = t_val_r.kind;\n+            if let ty::Float(_) = t_val_l.kind();\n+            if let ty::Float(_) = t_val_r.kind();\n \n             then {\n                 let sug_l = sugg::Sugg::hir(cx, &val_l, \"..\");"}, {"sha": "1fe4461533b36840a3330ed09f72e8a46d3fdda3", "filename": "src/tools/clippy/clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloat_literal.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             let ty = cx.typeck_results().expr_ty(expr);\n-            if let ty::Float(fty) = ty.kind;\n+            if let ty::Float(fty) = *ty.kind();\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;\n             then {"}, {"sha": "18fea8b34bfd46514e559bbf5437e292e0033f85", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -136,7 +136,7 @@ fn prepare_receiver_sugg<'a>(cx: &LateContext<'_>, mut expr: &'a Expr<'a>) -> Su\n     if_chain! {\n         // if the expression is a float literal and it is unsuffixed then\n         // add a suffix so the suggestion is valid and unambiguous\n-        if let ty::Float(float_ty) = cx.typeck_results().expr_ty(expr).kind;\n+        if let ty::Float(float_ty) = cx.typeck_results().expr_ty(expr).kind();\n         if let ExprKind::Lit(lit) = &expr.kind;\n         if let ast::LitKind::Float(sym, ast::LitFloatType::Unsuffixed) = lit.node;\n         then {"}, {"sha": "8bd85af87682a3027c0b5e7eb3efee27952aca8c", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -91,7 +91,7 @@ fn on_argumentv1_new<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, arms: &\n         if pats.len() == 1;\n         then {\n             let ty = walk_ptrs_ty(cx.typeck_results().pat_ty(&pats[0]));\n-            if ty.kind != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+            if *ty.kind() != rustc_middle::ty::Str && !is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n                 return None;\n             }\n             if let ExprKind::Lit(ref lit) = format_args.kind {"}, {"sha": "89fde1d509d30b96a69a71909ec25a320f4ca7f1", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -505,7 +505,7 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<\n static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n \n fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut FxHashSet<DefId>) -> bool {\n-    match ty.kind {\n+    match *ty.kind() {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(ref adt, ref substs) => {"}, {"sha": "2ab257ca88e3bdedc0794f4ea18ea1c617e0a8ef", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n             return;\n         }\n         let ret_ty = utils::return_ty(cx, hir_id);\n-        if let Opaque(id, subst) = ret_ty.kind {\n+        if let Opaque(id, subst) = *ret_ty.kind() {\n             let preds = cx.tcx.predicates_of(id).instantiate(cx.tcx, subst);\n             let mut is_future = false;\n             for p in preds.predicates {"}, {"sha": "8501d34770201b1a80d77210dcb6999bbda9d7be", "filename": "src/tools/clippy/clippy_lints/src/identity_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fidentity_op.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -75,7 +75,7 @@ fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_\n #[allow(clippy::cast_possible_wrap)]\n fn check(cx: &LateContext<'_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.typeck_results(), e) {\n-        let check = match cx.typeck_results().expr_ty(e).kind {\n+        let check = match *cx.typeck_results().expr_ty(e).kind() {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),\n             ty::Uint(uty) => clip(cx.tcx, !0, uty),\n             _ => return,"}, {"sha": "a28eda8be15a4ec8a129bb44a9aa172fb10cc247", "filename": "src/tools/clippy/clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Findexing_slicing.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n             let ty = cx.typeck_results().expr_ty(array);\n             if let Some(range) = higher::range(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n-                if let ty::Array(_, s) = ty.kind {\n+                if let ty::Array(_, s) = ty.kind() {\n                     let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {\n                         size.into()\n                     } else {\n@@ -141,7 +141,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n                 span_lint_and_help(cx, INDEXING_SLICING, expr.span, \"slicing may panic.\", None, help_msg);\n             } else {\n                 // Catchall non-range index, i.e., [n] or [n << m]\n-                if let ty::Array(..) = ty.kind {\n+                if let ty::Array(..) = ty.kind() {\n                     // Index is a constant uint.\n                     if let Some(..) = constant(cx, cx.typeck_results(), index) {\n                         // Let rustc's `const_err` lint handle constant `usize` indexing on arrays."}, {"sha": "025ff86da39d8cc9fd6b117fce951e37f400ebcd", "filename": "src/tools/clippy/clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if !item.span.from_expansion();\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            if let ty::Array(element_type, cst) = ty.kind;\n+            if let ty::Array(element_type, cst) = ty.kind();\n             if let ConstKind::Value(val) = cst.val;\n             if let ConstValue::Scalar(element_count) = val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);"}, {"sha": "9fd3780e14e04023423491d9c94cac1994de5b3a", "filename": "src/tools/clippy/clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n-            if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind;\n+            if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n             if let ConstKind::Value(val) = cst.val;\n             if let ConstValue::Scalar(element_count) = val;\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);"}, {"sha": "42a98dc963d2084cfe93eca9ac759608bcbfd5d4", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -286,7 +286,7 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     }\n \n     let ty = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr));\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n             cx.tcx\n                 .associated_items(principal.def_id())"}, {"sha": "604a97e3c083565b6f2fdde71e05b164d6c77d41", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -826,7 +826,7 @@ struct FixedOffsetVar<'hir> {\n }\n \n fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n-    let is_slice = match ty.kind {\n+    let is_slice = match ty.kind() {\n         ty::Ref(_, subty, _) => is_slice_like(cx, subty),\n         ty::Slice(..) | ty::Array(..) => true,\n         _ => false,\n@@ -1375,7 +1375,7 @@ fn is_end_eq_array_len<'tcx>(\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = end.kind;\n         if let ast::LitKind::Int(end_int, _) = lit.node;\n-        if let ty::Array(_, arr_len_const) = indexed_ty.kind;\n+        if let ty::Array(_, arr_len_const) = indexed_ty.kind();\n         if let Some(arr_len) = arr_len_const.try_eval_usize(cx.tcx, cx.param_env);\n         then {\n             return match limits {\n@@ -1612,7 +1612,7 @@ fn check_for_loop_over_map_kv<'tcx>(\n     if let PatKind::Tuple(ref pat, _) = pat.kind {\n         if pat.len() == 2 {\n             let arg_span = arg.span;\n-            let (new_pat_span, kind, ty, mutbl) = match cx.typeck_results().expr_ty(arg).kind {\n+            let (new_pat_span, kind, ty, mutbl) = match *cx.typeck_results().expr_ty(arg).kind() {\n                 ty::Ref(_, ty, mutbl) => match (&pat[0].kind, &pat[1].kind) {\n                     (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\", ty, mutbl),\n                     (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\", ty, Mutability::Not),\n@@ -1940,7 +1940,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 for expr in args {\n                     let ty = self.cx.typeck_results().expr_ty_adjusted(expr);\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.kind {\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n                             self.prefer_mutable = true;\n                         }\n@@ -1952,7 +1952,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 let def_id = self.cx.typeck_results().type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n-                    if let ty::Ref(_, _, mutbl) = ty.kind {\n+                    if let ty::Ref(_, _, mutbl) = *ty.kind() {\n                         if mutbl == Mutability::Mut {\n                             self.prefer_mutable = true;\n                         }\n@@ -2050,7 +2050,7 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n \n fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Array(_, n) => n\n             .try_eval_usize(cx.tcx, cx.param_env)\n             .map_or(false, |val| (0..=32).contains(&val)),"}, {"sha": "6d1c2ffbfbdd21a21ee450473b3ebfadffda323c", "filename": "src/tools/clippy/clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_clone.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                         match closure_expr.kind {\n                             hir::ExprKind::Unary(hir::UnOp::UnDeref, ref inner) => {\n                                 if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind {\n+                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n                                         lint(cx, e.span, args[0].span, true);\n                                     }\n                                 }\n@@ -80,7 +80,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n \n                                     let obj_ty = cx.typeck_results().expr_ty(&obj[0]);\n-                                    if let ty::Ref(_, ty, _) = obj_ty.kind {\n+                                    if let ty::Ref(_, ty, _) = obj_ty.kind() {\n                                         let copy = is_copy(cx, ty);\n                                         lint(cx, e.span, args[0].span, copy);\n                                     } else {"}, {"sha": "1f9ae8c931a1ee3aea3cbb5e683987a31ce71252", "filename": "src/tools/clippy/clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -93,7 +93,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MapUnit => [OPTION_MAP_UNIT_FN, RESULT_MAP_UNIT_FN]);\n \n fn is_unit_type(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Tuple(slice) => slice.is_empty(),\n         ty::Never => true,\n         _ => false,\n@@ -103,7 +103,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n fn is_unit_function(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n \n-    if let ty::FnDef(id, _) = ty.kind {\n+    if let ty::FnDef(id, _) = *ty.kind() {\n         if let Some(fn_type) = cx.tcx.fn_sig(id).no_bound_vars() {\n             return is_unit_type(fn_type.output());\n         }"}, {"sha": "7ba7397c29cb66797e5fdb8668e133c7825448b6", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -573,7 +573,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             if let QPath::Resolved(_, ref path) = qpath;\n             if let Some(def_id) = path.res.opt_def_id();\n             let ty = cx.tcx.type_of(def_id);\n-            if let ty::Adt(def, _) = ty.kind;\n+            if let ty::Adt(def, _) = ty.kind();\n             if def.is_struct() || def.is_union();\n             if fields.len() == def.non_enum_variant().fields.len();\n \n@@ -621,7 +621,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n         };\n \n         let ty = cx.typeck_results().expr_ty(ex);\n-        if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+        if *ty.kind() != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n             check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n         }\n@@ -712,7 +712,7 @@ fn check_single_match_opt_like(\n \n fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n-    if cx.typeck_results().expr_ty(ex).kind == ty::Bool {\n+    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n         span_lint_and_then(\n             cx,\n             MATCH_BOOL,\n@@ -860,7 +860,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n         // already covered.\n \n         let mut missing_variants = vec![];\n-        if let ty::Adt(def, _) = ty.kind {\n+        if let ty::Adt(def, _) = ty.kind() {\n             for variant in &def.variants {\n                 missing_variants.push(variant);\n             }\n@@ -914,7 +914,7 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n \n         let mut message = \"wildcard match will miss any future added variants\";\n \n-        if let ty::Adt(def, _) = ty.kind {\n+        if let ty::Adt(def, _) = ty.kind() {\n             if def.is_variant_list_non_exhaustive() {\n                 message = \"match on non-exhaustive enum doesn't explicitly match all known variants\";\n                 suggestion.push(String::from(\"_\"));\n@@ -1014,11 +1014,11 @@ fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             let input_ty = cx.typeck_results().expr_ty(ex);\n \n             let cast = if_chain! {\n-                if let ty::Adt(_, substs) = input_ty.kind;\n+                if let ty::Adt(_, substs) = input_ty.kind();\n                 let input_ty = substs.type_at(0);\n-                if let ty::Adt(_, substs) = output_ty.kind;\n+                if let ty::Adt(_, substs) = output_ty.kind();\n                 let output_ty = substs.type_at(0);\n-                if let ty::Ref(_, output_ty, _) = output_ty.kind;\n+                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n                 if input_ty != output_ty;\n                 then {\n                     \".map(|x| x as _)\""}, {"sha": "5dae7efad9763da38ff5e6ce4215715db489e2bc", "filename": "src/tools/clippy/clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -46,15 +46,15 @@ pub fn lint<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n /// Returns whether `ty` specializes `ToString`.\n /// Currently, these are `str`, `String`, and `Cow<'_, str>`.\n fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Str = ty.kind {\n+    if let ty::Str = ty.kind() {\n         return true;\n     }\n \n     if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n         return true;\n     }\n \n-    if let ty::Adt(adt, substs) = ty.kind {\n+    if let ty::Adt(adt, substs) = ty.kind() {\n         match_def_path(cx, adt.did, &paths::COW) && substs.type_at(1).is_str()\n     } else {\n         false"}, {"sha": "a7a3d67515678db2c2c0895b78a41caeda1651bb", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -1534,8 +1534,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     }\n                 }\n \n-                match self_ty.kind {\n-                    ty::Ref(_, ty, _) if ty.kind == ty::Str => {\n+                match self_ty.kind() {\n+                    ty::Ref(_, ty, _) if *ty.kind() == ty::Str => {\n                         for &(method, pos) in &PATTERN_METHODS {\n                             if method_call.ident.name.as_str() == method && args.len() > pos {\n                                 lint_single_char_pattern(cx, expr, &args[pos]);\n@@ -1661,7 +1661,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             }\n \n             // if return type is impl trait, check the associated types\n-            if let ty::Opaque(def_id, _) = ret_ty.kind {\n+            if let ty::Opaque(def_id, _) = *ret_ty.kind() {\n                 // one of the associated types must be Self\n                 for &(predicate, _span) in cx.tcx.predicates_of(def_id).predicates {\n                     if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n@@ -1803,7 +1803,7 @@ fn lint_or_fun_call<'tcx>(\n             if path.ident.as_str() == \"len\" {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(&args[0]));\n \n-                match ty.kind {\n+                match ty.kind() {\n                     ty::Slice(_) | ty::Array(_, _) => return,\n                     _ => (),\n                 }\n@@ -1910,7 +1910,7 @@ fn lint_expect_fun_call(\n                         && {\n                             let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n                             let base_type = walk_ptrs_ty(arg_type);\n-                            base_type.kind == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n+                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym!(string_type))\n                         }\n                     {\n                         &call_args[0]\n@@ -1931,8 +1931,8 @@ fn lint_expect_fun_call(\n         if is_type_diagnostic_item(cx, arg_ty, sym!(string_type)) {\n             return false;\n         }\n-        if let ty::Ref(_, ty, ..) = arg_ty.kind {\n-            if ty.kind == ty::Str && can_be_static_str(cx, arg) {\n+        if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n+            if *ty.kind() == ty::Str && can_be_static_str(cx, arg) {\n                 return false;\n             }\n         };\n@@ -1948,7 +1948,7 @@ fn lint_expect_fun_call(\n                 if let hir::ExprKind::Path(ref p) = fun.kind {\n                     match cx.qpath_res(p, fun.hir_id) {\n                         hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n-                            cx.tcx.fn_sig(def_id).output().skip_binder().kind,\n+                            cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n                             ty::Ref(ty::ReStatic, ..)\n                         ),\n                         _ => false,\n@@ -1962,7 +1962,7 @@ fn lint_expect_fun_call(\n                     .type_dependent_def_id(arg.hir_id)\n                     .map_or(false, |method_id| {\n                         matches!(\n-                            cx.tcx.fn_sig(method_id).output().skip_binder().kind,\n+                            cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n                             ty::Ref(ty::ReStatic, ..)\n                         )\n                     })\n@@ -2081,8 +2081,8 @@ fn lint_expect_fun_call(\n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    if let ty::Ref(_, inner, _) = arg_ty.kind {\n-        if let ty::Ref(_, innermost, _) = inner.kind {\n+    if let ty::Ref(_, inner, _) = arg_ty.kind() {\n+        if let ty::Ref(_, innermost, _) = inner.kind() {\n             span_lint_and_then(\n                 cx,\n                 CLONE_DOUBLE_REF,\n@@ -2093,7 +2093,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                     if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n                         let mut ty = innermost;\n                         let mut n = 0;\n-                        while let ty::Ref(_, inner, _) = ty.kind {\n+                        while let ty::Ref(_, inner, _) = ty.kind() {\n                             ty = inner;\n                             n += 1;\n                         }\n@@ -2172,7 +2172,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     let obj_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(arg));\n \n-    if let ty::Adt(_, subst) = obj_ty.kind {\n+    if let ty::Adt(_, subst) = obj_ty.kind() {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n             \"Rc\"\n         } else if is_type_diagnostic_item(cx, obj_ty, sym::Arc) {\n@@ -2202,7 +2202,7 @@ fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::E\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n         let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty(target));\n-        let ref_str = if self_ty.kind == ty::Str {\n+        let ref_str = if *self_ty.kind() == ty::Str {\n             \"\"\n         } else if is_type_diagnostic_item(cx, self_ty, sym!(string_type)) {\n             \"&\"\n@@ -2238,7 +2238,7 @@ fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>\n fn lint_cstring_as_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n     if_chain! {\n         let source_type = cx.typeck_results().expr_ty(source);\n-        if let ty::Adt(def, substs) = source_type.kind;\n+        if let ty::Adt(def, substs) = source_type.kind();\n         if cx.tcx.is_diagnostic_item(sym!(result_type), def.did);\n         if match_type(cx, substs.type_at(0), &paths::CSTRING);\n         then {\n@@ -2412,7 +2412,7 @@ fn lint_iter_next<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, iter_\n         }\n     } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym!(vec_type))\n         || matches!(\n-            &walk_ptrs_ty(cx.typeck_results().expr_ty(caller_expr)).kind,\n+            &walk_ptrs_ty(cx.typeck_results().expr_ty(caller_expr)).kind(),\n             ty::Array(_, _)\n         )\n     {\n@@ -2579,7 +2579,7 @@ fn derefs_to_slice<'tcx>(\n     ty: Ty<'tcx>,\n ) -> Option<&'tcx hir::Expr<'tcx>> {\n     fn may_slice<'a>(cx: &LateContext<'a>, ty: Ty<'a>) -> bool {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym!(vec_type)),\n@@ -2598,7 +2598,7 @@ fn derefs_to_slice<'tcx>(\n             None\n         }\n     } else {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Slice(_) => Some(expr),\n             ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n@@ -2692,9 +2692,9 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n-        let is_map_to_option = match map_closure_ty.kind {\n+        let is_map_to_option = match map_closure_ty.kind() {\n             ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n-                let map_closure_sig = match map_closure_ty.kind {\n+                let map_closure_sig = match map_closure_ty.kind() {\n                     ty::Closure(_, substs) => substs.as_closure().sig(),\n                     _ => map_closure_ty.fn_sig(cx.tcx),\n                 };\n@@ -3164,7 +3164,7 @@ fn lint_chars_cmp(\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = walk_ptrs_ty(cx.typeck_results().expr_ty_adjusted(&args[0][0]));\n \n-            if self_ty.kind != ty::Str {\n+            if *self_ty.kind() != ty::Str {\n                 return false;\n             }\n \n@@ -3352,7 +3352,7 @@ fn lint_asref(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, as_re\n \n fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(&'static str, &'static str)> {\n     has_iter_method(cx, self_ref_ty).map(|ty_name| {\n-        let mutbl = match self_ref_ty.kind {\n+        let mutbl = match self_ref_ty.kind() {\n             ty::Ref(_, _, mutbl) => mutbl,\n             _ => unreachable!(),\n         };\n@@ -3404,7 +3404,7 @@ fn lint_maybe_uninit(cx: &LateContext<'_>, expr: &hir::Expr<'_>, outer: &hir::Ex\n }\n \n fn is_maybe_uninit_ty_valid(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Array(ref component, _) => is_maybe_uninit_ty_valid(cx, component),\n         ty::Tuple(ref types) => types.types().all(|ty| is_maybe_uninit_ty_valid(cx, ty)),\n         ty::Adt(ref adt, _) => match_def_path(cx, adt.did, &paths::MEM_MAYBEUNINIT),\n@@ -3531,7 +3531,7 @@ fn lint_option_as_ref_deref<'tcx>(\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(_, substs) if is_type_diagnostic_item(cx, ty, sym!(result_type)) => substs.types().nth(1),\n         _ => None,\n     }\n@@ -3685,7 +3685,7 @@ impl SelfKind {\n             } else if ty.is_box() {\n                 ty.boxed_ty() == parent_ty\n             } else if is_type_diagnostic_item(cx, ty, sym::Rc) || is_type_diagnostic_item(cx, ty, sym::Arc) {\n-                if let ty::Adt(_, substs) = ty.kind {\n+                if let ty::Adt(_, substs) = ty.kind() {\n                     substs.types().next().map_or(false, |t| t == parent_ty)\n                 } else {\n                     false\n@@ -3696,7 +3696,7 @@ impl SelfKind {\n         }\n \n         fn matches_ref<'a>(cx: &LateContext<'a>, mutability: hir::Mutability, parent_ty: Ty<'a>, ty: Ty<'a>) -> bool {\n-            if let ty::Ref(_, t, m) = ty.kind {\n+            if let ty::Ref(_, t, m) = *ty.kind() {\n                 return m == mutability && t == parent_ty;\n             }\n \n@@ -3813,7 +3813,7 @@ fn contains_return(expr: &hir::Expr<'_>) -> bool {\n fn check_pointer_offset(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;\n-        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind;\n+        if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.typeck_results().expr_ty(&args[0]).kind();\n         if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n         if layout.is_zst();\n         then {"}, {"sha": "d4a50dd9013f01a8e8862399fc57c67a8275d900", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -561,17 +561,17 @@ fn is_signum(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n }\n \n fn is_float(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let value = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind;\n+    let value = &walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind();\n \n     if let ty::Array(arr_ty, _) = value {\n-        return matches!(arr_ty.kind, ty::Float(_));\n+        return matches!(arr_ty.kind(), ty::Float(_));\n     };\n \n     matches!(value, ty::Float(_))\n }\n \n fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(&walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind, ty::Array(_, _))\n+    matches!(&walk_ptrs_ty(cx.typeck_results().expr_ty(expr)).kind(), ty::Array(_, _))\n }\n \n fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {"}, {"sha": "da3ae1d652f6c515862ebb2c74016b4c7e69c4f0", "filename": "src/tools/clippy/clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -38,7 +38,7 @@ struct OperandInfo {\n \n fn analyze_operand(operand: &Expr<'_>, cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OperandInfo> {\n     match constant(cx, cx.typeck_results(), operand) {\n-        Some((Constant::Int(v), _)) => match cx.typeck_results().expr_ty(expr).kind {\n+        Some((Constant::Int(v), _)) => match *cx.typeck_results().expr_ty(expr).kind() {\n             ty::Int(ity) => {\n                 let value = sext(cx.tcx, v, ity);\n                 return Some(OperandInfo {"}, {"sha": "7423107e8f9453fb48906f151988894411a58c83", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -97,7 +97,7 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n // generics (because the compiler cannot ensure immutability for unknown types).\n fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n     let ty = walk_ptrs_ty(ty);\n-    if let Adt(def, substs) = ty.kind {\n+    if let Adt(def, substs) = ty.kind() {\n         if [&paths::HASHMAP, &paths::BTREEMAP, &paths::HASHSET, &paths::BTREESET]\n             .iter()\n             .any(|path| match_def_path(cx, def.did, &**path))\n@@ -109,7 +109,7 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n }\n \n fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n-    match ty.kind {\n+    match *ty.kind() {\n         RawPtr(TypeAndMut { ty: inner_ty, mutbl }) | Ref(_, inner_ty, mutbl) => {\n             mutbl == hir::Mutability::Mut || is_mutable_type(cx, inner_ty, span)\n         },"}, {"sha": "2f3cdb894f01c666de9fb75cec810b97594deca6", "filename": "src/tools/clippy/clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_mut.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                     expr.span,\n                     \"generally you want to avoid `&mut &mut _` if possible\",\n                 );\n-            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind {\n+            } else if let ty::Ref(_, _, hir::Mutability::Mut) = self.cx.typeck_results().expr_ty(e).kind() {\n                 span_lint(\n                     self.cx,\n                     MUT_MUT,"}, {"sha": "3f0b765df1561dc9543984506ea475dca498299a", "filename": "src/tools/clippy/clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_reference.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -61,11 +61,11 @@ fn check_arguments<'tcx>(\n     name: &str,\n     fn_kind: &str,\n ) {\n-    match type_definition.kind {\n+    match type_definition.kind() {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n-                match parameter.kind {\n+                match parameter.kind() {\n                     ty::Ref(_, _, Mutability::Not)\n                     | ty::RawPtr(ty::TypeAndMut {\n                         mutbl: Mutability::Not, .."}, {"sha": "cc635c2a202f6d4da3000d1ee1603a59b253bbe5", "filename": "src/tools/clippy/clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj\n                         .iter()\n-                        .any(|a| matches!(a.target.kind, ty::Ref(_, _, Mutability::Mut)))\n+                        .any(|a| matches!(a.target.kind(), ty::Ref(_, _, Mutability::Mut)))\n                     {\n                         self.found = true;\n                         return;"}, {"sha": "ea986874291e020f54c9751689383e1d4551ef3c", "filename": "src/tools/clippy/clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -67,7 +67,7 @@ declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n impl<'tcx> LateLintPass<'tcx> for Mutex {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         let ty = cx.typeck_results().expr_ty(expr);\n-        if let ty::Adt(_, subst) = ty.kind {\n+        if let ty::Adt(_, subst) = ty.kind() {\n             if is_type_diagnostic_item(cx, ty, sym!(mutex_type)) {\n                 let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n                          behavior and not the internal type, consider using `Mutex<()>`\",\n                         atomic_name\n                     );\n-                    match mutex_param.kind {\n+                    match *mutex_param.kind() {\n                         ty::Uint(t) if t != ast::UintTy::Usize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         ty::Int(t) if t != ast::IntTy::Isize => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for Mutex {\n }\n \n fn get_atomic_name(ty: Ty<'_>) -> Option<&'static str> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Bool => Some(\"AtomicBool\"),\n         ty::Uint(_) => Some(\"AtomicUsize\"),\n         ty::Int(_) => Some(\"AtomicIsize\"),"}, {"sha": "b71d5496a37a3e27b610ac5da97cf01279f0fe13", "filename": "src/tools/clippy/clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n             return;\n         }\n         if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = e.kind {\n-            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind {\n+            if let ty::Ref(..) = cx.typeck_results().expr_ty(inner).kind() {\n                 for adj3 in cx.typeck_results().expr_adjustments(e).windows(3) {\n                     if let [Adjustment {\n                         kind: Adjust::Deref(_), ..\n@@ -85,9 +85,9 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBorrow {\n         }\n         if_chain! {\n             if let PatKind::Binding(BindingAnnotation::Ref, .., name, _) = pat.kind;\n-            if let ty::Ref(_, tam, mutbl) = cx.typeck_results().pat_ty(pat).kind;\n+            if let ty::Ref(_, tam, mutbl) = *cx.typeck_results().pat_ty(pat).kind();\n             if mutbl == Mutability::Not;\n-            if let ty::Ref(_, _, mutbl) = tam.kind;\n+            if let ty::Ref(_, _, mutbl) = *tam.kind();\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n             if mutbl == Mutability::Not;\n             then {"}, {"sha": "7e933c674dd781a7093df9eb6c77e7457f6d56c3", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -194,7 +194,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n \n                     // Dereference suggestion\n                     let sugg = |diag: &mut DiagnosticBuilder<'_>| {\n-                        if let ty::Adt(def, ..) = ty.kind {\n+                        if let ty::Adt(def, ..) = ty.kind() {\n                             if let Some(span) = cx.tcx.hir().span_if_local(def.did) {\n                                 if can_type_implement_copy(cx.tcx, cx.param_env, ty).is_ok() {\n                                     diag.span_help(span, \"consider marking this type as `Copy`\");"}, {"sha": "98e9078094a225b0f9acaee37eb4e32c3c231163", "filename": "src/tools/clippy/clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_update.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessUpdate {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n             let ty = cx.typeck_results().expr_ty(expr);\n-            if let ty::Adt(def, _) = ty.kind {\n+            if let ty::Adt(def, _) = ty.kind() {\n                 if fields.len() == def.non_enum_variant().fields.len() {\n                     span_lint(\n                         cx,"}, {"sha": "73eabd4207e773cbc80a0c003b11e1cc3e204cf5", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -128,7 +128,7 @@ fn verify_ty_bound<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, source: Source) {\n                 diag.span_label(const_kw_span, \"make this a static item (maybe with lazy_static)\");\n             },\n             Source::Assoc { ty: ty_span, .. } => {\n-                if ty.flags.intersects(TypeFlags::HAS_FREE_LOCAL_NAMES) {\n+                if ty.flags().intersects(TypeFlags::HAS_FREE_LOCAL_NAMES) {\n                     diag.span_label(ty_span, &format!(\"consider requiring `{}` to be `Copy`\", ty));\n                 }\n             },"}, {"sha": "5539331d0460be96f00928833e1eb1300f5f3935", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -187,19 +187,19 @@ fn find_first_mismatch<'tcx>(\n     level: Level,\n ) -> Option<(Span, Mutability, Level)> {\n     if let PatKind::Ref(ref sub_pat, _) = pat.kind {\n-        if let TyKind::Ref(_, sub_ty, _) = ty.kind {\n+        if let TyKind::Ref(_, sub_ty, _) = ty.kind() {\n             return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n         }\n     }\n \n-    if let TyKind::Ref(_, _, mutability) = ty.kind {\n+    if let TyKind::Ref(_, _, mutability) = *ty.kind() {\n         if is_non_ref_pattern(&pat.kind) {\n             return Some((pat.span, mutability, level));\n         }\n     }\n \n     if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n@@ -208,7 +208,7 @@ fn find_first_mismatch<'tcx>(\n     }\n \n     if let PatKind::TupleStruct(ref qpath, ref pats, _) = pat.kind {\n-        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind() {\n             if let Some(variant) = get_variant(adt_def, qpath) {\n                 let field_defs = &variant.fields;\n                 let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n@@ -218,7 +218,7 @@ fn find_first_mismatch<'tcx>(\n     }\n \n     if let PatKind::Tuple(ref pats, _) = pat.kind {\n-        if let TyKind::Tuple(..) = ty.kind {\n+        if let TyKind::Tuple(..) = ty.kind() {\n             return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n         }\n     }"}, {"sha": "6b1c848a9467b2693334d12d6dad98f224128478", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -180,7 +180,7 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n             }\n         }\n \n-        if let ty::Ref(_, ty, Mutability::Not) = ty.kind {\n+        if let ty::Ref(_, ty, Mutability::Not) = ty.kind() {\n             if is_type_diagnostic_item(cx, ty, sym!(vec_type)) {\n                 let mut ty_snippet = None;\n                 if_chain! {"}, {"sha": "cc492917b9dafdd96b4cc89afa26ddfde4f4b635", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -281,7 +281,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n-        if let ty::Int(_) | ty::Uint(_) = ty.kind;\n+        if let ty::Int(_) | ty::Uint(_) = ty.kind();\n         if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);\n         if let Some((end_idx, _)) = constant(cx, cx.typeck_results(), end);\n         if let Some(ordering) = Constant::partial_cmp(cx.tcx, ty, &start_idx, &end_idx);"}, {"sha": "4773731e3272fc3b3e315525c10d34264302c7ea", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 continue;\n             }\n \n-            if let ty::Adt(ref def, _) = arg_ty.kind {\n+            if let ty::Adt(ref def, _) = arg_ty.kind() {\n                 if match_def_path(cx, def.did, &paths::MEM_MANUALLY_DROP) {\n                     continue;\n                 }\n@@ -287,7 +287,7 @@ fn is_call_with_ref_arg<'tcx>(\n         if let mir::TerminatorKind::Call { func, args, destination, .. } = kind;\n         if args.len() == 1;\n         if let mir::Operand::Move(mir::Place { local, .. }) = &args[0];\n-        if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).kind;\n+        if let ty::FnDef(def_id, _) = *func.ty(&*mir, cx.tcx).kind();\n         if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n         if !is_copy(cx, inner_ty);\n         then {"}, {"sha": "087d50c90e671236b090fa44266aeb3a0cda2e07", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -165,7 +165,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n     let var_ty = cx.typeck_results().node_type_opt(pat_id);\n-    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind, ty::Adt(..)))\n+    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind(), ty::Adt(..)))\n }\n \n fn check_pat<'tcx>("}, {"sha": "47a73ca9a24cf7eb5b46f6ee03d377700d48ec34", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -196,8 +196,8 @@ fn check_for_slice<'a>(cx: &LateContext<'_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<\n             if eq_expr_value(cx, lhs1, lhs2) {\n                 let ty = walk_ptrs_ty(cx.typeck_results().expr_ty(lhs1));\n \n-                if matches!(ty.kind, ty::Slice(_))\n-                    || matches!(ty.kind, ty::Array(_, _))\n+                if matches!(ty.kind(), ty::Slice(_))\n+                    || matches!(ty.kind(), ty::Array(_, _))\n                     || is_type_diagnostic_item(cx, ty, sym!(vec_type))\n                     || is_type_diagnostic_item(cx, ty, sym!(vecdeque_type))\n                 {"}, {"sha": "eeda39bfa20874fc2fd856767de67dd698a2fe39", "filename": "src/tools/clippy/clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for ToDigitIsSome {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";\n                             let char_arg_ty = cx.typeck_results().expr_ty_adjusted(char_arg);\n-                            if char_arg_ty.kind == ty::Char;\n+                            if *char_arg_ty.kind() == ty::Char;\n                             then {\n                                 Some((true, char_arg, radix_arg))\n                             } else {"}, {"sha": "87c5408c78588cf62bf04d1e482dc2a0cfa035c6", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -338,7 +338,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                 let from_ty = cx.typeck_results().expr_ty(&args[0]);\n                 let to_ty = cx.typeck_results().expr_ty(e);\n \n-                match (&from_ty.kind, &to_ty.kind) {\n+                match (&from_ty.kind(), &to_ty.kind()) {\n                     _ if from_ty == to_ty => span_lint(\n                         cx,\n                         USELESS_TRANSMUTE,\n@@ -446,7 +446,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             &format!(\"transmute from a `{}` to a `char`\", from_ty),\n                             |diag| {\n                                 let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let arg = if let ty::Int(_) = from_ty.kind {\n+                                let arg = if let ty::Int(_) = from_ty.kind() {\n                                     arg.as_ty(ast::UintTy::U32.name_str())\n                                 } else {\n                                     arg\n@@ -462,8 +462,8 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                     },\n                     (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) => {\n                         if_chain! {\n-                            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind, &ty_to.kind);\n-                            if let ty::Uint(ast::UintTy::U8) = slice_ty.kind;\n+                            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind(), &ty_to.kind());\n+                            if let ty::Uint(ast::UintTy::U8) = slice_ty.kind();\n                             if from_mutbl == to_mutbl;\n                             then {\n                                 let postfix = if *from_mutbl == Mutability::Mut {\n@@ -555,7 +555,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                         &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                         |diag| {\n                             let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                            let arg = if let ty::Int(int_ty) = from_ty.kind {\n+                            let arg = if let ty::Int(int_ty) = from_ty.kind() {\n                                 arg.as_ty(format!(\n                                     \"u{}\",\n                                     int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n@@ -601,7 +601,7 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n \n                             // cast the result of `to_bits` if `to_ty` is signed\n-                            arg = if let ty::Int(int_ty) = to_ty.kind {\n+                            arg = if let ty::Int(int_ty) = to_ty.kind() {\n                                 arg.as_ty(int_ty.name_str().to_string())\n                             } else {\n                                 arg"}, {"sha": "1f06d2dbe9144e0beb56fc0e33a090ac70e3457c", "filename": "src/tools/clippy/clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -83,7 +83,7 @@ impl<'tcx> TriviallyCopyPassByRef {\n         // Use lifetimes to determine if we're returning a reference to the\n         // argument. In that case we can't switch to pass-by-value as the\n         // argument will not live long enough.\n-        let output_lts = match fn_sig.output().kind {\n+        let output_lts = match *fn_sig.output().kind() {\n             ty::Ref(output_lt, _, _) => vec![output_lt],\n             ty::Adt(_, substs) => substs.regions().collect(),\n             _ => vec![],\n@@ -97,7 +97,7 @@ impl<'tcx> TriviallyCopyPassByRef {\n             }\n \n             if_chain! {\n-                if let ty::Ref(input_lt, ty, Mutability::Not) = ty.kind;\n+                if let ty::Ref(input_lt, ty, Mutability::Not) = ty.kind();\n                 if !output_lts.contains(&input_lt);\n                 if is_copy(cx, ty);\n                 if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());"}, {"sha": "3e747ec4ad9e25dcdb5b4bdc2fc03c9fb813bf55", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -132,7 +132,7 @@ fn find_return_type<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx ExprKind<'_>) -> O\n /// Extracts the error type from Result<T, E>.\n fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ty::Adt(_, subst) = ty.kind;\n+        if let ty::Adt(_, subst) = ty.kind();\n         if is_type_diagnostic_item(cx, ty, sym!(result_type));\n         let err_ty = subst.type_at(1);\n         then {\n@@ -146,11 +146,11 @@ fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n /// Extracts the error type from Poll<Result<T, E>>.\n fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind;\n+        if let ty::Adt(def, subst) = ty.kind();\n         if match_def_path(cx, def.did, &paths::POLL);\n         let ready_ty = subst.type_at(0);\n \n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind;\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym!(result_type), ready_def.did);\n         let err_ty = ready_subst.type_at(1);\n \n@@ -165,15 +165,15 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n /// Extracts the error type from Poll<Option<Result<T, E>>>.\n fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     if_chain! {\n-        if let ty::Adt(def, subst) = ty.kind;\n+        if let ty::Adt(def, subst) = ty.kind();\n         if match_def_path(cx, def.did, &paths::POLL);\n         let ready_ty = subst.type_at(0);\n \n-        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind;\n+        if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym!(option_type), ready_def.did);\n         let some_ty = ready_subst.type_at(0);\n \n-        if let ty::Adt(some_def, some_subst) = some_ty.kind;\n+        if let ty::Adt(some_def, some_subst) = some_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym!(result_type), some_def.did);\n         let err_ty = some_subst.type_at(1);\n "}, {"sha": "c82deaa43b2667eff7dbe47c708ef7c2a0a4f839", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -907,7 +907,7 @@ fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n }\n \n fn is_unit(ty: Ty<'_>) -> bool {\n-    matches!(ty.kind, ty::Tuple(slice) if slice.is_empty())\n+    matches!(ty.kind(), ty::Tuple(slice) if slice.is_empty())\n }\n \n fn is_unit_literal(expr: &Expr<'_>) -> bool {\n@@ -1134,7 +1134,7 @@ declare_clippy_lint! {\n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n-    match typ.kind {\n+    match typ.kind() {\n         ty::Int(i) => match i {\n             IntTy::Isize => tcx.data_layout.pointer_size.bits(),\n             IntTy::I8 => 8,\n@@ -1156,7 +1156,7 @@ fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n }\n \n fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    matches!(typ.kind, ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n+    matches!(typ.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n }\n \n fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n@@ -1248,7 +1248,7 @@ fn check_loss_of_sign(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     if_chain! {\n         if let Some((const_val, _)) = const_val;\n         if let Constant::Int(n) = const_val;\n-        if let ty::Int(ity) = cast_from.kind;\n+        if let ty::Int(ity) = *cast_from.kind();\n         if sext(cx.tcx, n, ity) >= 0;\n         then {\n             return\n@@ -1381,7 +1381,7 @@ declare_lint_pass!(Casts => [\n // Check if the given type is either `core::ffi::c_void` or\n // one of the platform specific `libc::<platform>::c_void` of libc.\n fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    if let ty::Adt(adt, _) = ty.kind {\n+    if let ty::Adt(adt, _) = ty.kind() {\n         let names = cx.get_def_path(adt.did);\n \n         if names.is_empty() {\n@@ -1397,7 +1397,7 @@ fn is_c_void(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n /// Returns the mantissa bits wide of a fp type.\n /// Will return 0 if the type is not a fp\n fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n-    match typ.kind {\n+    match typ.kind() {\n         ty::Float(FloatTy::F32) => 23,\n         ty::Float(FloatTy::F64) | ty::Infer(InferTy::FloatVar(_)) => 52,\n         _ => 0,\n@@ -1437,7 +1437,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                 match lit.node {\n                     LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {},\n                     _ => {\n-                        if cast_from.kind == cast_to.kind && !in_external_macro(cx.sess(), expr.span) {\n+                        if cast_from.kind() == cast_to.kind() && !in_external_macro(cx.sess(), expr.span) {\n                             span_lint(\n                                 cx,\n                                 UNNECESSARY_CAST,\n@@ -1470,7 +1470,7 @@ fn lint_numeric_casts<'tcx>(\n     match (cast_from.is_integral(), cast_to.is_integral()) {\n         (true, false) => {\n             let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n-            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind {\n+            let to_nbits = if let ty::Float(FloatTy::F32) = cast_to.kind() {\n                 32\n             } else {\n                 64\n@@ -1507,15 +1507,15 @@ fn lint_numeric_casts<'tcx>(\n             check_lossless(cx, expr, cast_expr, cast_from, cast_to);\n         },\n         (false, false) => {\n-            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.kind, &cast_to.kind) {\n+            if let (&ty::Float(FloatTy::F64), &ty::Float(FloatTy::F32)) = (&cast_from.kind(), &cast_to.kind()) {\n                 span_lint(\n                     cx,\n                     CAST_POSSIBLE_TRUNCATION,\n                     expr.span,\n                     \"casting `f64` to `f32` may truncate the value\",\n                 );\n             }\n-            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.kind, &cast_to.kind) {\n+            if let (&ty::Float(FloatTy::F32), &ty::Float(FloatTy::F64)) = (&cast_from.kind(), &cast_to.kind()) {\n                 span_lossless_lint(cx, expr, cast_expr, cast_from, cast_to);\n             }\n         },\n@@ -1524,8 +1524,8 @@ fn lint_numeric_casts<'tcx>(\n \n fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n     if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind;\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind;\n+        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n+        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n         if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n         if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n         if from_layout.align.abi < to_layout.align.abi;\n@@ -1558,11 +1558,11 @@ fn lint_fn_to_numeric_cast(\n     cast_to: Ty<'_>,\n ) {\n     // We only want to check casts to `ty::Uint` or `ty::Int`\n-    match cast_to.kind {\n+    match cast_to.kind() {\n         ty::Uint(_) | ty::Int(..) => { /* continue on */ },\n         _ => return,\n     }\n-    match cast_from.kind {\n+    match cast_from.kind() {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let mut applicability = Applicability::MaybeIncorrect;\n             let from_snippet = snippet_with_applicability(cx, cast_expr.span, \"x\", &mut applicability);\n@@ -1581,7 +1581,7 @@ fn lint_fn_to_numeric_cast(\n                     format!(\"{} as usize\", from_snippet),\n                     applicability,\n                 );\n-            } else if cast_to.kind != ty::Uint(UintTy::Usize) {\n+            } else if *cast_to.kind() != ty::Uint(UintTy::Usize) {\n                 span_lint_and_sugg(\n                     cx,\n                     FN_TO_NUMERIC_CAST,\n@@ -1798,7 +1798,7 @@ impl<'tcx> LateLintPass<'tcx> for CharLitAsU8 {\n             if let ExprKind::Cast(e, _) = &expr.kind;\n             if let ExprKind::Lit(l) = &e.kind;\n             if let LitKind::Char(c) = l.node;\n-            if ty::Uint(UintTy::U8) == cx.typeck_results().expr_ty(expr).kind;\n+            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(expr).kind();\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let snippet = snippet_with_applicability(cx, e.span, \"'x'\", &mut applicability);\n@@ -1937,7 +1937,7 @@ fn detect_extreme_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Op\n \n     let cv = constant(cx, cx.typeck_results(), expr)?.0;\n \n-    let which = match (&ty.kind, cv) {\n+    let which = match (ty.kind(), cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n         (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n             Minimum\n@@ -2071,7 +2071,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n         if cx.layout_of(pre_cast_ty).ok().map(|l| l.size) == cx.layout_of(cast_ty).ok().map(|l| l.size) {\n             return None;\n         }\n-        match pre_cast_ty.kind {\n+        match pre_cast_ty.kind() {\n             ty::Int(int_ty) => Some(match int_ty {\n                 IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n                 IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n@@ -2098,7 +2098,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_>, expr: &'a Expr<'_>) ->\n fn node_as_const_fullint<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n     let val = constant(cx, cx.typeck_results(), expr)?.0;\n     if let Constant::Int(const_int) = val {\n-        match cx.typeck_results().expr_ty(expr).kind {\n+        match *cx.typeck_results().expr_ty(expr).kind() {\n             ty::Int(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n             ty::Uint(_) => Some(FullInt::U(const_int)),\n             _ => None,\n@@ -2601,7 +2601,7 @@ impl<'tcx> LateLintPass<'tcx> for RefToMut {\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Mut, .. }) = t.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;\n             if let TyKind::Ptr(MutTy { mutbl: Mutability::Not, .. }) = t.kind;\n-            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind;\n+            if let ty::Ref(..) = cx.typeck_results().node_type(e.hir_id).kind();\n             then {\n                 span_lint(\n                     cx,"}, {"sha": "0d5a5017331b78bf0e6a16f6ebe276e19559d24f", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -110,7 +110,7 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Span, Option<Span>)> {\n     if_chain! {\n         if let ExprKind::Closure(_, _fn_decl, body_id, span, _) = arg.kind;\n-        if let ty::Closure(_def_id, substs) = &cx.typeck_results().node_type(arg.hir_id).kind;\n+        if let ty::Closure(_def_id, substs) = &cx.typeck_results().node_type(arg.hir_id).kind();\n         let ret_ty = substs.as_closure().sig().output();\n         let ty = cx.tcx.erase_late_bound_regions(&ret_ty);\n         if ty.is_unit();"}, {"sha": "9582c162e77b274734c7e976bc1e17735fde48f5", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -65,14 +65,14 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            match cx.typeck_results().expr_ty_adjusted(expr).kind {\n+            match cx.typeck_results().expr_ty_adjusted(expr).kind() {\n                 ty::RawPtr(ty::TypeAndMut { ty, .. }) => ty.is_trait(),\n                 _ => false,\n             }\n         }\n \n         fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            matches!(cx.typeck_results().expr_ty(expr).kind, ty::FnDef(..))\n+            matches!(cx.typeck_results().expr_ty(expr).kind(), ty::FnDef(..))\n         }\n \n         if_chain! {"}, {"sha": "8b00d29acb52c65ed79b28035419930d2d00d17d", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -230,7 +230,7 @@ fn key_returns_borrow(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let Some(def_id) = utils::fn_def_id(cx, expr) {\n         let output = cx.tcx.fn_sig(def_id).output();\n         let ty = output.skip_binder();\n-        return matches!(ty.kind, ty::Ref(..))\n+        return matches!(ty.kind(), ty::Ref(..))\n             || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n     }\n "}, {"sha": "615440e15f384bca82bff66cdda8796cf7e5266a", "filename": "src/tools/clippy/clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -107,7 +107,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         let a = cx.typeck_results().expr_ty(e);\n                         let b = cx.typeck_results().expr_ty(&args[0]);\n                         if is_type_diagnostic_item(cx, a, sym!(result_type));\n-                        if let ty::Adt(_, substs) = a.kind;\n+                        if let ty::Adt(_, substs) = a.kind();\n                         if let Some(a_type) = substs.types().next();\n                         if TyS::same_type(a_type, b);\n \n@@ -137,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::TRY_FROM);\n                             if is_type_diagnostic_item(cx, a, sym!(result_type));\n-                            if let ty::Adt(_, substs) = a.kind;\n+                            if let ty::Adt(_, substs) = a.kind();\n                             if let Some(a_type) = substs.types().next();\n                             if TyS::same_type(a_type, b);\n "}, {"sha": "45add9ab284d2c05e7b2c02279fbe35648e61391", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -129,23 +129,23 @@ pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n \n /// Checks if type is struct, enum or union type with the given def path.\n pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n \n /// Checks if the type is equal to a diagnostic item\n pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),\n         _ => false,\n     }\n }\n \n /// Checks if the type is equal to a lang item\n pub fn is_type_lang_item(cx: &LateContext<'_>, ty: Ty<'_>, lang_item: hir::LangItem) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.lang_items().require(lang_item).unwrap() == adt.did,\n         _ => false,\n     }\n@@ -754,7 +754,7 @@ pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n \n /// Returns the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Ref(_, ty, _) => walk_ptrs_ty(ty),\n         _ => ty,\n     }\n@@ -764,7 +764,7 @@ pub fn walk_ptrs_ty(ty: Ty<'_>) -> Ty<'_> {\n /// depth.\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n-        match ty.kind {\n+        match ty.kind() {\n             ty::Ref(_, ty, _) => inner(ty, depth + 1),\n             _ => (ty, depth),\n         }\n@@ -877,7 +877,7 @@ pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n \n /// Returns `true` if the given type is an `unsafe` function.\n pub fn type_is_unsafe_function<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::FnDef(..) | ty::FnPtr(_) => ty.fn_sig(cx.tcx).unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n@@ -942,7 +942,7 @@ pub fn is_refutable(cx: &LateContext<'_>, pat: &Pat<'_>) -> bool {\n             is_enum_variant(cx, qpath, pat.hir_id) || are_refutable(cx, pats.iter().map(|pat| &**pat))\n         },\n         PatKind::Slice(ref head, ref middle, ref tail) => {\n-            match &cx.typeck_results().node_type(pat.hir_id).kind {\n+            match &cx.typeck_results().node_type(pat.hir_id).kind() {\n                 ty::Slice(..) => {\n                     // [..] is the only irrefutable slice pattern.\n                     !head.is_empty() || middle.is_none() || !tail.is_empty()\n@@ -1156,12 +1156,12 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n         &paths::RECEIVER,\n     ];\n \n-    let ty_to_check = match probably_ref_ty.kind {\n+    let ty_to_check = match probably_ref_ty.kind() {\n         ty::Ref(_, ty_to_check, _) => ty_to_check,\n         _ => probably_ref_ty,\n     };\n \n-    let def_id = match ty_to_check.kind {\n+    let def_id = match ty_to_check.kind() {\n         ty::Array(..) => return Some(\"array\"),\n         ty::Slice(..) => return Some(\"slice\"),\n         ty::Adt(adt, _) => adt.did,\n@@ -1277,7 +1277,7 @@ pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n \n // Returns whether the type has #[must_use] attribute\n pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Adt(ref adt, _) => must_use_attr(&cx.tcx.get_attrs(adt.did)).is_some(),\n         ty::Foreign(ref did) => must_use_attr(&cx.tcx.get_attrs(*did)).is_some(),\n         ty::Slice(ref ty)\n@@ -1409,9 +1409,9 @@ pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bo\n /// Returns true iff the given type is a primitive (a bool or char, any integer or floating-point\n /// number type, a str, or an array, slice, or tuple of those types).\n pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n+    match ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n-        ty::Ref(_, inner, _) if inner.kind == ty::Str => true,\n+        ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n         ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n         ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n         _ => false,\n@@ -1423,24 +1423,23 @@ pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n /// `is_recursively_primitive_type` function) and None otherwise.\n pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n     let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n-    let expr_kind = &expr_type.kind;\n+    let expr_kind = expr_type.kind();\n     let is_primitive = match expr_kind {\n-        ty::Slice(ref element_type)\n-        | ty::Ref(\n-            _,\n-            ty::TyS {\n-                kind: ty::Slice(ref element_type),\n-                ..\n-            },\n-            _,\n-        ) => is_recursively_primitive_type(element_type),\n+        ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n+        ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &ty::Slice(_)) => {\n+            if let ty::Slice(element_type) = inner_ty.kind() {\n+                is_recursively_primitive_type(element_type)\n+            } else {\n+                unreachable!()\n+            }\n+        }\n         _ => false,\n     };\n \n     if is_primitive {\n         // if we have wrappers like Array, Slice or Tuple, print these\n         // and get the type enclosed in the slice ref\n-        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind {\n+        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n             ty::Slice(..) => return Some(\"slice\".into()),\n             ty::Array(..) => return Some(\"array\".into()),\n             ty::Tuple(..) => return Some(\"tuple\".into()),"}, {"sha": "149cceb39dd9903cc2625d0ccf1508f8f96f94be", "filename": "src/tools/clippy/clippy_lints/src/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2454643e137bde519786ee9e650c455d7ad6f34/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fvec.rs?ref=d2454643e137bde519786ee9e650c455d7ad6f34", "patch": "@@ -44,8 +44,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n-            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind;\n-            if let ty::Slice(..) = ty.kind;\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n+            if let ty::Slice(..) = ty.kind();\n             if let ExprKind::AddrOf(BorrowKind::Ref, _, ref addressee) = expr.kind;\n             if let Some(vec_args) = higher::vec_macro(cx, addressee);\n             then {\n@@ -127,7 +127,7 @@ fn size_of(cx: &LateContext<'_>, expr: &Expr<'_>) -> u64 {\n \n /// Returns the item type of the vector (i.e., the `T` in `Vec<T>`).\n fn vec_type(ty: Ty<'_>) -> Ty<'_> {\n-    if let ty::Adt(_, substs) = ty.kind {\n+    if let ty::Adt(_, substs) = ty.kind() {\n         substs.type_at(0)\n     } else {\n         panic!(\"The type of `vec!` is a not a struct?\");"}]}