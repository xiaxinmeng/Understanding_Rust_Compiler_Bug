{"sha": "58b908d09c846b9112fc6a178f832ff84486f8ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4YjkwOGQwOWM4NDZiOTExMmZjNmExNzhmODMyZmY4NDQ4NmY4ZWU=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-29T18:01:31Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-26T22:36:12Z"}, "message": "Lowering for hir::Expr.", "tree": {"sha": "b1c121e5b758d8d5a99f5fed99731f33f4e0380e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c121e5b758d8d5a99f5fed99731f33f4e0380e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58b908d09c846b9112fc6a178f832ff84486f8ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58b908d09c846b9112fc6a178f832ff84486f8ee", "html_url": "https://github.com/rust-lang/rust/commit/58b908d09c846b9112fc6a178f832ff84486f8ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58b908d09c846b9112fc6a178f832ff84486f8ee/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52e9825ba8f9a5f32c3568ab0ca25dbeb7842c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/52e9825ba8f9a5f32c3568ab0ca25dbeb7842c30", "html_url": "https://github.com/rust-lang/rust/commit/52e9825ba8f9a5f32c3568ab0ca25dbeb7842c30"}], "stats": {"total": 576, "additions": 347, "deletions": 229}, "files": [{"sha": "f604a66aebc01b77811f7ac2e2b43d4f5a2275c2", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=58b908d09c846b9112fc6a178f832ff84486f8ee", "patch": "@@ -125,14 +125,25 @@ macro_rules! arena_types {\n \n             // HIR types\n             [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n+            [] arm: rustc::hir::Arm<$tcx>,\n             [] attribute: syntax::ast::Attribute,\n+            [] block: rustc::hir::Block<$tcx>,\n             [few] global_asm: rustc::hir::GlobalAsm,\n+            [] expr: rustc::hir::Expr<$tcx>,\n+            [] field: rustc::hir::Field<$tcx>,\n+            [] field_pat: rustc::hir::FieldPat<$tcx>,\n             [] fn_decl: rustc::hir::FnDecl,\n             [] foreign_item: rustc::hir::ForeignItem<$tcx>,\n             [] impl_item_ref: rustc::hir::ImplItemRef,\n+            [] inline_asm: rustc::hir::InlineAsm<$tcx>,\n+            [] local: rustc::hir::Local<$tcx>,\n             [few] macro_def: rustc::hir::MacroDef<$tcx>,\n             [] param: rustc::hir::Param<$tcx>,\n+            [] pat: rustc::hir::Pat<$tcx>,\n             [] path: rustc::hir::Path,\n+            [] path_segment: rustc::hir::PathSegment,\n+            [] qpath: rustc::hir::QPath,\n+            [] stmt: rustc::hir::Stmt<$tcx>,\n             [] struct_field: rustc::hir::StructField<$tcx>,\n             [] trait_item_ref: rustc::hir::TraitItemRef,\n             [] ty: rustc::hir::Ty,"}, {"sha": "cb9f08c760013291514a4292910d821c5391039d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 80, "deletions": 69, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=58b908d09c846b9112fc6a178f832ff84486f8ee", "patch": "@@ -921,7 +921,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn with_new_scopes<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n@@ -2031,21 +2031,27 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n         let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n+        let ty = l.ty.as_ref().map(|t| {\n+            self.lower_ty(\n+                t,\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    ImplTraitContext::OpaqueTy(Some(parent_def_id))\n+                } else {\n+                    ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                },\n+            )\n+        });\n+        let ty = ty.map(|ty| -> &'hir hir::Ty { self.arena.alloc(ty.into_inner()) });\n+        let init = l\n+            .init\n+            .as_ref()\n+            .map(|e| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(e)) });\n         (\n             hir::Local {\n                 hir_id: self.lower_node_id(l.id),\n-                ty: l.ty.as_ref().map(|t| {\n-                    self.lower_ty(\n-                        t,\n-                        if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::OpaqueTy(Some(parent_def_id))\n-                        } else {\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                        },\n-                    )\n-                }),\n+                ty,\n                 pat: self.lower_pat(&l.pat),\n-                init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n+                init,\n                 span: l.span,\n                 attrs: l.attrs.clone(),\n                 source: hir::LocalSource::Normal,\n@@ -2586,14 +2592,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block<'hir>> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> &'hir hir::Block<'hir> {\n+        self.arena.alloc(self.lower_block_noalloc(b, targeted_by_break))\n+    }\n+\n+    fn lower_block_noalloc(&mut self, b: &Block, targeted_by_break: bool) -> hir::Block<'hir> {\n         let mut stmts = vec![];\n-        let mut expr = None;\n+        let mut expr: Option<&'hir _> = None;\n \n         for (index, stmt) in b.stmts.iter().enumerate() {\n             if index == b.stmts.len() - 1 {\n                 if let StmtKind::Expr(ref e) = stmt.kind {\n-                    expr = Some(P(self.lower_expr(e)));\n+                    expr = Some(self.arena.alloc(self.lower_expr(e)));\n                 } else {\n                     stmts.extend(self.lower_stmt(stmt));\n                 }\n@@ -2602,14 +2612,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        P(hir::Block {\n+        hir::Block {\n             hir_id: self.lower_node_id(b.id),\n-            stmts: stmts.into(),\n+            stmts: self.arena.alloc_from_iter(stmts),\n             expr,\n             rules: self.lower_block_check_mode(&b.rules),\n             span: b.span,\n             targeted_by_break,\n-        })\n+        }\n     }\n \n     /// Lowers a block directly to an expression, presuming that it\n@@ -2619,15 +2629,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.expr_block(block, AttrVec::new())\n     }\n \n-    fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat<'hir>> {\n+    fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n         let node = match p.kind {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n                 let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n                 let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n                 node\n             }\n-            PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n+            PatKind::Lit(ref e) => hir::PatKind::Lit(self.arena.alloc(self.lower_expr(e))),\n             PatKind::TupleStruct(ref path, ref pats) => {\n                 let qpath = self.lower_qpath(\n                     p.id,\n@@ -2640,7 +2650,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 hir::PatKind::TupleStruct(qpath, pats, ddpos)\n             }\n             PatKind::Or(ref pats) => {\n-                hir::PatKind::Or(pats.iter().map(|x| self.lower_pat(x)).collect())\n+                hir::PatKind::Or(self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))))\n             }\n             PatKind::Path(ref qself, ref path) => {\n                 let qpath = self.lower_qpath(\n@@ -2661,16 +2671,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     ImplTraitContext::disallowed(),\n                 );\n \n-                let fs = fields\n-                    .iter()\n-                    .map(|f| hir::FieldPat {\n-                        hir_id: self.next_id(),\n-                        ident: f.ident,\n-                        pat: self.lower_pat(&f.pat),\n-                        is_shorthand: f.is_shorthand,\n-                        span: f.span,\n-                    })\n-                    .collect();\n+                let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                    hir_id: self.next_id(),\n+                    ident: f.ident,\n+                    pat: self.lower_pat(&f.pat),\n+                    is_shorthand: f.is_shorthand,\n+                    span: f.span,\n+                }));\n                 hir::PatKind::Struct(qpath, fs, etc)\n             }\n             PatKind::Tuple(ref pats) => {\n@@ -2680,8 +2687,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n             PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n             PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n-                P(self.lower_expr(e1)),\n-                P(self.lower_expr(e2)),\n+                self.arena.alloc(self.lower_expr(e1)),\n+                self.arena.alloc(self.lower_expr(e2)),\n                 self.lower_range_end(end),\n             ),\n             PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n@@ -2700,7 +2707,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         pats: &[AstP<Pat>],\n         ctx: &str,\n-    ) -> (HirVec<P<hir::Pat<'hir>>>, Option<usize>) {\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n         let mut elems = Vec::with_capacity(pats.len());\n         let mut rest = None;\n \n@@ -2728,7 +2735,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        (elems.into(), rest.map(|(ddpos, _)| ddpos))\n+        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n     }\n \n     /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n@@ -2788,15 +2795,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n \n-        hir::PatKind::Slice(before.into(), slice, after.into())\n+        hir::PatKind::Slice(\n+            self.arena.alloc_from_iter(before),\n+            slice,\n+            self.arena.alloc_from_iter(after),\n+        )\n     }\n \n     fn lower_pat_ident(\n         &mut self,\n         p: &Pat,\n         binding_mode: &BindingMode,\n         ident: Ident,\n-        lower_sub: impl FnOnce(&mut Self) -> Option<P<hir::Pat<'hir>>>,\n+        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n     ) -> hir::PatKind<'hir> {\n         match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n             // `None` can occur in body-less function signatures\n@@ -2824,13 +2835,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> P<hir::Pat<'hir>> {\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n         self.pat_with_node_id_of(p, hir::PatKind::Wild)\n     }\n \n     /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n-    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> P<hir::Pat<'hir>> {\n-        P(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n     }\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n@@ -2883,7 +2894,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 ids.push({\n                     hir::Stmt {\n                         hir_id: self.lower_node_id(s.id),\n-                        kind: hir::StmtKind::Local(P(l)),\n+                        kind: hir::StmtKind::Local(self.arena.alloc(l)),\n                         span: s.span,\n                     }\n                 });\n@@ -2905,8 +2916,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => hir::StmtKind::Expr(P(self.lower_expr(e))),\n-            StmtKind::Semi(ref e) => hir::StmtKind::Semi(P(self.lower_expr(e))),\n+            StmtKind::Expr(ref e) => hir::StmtKind::Expr(self.arena.alloc(self.lower_expr(e))),\n+            StmtKind::Semi(ref e) => hir::StmtKind::Semi(self.arena.alloc(self.lower_expr(e))),\n             StmtKind::Mac(..) => panic!(\"shouldn't exist here\"),\n         };\n         smallvec![hir::Stmt { hir_id: self.lower_node_id(s.id), kind, span: s.span }]\n@@ -2949,30 +2960,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn stmt_expr(&mut self, span: Span, expr: hir::Expr<'hir>) -> hir::Stmt<'hir> {\n-        self.stmt(span, hir::StmtKind::Expr(P(expr)))\n+        self.stmt(span, hir::StmtKind::Expr(self.arena.alloc(expr)))\n     }\n \n     fn stmt_let_pat(\n         &mut self,\n         attrs: AttrVec,\n         span: Span,\n-        init: Option<P<hir::Expr<'hir>>>,\n-        pat: P<hir::Pat<'hir>>,\n+        init: Option<&'hir hir::Expr<'hir>>,\n+        pat: &'hir hir::Pat<'hir>,\n         source: hir::LocalSource,\n     ) -> hir::Stmt<'hir> {\n         let local = hir::Local { attrs, hir_id: self.next_id(), init, pat, source, span, ty: None };\n-        self.stmt(span, hir::StmtKind::Local(P(local)))\n+        self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n \n-    fn block_expr(&mut self, expr: P<hir::Expr<'hir>>) -> hir::Block<'hir> {\n-        self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n+    fn block_expr(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Block<'hir> {\n+        self.block_all(expr.span, &[], Some(expr))\n     }\n \n     fn block_all(\n         &mut self,\n         span: Span,\n-        stmts: hir::HirVec<hir::Stmt<'hir>>,\n-        expr: Option<P<hir::Expr<'hir>>>,\n+        stmts: &'hir [hir::Stmt<'hir>],\n+        expr: Option<&'hir hir::Expr<'hir>>,\n     ) -> hir::Block<'hir> {\n         hir::Block {\n             stmts,\n@@ -2985,33 +2996,33 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Constructs a `true` or `false` literal pattern.\n-    fn pat_bool(&mut self, span: Span, val: bool) -> P<hir::Pat<'hir>> {\n+    fn pat_bool(&mut self, span: Span, val: bool) -> &'hir hir::Pat<'hir> {\n         let expr = self.expr_bool(span, val);\n-        self.pat(span, hir::PatKind::Lit(P(expr)))\n+        self.pat(span, hir::PatKind::Lit(self.arena.alloc(expr)))\n     }\n \n-    fn pat_ok(&mut self, span: Span, pat: P<hir::Pat<'hir>>) -> P<hir::Pat<'hir>> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], hir_vec![pat])\n+    fn pat_ok(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Ok], arena_vec![self; pat])\n     }\n \n-    fn pat_err(&mut self, span: Span, pat: P<hir::Pat<'hir>>) -> P<hir::Pat<'hir>> {\n-        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], hir_vec![pat])\n+    fn pat_err(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::result, sym::Result, sym::Err], arena_vec![self; pat])\n     }\n \n-    fn pat_some(&mut self, span: Span, pat: P<hir::Pat<'hir>>) -> P<hir::Pat<'hir>> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], hir_vec![pat])\n+    fn pat_some(&mut self, span: Span, pat: &'hir hir::Pat<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::Some], arena_vec![self; pat])\n     }\n \n-    fn pat_none(&mut self, span: Span) -> P<hir::Pat<'hir>> {\n-        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], hir_vec![])\n+    fn pat_none(&mut self, span: Span) -> &'hir hir::Pat<'hir> {\n+        self.pat_std_enum(span, &[sym::option, sym::Option, sym::None], &[])\n     }\n \n     fn pat_std_enum(\n         &mut self,\n         span: Span,\n         components: &[Symbol],\n-        subpats: hir::HirVec<P<hir::Pat<'hir>>>,\n-    ) -> P<hir::Pat<'hir>> {\n+        subpats: &'hir [&'hir hir::Pat<'hir>],\n+    ) -> &'hir hir::Pat<'hir> {\n         let path = self.std_path(span, components, None, true);\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n@@ -3022,7 +3033,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, ident: Ident) -> (P<hir::Pat<'hir>>, hir::HirId) {\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n         self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n@@ -3031,11 +3042,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         ident: Ident,\n         bm: hir::BindingAnnotation,\n-    ) -> (P<hir::Pat<'hir>>, hir::HirId) {\n+    ) -> (&'hir hir::Pat<'hir>, hir::HirId) {\n         let hir_id = self.next_id();\n \n         (\n-            P(hir::Pat {\n+            self.arena.alloc(hir::Pat {\n                 hir_id,\n                 kind: hir::PatKind::Binding(bm, hir_id, ident.with_span_pos(span), None),\n                 span,\n@@ -3044,12 +3055,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn pat_wild(&mut self, span: Span) -> P<hir::Pat<'hir>> {\n+    fn pat_wild(&mut self, span: Span) -> &'hir hir::Pat<'hir> {\n         self.pat(span, hir::PatKind::Wild)\n     }\n \n-    fn pat(&mut self, span: Span, kind: hir::PatKind<'hir>) -> P<hir::Pat<'hir>> {\n-        P(hir::Pat { hir_id: self.next_id(), kind, span })\n+    fn pat(&mut self, span: Span, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.next_id(), kind, span })\n     }\n \n     /// Given a suffix `[\"b\", \"c\", \"d\"]`, returns path `::std::b::c::d` when"}, {"sha": "bc8a475e8a9d4ab7f611447b74d0e65bec0648b2", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 229, "deletions": 149, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=58b908d09c846b9112fc6a178f832ff84486f8ee", "patch": "@@ -1,7 +1,7 @@\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n+use crate::hir;\n use crate::hir::def::Res;\n use crate::hir::ptr::P;\n-use crate::hir::{self, HirVec};\n \n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -14,26 +14,28 @@ use syntax::symbol::{sym, Symbol};\n use rustc_error_codes::*;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n-    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr<'hir>> {\n-        exprs.iter().map(|x| self.lower_expr(x)).collect()\n+    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n+        self.arena.alloc_from_iter(exprs.iter().map(|x| self.lower_expr(x)))\n     }\n \n     pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         let kind = match e.kind {\n-            ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n+            ExprKind::Box(ref inner) => {\n+                hir::ExprKind::Box(self.arena.alloc(self.lower_expr(inner)))\n+            }\n             ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n             ExprKind::Repeat(ref expr, ref count) => {\n-                let expr = P(self.lower_expr(expr));\n+                let expr = self.arena.alloc(self.lower_expr(expr));\n                 let count = self.lower_anon_const(count);\n                 hir::ExprKind::Repeat(expr, count)\n             }\n             ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n             ExprKind::Call(ref f, ref args) => {\n-                let f = P(self.lower_expr(f));\n+                let f = self.arena.alloc(self.lower_expr(f));\n                 hir::ExprKind::Call(f, self.lower_exprs(args))\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = P(self.lower_path_segment(\n+                let hir_seg = self.arena.alloc(self.lower_path_segment(\n                     e.span,\n                     seg,\n                     ParamMode::Optional,\n@@ -47,26 +49,28 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n-                let lhs = P(self.lower_expr(lhs));\n-                let rhs = P(self.lower_expr(rhs));\n+                let lhs = self.arena.alloc(self.lower_expr(lhs));\n+                let rhs = self.arena.alloc(self.lower_expr(rhs));\n                 hir::ExprKind::Binary(binop, lhs, rhs)\n             }\n             ExprKind::Unary(op, ref ohs) => {\n                 let op = self.lower_unop(op);\n-                let ohs = P(self.lower_expr(ohs));\n+                let ohs = self.arena.alloc(self.lower_expr(ohs));\n                 hir::ExprKind::Unary(op, ohs)\n             }\n             ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.kind.clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n-                let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+                let expr = self.arena.alloc(self.lower_expr(expr));\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                hir::ExprKind::Cast(expr, self.arena.alloc(ty.into_inner()))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n-                let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+                let expr = self.arena.alloc(self.lower_expr(expr));\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                hir::ExprKind::Type(expr, self.arena.alloc(ty.into_inner()))\n             }\n             ExprKind::AddrOf(k, m, ref ohs) => {\n-                let ohs = P(self.lower_expr(ohs));\n+                let ohs = self.arena.alloc(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(k, m, ohs)\n             }\n             ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n@@ -85,8 +89,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }),\n             ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n             ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n-                P(self.lower_expr(expr)),\n-                arms.iter().map(|x| self.lower_arm(x)).collect(),\n+                self.arena.alloc(self.lower_expr(expr)),\n+                self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                 hir::MatchSource::Normal,\n             ),\n             ExprKind::Async(capture_clause, closure_node_id, ref block) => self.make_async_expr(\n@@ -122,18 +126,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_block(blk, opt_label.is_some()),\n                 self.lower_label(opt_label),\n             ),\n-            ExprKind::Assign(ref el, ref er, span) => {\n-                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)), span)\n-            }\n+            ExprKind::Assign(ref el, ref er, span) => hir::ExprKind::Assign(\n+                self.arena.alloc(self.lower_expr(el)),\n+                self.arena.alloc(self.lower_expr(er)),\n+                span,\n+            ),\n             ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n                 self.lower_binop(op),\n-                P(self.lower_expr(el)),\n-                P(self.lower_expr(er)),\n+                self.arena.alloc(self.lower_expr(el)),\n+                self.arena.alloc(self.lower_expr(er)),\n             ),\n-            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(P(self.lower_expr(el)), ident),\n-            ExprKind::Index(ref el, ref er) => {\n-                hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+            ExprKind::Field(ref el, ident) => {\n+                hir::ExprKind::Field(self.arena.alloc(self.lower_expr(el)), ident)\n             }\n+            ExprKind::Index(ref el, ref er) => hir::ExprKind::Index(\n+                self.arena.alloc(self.lower_expr(el)),\n+                self.arena.alloc(self.lower_expr(er)),\n+            ),\n             ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n                 self.lower_expr_range_closed(e.span, e1, e2)\n             }\n@@ -150,26 +159,38 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ExprKind::Path(qpath)\n             }\n-            ExprKind::Break(opt_label, ref opt_expr) => hir::ExprKind::Break(\n-                self.lower_jump_destination(e.id, opt_label),\n-                opt_expr.as_ref().map(|x| P(self.lower_expr(x))),\n-            ),\n+            ExprKind::Break(opt_label, ref opt_expr) => {\n+                let opt_expr = opt_expr\n+                    .as_ref()\n+                    .map(|x| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(x)) });\n+                hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+            }\n             ExprKind::Continue(opt_label) => {\n                 hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n             }\n-            ExprKind::Ret(ref e) => hir::ExprKind::Ret(e.as_ref().map(|x| P(self.lower_expr(x)))),\n+            ExprKind::Ret(ref e) => {\n+                let e = e\n+                    .as_ref()\n+                    .map(|x| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(x)) });\n+                hir::ExprKind::Ret(e)\n+            }\n             ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(asm),\n-            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n-                P(self.lower_qpath(\n-                    e.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                )),\n-                fields.iter().map(|x| self.lower_field(x)).collect(),\n-                maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),\n-            ),\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n+                let maybe_expr = maybe_expr\n+                    .as_ref()\n+                    .map(|x| -> &'hir hir::Expr<'hir> { self.arena.alloc(self.lower_expr(x)) });\n+                hir::ExprKind::Struct(\n+                    self.arena.alloc(self.lower_qpath(\n+                        e.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    )),\n+                    self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n+                    maybe_expr,\n+                )\n+            }\n             ExprKind::Paren(ref ex) => {\n                 let mut ex = self.lower_expr(ex);\n                 // Include parens in span, but only if it is a super-span.\n@@ -266,16 +287,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let then_arm = {\n             let pat = self.lower_pat(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pat, P(expr))\n+            self.arm(pat, self.arena.alloc(expr))\n         };\n         let else_arm = {\n             let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pat, P(expr))\n+            self.arm(pat, self.arena.alloc(expr))\n         };\n         hir::ExprKind::Match(\n-            P(scrutinee),\n-            vec![then_arm, else_arm].into(),\n+            self.arena.alloc(scrutinee),\n+            arena_vec![self; then_arm, else_arm],\n             hir::MatchSource::Normal,\n         )\n     }\n@@ -295,7 +316,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             None => (self.expr_block_empty(span), false),\n             Some(els) => (self.lower_expr(els), true),\n         };\n-        let else_arm = self.arm(else_pat, P(else_expr));\n+        let else_arm = self.arm(else_pat, self.arena.alloc(else_expr));\n \n         // Handle then + scrutinee:\n         let then_expr = self.lower_block_expr(then);\n@@ -315,14 +336,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+                let cond = self.expr_drop_temps(span_block, self.arena.alloc(cond), ThinVec::new());\n                 let pat = self.pat_bool(span, true);\n                 (pat, cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pat, P(then_expr));\n+        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n \n-        hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n+        hir::ExprKind::Match(\n+            self.arena.alloc(scrutinee),\n+            arena_vec![self; then_arm, else_arm],\n+            desugar,\n+        )\n     }\n \n     fn lower_expr_while_in_loop_scope(\n@@ -379,28 +404,36 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n-                let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+                let cond = self.expr_drop_temps(span_block, self.arena.alloc(cond), ThinVec::new());\n                 // `true => <then>`:\n                 let pat = self.pat_bool(span, true);\n                 (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pat, P(then_expr));\n+        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n \n         // `match <scrutinee> { ... }`\n-        let match_expr =\n-            self.expr_match(scrutinee.span, P(scrutinee), hir_vec![then_arm, else_arm], desugar);\n+        let match_expr = self.expr_match(\n+            scrutinee.span,\n+            self.arena.alloc(scrutinee),\n+            arena_vec![self; then_arm, else_arm],\n+            desugar,\n+        );\n \n         // `[opt_ident]: loop { ... }`\n-        hir::ExprKind::Loop(P(self.block_expr(P(match_expr))), self.lower_label(opt_label), source)\n+        hir::ExprKind::Loop(\n+            self.arena.alloc(self.block_expr(self.arena.alloc(match_expr))),\n+            self.lower_label(opt_label),\n+            source,\n+        )\n     }\n \n     /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n     /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n     /// and save the block id to use it as a break target for desugaring of the `?` operator.\n     fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind<'hir> {\n         self.with_catch_scope(body.id, |this| {\n-            let mut block = this.lower_block(body, true).into_inner();\n+            let mut block = this.lower_block_noalloc(body, true);\n \n             let try_span = this.mark_span_with_reason(\n                 DesugaringKind::TryBlock,\n@@ -410,8 +443,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             // Final expression of the block (if present) or `()` with span at the end of block\n             let tail_expr = block.expr.take().map_or_else(\n-                || this.expr_unit(this.sess.source_map().end_point(try_span)),\n-                |x: P<hir::Expr<'hir>>| x.into_inner(),\n+                || -> &'hir hir::Expr<'hir> {\n+                    this.arena.alloc(this.expr_unit(this.sess.source_map().end_point(try_span)))\n+                },\n+                |x: &'hir hir::Expr<'hir>| x,\n             );\n \n             let ok_wrapped_span =\n@@ -425,32 +460,33 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ok_wrapped_span,\n             ));\n \n-            hir::ExprKind::Block(P(block), None)\n+            hir::ExprKind::Block(this.arena.alloc(block), None)\n         })\n     }\n \n     fn wrap_in_try_constructor(\n         &mut self,\n         method: Symbol,\n         method_span: Span,\n-        expr: hir::Expr<'hir>,\n+        expr: &'hir hir::Expr<'hir>,\n         overall_span: Span,\n-    ) -> P<hir::Expr<'hir>> {\n+    ) -> &'hir hir::Expr<'hir> {\n         let path = &[sym::ops, sym::Try, method];\n-        let constructor = P(self.expr_std_path(method_span, path, None, ThinVec::new()));\n-        P(self.expr_call(overall_span, constructor, hir_vec![expr]))\n+        let constructor =\n+            self.arena.alloc(self.expr_std_path(method_span, path, None, ThinVec::new()));\n+        self.arena.alloc(self.expr_call(overall_span, constructor, std::slice::from_ref(expr)))\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n-            attrs: self.lower_attrs(&arm.attrs),\n+            attrs: self.lower_attrs_arena(&arm.attrs),\n             pat: self.lower_pat(&arm.pat),\n             guard: match arm.guard {\n-                Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n+                Some(ref x) => Some(hir::Guard::If(self.arena.alloc(self.lower_expr(x)))),\n                 _ => None,\n             },\n-            body: P(self.lower_expr(&arm.body)),\n+            body: self.arena.alloc(self.lower_expr(&arm.body)),\n             span: arm.span,\n         }\n     }\n@@ -469,7 +505,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             None => FunctionRetTy::Default(span),\n         };\n         let ast_decl = FnDecl { inputs: vec![], output };\n-        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n+        let decl = self.arena.alloc(\n+            self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None).into_inner(),\n+        );\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n             this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n             body(this)\n@@ -501,7 +539,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         );\n \n         // `future::from_generator(generator)`:\n-        hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n+        hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n     }\n \n     /// Desugar `<expr>.await` into:\n@@ -550,22 +588,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         //     ::std::pin::Pin::new_unchecked(&mut pinned)\n         // })`\n         let poll_expr = {\n-            let pinned = P(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n+            let pinned = self.arena.alloc(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n             let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n             let pin_ty_id = self.next_id();\n             let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n                 pin_ty_id,\n                 span,\n                 &[sym::pin, sym::Pin],\n                 \"new_unchecked\",\n-                hir_vec![ref_mut_pinned],\n+                arena_vec![self; ref_mut_pinned],\n             );\n-            let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n+            let new_unchecked =\n+                self.arena.alloc(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n             let unsafe_expr = self.expr_unsafe(new_unchecked);\n-            P(self.expr_call_std_path(\n+            self.arena.alloc(self.expr_call_std_path(\n                 gen_future_span,\n                 &[sym::future, sym::poll_with_tls_context],\n-                hir_vec![unsafe_expr],\n+                arena_vec![self; unsafe_expr],\n             ))\n         };\n \n@@ -575,30 +614,32 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ready_arm = {\n             let x_ident = Ident::with_dummy_span(sym::result);\n             let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n-            let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n-            let ready_pat =\n-                self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Ready], hir_vec![x_pat]);\n-            let break_x = self.with_loop_scope(loop_node_id, |this| {\n+            let x_expr = self.arena.alloc(self.expr_ident(span, x_ident, x_pat_hid));\n+            let ready_pat = self.pat_std_enum(\n+                span,\n+                &[sym::task, sym::Poll, sym::Ready],\n+                arena_vec![self; x_pat],\n+            );\n+            let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n-                P(this.expr(await_span, expr_break, ThinVec::new()))\n+                this.arena.alloc(this.expr(await_span, expr_break, ThinVec::new()))\n             });\n             self.arm(ready_pat, break_x)\n         };\n \n         // `::std::task::Poll::Pending => {}`\n         let pending_arm = {\n-            let pending_pat =\n-                self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Pending], hir_vec![]);\n-            let empty_block = P(self.expr_block_empty(span));\n+            let pending_pat = self.pat_std_enum(span, &[sym::task, sym::Poll, sym::Pending], &[]);\n+            let empty_block = self.arena.alloc(self.expr_block_empty(span));\n             self.arm(pending_pat, empty_block)\n         };\n \n         let inner_match_stmt = {\n             let match_expr = self.expr_match(\n                 span,\n                 poll_expr,\n-                hir_vec![ready_arm, pending_arm],\n+                arena_vec![self; ready_arm, pending_arm],\n                 hir::MatchSource::AwaitDesugar,\n             );\n             self.stmt_expr(span, match_expr)\n@@ -608,16 +649,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let unit = self.expr_unit(span);\n             let yield_expr = self.expr(\n                 span,\n-                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n+                hir::ExprKind::Yield(self.arena.alloc(unit), hir::YieldSource::Await),\n                 ThinVec::new(),\n             );\n             self.stmt_expr(span, yield_expr)\n         };\n \n-        let loop_block = P(self.block_all(span, hir_vec![inner_match_stmt, yield_stmt], None));\n+        let loop_block = self.arena.alloc(self.block_all(\n+            span,\n+            arena_vec![self; inner_match_stmt, yield_stmt],\n+            None,\n+        ));\n \n         // loop { .. }\n-        let loop_expr = P(hir::Expr {\n+        let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: loop_hir_id,\n             kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop),\n             span,\n@@ -630,8 +675,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // match <expr> {\n         //     mut pinned => loop { .. }\n         // }\n-        let expr = P(self.lower_expr(expr));\n-        hir::ExprKind::Match(expr, hir_vec![pinned_arm], hir::MatchSource::AwaitDesugar)\n+        let expr = self.arena.alloc(self.lower_expr(expr));\n+        hir::ExprKind::Match(expr, arena_vec![self; pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n \n     fn lower_expr_closure(\n@@ -644,8 +689,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         // Lower outside new scope to preserve `is_in_loop_condition`.\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n+        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n-        self.with_new_scopes(|this| {\n+        self.with_new_scopes(move |this| {\n             let prev = this.current_item;\n             this.current_item = Some(fn_decl_span);\n             let mut generator_kind = None;\n@@ -706,8 +752,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // have to conserve the state of being inside a loop condition for the\n         // closure argument types.\n         let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n+        let fn_decl = self.arena.alloc(fn_decl.into_inner());\n \n-        self.with_new_scopes(|this| {\n+        self.with_new_scopes(move |this| {\n             // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n             if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n                 struct_span_err!(\n@@ -752,7 +799,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             span,\n             &[sym::ops, sym::RangeInclusive],\n             \"new\",\n-            hir_vec![e1, e2],\n+            arena_vec![self; e1, e2],\n         )\n     }\n \n@@ -777,16 +824,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n         };\n \n-        let fields = e1\n-            .iter()\n-            .map(|e| (\"start\", e))\n-            .chain(e2.iter().map(|e| (\"end\", e)))\n-            .map(|(s, e)| {\n-                let expr = P(self.lower_expr(&e));\n+        let fields = self.arena.alloc_from_iter(\n+            e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e))).map(|(s, e)| {\n+                let expr = self.arena.alloc(self.lower_expr(&e));\n                 let ident = Ident::new(Symbol::intern(s), e.span);\n                 self.field(ident, expr, e.span)\n-            })\n-            .collect::<P<[hir::Field<'hir>]>>();\n+            }),\n+        );\n \n         let is_unit = fields.is_empty();\n         let struct_path = [sym::ops, path];\n@@ -796,7 +840,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         if is_unit {\n             hir::ExprKind::Path(struct_path)\n         } else {\n-            hir::ExprKind::Struct(P(struct_path), fields, None)\n+            hir::ExprKind::Struct(self.arena.alloc(struct_path), fields, None)\n         }\n     }\n \n@@ -837,7 +881,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let len = self.catch_scopes.len();\n         self.catch_scopes.push(catch_id);\n@@ -856,7 +900,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         // We're no longer in the base loop's condition; we're in another loop.\n         let was_in_loop_condition = self.is_in_loop_condition;\n@@ -881,7 +925,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn with_loop_condition_scope<T, F>(&mut self, f: F) -> T\n     where\n-        F: FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+        F: FnOnce(&mut Self) -> T,\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = true;\n@@ -915,17 +959,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n         let hir_asm = hir::InlineAsm {\n             inner,\n-            inputs_exprs: asm.inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect(),\n-            outputs_exprs: asm.outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n+            inputs_exprs: self\n+                .arena\n+                .alloc_from_iter(asm.inputs.iter().map(|&(_, ref input)| self.lower_expr(input))),\n+            outputs_exprs: self\n+                .arena\n+                .alloc_from_iter(asm.outputs.iter().map(|out| self.lower_expr(&out.expr))),\n         };\n-        hir::ExprKind::InlineAsm(P(hir_asm))\n+        hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n     }\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field<'hir> {\n         hir::Field {\n             hir_id: self.next_id(),\n             ident: f.ident,\n-            expr: P(self.lower_expr(&f.expr)),\n+            expr: self.arena.alloc(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n         }\n@@ -944,7 +992,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let expr =\n             opt_expr.as_ref().map(|x| self.lower_expr(x)).unwrap_or_else(|| self.expr_unit(span));\n \n-        hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n+        hir::ExprKind::Yield(self.arena.alloc(expr), hir::YieldSource::Yield)\n     }\n \n     /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n@@ -992,9 +1040,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let pat_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n-            let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n-            let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n-            let assign = P(self.expr(\n+            let val_expr = self.arena.alloc(self.expr_ident(pat.span, val_ident, val_pat_hid));\n+            let next_expr = self.arena.alloc(self.expr_ident(pat.span, next_ident, next_pat_hid));\n+            let assign = self.arena.alloc(self.expr(\n                 pat.span,\n                 hir::ExprKind::Assign(next_expr, val_expr, pat.span),\n                 ThinVec::new(),\n@@ -1017,18 +1065,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n         let match_expr = {\n-            let iter = P(self.expr_ident(desugared_span, iter, iter_pat_nid));\n+            let iter = self.arena.alloc(self.expr_ident(desugared_span, iter, iter_pat_nid));\n             let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n             let next_path = &[sym::iter, sym::Iterator, sym::next];\n-            let next_expr =\n-                P(self.expr_call_std_path(desugared_span, next_path, hir_vec![ref_mut_iter]));\n-            let arms = hir_vec![pat_arm, break_arm];\n+            let next_expr = self.arena.alloc(self.expr_call_std_path(\n+                desugared_span,\n+                next_path,\n+                arena_vec![self; ref_mut_iter],\n+            ));\n+            let arms = arena_vec![self; pat_arm, break_arm];\n \n             self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n         };\n         let match_stmt = self.stmt_expr(desugared_span, match_expr);\n \n-        let next_expr = P(self.expr_ident(desugared_span, next_ident, next_pat_hid));\n+        let next_expr = self.arena.alloc(self.expr_ident(desugared_span, next_ident, next_pat_hid));\n \n         // `let mut __next`\n         let next_let = self.stmt_let_pat(\n@@ -1053,13 +1104,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let body_expr = self.expr_block(body_block, ThinVec::new());\n         let body_stmt = self.stmt_expr(body.span, body_expr);\n \n-        let loop_block =\n-            P(self.block_all(e.span, hir_vec![next_let, match_stmt, pat_let, body_stmt], None));\n+        let loop_block = self.arena.alloc(self.block_all(\n+            e.span,\n+            arena_vec![self; next_let, match_stmt, pat_let, body_stmt],\n+            None,\n+        ));\n \n         // `[opt_ident]: loop { ... }`\n         let kind =\n             hir::ExprKind::Loop(loop_block, self.lower_label(opt_label), hir::LoopSource::ForLoop);\n-        let loop_expr = P(hir::Expr {\n+        let loop_expr = self.arena.alloc(hir::Expr {\n             hir_id: self.lower_node_id(e.id),\n             kind,\n             span: e.span,\n@@ -1072,13 +1126,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n         let into_iter_expr = {\n             let into_iter_path = &[sym::iter, sym::IntoIterator, sym::into_iter];\n-            P(self.expr_call_std_path(desugared_span, into_iter_path, hir_vec![head]))\n+            self.arena.alloc(self.expr_call_std_path(\n+                desugared_span,\n+                into_iter_path,\n+                arena_vec![self; head],\n+            ))\n         };\n \n-        let match_expr = P(self.expr_match(\n+        let match_expr = self.arena.alloc(self.expr_match(\n             desugared_span,\n             into_iter_expr,\n-            hir_vec![iter_arm],\n+            arena_vec![self; iter_arm],\n             hir::MatchSource::ForLoopDesugar,\n         ));\n \n@@ -1121,7 +1179,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let sub_expr = self.lower_expr(sub_expr);\n \n             let path = &[sym::ops, sym::Try, sym::into_result];\n-            P(self.expr_call_std_path(unstable_span, path, hir_vec![sub_expr]))\n+            self.arena.alloc(self.expr_call_std_path(\n+                unstable_span,\n+                path,\n+                arena_vec![self; sub_expr],\n+            ))\n         };\n \n         // `#[allow(unreachable_code)]`\n@@ -1141,7 +1203,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ok_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n-            let val_expr = P(self.expr_ident_with_attrs(\n+            let val_expr = self.arena.alloc(self.expr_ident_with_attrs(\n                 span,\n                 val_ident,\n                 val_pat_nid,\n@@ -1159,15 +1221,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let from_expr = {\n                 let from_path = &[sym::convert, sym::From, sym::from];\n                 let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n-                self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n+                self.arena.alloc(self.expr_call_std_path(\n+                    try_span,\n+                    from_path,\n+                    arena_vec![self; err_expr],\n+                ))\n             };\n             let from_err_expr =\n                 self.wrap_in_try_constructor(sym::from_error, unstable_span, from_expr, try_span);\n             let thin_attrs = ThinVec::from(attrs);\n             let catch_scope = self.catch_scopes.last().map(|x| *x);\n             let ret_expr = if let Some(catch_node) = catch_scope {\n                 let target_id = Ok(self.lower_node_id(catch_node));\n-                P(self.expr(\n+                self.arena.alloc(self.expr(\n                     try_span,\n                     hir::ExprKind::Break(\n                         hir::Destination { label: None, target_id },\n@@ -1176,14 +1242,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     thin_attrs,\n                 ))\n             } else {\n-                P(self.expr(try_span, hir::ExprKind::Ret(Some(from_err_expr)), thin_attrs))\n+                self.arena.alloc(self.expr(\n+                    try_span,\n+                    hir::ExprKind::Ret(Some(from_err_expr)),\n+                    thin_attrs,\n+                ))\n             };\n \n             let err_pat = self.pat_err(try_span, err_local);\n             self.arm(err_pat, ret_expr)\n         };\n \n-        hir::ExprKind::Match(scrutinee, hir_vec![err_arm, ok_arm], hir::MatchSource::TryDesugar)\n+        hir::ExprKind::Match(\n+            scrutinee,\n+            arena_vec![self; err_arm, ok_arm],\n+            hir::MatchSource::TryDesugar,\n+        )\n     }\n \n     // =========================================================================\n@@ -1205,7 +1279,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn expr_drop_temps(\n         &mut self,\n         span: Span,\n-        expr: P<hir::Expr<'hir>>,\n+        expr: &'hir hir::Expr<'hir>,\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n@@ -1214,19 +1288,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn expr_match(\n         &mut self,\n         span: Span,\n-        arg: P<hir::Expr<'hir>>,\n-        arms: hir::HirVec<hir::Arm<'hir>>,\n+        arg: &'hir hir::Expr<'hir>,\n+        arms: &'hir [hir::Arm<'hir>],\n         source: hir::MatchSource,\n     ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> P<hir::Expr<'hir>> {\n+    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n-        P(self.expr(span, expr_break, attrs))\n+        self.arena.alloc(self.expr(span, expr_break, attrs))\n     }\n \n-    fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr<'_>>) -> hir::Expr<'_> {\n+    fn expr_mut_addr_of(&mut self, span: Span, e: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n         self.expr(\n             span,\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n@@ -1235,18 +1309,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> hir::Expr<'hir> {\n-        self.expr_tuple(sp, hir_vec![])\n+        self.expr_tuple(sp, &[])\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr<'hir>>) -> hir::Expr<'hir> {\n+    fn expr_tuple(&mut self, sp: Span, exprs: &'hir [hir::Expr<'hir>]) -> hir::Expr<'hir> {\n         self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new())\n     }\n \n     fn expr_call(\n         &mut self,\n         span: Span,\n-        e: P<hir::Expr<'hir>>,\n-        args: hir::HirVec<hir::Expr<'hir>>,\n+        e: &'hir hir::Expr<'hir>,\n+        args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n     }\n@@ -1256,9 +1330,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         path_components: &[Symbol],\n-        args: hir::HirVec<hir::Expr<'hir>>,\n+        args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n+        let path =\n+            self.arena.alloc(self.expr_std_path(span, path_components, None, ThinVec::new()));\n         self.expr_call(span, path, args)\n     }\n \n@@ -1277,13 +1352,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         ty_path_components: &[Symbol],\n         assoc_fn_name: &str,\n-        args: hir::HirVec<hir::Expr<'hir>>,\n+        args: &'hir [hir::Expr<'hir>],\n     ) -> hir::ExprKind<'hir> {\n         let ty_path = P(self.std_path(span, ty_path_components, None, false));\n         let ty = P(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n         let fn_seg = P(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n         let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n-        let fn_expr = P(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        let fn_expr =\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n         hir::ExprKind::Call(fn_expr, args)\n     }\n \n@@ -1326,14 +1402,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         self.expr(span, expr_path, attrs)\n     }\n \n-    fn expr_unsafe(&mut self, expr: P<hir::Expr<'hir>>) -> hir::Expr<'hir> {\n+    fn expr_unsafe(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n         let span = expr.span;\n         self.expr(\n             span,\n             hir::ExprKind::Block(\n-                P(hir::Block {\n-                    stmts: hir_vec![],\n+                self.arena.alloc(hir::Block {\n+                    stmts: &[],\n                     expr: Some(expr),\n                     hir_id,\n                     rules: hir::UnsafeBlock(hir::CompilerGenerated),\n@@ -1347,11 +1423,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn expr_block_empty(&mut self, span: Span) -> hir::Expr<'hir> {\n-        let blk = self.block_all(span, hir_vec![], None);\n-        self.expr_block(P(blk), ThinVec::new())\n+        let blk = self.block_all(span, &[], None);\n+        self.expr_block(self.arena.alloc(blk), ThinVec::new())\n     }\n \n-    pub(super) fn expr_block(&mut self, b: P<hir::Block<'hir>>, attrs: AttrVec) -> hir::Expr<'hir> {\n+    pub(super) fn expr_block(\n+        &mut self,\n+        b: &'hir hir::Block<'hir>,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n         self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n@@ -1364,14 +1444,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n     }\n \n-    fn field(&mut self, ident: Ident, expr: P<hir::Expr<'hir>>, span: Span) -> hir::Field<'hir> {\n+    fn field(&mut self, ident: Ident, expr: &'hir hir::Expr<'hir>, span: Span) -> hir::Field<'hir> {\n         hir::Field { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n     }\n \n-    fn arm(&mut self, pat: P<hir::Pat<'hir>>, expr: P<hir::Expr<'hir>>) -> hir::Arm<'hir> {\n+    fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n-            attrs: hir_vec![],\n+            attrs: &[],\n             pat,\n             guard: None,\n             span: expr.span,"}, {"sha": "19ef106b9bd8eb10438c0ea5f11a191cac234398", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=58b908d09c846b9112fc6a178f832ff84486f8ee", "patch": "@@ -1005,7 +1005,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n         hir::Param {\n-            attrs: self.lower_attrs(&param.attrs),\n+            attrs: self.lower_attrs_arena(&param.attrs),\n             hir_id: self.lower_node_id(param.id),\n             pat: self.lower_pat(&param.pat),\n             span: param.span,\n@@ -1066,8 +1066,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         self.lower_body(|this| {\n-            let mut parameters: Vec<hir::Param<'hir>> = Vec::new();\n-            let mut statements: Vec<hir::Stmt<'hir>> = Vec::new();\n+            let mut parameters: Vec<hir::Param<'_>> = Vec::new();\n+            let mut statements: Vec<hir::Stmt<'_>> = Vec::new();\n \n             // Async function parameters are lowered into the closure body so that they are\n             // captured and so that the drop order matches the equivalent non-async functions.\n@@ -1145,7 +1145,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n-                        Some(P(expr)),\n+                        Some(this.arena.alloc(expr)),\n                         parameter.pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1175,7 +1175,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let move_stmt = this.stmt_let_pat(\n                         AttrVec::new(),\n                         desugared_span,\n-                        Some(P(move_expr)),\n+                        Some(this.arena.alloc(move_expr)),\n                         move_pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1186,7 +1186,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let pattern_stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n-                        Some(P(pattern_expr)),\n+                        Some(this.arena.alloc(pattern_expr)),\n                         parameter.pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1212,8 +1212,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n                         this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None);\n-                    let user_body =\n-                        this.expr_drop_temps(desugared_span, P(user_body), AttrVec::new());\n+                    let user_body = this.expr_drop_temps(\n+                        desugared_span,\n+                        this.arena.alloc(user_body),\n+                        AttrVec::new(),\n+                    );\n \n                     // As noted above, create the final block like\n                     //\n@@ -1224,9 +1227,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     //   drop-temps { <user-body> }\n                     // }\n                     // ```\n-                    let body =\n-                        this.block_all(desugared_span, statements.into(), Some(P(user_body)));\n-                    this.expr_block(P(body), AttrVec::new())\n+                    let body = this.block_all(\n+                        desugared_span,\n+                        this.arena.alloc_from_iter(statements),\n+                        Some(this.arena.alloc(user_body)),\n+                    );\n+\n+                    this.expr_block(this.arena.alloc(body), AttrVec::new())\n                 },\n             );\n "}, {"sha": "003917ee1e1bf4bc6182d4d4a6b7de45c8a75ce4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58b908d09c846b9112fc6a178f832ff84486f8ee/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=58b908d09c846b9112fc6a178f832ff84486f8ee", "patch": "@@ -50,6 +50,15 @@ macro_rules! hir_vec {\n     );\n }\n \n+macro_rules! arena_vec {\n+    () => (\n+        &[]\n+    );\n+    ($this:expr; $($x:expr),*) => (\n+        $this.arena.alloc_from_iter(vec![$($x),*])\n+    );\n+}\n+\n pub mod check_attr;\n pub mod def;\n pub mod def_id;"}]}