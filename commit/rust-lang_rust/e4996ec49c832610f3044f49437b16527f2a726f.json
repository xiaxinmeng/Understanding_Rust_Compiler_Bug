{"sha": "e4996ec49c832610f3044f49437b16527f2a726f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0OTk2ZWM0OWM4MzI2MTBmMzA0NGY0OTQzN2IxNjUyN2YyYTcyNmY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-29T16:24:49Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-01T08:18:31Z"}, "message": "rustc: use hir::ItemLocalId instead of ast::NodeId in CodeExtent.", "tree": {"sha": "cd9918ad7389205be8218d9e30e182dff1cfc8ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd9918ad7389205be8218d9e30e182dff1cfc8ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4996ec49c832610f3044f49437b16527f2a726f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4996ec49c832610f3044f49437b16527f2a726f", "html_url": "https://github.com/rust-lang/rust/commit/e4996ec49c832610f3044f49437b16527f2a726f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4996ec49c832610f3044f49437b16527f2a726f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea6aca7726bd035ae79fc4643f863178c8f26e90", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6aca7726bd035ae79fc4643f863178c8f26e90", "html_url": "https://github.com/rust-lang/rust/commit/ea6aca7726bd035ae79fc4643f863178c8f26e90"}], "stats": {"total": 736, "additions": 333, "deletions": 403}, "files": [{"sha": "8908bcb88655901d0b7926d13a933bff4ee05c8d", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -582,10 +582,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         target_scope: CodeExtent,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = CodeExtent::Misc(from_expr.id);\n+        let mut scope = CodeExtent::Misc(from_expr.hir_id.local_id);\n         let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n-            data.exiting_scopes.push(self.tcx.hir.node_to_hir_id(scope.node_id()).local_id);\n+            data.exiting_scopes.push(scope.item_local_id());\n             scope = region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n@@ -612,7 +612,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ScopeTarget::Block(block_expr_id) => {\n                 for b in &self.breakable_block_scopes {\n                     if b.block_expr_id == self.tcx.hir.node_to_hir_id(block_expr_id).local_id {\n-                        return (CodeExtent::Misc(block_expr_id), match scope_cf_kind {\n+                        let scope_id = self.tcx.hir.node_to_hir_id(block_expr_id).local_id;\n+                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => b.break_index,\n                             ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n                         });\n@@ -623,7 +624,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => {\n                 for l in &self.loop_scopes {\n                     if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n-                        return (CodeExtent::Misc(loop_id), match scope_cf_kind {\n+                        let scope_id = self.tcx.hir.node_to_hir_id(loop_id).local_id;\n+                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => l.break_index,\n                             ScopeCfKind::Continue => l.continue_index,\n                         });"}, {"sha": "9241240caf043b174a72fdd913d6c2bbf91b940d", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -32,8 +32,9 @@ pub struct LabelledCFG<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n     fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n+        assert!(self.cfg.owner_def_id.is_local());\n         let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n-            owner: self.tcx.closure_base_def_id(self.cfg.owner_def_id).index,\n+            owner: self.tcx.hir.def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n             local_id\n         });\n         let s = self.tcx.hir.node_to_string(node_id);"}, {"sha": "90d781c6e36649e15357bf3faf14a802da7b165a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             prefix, scope, suffix)\n                 };\n                 let span = scope.span(self, region_maps);\n-                let tag = match self.hir.find(scope.node_id()) {\n+                let tag = match self.hir.find(scope.node_id(self, region_maps)) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\","}, {"sha": "1589ba60275904dc5ea7d0e398cf0b43e4c4983a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -23,7 +23,7 @@ use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n use middle::mem_categorization as mc;\n-use middle::region::RegionMaps;\n+use middle::region::{CodeExtent, RegionMaps};\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n@@ -298,7 +298,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         for arg in &body.arguments {\n             let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.hir_id));\n \n-            let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n+            let fn_body_scope_r =\n+                self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(body.value.hir_id.local_id)));\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -542,16 +543,17 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n+                let call_scope = CodeExtent::Misc(call.hir_id.local_id);\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n-                        let call_scope_r = self.tcx().node_scope_region(call.id);\n+                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n                         self.borrow_expr(callee,\n                                          call_scope_r,\n                                          ty::MutBorrow,\n                                          ClosureInvocation);\n                     }\n                     FnOverloadedCall => {\n-                        let call_scope_r = self.tcx().node_scope_region(call.id);\n+                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n                         self.borrow_expr(callee,\n                                          call_scope_r,\n                                          ty::ImmBorrow,\n@@ -749,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = self.tcx().node_scope_region(expr.id);\n+                let r = self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,"}, {"sha": "fdab71ee004419b8836ef3d44e995a302a2f2cd1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -861,8 +861,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region<'tcx>\n-    {\n+    pub fn temporary_scope(&self, id: hir::ItemLocalId) -> ty::Region<'tcx> {\n         let scope = self.region_maps.temporary_scope(id);\n         self.tcx.mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n@@ -890,7 +889,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let re = if promotable {\n             self.tcx.types.re_static\n         } else {\n-            self.temporary_scope(id)\n+            self.temporary_scope(self.tcx.hir.node_to_hir_id(id).local_id)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);"}, {"sha": "f58d1a0b41fec859e249e3f0257c0e218f3b61bf", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 142, "deletions": 194, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -16,23 +16,22 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n-use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n+use std::collections::hash_map::Entry;\n use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n use syntax::ast;\n-use syntax::ast::NodeId;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n use ty::TyCtxt;\n use ty::maps::Providers;\n \n use hir;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n-use hir::map::Node;\n use mir::transform::MirSource;\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -98,18 +97,18 @@ use mir::transform::MirSource;\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum CodeExtent {\n-    Misc(ast::NodeId),\n+    Misc(hir::ItemLocalId),\n \n     // extent of the call-site for a function or closure (outlives\n     // the parameters as well as the body).\n-    CallSiteScope(hir::BodyId),\n+    CallSiteScope(hir::ItemLocalId),\n \n     // extent of parameters passed to a function or closure (they\n     // outlive its body)\n-    ParameterScope(hir::BodyId),\n+    ParameterScope(hir::ItemLocalId),\n \n     // extent of destructors for temporaries of node-id\n-    DestructionScope(ast::NodeId),\n+    DestructionScope(hir::ItemLocalId),\n \n     // extent of code following a `let id = expr;` binding in a block\n     Remainder(BlockRemainder)\n@@ -135,38 +134,51 @@ pub enum CodeExtent {\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n-    pub block: ast::NodeId,\n+    pub block: hir::ItemLocalId,\n     pub first_statement_index: u32,\n }\n \n impl CodeExtent {\n-    /// Returns a node id associated with this scope.\n+    /// Returns a item-local id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n-    pub fn node_id(&self) -> ast::NodeId {\n+    pub fn item_local_id(&self) -> hir::ItemLocalId {\n         match *self {\n-            CodeExtent::Misc(node_id) => node_id,\n+            CodeExtent::Misc(id) => id,\n \n             // These cases all return rough approximations to the\n             // precise extent denoted by `self`.\n             CodeExtent::Remainder(br) => br.block,\n-            CodeExtent::DestructionScope(node_id) => node_id,\n-            CodeExtent::CallSiteScope(body_id) |\n-            CodeExtent::ParameterScope(body_id) => body_id.node_id,\n+            CodeExtent::DestructionScope(id) |\n+            CodeExtent::CallSiteScope(id) |\n+            CodeExtent::ParameterScope(id) => id,\n+        }\n+    }\n+\n+    pub fn node_id(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> ast::NodeId {\n+        match region_maps.root_body {\n+            Some(hir_id) => {\n+                tcx.hir.hir_to_node_id(hir::HirId {\n+                    owner: hir_id.owner,\n+                    local_id: self.item_local_id()\n+                })\n+            }\n+            None => ast::DUMMY_NODE_ID\n         }\n     }\n \n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n     pub fn span(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> Span {\n-        let root_node = region_maps.root_body.unwrap().node_id;\n-        assert_eq!(DefId::local(tcx.hir.node_to_hir_id(self.node_id()).owner),\n-                   DefId::local(tcx.hir.node_to_hir_id(root_node).owner));\n-        let span = tcx.hir.span(self.node_id());\n+        let node_id = self.node_id(tcx, region_maps);\n+        if node_id == ast::DUMMY_NODE_ID {\n+            return DUMMY_SP;\n+        }\n+        let span = tcx.hir.span(node_id);\n         if let CodeExtent::Remainder(r) = *self {\n-            if let hir::map::NodeBlock(ref blk) = tcx.hir.get(r.block) {\n+            if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for extent starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -189,9 +201,10 @@ impl CodeExtent {\n }\n \n /// The region maps encode information about region relationships.\n+#[derive(Default)]\n pub struct RegionMaps {\n     /// If not empty, this body is the root of this region hierarchy.\n-    root_body: Option<hir::BodyId>,\n+    root_body: Option<hir::HirId>,\n \n     /// The parent of the root body owner, if the latter is an\n     /// an associated const or method, as impls/traits can also\n@@ -208,10 +221,10 @@ pub struct RegionMaps {\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: NodeMap<CodeExtent>,\n+    var_map: FxHashMap<hir::ItemLocalId, CodeExtent>,\n \n     /// maps from a node-id to the associated destruction scope (if any)\n-    destruction_scopes: NodeMap<CodeExtent>,\n+    destruction_scopes: FxHashMap<hir::ItemLocalId, CodeExtent>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n@@ -221,7 +234,7 @@ pub struct RegionMaps {\n     /// block (see `terminating_scopes`).\n     /// In constants, None is used to indicate that certain expressions\n     /// escape into 'static and should have no local cleanup scope.\n-    rvalue_scopes: NodeMap<Option<CodeExtent>>,\n+    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<CodeExtent>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -233,7 +246,11 @@ pub struct RegionMaps {\n     /// closure defined by that fn. See the \"Modeling closures\"\n     /// section of the README in infer::region_inference for\n     /// more details.\n-    fn_tree: NodeMap<ast::NodeId>,\n+    closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n+\n+    /// If there are any `yield` nested within a scope, this map\n+    /// stores the `Span` of the first one.\n+    yield_in_scope: FxHashMap<CodeExtent, Span>,\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -244,7 +261,7 @@ pub struct Context {\n     /// arranged into a tree. See the \"Modeling closures\" section of\n     /// the README in infer::region_inference for more\n     /// details.\n-    root_id: Option<ast::NodeId>,\n+    root_id: Option<hir::ItemLocalId>,\n \n     /// the scope that contains any new variables declared\n     var_parent: Option<CodeExtent>,\n@@ -281,23 +298,11 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     /// arbitrary amounts of stack space. Terminating scopes end\n     /// up being contained in a DestructionScope that contains the\n     /// destructor's execution.\n-    terminating_scopes: NodeSet,\n+    terminating_scopes: FxHashSet<hir::ItemLocalId>,\n }\n \n \n impl<'tcx> RegionMaps {\n-    pub fn new() -> Self {\n-        RegionMaps {\n-            root_body: None,\n-            root_parent: None,\n-            scope_map: FxHashMap(),\n-            destruction_scopes: FxHashMap(),\n-            var_map: NodeMap(),\n-            rvalue_scopes: NodeMap(),\n-            fn_tree: NodeMap(),\n-        }\n-    }\n-\n     pub fn record_code_extent(&mut self,\n                               child: CodeExtent,\n                               parent: Option<CodeExtent>) {\n@@ -320,46 +325,51 @@ impl<'tcx> RegionMaps {\n         }\n     }\n \n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent) {\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&hir::ItemLocalId, CodeExtent) {\n         for (child, &parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n-    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn opt_destruction_extent(&self, n: hir::ItemLocalId) -> Option<CodeExtent> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n-    /// Records that `sub_fn` is defined within `sup_fn`. These ids\n+    /// Records that `sub_closure` is defined within `sup_closure`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n-    fn record_fn_parent(&mut self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n-        debug!(\"record_fn_parent(sub_fn={:?}, sup_fn={:?})\", sub_fn, sup_fn);\n-        assert!(sub_fn != sup_fn);\n-        let previous = self.fn_tree.insert(sub_fn, sup_fn);\n+    fn record_closure_parent(&mut self,\n+                             sub_closure: hir::ItemLocalId,\n+                             sup_closure: hir::ItemLocalId) {\n+        debug!(\"record_closure_parent(sub_closure={:?}, sup_closure={:?})\",\n+               sub_closure, sup_closure);\n+        assert!(sub_closure != sup_closure);\n+        let previous = self.closure_tree.insert(sub_closure, sup_closure);\n         assert!(previous.is_none());\n     }\n \n-    fn fn_is_enclosed_by(&self, mut sub_fn: ast::NodeId, sup_fn: ast::NodeId) -> bool {\n+    fn closure_is_enclosed_by(&self,\n+                              mut sub_closure: hir::ItemLocalId,\n+                              sup_closure: hir::ItemLocalId) -> bool {\n         loop {\n-            if sub_fn == sup_fn { return true; }\n-            match self.fn_tree.get(&sub_fn) {\n-                Some(&s) => { sub_fn = s; }\n+            if sub_closure == sup_closure { return true; }\n+            match self.closure_tree.get(&sub_closure) {\n+                Some(&s) => { sub_closure = s; }\n                 None => { return false; }\n             }\n         }\n     }\n \n-    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        assert!(var != lifetime.item_local_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: Option<CodeExtent>) {\n+    fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<CodeExtent>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         if let Some(lifetime) = lifetime {\n-            assert!(var != lifetime.node_id());\n+            assert!(var != lifetime.item_local_id());\n         }\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n@@ -376,14 +386,14 @@ impl<'tcx> RegionMaps {\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n+    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> CodeExtent {\n         match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -413,7 +423,7 @@ impl<'tcx> RegionMaps {\n         return None;\n     }\n \n-    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind {\n+    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n@@ -493,10 +503,10 @@ impl<'tcx> RegionMaps {\n             return match (a_root_scope, b_root_scope) {\n                 (CodeExtent::DestructionScope(a_root_id),\n                  CodeExtent::DestructionScope(b_root_id)) => {\n-                    if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n+                    if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n-                    } else if self.fn_is_enclosed_by(b_root_id, a_root_id) {\n+                    } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n                         // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n                         scope_a\n                     } else {\n@@ -561,20 +571,23 @@ impl<'tcx> RegionMaps {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let body_id = tcx.hir.maybe_body_owned_by(param_owner_id).unwrap_or_else(|| {\n+        let scope = tcx.hir.maybe_body_owned_by(param_owner_id).map(|body_id| {\n+            tcx.hir.body(body_id).value.hir_id.local_id\n+        }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n             // which in practice can only mean a trait or an impl, that\n             // is the parent of a method, and that is enforced below.\n             assert_eq!(Some(param_owner_id), self.root_parent,\n-                       \"free_extent: {:?} not recognized by the region maps for {:?}\",\n+                       \"free_extent: {:?} not recognized by the region maps for {:?} / {:?}\",\n                        param_owner,\n-                       self.root_body.map(|body| tcx.hir.body_owner_def_id(body)));\n+                       self.root_parent.map(|id| tcx.hir.local_def_id(id)),\n+                       self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n \n             // The trait/impl lifetime is in scope for the method's body.\n-            self.root_body.unwrap()\n+            self.root_body.unwrap().local_id\n         });\n \n-        CodeExtent::CallSiteScope(body_id)\n+        CodeExtent::CallSiteScope(scope)\n     }\n \n     /// Assuming that the provided region was defined within this `RegionMaps`,\n@@ -593,13 +606,20 @@ impl<'tcx> RegionMaps {\n         assert_eq!(param_owner, fr.scope);\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        CodeExtent::CallSiteScope(tcx.hir.body_owned_by(param_owner_id))\n+        let body_id = tcx.hir.body_owned_by(param_owner_id);\n+        CodeExtent::CallSiteScope(tcx.hir.body(body_id).value.hir_id.local_id)\n+    }\n+\n+    /// Checks whether the given code extent contains a `yield`. If so,\n+    /// returns `Some(span)` with the span of a yield we found.\n+    pub fn yield_in_scope(&self, scope: CodeExtent) -> Option<Span> {\n+        self.yield_in_scope.get(&scope).cloned()\n     }\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n-                       var_id: ast::NodeId,\n+                       var_id: hir::ItemLocalId,\n                        _sp: Span) {\n     match visitor.cx.var_parent {\n         None => {\n@@ -642,7 +662,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     // `other_argument()` has run and also the call to `quux(..)`\n     // itself has returned.\n \n-    visitor.enter_node_extent_with_dtor(blk.id);\n+    visitor.enter_node_extent_with_dtor(blk.hir_id.local_id);\n     visitor.cx.var_parent = visitor.cx.parent;\n \n     {\n@@ -661,7 +681,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // block itself as a parent.\n                 visitor.enter_code_extent(\n                     CodeExtent::Remainder(BlockRemainder {\n-                        block: blk.id,\n+                        block: blk.hir_id.local_id,\n                         first_statement_index: i as u32\n                     })\n                 );\n@@ -676,28 +696,28 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n }\n \n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    visitor.terminating_scopes.insert(arm.body.id);\n+    visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n     if let Some(ref expr) = arm.guard {\n-        visitor.terminating_scopes.insert(expr.id);\n+        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n     intravisit::walk_arm(visitor, arm);\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n-    visitor.record_code_extent(CodeExtent::Misc(pat.id));\n+    visitor.record_code_extent(CodeExtent::Misc(pat.hir_id.local_id));\n \n     // If this is a binding then record the lifetime of that binding.\n     if let PatKind::Binding(..) = pat.node {\n-        record_var_lifetime(visitor, pat.id, pat.span);\n+        record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n     }\n \n     intravisit::walk_pat(visitor, pat);\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = stmt.node.id();\n+    let stmt_id = visitor.tcx.hir.node_to_hir_id(stmt.node.id()).local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during\n@@ -719,11 +739,11 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let prev_cx = visitor.cx;\n-    visitor.enter_node_extent_with_dtor(expr.id);\n+    visitor.enter_node_extent_with_dtor(expr.hir_id.local_id);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n-        let mut terminating = |id: ast::NodeId| {\n+        let mut terminating = |id: hir::ItemLocalId| {\n             terminating_scopes.insert(id);\n         };\n         match expr.node {\n@@ -735,27 +755,27 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             hir::ExprBinary(codemap::Spanned { node: hir::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n-                terminating(r.id);\n+                terminating(r.hir_id.local_id);\n             }\n \n             hir::ExprIf(ref expr, ref then, Some(ref otherwise)) => {\n-                terminating(expr.id);\n-                terminating(then.id);\n-                terminating(otherwise.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(then.hir_id.local_id);\n+                terminating(otherwise.hir_id.local_id);\n             }\n \n             hir::ExprIf(ref expr, ref then, None) => {\n-                terminating(expr.id);\n-                terminating(then.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(then.hir_id.local_id);\n             }\n \n             hir::ExprLoop(ref body, _, _) => {\n-                terminating(body.id);\n+                terminating(body.hir_id.local_id);\n             }\n \n             hir::ExprWhile(ref expr, ref body, _) => {\n-                terminating(expr.id);\n-                terminating(body.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(body.hir_id.local_id);\n             }\n \n             hir::ExprMatch(..) => {\n@@ -784,6 +804,29 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 // record_superlifetime(new_cx, expr.callee_id);\n             }\n \n+            hir::ExprYield(..) => {\n+                // Mark this expr's scope and all parent scopes as containing `yield`.\n+                let mut scope = CodeExtent::Misc(expr.hir_id.local_id);\n+                loop {\n+                    match visitor.region_maps.yield_in_scope.entry(scope) {\n+                        // Another `yield` has already been found.\n+                        Entry::Occupied(_) => break,\n+\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(expr.span);\n+                        }\n+                    }\n+\n+                    // Keep traversing up while we can.\n+                    match visitor.region_maps.scope_map.get(&scope) {\n+                        // Don't cross from closure bodies to their parent.\n+                        Some(&CodeExtent::CallSiteScope(_)) => break,\n+                        Some(&superscope) => scope = superscope,\n+                        None => break\n+                    }\n+                }\n+            }\n+\n             _ => {}\n         }\n     }\n@@ -1014,7 +1057,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n             // because in trans if we must compile e.g. `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n-            visitor.region_maps.record_rvalue_scope(expr.id, blk_scope);\n+            visitor.region_maps.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.node {\n                 hir::ExprAddrOf(_, ref subexpr) |\n@@ -1046,7 +1089,7 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n         self.cx.parent = Some(child_scope);\n     }\n \n-    fn enter_node_extent_with_dtor(&mut self, id: ast::NodeId) {\n+    fn enter_node_extent_with_dtor(&mut self, id: hir::ItemLocalId) {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n         // account for the destruction scope representing the extent of\n@@ -1078,16 +1121,16 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n                self.cx.parent);\n \n         let outer_cx = self.cx;\n-        let outer_ts = mem::replace(&mut self.terminating_scopes, NodeSet());\n-        self.terminating_scopes.insert(body_id.node_id);\n+        let outer_ts = mem::replace(&mut self.terminating_scopes, FxHashSet());\n+        self.terminating_scopes.insert(body.value.hir_id.local_id);\n \n         if let Some(root_id) = self.cx.root_id {\n-            self.region_maps.record_fn_parent(body_id.node_id, root_id);\n+            self.region_maps.record_closure_parent(body.value.hir_id.local_id, root_id);\n         }\n-        self.cx.root_id = Some(body_id.node_id);\n+        self.cx.root_id = Some(body.value.hir_id.local_id);\n \n-        self.enter_code_extent(CodeExtent::CallSiteScope(body_id));\n-        self.enter_code_extent(CodeExtent::ParameterScope(body_id));\n+        self.enter_code_extent(CodeExtent::CallSiteScope(body.value.hir_id.local_id));\n+        self.enter_code_extent(CodeExtent::ParameterScope(body.value.hir_id.local_id));\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n@@ -1153,19 +1196,20 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n \n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let maps = if let Some(body) = tcx.hir.maybe_body_owned_by(id) {\n+    let maps = if let Some(body_id) = tcx.hir.maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n-            region_maps: RegionMaps::new(),\n+            region_maps: RegionMaps::default(),\n             cx: Context {\n                 root_id: None,\n                 parent: None,\n                 var_parent: None,\n             },\n-            terminating_scopes: NodeSet(),\n+            terminating_scopes: FxHashSet(),\n         };\n \n-        visitor.region_maps.root_body = Some(body);\n+        let body = tcx.hir.body(body_id);\n+        visitor.region_maps.root_body = Some(body.value.hir_id);\n \n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n@@ -1178,112 +1222,16 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             _ => {}\n         }\n \n-        visitor.visit_body(tcx.hir.body(body));\n+        visitor.visit_body(body);\n \n         visitor.region_maps\n     } else {\n-        RegionMaps::new()\n+        RegionMaps::default()\n     };\n \n     Rc::new(maps)\n }\n \n-struct YieldFinder<'a> {\n-    cache: &'a mut FxHashMap<NodeId, Option<Span>>,\n-    result: Option<Span>,\n-}\n-\n-impl<'a> YieldFinder<'a> {\n-    fn lookup<F: FnOnce(&mut Self)>(&mut self, id: NodeId, f: F) {\n-        // Don't traverse further if we found a yield expression\n-        if self.result.is_some() {\n-            return;\n-        }\n-\n-        // See if there's an entry in the cache\n-        if let Some(result) = self.cache.get(&id) {\n-            self.result = *result;\n-            return;\n-        }\n-\n-        // Otherwise calculate the result and insert it into the cache\n-        f(self);\n-        self.cache.insert(id, self.result);\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for YieldFinder<'a> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprYield(..) = expr.node {\n-            self.result = Some(expr.span);\n-            return;\n-        }\n-\n-        self.lookup(expr.id, |this| {\n-            intravisit::walk_expr(this, expr);\n-        });\n-    }\n-\n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        self.lookup(block.id, |this| {\n-            intravisit::walk_block(this, block);\n-        });\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Checks whether the given code extent contains a `yield`. If so,\n-    /// returns `Some(span)` with the span of a yield we found.\n-    pub fn yield_in_extent(self,\n-                          extent: CodeExtent,\n-                          cache: &mut FxHashMap<NodeId, Option<Span>>) -> Option<Span> {\n-        let mut finder = YieldFinder {\n-            cache,\n-            result: None,\n-        };\n-\n-        match extent {\n-            CodeExtent::DestructionScope(node_id) |\n-            CodeExtent::Misc(node_id) => {\n-                match self.hir.get(node_id) {\n-                    Node::NodeItem(_) |\n-                    Node::NodeTraitItem(_) |\n-                    Node::NodeImplItem(_) => {\n-                        let body = self.hir.body(self.hir.body_owned_by(node_id));\n-                        finder.visit_body(body);\n-                    }\n-                    Node::NodeExpr(expr) => finder.visit_expr(expr),\n-                    Node::NodeStmt(stmt) => finder.visit_stmt(stmt),\n-                    Node::NodeBlock(block) => finder.visit_block(block),\n-                    _ => bug!(),\n-                }\n-            }\n-\n-            CodeExtent::CallSiteScope(body_id) |\n-            CodeExtent::ParameterScope(body_id) => {\n-                finder.visit_body(self.hir.body(body_id))\n-            }\n-\n-            CodeExtent::Remainder(r) => {\n-                if let Node::NodeBlock(block) = self.hir.get(r.block) {\n-                    for stmt in &block.stmts[(r.first_statement_index as usize + 1)..] {\n-                        finder.visit_stmt(stmt);\n-                    }\n-                    block.expr.as_ref().map(|e| finder.visit_expr(e));\n-                } else {\n-                    bug!()\n-                }\n-            }\n-        }\n-\n-        finder.result\n-    }\n-}\n-\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         region_maps,"}, {"sha": "35ca8eb14228379563fed15283de2c720f9d6347", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -532,7 +532,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n             predicates);\n \n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(region_context, &region_maps, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {"}, {"sha": "1851e1b8d34bbe595469f394cfe04c43104ddd9b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -23,7 +23,6 @@ use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n-use middle::region::CodeExtent;\n use mir::Mir;\n use mir::GeneratorLayout;\n use traits;\n@@ -2309,10 +2308,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n-        self.mk_region(ty::ReScope(CodeExtent::Misc(id)))\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "2f5f31e0f63bc8c8646ba3427c4e459948263216", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::BodyId;\n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n use middle::region::{CodeExtent, BlockRemainder};\n@@ -527,16 +526,16 @@ impl fmt::Display for ty::RegionKind {\n             }\n             ty::ReScope(code_extent) if identify_regions() => {\n                 match code_extent {\n-                    CodeExtent::Misc(node_id) =>\n-                        write!(f, \"'{}mce\", node_id.as_u32()),\n-                    CodeExtent::CallSiteScope(BodyId { node_id }) =>\n-                        write!(f, \"'{}cce\", node_id.as_u32()),\n-                    CodeExtent::ParameterScope(BodyId { node_id }) =>\n-                        write!(f, \"'{}pce\", node_id.as_u32()),\n-                    CodeExtent::DestructionScope(node_id) =>\n-                        write!(f, \"'{}dce\", node_id.as_u32()),\n+                    CodeExtent::Misc(id) =>\n+                        write!(f, \"'{}mce\", id.as_usize()),\n+                    CodeExtent::CallSiteScope(id) =>\n+                        write!(f, \"'{}cce\", id.as_usize()),\n+                    CodeExtent::ParameterScope(id) =>\n+                        write!(f, \"'{}pce\", id.as_usize()),\n+                    CodeExtent::DestructionScope(id) =>\n+                        write!(f, \"'{}dce\", id.as_usize()),\n                     CodeExtent::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rce\", block, first_statement_index),\n+                        write!(f, \"'{}_{}rce\", block.as_usize(), first_statement_index),\n                 }\n             }\n             ty::ReVar(region_vid) if identify_regions() => {"}, {"sha": "7f31c53e63caf70ccc772d7360e3731447415acc", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n-        self.each_issued_loan(self.tcx().hir.node_to_hir_id(scope.node_id()).local_id, |loan| {\n+        self.each_issued_loan(scope.item_local_id(), |loan| {\n             if self.bccx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n@@ -467,7 +467,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                self.tcx().hir.span(old_loan.kill_scope.node_id()).end_point();\n+                old_loan.kill_scope.span(self.tcx(), &self.bccx.region_maps).end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n@@ -713,12 +713,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         let mut ret = UseOk;\n \n-        let node_id = self.tcx().hir.hir_to_node_id(hir::HirId {\n-            owner: self.tcx().closure_base_def_id(self.bccx.owner_def_id).index,\n-            local_id: expr_id\n-        });\n         self.each_in_scope_loan_affecting_path(\n-            region::CodeExtent::Misc(node_id), use_path, |loan| {\n+            region::CodeExtent::Misc(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -837,11 +833,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let node_id = self.tcx().hir.hir_to_node_id(hir::HirId {\n-                owner: self.tcx().closure_base_def_id(self.bccx.owner_def_id).index,\n-                local_id: assignment_id\n-            });\n-            let scope = region::CodeExtent::Misc(node_id);\n+            let scope = region::CodeExtent::Misc(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "461f1d6a43283930a7addae2b77a0bb1e737de27", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -115,8 +115,9 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n             Categorization::Local(local_id) => {\n+                let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n                 self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.region_maps.var_scope(local_id)))\n+                    self.bccx.region_maps.var_scope(hir_id.local_id)))\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(_, mc::UnsafePtr(..)) => {"}, {"sha": "5689a30fd38c0c26b82ea614b3d780ecd0bb4bab", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -43,7 +43,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let mut glcx = GatherLoanCtxt {\n         bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::CodeExtent::Misc(body.node_id),\n+        item_ub: region::CodeExtent::Misc(bccx.tcx.hir.body(body).value.hir_id.local_id),\n         move_data: MoveData::default(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -126,7 +126,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        self.guarantee_valid(borrow_id,\n+        let hir_id = self.bccx.tcx.hir.node_to_hir_id(borrow_id);\n+        self.guarantee_valid(hir_id.local_id,\n                              borrow_span,\n                              cmt,\n                              bk,\n@@ -291,13 +292,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     /// reports an error.  This may entail taking out loans, which will be added to the\n     /// `req_loan_map`.\n     fn guarantee_valid(&mut self,\n-                       borrow_id: ast::NodeId,\n+                       borrow_id: hir::ItemLocalId,\n                        borrow_span: Span,\n                        cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region<'tcx>,\n                        cause: euv::LoanCause) {\n-        debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n+        debug!(\"guarantee_valid(borrow_id={:?}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt,\n@@ -396,7 +397,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id={}), loan={:?}\",\n+        debug!(\"guarantee_valid(borrow_id={:?}), loan={:?}\",\n                borrow_id, loan);\n \n         // let loan_path = loan.loan_path;"}, {"sha": "25aac92c13d8572773e07dd7455c7a923dc1e838", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -36,7 +36,6 @@ use rustc::middle::region::{self, RegionMaps};\n use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::util::nodemap::FxHashMap;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::fmt;\n@@ -167,10 +166,9 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(this.tcx.hir.node_to_hir_id(loan.gen_scope.node_id()).local_id,\n-                          loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.item_local_id(), loan_idx);\n         loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           this.tcx.hir.node_to_hir_id(loan.kill_scope.node_id()).local_id,\n+                           loan.kill_scope.item_local_id(),\n                            loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n@@ -366,10 +364,14 @@ fn closure_to_block(closure_id: DefIndex,\n impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n-            LpVar(local_id) => bccx.region_maps.var_scope(local_id),\n+            LpVar(local_id) => {\n+                let hir_id = bccx.tcx.hir.node_to_hir_id(local_id);\n+                bccx.region_maps.var_scope(hir_id.local_id)\n+            }\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                region::CodeExtent::Misc(block_id)\n+                let hir_id = bccx.tcx.hir.node_to_hir_id(block_id);\n+                region::CodeExtent::Misc(hir_id.local_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(bccx),\n@@ -643,7 +645,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         // Get type of value and span where it was previously\n         // moved.\n         let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n-            owner: self.tcx.closure_base_def_id(self.owner_def_id).index,\n+            owner: self.body.value.hir_id.owner,\n             local_id: the_move.id\n         });\n         let (move_span, move_note) = match the_move.kind {\n@@ -818,7 +820,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 debug!(\"err_out_of_scope: self.body.is_generator = {:?}\",\n                        self.body.is_generator);\n                 let maybe_borrow_across_yield = if self.body.is_generator {\n-                    let body_extent = region::CodeExtent::Misc(self.body.id().node_id);\n+                    let body_extent = region::CodeExtent::Misc(self.body.value.hir_id.local_id);\n                     debug!(\"err_out_of_scope: body_extent = {:?}\", body_extent);\n                     debug!(\"err_out_of_scope: super_scope = {:?}\", super_scope);\n                     debug!(\"err_out_of_scope: sub_scope = {:?}\", sub_scope);\n@@ -844,7 +846,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                 // block remainder that starts with\n                                 // `let a`) for a yield. We can cite\n                                 // that for the user.\n-                                self.tcx.yield_in_extent(value_extent, &mut FxHashMap())\n+                                self.region_maps.yield_in_scope(value_extent)\n                             } else {\n                                 None\n                             }\n@@ -966,8 +968,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n-                    db.note(\"consider using a `let` binding to increase its lifetime\");\n+                if let ty::ReScope(scope) = *super_scope {\n+                    let node_id = scope.node_id(self.tcx, &self.region_maps);\n+                    match self.tcx.hir.find(node_id) {\n+                        Some(hir_map::NodeStmt(_)) => {\n+                            db.note(\"consider using a `let` binding to increase its lifetime\");\n+                        }\n+                        _ => {}\n+                    }\n                 }\n \n                 db.emit();\n@@ -1386,18 +1394,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n-    match *region {\n-        ty::ReScope(scope) => {\n-            match tcx.hir.find(scope.node_id()) {\n-                Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),\n-                _ => None\n-            }\n-        }\n-        _ => None\n-    }\n-}\n-\n impl BitwiseOperator for LoanDataFlowOperator {\n     #[inline]\n     fn join(&self, succ: usize, pred: usize) -> usize {"}, {"sha": "7915eccbf74451cc447b6d779d949979b03250f2", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -485,8 +485,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(bccx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path,\n-                                    bccx.tcx.hir.node_to_hir_id(kill_scope.node_id()).local_id,\n+                    self.kill_moves(path, kill_scope.item_local_id(),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -501,8 +500,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(bccx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         bccx.tcx.hir.node_to_hir_id(kill_scope.node_id())\n-                                            .local_id,\n+                                         kill_scope.item_local_id(),\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {"}, {"sha": "247f51b1da4437ee4a8c785a307428f97a17a687", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -50,7 +50,7 @@ struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n struct RH<'a> {\n-    id: ast::NodeId,\n+    id: hir::ItemLocalId,\n     sub: &'a [RH<'a>],\n }\n \n@@ -157,7 +157,7 @@ fn test_env<F>(source_string: &str,\n                              \"test_crate\",\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n-            let mut region_maps = RegionMaps::new();\n+            let mut region_maps = RegionMaps::default();\n             body(Env {\n                 infcx: &infcx,\n                 region_maps: &mut region_maps,\n@@ -188,21 +188,19 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n \n-        let node = ast::NodeId::from_u32;\n-        let dscope = CodeExtent::DestructionScope(node(1));\n+        let dscope = CodeExtent::DestructionScope(hir::ItemLocalId(1));\n         self.region_maps.record_code_extent(dscope, None);\n         self.create_region_hierarchy(&RH {\n-                                         id: node(1),\n-                                         sub: &[RH {\n-                                                    id: node(10),\n-                                                    sub: &[],\n-                                                },\n-                                                RH {\n-                                                    id: node(11),\n-                                                    sub: &[],\n-                                                }],\n-                                     },\n-                                     dscope);\n+            id: hir::ItemLocalId(1),\n+            sub: &[RH {\n+                id: hir::ItemLocalId(10),\n+                sub: &[],\n+            },\n+            RH {\n+                id: hir::ItemLocalId(11),\n+                sub: &[],\n+            }],\n+        }, dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -335,7 +333,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(CodeExtent::Misc(ast::NodeId::from_u32(id)));\n+        let r = ty::ReScope(CodeExtent::Misc(hir::ItemLocalId(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n "}, {"sha": "52b645638b86f37377a2829c9e2c729af1036500", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -854,7 +854,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             let local_id = cfg.graph.node_data(idx).id();\n             if local_id != hir::DUMMY_ITEM_LOCAL_ID {\n                 let node_id = cx.tcx.hir.hir_to_node_id(hir::HirId {\n-                    owner: cx.tcx.closure_base_def_id(cfg.owner_def_id).index,\n+                    owner: body.value.hir_id.owner,\n                     local_id\n                 });\n                 let self_recursive = match method {"}, {"sha": "fc6eca466a811b43015bccc7886f15a062f42e3d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -202,7 +202,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n-        let extent = self.hir.region_maps.var_scope(var);\n+        let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n+        let extent = self.hir.region_maps.var_scope(hir_id.local_id);\n         self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n     }\n "}, {"sha": "5cced32f7e69bae9f2b94c33ababc0577cdba52b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -355,8 +355,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         arguments.len(),\n         return_ty);\n \n-    let call_site_extent = CodeExtent::CallSiteScope(body.id());\n-    let arg_extent = CodeExtent::ParameterScope(body.id());\n+    let call_site_extent = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n+    let arg_extent = CodeExtent::ParameterScope(body.value.hir_id.local_id);\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     unpack!(block = builder.in_scope((call_site_extent, source_info), block, |builder| {"}, {"sha": "8a87751d846c8922446a65ff615f769a254e06d4", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -13,19 +13,18 @@ use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{BlockRemainder, CodeExtent};\n use rustc::hir;\n-use syntax::ast;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n-        let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n-        let opt_destruction_extent = cx.region_maps.opt_destruction_extent(self.id);\n+        let stmts = mirror_stmts(cx, self.hir_id.local_id, &*self.stmts);\n+        let opt_destruction_extent = cx.region_maps.opt_destruction_extent(self.hir_id.local_id);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: CodeExtent::Misc(self.id),\n+            extent: CodeExtent::Misc(self.hir_id.local_id),\n             opt_destruction_extent,\n             span: self.span,\n             stmts,\n@@ -35,24 +34,25 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n }\n \n fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                block_id: ast::NodeId,\n+                                block_id: hir::ItemLocalId,\n                                 stmts: &'tcx [hir::Stmt])\n                                 -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n-        let opt_dxn_ext = cx.region_maps.opt_destruction_extent(stmt.node.id());\n+        let hir_id = cx.tcx.hir.node_to_hir_id(stmt.node.id());\n+        let opt_dxn_ext = cx.region_maps.opt_destruction_extent(hir_id.local_id);\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) |\n-            hir::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, _) |\n+            hir::StmtSemi(ref expr, _) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     kind: StmtKind::Expr {\n-                        scope: CodeExtent::Misc(id),\n+                        scope: CodeExtent::Misc(hir_id.local_id),\n                         expr: expr.to_ref(),\n                     },\n                     opt_destruction_extent: opt_dxn_ext,\n                 })))\n             }\n-            hir::StmtDecl(ref decl, id) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     hir::DeclItem(..) => {\n                         // ignore for purposes of the MIR\n@@ -70,7 +70,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n-                                init_scope: CodeExtent::Misc(id),\n+                                init_scope: CodeExtent::Misc(hir_id.local_id),\n                                 pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n@@ -88,7 +88,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.hir_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(block.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(block.hir_id.local_id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime,"}, {"sha": "a877c61a47a912b35531d310e24c8a054cee789a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -25,8 +25,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let temp_lifetime = cx.region_maps.temporary_scope(self.id);\n-        let expr_extent = CodeExtent::Misc(self.id);\n+        let temp_lifetime = cx.region_maps.temporary_scope(self.hir_id.local_id);\n+        let expr_extent = CodeExtent::Misc(self.hir_id.local_id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -52,7 +52,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.id) {\n+        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.hir_id.local_id) {\n             expr = Expr {\n                 temp_lifetime,\n                 ty: expr.ty,\n@@ -125,7 +125,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // Convert this to a suitable `&foo` and\n             // then an unsafe coercion. Limit the region to be just this\n             // expression.\n-            let region = ty::ReScope(CodeExtent::Misc(hir_expr.id));\n+            let region = ty::ReScope(CodeExtent::Misc(hir_expr.hir_id.local_id));\n             let region = cx.tcx.mk_region(region);\n             expr = Expr {\n                 temp_lifetime,\n@@ -160,7 +160,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -487,7 +487,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: CodeExtent::Misc(target_id),\n+                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -498,7 +498,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: CodeExtent::Misc(loop_id),\n+                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -585,7 +585,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n                                  -> Expr<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n         (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n@@ -676,7 +676,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -867,7 +867,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n     let fun = method_callee(cx, expr, custom_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n@@ -896,7 +896,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.hir_id.local_id);\n     let var_ty = cx.tables()\n                    .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n     let captured_var = Expr {"}, {"sha": "a4bbedfb26b3874036b07693b7b3cf33ab6f57bc", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -340,7 +340,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // region obligations that get overlooked.  The right\n             // thing to do is the code below. But we keep this old\n             // pass around temporarily.\n-            let region_maps = RegionMaps::new();\n+            let region_maps = RegionMaps::default();\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n             infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);"}, {"sha": "fd7dd052cd16d524cf99daf90fdef0bbe29e3dbb", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -114,7 +114,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             return Err(ErrorReported);\n         }\n \n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(drop_impl_did, &region_maps, &free_regions);\n         Ok(())"}, {"sha": "60762134f0ffd884920c38c397bf9b2a57e6e46b", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -18,15 +18,12 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Body, Pat, PatKind, Expr};\n use rustc::middle::region::{RegionMaps, CodeExtent};\n use rustc::ty::Ty;\n-use syntax::ast::NodeId;\n-use syntax::codemap::Span;\n use std::rc::Rc;\n use super::FnCtxt;\n use util::nodemap::FxHashMap;\n \n struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    cache: FxHashMap<NodeId, Option<Span>>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_maps: Rc<RegionMaps>,\n }\n@@ -36,7 +33,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n         use syntax_pos::DUMMY_SP;\n \n         let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.fcx.tcx.yield_in_extent(s, &mut self.cache)\n+            self.region_maps.yield_in_scope(s)\n         });\n \n         if let Some(span) = live_across_yield {\n@@ -62,7 +59,6 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap(),\n-        cache: FxHashMap(),\n         region_maps: fcx.tcx.region_maps(def_id),\n     };\n     intravisit::walk_body(&mut visitor, body);\n@@ -97,7 +93,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         if let PatKind::Binding(..) = pat.node {\n-            let scope = self.region_maps.var_scope(pat.id);\n+            let scope = self.region_maps.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None);\n         }\n@@ -106,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        let scope = self.region_maps.temporary_scope(expr.id);\n+        let scope = self.region_maps.temporary_scope(expr.hir_id.local_id);\n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n         self.record(ty, scope, Some(expr));\n "}, {"sha": "2fa80a10d12e48929b44a7007cee197c7d713816", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -606,8 +606,9 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir.as_local_node_id(def_id);\n         let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n-        let implicit_region_bound = body_id.map(|body| {\n-            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body)))\n+        let implicit_region_bound = body_id.map(|body_id| {\n+            let body = tcx.hir.body(body_id);\n+            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body.value.hir_id.local_id)))\n         });\n \n         Inherited {"}, {"sha": "0cd38a49adef206772a6fc4851ad8772f4a30bc5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = CodeExtent::CallSiteScope(body_id);\n+        let call_site = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(CodeExtent::Misc(body_id.node_id), &body.arguments);\n+        self.link_fn_args(CodeExtent::Misc(body.value.hir_id.local_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -610,11 +610,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // that the lifetime of any regions that appear in a\n             // variable's type enclose at least the variable's scope.\n \n-            let var_scope = self.region_maps.var_scope(id);\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let var_scope = self.region_maps.var_scope(hir_id.local_id);\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            let hir_id = self.tcx.hir.node_to_hir_id(id);\n             self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n             let typ = self.resolve_node_type(hir_id);\n@@ -668,7 +668,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n-        let expr_region = self.tcx.node_scope_region(expr.id);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n@@ -950,7 +950,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = CodeExtent::Misc(call_expr.id);\n+        let callee_scope = CodeExtent::Misc(call_expr.hir_id.local_id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -1002,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // expression.\n         self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n \n-        let expr_region = self.tcx.node_scope_region(expr.id);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n         for adjustment in adjustments {\n             debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n                    adjustment, cmt);\n@@ -1095,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.id));\n+        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.hir_id.local_id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1232,7 +1232,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                let r = self.tcx.node_scope_region(expr.id);\n+                let r = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n         }"}, {"sha": "9cf15e2145d36ff811b202b43b817b98cf17c0ab", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -390,7 +390,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Finally, resolve all regions.\n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let mut free_regions = FreeRegionMap::new();\n         free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n         infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);"}, {"sha": "7be677c184b735a9478bbc7e9b6d86ed55afb18a", "filename": "src/test/mir-opt/end_region_1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_1.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -22,16 +22,16 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _1: i32;\n-//     let _2: &'6_1rce i32;\n+//     let _2: &'10_1rce i32;\n //\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const 3i32;\n //         StorageLive(_2);\n-//         _2 = &'6_1rce _1;\n+//         _2 = &'10_1rce _1;\n //         _0 = ();\n //         StorageDead(_2);\n-//         EndRegion('6_1rce);\n+//         EndRegion('10_1rce);\n //         StorageDead(_1);\n //         return;\n //     }"}, {"sha": "2cb9b38e7bb94928390385e5b2d9c2abb88393e8", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -27,8 +27,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _2: bool;\n-//     let _3: &'7_1rce bool;\n-//     let _7: &'7_3rce bool;\n+//     let _3: &'23_1rce bool;\n+//     let _7: &'23_3rce bool;\n //     let mut _4: ();\n //     let mut _5: bool;\n //     bb0: {\n@@ -38,7 +38,7 @@ fn main() {\n //         StorageLive(_2);\n //         _2 = const true;\n //         StorageLive(_3);\n-//         _3 = &'7_1rce _2;\n+//         _3 = &'23_1rce _2;\n //         StorageLive(_5);\n //         _5 = _2;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -47,19 +47,19 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('7_1rce);\n+//         EndRegion('23_1rce);\n //         StorageDead(_2);\n //         return;\n //     }\n //     bb3: {\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'7_3rce _2;\n+//         _7 = &'23_3rce _2;\n //         _1 = ();\n //         StorageDead(_7);\n-//         EndRegion('7_3rce);\n+//         EndRegion('23_3rce);\n //         StorageDead(_3);\n-//         EndRegion('7_1rce);\n+//         EndRegion('23_1rce);\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }"}, {"sha": "001bb9c1a02849749695657b121e35df195e4557", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -28,8 +28,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let mut _1: bool;\n-//     let _3: &'9_1rce bool;\n-//     let _7: &'9_3rce bool;\n+//     let _3: &'26_1rce bool;\n+//     let _7: &'26_3rce bool;\n //     let mut _2: ();\n //     let mut _4: ();\n //     let mut _5: bool;\n@@ -41,7 +41,7 @@ fn main() {\n //     bb1: {\n //         _1 = const true;\n //         StorageLive(_3);\n-//         _3 = &'9_1rce _1;\n+//         _3 = &'26_1rce _1;\n //         StorageLive(_5);\n //         _5 = _1;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -50,20 +50,20 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('9_1rce);\n+//         EndRegion('26_1rce);\n //         StorageDead(_1);\n //         return;\n //     }\n //     bb3: {\n //         _4 = ();\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'9_3rce _1;\n+//         _7 = &'26_3rce _1;\n //         _2 = ();\n //         StorageDead(_7);\n-//         EndRegion('9_3rce);\n+//         EndRegion('26_3rce);\n //         StorageDead(_3);\n-//         EndRegion('9_1rce);\n+//         EndRegion('26_1rce);\n //         goto -> bb1;\n //     }\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "8c854ce87a2c6b100b2e398f73190633b420aa72", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -33,8 +33,8 @@ fn foo(i: i32) {\n //     let mut _0: ();\n //     let _1: D;\n //     let _2: i32;\n-//     let _3: &'6_2rce i32;\n-//     let _6: &'6_4rce i32;\n+//     let _3: &'26_2rce i32;\n+//     let _6: &'26_4rce i32;\n //     let mut _4: ();\n //     let mut _5: i32;\n //     bb0: {\n@@ -43,28 +43,28 @@ fn foo(i: i32) {\n //         StorageLive(_2);\n //         _2 = const 0i32;\n //         StorageLive(_3);\n-//         _3 = &'6_2rce _2;\n+//         _3 = &'26_2rce _2;\n //         StorageLive(_5);\n //         _5 = (*_3);\n //         _4 = const foo(_5) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_5);\n //         StorageLive(_6);\n-//         _6 = &'6_4rce _2;\n+//         _6 = &'26_4rce _2;\n //         _0 = ();\n //         StorageDead(_6);\n-//         EndRegion('6_4rce);\n+//         EndRegion('26_4rce);\n //         StorageDead(_3);\n-//         EndRegion('6_2rce);\n+//         EndRegion('26_2rce);\n //         StorageDead(_2);\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('6_2rce);\n+//         EndRegion('26_2rce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {"}, {"sha": "ae1b4e2e83abb9ed22d052a6f4b73e1f2edb9859", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(18) d:&'19mce D];\n-//     let mut _4: &'19mce D;\n+//     let mut _3: [closure@NodeId(18) d:&'14mce D];\n+//     let mut _4: &'14mce D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'19mce _1;\n+//         _4 = &'14mce _1;\n //         _3 = [closure@NodeId(18)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('19mce);\n+//         EndRegion('14mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('19mce);\n+//         EndRegion('14mce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -64,13 +64,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node18.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'19mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'14mce D]) -> i32 {\n //    let mut _0: i32;\n //    let mut _2: i32;\n //\n //    bb0: {\n //        StorageLive(_2);\n-//        _2 = ((*(_1.0: &'19mce D)).0: i32);\n+//        _2 = ((*(_1.0: &'14mce D)).0: i32);\n //        _0 = _2;\n //        StorageDead(_2);\n //        return;"}, {"sha": "8054b64400669c05f5cebf9d4a920ec6a612b1b9", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(22) d:&'23mce D];\n-//     let mut _4: &'23mce D;\n+//     let mut _3: [closure@NodeId(22) d:&'19mce D];\n+//     let mut _4: &'19mce D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'23mce _1;\n+//         _4 = &'19mce _1;\n //         _3 = [closure@NodeId(22)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('23mce);\n+//         EndRegion('19mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('23mce);\n+//         EndRegion('19mce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -63,20 +63,20 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'23mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'19mce D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'14_0rce D;\n+//     let _2: &'15_0rce D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'14_0rce (*(_1.0: &'23mce D));\n+//         _2 = &'15_0rce (*(_1.0: &'19mce D));\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('14_0rce);\n+//         EndRegion('15_0rce);\n //         return;\n //     }\n // END rustc.node22.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "d68439087615b93d80361aea7f3e32bce5d9b10b", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -74,18 +74,18 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(22) d:D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'14_0rce D;\n+//     let _2: &'15_0rce D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'14_0rce (_1.0: D);\n+//         _2 = &'15_0rce (_1.0: D);\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('14_0rce);\n+//         EndRegion('15_0rce);\n //         drop(_1) -> bb1;\n //     }\n //     bb1: {"}, {"sha": "8d7050941e7ebfe060b9bc8ebce967d544aae4ac", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -31,15 +31,15 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // fn main() -> () {\n //    let mut _0: ();\n //    let _1: D;\n-//    let _2: &'6_1rce D;\n+//    let _2: &'21_1rce D;\n //    let mut _3: ();\n-//    let mut _4: [closure@NodeId(22) r:&'6_1rce D];\n-//    let mut _5: &'6_1rce D;\n+//    let mut _4: [closure@NodeId(22) r:&'21_1rce D];\n+//    let mut _5: &'21_1rce D;\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);\n //        StorageLive(_2);\n-//        _2 = &'6_1rce _1;\n+//        _2 = &'21_1rce _1;\n //        StorageLive(_4);\n //        StorageLive(_5);\n //        _5 = _2;\n@@ -51,14 +51,14 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //        StorageDead(_4);\n //        _0 = ();\n //        StorageDead(_2);\n-//        EndRegion('6_1rce);\n+//        EndRegion('21_1rce);\n //        drop(_1) -> bb4;\n //    }\n //    bb2: {\n //        resume;\n //    }\n //    bb3: {\n-//        EndRegion('6_1rce);\n+//        EndRegion('21_1rce);\n //        drop(_1) -> bb2;\n //    }\n //    bb4: {\n@@ -69,13 +69,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'6_1rce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'21_1rce D]) -> i32 {\n //     let mut _0: i32;\n //     let mut _2: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = ((*(_1.0: &'6_1rce D)).0: i32);\n+//         _2 = ((*(_1.0: &'21_1rce D)).0: i32);\n //         _0 = _2;\n //         StorageDead(_2);\n //         return;"}, {"sha": "9c528da8b348dda7bc3481a2f9dbada0a6a1e120", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -37,19 +37,19 @@ fn main() {\n // START rustc.node23.EraseRegions.after.mir\n // fn main() -> () {\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [_1: i32]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [_1: i32]);\n //         _6 = &ReErased mut _1;\n-//         Validate(Acquire, [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n-//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n+//         Validate(Acquire, [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n //         _5 = &ReErased mut (*_6);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(34)))]);\n-//         Validate(Release, [_2: (), _3: &ReScope(Misc(NodeId(34))) Test, _5: &ReScope(Misc(NodeId(34))) mut i32]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(10)))]);\n+//         Validate(Release, [_2: (), _3: &ReScope(Misc(ItemLocalId(10))) Test, _5: &ReScope(Misc(ItemLocalId(10))) mut i32]);\n //         _2 = const Test::foo(_3, _5) -> bb1;\n //     }\n //\n //     bb1: {\n //         Validate(Acquire, [_2: ()]);\n-//         EndRegion(ReScope(Misc(NodeId(34))));\n+//         EndRegion(ReScope(Misc(ItemLocalId(10))));\n //         return;\n //     }\n // }\n@@ -61,15 +61,15 @@ fn main() {\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);\n-//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 }))), [(*_3): i32]);\n+//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 }))), [(*_3): i32]);\n //         _4 = &ReErased (*_3);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 })) (imm)]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })) (imm)]);\n //         StorageLive(_5);\n //         _5 = (*_4);\n //         _0 = _5;\n //         StorageDead(_5);\n //         StorageDead(_4);\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 })));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })));\n //         StorageDead(_3);\n //         return;\n //     }"}, {"sha": "cd556564b7913d39bfaf8fc6e073f46044b279e3", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -32,18 +32,18 @@ fn main() {\n // fn main() -> () {\n //     let mut _5: &ReErased i32;\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n-//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n //         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Misc(NodeId(46))) (imm)]);\n-//         Validate(Release, [_3: (), _4: &ReScope(Misc(NodeId(46))) i32]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Misc(ItemLocalId(17))) i32]);\n //         _3 = const foo(_4) -> bb1;\n //     }\n //     bb1: {\n-//         EndRegion(ReScope(Misc(NodeId(46))));\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })));\n+//         EndRegion(ReScope(Misc(ItemLocalId(17))));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })));\n //         return;\n //     }\n // }"}, {"sha": "224f4ce2effe3294cd47269c84c8a74c1311ed95", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4996ec49c832610f3044f49437b16527f2a726f/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=e4996ec49c832610f3044f49437b16527f2a726f", "patch": "@@ -50,12 +50,12 @@ fn main() {\n //         _3 = _2;\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Misc(NodeId(44)))), [(*_3): i32]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(9)))), [(*_3): i32]);\n //         _5 = &ReErased mut (*_3);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(44)))]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(9)))]);\n //         _4 = _5 as *mut i32 (Misc);\n //         StorageDead(_5);\n-//         EndRegion(ReScope(Misc(NodeId(44))));\n+//         EndRegion(ReScope(Misc(ItemLocalId(9))));\n //         Validate(Release, [_0: bool, _4: *mut i32]);\n //         _0 = const write_42(_4) -> bb1;\n //     }"}]}