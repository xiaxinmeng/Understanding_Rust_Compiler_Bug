{"sha": "653406fcf78aff6bfc4a7c025a8176919d708565", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MzQwNmZjZjc4YWZmNmJmYzRhN2MwMjVhODE3NjkxOWQ3MDg1NjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-03T19:26:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "uv: Remove closure-based home_for_io for raii\n\nUsing an raii wrapper means that there's no need for a '_self' variant and we\ncan greatly reduce the amount of 'self_'-named variables.", "tree": {"sha": "f20b562054685333193866716cff61d5c5d141c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f20b562054685333193866716cff61d5c5d141c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653406fcf78aff6bfc4a7c025a8176919d708565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653406fcf78aff6bfc4a7c025a8176919d708565", "html_url": "https://github.com/rust-lang/rust/commit/653406fcf78aff6bfc4a7c025a8176919d708565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653406fcf78aff6bfc4a7c025a8176919d708565/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bcde6bc068b8962d368fc70bd68cb21f5d1013c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bcde6bc068b8962d368fc70bd68cb21f5d1013c", "html_url": "https://github.com/rust-lang/rust/commit/4bcde6bc068b8962d368fc70bd68cb21f5d1013c"}], "stats": {"total": 711, "additions": 326, "deletions": 385}, "files": [{"sha": "bf8358070dcdf9e7572f9a909fd59d2f2893fe91", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 326, "deletions": 385, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/653406fcf78aff6bfc4a7c025a8176919d708565/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653406fcf78aff6bfc4a7c025a8176919d708565/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=653406fcf78aff6bfc4a7c025a8176919d708565", "patch": "@@ -86,12 +86,39 @@ trait HomingIO {\n         self.home().sched_id\n     }\n \n-    // XXX: dummy self parameter\n-    fn restore_original_home(_: Option<Self>, io_home: uint) {\n+    /// Fires a single homing missile, returning another missile targeted back\n+    /// at the original home of this task. In other words, this function will\n+    /// move the local task to its I/O scheduler and then return an RAII wrapper\n+    /// which will return the task home.\n+    fn fire_homing_missile(&mut self) -> HomingMissile {\n+        HomingMissile { io_home: self.go_to_IO_home() }\n+    }\n+\n+    /// Same as `fire_homing_missile`, but returns the local I/O scheduler as\n+    /// well (the one that was homed to).\n+    fn fire_homing_missile_sched(&mut self) -> (HomingMissile, ~Scheduler) {\n+        // First, transplant ourselves to the home I/O scheduler\n+        let missile = self.fire_homing_missile();\n+        // Next (must happen next), grab the local I/O scheduler\n+        let io_sched: ~Scheduler = Local::take();\n+\n+        (missile, io_sched)\n+    }\n+}\n+\n+/// After a homing operation has been completed, this will return the current\n+/// task back to its appropriate home (if applicable). The field is used to\n+/// assert that we are where we think we are.\n+struct HomingMissile {\n+    priv io_home: uint,\n+}\n+\n+impl Drop for HomingMissile {\n+    fn drop(&mut self) {\n         // It would truly be a sad day if we had moved off the home I/O\n         // scheduler while we were doing I/O.\n         assert_eq!(Local::borrow(|sched: &mut Scheduler| sched.sched_id()),\n-                   io_home);\n+                   self.io_home);\n \n         // If we were a homed task, then we must send ourselves back to the\n         // original scheduler. Otherwise, we can just return and keep running\n@@ -106,30 +133,6 @@ trait HomingIO {\n             }\n         }\n     }\n-\n-    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n-        let home = self.go_to_IO_home();\n-        let a = io(self); // do IO\n-        HomingIO::restore_original_home(None::<Self>, home);\n-        a // return the result of the IO\n-    }\n-\n-    fn home_for_io_consume<A>(mut self, io: &fn(Self) -> A) -> A {\n-        let home = self.go_to_IO_home();\n-        let a = io(self); // do IO\n-        HomingIO::restore_original_home(None::<Self>, home);\n-        a // return the result of the IO\n-    }\n-\n-    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n-        let home = self.go_to_IO_home();\n-        let a = do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            io_sched(self, scheduler) // do IO and scheduling action\n-        };\n-        HomingIO::restore_original_home(None::<Self>, home);\n-        a // return result of IO\n-    }\n }\n \n // get a handle for the current scheduler\n@@ -915,52 +918,49 @@ impl UvTcpListener {\n \n impl Drop for UvTcpListener {\n     fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task = Cell::new(task);\n-                do self_.watcher.as_stream().close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task.take());\n-                }\n+        let (_m, sched) = self.fire_homing_missile_sched();\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            let task = Cell::new(task);\n+            do self.watcher.as_stream().close {\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task.take());\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvTcpListener {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.watcher)\n-        }\n+        let _m = self.fire_homing_missile();\n+        socket_name(Tcp, self.watcher)\n     }\n }\n \n impl RtioTcpListener for UvTcpListener {\n-    fn listen(~self) -> Result<~RtioTcpAcceptor, IoError> {\n-        do self.home_for_io_consume |self_| {\n-            let acceptor = ~UvTcpAcceptor::new(self_);\n-            let incoming = Cell::new(acceptor.incoming.clone());\n-            let mut stream = acceptor.listener.watcher.as_stream();\n-            let res = do stream.listen |mut server, status| {\n-                do incoming.with_mut_ref |incoming| {\n-                    let inc = match status {\n-                        Some(_) => Err(standard_error(OtherIoError)),\n-                        None => {\n-                            let inc = TcpWatcher::new(&server.event_loop());\n-                            // first accept call in the callback guarenteed to succeed\n-                            server.accept(inc.as_stream());\n-                            let home = get_handle_to_current_scheduler!();\n-                            Ok(~UvTcpStream { watcher: inc, home: home }\n-                                    as ~RtioTcpStream)\n-                        }\n-                    };\n-                    incoming.send(inc);\n-                }\n-            };\n-            match res {\n-                Ok(()) => Ok(acceptor as ~RtioTcpAcceptor),\n-                Err(e) => Err(uv_error_to_io_error(e)),\n+    fn listen(mut ~self) -> Result<~RtioTcpAcceptor, IoError> {\n+        let _m = self.fire_homing_missile();\n+        let acceptor = ~UvTcpAcceptor::new(*self);\n+        let incoming = Cell::new(acceptor.incoming.clone());\n+        let mut stream = acceptor.listener.watcher.as_stream();\n+        let res = do stream.listen |mut server, status| {\n+            do incoming.with_mut_ref |incoming| {\n+                let inc = match status {\n+                    Some(_) => Err(standard_error(OtherIoError)),\n+                    None => {\n+                        let inc = TcpWatcher::new(&server.event_loop());\n+                        // first accept call in the callback guarenteed to succeed\n+                        server.accept(inc.as_stream());\n+                        let home = get_handle_to_current_scheduler!();\n+                        Ok(~UvTcpStream { watcher: inc, home: home }\n+                                as ~RtioTcpStream)\n+                    }\n+                };\n+                incoming.send(inc);\n             }\n+        };\n+        match res {\n+            Ok(()) => Ok(acceptor as ~RtioTcpAcceptor),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n }\n@@ -982,9 +982,8 @@ impl UvTcpAcceptor {\n \n impl RtioSocket for UvTcpAcceptor {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.listener.watcher)\n-        }\n+        let _m = self.fire_homing_missile();\n+        socket_name(Tcp, self.listener.watcher)\n     }\n }\n \n@@ -997,21 +996,18 @@ fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n \n impl RtioTcpAcceptor for UvTcpAcceptor {\n     fn accept(&mut self) -> Result<~RtioTcpStream, IoError> {\n-        do self.home_for_io |self_| {\n-            self_.incoming.recv()\n-        }\n+        let _m = self.fire_homing_missile();\n+        self.incoming.recv()\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.watcher.as_stream(), 1)\n-        }\n+        let _m = self.fire_homing_missile();\n+        accept_simultaneously(self.listener.watcher.as_stream(), 1)\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.watcher.as_stream(), 0)\n-        }\n+        let _m = self.fire_homing_missile();\n+        accept_simultaneously(self.listener.watcher.as_stream(), 0)\n     }\n }\n \n@@ -1102,14 +1098,12 @@ impl HomingIO for UvUnboundPipe {\n \n impl Drop for UvUnboundPipe {\n     fn drop(&mut self) {\n-        do self.home_for_io |self_| {\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.pipe.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        let (_m, sched) = self.fire_homing_missile_sched();\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do self.pipe.close {\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }\n@@ -1127,14 +1121,12 @@ impl UvPipeStream {\n \n impl RtioPipe for UvPipeStream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.inner.home_for_io_with_sched |self_, scheduler| {\n-            read_stream(self_.pipe.as_stream(), scheduler, buf)\n-        }\n+        let (_m, scheduler) = self.inner.fire_homing_missile_sched();\n+        read_stream(self.inner.pipe.as_stream(), scheduler, buf)\n     }\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.inner.home_for_io_with_sched |self_, scheduler| {\n-            write_stream(self_.pipe.as_stream(), scheduler, buf)\n-        }\n+        let (_m, scheduler) = self.inner.fire_homing_missile_sched();\n+        write_stream(self.inner.pipe.as_stream(), scheduler, buf)\n     }\n }\n \n@@ -1149,81 +1141,68 @@ impl HomingIO for UvTcpStream {\n \n impl Drop for UvTcpStream {\n     fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.as_stream().close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        let (_m, sched) = self.fire_homing_missile_sched();\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do self.watcher.as_stream().close {\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvTcpStream {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Tcp, self_.watcher)\n-        }\n+        let _m = self.fire_homing_missile();\n+        socket_name(Tcp, self.watcher)\n     }\n }\n \n impl RtioTcpStream for UvTcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            read_stream(self_.watcher.as_stream(), scheduler, buf)\n-        }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        read_stream(self.watcher.as_stream(), scheduler, buf)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            write_stream(self_.watcher.as_stream(), scheduler, buf)\n-        }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        write_stream(self.watcher.as_stream(), scheduler, buf)\n     }\n \n     fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(TcpPeer, self_.watcher)\n-        }\n+        let _m = self.fire_homing_missile();\n+        socket_name(TcpPeer, self.watcher)\n     }\n \n     fn control_congestion(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_tcp_nodelay(self_.watcher.native_handle(), 0 as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_nodelay(self.watcher.native_handle(), 0 as c_int)\n+        })\n     }\n \n     fn nodelay(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_tcp_nodelay(self_.watcher.native_handle(), 1 as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_nodelay(self.watcher.native_handle(), 1 as c_int)\n+        })\n     }\n \n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_tcp_keepalive(self_.watcher.native_handle(), 1 as c_int,\n-                                       delay_in_seconds as c_uint)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_keepalive(self.watcher.native_handle(), 1 as c_int,\n+                                   delay_in_seconds as c_uint)\n+        })\n     }\n \n     fn letdie(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_tcp_keepalive(self_.watcher.native_handle(),\n-                                       0 as c_int, 0 as c_uint)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_keepalive(self.watcher.native_handle(),\n+                                   0 as c_int, 0 as c_uint)\n+        })\n     }\n }\n \n@@ -1238,170 +1217,151 @@ impl HomingIO for UvUdpSocket {\n \n impl Drop for UvUdpSocket {\n     fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do self.watcher.close {\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvUdpSocket {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        do self.home_for_io |self_| {\n-            socket_name(Udp, self_.watcher)\n-        }\n+        let _m = self.fire_homing_missile();\n+        socket_name(Udp, self.watcher)\n     }\n }\n \n impl RtioUdpSocket for UvUdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            let result_cell = Cell::new_empty();\n-            let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n-            let uv_buf = slice_to_uv_buf(buf);\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let alloc: AllocCallback = |_| uv_buf;\n-                do self_.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n-                    let _ = flags; // /XXX add handling for partials?\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n \n-                    watcher.recv_stop();\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do self.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n+                let _ = flags; // /XXX add handling for partials?\n \n-                    let result = match status {\n-                        None => {\n-                            assert!(nread >= 0);\n-                            Ok((nread as uint, addr))\n-                        }\n-                        Some(err) => Err(uv_error_to_io_error(err)),\n-                    };\n+                watcher.recv_stop();\n \n-                    unsafe { (*result_cell_ptr).put_back(result); }\n+                let result = match status {\n+                    None => {\n+                        assert!(nread >= 0);\n+                        Ok((nread as uint, addr))\n+                    }\n+                    Some(err) => Err(uv_error_to_io_error(err)),\n+                };\n \n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n-            }\n+                unsafe { (*result_cell_ptr).put_back(result); }\n \n-            assert!(!result_cell.is_empty());\n-            result_cell.take()\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            }\n         }\n+\n+        assert!(!result_cell.is_empty());\n+        result_cell.take()\n     }\n \n     fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            let result_cell = Cell::new_empty();\n-            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-            let buf_ptr: *&[u8] = &buf;\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                do self_.watcher.send(buf, dst) |_watcher, status| {\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do self.watcher.send(buf, dst) |_watcher, status| {\n \n-                    let result = match status {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err)),\n-                    };\n+                let result = match status {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err)),\n+                };\n \n-                    unsafe { (*result_cell_ptr).put_back(result); }\n+                unsafe { (*result_cell_ptr).put_back(result); }\n \n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n-\n-            assert!(!result_cell.is_empty());\n-            result_cell.take()\n         }\n+\n+        assert!(!result_cell.is_empty());\n+        result_cell.take()\n     }\n \n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                do multi.to_str().with_c_str |m_addr| {\n-                    uvll::uv_udp_set_membership(self_.watcher.native_handle(),\n-                                                m_addr, ptr::null(),\n-                                                uvll::UV_JOIN_GROUP)\n-                }\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            do multi.to_str().with_c_str |m_addr| {\n+                uvll::uv_udp_set_membership(self.watcher.native_handle(),\n+                                            m_addr, ptr::null(),\n+                                            uvll::UV_JOIN_GROUP)\n+            }\n+        })\n     }\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                do multi.to_str().with_c_str |m_addr| {\n-                    uvll::uv_udp_set_membership(self_.watcher.native_handle(),\n-                                                m_addr, ptr::null(),\n-                                                uvll::UV_LEAVE_GROUP)\n-                }\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            do multi.to_str().with_c_str |m_addr| {\n+                uvll::uv_udp_set_membership(self.watcher.native_handle(),\n+                                            m_addr, ptr::null(),\n+                                            uvll::UV_LEAVE_GROUP)\n+            }\n+        })\n     }\n \n     fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_udp_set_multicast_loop(self_.watcher.native_handle(),\n-                                                1 as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_multicast_loop(self.watcher.native_handle(),\n+                                            1 as c_int)\n+        })\n     }\n \n     fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_udp_set_multicast_loop(self_.watcher.native_handle(),\n-                                                0 as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_multicast_loop(self.watcher.native_handle(),\n+                                            0 as c_int)\n+        })\n     }\n \n     fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_udp_set_multicast_ttl(self_.watcher.native_handle(),\n-                                               ttl as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_multicast_ttl(self.watcher.native_handle(),\n+                                           ttl as c_int)\n+        })\n     }\n \n     fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_ttl(self.watcher.native_handle(), ttl as c_int)\n+        })\n     }\n \n     fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_udp_set_broadcast(self_.watcher.native_handle(),\n-                                           1 as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_broadcast(self.watcher.native_handle(),\n+                                       1 as c_int)\n+        })\n     }\n \n     fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            let r = unsafe {\n-                uvll::uv_udp_set_broadcast(self_.watcher.native_handle(),\n-                                           0 as c_int)\n-            };\n-            status_to_io_result(r)\n-        }\n+        let _m = self.fire_homing_missile();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_broadcast(self.watcher.native_handle(),\n+                                       0 as c_int)\n+        })\n     }\n }\n \n@@ -1422,47 +1382,43 @@ impl UvTimer {\n \n impl Drop for UvTimer {\n     fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            uvdebug!(\"closing UvTimer\");\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        uvdebug!(\"closing UvTimer\");\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do self.watcher.close {\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }\n }\n \n impl RtioTimer for UvTimer {\n     fn sleep(&mut self, msecs: u64) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_sched, task| {\n-                uvdebug!(\"sleep: entered scheduler context\");\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.start(msecs, 0) |_, status| {\n-                    assert!(status.is_none());\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        do scheduler.deschedule_running_task_and_then |_sched, task| {\n+            uvdebug!(\"sleep: entered scheduler context\");\n+            let task_cell = Cell::new(task);\n+            do self.watcher.start(msecs, 0) |_, status| {\n+                assert!(status.is_none());\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n-            self_.watcher.stop();\n         }\n+        self.watcher.stop();\n     }\n \n     fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n         use std::comm::oneshot;\n \n         let (port, chan) = oneshot();\n         let chan = Cell::new(chan);\n-        do self.home_for_io |self_| {\n-            let chan = Cell::new(chan.take());\n-            do self_.watcher.start(msecs, 0) |_, status| {\n-                assert!(status.is_none());\n-                assert!(!chan.is_empty());\n-                chan.take().send_deferred(());\n-            }\n+        let _m = self.fire_homing_missile();\n+        do self.watcher.start(msecs, 0) |_, status| {\n+            assert!(status.is_none());\n+            assert!(!chan.is_empty());\n+            chan.take().send_deferred(());\n         }\n \n         return port;\n@@ -1473,13 +1429,11 @@ impl RtioTimer for UvTimer {\n \n         let (port, chan) = stream();\n         let chan = Cell::new(chan);\n-        do self.home_for_io |self_| {\n-            let chan = Cell::new(chan.take());\n-            do self_.watcher.start(msecs, msecs) |_, status| {\n-                assert!(status.is_none());\n-                do chan.with_ref |chan| {\n-                    chan.send_deferred(());\n-                }\n+        let _m = self.fire_homing_missile();\n+        do self.watcher.start(msecs, msecs) |_, status| {\n+            assert!(status.is_none());\n+            do chan.with_ref |chan| {\n+                chan.send_deferred(());\n             }\n         }\n \n@@ -1512,20 +1466,19 @@ impl UvFileStream {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n         let buf_ptr: *&mut [u8] = &buf;\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-                let task_cell = Cell::new(task);\n-                let read_req = file::FsRequest::new();\n-                do read_req.read(&self_.loop_, self_.fd, buf, offset) |req, uverr| {\n-                    let res = match uverr  {\n-                        None => Ok(req.get_result() as int),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            let task_cell = Cell::new(task);\n+            let read_req = file::FsRequest::new();\n+            do read_req.read(&self.loop_, self.fd, buf, offset) |req, uverr| {\n+                let res = match uverr  {\n+                    None => Ok(req.get_result() as int),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n         result_cell.take()\n@@ -1555,19 +1508,18 @@ impl UvFileStream {\n             -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        do self.home_for_io_with_sched |self_, sched| {\n-            do sched.deschedule_running_task_and_then |_, task| {\n-                let task = Cell::new(task);\n-                let req = file::FsRequest::new();\n-                do f(self_, req) |_, uverr| {\n-                    let res = match uverr  {\n-                        None => Ok(()),\n-                        Some(err) => Err(uv_error_to_io_error(err))\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task.take());\n-                }\n+        let (_m, sched) = self.fire_homing_missile_sched();\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            let task = Cell::new(task);\n+            let req = file::FsRequest::new();\n+            do f(self_, req) |_, uverr| {\n+                let res = match uverr  {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err))\n+                };\n+                unsafe { (*result_cell_ptr).put_back(res); }\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task.take());\n             }\n         }\n         result_cell.take()\n@@ -1583,14 +1535,13 @@ impl Drop for UvFileStream {\n                 do close_req.close(&self.loop_, self.fd) |_,_| {}\n             }\n             CloseSynchronously => {\n-                do self.home_for_io_with_sched |self_, scheduler| {\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        let task_cell = Cell::new(task);\n-                        let close_req = file::FsRequest::new();\n-                        do close_req.close(&self_.loop_, self_.fd) |_,_| {\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n+                let (_m, scheduler) = self.fire_homing_missile_sched();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    let close_req = file::FsRequest::new();\n+                    do close_req.close(&self.loop_, self.fd) |_,_| {\n+                        let scheduler: ~Scheduler = Local::take();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n                     }\n                 }\n             }\n@@ -1623,7 +1574,7 @@ impl RtioFileStream for UvFileStream {\n     fn tell(&self) -> Result<u64, IoError> {\n         use std::libc::SEEK_CUR;\n         // this is temporary\n-        let self_ = unsafe { cast::transmute::<&UvFileStream, &mut UvFileStream>(self) };\n+        let self_ = unsafe { cast::transmute_mut(self) };\n         self_.seek_common(0, SEEK_CUR)\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {\n@@ -1681,7 +1632,8 @@ impl Drop for UvProcess {\n         if self.home.is_none() {\n             close(self)\n         } else {\n-            self.home_for_io(close)\n+            let _m = self.fire_homing_missile();\n+            close(self)\n         }\n     }\n }\n@@ -1692,30 +1644,28 @@ impl RtioProcess for UvProcess {\n     }\n \n     fn kill(&mut self, signal: int) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.process.kill(signal) {\n-                Ok(()) => Ok(()),\n-                Err(uverr) => Err(uv_error_to_io_error(uverr))\n-            }\n+        let _m = self.fire_homing_missile();\n+        match self.process.kill(signal) {\n+            Ok(()) => Ok(()),\n+            Err(uverr) => Err(uv_error_to_io_error(uverr))\n         }\n     }\n \n     fn wait(&mut self) -> int {\n         // Make sure (on the home scheduler) that we have an exit status listed\n-        do self.home_for_io |self_| {\n-            match self_.exit_status {\n-                Some(*) => {}\n-                None => {\n-                    // If there's no exit code previously listed, then the\n-                    // process's exit callback has yet to be invoked. We just\n-                    // need to deschedule ourselves and wait to be reawoken.\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        assert!(self_.descheduled.is_none());\n-                        self_.descheduled = Some(task);\n-                    }\n-                    assert!(self_.exit_status.is_some());\n+        let _m = self.fire_homing_missile();\n+        match self.exit_status {\n+            Some(*) => {}\n+            None => {\n+                // If there's no exit code previously listed, then the\n+                // process's exit callback has yet to be invoked. We just\n+                // need to deschedule ourselves and wait to be reawoken.\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    assert!(self.descheduled.is_none());\n+                    self.descheduled = Some(task);\n                 }\n+                assert!(self.exit_status.is_some());\n             }\n         }\n \n@@ -1738,28 +1688,27 @@ impl UvUnixListener {\n }\n \n impl RtioUnixListener for UvUnixListener {\n-    fn listen(~self) -> Result<~RtioUnixAcceptor, IoError> {\n-        do self.home_for_io_consume |self_| {\n-            let acceptor = ~UvUnixAcceptor::new(self_);\n-            let incoming = Cell::new(acceptor.incoming.clone());\n-            let mut stream = acceptor.listener.inner.pipe.as_stream();\n-            let res = do stream.listen |mut server, status| {\n-                do incoming.with_mut_ref |incoming| {\n-                    let inc = match status {\n-                        Some(e) => Err(uv_error_to_io_error(e)),\n-                        None => {\n-                            let pipe = UvUnboundPipe::new(&server.event_loop());\n-                            server.accept(pipe.pipe.as_stream());\n-                            Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n-                        }\n-                    };\n-                    incoming.send(inc);\n-                }\n-            };\n-            match res {\n-                Ok(()) => Ok(acceptor as ~RtioUnixAcceptor),\n-                Err(e) => Err(uv_error_to_io_error(e)),\n+    fn listen(mut ~self) -> Result<~RtioUnixAcceptor, IoError> {\n+        let _m = self.fire_homing_missile();\n+        let acceptor = ~UvUnixAcceptor::new(*self);\n+        let incoming = Cell::new(acceptor.incoming.clone());\n+        let mut stream = acceptor.listener.inner.pipe.as_stream();\n+        let res = do stream.listen |mut server, status| {\n+            do incoming.with_mut_ref |incoming| {\n+                let inc = match status {\n+                    Some(e) => Err(uv_error_to_io_error(e)),\n+                    None => {\n+                        let pipe = UvUnboundPipe::new(&server.event_loop());\n+                        server.accept(pipe.pipe.as_stream());\n+                        Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n+                    }\n+                };\n+                incoming.send(inc);\n             }\n+        };\n+        match res {\n+            Ok(()) => Ok(acceptor as ~RtioUnixAcceptor),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n }\n@@ -1787,30 +1736,26 @@ impl Drop for UvTTY {\n \n impl RtioTTY for UvTTY {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            read_stream(self_.tty.as_stream(), scheduler, buf)\n-        }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        read_stream(self.tty.as_stream(), scheduler, buf)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            write_stream(self_.tty.as_stream(), scheduler, buf)\n-        }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        write_stream(self.tty.as_stream(), scheduler, buf)\n     }\n \n     fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.tty.set_mode(raw) {\n-                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-            }\n+        let _m = self.fire_homing_missile();\n+        match self.tty.set_mode(raw) {\n+            Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n-        do self.home_for_io |self_| {\n-            match self_.tty.get_winsize() {\n-                Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-            }\n+        let _m = self.fire_homing_missile();\n+        match self.tty.get_winsize() {\n+            Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n@@ -1836,21 +1781,18 @@ impl UvUnixAcceptor {\n \n impl RtioUnixAcceptor for UvUnixAcceptor {\n     fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n-        do self.home_for_io |self_| {\n-            self_.incoming.recv()\n-        }\n+        let _m = self.fire_homing_missile();\n+        self.incoming.recv()\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 1)\n-        }\n+        let _m = self.fire_homing_missile();\n+        accept_simultaneously(self.listener.inner.pipe.as_stream(), 1)\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        do self.home_for_io |self_| {\n-            accept_simultaneously(self_.listener.inner.pipe.as_stream(), 0)\n-        }\n+        let _m = self.fire_homing_missile();\n+        accept_simultaneously(self.listener.inner.pipe.as_stream(), 0)\n     }\n }\n \n@@ -1873,14 +1815,13 @@ impl RtioSignal for UvSignal {}\n \n impl Drop for UvSignal {\n     fn drop(&mut self) {\n-        do self.home_for_io_with_sched |self_, scheduler| {\n-            uvdebug!(\"closing UvSignal\");\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher.close {\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                }\n+        let (_m, scheduler) = self.fire_homing_missile_sched();\n+        uvdebug!(\"closing UvSignal\");\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            do self.watcher.close {\n+                let scheduler: ~Scheduler = Local::take();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n             }\n         }\n     }"}]}