{"sha": "9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZTljNmRhM2U3ZDFkNzFiNmZjYjlkOTlhMjljY2JhOGRlY2YwNGU=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-16T09:42:05Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-17T09:58:26Z"}, "message": "Using <Iter>::new instead of exposing internal fields", "tree": {"sha": "d28394d6481c48fe51ab2631bb50862ec962504c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d28394d6481c48fe51ab2631bb50862ec962504c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "html_url": "https://github.com/rust-lang/rust/commit/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285fc7d704fcdd7b2a37d475d04d5d955490e000", "url": "https://api.github.com/repos/rust-lang/rust/commits/285fc7d704fcdd7b2a37d475d04d5d955490e000", "html_url": "https://github.com/rust-lang/rust/commit/285fc7d704fcdd7b2a37d475d04d5d955490e000"}], "stats": {"total": 302, "additions": 218, "deletions": 84}, "files": [{"sha": "1c004f2d3fafcbe74849a6a23640e7436fb419ec", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 193, "deletions": 57, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "patch": "@@ -8,7 +8,7 @@ use crate::cmp::Ordering;\n use crate::fmt;\n use crate::intrinsics::{assume, exact_div, unchecked_sub};\n use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\n-use crate::marker::{self, Send, Sized, Sync};\n+use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem;\n use crate::ptr::NonNull;\n \n@@ -62,11 +62,11 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    pub(super) ptr: NonNull<T>,\n-    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    ptr: NonNull<T>,\n+    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n-    pub(super) _marker: marker::PhantomData<&'a T>,\n+    _marker: PhantomData<&'a T>,\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -82,6 +82,10 @@ unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n \n impl<'a, T> Iter<'a, T> {\n+    pub(super) fn new(ptr: NonNull<T>, end: *const T) -> Self {\n+        Self { ptr, end, _marker: PhantomData }\n+    }\n+\n     /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n@@ -164,11 +168,11 @@ impl<T> AsRef<[T]> for Iter<'_, T> {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    pub(super) ptr: NonNull<T>,\n-    pub(super) end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    ptr: NonNull<T>,\n+    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n-    pub(super) _marker: marker::PhantomData<&'a mut T>,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -184,6 +188,10 @@ unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n+    pub(super) fn new(ptr: NonNull<T>, end: *mut T) -> Self {\n+        Self { ptr, end, _marker: PhantomData }\n+    }\n+\n     /// Views the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n@@ -277,9 +285,15 @@ pub struct Split<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> Split<'a, T, P> {\n+    pub(super) fn new(slice: &'a [T], pred: P, finished: bool) -> Self {\n+        Self { v: slice, pred, finished }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -385,9 +399,15 @@ pub struct SplitInclusive<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusive<'a, T, P> {\n+    pub(super) fn new(slice: &'a [T], pred: P, finished: bool) -> Self {\n+        Self { v: slice, pred, finished }\n+    }\n }\n \n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n@@ -483,9 +503,15 @@ pub struct SplitMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a mut [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a mut [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitMut<'a, T, P> {\n+    pub(super) fn new(slice: &'a mut [T], pred: P, finished: bool) -> Self {\n+        Self { v: slice, pred, finished }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -598,9 +624,15 @@ pub struct SplitInclusiveMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a mut [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a mut [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusiveMut<'a, T, P> {\n+    pub(super) fn new(slice: &'a mut [T], pred: P, finished: bool) -> Self {\n+        Self { v: slice, pred, finished }\n+    }\n }\n \n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n@@ -706,7 +738,13 @@ pub struct RSplit<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: Split<'a, T, P>,\n+    inner: Split<'a, T, P>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplit<'a, T, P> {\n+    pub(super) fn new(slice: &'a [T], pred: P, finished: bool) -> Self {\n+        Self { inner: Split::new(slice, pred, finished) }\n+    }\n }\n \n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n@@ -777,7 +815,13 @@ pub struct RSplitMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: SplitMut<'a, T, P>,\n+    inner: SplitMut<'a, T, P>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitMut<'a, T, P> {\n+    pub(super) fn new(slice: &'a mut [T], pred: P, finished: bool) -> Self {\n+        Self { inner: SplitMut::new(slice, pred, finished) }\n+    }\n }\n \n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n@@ -840,9 +884,9 @@ impl<T, P> FusedIterator for RSplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n /// match a predicate function, splitting at most a fixed number of\n /// times.\n #[derive(Debug)]\n-pub(super) struct GenericSplitN<I> {\n-    pub(super) iter: I,\n-    pub(super) count: usize,\n+struct GenericSplitN<I> {\n+    iter: I,\n+    count: usize,\n }\n \n impl<T, I: SplitIter<Item = T>> Iterator for GenericSplitN<I> {\n@@ -882,7 +926,13 @@ pub struct SplitN<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<Split<'a, T, P>>,\n+    inner: GenericSplitN<Split<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitN<'a, T, P> {\n+    pub(super) fn new(s: Split<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -908,7 +958,13 @@ pub struct RSplitN<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<RSplit<'a, T, P>>,\n+    inner: GenericSplitN<RSplit<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitN<'a, T, P> {\n+    pub(super) fn new(s: RSplit<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -933,7 +989,13 @@ pub struct SplitNMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<SplitMut<'a, T, P>>,\n+    inner: GenericSplitN<SplitMut<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitNMut<'a, T, P> {\n+    pub(super) fn new(s: SplitMut<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -959,7 +1021,13 @@ pub struct RSplitNMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<RSplitMut<'a, T, P>>,\n+    inner: GenericSplitN<RSplitMut<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitNMut<'a, T, P> {\n+    pub(super) fn new(s: RSplitMut<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -986,8 +1054,14 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) size: usize,\n+    v: &'a [T],\n+    size: usize,\n+}\n+\n+impl<'a, T: 'a> Windows<'a, T> {\n+    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n+        Self { v: slice, size }\n+    }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n@@ -1118,8 +1192,14 @@ unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> Chunks<'a, T> {\n+    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n@@ -1272,8 +1352,14 @@ unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> ChunksMut<'a, T> {\n+    pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1425,9 +1511,15 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n pub struct ChunksExact<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) rem: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    rem: &'a [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> ChunksExact<'a, T> {\n+    pub(super) fn new(slice: &'a [T], rem: &'a [T], size: usize) -> Self {\n+        Self { v: slice, rem, chunk_size: size }\n+    }\n }\n \n impl<'a, T> ChunksExact<'a, T> {\n@@ -1565,9 +1657,15 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n pub struct ChunksExactMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) rem: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    rem: &'a mut [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> ChunksExactMut<'a, T> {\n+    pub(super) fn new(slice: &'a mut [T], rem: &'a mut [T], size: usize) -> Self {\n+        Self { v: slice, rem, chunk_size: size }\n+    }\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n@@ -1697,9 +1795,15 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n #[derive(Debug, Clone, Copy)]\n #[unstable(feature = \"array_windows\", issue = \"75027\")]\n pub struct ArrayWindows<'a, T: 'a, const N: usize> {\n-    pub(crate) slice_head: *const T,\n-    pub(crate) num: usize,\n-    pub(crate) marker: marker::PhantomData<&'a [T; N]>,\n+    slice_head: *const T,\n+    num: usize,\n+    marker: PhantomData<&'a [T; N]>,\n+}\n+\n+impl<'a, T: 'a, const N: usize> ArrayWindows<'a, T, N> {\n+    pub(super) fn new(head: *const T, num: usize) -> Self {\n+        Self { slice_head: head, num, marker: PhantomData }\n+    }\n }\n \n #[unstable(feature = \"array_windows\", issue = \"75027\")]\n@@ -1802,8 +1906,14 @@ impl<T, const N: usize> ExactSizeIterator for ArrayWindows<'_, T, N> {\n #[derive(Debug)]\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n-    pub(super) iter: Iter<'a, [T; N]>,\n-    pub(super) rem: &'a [T],\n+    iter: Iter<'a, [T; N]>,\n+    rem: &'a [T],\n+}\n+\n+impl<'a, T: 'a, const N: usize> ArrayChunks<'a, T, N> {\n+    pub(super) fn new(iter: Iter<'a, [T; N]>, rem: &'a [T]) -> Self {\n+        Self { iter, rem }\n+    }\n }\n \n impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n@@ -1909,8 +2019,14 @@ unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N>\n #[derive(Debug)]\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub struct ArrayChunksMut<'a, T: 'a, const N: usize> {\n-    pub(super) iter: IterMut<'a, [T; N]>,\n-    pub(super) rem: &'a mut [T],\n+    iter: IterMut<'a, [T; N]>,\n+    rem: &'a mut [T],\n+}\n+\n+impl<'a, T: 'a, const N: usize> ArrayChunksMut<'a, T, N> {\n+    pub(super) fn new(iter: IterMut<'a, [T; N]>, rem: &'a mut [T]) -> Self {\n+        Self { iter, rem }\n+    }\n }\n \n impl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n@@ -2006,8 +2122,14 @@ unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunksMut<'a, T,\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunks<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> RChunks<'a, T> {\n+    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n@@ -2156,8 +2278,14 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> RChunksMut<'a, T> {\n+    pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -2306,12 +2434,16 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksExact<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) rem: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    rem: &'a [T],\n+    chunk_size: usize,\n }\n \n impl<'a, T> RChunksExact<'a, T> {\n+    pub(super) fn new(slice: &'a [T], rem: &'a [T], size: usize) -> Self {\n+        Self { v: slice, rem, chunk_size: size }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -2451,12 +2583,16 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksExactMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) rem: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    rem: &'a mut [T],\n+    chunk_size: usize,\n }\n \n impl<'a, T> RChunksExactMut<'a, T> {\n+    pub(super) fn new(slice: &'a mut [T], rem: &'a mut [T], size: usize) -> Self {\n+        Self { v: slice, rem, chunk_size: size }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements."}, {"sha": "238e5c209d39220f1a23cd92cac04918a0a7dc96", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=9fe9c6da3e7d1d71b6fcb9d99a29ccba8decf04e", "patch": "@@ -10,7 +10,7 @@\n \n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics::assume;\n-use crate::marker::{self, Copy};\n+use crate::marker::Copy;\n use crate::mem;\n use crate::ops::{FnMut, Range, RangeBounds};\n use crate::option::Option;\n@@ -35,8 +35,6 @@ mod raw;\n mod rotate;\n mod sort;\n \n-use iter::GenericSplitN;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use iter::{Chunks, ChunksMut, Windows};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -707,7 +705,7 @@ impl<T> [T] {\n                 ptr.add(self.len())\n             };\n \n-            Iter { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: marker::PhantomData }\n+            Iter::new(NonNull::new_unchecked(ptr as *mut T), end)\n         }\n     }\n \n@@ -751,7 +749,7 @@ impl<T> [T] {\n                 ptr.add(self.len())\n             };\n \n-            IterMut { ptr: NonNull::new_unchecked(ptr), end, _marker: marker::PhantomData }\n+            IterMut::new(NonNull::new_unchecked(ptr), end)\n         }\n     }\n \n@@ -785,7 +783,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<'_, T> {\n         assert_ne!(size, 0);\n-        Windows { v: self, size }\n+        Windows::new(self, size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -819,7 +817,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        Chunks { v: self, chunk_size }\n+        Chunks::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -857,7 +855,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        ChunksMut { v: self, chunk_size }\n+        ChunksMut::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -898,7 +896,7 @@ impl<T> [T] {\n         let fst_len = self.len() - rem;\n         // SAFETY: 0 <= fst_len <= self.len() by construction above\n         let (fst, snd) = unsafe { self.split_at_unchecked(fst_len) };\n-        ChunksExact { v: fst, rem: snd, chunk_size }\n+        ChunksExact::new(fst, snd, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -944,7 +942,7 @@ impl<T> [T] {\n         let fst_len = self.len() - rem;\n         // SAFETY: 0 <= fst_len <= self.len() by construction above\n         let (fst, snd) = unsafe { self.split_at_mut_unchecked(fst_len) };\n-        ChunksExactMut { v: fst, rem: snd, chunk_size }\n+        ChunksExactMut::new(fst, snd, chunk_size)\n     }\n \n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n@@ -983,7 +981,7 @@ impl<T> [T] {\n         // SAFETY: We cast a slice of `len * N` elements into\n         // a slice of `len` many `N` elements chunks.\n         let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n-        ArrayChunks { iter: array_slice.iter(), rem: snd }\n+        ArrayChunks::new(array_slice.iter(), snd)\n     }\n \n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n@@ -1025,7 +1023,7 @@ impl<T> [T] {\n         // a slice of `len` many `N` elements chunks.\n         unsafe {\n             let array_slice: &mut [[T; N]] = from_raw_parts_mut(fst.as_mut_ptr().cast(), len);\n-            ArrayChunksMut { iter: array_slice.iter_mut(), rem: snd }\n+            ArrayChunksMut::new(array_slice.iter_mut(), snd)\n         }\n     }\n \n@@ -1060,7 +1058,7 @@ impl<T> [T] {\n         assert_ne!(N, 0);\n \n         let num_windows = self.len().saturating_sub(N - 1);\n-        ArrayWindows { slice_head: self.as_ptr(), num: num_windows, marker: marker::PhantomData }\n+        ArrayWindows::new(self.as_ptr(), num_windows)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1094,7 +1092,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks(&self, chunk_size: usize) -> RChunks<'_, T> {\n         assert!(chunk_size != 0);\n-        RChunks { v: self, chunk_size }\n+        RChunks::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1132,7 +1130,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<'_, T> {\n         assert!(chunk_size != 0);\n-        RChunksMut { v: self, chunk_size }\n+        RChunksMut::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -1174,7 +1172,7 @@ impl<T> [T] {\n         let rem = self.len() % chunk_size;\n         // SAFETY: 0 <= rem <= self.len() by construction above\n         let (fst, snd) = unsafe { self.split_at_unchecked(rem) };\n-        RChunksExact { v: snd, rem: fst, chunk_size }\n+        RChunksExact::new(snd, fst, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1220,7 +1218,7 @@ impl<T> [T] {\n         let rem = self.len() % chunk_size;\n         // SAFETY: 0 <= rem <= self.len() by construction above\n         let (fst, snd) = unsafe { self.split_at_mut_unchecked(rem) };\n-        RChunksExactMut { v: snd, rem: fst, chunk_size }\n+        RChunksExactMut::new(snd, fst, chunk_size)\n     }\n \n     /// Divides one slice into two at an index.\n@@ -1439,7 +1437,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        Split { v: self, pred, finished: false }\n+        Split::new(self, pred, false)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1461,7 +1459,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitMut { v: self, pred, finished: false }\n+        SplitMut::new(self, pred, false)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1499,7 +1497,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitInclusive { v: self, pred, finished: false }\n+        SplitInclusive::new(self, pred, false)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1524,7 +1522,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitInclusiveMut { v: self, pred, finished: false }\n+        SplitInclusiveMut::new(self, pred, false)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1560,7 +1558,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplit { inner: self.split(pred) }\n+        RSplit::new(self, pred, false)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1586,7 +1584,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplitMut { inner: self.split_mut(pred) }\n+        RSplitMut::new(self, pred, false)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1614,7 +1612,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitN { inner: GenericSplitN { iter: self.split(pred), count: n } }\n+        SplitN::new(self.split(pred), n)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1640,7 +1638,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitNMut { inner: GenericSplitN { iter: self.split_mut(pred), count: n } }\n+        SplitNMut::new(self.split_mut(pred), n)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1669,7 +1667,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplitN { inner: GenericSplitN { iter: self.rsplit(pred), count: n } }\n+        RSplitN::new(self.rsplit(pred), n)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1696,7 +1694,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplitNMut { inner: GenericSplitN { iter: self.rsplit_mut(pred), count: n } }\n+        RSplitNMut::new(self.rsplit_mut(pred), n)\n     }\n \n     /// Returns `true` if the slice contains an element with the given value."}]}