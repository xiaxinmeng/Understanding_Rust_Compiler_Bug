{"sha": "3dda9aabf217d59881970f847b06338d417f6f6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZGE5YWFiZjIxN2Q1OTg4MTk3MGY4NDdiMDYzMzhkNDE3ZjZmNmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-08T22:30:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-08T22:30:37Z"}, "message": "stdlib: std::ebmlivec and std::ebml are now synonyms", "tree": {"sha": "5a4400cb1411963e3b18ca685146658c61754f40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a4400cb1411963e3b18ca685146658c61754f40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dda9aabf217d59881970f847b06338d417f6f6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dda9aabf217d59881970f847b06338d417f6f6f", "html_url": "https://github.com/rust-lang/rust/commit/3dda9aabf217d59881970f847b06338d417f6f6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dda9aabf217d59881970f847b06338d417f6f6f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d7f866eec99d37ef9c3c548ae8916c4f5634717", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d7f866eec99d37ef9c3c548ae8916c4f5634717", "html_url": "https://github.com/rust-lang/rust/commit/4d7f866eec99d37ef9c3c548ae8916c4f5634717"}], "stats": {"total": 243, "additions": 33, "deletions": 210}, "files": [{"sha": "41e5bf03b1a32d19180c2fd59259fa05e32c7163", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3dda9aabf217d59881970f847b06338d417f6f6f/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dda9aabf217d59881970f847b06338d417f6f6f/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=3dda9aabf217d59881970f847b06338d417f6f6f", "patch": "@@ -15,9 +15,9 @@ type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n // modules within this file.\n \n // ebml reading\n-type doc = {data: vec[u8], start: uint, end: uint};\n+type doc = {data: @u8[], start: uint, end: uint};\n \n-fn vint_at(data: vec[u8], start: uint) -> {val: uint, next: uint} {\n+fn vint_at(data: &u8[], start: uint) -> {val: uint, next: uint} {\n     let a = data.(start);\n     if a & 0x80u8 != 0u8 { ret {val: a & 0x7fu8 as uint, next: start + 1u}; }\n     if a & 0x40u8 != 0u8 {\n@@ -39,22 +39,22 @@ fn vint_at(data: vec[u8], start: uint) -> {val: uint, next: uint} {\n     } else { log_err \"vint too big\"; fail; }\n }\n \n-fn new_doc(data: vec[u8]) -> doc {\n-    ret {data: data, start: 0u, end: vec::len[u8](data)};\n+fn new_doc(data: &@u8[]) -> doc {\n+    ret {data: data, start: 0u, end: ivec::len[u8](*data)};\n }\n \n-fn doc_at(data: vec[u8], start: uint) -> doc {\n-    let elt_tag = vint_at(data, start);\n-    let elt_size = vint_at(data, elt_tag.next);\n+fn doc_at(data: &@u8[], start: uint) -> doc {\n+    let elt_tag = vint_at(*data, start);\n+    let elt_size = vint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n     ret {data: data, start: elt_size.next, end: end};\n }\n \n fn maybe_get_doc(d: doc, tg: uint) -> option::t[doc] {\n     let pos = d.start;\n     while pos < d.end {\n-        let elt_tag = vint_at(d.data, pos);\n-        let elt_size = vint_at(d.data, elt_tag.next);\n+        let elt_tag = vint_at(*d.data, pos);\n+        let elt_size = vint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n             ret some[doc]({data: d.data, start: elt_size.next, end: pos});\n@@ -76,8 +76,8 @@ fn get_doc(d: doc, tg: uint) -> doc {\n iter docs(d: doc) -> {tag: uint, doc: doc} {\n     let pos = d.start;\n     while pos < d.end {\n-        let elt_tag = vint_at(d.data, pos);\n-        let elt_size = vint_at(d.data, elt_tag.next);\n+        let elt_tag = vint_at(*d.data, pos);\n+        let elt_size = vint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         put {tag: elt_tag.val,\n              doc: {data: d.data, start: elt_size.next, end: pos}};\n@@ -87,18 +87,18 @@ iter docs(d: doc) -> {tag: uint, doc: doc} {\n iter tagged_docs(d: doc, tg: uint) -> doc {\n     let pos = d.start;\n     while pos < d.end {\n-        let elt_tag = vint_at(d.data, pos);\n-        let elt_size = vint_at(d.data, elt_tag.next);\n+        let elt_tag = vint_at(*d.data, pos);\n+        let elt_size = vint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n             put {data: d.data, start: elt_size.next, end: pos};\n         }\n     }\n }\n \n-fn doc_data(d: doc) -> vec[u8] { ret vec::slice[u8](d.data, d.start, d.end); }\n+fn doc_data(d: doc) -> u8[] { ret ivec::slice[u8](*d.data, d.start, d.end); }\n \n-fn be_uint_from_bytes(data: vec[u8], start: uint, size: uint) -> uint {\n+fn be_uint_from_bytes(data: &@u8[], start: uint, size: uint) -> uint {\n     let sz = size;\n     assert (sz <= 4u);\n     let val = 0u;\n@@ -117,29 +117,29 @@ fn doc_as_uint(d: doc) -> uint {\n \n \n // ebml writing\n-type writer = {writer: io::buf_writer, mutable size_positions: vec[uint]};\n+type writer = {writer: ioivec::buf_writer, mutable size_positions: uint[]};\n \n-fn write_sized_vint(w: &io::buf_writer, n: uint, size: uint) {\n-    let buf: vec[u8];\n+fn write_sized_vint(w: &ioivec::buf_writer, n: uint, size: uint) {\n+    let buf: u8[];\n     alt size {\n-      1u { buf = [0x80u8 | (n as u8)]; }\n-      2u { buf = [0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n+      1u { buf = ~[0x80u8 | (n as u8)]; }\n+      2u { buf = ~[0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n       3u {\n         buf =\n-            [0x20u8 | (n >> 16u as u8), n >> 8u & 0xffu as u8,\n-             n & 0xffu as u8];\n+            ~[0x20u8 | (n >> 16u as u8), n >> 8u & 0xffu as u8,\n+              n & 0xffu as u8];\n       }\n       4u {\n         buf =\n-            [0x10u8 | (n >> 24u as u8), n >> 16u & 0xffu as u8,\n-             n >> 8u & 0xffu as u8, n & 0xffu as u8];\n+            ~[0x10u8 | (n >> 24u as u8), n >> 16u & 0xffu as u8,\n+              n >> 8u & 0xffu as u8, n & 0xffu as u8];\n       }\n       _ { log_err \"vint to write too big\"; fail; }\n     }\n     w.write(buf);\n }\n \n-fn write_vint(w: &io::buf_writer, n: uint) {\n+fn write_vint(w: &ioivec::buf_writer, n: uint) {\n     if n < 0x7fu { write_sized_vint(w, n, 1u); ret; }\n     if n < 0x4000u { write_sized_vint(w, n, 2u); ret; }\n     if n < 0x200000u { write_sized_vint(w, n, 3u); ret; }\n@@ -148,8 +148,8 @@ fn write_vint(w: &io::buf_writer, n: uint) {\n     fail;\n }\n \n-fn create_writer(w: &io::buf_writer) -> writer {\n-    let size_positions: vec[uint] = [];\n+fn create_writer(w: &ioivec::buf_writer) -> writer {\n+    let size_positions: uint[] = ~[];\n     ret {writer: w, mutable size_positions: size_positions};\n }\n \n@@ -161,17 +161,17 @@ fn start_tag(w: &writer, tag_id: uint) {\n     write_vint(w.writer, tag_id);\n     // Write a placeholder four-byte size.\n \n-    w.size_positions += [w.writer.tell()];\n-    let zeroes: vec[u8] = [0u8, 0u8, 0u8, 0u8];\n+    w.size_positions += ~[w.writer.tell()];\n+    let zeroes: u8[] = ~[0u8, 0u8, 0u8, 0u8];\n     w.writer.write(zeroes);\n }\n \n fn end_tag(w: &writer) {\n-    let last_size_pos = vec::pop[uint](w.size_positions);\n+    let last_size_pos = ivec::pop[uint](w.size_positions);\n     let cur_pos = w.writer.tell();\n-    w.writer.seek(last_size_pos as int, io::seek_set);\n+    w.writer.seek(last_size_pos as int, ioivec::seek_set);\n     write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);\n-    w.writer.seek(cur_pos as int, io::seek_set);\n+    w.writer.seek(cur_pos as int, ioivec::seek_set);\n }\n // TODO: optionally perform \"relaxations\" on end_tag to more efficiently\n // encode sizes; this is a fixed point iteration"}, {"sha": "41e5bf03b1a32d19180c2fd59259fa05e32c7163", "filename": "src/lib/ebmlivec.rs", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/4d7f866eec99d37ef9c3c548ae8916c4f5634717/src%2Flib%2Febmlivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d7f866eec99d37ef9c3c548ae8916c4f5634717/src%2Flib%2Febmlivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febmlivec.rs?ref=4d7f866eec99d37ef9c3c548ae8916c4f5634717", "patch": "@@ -1,177 +0,0 @@\n-\n-\n-// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n-// cursor model. See the specification here:\n-//     http://www.matroska.org/technical/specs/rfc/index.html\n-import option::none;\n-import option::some;\n-\n-type ebml_tag = {id: uint, size: uint};\n-\n-type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n-\n-\n-// TODO: When we have module renaming, make \"reader\" and \"writer\" separate\n-// modules within this file.\n-\n-// ebml reading\n-type doc = {data: @u8[], start: uint, end: uint};\n-\n-fn vint_at(data: &u8[], start: uint) -> {val: uint, next: uint} {\n-    let a = data.(start);\n-    if a & 0x80u8 != 0u8 { ret {val: a & 0x7fu8 as uint, next: start + 1u}; }\n-    if a & 0x40u8 != 0u8 {\n-        ret {val: (a & 0x3fu8 as uint) << 8u | (data.(start + 1u) as uint),\n-             next: start + 2u};\n-    } else if (a & 0x20u8 != 0u8) {\n-        ret {val:\n-                 (a & 0x1fu8 as uint) << 16u |\n-                     (data.(start + 1u) as uint) << 8u |\n-                     (data.(start + 2u) as uint),\n-             next: start + 3u};\n-    } else if (a & 0x10u8 != 0u8) {\n-        ret {val:\n-                 (a & 0x0fu8 as uint) << 24u |\n-                     (data.(start + 1u) as uint) << 16u |\n-                     (data.(start + 2u) as uint) << 8u |\n-                     (data.(start + 3u) as uint),\n-             next: start + 4u};\n-    } else { log_err \"vint too big\"; fail; }\n-}\n-\n-fn new_doc(data: &@u8[]) -> doc {\n-    ret {data: data, start: 0u, end: ivec::len[u8](*data)};\n-}\n-\n-fn doc_at(data: &@u8[], start: uint) -> doc {\n-    let elt_tag = vint_at(*data, start);\n-    let elt_size = vint_at(*data, elt_tag.next);\n-    let end = elt_size.next + elt_size.val;\n-    ret {data: data, start: elt_size.next, end: end};\n-}\n-\n-fn maybe_get_doc(d: doc, tg: uint) -> option::t[doc] {\n-    let pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vint_at(*d.data, pos);\n-        let elt_size = vint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            ret some[doc]({data: d.data, start: elt_size.next, end: pos});\n-        }\n-    }\n-    ret none[doc];\n-}\n-\n-fn get_doc(d: doc, tg: uint) -> doc {\n-    alt maybe_get_doc(d, tg) {\n-      some(d) { ret d; }\n-      none. {\n-        log_err \"failed to find block with tag \" + uint::to_str(tg, 10u);\n-        fail;\n-      }\n-    }\n-}\n-\n-iter docs(d: doc) -> {tag: uint, doc: doc} {\n-    let pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vint_at(*d.data, pos);\n-        let elt_size = vint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        put {tag: elt_tag.val,\n-             doc: {data: d.data, start: elt_size.next, end: pos}};\n-    }\n-}\n-\n-iter tagged_docs(d: doc, tg: uint) -> doc {\n-    let pos = d.start;\n-    while pos < d.end {\n-        let elt_tag = vint_at(*d.data, pos);\n-        let elt_size = vint_at(*d.data, elt_tag.next);\n-        pos = elt_size.next + elt_size.val;\n-        if elt_tag.val == tg {\n-            put {data: d.data, start: elt_size.next, end: pos};\n-        }\n-    }\n-}\n-\n-fn doc_data(d: doc) -> u8[] { ret ivec::slice[u8](*d.data, d.start, d.end); }\n-\n-fn be_uint_from_bytes(data: &@u8[], start: uint, size: uint) -> uint {\n-    let sz = size;\n-    assert (sz <= 4u);\n-    let val = 0u;\n-    let pos = start;\n-    while sz > 0u {\n-        sz -= 1u;\n-        val += (data.(pos) as uint) << sz * 8u;\n-        pos += 1u;\n-    }\n-    ret val;\n-}\n-\n-fn doc_as_uint(d: doc) -> uint {\n-    ret be_uint_from_bytes(d.data, d.start, d.end - d.start);\n-}\n-\n-\n-// ebml writing\n-type writer = {writer: ioivec::buf_writer, mutable size_positions: uint[]};\n-\n-fn write_sized_vint(w: &ioivec::buf_writer, n: uint, size: uint) {\n-    let buf: u8[];\n-    alt size {\n-      1u { buf = ~[0x80u8 | (n as u8)]; }\n-      2u { buf = ~[0x40u8 | (n >> 8u as u8), n & 0xffu as u8]; }\n-      3u {\n-        buf =\n-            ~[0x20u8 | (n >> 16u as u8), n >> 8u & 0xffu as u8,\n-              n & 0xffu as u8];\n-      }\n-      4u {\n-        buf =\n-            ~[0x10u8 | (n >> 24u as u8), n >> 16u & 0xffu as u8,\n-              n >> 8u & 0xffu as u8, n & 0xffu as u8];\n-      }\n-      _ { log_err \"vint to write too big\"; fail; }\n-    }\n-    w.write(buf);\n-}\n-\n-fn write_vint(w: &ioivec::buf_writer, n: uint) {\n-    if n < 0x7fu { write_sized_vint(w, n, 1u); ret; }\n-    if n < 0x4000u { write_sized_vint(w, n, 2u); ret; }\n-    if n < 0x200000u { write_sized_vint(w, n, 3u); ret; }\n-    if n < 0x10000000u { write_sized_vint(w, n, 4u); ret; }\n-    log_err \"vint to write too big\";\n-    fail;\n-}\n-\n-fn create_writer(w: &ioivec::buf_writer) -> writer {\n-    let size_positions: uint[] = ~[];\n-    ret {writer: w, mutable size_positions: size_positions};\n-}\n-\n-\n-// TODO: Provide a function to write the standard ebml header.\n-fn start_tag(w: &writer, tag_id: uint) {\n-    // Write the tag ID:\n-\n-    write_vint(w.writer, tag_id);\n-    // Write a placeholder four-byte size.\n-\n-    w.size_positions += ~[w.writer.tell()];\n-    let zeroes: u8[] = ~[0u8, 0u8, 0u8, 0u8];\n-    w.writer.write(zeroes);\n-}\n-\n-fn end_tag(w: &writer) {\n-    let last_size_pos = ivec::pop[uint](w.size_positions);\n-    let cur_pos = w.writer.tell();\n-    w.writer.seek(last_size_pos as int, ioivec::seek_set);\n-    write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);\n-    w.writer.seek(cur_pos as int, ioivec::seek_set);\n-}\n-// TODO: optionally perform \"relaxations\" on end_tag to more efficiently\n-// encode sizes; this is a fixed point iteration"}, {"sha": "e18642bc46b71e8f27e03ebf1d61ae4504dd1da2", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dda9aabf217d59881970f847b06338d417f6f6f/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3dda9aabf217d59881970f847b06338d417f6f6f/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=3dda9aabf217d59881970f847b06338d417f6f6f", "patch": "@@ -94,7 +94,7 @@ mod smallintmap;\n mod ptr;\n mod test;\n mod unsafe;\n-mod ebmlivec;\n+mod ebmlivec = \"ebml.rs\";\n mod termivec;\n \n // Local Variables:"}]}