{"sha": "55c9842e7d16c3313ae12fbcc2d3a80cc9464190", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1Yzk4NDJlN2QxNmMzMzEzYWUxMmZiY2MyZDNhODBjYzk0NjQxOTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-15T19:06:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-15T19:06:10Z"}, "message": "rustc: Unbreak \"3 as uint < 5u\"", "tree": {"sha": "1ec88791aeca4a357fbaab61f99b24a399913be2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ec88791aeca4a357fbaab61f99b24a399913be2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55c9842e7d16c3313ae12fbcc2d3a80cc9464190", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55c9842e7d16c3313ae12fbcc2d3a80cc9464190", "html_url": "https://github.com/rust-lang/rust/commit/55c9842e7d16c3313ae12fbcc2d3a80cc9464190", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55c9842e7d16c3313ae12fbcc2d3a80cc9464190/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91d83f554716560b8c23821c240affd299c4436a", "url": "https://api.github.com/repos/rust-lang/rust/commits/91d83f554716560b8c23821c240affd299c4436a", "html_url": "https://github.com/rust-lang/rust/commit/91d83f554716560b8c23821c240affd299c4436a"}], "stats": {"total": 108, "additions": 59, "deletions": 49}, "files": [{"sha": "27ded6cdc250b5f9d0e765238f8765850df1cdfa", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 59, "deletions": 49, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/55c9842e7d16c3313ae12fbcc2d3a80cc9464190/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55c9842e7d16c3313ae12fbcc2d3a80cc9464190/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=55c9842e7d16c3313ae12fbcc2d3a80cc9464190", "patch": "@@ -272,7 +272,7 @@ fn parse_ty_fn(proto: ast::proto, p: &parser, lo: uint) -> ast::ty_ {\n             p.bump();\n             mode = ast::alias(eat_word(p, \"mutable\"));\n         }\n-        let t = parse_ty(p);\n+        let t = parse_ty(p, false);\n         ret spanned(lo, t.span.hi, {mode: mode, ty: t});\n     }\n     let lo = p.get_lo_pos();\n@@ -337,7 +337,7 @@ fn parse_ty_obj(p: &parser, hi: &mutable uint) -> ast::ty_ {\n \n fn parse_mt(p: &parser) -> ast::mt {\n     let mut = parse_mutability(p);\n-    let t = parse_ty(p);\n+    let t = parse_ty(p, false);\n     ret {ty: t, mut: mut};\n }\n \n@@ -346,7 +346,7 @@ fn parse_ty_field(p: &parser) -> ast::ty_field {\n     let mut = parse_mutability(p);\n     let id = parse_ident(p);\n     expect(p, token::COLON);\n-    let ty = parse_ty(p);\n+    let ty = parse_ty(p, false);\n     ret spanned(lo, ty.span.hi, {ident: id, mt: {ty: ty, mut: mut}});\n }\n \n@@ -421,46 +421,52 @@ fn parse_type_constraints(p: &parser) -> [@ast::ty_constr] {\n     ret parse_constrs(parse_constr_in_type, p);\n }\n \n-fn parse_ty_postfix(orig_t: ast::ty_, p: &parser) -> @ast::ty {\n+fn parse_ty_postfix(orig_t: ast::ty_, p: &parser, colons_before_params: bool)\n+        -> @ast::ty {\n     let lo = p.get_lo_pos();\n-    if p.peek() == token::LBRACKET || p.peek() == token::LT {\n-        let end;\n-        if p.peek() == token::LBRACKET {\n-            end = token::RBRACKET;\n-        } else {\n-            end = token::GT;\n-        }\n \n-        // This is explicit type parameter instantiation.\n+    let end;\n+    if p.peek() == token::LBRACKET {\n+        p.bump();\n+        end = token::RBRACKET;\n+    } else if colons_before_params && p.peek() == token::MOD_SEP {\n+        p.bump();\n+        expect(p, token::LT);\n+        end = token::GT;\n+    } else if !colons_before_params && p.peek() == token::LT {\n         p.bump();\n+        end = token::GT;\n+    } else {\n+        ret @spanned(lo, p.get_lo_pos(), orig_t);\n+    }\n \n-        let seq = parse_seq_to_end(end, some(token::COMMA), parse_ty, p);\n+    // If we're here, we have explicit type parameter instantiation.\n+    let seq = parse_seq_to_end(end, some(token::COMMA),\n+                               bind parse_ty(_, false), p);\n \n-        alt orig_t {\n-          ast::ty_path(pth, ann) {\n-            let hi = p.get_hi_pos();\n-            ret @spanned(lo, hi,\n-                         ast::ty_path(spanned(lo, hi,\n-                                              {global: pth.node.global,\n-                                               idents: pth.node.idents,\n-                                               types: seq}), ann));\n-          }\n-          _ {\n-            p.fatal(\"type parameter instantiation only allowed for paths\");\n-          }\n-        }\n+    alt orig_t {\n+      ast::ty_path(pth, ann) {\n+        let hi = p.get_hi_pos();\n+        ret @spanned(lo, hi,\n+                     ast::ty_path(spanned(lo, hi,\n+                                          {global: pth.node.global,\n+                                           idents: pth.node.idents,\n+                                           types: seq}), ann));\n+      }\n+      _ {\n+        p.fatal(\"type parameter instantiation only allowed for paths\");\n+      }\n     }\n-    ret @spanned(lo, p.get_lo_pos(), orig_t);\n }\n \n fn parse_ty_or_bang(p: &parser) -> ty_or_bang {\n     alt p.peek() {\n       token::NOT. { p.bump(); ret a_bang; }\n-      _ { ret a_ty(parse_ty(p)); }\n+      _ { ret a_ty(parse_ty(p, false)); }\n     }\n }\n \n-fn parse_ty(p: &parser) -> @ast::ty {\n+fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n     let lo = p.get_lo_pos();\n     let hi = lo;\n     let t: ast::ty_;\n@@ -511,10 +517,10 @@ fn parse_ty(p: &parser) -> @ast::ty {\n             p.bump();\n             t = ast::ty_nil;\n         } else {\n-            let ts = ~[parse_ty(p)];\n+            let ts = ~[parse_ty(p, false)];\n             while p.peek() == token::COMMA {\n                 p.bump();\n-                ts += ~[parse_ty(p)];\n+                ts += ~[parse_ty(p, false)];\n             }\n             if ivec::len(ts) == 1u {\n                 t = ts.(0).node;\n@@ -572,25 +578,25 @@ fn parse_ty(p: &parser) -> @ast::ty {\n         t = parse_ty_obj(p, hi);\n     } else if (eat_word(p, \"port\")) {\n         expect(p, token::LBRACKET);\n-        t = ast::ty_port(parse_ty(p));\n+        t = ast::ty_port(parse_ty(p, false));\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"chan\")) {\n         expect(p, token::LBRACKET);\n-        t = ast::ty_chan(parse_ty(p));\n+        t = ast::ty_chan(parse_ty(p, false));\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"mutable\")) {\n         p.warn(\"ignoring deprecated 'mutable' type constructor\");\n-        let typ = parse_ty(p);\n+        let typ = parse_ty(p, false);\n         t = typ.node;\n         hi = typ.span.hi;\n     } else if (p.peek() == token::MOD_SEP || is_ident(p.peek())) {\n         let path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n         hi = path.span.hi;\n     } else { p.fatal(\"expecting type\"); }\n-    ret parse_ty_postfix(t, p);\n+    ret parse_ty_postfix(t, p, colons_before_params);\n }\n \n fn parse_arg(p: &parser) -> ast::arg {\n@@ -602,7 +608,7 @@ fn parse_arg(p: &parser) -> ast::arg {\n     } else if eat(p, token::BINOP(token::MINUS)) {\n         m = ast::move;\n     }\n-    let t: @ast::ty = parse_ty(p);\n+    let t: @ast::ty = parse_ty(p, false);\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n@@ -706,7 +712,11 @@ fn parse_path(p: &parser) -> ast::path {\n             ids += ~[p.get_str(i)];\n             hi = p.get_hi_pos();\n             p.bump();\n-            if p.peek() == token::MOD_SEP { p.bump(); } else { break; }\n+            if p.peek() == token::MOD_SEP && p.look_ahead(1u) != token::LT {\n+                p.bump();\n+            } else {\n+                break;\n+            }\n           }\n           _ { break; }\n         }\n@@ -720,7 +730,7 @@ fn parse_path_and_ty_param_substs(p: &parser) -> ast::path {\n     if p.peek() == token::LBRACKET {\n         let seq =\n             parse_seq(token::LBRACKET, token::RBRACKET, some(token::COMMA),\n-                      parse_ty, p);\n+                      bind parse_ty(_, false), p);\n         let hi = seq.span.hi;\n         path =\n             spanned(lo, hi,\n@@ -830,7 +840,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         ex = ast::expr_vec(es, mut, ast::sk_rc);\n     } else if (p.peek() == token::POUND_LT) {\n         p.bump();\n-        let ty = parse_ty(p);\n+        let ty = parse_ty(p, false);\n         expect(p, token::GT);\n \n         /* hack: early return to take advantage of specialized function */\n@@ -976,7 +986,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         let ty = @spanned(lo, hi, ast::ty_infer);\n         if token::LBRACKET == p.peek() {\n             expect(p, token::LBRACKET);\n-            ty = parse_ty(p);\n+            ty = parse_ty(p, false);\n             expect(p, token::RBRACKET);\n         }\n         expect(p, token::LPAREN);\n@@ -1201,7 +1211,7 @@ fn parse_more_binops(p: &parser, lhs: @ast::expr, min_prec: int) ->\n         }\n     }\n     if as_prec > min_prec && eat_word(p, \"as\") {\n-        let rhs = parse_ty(p);\n+        let rhs = parse_ty(p, true);\n         let _as =\n             mk_expr(p, lhs.span.lo, rhs.span.hi, ast::expr_cast(lhs, rhs));\n         ret parse_more_binops(p, _as, min_prec);\n@@ -1521,7 +1531,7 @@ fn parse_local(p: &parser, allow_init: bool) -> @ast::local {\n     let lo = p.get_lo_pos();\n     let pat = parse_pat(p);\n     let ty = @spanned(lo, lo, ast::ty_infer);\n-    if eat(p, token::COLON) { ty = parse_ty(p); }\n+    if eat(p, token::COLON) { ty = parse_ty(p, false); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n     ret @spanned(lo, p.get_last_hi_pos(),\n                  {ty: ty,\n@@ -1814,15 +1824,15 @@ fn parse_obj_field(p: &parser) -> ast::obj_field {\n     let mut = parse_mutability(p);\n     let ident = parse_value_ident(p);\n     expect(p, token::COLON);\n-    let ty = parse_ty(p);\n+    let ty = parse_ty(p, false);\n     ret {mut: mut, ty: ty, ident: ident, id: p.get_id()};\n }\n \n fn parse_anon_obj_field(p: &parser) -> ast::anon_obj_field {\n     let mut = parse_mutability(p);\n     let ident = parse_value_ident(p);\n     expect(p, token::COLON);\n-    let ty = parse_ty(p);\n+    let ty = parse_ty(p, false);\n     expect(p, token::EQ);\n     let expr = parse_expr(p);\n     ret {mut: mut, ty: ty, expr: expr, ident: ident, id: p.get_id()};\n@@ -1865,7 +1875,7 @@ fn parse_item_res(p: &parser, attrs: &[ast::attribute]) ->\n     expect(p, token::LPAREN);\n     let arg_ident = parse_value_ident(p);\n     expect(p, token::COLON);\n-    let t = parse_ty(p);\n+    let t = parse_ty(p, false);\n     expect(p, token::RPAREN);\n     let dtor = parse_block(p);\n     let decl =\n@@ -1909,7 +1919,7 @@ fn parse_item_const(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_value_ident(p);\n     expect(p, token::COLON);\n-    let ty = parse_ty(p);\n+    let ty = parse_ty(p, false);\n     expect(p, token::EQ);\n     let e = parse_expr(p);\n     let hi = p.get_hi_pos();\n@@ -2031,7 +2041,7 @@ fn parse_item_type(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let t = parse_type_decl(p);\n     let tps = parse_ty_params(p);\n     expect(p, token::EQ);\n-    let ty = parse_ty(p);\n+    let ty = parse_ty(p, false);\n     let hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps), attrs);\n@@ -2048,7 +2058,7 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n             p.fatal(\"found \" + id + \" in tag constructor position\");\n         }\n         p.bump();\n-        let ty = parse_ty(p);\n+        let ty = parse_ty(p, false);\n         expect(p, token::SEMI);\n         let variant =\n             spanned(ty.span.lo, ty.span.hi,\n@@ -2072,7 +2082,7 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n               token::LPAREN. {\n                 let arg_tys =\n                     parse_seq(token::LPAREN, token::RPAREN,\n-                              some(token::COMMA), parse_ty, p);\n+                              some(token::COMMA), bind parse_ty(_, false), p);\n                 for ty: @ast::ty  in arg_tys.node {\n                     args += ~[{ty: ty, id: p.get_id()}];\n                 }"}]}