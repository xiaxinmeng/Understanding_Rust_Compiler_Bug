{"sha": "7d15250b0e5180137f5055b2e4333d5aac6579fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMTUyNTBiMGU1MTgwMTM3ZjUwNTViMmU0MzMzZDVhYWM2NTc5ZmU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-10-22T00:33:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-11-24T21:43:00Z"}, "message": "Support `?Sized` in where clauses", "tree": {"sha": "4e55f5d402a1ad0a799927d9c69a8b7fc933f63a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e55f5d402a1ad0a799927d9c69a8b7fc933f63a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d15250b0e5180137f5055b2e4333d5aac6579fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d15250b0e5180137f5055b2e4333d5aac6579fe", "html_url": "https://github.com/rust-lang/rust/commit/7d15250b0e5180137f5055b2e4333d5aac6579fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d15250b0e5180137f5055b2e4333d5aac6579fe/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a31ad75bdedab55ca290332edda9acbd2d5a0157", "url": "https://api.github.com/repos/rust-lang/rust/commits/a31ad75bdedab55ca290332edda9acbd2d5a0157", "html_url": "https://github.com/rust-lang/rust/commit/a31ad75bdedab55ca290332edda9acbd2d5a0157"}], "stats": {"total": 196, "additions": 161, "deletions": 35}, "files": [{"sha": "ce80f617afdd95817d39244cbb61ccf221f25ad8", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7d15250b0e5180137f5055b2e4333d5aac6579fe", "patch": "@@ -46,6 +46,7 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n+use util::nodemap::NodeMap;\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -394,7 +395,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_param(&mut self, tp: &TyParam) -> hir::TyParam {\n+    fn lower_ty_param(&mut self, tp: &TyParam, add_bounds: &[TyParamBound]) -> hir::TyParam {\n         let mut name = tp.ident.name;\n \n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n@@ -404,18 +405,26 @@ impl<'a> LoweringContext<'a> {\n             name = Symbol::gensym(\"Self\");\n         }\n \n+        let mut bounds = self.lower_bounds(&tp.bounds);\n+        if !add_bounds.is_empty() {\n+            bounds = bounds.into_iter().chain(self.lower_bounds(add_bounds).into_iter()).collect();\n+        }\n+\n         hir::TyParam {\n             id: tp.id,\n             name: name,\n-            bounds: self.lower_bounds(&tp.bounds),\n+            bounds: bounds,\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n             span: tp.span,\n             pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n \n-    fn lower_ty_params(&mut self, tps: &P<[TyParam]>) -> hir::HirVec<hir::TyParam> {\n-        tps.iter().map(|tp| self.lower_ty_param(tp)).collect()\n+    fn lower_ty_params(&mut self, tps: &P<[TyParam]>, add_bounds: &NodeMap<Vec<TyParamBound>>)\n+                       -> hir::HirVec<hir::TyParam> {\n+        tps.iter().map(|tp| {\n+            self.lower_ty_param(tp, add_bounds.get(&tp.id).map_or(&[][..], |x| &x))\n+        }).collect()\n     }\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n@@ -447,8 +456,47 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_generics(&mut self, g: &Generics) -> hir::Generics {\n+        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n+        let mut add_bounds = NodeMap();\n+        for pred in &g.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n+                'next_bound: for bound in &bound_pred.bounds {\n+                    if let TraitTyParamBound(_, TraitBoundModifier::Maybe) = *bound {\n+                        let report_error = |this: &mut Self| {\n+                            this.diagnostic().span_err(bound_pred.bounded_ty.span,\n+                                                       \"`?Trait` bounds are only permitted at the \\\n+                                                        point where a type parameter is declared\");\n+                        };\n+                        // Check if the where clause type is a plain type parameter.\n+                        match bound_pred.bounded_ty.node {\n+                            TyKind::Path(None, ref path)\n+                                    if !path.global && path.segments.len() == 1 &&\n+                                        bound_pred.bound_lifetimes.is_empty() => {\n+                                if let Some(Def::TyParam(def_id)) =\n+                                        self.resolver.get_resolution(bound_pred.bounded_ty.id)\n+                                                     .map(|d| d.base_def) {\n+                                    if let Some(node_id) =\n+                                            self.resolver.definitions().as_local_node_id(def_id) {\n+                                        for ty_param in &g.ty_params {\n+                                            if node_id == ty_param.id {\n+                                                add_bounds.entry(ty_param.id).or_insert(Vec::new())\n+                                                                            .push(bound.clone());\n+                                                continue 'next_bound;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                report_error(self)\n+                            }\n+                            _ => report_error(self)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         hir::Generics {\n-            ty_params: self.lower_ty_params(&g.ty_params),\n+            ty_params: self.lower_ty_params(&g.ty_params, &add_bounds),\n             lifetimes: self.lower_lifetime_defs(&g.lifetimes),\n             where_clause: self.lower_where_clause(&g.where_clause),\n             span: g.span,\n@@ -474,7 +522,11 @@ impl<'a> LoweringContext<'a> {\n                 hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     bound_lifetimes: self.lower_lifetime_defs(bound_lifetimes),\n                     bounded_ty: self.lower_ty(bounded_ty),\n-                    bounds: bounds.iter().map(|x| self.lower_ty_param_bound(x)).collect(),\n+                    bounds: bounds.iter().filter_map(|bound| match *bound {\n+                        // Ignore `?Trait` bounds, they were copied into type parameters already.\n+                        TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                        _ => Some(self.lower_ty_param_bound(bound))\n+                    }).collect(),\n                     span: span,\n                 })\n             }\n@@ -563,7 +615,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_bounds(&mut self, bounds: &TyParamBounds) -> hir::TyParamBounds {\n+    fn lower_bounds(&mut self, bounds: &[TyParamBound]) -> hir::TyParamBounds {\n         bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n     }\n "}, {"sha": "fa07006aa63e1da6312dbb2d2d744df1424a2426", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=7d15250b0e5180137f5055b2e4333d5aac6579fe", "patch": "@@ -86,6 +86,19 @@ impl<'a> AstValidator<'a> {\n             _ => {}\n         }\n     }\n+\n+    fn no_questions_in_bounds(&self, bounds: &TyParamBounds, where_: &str, is_trait: bool) {\n+        for bound in bounds {\n+            if let TraitTyParamBound(ref poly, TraitBoundModifier::Maybe) = *bound {\n+                let mut err = self.err_handler().struct_span_err(poly.span,\n+                                    &format!(\"`?Trait` is not permitted in {}\", where_));\n+                if is_trait {\n+                    err.note(&format!(\"traits are `?{}` by default\", poly.trait_ref.path));\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n }\n \n impl<'a> Visitor for AstValidator<'a> {\n@@ -130,6 +143,10 @@ impl<'a> Visitor for AstValidator<'a> {\n                     err.emit();\n                 });\n             }\n+            TyKind::ObjectSum(_, ref bounds) |\n+            TyKind::PolyTraitRef(ref bounds) => {\n+                self.no_questions_in_bounds(bounds, \"trait object types\", false);\n+            }\n             _ => {}\n         }\n \n@@ -189,7 +206,8 @@ impl<'a> Visitor for AstValidator<'a> {\n                     }\n                 }\n             }\n-            ItemKind::Trait(.., ref trait_items) => {\n+            ItemKind::Trait(.., ref bounds, ref trait_items) => {\n+                self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n                         self.check_trait_fn_not_const(sig.constness);"}, {"sha": "bdd1606805fefa2573a98230d581b3f858916e4f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7d15250b0e5180137f5055b2e4333d5aac6579fe", "patch": "@@ -88,13 +88,6 @@ pub enum PathStyle {\n     Expr,\n }\n \n-/// How to parse a bound, whether to allow bound modifiers such as `?`.\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum BoundParsingMode {\n-    Bare,\n-    Modified,\n-}\n-\n #[derive(Clone, Copy, PartialEq)]\n pub enum SemiColonMode {\n     Break,\n@@ -1041,7 +1034,7 @@ impl<'a> Parser<'a> {\n                                                      trait_ref: trait_ref,\n                                                      span: mk_sp(lo, hi)};\n             let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n-                self.parse_ty_param_bounds(BoundParsingMode::Bare)?\n+                self.parse_ty_param_bounds()?\n             } else {\n                 P::new()\n             };\n@@ -1059,7 +1052,7 @@ impl<'a> Parser<'a> {\n         The `impl` has already been consumed.\n         */\n \n-        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Modified)?;\n+        let bounds = self.parse_ty_param_bounds()?;\n \n         if !bounds.iter().any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n             self.span_err(self.prev_span, \"at least one trait must be specified\");\n@@ -1271,7 +1264,7 @@ impl<'a> Parser<'a> {\n             return Ok(lhs);\n         }\n \n-        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Bare)?;\n+        let bounds = self.parse_ty_param_bounds()?;\n \n         // In type grammar, `+` is treated like a binary operator,\n         // and hence both L and R side are required.\n@@ -4148,24 +4141,20 @@ impl<'a> Parser<'a> {\n \n     // Parses a sequence of bounds if a `:` is found,\n     // otherwise returns empty list.\n-    fn parse_colon_then_ty_param_bounds(&mut self,\n-                                        mode: BoundParsingMode)\n-                                        -> PResult<'a, TyParamBounds>\n+    fn parse_colon_then_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n     {\n         if !self.eat(&token::Colon) {\n             Ok(P::new())\n         } else {\n-            self.parse_ty_param_bounds(mode)\n+            self.parse_ty_param_bounds()\n         }\n     }\n \n     // matches bounds    = ( boundseq )?\n     // where   boundseq  = ( polybound + boundseq ) | polybound\n     // and     polybound = ( 'for' '<' 'region '>' )? bound\n     // and     bound     = 'region | trait_ref\n-    fn parse_ty_param_bounds(&mut self,\n-                             mode: BoundParsingMode)\n-                             -> PResult<'a, TyParamBounds>\n+    fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n     {\n         let mut result = vec![];\n         loop {\n@@ -4187,13 +4176,7 @@ impl<'a> Parser<'a> {\n                 token::ModSep | token::Ident(..) => {\n                     let poly_trait_ref = self.parse_poly_trait_ref()?;\n                     let modifier = if ate_question {\n-                        if mode == BoundParsingMode::Modified {\n-                            TraitBoundModifier::Maybe\n-                        } else {\n-                            self.span_err(question_span,\n-                                          \"unexpected `?`\");\n-                            TraitBoundModifier::None\n-                        }\n+                        TraitBoundModifier::Maybe\n                     } else {\n                         TraitBoundModifier::None\n                     };\n@@ -4215,7 +4198,7 @@ impl<'a> Parser<'a> {\n         let span = self.span;\n         let ident = self.parse_ident()?;\n \n-        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified)?;\n+        let bounds = self.parse_colon_then_ty_param_bounds()?;\n \n         let default = if self.check(&token::Eq) {\n             self.bump();\n@@ -4439,7 +4422,7 @@ impl<'a> Parser<'a> {\n                     let bounded_ty = self.parse_ty()?;\n \n                     if self.eat(&token::Colon) {\n-                        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Bare)?;\n+                        let bounds = self.parse_ty_param_bounds()?;\n                         let hi = self.prev_span.hi;\n                         let span = mk_sp(lo, hi);\n \n@@ -4901,7 +4884,7 @@ impl<'a> Parser<'a> {\n         let mut tps = self.parse_generics()?;\n \n         // Parse supertrait bounds.\n-        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare)?;\n+        let bounds = self.parse_colon_then_ty_param_bounds()?;\n \n         tps.where_clause = self.parse_where_clause()?;\n "}, {"sha": "f10526200ff141c675cda3b11162dff196f11ba7", "filename": "src/test/compile-fail/maybe-bounds-where-cpass.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where-cpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where-cpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where-cpass.rs?ref=7d15250b0e5180137f5055b2e4333d5aac6579fe", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+struct S<T>(*const T) where T: ?Sized;\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+    let u = vec![1, 2, 3];\n+    let _s: S<[u8]> = S(&u[..]);\n+}"}, {"sha": "211fac2ee234c2c047d8f7c0df3a1e809d1b331f", "filename": "src/test/compile-fail/maybe-bounds-where.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds-where.rs?ref=7d15250b0e5180137f5055b2e4333d5aac6579fe", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S1<T>(T) where (T): ?Sized;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+struct S2<T>(T) where u8: ?Sized;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+struct S3<T>(T) where &'static T: ?Sized;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+trait Trait<'a> {}\n+\n+struct S4<T>(T) where for<'a> T: ?Trait<'a>;\n+//~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+\n+struct S5<T>(*const T) where T: ?Trait<'static> + ?Sized;\n+//~^ ERROR type parameter has more than one relaxed default bound\n+//~| WARN default bound relaxed for a type parameter\n+\n+impl<T> S1<T> {\n+    fn f() where T: ?Sized {}\n+    //~^ ERROR `?Trait` bounds are only permitted at the point where a type parameter is declared\n+}\n+\n+fn main() {\n+    let u = vec![1, 2, 3];\n+    let _s: S5<[u8]> = S5(&u[..]); // OK\n+}"}, {"sha": "b0b412bbf89ecc37657608cf734f1be909b812af", "filename": "src/test/compile-fail/maybe-bounds.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d15250b0e5180137f5055b2e4333d5aac6579fe/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmaybe-bounds.rs?ref=7d15250b0e5180137f5055b2e4333d5aac6579fe", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Tr: ?Sized {} //~ ERROR `?Trait` is not permitted in supertraits\n+                    //~^ NOTE traits are `?Sized` by default\n+\n+type A1 = Tr + ?Sized; //~ ERROR `?Trait` is not permitted in trait object types\n+type A2 = for<'a> Tr + ?Sized; //~ ERROR `?Trait` is not permitted in trait object types\n+\n+fn main() {}"}]}