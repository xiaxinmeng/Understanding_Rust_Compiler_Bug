{"sha": "ea7e131435a960d154e9a5d6a9297039574ffd7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhN2UxMzE0MzVhOTYwZDE1NGU5YTVkNmE5Mjk3MDM5NTc0ZmZkN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-05T17:18:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-05T17:18:01Z"}, "message": "Auto merge of #77171 - VFLashM:better_sso_structures, r=oli-obk\n\nBetter sso structures\n\nThis change greatly expands interface of MiniSet/MiniMap and renames them because they are no longer \"Mini\".", "tree": {"sha": "e380e7fbfbd156f4bb07a0bd4b0c34e2941a1e2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e380e7fbfbd156f4bb07a0bd4b0c34e2941a1e2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea7e131435a960d154e9a5d6a9297039574ffd7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea7e131435a960d154e9a5d6a9297039574ffd7d", "html_url": "https://github.com/rust-lang/rust/commit/ea7e131435a960d154e9a5d6a9297039574ffd7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea7e131435a960d154e9a5d6a9297039574ffd7d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f317a93d4d326442680eaeb78c22eece739433c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f317a93d4d326442680eaeb78c22eece739433c7", "html_url": "https://github.com/rust-lang/rust/commit/f317a93d4d326442680eaeb78c22eece739433c7"}, {"sha": "d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a", "html_url": "https://github.com/rust-lang/rust/commit/d1d2184db407dbdc0a0872c9efb4ff58457e1c9a"}], "stats": {"total": 1029, "additions": 902, "deletions": 127}, "files": [{"sha": "9958e5dd5e0ee5f67d828e970924f2301554928a", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -100,8 +100,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n-pub mod mini_map;\n-pub mod mini_set;\n+pub mod sso;\n pub mod tagged_ptr;\n pub mod temp_dir;\n pub mod unhash;"}, {"sha": "cd3e949d3831aaaa9b531f67649634c365098a7e", "filename": "compiler/rustc_data_structures/src/mini_map.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f317a93d4d326442680eaeb78c22eece739433c7/compiler%2Frustc_data_structures%2Fsrc%2Fmini_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f317a93d4d326442680eaeb78c22eece739433c7/compiler%2Frustc_data_structures%2Fsrc%2Fmini_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmini_map.rs?ref=f317a93d4d326442680eaeb78c22eece739433c7", "patch": "@@ -1,61 +0,0 @@\n-use crate::fx::FxHashMap;\n-use arrayvec::ArrayVec;\n-\n-use std::hash::Hash;\n-\n-/// Small-storage-optimized implementation of a map\n-/// made specifically for caching results.\n-///\n-/// Stores elements in a small array up to a certain length\n-/// and switches to `HashMap` when that length is exceeded.\n-pub enum MiniMap<K, V> {\n-    Array(ArrayVec<[(K, V); 8]>),\n-    Map(FxHashMap<K, V>),\n-}\n-\n-impl<K: Eq + Hash, V> MiniMap<K, V> {\n-    /// Creates an empty `MiniMap`.\n-    pub fn new() -> Self {\n-        MiniMap::Array(ArrayVec::new())\n-    }\n-\n-    /// Inserts or updates value in the map.\n-    pub fn insert(&mut self, key: K, value: V) {\n-        match self {\n-            MiniMap::Array(array) => {\n-                for pair in array.iter_mut() {\n-                    if pair.0 == key {\n-                        pair.1 = value;\n-                        return;\n-                    }\n-                }\n-                if let Err(error) = array.try_push((key, value)) {\n-                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n-                    let (key, value) = error.element();\n-                    map.insert(key, value);\n-                    *self = MiniMap::Map(map);\n-                }\n-            }\n-            MiniMap::Map(map) => {\n-                map.insert(key, value);\n-            }\n-        }\n-    }\n-\n-    /// Return value by key if any.\n-    pub fn get(&self, key: &K) -> Option<&V> {\n-        match self {\n-            MiniMap::Array(array) => {\n-                for pair in array {\n-                    if pair.0 == *key {\n-                        return Some(&pair.1);\n-                    }\n-                }\n-                return None;\n-            }\n-            MiniMap::Map(map) => {\n-                return map.get(key);\n-            }\n-        }\n-    }\n-}"}, {"sha": "9d45af723deb673463a75aac988cbff7c6282ecb", "filename": "compiler/rustc_data_structures/src/mini_set.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f317a93d4d326442680eaeb78c22eece739433c7/compiler%2Frustc_data_structures%2Fsrc%2Fmini_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f317a93d4d326442680eaeb78c22eece739433c7/compiler%2Frustc_data_structures%2Fsrc%2Fmini_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmini_set.rs?ref=f317a93d4d326442680eaeb78c22eece739433c7", "patch": "@@ -1,41 +0,0 @@\n-use crate::fx::FxHashSet;\n-use arrayvec::ArrayVec;\n-use std::hash::Hash;\n-/// Small-storage-optimized implementation of a set.\n-///\n-/// Stores elements in a small array up to a certain length\n-/// and switches to `HashSet` when that length is exceeded.\n-pub enum MiniSet<T> {\n-    Array(ArrayVec<[T; 8]>),\n-    Set(FxHashSet<T>),\n-}\n-\n-impl<T: Eq + Hash> MiniSet<T> {\n-    /// Creates an empty `MiniSet`.\n-    pub fn new() -> Self {\n-        MiniSet::Array(ArrayVec::new())\n-    }\n-\n-    /// Adds a value to the set.\n-    ///\n-    /// If the set did not have this value present, true is returned.\n-    ///\n-    /// If the set did have this value present, false is returned.\n-    pub fn insert(&mut self, elem: T) -> bool {\n-        match self {\n-            MiniSet::Array(array) => {\n-                if array.iter().any(|e| *e == elem) {\n-                    false\n-                } else {\n-                    if let Err(error) = array.try_push(elem) {\n-                        let mut set: FxHashSet<T> = array.drain(..).collect();\n-                        set.insert(error.element());\n-                        *self = MiniSet::Set(set);\n-                    }\n-                    true\n-                }\n-            }\n-            MiniSet::Set(set) => set.insert(elem),\n-        }\n-    }\n-}"}, {"sha": "af8ffcf4c13a58ba2f9b7ff70fe69d00bec0ea61", "filename": "compiler/rustc_data_structures/src/sso/either_iter.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Feither_iter.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -0,0 +1,75 @@\n+use std::fmt;\n+use std::iter::ExactSizeIterator;\n+use std::iter::FusedIterator;\n+use std::iter::Iterator;\n+\n+/// Iterator which may contain instance of\n+/// one of two specific implementations.\n+///\n+/// Note: For most methods providing custom\n+///       implementation may margianlly\n+///       improve performance by avoiding\n+///       doing Left/Right match on every step\n+///       and doing it only once instead.\n+#[derive(Clone)]\n+pub enum EitherIter<L, R> {\n+    Left(L),\n+    Right(R),\n+}\n+\n+impl<L, R> Iterator for EitherIter<L, R>\n+where\n+    L: Iterator,\n+    R: Iterator<Item = L::Item>,\n+{\n+    type Item = L::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self {\n+            EitherIter::Left(l) => l.next(),\n+            EitherIter::Right(r) => r.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self {\n+            EitherIter::Left(l) => l.size_hint(),\n+            EitherIter::Right(r) => r.size_hint(),\n+        }\n+    }\n+}\n+\n+impl<L, R> ExactSizeIterator for EitherIter<L, R>\n+where\n+    L: ExactSizeIterator,\n+    R: ExactSizeIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+    fn len(&self) -> usize {\n+        match self {\n+            EitherIter::Left(l) => l.len(),\n+            EitherIter::Right(r) => r.len(),\n+        }\n+    }\n+}\n+\n+impl<L, R> FusedIterator for EitherIter<L, R>\n+where\n+    L: FusedIterator,\n+    R: FusedIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+}\n+\n+impl<L, R> fmt::Debug for EitherIter<L, R>\n+where\n+    L: fmt::Debug,\n+    R: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            EitherIter::Left(l) => l.fmt(f),\n+            EitherIter::Right(r) => r.fmt(f),\n+        }\n+    }\n+}"}, {"sha": "fa510e58314af06fcdf9c78754f0c78cfc26852d", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -0,0 +1,560 @@\n+use super::either_iter::EitherIter;\n+use crate::fx::FxHashMap;\n+use arrayvec::ArrayVec;\n+use std::fmt;\n+use std::hash::Hash;\n+use std::iter::FromIterator;\n+use std::ops::Index;\n+\n+// For pointer-sized arguments arrays\n+// are faster than set/map for up to 64\n+// arguments.\n+//\n+// On the other hand such a big array\n+// hurts cache performance, makes passing\n+// sso structures around very expensive.\n+//\n+// Biggest performance benefit is gained\n+// for reasonably small arrays that stay\n+// small in vast majority of cases.\n+//\n+// '8' is choosen as a sane default, to be\n+// reevaluated later.\n+//\n+// Note: As of now ArrayVec design prevents\n+//       us from making it user-customizable.\n+const SSO_ARRAY_SIZE: usize = 8;\n+\n+/// Small-storage-optimized implementation of a map.\n+///\n+/// Stores elements in a small array up to a certain length\n+/// and switches to `HashMap` when that length is exceeded.\n+//\n+// FIXME: Implements subset of HashMap API.\n+//\n+// Missing HashMap API:\n+//   all hasher-related\n+//   try_reserve (unstable)\n+//   shrink_to (unstable)\n+//   drain_filter (unstable)\n+//   into_keys/into_values (unstable)\n+//   all raw_entry-related\n+//   PartialEq/Eq (requires sorting the array)\n+//   Entry::or_insert_with_key (unstable)\n+//   Vacant/Occupied entries and related\n+//\n+// FIXME: In HashMap most methods accepting key reference\n+// accept reference to generic `Q` where `K: Borrow<Q>`.\n+//\n+// However, using this approach in `HashMap::get` apparently\n+// breaks inlining and noticeably reduces performance.\n+//\n+// Performance *should* be the same given that borrow is\n+// a NOP in most cases, but in practice that's not the case.\n+//\n+// Further investigation is required.\n+//\n+// Affected methods:\n+//   SsoHashMap::get\n+//   SsoHashMap::get_mut\n+//   SsoHashMap::get_entry\n+//   SsoHashMap::get_key_value\n+//   SsoHashMap::contains_key\n+//   SsoHashMap::remove\n+//   SsoHashMap::remove_entry\n+//   Index::index\n+//   SsoHashSet::take\n+//   SsoHashSet::get\n+//   SsoHashSet::remove\n+//   SsoHashSet::contains\n+\n+#[derive(Clone)]\n+pub enum SsoHashMap<K, V> {\n+    Array(ArrayVec<[(K, V); SSO_ARRAY_SIZE]>),\n+    Map(FxHashMap<K, V>),\n+}\n+\n+impl<K, V> SsoHashMap<K, V> {\n+    /// Creates an empty `SsoHashMap`.\n+    #[inline]\n+    pub fn new() -> Self {\n+        SsoHashMap::Array(ArrayVec::new())\n+    }\n+\n+    /// Creates an empty `SsoHashMap` with the specified capacity.\n+    pub fn with_capacity(cap: usize) -> Self {\n+        if cap <= SSO_ARRAY_SIZE {\n+            Self::new()\n+        } else {\n+            SsoHashMap::Map(FxHashMap::with_capacity_and_hasher(cap, Default::default()))\n+        }\n+    }\n+\n+    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n+    pub fn clear(&mut self) {\n+        match self {\n+            SsoHashMap::Array(array) => array.clear(),\n+            SsoHashMap::Map(map) => map.clear(),\n+        }\n+    }\n+\n+    /// Returns the number of elements the map can hold without reallocating.\n+    pub fn capacity(&self) -> usize {\n+        match self {\n+            SsoHashMap::Array(_) => SSO_ARRAY_SIZE,\n+            SsoHashMap::Map(map) => map.capacity(),\n+        }\n+    }\n+\n+    /// Returns the number of elements in the map.\n+    pub fn len(&self) -> usize {\n+        match self {\n+            SsoHashMap::Array(array) => array.len(),\n+            SsoHashMap::Map(map) => map.len(),\n+        }\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    pub fn is_empty(&self) -> bool {\n+        match self {\n+            SsoHashMap::Array(array) => array.is_empty(),\n+            SsoHashMap::Map(map) => map.is_empty(),\n+        }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order.\n+    /// The iterator element type is `(&'a K, &'a V)`.\n+    #[inline]\n+    pub fn iter(&self) -> <&Self as IntoIterator>::IntoIter {\n+        self.into_iter()\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order,\n+    /// with mutable references to the values.\n+    /// The iterator element type is `(&'a K, &'a mut V)`.\n+    #[inline]\n+    pub fn iter_mut(&mut self) -> impl Iterator<Item = (&'_ K, &'_ mut V)> {\n+        self.into_iter()\n+    }\n+\n+    /// An iterator visiting all keys in arbitrary order.\n+    /// The iterator element type is `&'a K`.\n+    pub fn keys(&self) -> impl Iterator<Item = &'_ K> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(k, _v)| k)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.keys()),\n+        }\n+    }\n+\n+    /// An iterator visiting all values in arbitrary order.\n+    /// The iterator element type is `&'a V`.\n+    pub fn values(&self) -> impl Iterator<Item = &'_ V> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.values()),\n+        }\n+    }\n+\n+    /// An iterator visiting all values mutably in arbitrary order.\n+    /// The iterator element type is `&'a mut V`.\n+    pub fn values_mut(&mut self) -> impl Iterator<Item = &'_ mut V> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter_mut().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.values_mut()),\n+        }\n+    }\n+\n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    pub fn drain(&mut self) -> impl Iterator<Item = (K, V)> + '_ {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.drain(..)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.drain()),\n+        }\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n+    /// Changes underlying storage from array to hashmap\n+    /// if array is full.\n+    fn migrate_if_full(&mut self) {\n+        if let SsoHashMap::Array(array) = self {\n+            if array.is_full() {\n+                *self = SsoHashMap::Map(array.drain(..).collect());\n+            }\n+        }\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `SsoHashMap`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    pub fn reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if SSO_ARRAY_SIZE < (array.len() + additional) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    map.reserve(additional);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.reserve(additional),\n+        }\n+    }\n+\n+    /// Shrinks the capacity of the map as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    pub fn shrink_to_fit(&mut self) {\n+        if let SsoHashMap::Map(map) = self {\n+            if map.len() <= SSO_ARRAY_SIZE {\n+                *self = SsoHashMap::Array(map.drain().collect());\n+            } else {\n+                map.shrink_to_fit();\n+            }\n+        }\n+    }\n+\n+    /// Retains only the elements specified by the predicate.\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => array.retain(|(k, v)| f(k, v)),\n+            SsoHashMap::Map(map) => map.retain(f),\n+        }\n+    }\n+\n+    /// Inserts a key-value pair into the map.\n+    ///\n+    /// If the map did not have this key present, [`None`] is returned.\n+    ///\n+    /// If the map did have this key present, the value is updated, and the old\n+    /// value is returned. The key is not updated, though; this matters for\n+    /// types that can be `==` without being identical. See the [module-level\n+    /// documentation] for more.\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array.iter_mut() {\n+                    if *k == key {\n+                        let old_value = std::mem::replace(v, value);\n+                        return Some(old_value);\n+                    }\n+                }\n+                if let Err(error) = array.try_push((key, value)) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    let (key, value) = error.element();\n+                    map.insert(key, value);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.insert(key, value),\n+        }\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if let Some(index) = array.iter().position(|(k, _v)| k == key) {\n+                    Some(array.swap_remove(index).1)\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.remove(key),\n+        }\n+    }\n+\n+    /// Removes a key from the map, returning the stored key and value if the\n+    /// key was previously in the map.\n+    pub fn remove_entry(&mut self, key: &K) -> Option<(K, V)> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if let Some(index) = array.iter().position(|(k, _v)| k == key) {\n+                    Some(array.swap_remove(index))\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.remove_entry(key),\n+        }\n+    }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    pub fn get(&self, key: &K) -> Option<&V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if k == key {\n+                        return Some(v);\n+                    }\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.get(key),\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if k == key {\n+                        return Some(v);\n+                    }\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.get_mut(key),\n+        }\n+    }\n+\n+    /// Returns the key-value pair corresponding to the supplied key.\n+    pub fn get_key_value(&self, key: &K) -> Option<(&K, &V)> {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if k == key {\n+                        return Some((k, v));\n+                    }\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.get_key_value(key),\n+        }\n+    }\n+\n+    /// Returns `true` if the map contains a value for the specified key.\n+    pub fn contains_key(&self, key: &K) -> bool {\n+        match self {\n+            SsoHashMap::Array(array) => array.iter().any(|(k, _v)| k == key),\n+            SsoHashMap::Map(map) => map.contains_key(key),\n+        }\n+    }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    #[inline]\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+        Entry { ssomap: self, key }\n+    }\n+}\n+\n+impl<K, V> Default for SsoHashMap<K, V> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> FromIterator<(K, V)> for SsoHashMap<K, V> {\n+    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> SsoHashMap<K, V> {\n+        let mut map: SsoHashMap<K, V> = Default::default();\n+        map.extend(iter);\n+        map\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> Extend<(K, V)> for SsoHashMap<K, V> {\n+    fn extend<I>(&mut self, iter: I)\n+    where\n+        I: IntoIterator<Item = (K, V)>,\n+    {\n+        for (key, value) in iter.into_iter() {\n+            self.insert(key, value);\n+        }\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.insert(k, v);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if SSO_ARRAY_SIZE < (array.len() + additional) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    map.extend_reserve(additional);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.extend_reserve(additional),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> Extend<(&'a K, &'a V)> for SsoHashMap<K, V>\n+where\n+    K: Eq + Hash + Copy,\n+    V: Copy,\n+{\n+    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n+        self.extend(iter.into_iter().map(|(k, v)| (k.clone(), v.clone())))\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.insert(k, v);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<(K, V)>::extend_reserve(self, additional)\n+    }\n+}\n+\n+impl<K, V> IntoIterator for SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        <ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+        <FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter()),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+/// adapts Item of array reference iterator to Item of hashmap reference iterator.\n+#[inline(always)]\n+fn adapt_array_ref_it<K, V>(pair: &'a (K, V)) -> (&'a K, &'a V) {\n+    let (a, b) = pair;\n+    (a, b)\n+}\n+\n+/// adapts Item of array mut reference iterator to Item of hashmap mut reference iterator.\n+#[inline(always)]\n+fn adapt_array_mut_it<K, V>(pair: &'a mut (K, V)) -> (&'a K, &'a mut V) {\n+    let (a, b) = pair;\n+    (a, b)\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        std::iter::Map<\n+            <&'a ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            fn(&'a (K, V)) -> (&'a K, &'a V),\n+        >,\n+        <&'a FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_ref_it)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        std::iter::Map<\n+            <&'a mut ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            fn(&'a mut (K, V)) -> (&'a K, &'a mut V),\n+        >,\n+        <&'a mut FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_mut_it)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<K, V> fmt::Debug for SsoHashMap<K, V>\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_map().entries(self.iter()).finish()\n+    }\n+}\n+\n+impl<'a, K, V> Index<&'a K> for SsoHashMap<K, V>\n+where\n+    K: Eq + Hash,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, key: &K) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+/// A view into a single entry in a map.\n+pub struct Entry<'a, K, V> {\n+    ssomap: &'a mut SsoHashMap<K, V>,\n+    key: K,\n+}\n+\n+impl<'a, K: Eq + Hash, V> Entry<'a, K, V> {\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    pub fn and_modify<F>(self, f: F) -> Self\n+    where\n+        F: FnOnce(&mut V),\n+    {\n+        if let Some(value) = self.ssomap.get_mut(&self.key) {\n+            f(value);\n+        }\n+        self\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    #[inline]\n+    pub fn or_insert(self, value: V) -> &'a mut V {\n+        self.or_insert_with(|| value)\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        self.ssomap.migrate_if_full();\n+        match self.ssomap {\n+            SsoHashMap::Array(array) => {\n+                let key_ref = &self.key;\n+                let found_index = array.iter().position(|(k, _v)| k == key_ref);\n+                let index = if let Some(index) = found_index {\n+                    index\n+                } else {\n+                    let index = array.len();\n+                    array.try_push((self.key, default())).unwrap();\n+                    index\n+                };\n+                &mut array[index].1\n+            }\n+            SsoHashMap::Map(map) => map.entry(self.key).or_insert_with(default),\n+        }\n+    }\n+\n+    /// Returns a reference to this entry's key.\n+    #[inline]\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+}\n+\n+impl<'a, K: Eq + Hash, V: Default> Entry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    #[inline]\n+    pub fn or_default(self) -> &'a mut V {\n+        self.or_insert_with(Default::default)\n+    }\n+}"}, {"sha": "dd21bc8e6963680253ac03c0e59bdd5ce59ce2a7", "filename": "compiler/rustc_data_structures/src/sso/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -0,0 +1,6 @@\n+mod either_iter;\n+mod map;\n+mod set;\n+\n+pub use map::SsoHashMap;\n+pub use set::SsoHashSet;"}, {"sha": "23cff0206c530367de30922de990535788f63721", "filename": "compiler/rustc_data_structures/src/sso/set.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -0,0 +1,237 @@\n+use std::fmt;\n+use std::hash::Hash;\n+use std::iter::FromIterator;\n+\n+use super::map::SsoHashMap;\n+\n+/// Small-storage-optimized implementation of a set.\n+///\n+/// Stores elements in a small array up to a certain length\n+/// and switches to `HashSet` when that length is exceeded.\n+//\n+// FIXME: Implements subset of HashSet API.\n+//\n+// Missing HashSet API:\n+//   all hasher-related\n+//   try_reserve (unstable)\n+//   shrink_to (unstable)\n+//   drain_filter (unstable)\n+//   replace\n+//   get_or_insert/get_or_insert_owned/get_or_insert_with (unstable)\n+//   difference/symmetric_difference/intersection/union\n+//   is_disjoint/is_subset/is_superset\n+//   PartialEq/Eq (requires SsoHashMap implementation)\n+//   BitOr/BitAnd/BitXor/Sub\n+#[derive(Clone)]\n+pub struct SsoHashSet<T> {\n+    map: SsoHashMap<T, ()>,\n+}\n+\n+/// Adapter function used ot return\n+/// result if SsoHashMap functions into\n+/// result SsoHashSet should return.\n+#[inline(always)]\n+fn entry_to_key<K, V>((k, _v): (K, V)) -> K {\n+    k\n+}\n+\n+impl<T> SsoHashSet<T> {\n+    /// Creates an empty `SsoHashSet`.\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { map: SsoHashMap::new() }\n+    }\n+\n+    /// Creates an empty `SsoHashSet` with the specified capacity.\n+    #[inline]\n+    pub fn with_capacity(cap: usize) -> Self {\n+        Self { map: SsoHashMap::with_capacity(cap) }\n+    }\n+\n+    /// Clears the set, removing all values.\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.map.clear()\n+    }\n+\n+    /// Returns the number of elements the set can hold without reallocating.\n+    #[inline]\n+    pub fn capacity(&self) -> usize {\n+        self.map.capacity()\n+    }\n+\n+    /// Returns the number of elements in the set.\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.map.len()\n+    }\n+\n+    /// Returns `true` if the set contains no elements.\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// The iterator element type is `&'a T`.\n+    #[inline]\n+    pub fn iter(&'a self) -> impl Iterator<Item = &'a T> {\n+        self.into_iter()\n+    }\n+\n+    /// Clears the set, returning all elements in an iterator.\n+    #[inline]\n+    pub fn drain(&mut self) -> impl Iterator<Item = T> + '_ {\n+        self.map.drain().map(entry_to_key)\n+    }\n+}\n+\n+impl<T: Eq + Hash> SsoHashSet<T> {\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `SsoHashSet`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    #[inline]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.map.reserve(additional)\n+    }\n+\n+    /// Shrinks the capacity of the set as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.map.shrink_to_fit()\n+    }\n+\n+    /// Retains only the elements specified by the predicate.\n+    #[inline]\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        self.map.retain(|k, _v| f(k))\n+    }\n+\n+    /// Removes and returns the value in the set, if any, that is equal to the given one.\n+    #[inline]\n+    pub fn take(&mut self, value: &T) -> Option<T> {\n+        self.map.remove_entry(value).map(entry_to_key)\n+    }\n+\n+    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n+    #[inline]\n+    pub fn get(&self, value: &T) -> Option<&T> {\n+        self.map.get_key_value(value).map(entry_to_key)\n+    }\n+\n+    /// Adds a value to the set.\n+    ///\n+    /// If the set did not have this value present, `true` is returned.\n+    ///\n+    /// If the set did have this value present, `false` is returned.\n+    #[inline]\n+    pub fn insert(&mut self, elem: T) -> bool {\n+        self.map.insert(elem, ()).is_none()\n+    }\n+\n+    /// Removes a value from the set. Returns whether the value was\n+    /// present in the set.\n+    #[inline]\n+    pub fn remove(&mut self, value: &T) -> bool {\n+        self.map.remove(value).is_some()\n+    }\n+\n+    /// Returns `true` if the set contains a value.\n+    #[inline]\n+    pub fn contains(&self, value: &T) -> bool {\n+        self.map.contains_key(value)\n+    }\n+}\n+\n+impl<T: Eq + Hash> FromIterator<T> for SsoHashSet<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> SsoHashSet<T> {\n+        let mut set: SsoHashSet<T> = Default::default();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl<T> Default for SsoHashSet<T> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<T: Eq + Hash> Extend<T> for SsoHashSet<T> {\n+    fn extend<I>(&mut self, iter: I)\n+    where\n+        I: IntoIterator<Item = T>,\n+    {\n+        for val in iter.into_iter() {\n+            self.insert(val);\n+        }\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.insert(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.map.extend_reserve(additional)\n+    }\n+}\n+\n+impl<'a, T> Extend<&'a T> for SsoHashSet<T>\n+where\n+    T: 'a + Eq + Hash + Copy,\n+{\n+    #[inline]\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n+        self.extend(iter.into_iter().cloned());\n+    }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.insert(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<T>::extend_reserve(self, additional)\n+    }\n+}\n+\n+impl<T> IntoIterator for SsoHashSet<T> {\n+    type IntoIter = std::iter::Map<<SsoHashMap<T, ()> as IntoIterator>::IntoIter, fn((T, ())) -> T>;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.map.into_iter().map(entry_to_key)\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a SsoHashSet<T> {\n+    type IntoIter = std::iter::Map<\n+        <&'a SsoHashMap<T, ()> as IntoIterator>::IntoIter,\n+        fn((&'a T, &'a ())) -> &'a T,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    #[inline]\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.map.iter().map(entry_to_key)\n+    }\n+}\n+\n+impl<T> fmt::Debug for SsoHashSet<T>\n+where\n+    T: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_set().entries(self.iter()).finish()\n+    }\n+}"}, {"sha": "6a1715ef8189992e1b6742cda5c1bd72b34fbee4", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -35,7 +35,7 @@ use super::{InferCtxt, MiscVariable, TypeTrace};\n use crate::traits::{Obligation, PredicateObligations};\n \n use rustc_ast as ast;\n-use rustc_data_structures::mini_map::MiniMap;\n+use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n@@ -429,7 +429,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             needs_wf: false,\n             root_ty: ty,\n             param_env: self.param_env,\n-            cache: MiniMap::new(),\n+            cache: SsoHashMap::new(),\n         };\n \n         let ty = match generalize.relate(ty, ty) {\n@@ -490,7 +490,7 @@ struct Generalizer<'cx, 'tcx> {\n \n     param_env: ty::ParamEnv<'tcx>,\n \n-    cache: MiniMap<Ty<'tcx>, RelateResult<'tcx, Ty<'tcx>>>,\n+    cache: SsoHashMap<Ty<'tcx>, RelateResult<'tcx, Ty<'tcx>>>,\n }\n \n /// Result from a generalization operation. This includes"}, {"sha": "07924298c241bc67adcbfcf64836c917df347a4f", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::{GenericKind, VerifyBound};\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::mini_set::MiniSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -32,7 +32,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     /// Returns a \"verify bound\" that encodes what we know about\n     /// `generic` and the regions it outlives.\n     pub fn generic_bound(&self, generic: GenericKind<'tcx>) -> VerifyBound<'tcx> {\n-        let mut visited = MiniSet::new();\n+        let mut visited = SsoHashSet::new();\n         match generic {\n             GenericKind::Param(param_ty) => self.param_bound(param_ty),\n             GenericKind::Projection(projection_ty) => {\n@@ -44,7 +44,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn type_bound(\n         &self,\n         ty: Ty<'tcx>,\n-        visited: &mut MiniSet<GenericArg<'tcx>>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n         match *ty.kind() {\n             ty::Param(p) => self.param_bound(p),\n@@ -148,7 +148,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     pub fn projection_bound(\n         &self,\n         projection_ty: ty::ProjectionTy<'tcx>,\n-        visited: &mut MiniSet<GenericArg<'tcx>>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(projection_ty={:?})\", projection_ty);\n \n@@ -186,7 +186,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n     fn recursive_bound(\n         &self,\n         parent: GenericArg<'tcx>,\n-        visited: &mut MiniSet<GenericArg<'tcx>>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n         let mut bounds = parent\n             .walk_shallow(visited)"}, {"sha": "4c20141bbe691f4a4267516e6e69fa0bf853bc09", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -4,7 +4,7 @@\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_data_structures::mini_set::MiniSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use smallvec::SmallVec;\n \n #[derive(Debug)]\n@@ -51,7 +51,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Push onto `out` all the things that must outlive `'a` for the condition\n     /// `ty0: 'a` to hold. Note that `ty0` must be a **fully resolved type**.\n     pub fn push_outlives_components(self, ty0: Ty<'tcx>, out: &mut SmallVec<[Component<'tcx>; 4]>) {\n-        let mut visited = MiniSet::new();\n+        let mut visited = SsoHashSet::new();\n         compute_components(self, ty0, out, &mut visited);\n         debug!(\"components({:?}) = {:?}\", ty0, out);\n     }\n@@ -61,7 +61,7 @@ fn compute_components(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     out: &mut SmallVec<[Component<'tcx>; 4]>,\n-    visited: &mut MiniSet<GenericArg<'tcx>>,\n+    visited: &mut SsoHashSet<GenericArg<'tcx>>,\n ) {\n     // Descend through the types, looking for the various \"base\"\n     // components and collecting them into `out`. This is not written\n@@ -142,7 +142,7 @@ fn compute_components(\n                     // OutlivesProjectionComponents.  Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n-                    let mut subvisited = MiniSet::new();\n+                    let mut subvisited = SsoHashSet::new();\n                     compute_components_recursive(tcx, ty.into(), &mut subcomponents, &mut subvisited);\n                     out.push(Component::EscapingProjection(subcomponents.into_iter().collect()));\n                 }\n@@ -194,7 +194,7 @@ fn compute_components_recursive(\n     tcx: TyCtxt<'tcx>,\n     parent: GenericArg<'tcx>,\n     out: &mut SmallVec<[Component<'tcx>; 4]>,\n-    visited: &mut MiniSet<GenericArg<'tcx>>,\n+    visited: &mut SsoHashSet<GenericArg<'tcx>>,\n ) {\n     for child in parent.walk_shallow(visited) {\n         match child.unpack() {"}, {"sha": "2e00be2395b8caea43f507b10f11a89dd04163e6", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -2,7 +2,7 @@ use crate::ty::subst::{GenericArg, Subst};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::mini_set::MiniSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n \n@@ -269,7 +269,7 @@ pub trait Printer<'tcx>: Sized {\n /// deeply nested tuples that have no DefId.\n fn characteristic_def_id_of_type_cached<'a>(\n     ty: Ty<'a>,\n-    visited: &mut MiniSet<Ty<'a>>,\n+    visited: &mut SsoHashSet<Ty<'a>>,\n ) -> Option<DefId> {\n     match *ty.kind() {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n@@ -316,7 +316,7 @@ fn characteristic_def_id_of_type_cached<'a>(\n     }\n }\n pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n-    characteristic_def_id_of_type_cached(ty, &mut MiniSet::new())\n+    characteristic_def_id_of_type_cached(ty, &mut SsoHashSet::new())\n }\n \n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for ty::RegionKind {"}, {"sha": "357a0dd65c414fda4bf7f000c1daf9236392495c", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -3,7 +3,7 @@\n \n use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_data_structures::mini_set::MiniSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use smallvec::{self, SmallVec};\n \n // The TypeWalker's stack is hot enough that it's worth going to some effort to\n@@ -13,7 +13,7 @@ type TypeWalkerStack<'tcx> = SmallVec<[GenericArg<'tcx>; 8]>;\n pub struct TypeWalker<'tcx> {\n     stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n-    visited: MiniSet<GenericArg<'tcx>>,\n+    visited: SsoHashSet<GenericArg<'tcx>>,\n }\n \n /// An iterator for walking the type tree.\n@@ -26,7 +26,7 @@ pub struct TypeWalker<'tcx> {\n /// skips any types that are already there.\n impl<'tcx> TypeWalker<'tcx> {\n     pub fn new(root: GenericArg<'tcx>) -> Self {\n-        Self { stack: smallvec![root], last_subtree: 1, visited: MiniSet::new() }\n+        Self { stack: smallvec![root], last_subtree: 1, visited: SsoHashSet::new() }\n     }\n \n     /// Skips the subtree corresponding to the last type\n@@ -87,7 +87,7 @@ impl GenericArg<'tcx> {\n     /// and skips any types that are already there.\n     pub fn walk_shallow(\n         self,\n-        visited: &mut MiniSet<GenericArg<'tcx>>,\n+        visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> impl Iterator<Item = GenericArg<'tcx>> {\n         let mut stack = SmallVec::new();\n         push_inner(&mut stack, self);"}, {"sha": "bdbf45f78a23b206ec05104c5972d79550143348", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea7e131435a960d154e9a5d6a9297039574ffd7d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=ea7e131435a960d154e9a5d6a9297039574ffd7d", "patch": "@@ -7,7 +7,7 @@ use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n-use rustc_data_structures::mini_map::MiniMap;\n+use rustc_data_structures::sso::SsoHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_infer::traits::Normalized;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n@@ -58,7 +58,7 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n             param_env: self.param_env,\n             obligations: vec![],\n             error: false,\n-            cache: MiniMap::new(),\n+            cache: SsoHashMap::new(),\n             anon_depth: 0,\n         };\n \n@@ -87,7 +87,7 @@ struct QueryNormalizer<'cx, 'tcx> {\n     cause: &'cx ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n-    cache: MiniMap<Ty<'tcx>, Ty<'tcx>>,\n+    cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n     error: bool,\n     anon_depth: usize,\n }"}]}