{"sha": "91198820d7e697def79177c022b5e98b3d482ddc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMTk4ODIwZDdlNjk3ZGVmNzkxNzdjMDIyYjVlOThiM2Q0ODJkZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-19T21:39:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-19T21:39:47Z"}, "message": "Auto merge of #88575 - eddyb:fn-abi-queries, r=nagisa\n\nQuerify `FnAbi::of_{fn_ptr,instance}` as `fn_abi_of_{fn_ptr,instance}`.\n\n*Note: opening this PR as draft because it's based on #88499*\n\nThis more or less replicates the `LayoutOf::layout_of` setup from #88499, to replace `FnAbi::of_{fn_ptr,instance}` with `FnAbiOf::fn_abi_of_{fn_ptr,instance}`, and also route them through queries (which `layout_of` has used for a while).\n\nThe two changes at the use sites (other than the names) are:\n* return type is now wrapped in `&'tcx`\n  * the value *is* interned, which may affect performance\n* the `extra_args` list is now an interned `&'tcx ty::List<Ty<'tcx>>`\n  * should be cheap (it's empty for anything other than C variadics)\n\nTheoretically, a `FnAbiOfHelpers` implementer could choose to keep the `Result<...>` instead of eagerly erroring, but the only existing users of these APIs are codegen backends, so they don't (want to) take advantage of this.\nAt least miri could make use of this, since it prefers propagating errors (it \"just\" doesn't use `FnAbi` yet - cc `@RalfJung).`\n\nThe way this is done is probably less efficient than what is possible, because the queries handle the correctness-oriented API (i.e. the split into `fn` pointers vs instances), whereas a lower-level query could end up with more reuse between different instances with identical signatures.\n\nr? `@nagisa` cc `@oli-obk` `@bjorn3`", "tree": {"sha": "57809cb2d81d9ba41110e5cb142203802bbd78b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57809cb2d81d9ba41110e5cb142203802bbd78b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91198820d7e697def79177c022b5e98b3d482ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91198820d7e697def79177c022b5e98b3d482ddc", "html_url": "https://github.com/rust-lang/rust/commit/91198820d7e697def79177c022b5e98b3d482ddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91198820d7e697def79177c022b5e98b3d482ddc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ecc8ad8462574354a55162a0c16b10eb95e3e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ecc8ad8462574354a55162a0c16b10eb95e3e70", "html_url": "https://github.com/rust-lang/rust/commit/5ecc8ad8462574354a55162a0c16b10eb95e3e70"}, {"sha": "8c918d7e2d973ac3d148097224e0951daba16835", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c918d7e2d973ac3d148097224e0951daba16835", "html_url": "https://github.com/rust-lang/rust/commit/8c918d7e2d973ac3d148097224e0951daba16835"}], "stats": {"total": 748, "additions": 506, "deletions": 242}, "files": [{"sha": "15bb90678059daa9be2156909d3b127a9805dfb1", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -5,7 +5,7 @@ mod pass_mode;\n mod returning;\n \n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n-use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::layout::FnAbiOf;\n use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n@@ -53,7 +53,11 @@ pub(crate) fn get_function_sig<'tcx>(\n     inst: Instance<'tcx>,\n ) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    clif_sig_from_fn_abi(tcx, triple, &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]))\n+    clif_sig_from_fn_abi(\n+        tcx,\n+        triple,\n+        &RevealAllLayoutCx(tcx).fn_abi_of_instance(inst, ty::List::empty()),\n+    )\n }\n \n /// Instance must be monomorphized\n@@ -350,14 +354,13 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     };\n \n     let extra_args = &args[fn_sig.inputs().len()..];\n-    let extra_args = extra_args\n-        .iter()\n-        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n-        .collect::<Vec<_>>();\n+    let extra_args = fx\n+        .tcx\n+        .mk_type_list(extra_args.iter().map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx))));\n     let fn_abi = if let Some(instance) = instance {\n-        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+        RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(instance, extra_args)\n     } else {\n-        FnAbi::of_fn_ptr(&RevealAllLayoutCx(fx.tcx), fn_ty.fn_sig(fx.tcx), &extra_args)\n+        RevealAllLayoutCx(fx.tcx).fn_abi_of_fn_ptr(fn_ty.fn_sig(fx.tcx), extra_args)\n     };\n \n     let is_cold = instance\n@@ -525,7 +528,8 @@ pub(crate) fn codegen_drop<'tcx>(\n                     def: ty::InstanceDef::Virtual(drop_instance.def_id(), 0),\n                     substs: drop_instance.substs,\n                 };\n-                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), virtual_drop, &[]);\n+                let fn_abi =\n+                    RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(virtual_drop, ty::List::empty());\n \n                 let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n@@ -534,7 +538,8 @@ pub(crate) fn codegen_drop<'tcx>(\n             _ => {\n                 assert!(!matches!(drop_instance.def, InstanceDef::Virtual(_, _)));\n \n-                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), drop_instance, &[]);\n+                let fn_abi =\n+                    RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(drop_instance, ty::List::empty());\n \n                 let arg_value = drop_place.place_ref(\n                     fx,"}, {"sha": "d8fa2c769046827fa36c332f1e5d71047ef68507", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -3,8 +3,7 @@\n use cranelift_codegen::binemit::{NullStackMapSink, NullTrapSink};\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n-use rustc_middle::ty::layout::FnAbiExt;\n-use rustc_target::abi::call::FnAbi;\n+use rustc_middle::ty::layout::FnAbiOf;\n \n use crate::constant::ConstantCx;\n use crate::prelude::*;\n@@ -62,7 +61,7 @@ pub(crate) fn codegen_fn<'tcx>(\n         instance,\n         symbol_name,\n         mir,\n-        fn_abi: Some(FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n+        fn_abi: Some(RevealAllLayoutCx(tcx).fn_abi_of_instance(instance, ty::List::empty())),\n \n         bcx,\n         block_map,"}, {"sha": "0e84681d9ad94f4c40db9dcff7854c22f6017dd9", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -1,5 +1,7 @@\n use rustc_index::vec::IndexVec;\n-use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers};\n+use rustc_middle::ty::layout::{\n+    FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n+};\n use rustc_middle::ty::SymbolName;\n use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n@@ -239,7 +241,7 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) instance: Instance<'tcx>,\n     pub(crate) symbol_name: SymbolName<'tcx>,\n     pub(crate) mir: &'tcx Body<'tcx>,\n-    pub(crate) fn_abi: Option<FnAbi<'tcx, Ty<'tcx>>>,\n+    pub(crate) fn_abi: Option<&'tcx FnAbi<'tcx, Ty<'tcx>>>,\n \n     pub(crate) bcx: FunctionBuilder<'clif>,\n     pub(crate) block_map: IndexVec<BasicBlock, Block>,\n@@ -266,6 +268,20 @@ impl<'tcx> LayoutOfHelpers<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     }\n }\n \n+impl<'tcx> FnAbiOfHelpers<'tcx> for FunctionCx<'_, '_, 'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        RevealAllLayoutCx(self.tcx).handle_fn_abi_err(err, span, fn_abi_request)\n+    }\n+}\n+\n impl<'tcx> layout::HasTyCtxt<'tcx> for FunctionCx<'_, '_, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -378,6 +394,43 @@ impl<'tcx> LayoutOfHelpers<'tcx> for RevealAllLayoutCx<'tcx> {\n     }\n }\n \n+impl<'tcx> FnAbiOfHelpers<'tcx> for RevealAllLayoutCx<'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n+            self.0.sess.span_fatal(span, &err.to_string())\n+        } else {\n+            match fn_abi_request {\n+                FnAbiRequest::OfFnPtr { sig, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n+                        sig,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+                FnAbiRequest::OfInstance { instance, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n+                        instance,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> layout::HasTyCtxt<'tcx> for RevealAllLayoutCx<'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.0"}, {"sha": "5c4991f1fb667382809dc2bfc00896653a75072e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -129,9 +129,7 @@ pub(crate) fn codegen_constant<'tcx>(\n     };\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n-        ConstKind::Unevaluated(uv)\n-            if fx.tcx.is_static(uv.def.did) =>\n-        {\n+        ConstKind::Unevaluated(uv) if fx.tcx.is_static(uv.def.did) => {\n             assert!(uv.substs(fx.tcx).is_empty());\n             assert!(uv.promoted.is_none());\n "}, {"sha": "ec846d71960b89863e7cb49e0d9eddf30d5a04fe", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -61,9 +61,8 @@ use cranelift_codegen::{\n     write::{FuncWriter, PlainWriter},\n };\n \n-use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::layout::FnAbiOf;\n use rustc_session::config::OutputType;\n-use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -81,7 +80,10 @@ impl CommentWriter {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n-                format!(\"abi {:?}\", FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n+                format!(\n+                    \"abi {:?}\",\n+                    RevealAllLayoutCx(tcx).fn_abi_of_instance(instance, ty::List::empty())\n+                ),\n                 String::new(),\n             ]\n         } else {"}, {"sha": "dab7d3eaa8cfd45c6de1c95c831941e8f219920a", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -15,10 +15,12 @@ use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::layout::{LayoutError, LayoutOfHelpers, TyAndLayout};\n+use rustc_middle::ty::layout::{\n+    FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers, TyAndLayout,\n+};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n-use rustc_target::abi::{self, Align, Size, WrappingRange};\n+use rustc_target::abi::{self, call::FnAbi, Align, Size, WrappingRange};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n@@ -97,6 +99,20 @@ impl LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n+impl FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        self.cx.handle_fn_abi_err(err, span, fn_abi_request)\n+    }\n+}\n+\n impl Deref for Builder<'_, 'll, 'tcx> {\n     type Target = CodegenCx<'ll, 'tcx>;\n "}, {"sha": "a96ba148a6ce30f7374b2a36086401bd09e30597", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -4,15 +4,15 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-use crate::abi::{FnAbi, FnAbiLlvmExt};\n+use crate::abi::FnAbiLlvmExt;\n use crate::attributes;\n use crate::context::CodegenCx;\n use crate::llvm;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n use tracing::debug;\n \n-use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -42,7 +42,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n         sym\n     );\n \n-    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n+    let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let llfn = if let Some(llfn) = cx.get_declared_value(&sym) {\n         // Create a fn pointer with the new signature."}, {"sha": "52a12b2fd81d8b16ebfd8cc73467965437f3d388", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -15,14 +15,19 @@ use rustc_data_structures::base_n;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_middle::mir::mono::CodegenUnit;\n-use rustc_middle::ty::layout::{HasParamEnv, LayoutError, LayoutOfHelpers, TyAndLayout};\n+use rustc_middle::ty::layout::{\n+    FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, LayoutError, LayoutOfHelpers,\n+    TyAndLayout,\n+};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CFGuard, CrateType, DebugInfo};\n use rustc_session::Session;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n-use rustc_target::abi::{HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n+use rustc_target::abi::{\n+    call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx,\n+};\n use rustc_target::spec::{HasTargetSpec, RelocModel, Target, TlsModel};\n use smallvec::SmallVec;\n \n@@ -835,6 +840,12 @@ impl ty::layout::HasTyCtxt<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n+impl<'tcx, 'll> HasParamEnv<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        ty::ParamEnv::reveal_all()\n+    }\n+}\n+\n impl LayoutOfHelpers<'tcx> for CodegenCx<'ll, 'tcx> {\n     type LayoutOfResult = TyAndLayout<'tcx>;\n \n@@ -848,8 +859,39 @@ impl LayoutOfHelpers<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n }\n \n-impl<'tcx, 'll> HasParamEnv<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        ty::ParamEnv::reveal_all()\n+impl FnAbiOfHelpers<'tcx> for CodegenCx<'ll, 'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n+            self.sess().span_fatal(span, &err.to_string())\n+        } else {\n+            match fn_abi_request {\n+                FnAbiRequest::OfFnPtr { sig, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n+                        sig,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+                FnAbiRequest::OfInstance { instance, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n+                        instance,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "093aceda2b7413ef4713a220598e7415bf6f6562", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -1,6 +1,6 @@\n use crate::llvm;\n \n-use crate::abi::{Abi, FnAbi};\n+use crate::abi::Abi;\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n \n@@ -20,7 +20,7 @@ use rustc_middle::mir::coverage::{\n     CodeRegion, CounterValueReference, ExpressionOperandId, InjectedExpressionId, Op,\n };\n use rustc_middle::ty;\n-use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Instance;\n \n@@ -200,16 +200,15 @@ fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx\n \n     let llfn = cx.declare_fn(\n         &tcx.symbol_name(instance).name,\n-        &FnAbi::of_fn_ptr(\n-            cx,\n+        &cx.fn_abi_of_fn_ptr(\n             ty::Binder::dummy(tcx.mk_fn_sig(\n                 iter::once(tcx.mk_unit()),\n                 tcx.mk_unit(),\n                 false,\n                 hir::Unsafety::Unsafe,\n                 Abi::Rust,\n             )),\n-            &[],\n+            ty::List::empty(),\n         ),\n     );\n "}, {"sha": "1612922d43953359453b4596f168ea99c809ff7b", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -3,12 +3,11 @@ use super::utils::DIB;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext};\n use rustc_codegen_ssa::traits::*;\n \n-use crate::abi::FnAbi;\n use crate::common::CodegenCx;\n use crate::llvm;\n use crate::llvm::debuginfo::{DILocation, DIScope};\n use rustc_middle::mir::{Body, SourceScope};\n-use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::{self, Instance};\n use rustc_session::config::DebugInfo;\n \n@@ -94,7 +93,7 @@ fn make_mir_scope(\n                 ty::ParamEnv::reveal_all(),\n                 callee,\n             );\n-            let callee_fn_abi = FnAbi::of_instance(cx, callee, &[]);\n+            let callee_fn_abi = cx.fn_abi_of_instance(callee, ty::List::empty());\n             cx.dbg_scope_fn(callee, &callee_fn_abi, None)\n         }\n         None => unsafe {"}, {"sha": "37b3279fb80966dd3058b49c412e31fe70e9b087", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -15,7 +15,7 @@ use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_hir as hir;\n-use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, LayoutOf};\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::{sym, symbol::kw, Span, Symbol};\n@@ -737,7 +737,7 @@ fn gen_fn<'ll, 'tcx>(\n     rust_fn_sig: ty::PolyFnSig<'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n ) -> (&'ll Type, &'ll Value) {\n-    let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n+    let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n     let llty = fn_abi.llvm_type(cx);\n     let llfn = cx.declare_fn(name, &fn_abi);\n     cx.set_frame_pointer_type(llfn);"}, {"sha": "34982f769d03a5cef6dda69a6116e751a8b6cb0e", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -1,4 +1,3 @@\n-use crate::abi::FnAbi;\n use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n@@ -8,7 +7,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n pub use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n-use rustc_middle::ty::layout::{FnAbiExt, LayoutOf};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n use rustc_session::config::CrateType;\n use rustc_target::spec::RelocModel;\n@@ -53,7 +52,7 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) {\n         assert!(!instance.substs.needs_infer());\n \n-        let fn_abi = FnAbi::of_instance(self, instance, &[]);\n+        let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         let lldecl = self.declare_fn(symbol_name, &fn_abi);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n         let attrs = self.tcx.codegen_fn_attrs(instance.def_id());"}, {"sha": "757ccbddbeedf140c425a1eaee7608f048fcbd77", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -1,10 +1,9 @@\n-use crate::abi::FnAbi;\n use crate::common::*;\n use crate::context::TypeLowering;\n use crate::type_::Type;\n use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n-use rustc_middle::ty::layout::{FnAbiExt, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n@@ -231,7 +230,9 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n                 ty::Adt(def, _) if def.is_box() => {\n                     cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).llvm_type(cx))\n                 }\n-                ty::FnPtr(sig) => cx.fn_ptr_backend_type(&FnAbi::of_fn_ptr(cx, sig, &[])),\n+                ty::FnPtr(sig) => {\n+                    cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty()))\n+                }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO),\n             };\n             cx.scalar_lltypes.borrow_mut().insert(self.ty, llty);"}, {"sha": "4be050fb88c2da7c936792c2ff280c951cba0329", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::{self, SwitchTargets};\n-use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, LayoutOf};\n+use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_span::source_map::Span;\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         bx: &mut Bx,\n-        fn_abi: FnAbi<'tcx, Ty<'tcx>>,\n+        fn_abi: &'tcx FnAbi<'tcx, Ty<'tcx>>,\n         fn_ptr: Bx::Value,\n         llargs: &[Bx::Value],\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n@@ -337,7 +337,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     def: ty::InstanceDef::Virtual(drop_fn.def_id(), 0),\n                     substs: drop_fn.substs,\n                 };\n-                let fn_abi = FnAbi::of_instance(&bx, virtual_drop, &[]);\n+                let fn_abi = bx.fn_abi_of_instance(virtual_drop, ty::List::empty());\n                 let vtable = args[1];\n                 args = &args[..1];\n                 (\n@@ -346,7 +346,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     fn_abi,\n                 )\n             }\n-            _ => (bx.get_fn_addr(drop_fn), FnAbi::of_instance(&bx, drop_fn, &[])),\n+            _ => (bx.get_fn_addr(drop_fn), bx.fn_abi_of_instance(drop_fn, ty::List::empty())),\n         };\n         helper.do_call(\n             self,\n@@ -433,7 +433,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Obtain the panic entry point.\n         let def_id = common::langcall(bx.tcx(), Some(span), \"\", lang_item);\n         let instance = ty::Instance::mono(bx.tcx(), def_id);\n-        let fn_abi = FnAbi::of_instance(&bx, instance, &[]);\n+        let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n         let llfn = bx.get_fn_addr(instance);\n \n         // Codegen the actual panic invoke/call.\n@@ -494,7 +494,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let def_id =\n                     common::langcall(bx.tcx(), Some(source_info.span), \"\", LangItem::Panic);\n                 let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                let fn_abi = FnAbi::of_instance(bx, instance, &[]);\n+                let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n                 let llfn = bx.get_fn_addr(instance);\n \n                 // Codegen the actual panic invoke/call.\n@@ -570,17 +570,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         let extra_args = &args[sig.inputs().skip_binder().len()..];\n-        let extra_args = extra_args\n-            .iter()\n-            .map(|op_arg| {\n-                let op_ty = op_arg.ty(self.mir, bx.tcx());\n-                self.monomorphize(op_ty)\n-            })\n-            .collect::<Vec<_>>();\n+        let extra_args = bx.tcx().mk_type_list(extra_args.iter().map(|op_arg| {\n+            let op_ty = op_arg.ty(self.mir, bx.tcx());\n+            self.monomorphize(op_ty)\n+        }));\n \n         let fn_abi = match instance {\n-            Some(instance) => FnAbi::of_instance(&bx, instance, &extra_args),\n-            None => FnAbi::of_fn_ptr(&bx, sig, &extra_args),\n+            Some(instance) => bx.fn_abi_of_instance(instance, extra_args),\n+            None => bx.fn_abi_of_fn_ptr(sig, extra_args),\n         };\n \n         if intrinsic == Some(sym::transmute) {"}, {"sha": "8e3982c72d7742408951922d31ad4da40b64755c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -2,7 +2,7 @@ use crate::traits::*;\n use rustc_errors::ErrorReported;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_target::abi::call::{FnAbi, PassMode};\n \n@@ -29,7 +29,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n \n     cx: &'a Bx::CodegenCx,\n \n-    fn_abi: FnAbi<'tcx, Ty<'tcx>>,\n+    fn_abi: &'tcx FnAbi<'tcx, Ty<'tcx>>,\n \n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n@@ -139,7 +139,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let mir = cx.tcx().instance_mir(instance.def);\n \n-    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n+    let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n     debug!(\"fn_abi: {:?}\", fn_abi);\n \n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);"}, {"sha": "82b79fd0b2ac3e1d525d2ec622a8b8332a081639", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -8,14 +8,15 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::ErrorReported;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::{EncodedMetadata, MetadataLoaderDyn};\n-use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_session::{\n     config::{self, OutputFilenames, PrintRequest},\n     Session,\n };\n use rustc_span::symbol::Symbol;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::spec::Target;\n \n pub use rustc_data_structures::sync::MetadataRef;\n@@ -38,12 +39,19 @@ pub trait BackendTypes {\n }\n \n pub trait Backend<'tcx>:\n-    Sized + BackendTypes + HasTyCtxt<'tcx> + LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>>\n+    Sized\n+    + BackendTypes\n+    + HasTyCtxt<'tcx>\n+    + LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>>\n+    + FnAbiOf<'tcx, FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>>\n {\n }\n \n impl<'tcx, T> Backend<'tcx> for T where\n-    Self: BackendTypes + HasTyCtxt<'tcx> + LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>>\n+    Self: BackendTypes\n+        + HasTyCtxt<'tcx>\n+        + LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>>\n+        + FnAbiOf<'tcx, FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>>\n {\n }\n "}, {"sha": "2dd43a4e8522d0e0a3dacb3828d80c88c3dd3bf6", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -11,7 +11,8 @@\n macro_rules! arena_types {\n     ($macro:path, $tcx:lifetime) => (\n         $macro!([\n-            [] layouts: rustc_target::abi::Layout,\n+            [] layout: rustc_target::abi::Layout,\n+            [] fn_abi: rustc_target::abi::call::FnAbi<$tcx, rustc_middle::ty::Ty<$tcx>>,\n             // AdtDef are interned and compared by address\n             [] adt_def: rustc_middle::ty::AdtDef,\n             [] steal_thir: rustc_data_structures::steal::Steal<rustc_middle::thir::Thir<$tcx>>,"}, {"sha": "c13d7720e37540747236a788225c4549d70fb6bc", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -1128,6 +1128,27 @@ rustc_queries! {\n         desc { \"computing layout of `{}`\", key.value }\n     }\n \n+    /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n+    ///\n+    /// NB: this doesn't handle virtual calls - those should use `fn_abi_of_instance`\n+    /// instead, where the instance is an `InstanceDef::Virtual`.\n+    query fn_abi_of_fn_ptr(\n+        key: ty::ParamEnvAnd<'tcx, (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>)>\n+    ) -> Result<&'tcx abi::call::FnAbi<'tcx, Ty<'tcx>>, ty::layout::FnAbiError<'tcx>> {\n+        desc { \"computing call ABI of `{}` function pointers\", key.value.0 }\n+    }\n+\n+    /// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for\n+    /// direct calls to an `fn`.\n+    ///\n+    /// NB: that includes virtual calls, which are represented by \"direct calls\"\n+    /// to an `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n+    query fn_abi_of_instance(\n+        key: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>)>\n+    ) -> Result<&'tcx abi::call::FnAbi<'tcx, Ty<'tcx>>, ty::layout::FnAbiError<'tcx>> {\n+        desc { \"computing call ABI of `{}`\", key.value.0 }\n+    }\n+\n     query dylib_dependency_formats(_: CrateNum)\n                                     -> &'tcx [(CrateNum, LinkagePreference)] {\n         desc { \"dylib dependency formats of crate\" }"}, {"sha": "72b8d7cce7142d93c7ee5e7c9a09c57ee72362ae", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 26, "deletions": 55, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -102,8 +102,8 @@ pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc. are allocated from.\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n \n-    /// Specifically use a speedy hash algorithm for these hash sets, since\n-    /// they're accessed quite often.\n+    // Specifically use a speedy hash algorithm for these hash sets, since\n+    // they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n     type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n@@ -116,9 +116,9 @@ pub struct CtxtInterners<'tcx> {\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n-    /// Const allocations.\n-    allocation: InternedSet<'tcx, Allocation>,\n+    const_allocation: InternedSet<'tcx, Allocation>,\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n+    layout: InternedSet<'tcx, Layout>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -136,8 +136,9 @@ impl<'tcx> CtxtInterners<'tcx> {\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n-            allocation: Default::default(),\n+            const_allocation: Default::default(),\n             bound_variable_kinds: Default::default(),\n+            layout: Default::default(),\n         }\n     }\n \n@@ -1046,10 +1047,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Stores memory for globals (statics/consts).\n     pub(crate) alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n-    layout_interner: ShardedHashMap<&'tcx Layout, ()>,\n-\n     output_filenames: Arc<OutputFilenames>,\n \n+    // FIXME(eddyb) this doesn't belong here and should be using a query.\n     pub(super) vtables_cache:\n         Lock<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), AllocId>>,\n }\n@@ -1091,13 +1091,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.arena.alloc(ty::AdtDef::new(self, did, kind, variants, repr))\n     }\n \n-    pub fn intern_const_alloc(self, alloc: Allocation) -> &'tcx Allocation {\n-        self.interners\n-            .allocation\n-            .intern(alloc, |alloc| Interned(self.interners.arena.alloc(alloc)))\n-            .0\n-    }\n-\n     /// Allocates a read-only byte or string literal for `mir::interpret`.\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // Create an allocation that just contains these bytes.\n@@ -1106,20 +1099,19 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.create_memory_alloc(alloc)\n     }\n \n+    // FIXME(eddyb) move to `direct_interners!`.\n     pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n         self.stability_interner.intern(stab, |stab| self.arena.alloc(stab))\n     }\n \n+    // FIXME(eddyb) move to `direct_interners!`.\n     pub fn intern_const_stability(self, stab: attr::ConstStability) -> &'tcx attr::ConstStability {\n         self.const_stability_interner.intern(stab, |stab| self.arena.alloc(stab))\n     }\n \n-    pub fn intern_layout(self, layout: Layout) -> &'tcx Layout {\n-        self.layout_interner.intern(layout, |layout| self.arena.alloc(layout))\n-    }\n-\n     /// Returns a range of the start/end indices specified with the\n     /// `rustc_layout_scalar_valid_range` attribute.\n+    // FIXME(eddyb) this is an awkward spot for this method, maybe move it?\n     pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n         let attrs = self.get_attrs(def_id);\n         let get = |name| {\n@@ -1194,7 +1186,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             evaluation_cache: Default::default(),\n             crate_name: Symbol::intern(crate_name),\n             data_layout,\n-            layout_interner: Default::default(),\n             stability_interner: Default::default(),\n             const_stability_interner: Default::default(),\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n@@ -1665,7 +1656,7 @@ macro_rules! nop_list_lift {\n nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n nop_lift! {region; Region<'a> => Region<'tcx>}\n nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n-nop_lift! {allocation; &'a Allocation => &'tcx Allocation}\n+nop_lift! {const_allocation; &'a Allocation => &'tcx Allocation}\n nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n@@ -1957,8 +1948,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     \"Const Stability interner: #{}\",\n                     self.0.const_stability_interner.len()\n                 )?;\n-                writeln!(fmt, \"Allocation interner: #{}\", self.0.interners.allocation.len())?;\n-                writeln!(fmt, \"Layout interner: #{}\", self.0.layout_interner.len())?;\n+                writeln!(\n+                    fmt,\n+                    \"Const Allocation interner: #{}\",\n+                    self.0.interners.const_allocation.len()\n+                )?;\n+                writeln!(fmt, \"Layout interner: #{}\", self.0.interners.layout.len())?;\n \n                 Ok(())\n             }\n@@ -2046,38 +2041,6 @@ impl<'tcx, T> Borrow<[T]> for Interned<'tcx, List<T>> {\n     }\n }\n \n-impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n-    fn borrow(&self) -> &RegionKind {\n-        &self.0\n-    }\n-}\n-\n-impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a Const<'tcx> {\n-        &self.0\n-    }\n-}\n-\n-impl<'tcx> Borrow<Allocation> for Interned<'tcx, Allocation> {\n-    fn borrow<'a>(&'a self) -> &'a Allocation {\n-        &self.0\n-    }\n-}\n-\n-impl<'tcx> PartialEq for Interned<'tcx, Allocation> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.0 == other.0\n-    }\n-}\n-\n-impl<'tcx> Eq for Interned<'tcx, Allocation> {}\n-\n-impl<'tcx> Hash for Interned<'tcx, Allocation> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.0.hash(s)\n-    }\n-}\n-\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty),)+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n@@ -2094,9 +2057,15 @@ macro_rules! direct_interners {\n             }\n         }\n \n+        impl<'tcx> Borrow<$ty> for Interned<'tcx, $ty> {\n+            fn borrow<'a>(&'a self) -> &'a $ty {\n+                &self.0\n+            }\n+        }\n+\n         impl<'tcx> TyCtxt<'tcx> {\n             pub fn $method(self, v: $ty) -> &'tcx $ty {\n-                self.interners.$name.intern_ref(&v, || {\n+                self.interners.$name.intern(v, |v| {\n                     Interned(self.interners.arena.alloc(v))\n                 }).0\n             }\n@@ -2107,6 +2076,8 @@ macro_rules! direct_interners {\n direct_interners! {\n     region: mk_region(RegionKind),\n     const_: mk_const(Const<'tcx>),\n+    const_allocation: intern_const_alloc(Allocation),\n+    layout: intern_layout(Layout),\n }\n \n macro_rules! slice_interners {"}, {"sha": "cfbbec374a172acc35fa6d9adf7cc97cd15755db", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 210, "deletions": 104, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -1,12 +1,10 @@\n-use crate::ich::StableHashingContext;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n use crate::ty::subst::Subst;\n use crate::ty::{self, subst::SubstsRef, ReprOptions, Ty, TyCtxt, TypeFoldable};\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::BitSet;\n@@ -18,15 +16,19 @@ use rustc_target::abi::call::{\n     ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, Conv, FnAbi, PassMode, Reg, RegKind,\n };\n use rustc_target::abi::*;\n-use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy};\n+use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy, Target};\n \n use std::cmp;\n use std::fmt;\n use std::iter;\n-use std::mem;\n use std::num::NonZeroUsize;\n use std::ops::Bound;\n \n+pub fn provide(providers: &mut ty::query::Providers) {\n+    *providers =\n+        ty::query::Providers { layout_of, fn_abi_of_fn_ptr, fn_abi_of_instance, ..*providers };\n+}\n+\n pub trait IntegerExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>, signed: bool) -> Ty<'tcx>;\n     fn from_attr<C: HasDataLayout>(cx: &C, ity: attr::IntType) -> Integer;\n@@ -191,7 +193,7 @@ pub const FAT_PTR_EXTRA: usize = 1;\n /// * Cranelift stores the base-2 log of the lane count in a 4 bit integer.\n pub const MAX_SIMD_LANES: u64 = 1 << 0xF;\n \n-#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable)]\n+#[derive(Copy, Clone, Debug, HashStable, TyEncodable, TyDecodable)]\n pub enum LayoutError<'tcx> {\n     Unknown(Ty<'tcx>),\n     SizeOverflow(Ty<'tcx>),\n@@ -248,10 +250,6 @@ fn layout_of<'tcx>(\n     })\n }\n \n-pub fn provide(providers: &mut ty::query::Providers) {\n-    *providers = ty::query::Providers { layout_of, ..*providers };\n-}\n-\n pub struct LayoutCx<'tcx, C> {\n     pub tcx: C,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -2015,6 +2013,12 @@ impl<'tcx> HasDataLayout for TyCtxt<'tcx> {\n     }\n }\n \n+impl<'tcx> HasTargetSpec for TyCtxt<'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.sess.target\n+    }\n+}\n+\n impl<'tcx> HasTyCtxt<'tcx> for TyCtxt<'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -2029,6 +2033,12 @@ impl<'tcx> HasDataLayout for ty::query::TyCtxtAt<'tcx> {\n     }\n }\n \n+impl<'tcx> HasTargetSpec for ty::query::TyCtxtAt<'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.sess.target\n+    }\n+}\n+\n impl<'tcx> HasTyCtxt<'tcx> for ty::query::TyCtxtAt<'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -2048,6 +2058,12 @@ impl<'tcx, T: HasDataLayout> HasDataLayout for LayoutCx<'tcx, T> {\n     }\n }\n \n+impl<'tcx, T: HasTargetSpec> HasTargetSpec for LayoutCx<'tcx, T> {\n+    fn target_spec(&self) -> &Target {\n+        self.tcx.target_spec()\n+    }\n+}\n+\n impl<'tcx, T: HasTyCtxt<'tcx>> HasTyCtxt<'tcx> for LayoutCx<'tcx, T> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.tcx()\n@@ -2130,10 +2146,10 @@ pub trait LayoutOf<'tcx>: LayoutOfHelpers<'tcx> {\n     #[inline]\n     fn spanned_layout_of(&self, ty: Ty<'tcx>, span: Span) -> Self::LayoutOfResult {\n         let span = if !span.is_dummy() { span } else { self.layout_tcx_at_span() };\n+        let tcx = self.tcx().at(span);\n+\n         MaybeResult::from(\n-            self.tcx()\n-                .at(span)\n-                .layout_of(self.param_env().and(ty))\n+            tcx.layout_of(self.param_env().and(ty))\n                 .map_err(|err| self.handle_layout_err(err, span, ty)),\n         )\n     }\n@@ -2519,24 +2535,12 @@ where\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for LayoutError<'tcx> {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        use crate::ty::layout::LayoutError::*;\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-\n-        match *self {\n-            Unknown(t) | SizeOverflow(t) => t.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n impl<'tcx> ty::Instance<'tcx> {\n     // NOTE(eddyb) this is private to avoid using it from outside of\n-    // `FnAbi::of_instance` - any other uses are either too high-level\n+    // `fn_abi_of_instance` - any other uses are either too high-level\n     // for `Instance` (e.g. typeck would use `Ty::fn_sig` instead),\n     // or should go through `FnAbi` instead, to avoid losing any\n-    // adjustments `FnAbi::of_instance` might be performing.\n+    // adjustments `fn_abi_of_instance` might be performing.\n     fn fn_sig_for_fn_abi(&self, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n         // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n         let ty = self.ty(tcx, ty::ParamEnv::reveal_all());\n@@ -2633,34 +2637,6 @@ impl<'tcx> ty::Instance<'tcx> {\n     }\n }\n \n-pub trait FnAbiExt<'tcx, C>\n-where\n-    C: LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>> + HasTargetSpec,\n-{\n-    /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n-    ///\n-    /// NB: this doesn't handle virtual calls - those should use `FnAbi::of_instance`\n-    /// instead, where the instance is an `InstanceDef::Virtual`.\n-    fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n-\n-    /// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for\n-    /// direct calls to an `fn`.\n-    ///\n-    /// NB: that includes virtual calls, which are represented by \"direct calls\"\n-    /// to an `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self;\n-\n-    fn new_internal(\n-        cx: &C,\n-        sig: ty::PolyFnSig<'tcx>,\n-        extra_args: &[Ty<'tcx>],\n-        caller_location: Option<Ty<'tcx>>,\n-        codegen_fn_attr_flags: CodegenFnAttrFlags,\n-        make_self_ptr_thin: bool,\n-    ) -> Self;\n-    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n-}\n-\n /// Calculates whether a function's ABI can unwind or not.\n ///\n /// This takes two primary parameters:\n@@ -2816,48 +2792,175 @@ pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n     }\n }\n \n-impl<'tcx, C> FnAbiExt<'tcx, C> for call::FnAbi<'tcx, Ty<'tcx>>\n-where\n-    C: LayoutOf<'tcx, LayoutOfResult = TyAndLayout<'tcx>> + HasTargetSpec,\n-{\n-    fn of_fn_ptr(cx: &C, sig: ty::PolyFnSig<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        call::FnAbi::new_internal(cx, sig, extra_args, None, CodegenFnAttrFlags::empty(), false)\n+/// Error produced by attempting to compute or adjust a `FnAbi`.\n+#[derive(Clone, Debug, HashStable)]\n+pub enum FnAbiError<'tcx> {\n+    /// Error produced by a `layout_of` call, while computing `FnAbi` initially.\n+    Layout(LayoutError<'tcx>),\n+\n+    /// Error produced by attempting to adjust a `FnAbi`, for a \"foreign\" ABI.\n+    AdjustForForeignAbi(call::AdjustForForeignAbiError),\n+}\n+\n+impl From<LayoutError<'tcx>> for FnAbiError<'tcx> {\n+    fn from(err: LayoutError<'tcx>) -> Self {\n+        Self::Layout(err)\n     }\n+}\n \n-    fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n-        let sig = instance.fn_sig_for_fn_abi(cx.tcx());\n+impl From<call::AdjustForForeignAbiError> for FnAbiError<'_> {\n+    fn from(err: call::AdjustForForeignAbiError) -> Self {\n+        Self::AdjustForForeignAbi(err)\n+    }\n+}\n \n-        let caller_location = if instance.def.requires_caller_location(cx.tcx()) {\n-            Some(cx.tcx().caller_location_ty())\n-        } else {\n-            None\n-        };\n+impl<'tcx> fmt::Display for FnAbiError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Layout(err) => err.fmt(f),\n+            Self::AdjustForForeignAbi(err) => err.fmt(f),\n+        }\n+    }\n+}\n+\n+// FIXME(eddyb) maybe use something like this for an unified `fn_abi_of`, not\n+// just for error handling.\n+#[derive(Debug)]\n+pub enum FnAbiRequest<'tcx> {\n+    OfFnPtr { sig: ty::PolyFnSig<'tcx>, extra_args: &'tcx ty::List<Ty<'tcx>> },\n+    OfInstance { instance: ty::Instance<'tcx>, extra_args: &'tcx ty::List<Ty<'tcx>> },\n+}\n+\n+/// Trait for contexts that want to be able to compute `FnAbi`s.\n+/// This automatically gives access to `FnAbiOf`, through a blanket `impl`.\n+pub trait FnAbiOfHelpers<'tcx>: LayoutOfHelpers<'tcx> {\n+    /// The `&FnAbi`-wrapping type (or `&FnAbi` itself), which will be\n+    /// returned from `fn_abi_of_*` (see also `handle_fn_abi_err`).\n+    type FnAbiOfResult: MaybeResult<&'tcx FnAbi<'tcx, Ty<'tcx>>>;\n \n-        let attrs = cx.tcx().codegen_fn_attrs(instance.def_id()).flags;\n+    /// Helper used for `fn_abi_of_*`, to adapt `tcx.fn_abi_of_*(...)` into a\n+    /// `Self::FnAbiOfResult` (which does not need to be a `Result<...>`).\n+    ///\n+    /// Most `impl`s, which propagate `FnAbiError`s, should simply return `err`,\n+    /// but this hook allows e.g. codegen to return only `&FnAbi` from its\n+    /// `cx.fn_abi_of_*(...)`, without any `Result<...>` around it to deal with\n+    /// (and any `FnAbiError`s are turned into fatal errors or ICEs).\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> <Self::FnAbiOfResult as MaybeResult<&'tcx FnAbi<'tcx, Ty<'tcx>>>>::Error;\n+}\n+\n+/// Blanket extension trait for contexts that can compute `FnAbi`s.\n+pub trait FnAbiOf<'tcx>: FnAbiOfHelpers<'tcx> {\n+    /// Compute a `FnAbi` suitable for indirect calls, i.e. to `fn` pointers.\n+    ///\n+    /// NB: this doesn't handle virtual calls - those should use `fn_abi_of_instance`\n+    /// instead, where the instance is an `InstanceDef::Virtual`.\n+    #[inline]\n+    fn fn_abi_of_fn_ptr(\n+        &self,\n+        sig: ty::PolyFnSig<'tcx>,\n+        extra_args: &'tcx ty::List<Ty<'tcx>>,\n+    ) -> Self::FnAbiOfResult {\n+        // FIXME(eddyb) get a better `span` here.\n+        let span = self.layout_tcx_at_span();\n+        let tcx = self.tcx().at(span);\n+\n+        MaybeResult::from(tcx.fn_abi_of_fn_ptr(self.param_env().and((sig, extra_args))).map_err(\n+            |err| self.handle_fn_abi_err(err, span, FnAbiRequest::OfFnPtr { sig, extra_args }),\n+        ))\n+    }\n \n-        call::FnAbi::new_internal(\n-            cx,\n-            sig,\n-            extra_args,\n-            caller_location,\n-            attrs,\n-            matches!(instance.def, ty::InstanceDef::Virtual(..)),\n+    /// Compute a `FnAbi` suitable for declaring/defining an `fn` instance, and for\n+    /// direct calls to an `fn`.\n+    ///\n+    /// NB: that includes virtual calls, which are represented by \"direct calls\"\n+    /// to an `InstanceDef::Virtual` instance (of `<dyn Trait as Trait>::fn`).\n+    #[inline]\n+    fn fn_abi_of_instance(\n+        &self,\n+        instance: ty::Instance<'tcx>,\n+        extra_args: &'tcx ty::List<Ty<'tcx>>,\n+    ) -> Self::FnAbiOfResult {\n+        // FIXME(eddyb) get a better `span` here.\n+        let span = self.layout_tcx_at_span();\n+        let tcx = self.tcx().at(span);\n+\n+        MaybeResult::from(\n+            tcx.fn_abi_of_instance(self.param_env().and((instance, extra_args))).map_err(|err| {\n+                // HACK(eddyb) at least for definitions of/calls to `Instance`s,\n+                // we can get some kind of span even if one wasn't provided.\n+                // However, we don't do this early in order to avoid calling\n+                // `def_span` unconditionally (which may have a perf penalty).\n+                let span = if !span.is_dummy() { span } else { tcx.def_span(instance.def_id()) };\n+                self.handle_fn_abi_err(err, span, FnAbiRequest::OfInstance { instance, extra_args })\n+            }),\n         )\n     }\n+}\n \n-    fn new_internal(\n-        cx: &C,\n+impl<C: FnAbiOfHelpers<'tcx>> FnAbiOf<'tcx> for C {}\n+\n+fn fn_abi_of_fn_ptr<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>)>,\n+) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n+    let (param_env, (sig, extra_args)) = query.into_parts();\n+\n+    LayoutCx { tcx, param_env }.fn_abi_new_uncached(\n+        sig,\n+        extra_args,\n+        None,\n+        CodegenFnAttrFlags::empty(),\n+        false,\n+    )\n+}\n+\n+fn fn_abi_of_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>)>,\n+) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n+    let (param_env, (instance, extra_args)) = query.into_parts();\n+\n+    let sig = instance.fn_sig_for_fn_abi(tcx);\n+\n+    let caller_location = if instance.def.requires_caller_location(tcx) {\n+        Some(tcx.caller_location_ty())\n+    } else {\n+        None\n+    };\n+\n+    let attrs = tcx.codegen_fn_attrs(instance.def_id()).flags;\n+\n+    LayoutCx { tcx, param_env }.fn_abi_new_uncached(\n+        sig,\n+        extra_args,\n+        caller_location,\n+        attrs,\n+        matches!(instance.def, ty::InstanceDef::Virtual(..)),\n+    )\n+}\n+\n+impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n+    // FIXME(eddyb) perhaps group the signature/type-containing (or all of them?)\n+    // arguments of this method, into a separate `struct`.\n+    fn fn_abi_new_uncached(\n+        &self,\n         sig: ty::PolyFnSig<'tcx>,\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n         codegen_fn_attr_flags: CodegenFnAttrFlags,\n+        // FIXME(eddyb) replace this with something typed, like an `enum`.\n         force_thin_self_ptr: bool,\n-    ) -> Self {\n-        debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n+    ) -> Result<&'tcx FnAbi<'tcx, Ty<'tcx>>, FnAbiError<'tcx>> {\n+        debug!(\"fn_abi_new_uncached({:?}, {:?})\", sig, extra_args);\n \n-        let sig = cx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), sig);\n+        let sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, sig);\n \n-        let conv = conv_from_spec_abi(cx.tcx(), sig.abi);\n+        let conv = conv_from_spec_abi(self.tcx(), sig.abi);\n \n         let mut inputs = sig.inputs();\n         let extra_args = if sig.abi == RustCall {\n@@ -2884,7 +2987,7 @@ where\n             extra_args.to_vec()\n         };\n \n-        let target = &cx.tcx().sess.target;\n+        let target = &self.tcx.sess.target;\n         let target_env_gnu_like = matches!(&target.env[..], \"gnu\" | \"musl\");\n         let win_x64_gnu = target.os == \"windows\" && target.arch == \"x86_64\" && target.env == \"gnu\";\n         let linux_s390x_gnu_like =\n@@ -2917,7 +3020,7 @@ where\n                 attrs.set(ArgAttribute::NonNull);\n             }\n \n-            if let Some(pointee) = layout.pointee_info_at(cx, offset) {\n+            if let Some(pointee) = layout.pointee_info_at(self, offset) {\n                 if let Some(kind) = pointee.safe {\n                     attrs.pointee_align = Some(pointee.align);\n \n@@ -2961,20 +3064,20 @@ where\n             }\n         };\n \n-        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n+        let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| -> Result<_, FnAbiError<'tcx>> {\n             let is_return = arg_idx.is_none();\n \n-            let layout = cx.layout_of(ty);\n+            let layout = self.layout_of(ty)?;\n             let layout = if force_thin_self_ptr && arg_idx == Some(0) {\n                 // Don't pass the vtable, it's not an argument of the virtual fn.\n                 // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n                 // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-                make_thin_self_ptr(cx, layout)\n+                make_thin_self_ptr(self, layout)\n             } else {\n                 layout\n             };\n \n-            let mut arg = ArgAbi::new(cx, layout, |layout, scalar, offset| {\n+            let mut arg = ArgAbi::new(self, layout, |layout, scalar, offset| {\n                 let mut attrs = ArgAttributes::new();\n                 adjust_for_rust_scalar(&mut attrs, scalar, *layout, offset, is_return);\n                 attrs\n@@ -2995,32 +3098,36 @@ where\n                 }\n             }\n \n-            arg\n+            Ok(arg)\n         };\n \n         let mut fn_abi = FnAbi {\n-            ret: arg_of(sig.output(), None),\n+            ret: arg_of(sig.output(), None)?,\n             args: inputs\n                 .iter()\n                 .cloned()\n                 .chain(extra_args)\n                 .chain(caller_location)\n                 .enumerate()\n                 .map(|(i, ty)| arg_of(ty, Some(i)))\n-                .collect(),\n+                .collect::<Result<_, _>>()?,\n             c_variadic: sig.c_variadic,\n             fixed_count: inputs.len(),\n             conv,\n-            can_unwind: fn_can_unwind(cx.tcx(), codegen_fn_attr_flags, sig.abi),\n+            can_unwind: fn_can_unwind(self.tcx(), codegen_fn_attr_flags, sig.abi),\n         };\n-        fn_abi.adjust_for_abi(cx, sig.abi);\n-        debug!(\"FnAbi::new_internal = {:?}\", fn_abi);\n-        fn_abi\n+        self.fn_abi_adjust_for_abi(&mut fn_abi, sig.abi)?;\n+        debug!(\"fn_abi_new_uncached = {:?}\", fn_abi);\n+        Ok(self.tcx.arena.alloc(fn_abi))\n     }\n \n-    fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi) {\n+    fn fn_abi_adjust_for_abi(\n+        &self,\n+        fn_abi: &mut FnAbi<'tcx, Ty<'tcx>>,\n+        abi: SpecAbi,\n+    ) -> Result<(), FnAbiError<'tcx>> {\n         if abi == SpecAbi::Unadjusted {\n-            return;\n+            return Ok(());\n         }\n \n         if abi == SpecAbi::Rust\n@@ -3057,7 +3164,7 @@ where\n                     // anyway, we control all calls to it in libstd.\n                     Abi::Vector { .. }\n                         if abi != SpecAbi::PlatformIntrinsic\n-                            && cx.tcx().sess.target.simd_types_indirect =>\n+                            && self.tcx.sess.target.simd_types_indirect =>\n                     {\n                         arg.make_indirect();\n                         return;\n@@ -3068,7 +3175,7 @@ where\n \n                 // Pass and return structures up to 2 pointers in size by value, matching `ScalarPair`.\n                 // LLVM will usually pass these in 2 registers, which is more efficient than by-ref.\n-                let max_by_val_size = Pointer.size(cx) * 2;\n+                let max_by_val_size = Pointer.size(self) * 2;\n                 let size = arg.layout.size;\n \n                 if arg.layout.is_unsized() || size > max_by_val_size {\n@@ -3080,16 +3187,15 @@ where\n                     arg.cast_to(Reg { kind: RegKind::Integer, size });\n                 }\n             };\n-            fixup(&mut self.ret);\n-            for arg in &mut self.args {\n+            fixup(&mut fn_abi.ret);\n+            for arg in &mut fn_abi.args {\n                 fixup(arg);\n             }\n-            return;\n+        } else {\n+            fn_abi.adjust_for_foreign_abi(self, abi)?;\n         }\n \n-        if let Err(msg) = self.adjust_for_cabi(cx, abi) {\n-            cx.tcx().sess.fatal(&msg);\n-        }\n+        Ok(())\n     }\n }\n "}, {"sha": "154b26464a804af2fc4f3963f9d26b826eeb4c92", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -48,6 +48,7 @@ use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n+use rustc_target::abi;\n use rustc_target::spec::PanicStrategy;\n \n use rustc_ast as ast;"}, {"sha": "563a3cf14382c74ad8ef7d094be0a9677cd12ed3", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -449,3 +449,25 @@ impl<'tcx> Key for (ty::Predicate<'tcx>, traits::WellFormedLoc) {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for (ty::PolyFnSig<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n+impl<'tcx> Key for (ty::Instance<'tcx>, &'tcx ty::List<Ty<'tcx>>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}"}, {"sha": "324278c57bf144ed2a09c5762b5ab5f1b55869a3", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91198820d7e697def79177c022b5e98b3d482ddc/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=91198820d7e697def79177c022b5e98b3d482ddc", "patch": "@@ -1,6 +1,7 @@\n use crate::abi::{self, Abi, Align, FieldsShape, Size};\n use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n+use std::fmt;\n \n mod aarch64;\n mod amdgpu;\n@@ -24,7 +25,7 @@ mod x86;\n mod x86_64;\n mod x86_win64;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum PassMode {\n     /// Ignore the argument.\n     ///\n@@ -59,7 +60,7 @@ pub use attr_impl::ArgAttribute;\n mod attr_impl {\n     // The subset of llvm::Attribute needed for arguments, packed into a bitfield.\n     bitflags::bitflags! {\n-        #[derive(Default)]\n+        #[derive(Default, HashStable_Generic)]\n         pub struct ArgAttribute: u16 {\n             const NoAlias   = 1 << 1;\n             const NoCapture = 1 << 2;\n@@ -76,7 +77,7 @@ mod attr_impl {\n /// Sometimes an ABI requires small integers to be extended to a full or partial register. This enum\n /// defines if this extension should be zero-extension or sign-extension when necessary. When it is\n /// not necessary to extend the argument, this enum is ignored.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum ArgExtension {\n     None,\n     Zext,\n@@ -85,7 +86,7 @@ pub enum ArgExtension {\n \n /// A compact representation of LLVM attributes (at least those relevant for this module)\n /// that can be manipulated without interacting with LLVM's Attribute machinery.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct ArgAttributes {\n     pub regular: ArgAttribute,\n     pub arg_ext: ArgExtension,\n@@ -126,14 +127,14 @@ impl ArgAttributes {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum RegKind {\n     Integer,\n     Float,\n     Vector,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct Reg {\n     pub kind: RegKind,\n     pub size: Size,\n@@ -183,7 +184,7 @@ impl Reg {\n \n /// An argument passed entirely registers with the\n /// same kind (e.g., HFA / HVA on PPC64 and AArch64).\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct Uniform {\n     pub unit: Reg,\n \n@@ -208,7 +209,7 @@ impl Uniform {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct CastTarget {\n     pub prefix: [Option<RegKind>; 8],\n     pub prefix_chunk_size: Size,\n@@ -436,7 +437,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n \n /// Information about how to pass an argument to,\n /// or return a value from, a function, under some ABI.\n-#[derive(Debug)]\n+#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct ArgAbi<'a, Ty> {\n     pub layout: TyAndLayout<'a, Ty>,\n \n@@ -544,7 +545,7 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum Conv {\n     // General language calling conventions, for which every target\n     // should have its own backend (e.g. LLVM) support.\n@@ -578,7 +579,7 @@ pub enum Conv {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(Debug)]\n+#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct FnAbi<'a, Ty> {\n     /// The LLVM types of each argument.\n     pub args: Vec<ArgAbi<'a, Ty>>,\n@@ -599,8 +600,29 @@ pub struct FnAbi<'a, Ty> {\n     pub can_unwind: bool,\n }\n \n+/// Error produced by attempting to adjust a `FnAbi`, for a \"foreign\" ABI.\n+#[derive(Clone, Debug, HashStable_Generic)]\n+pub enum AdjustForForeignAbiError {\n+    /// Target architecture doesn't support \"foreign\" (i.e. non-Rust) ABIs.\n+    Unsupported { arch: String, abi: spec::abi::Abi },\n+}\n+\n+impl fmt::Display for AdjustForForeignAbiError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Self::Unsupported { arch, abi } => {\n+                write!(f, \"target architecture {:?} does not support `extern {}` ABI\", arch, abi)\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, Ty> FnAbi<'a, Ty> {\n-    pub fn adjust_for_cabi<C>(&mut self, cx: &C, abi: spec::abi::Abi) -> Result<(), String>\n+    pub fn adjust_for_foreign_abi<C>(\n+        &mut self,\n+        cx: &C,\n+        abi: spec::abi::Abi,\n+    ) -> Result<(), AdjustForForeignAbiError>\n     where\n         Ty: TyAbiInterface<'a, C> + Copy,\n         C: HasDataLayout + HasTargetSpec,\n@@ -655,7 +677,9 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             }\n             \"asmjs\" => wasm::compute_c_abi_info(cx, self),\n             \"bpf\" => bpf::compute_abi_info(self),\n-            a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)),\n+            arch => {\n+                return Err(AdjustForForeignAbiError::Unsupported { arch: arch.to_string(), abi });\n+            }\n         }\n \n         Ok(())"}]}