{"sha": "0d9998cb973f497110789b4d97d1b9803aab6fb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkOTk5OGNiOTczZjQ5NzExMDc4OWI0ZDk3ZDFiOTgwM2FhYjZmYjE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-06-15T03:47:36Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-06-19T17:38:37Z"}, "message": "Added diagnostics for suggesting `mut x` on repeated mutations of `x`.\n\n(Follow-on commits updating the test suite show the resulting changes\nto diagnostic output.)", "tree": {"sha": "0ee301b35a28be257859684e6ce572ec33306adf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ee301b35a28be257859684e6ce572ec33306adf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d9998cb973f497110789b4d97d1b9803aab6fb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d9998cb973f497110789b4d97d1b9803aab6fb1", "html_url": "https://github.com/rust-lang/rust/commit/0d9998cb973f497110789b4d97d1b9803aab6fb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d9998cb973f497110789b4d97d1b9803aab6fb1/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "620a8536f614936237de9eb7a043dac46356512c", "url": "https://api.github.com/repos/rust-lang/rust/commits/620a8536f614936237de9eb7a043dac46356512c", "html_url": "https://github.com/rust-lang/rust/commit/620a8536f614936237de9eb7a043dac46356512c"}], "stats": {"total": 109, "additions": 63, "deletions": 46}, "files": [{"sha": "20a0df2a1717780c9c447f8cafead3cbb4dea256", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0d9998cb973f497110789b4d97d1b9803aab6fb1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9998cb973f497110789b4d97d1b9803aab6fb1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0d9998cb973f497110789b4d97d1b9803aab6fb1", "patch": "@@ -635,6 +635,45 @@ pub struct LocalDecl<'tcx> {\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n+    /// Returns true only if local is a binding that can itself be\n+    /// made mutable via the addition of the `mut` keyword, namely\n+    /// something like the occurrences of `x` in:\n+    /// - `fn foo(x: Type) { ... }`,\n+    /// - `let x = ...`,\n+    /// - or `match ... { C(x) => ... }`\n+    pub fn can_be_made_mutable(&self) -> bool\n+    {\n+        match self.is_user_variable {\n+            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info: _,\n+            }))) => true,\n+\n+            // FIXME: might be able to thread the distinction between\n+            // `self`/`mut self`/`&self`/`&mut self` into the\n+            // `BindingForm::ImplicitSelf` variant, (and then return\n+            // true here for solely the first case).\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if local is definitely not a `ref ident` or\n+    /// `ref mut ident` binding. (Such bindings cannot be made into\n+    /// mutable bindings, but the inverse does not necessarily hold).\n+    pub fn is_nonref_binding(&self) -> bool\n+    {\n+        match self.is_user_variable {\n+            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                binding_mode: ty::BindingMode::BindByValue(_),\n+                opt_ty_info: _,\n+            }))) => true,\n+\n+            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf)) => true,\n+\n+            _ => false,\n+        }\n+    }\n+\n     /// Create a new `LocalDecl` for a temporary.\n     #[inline]\n     pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {"}, {"sha": "38d1ac2cb4ad0482b97c5ae4a29fce422c9d5129", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0d9998cb973f497110789b4d97d1b9803aab6fb1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9998cb973f497110789b4d97d1b9803aab6fb1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=0d9998cb973f497110789b4d97d1b9803aab6fb1", "patch": "@@ -593,11 +593,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.emit();\n     }\n \n+    /// Reports an illegal reassignment; for example, an assignment to\n+    /// (part of) a non-`mut` local that occurs potentially after that\n+    /// local has already been initialized. `place` is the path being\n+    /// assigned; `err_place` is a place providing a reason why\n+    /// `place` is not mutable (e.g. the non-`mut` local `x` in an\n+    /// assignment to `x.f`).\n     pub(super) fn report_illegal_reassignment(\n         &mut self,\n         _context: Context,\n         (place, span): (&Place<'tcx>, Span),\n         assigned_span: Span,\n+        err_place: &Place<'tcx>,\n     ) {\n         let is_arg = if let Place::Local(local) = place {\n             if let LocalKind::Arg = self.mir.local_kind(*local) {\n@@ -621,16 +628,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"cannot assign twice to immutable variable\"\n         };\n         if span != assigned_span {\n-            if is_arg {\n-                err.span_label(assigned_span, \"argument not declared as `mut`\");\n-            } else {\n+            if !is_arg {\n                 let value_msg = match self.describe_place(place) {\n                     Some(name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n                 };\n                 err.span_label(assigned_span, format!(\"first assignment to {}\", value_msg));\n             }\n         }\n+        if let Place::Local(local) = err_place {\n+            let local_decl = &self.mir.local_decls[*local];\n+            if let Some(name) = local_decl.name {\n+                if local_decl.can_be_made_mutable() {\n+                    err.span_label(local_decl.source_info.span,\n+                                   format!(\"consider changing this to `mut {}`\", name));\n+                }\n+            }\n+        }\n         err.span_label(span, msg);\n         err.emit();\n     }"}, {"sha": "122b2df4766adbce7da67fc54a300f40e4049f52", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 7, "deletions": 43, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0d9998cb973f497110789b4d97d1b9803aab6fb1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d9998cb973f497110789b4d97d1b9803aab6fb1/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0d9998cb973f497110789b4d97d1b9803aab6fb1", "patch": "@@ -1398,9 +1398,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", place);\n         // determine if this path has a non-mut owner (and thus needs checking).\n-        if let Ok(..) = self.is_mutable(place, LocalMutationIsAllowed::No) {\n-            return;\n-        }\n+        let err_place = match self.is_mutable(place, LocalMutationIsAllowed::No) {\n+            Ok(..) => return,\n+            Err(place) => place,\n+        };\n         debug!(\n             \"check_if_reassignment_to_immutable_state({:?}) - is an imm local\",\n             place\n@@ -1410,7 +1411,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let init = self.move_data.inits[i];\n             let init_place = &self.move_data.move_paths[init.path].place;\n             if places_conflict(self.tcx, self.mir, &init_place, place, Deep) {\n-                self.report_illegal_reassignment(context, (place, span), init.span);\n+                self.report_illegal_reassignment(context, (place, span), init.span, err_place);\n                 break;\n             }\n         }\n@@ -1784,7 +1785,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match the_place_err {\n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n-            Place::Local(local) if local_can_be_made_mutable(self.mir, *local) => {\n+            Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n@@ -1819,7 +1820,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // arbitrary base for the projection?\n             Place::Projection(box Projection { base: Place::Local(local),\n                                                elem: ProjectionElem::Deref })\n-                if local_is_nonref_binding(self.mir, *local) =>\n+                if self.mir.local_decls[*local].is_nonref_binding() =>\n             {\n                 let (err_help_span, suggested_code) =\n                     find_place_to_suggest_ampmut(self.tcx, self.mir, *local);\n@@ -1846,43 +1847,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err.emit();\n         return true;\n \n-        // Returns true if local is a binding that can itself be made\n-        // mutable via the addition of the `mut` keyword, namely\n-        // something like:\n-        // - `fn foo(x: Type) { ... }`,\n-        // - `let x = ...`,\n-        // - or `match ... { C(x) => ... }`\n-        fn local_can_be_made_mutable(mir: &Mir, local: mir::Local) -> bool\n-        {\n-            let local = &mir.local_decls[local];\n-            match local.is_user_variable {\n-                Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                    binding_mode: ty::BindingMode::BindByValue(_),\n-                    opt_ty_info: _,\n-                }))) => true,\n-\n-                _ => false,\n-            }\n-        }\n-\n-        // Returns true if local is definitely not a `ref ident` or\n-        // `ref mut ident` binding. (Such bindings cannot be made into\n-        // mutable bindings.)\n-        fn local_is_nonref_binding(mir: &Mir, local: mir::Local) -> bool\n-        {\n-            let local = &mir.local_decls[local];\n-            match local.is_user_variable {\n-                Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                    binding_mode: ty::BindingMode::BindByValue(_),\n-                    opt_ty_info: _,\n-                }))) => true,\n-\n-                Some(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf)) => true,\n-\n-            _ => false,\n-            }\n-        }\n-\n         // Returns the span to highlight and the associated text to\n         // present when suggesting that the user use an `&mut`.\n         //"}]}