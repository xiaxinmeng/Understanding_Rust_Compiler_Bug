{"sha": "67d8d18b230dda20758f3733ebce56fb09f0e093", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZDhkMThiMjMwZGRhMjA3NThmMzczM2ViY2U1NmZiMDlmMGUwOTM=", "commit": {"author": {"name": "Justus K", "email": "justus.k@protonmail.com", "date": "2021-05-08T08:04:03Z"}, "committer": {"name": "Justus K", "email": "justus.k@protonmail.com", "date": "2021-05-15T11:21:35Z"}, "message": "Minimize amount of fake `DefId`s used in rustdoc", "tree": {"sha": "687ee9c8ec660934d909363ba364e1c33e797353", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/687ee9c8ec660934d909363ba364e1c33e797353"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67d8d18b230dda20758f3733ebce56fb09f0e093", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEDDGYqKFKtc1ioGY0jGL+mKYvxGIFAmCfrr8ACgkQjGL+mKYv\nxGI6kQ/+IYOn5/wzTSmi+miTHi3RsgxlFC1LeJxgjw/er5cu99h7GcxKp3rNTy+K\ncnhLLxEBaJPelUn4vsbuO7Z8MdUuRaQVFF+9ypPempnw/v0AA2Jom5TTa2P0KukI\nqx4XSmo4tE7tf3miWHX1zSRcBy42Y6U2RHOV3L1i111yh+Q6QzA11QzxUeXYmpQp\nh7ej2Sw5cRu4ylKznsI1M83kq0vbXOq2zW1eVcubI3NaE9paM8QkDT23VMEj4YWW\nJSCB7kPQrOa373l2800jbpThikLF2GN/rRx+2GRf7or47oWBz+GYHvDcqMsr4nM6\nh/XEFAVG6zcv7uKZK2NLddj/MFH8oUY7Jdm1d0/fD4khpxszJFIq0YLJCkFWggtw\njficksTghaKQpNvqb2t1kBs/EhGl3rfDkzL6/HwE0mUS1PRwxRD9FE8LTTXQlnUZ\nA/PDygdE6NcfMxRSimcx44gkfQed7Wtxj281C/LaxNgUFzBaYE6kJFcgXqsGq4sW\noFra1S9JYPHQR9/7kk12HxftcPNoitnB6+OoeyQg/ARi3O2fpX5ScQhYM8Y1UNsu\n3v3R9nnGouApzasbSiVT0mPBuj5seiJt08iJtnS0O56iv2ujj3vRvRrSPKjzMhCx\nvU9ZvFdv8HpUYEDrBpF0Yo1g2wnUV4NrC4VG/E0ngY71mXEDLn0=\n=f3py\n-----END PGP SIGNATURE-----", "payload": "tree 687ee9c8ec660934d909363ba364e1c33e797353\nparent c6dd87a6b4a62cf5d2cb6207b1dcea652ea1aa60\nauthor Justus K <justus.k@protonmail.com> 1620461043 +0200\ncommitter Justus K <justus.k@protonmail.com> 1621077695 +0200\n\nMinimize amount of fake `DefId`s used in rustdoc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67d8d18b230dda20758f3733ebce56fb09f0e093", "html_url": "https://github.com/rust-lang/rust/commit/67d8d18b230dda20758f3733ebce56fb09f0e093", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67d8d18b230dda20758f3733ebce56fb09f0e093/comments", "author": {"login": "Stupremee", "id": 39732259, "node_id": "MDQ6VXNlcjM5NzMyMjU5", "avatar_url": "https://avatars.githubusercontent.com/u/39732259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stupremee", "html_url": "https://github.com/Stupremee", "followers_url": "https://api.github.com/users/Stupremee/followers", "following_url": "https://api.github.com/users/Stupremee/following{/other_user}", "gists_url": "https://api.github.com/users/Stupremee/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stupremee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stupremee/subscriptions", "organizations_url": "https://api.github.com/users/Stupremee/orgs", "repos_url": "https://api.github.com/users/Stupremee/repos", "events_url": "https://api.github.com/users/Stupremee/events{/privacy}", "received_events_url": "https://api.github.com/users/Stupremee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Stupremee", "id": 39732259, "node_id": "MDQ6VXNlcjM5NzMyMjU5", "avatar_url": "https://avatars.githubusercontent.com/u/39732259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stupremee", "html_url": "https://github.com/Stupremee", "followers_url": "https://api.github.com/users/Stupremee/followers", "following_url": "https://api.github.com/users/Stupremee/following{/other_user}", "gists_url": "https://api.github.com/users/Stupremee/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stupremee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stupremee/subscriptions", "organizations_url": "https://api.github.com/users/Stupremee/orgs", "repos_url": "https://api.github.com/users/Stupremee/repos", "events_url": "https://api.github.com/users/Stupremee/events{/privacy}", "received_events_url": "https://api.github.com/users/Stupremee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6dd87a6b4a62cf5d2cb6207b1dcea652ea1aa60", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6dd87a6b4a62cf5d2cb6207b1dcea652ea1aa60", "html_url": "https://github.com/rust-lang/rust/commit/c6dd87a6b4a62cf5d2cb6207b1dcea652ea1aa60"}], "stats": {"total": 145, "additions": 55, "deletions": 90}, "files": [{"sha": "feeb03b1b67004db00205d262f0d8b7d523e73d0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -533,8 +533,7 @@ impl Clean<Generics> for hir::Generics<'_> {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds\n-                            .insert(FakeDefId::new_real(did).into(), bounds.clone());\n+                        cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n                     }\n                     GenericParamDefKind::Const { .. } => unreachable!(),\n                 }\n@@ -615,7 +614,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .collect::<Vec<GenericParamDef>>();\n \n         // param index -> [(DefId of trait, associated type name, type)]\n-        let mut impl_trait_proj = FxHashMap::<u32, Vec<(FakeDefId, Symbol, Ty<'tcx>)>>::default();\n+        let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n \n         let where_predicates = preds\n             .predicates\n@@ -687,13 +686,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                 if let Some(proj) = impl_trait_proj.remove(&idx) {\n                     for (trait_did, name, rhs) in proj {\n                         let rhs = rhs.clean(cx);\n-                        simplify::merge_bounds(\n-                            cx,\n-                            &mut bounds,\n-                            trait_did.expect_real(),\n-                            name,\n-                            &rhs,\n-                        );\n+                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs);\n                     }\n                 }\n             } else {\n@@ -1183,8 +1176,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 if let Some(new_ty) = cx.ty_substs.get(&did).cloned() {\n                     return new_ty;\n                 }\n-                if let Some(bounds) = cx.impl_trait_bounds.remove(&FakeDefId::new_real(did).into())\n-                {\n+                if let Some(bounds) = cx.impl_trait_bounds.remove(&did.into()) {\n                     return ImplTrait(bounds);\n                 }\n             }"}, {"sha": "edd3d77eeb7809b0acec5031b56f2c4983d43e05", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -73,10 +73,6 @@ impl FakeDefId {\n         Self::Fake(DefIndex::from(id), krate)\n     }\n \n-    crate fn new_real(id: DefId) -> Self {\n-        Self::Real(id)\n-    }\n-\n     #[inline]\n     crate fn is_local(self) -> bool {\n         match self {\n@@ -470,7 +466,7 @@ impl Item {\n             .filter_map(|ItemLink { link: s, link_text, did, ref fragment }| {\n                 match did {\n                     Some(did) => {\n-                        if let Some((mut href, ..)) = href(did.expect_real(), cx) {\n+                        if let Some((mut href, ..)) = href(did.clone(), cx) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push('#');\n                                 href.push_str(fragment);\n@@ -972,7 +968,7 @@ crate struct ItemLink {\n     /// This may not be the same as `link` if there was a disambiguator\n     /// in an intra-doc link (e.g. \\[`fn@f`\\])\n     pub(crate) link_text: String,\n-    pub(crate) did: Option<FakeDefId>,\n+    pub(crate) did: Option<DefId>,\n     /// The url fragment to append to the link\n     pub(crate) fragment: Option<String>,\n }"}, {"sha": "2930c3c5fb7ec510bdea8ac02a2ec01a78f48cd6", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -576,12 +576,12 @@ impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n crate enum ImplTraitParam {\n-    DefId(FakeDefId),\n+    DefId(DefId),\n     ParamIndex(u32),\n }\n \n-impl From<FakeDefId> for ImplTraitParam {\n-    fn from(did: FakeDefId) -> Self {\n+impl From<DefId> for ImplTraitParam {\n+    fn from(did: DefId) -> Self {\n         ImplTraitParam::DefId(did)\n     }\n }"}, {"sha": "5734a4a98e2b5f32f870497f28c8e567410d747e", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -67,7 +67,7 @@ crate struct Cache {\n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    crate implementors: FxHashMap<FakeDefId, Vec<Impl>>,\n+    crate implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n     crate extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc: item\n                                 .doc_value()\n                                 .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n-                            parent: parent.map(FakeDefId::new_real),\n+                            parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item, &self.empty_cache, self.tcx),\n                             aliases: item.attrs.get_doc_aliases(),"}, {"sha": "3e056c4b67a70df1d3127b54b22d9e7b910444cf", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -7,7 +7,7 @@ use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n use crate::clean::types::{\n-    FakeDefId, FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n+    FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n };\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n@@ -82,7 +82,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 defid_to_pathid.insert(defid, pathid);\n                 lastpathid += 1;\n \n-                if let Some(&(ref fqp, short)) = paths.get(&defid.expect_real()) {\n+                if let Some(&(ref fqp, short)) = paths.get(&defid) {\n                     crate_paths.push((short, fqp.last().unwrap().clone()));\n                     Some(pathid)\n                 } else {\n@@ -214,7 +214,7 @@ crate fn get_index_search_type<'tcx>(\n \n fn get_index_type(clean_type: &clean::Type, cache: &Cache) -> RenderType {\n     RenderType {\n-        ty: clean_type.def_id_full(cache).map(FakeDefId::new_real),\n+        ty: clean_type.def_id_full(cache),\n         idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n         generics: get_generics(clean_type, cache),\n@@ -256,7 +256,7 @@ fn get_generics(clean_type: &clean::Type, cache: &Cache) -> Option<Vec<Generic>>\n             .filter_map(|t| {\n                 get_index_type_name(t, false).map(|name| Generic {\n                     name: name.as_str().to_ascii_lowercase(),\n-                    defid: t.def_id_full(cache).map(FakeDefId::new_real),\n+                    defid: t.def_id_full(cache),\n                     idx: None,\n                 })\n             })"}, {"sha": "e4dbf145866296a64416c840d92f6de732e45cc1", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -87,7 +87,7 @@ crate struct IndexItem {\n     crate name: String,\n     crate path: String,\n     crate desc: String,\n-    crate parent: Option<FakeDefId>,\n+    crate parent: Option<DefId>,\n     crate parent_idx: Option<usize>,\n     crate search_type: Option<IndexItemFunctionType>,\n     crate aliases: Box<[String]>,\n@@ -96,7 +96,7 @@ crate struct IndexItem {\n /// A type used for the search index.\n #[derive(Debug)]\n crate struct RenderType {\n-    ty: Option<FakeDefId>,\n+    ty: Option<DefId>,\n     idx: Option<usize>,\n     name: Option<String>,\n     generics: Option<Vec<Generic>>,\n@@ -128,7 +128,7 @@ impl Serialize for RenderType {\n #[derive(Debug)]\n crate struct Generic {\n     name: String,\n-    defid: Option<FakeDefId>,\n+    defid: Option<DefId>,\n     idx: Option<usize>,\n }\n \n@@ -2137,7 +2137,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         \"</div>\",\n     );\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n         let cache = cx.cache();\n         let mut res = implementors\n             .iter()"}, {"sha": "ff639cb292462acd82cbbd4766ef3626b7fcd5d4", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -642,7 +642,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.def_id.expect_real(), AssocItemRender::All);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id.expect_real()) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();"}, {"sha": "c25a73f58eb602328f078f352ff71965f740485f", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -465,8 +465,6 @@ pub(super) fn write_shared(\n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n     for (&did, imps) in &cx.cache.implementors {\n-        let did = did.expect_real();\n-\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't"}, {"sha": "5ac43c736462257f12cd7bbb5184b90184da56ff", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -14,9 +14,8 @@ use rustc_span::Pos;\n \n use rustdoc_json_types::*;\n \n-use crate::clean;\n use crate::clean::utils::print_const_expr;\n-use crate::clean::FakeDefId;\n+use crate::clean::{self, FakeDefId};\n use crate::formats::item_type::ItemType;\n use crate::json::JsonRenderer;\n use std::collections::HashSet;\n@@ -31,7 +30,7 @@ impl JsonRenderer<'_> {\n             .into_iter()\n             .flatten()\n             .filter_map(|clean::ItemLink { link, did, .. }| {\n-                did.map(|did| (link.clone(), from_def_id(did)))\n+                did.map(|did| (link.clone(), from_def_id(did.into())))\n             })\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();"}, {"sha": "f8bd971081395a126f771a8bbc9921d3d20de4cd", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -12,13 +12,14 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n \n use rustdoc_json_types as types;\n \n use crate::clean;\n-use crate::clean::{ExternalCrate, FakeDefId};\n+use crate::clean::ExternalCrate;\n use crate::config::RenderOptions;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -42,7 +43,7 @@ impl JsonRenderer<'tcx> {\n         self.tcx.sess\n     }\n \n-    fn get_trait_implementors(&mut self, id: FakeDefId) -> Vec<types::Id> {\n+    fn get_trait_implementors(&mut self, id: DefId) -> Vec<types::Id> {\n         Rc::clone(&self.cache)\n             .implementors\n             .get(&id)\n@@ -59,10 +60,10 @@ impl JsonRenderer<'tcx> {\n             .unwrap_or_default()\n     }\n \n-    fn get_impls(&mut self, id: FakeDefId) -> Vec<types::Id> {\n+    fn get_impls(&mut self, id: DefId) -> Vec<types::Id> {\n         Rc::clone(&self.cache)\n             .impls\n-            .get(&id.expect_real())\n+            .get(&id)\n             .map(|impls| {\n                 impls\n                     .iter()\n@@ -163,11 +164,11 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         let id = item.def_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::Trait(ref mut t) = new_item.inner {\n-                t.implementors = self.get_trait_implementors(id)\n+                t.implementors = self.get_trait_implementors(id.expect_real())\n             } else if let types::ItemEnum::Struct(ref mut s) = new_item.inner {\n-                s.impls = self.get_impls(id)\n+                s.impls = self.get_impls(id.expect_real())\n             } else if let types::ItemEnum::Enum(ref mut e) = new_item.inner {\n-                e.impls = self.get_impls(id)\n+                e.impls = self.get_impls(id.expect_real())\n             }\n             let removed = self.index.borrow_mut().insert(from_def_id(id), new_item.clone());\n "}, {"sha": "88207b67743cf57233420100d32291da3ee79040", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 21, "deletions": 42, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -30,9 +30,7 @@ use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{\n-    self, utils::find_nearest_parent_module, Crate, FakeDefId, Item, ItemLink, PrimitiveType,\n-};\n+use crate::clean::{self, utils::find_nearest_parent_module, Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::{markdown_links, MarkdownLink};\n@@ -248,7 +246,7 @@ enum AnchorFailure {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n struct ResolutionInfo {\n-    module_id: FakeDefId,\n+    module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n     extra_fragment: Option<String>,\n@@ -274,7 +272,7 @@ struct LinkCollector<'a, 'tcx> {\n     ///\n     /// The last module will be used if the parent scope of the current item is\n     /// unknown.\n-    mod_ids: Vec<FakeDefId>,\n+    mod_ids: Vec<DefId>,\n     /// This is used to store the kind of associated items,\n     /// because `clean` and the disambiguator code expect them to be different.\n     /// See the code for associated items on inherent impls for details.\n@@ -861,7 +859,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n         if item.is_mod() && inner_docs {\n-            self.mod_ids.push(item.def_id);\n+            self.mod_ids.push(item.def_id.expect_real());\n         }\n \n         // We want to resolve in the lexical scope of the documentation.\n@@ -888,7 +886,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         Some(if item.is_mod() {\n             if !inner_docs {\n-                self.mod_ids.push(item.def_id);\n+                self.mod_ids.push(item.def_id.expect_real());\n             }\n \n             let ret = self.fold_item_recur(item);\n@@ -1070,11 +1068,8 @@ impl LinkCollector<'_, '_> {\n         // we've already pushed this node onto the resolution stack but\n         // for outer comments we explicitly try and resolve against the\n         // parent_node first.\n-        let base_node = if item.is_mod() && inner_docs {\n-            self.mod_ids.last().copied()\n-        } else {\n-            parent_node.map(|id| FakeDefId::new_real(id))\n-        };\n+        let base_node =\n+            if item.is_mod() && inner_docs { self.mod_ids.last().copied() } else { parent_node };\n \n         let mut module_id = if let Some(id) = base_node {\n             id\n@@ -1119,7 +1114,7 @@ impl LinkCollector<'_, '_> {\n                 resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n                 path_str = &resolved_self;\n             }\n-            module_id = FakeDefId::new_real(DefId { krate, index: CRATE_DEF_INDEX });\n+            module_id = DefId { krate, index: CRATE_DEF_INDEX };\n         }\n \n         let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n@@ -1180,8 +1175,8 @@ impl LinkCollector<'_, '_> {\n             report_diagnostic(self.cx.tcx, BROKEN_INTRA_DOC_LINKS, &msg, &diag_info, callback);\n         };\n \n-        let verify = |kind: DefKind, id: FakeDefId| {\n-            let (kind, id) = self.kind_side_channel.take().unwrap_or((kind, id.expect_real()));\n+        let verify = |kind: DefKind, id: DefId| {\n+            let (kind, id) = self.kind_side_channel.take().unwrap_or((kind, id));\n             debug!(\"intra-doc link to {} resolved to {:?} (id: {:?})\", path_str, res, id);\n \n             // Disallow e.g. linking to enums with `struct@`\n@@ -1345,7 +1340,7 @@ impl LinkCollector<'_, '_> {\n \n         match disambiguator.map(Disambiguator::ns) {\n             Some(expected_ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, expected_ns, base_node.expect_real(), extra_fragment) {\n+                match self.resolve(path_str, expected_ns, base_node, extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1354,12 +1349,9 @@ impl LinkCollector<'_, '_> {\n                             // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n                             // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for &new_ns in &[other_ns, MacroNS] {\n-                                if let Some(res) = self.check_full_res(\n-                                    new_ns,\n-                                    path_str,\n-                                    base_node.expect_real(),\n-                                    extra_fragment,\n-                                ) {\n+                                if let Some(res) =\n+                                    self.check_full_res(new_ns, path_str, base_node, extra_fragment)\n+                                {\n                                     kind = ResolutionFailure::WrongNamespace { res, expected_ns };\n                                     break;\n                                 }\n@@ -1381,14 +1373,9 @@ impl LinkCollector<'_, '_> {\n                 // Try everything!\n                 let mut candidates = PerNS {\n                     macro_ns: self\n-                        .resolve_macro(path_str, base_node.expect_real())\n+                        .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n-                    type_ns: match self.resolve(\n-                        path_str,\n-                        TypeNS,\n-                        base_node.expect_real(),\n-                        extra_fragment,\n-                    ) {\n+                    type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n@@ -1399,12 +1386,7 @@ impl LinkCollector<'_, '_> {\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(\n-                        path_str,\n-                        ValueNS,\n-                        base_node.expect_real(),\n-                        extra_fragment,\n-                    ) {\n+                    value_ns: match self.resolve(path_str, ValueNS, base_node, extra_fragment) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n                             anchor_failure(self.cx, diag, msg);\n@@ -1460,17 +1442,14 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             Some(MacroNS) => {\n-                match self.resolve_macro(path_str, base_node.expect_real()) {\n+                match self.resolve_macro(path_str, base_node) {\n                     Ok(res) => Some((res, extra_fragment.clone())),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n-                            if let Some(res) = self.check_full_res(\n-                                ns,\n-                                path_str,\n-                                base_node.expect_real(),\n-                                extra_fragment,\n-                            ) {\n+                            if let Some(res) =\n+                                self.check_full_res(ns, path_str, base_node, extra_fragment)\n+                            {\n                                 kind =\n                                     ResolutionFailure::WrongNamespace { res, expected_ns: MacroNS };\n                                 break;"}, {"sha": "9b7e10b2688bb71bf58e200627da73444ac8181e", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d8d18b230dda20758f3733ebce56fb09f0e093/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=67d8d18b230dda20758f3733ebce56fb09f0e093", "patch": "@@ -126,7 +126,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n         // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n         // `Deref` target type and the impl for type positions, this map of types is keyed by\n         // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n-        if cleaner.keep_impl_with_def_id(&FakeDefId::new_real(*type_did)) {\n+        if cleaner.keep_impl_with_def_id(FakeDefId::Real(*type_did)) {\n             add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did);\n         }\n     }\n@@ -206,13 +206,13 @@ impl BadImplStripper {\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n         } else if let Some(did) = ty.def_id() {\n-            self.keep_impl_with_def_id(&did.into())\n+            self.keep_impl_with_def_id(did.into())\n         } else {\n             false\n         }\n     }\n \n-    fn keep_impl_with_def_id(&self, did: &FakeDefId) -> bool {\n-        self.items.contains(did)\n+    fn keep_impl_with_def_id(&self, did: FakeDefId) -> bool {\n+        self.items.contains(&did)\n     }\n }"}]}