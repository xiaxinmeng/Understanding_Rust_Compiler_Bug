{"sha": "a6fda14394c956bdfa5f0dfac6992063d157fc41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZmRhMTQzOTRjOTU2YmRmYTVmMGRmYWM2OTkyMDYzZDE1N2ZjNDE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-26T14:08:24Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-26T14:08:24Z"}, "message": "Move `qualify_min_const_fn` out of rustc into clippy", "tree": {"sha": "b130feb7c1b6495f197a29baaca25af937851c98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b130feb7c1b6495f197a29baaca25af937851c98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6fda14394c956bdfa5f0dfac6992063d157fc41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6fda14394c956bdfa5f0dfac6992063d157fc41", "html_url": "https://github.com/rust-lang/rust/commit/a6fda14394c956bdfa5f0dfac6992063d157fc41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6fda14394c956bdfa5f0dfac6992063d157fc41/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6273be6fc26b22f91389a67a30c6633d60cc459d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6273be6fc26b22f91389a67a30c6633d60cc459d", "html_url": "https://github.com/rust-lang/rust/commit/6273be6fc26b22f91389a67a30c6633d60cc459d"}], "stats": {"total": 466, "additions": 465, "deletions": 1}, "files": [{"sha": "c3ff34e6e1eedd86002c0fc3151c5208c1ff471b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a6fda14394c956bdfa5f0dfac6992063d157fc41", "patch": "@@ -6,6 +6,7 @@\n #![feature(concat_idents)]\n #![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n+#![feature(in_band_lifetimes)]\n #![feature(or_patterns)]\n #![feature(rustc_private)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "e5f7cc51111203756298c993bc47be8e4bc4ff3f", "filename": "clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=a6fda14394c956bdfa5f0dfac6992063d157fc41", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, Constness, FnDecl, GenericParamKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n-use rustc_mir::transform::qualify_min_const_fn::is_min_const_fn;\n+use crate::utils::qualify_min_const_fn::is_min_const_fn;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;"}, {"sha": "96d9905027b628e2f2c14ba8f0d20f2b2d77869f", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=a6fda14394c956bdfa5f0dfac6992063d157fc41", "patch": "@@ -20,6 +20,7 @@ pub mod paths;\n pub mod ptr;\n pub mod sugg;\n pub mod usage;\n+pub mod qualify_min_const_fn;\n \n pub use self::attrs::*;\n pub use self::diagnostics::*;"}, {"sha": "9fa9b0341b109f03cbe8062edb8fc0f378e02995", "filename": "clippy_lints/src/utils/qualify_min_const_fn.rs", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6fda14394c956bdfa5f0dfac6992063d157fc41/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs?ref=a6fda14394c956bdfa5f0dfac6992063d157fc41", "patch": "@@ -0,0 +1,462 @@\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};\n+use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::Span;\n+use rustc_target::spec::abi::Abi::RustIntrinsic;\n+use std::borrow::Cow;\n+\n+type McfResult = Result<(), (Span, Cow<'static, str>)>;\n+\n+pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n+    // Prevent const trait methods from being annotated as `stable`.\n+    if tcx.features().staged_api {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+        if rustc_mir::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n+            return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n+        }\n+    }\n+\n+    let mut current = def_id;\n+    loop {\n+        let predicates = tcx.predicates_of(current);\n+        for (predicate, _) in predicates.predicates {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::RegionOutlives(_)\n+                | ty::PredicateAtom::TypeOutlives(_)\n+                | ty::PredicateAtom::WellFormed(_)\n+                | ty::PredicateAtom::Projection(_)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..)\n+                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n+                ty::PredicateAtom::ObjectSafe(_) => {\n+                    panic!(\"object safe predicate on function: {:#?}\", predicate)\n+                }\n+                ty::PredicateAtom::ClosureKind(..) => {\n+                    panic!(\"closure kind predicate on function: {:#?}\", predicate)\n+                }\n+                ty::PredicateAtom::Subtype(_) => {\n+                    panic!(\"subtype predicate on function: {:#?}\", predicate)\n+                }\n+                ty::PredicateAtom::Trait(pred, constness) => {\n+                    if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n+                        continue;\n+                    }\n+                    match pred.self_ty().kind() {\n+                        ty::Param(ref p) => {\n+                            // Allow `T: ?const Trait`\n+                            if constness == hir::Constness::NotConst\n+                                && feature_allowed(tcx, def_id, sym::const_trait_bound_opt_out)\n+                            {\n+                                continue;\n+                            }\n+\n+                            let generics = tcx.generics_of(current);\n+                            let def = generics.type_param(p, tcx);\n+                            let span = tcx.def_span(def.def_id);\n+                            return Err((\n+                                span,\n+                                \"trait bounds other than `Sized` \\\n+                                 on const fn parameters are unstable\"\n+                                    .into(),\n+                            ));\n+                        }\n+                        // other kinds of bounds are either tautologies\n+                        // or cause errors in other passes\n+                        _ => continue,\n+                    }\n+                }\n+            }\n+        }\n+        match predicates.parent {\n+            Some(parent) => current = parent,\n+            None => break,\n+        }\n+    }\n+\n+    for local in &body.local_decls {\n+        check_ty(tcx, local.ty, local.source_info.span, def_id)?;\n+    }\n+    // impl trait is gone in MIR, so check the return type manually\n+    check_ty(\n+        tcx,\n+        tcx.fn_sig(def_id).output().skip_binder(),\n+        body.local_decls.iter().next().unwrap().source_info.span,\n+        def_id,\n+    )?;\n+\n+    for bb in body.basic_blocks() {\n+        check_terminator(tcx, body, def_id, bb.terminator())?;\n+        for stmt in &bb.statements {\n+            check_statement(tcx, body, def_id, stmt)?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n+    for arg in ty.walk() {\n+        let ty = match arg.unpack() {\n+            GenericArgKind::Type(ty) => ty,\n+\n+            // No constraints on lifetimes or constants, except potentially\n+            // constants' types, but `walk` will get to them as well.\n+            GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => continue,\n+        };\n+\n+        match ty.kind() {\n+            ty::Ref(_, _, hir::Mutability::Mut) => {\n+                if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {\n+                    return Err((span, \"mutable references in const fn are unstable\".into()));\n+                }\n+            }\n+            ty::Opaque(..) => return Err((span, \"`impl Trait` in const fn is unstable\".into())),\n+            ty::FnPtr(..) => {\n+                if !tcx.const_fn_is_allowed_fn_ptr(fn_def_id) {\n+                    return Err((span, \"function pointers in const fn are unstable\".into()));\n+                }\n+            }\n+            ty::Dynamic(preds, _) => {\n+                for pred in preds.iter() {\n+                    match pred.skip_binder() {\n+                        ty::ExistentialPredicate::AutoTrait(_)\n+                        | ty::ExistentialPredicate::Projection(_) => {\n+                            return Err((\n+                                span,\n+                                \"trait bounds other than `Sized` \\\n+                                 on const fn parameters are unstable\"\n+                                    .into(),\n+                            ));\n+                        }\n+                        ty::ExistentialPredicate::Trait(trait_ref) => {\n+                            if Some(trait_ref.def_id) != tcx.lang_items().sized_trait() {\n+                                return Err((\n+                                    span,\n+                                    \"trait bounds other than `Sized` \\\n+                                     on const fn parameters are unstable\"\n+                                        .into(),\n+                                ));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    Ok(())\n+}\n+\n+fn check_rvalue(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    rvalue: &Rvalue<'tcx>,\n+    span: Span,\n+) -> McfResult {\n+    match rvalue {\n+        Rvalue::ThreadLocalRef(_) => {\n+            Err((span, \"cannot access thread local storage in const fn\".into()))\n+        }\n+        Rvalue::Repeat(operand, _) | Rvalue::Use(operand) => {\n+            check_operand(tcx, operand, span, def_id, body)\n+        }\n+        Rvalue::Len(place)\n+        | Rvalue::Discriminant(place)\n+        | Rvalue::Ref(_, _, place)\n+        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span, def_id, body),\n+        Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n+            use rustc_middle::ty::cast::CastTy;\n+            let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n+            let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+            match (cast_in, cast_out) {\n+                (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n+                    Err((span, \"casting pointers to ints is unstable in const fn\".into()))\n+                }\n+                _ => check_operand(tcx, operand, span, def_id, body),\n+            }\n+        }\n+        Rvalue::Cast(\n+            CastKind::Pointer(PointerCast::MutToConstPointer | PointerCast::ArrayToPointer),\n+            operand,\n+            _,\n+        ) => check_operand(tcx, operand, span, def_id, body),\n+        Rvalue::Cast(\n+            CastKind::Pointer(\n+                PointerCast::UnsafeFnPointer\n+                | PointerCast::ClosureFnPointer(_)\n+                | PointerCast::ReifyFnPointer,\n+            ),\n+            _,\n+            _,\n+        ) => Err((span, \"function pointer casts are not allowed in const fn\".into())),\n+        Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), op, cast_ty) => {\n+            let pointee_ty = if let Some(deref_ty) = cast_ty.builtin_deref(true) {\n+                deref_ty.ty\n+            } else {\n+                // We cannot allow this for now.\n+                return Err((\n+                    span,\n+                    \"unsizing casts are only allowed for references right now\".into(),\n+                ));\n+            };\n+            let unsized_ty = tcx.struct_tail_erasing_lifetimes(pointee_ty, tcx.param_env(def_id));\n+            if let ty::Slice(_) | ty::Str = unsized_ty.kind() {\n+                check_operand(tcx, op, span, def_id, body)?;\n+                // Casting/coercing things to slices is fine.\n+                Ok(())\n+            } else {\n+                // We just can't allow trait objects until we have figured out trait method calls.\n+                Err((span, \"unsizing casts are not allowed in const fn\".into()))\n+            }\n+        }\n+        // binops are fine on integers\n+        Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n+            check_operand(tcx, lhs, span, def_id, body)?;\n+            check_operand(tcx, rhs, span, def_id, body)?;\n+            let ty = lhs.ty(body, tcx);\n+            if ty.is_integral() || ty.is_bool() || ty.is_char() {\n+                Ok(())\n+            } else {\n+                Err((span, \"only int, `bool` and `char` operations are stable in const fn\".into()))\n+            }\n+        }\n+        Rvalue::NullaryOp(NullOp::SizeOf, _) => Ok(()),\n+        Rvalue::NullaryOp(NullOp::Box, _) => {\n+            Err((span, \"heap allocations are not allowed in const fn\".into()))\n+        }\n+        Rvalue::UnaryOp(_, operand) => {\n+            let ty = operand.ty(body, tcx);\n+            if ty.is_integral() || ty.is_bool() {\n+                check_operand(tcx, operand, span, def_id, body)\n+            } else {\n+                Err((span, \"only int and `bool` operations are stable in const fn\".into()))\n+            }\n+        }\n+        Rvalue::Aggregate(_, operands) => {\n+            for operand in operands {\n+                check_operand(tcx, operand, span, def_id, body)?;\n+            }\n+            Ok(())\n+        }\n+    }\n+}\n+\n+fn check_statement(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    def_id: DefId,\n+    statement: &Statement<'tcx>,\n+) -> McfResult {\n+    let span = statement.source_info.span;\n+    match &statement.kind {\n+        StatementKind::Assign(box (place, rval)) => {\n+            check_place(tcx, *place, span, def_id, body)?;\n+            check_rvalue(tcx, body, def_id, rval, span)\n+        }\n+\n+        StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, def_id, body),\n+\n+        // just an assignment\n+        StatementKind::SetDiscriminant { place, .. } => {\n+            check_place(tcx, **place, span, def_id, body)\n+        }\n+\n+        StatementKind::LlvmInlineAsm { .. } => {\n+            Err((span, \"cannot use inline assembly in const fn\".into()))\n+        }\n+\n+        // These are all NOPs\n+        StatementKind::StorageLive(_)\n+        | StatementKind::StorageDead(_)\n+        | StatementKind::Retag { .. }\n+        | StatementKind::AscribeUserType(..)\n+        | StatementKind::Coverage(..)\n+        | StatementKind::Nop => Ok(()),\n+    }\n+}\n+\n+fn check_operand(\n+    tcx: TyCtxt<'tcx>,\n+    operand: &Operand<'tcx>,\n+    span: Span,\n+    def_id: DefId,\n+    body: &Body<'tcx>,\n+) -> McfResult {\n+    match operand {\n+        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, def_id, body),\n+        Operand::Constant(c) => match c.check_static_ptr(tcx) {\n+            Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n+            None => Ok(()),\n+        },\n+    }\n+}\n+\n+fn check_place(\n+    tcx: TyCtxt<'tcx>,\n+    place: Place<'tcx>,\n+    span: Span,\n+    def_id: DefId,\n+    body: &Body<'tcx>,\n+) -> McfResult {\n+    let mut cursor = place.projection.as_ref();\n+    while let &[ref proj_base @ .., elem] = cursor {\n+        cursor = proj_base;\n+        match elem {\n+            ProjectionElem::Field(..) => {\n+                let base_ty = Place::ty_from(place.local, &proj_base, body, tcx).ty;\n+                if let Some(def) = base_ty.ty_adt_def() {\n+                    // No union field accesses in `const fn`\n+                    if def.is_union() {\n+                        if !feature_allowed(tcx, def_id, sym::const_fn_union) {\n+                            return Err((span, \"accessing union fields is unstable\".into()));\n+                        }\n+                    }\n+                }\n+            }\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Downcast(..)\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Deref\n+            | ProjectionElem::Index(_) => {}\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+/// Returns `true` if the given feature gate is allowed within the function with the given `DefId`.\n+fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n+    // All features require that the corresponding gate be enabled,\n+    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n+    if !tcx.features().enabled(feature_gate) {\n+        return false;\n+    }\n+\n+    // If this crate is not using stability attributes, or this function is not claiming to be a\n+    // stable `const fn`, that is all that is required.\n+    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n+        return true;\n+    }\n+\n+    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n+    // opt-in via `allow_internal_unstable`.\n+    rustc_mir::transform::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n+}\n+\n+/// Returns `true` if the given library feature gate is allowed within the function with the given `DefId`.\n+pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n+    // All features require that the corresponding gate be enabled,\n+    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n+    if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == feature_gate) {\n+        return false;\n+    }\n+\n+    // If this crate is not using stability attributes, or this function is not claiming to be a\n+    // stable `const fn`, that is all that is required.\n+    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n+        return true;\n+    }\n+\n+    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n+    // opt-in via `allow_internal_unstable`.\n+    rustc_mir::transform::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n+}\n+\n+fn check_terminator(\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+    def_id: DefId,\n+    terminator: &Terminator<'tcx>,\n+) -> McfResult {\n+    let span = terminator.source_info.span;\n+    match &terminator.kind {\n+        TerminatorKind::FalseEdge { .. }\n+        | TerminatorKind::FalseUnwind { .. }\n+        | TerminatorKind::Goto { .. }\n+        | TerminatorKind::Return\n+        | TerminatorKind::Resume\n+        | TerminatorKind::Unreachable => Ok(()),\n+\n+        TerminatorKind::Drop { place, .. } => check_place(tcx, *place, span, def_id, body),\n+        TerminatorKind::DropAndReplace { place, value, .. } => {\n+            check_place(tcx, *place, span, def_id, body)?;\n+            check_operand(tcx, value, span, def_id, body)\n+        }\n+\n+        TerminatorKind::SwitchInt { discr, switch_ty: _, values: _, targets: _ } => {\n+            check_operand(tcx, discr, span, def_id, body)\n+        }\n+\n+        TerminatorKind::Abort => Err((span, \"abort is not stable in const fn\".into())),\n+        TerminatorKind::GeneratorDrop | TerminatorKind::Yield { .. } => {\n+            Err((span, \"const fn generators are unstable\".into()))\n+        }\n+\n+        TerminatorKind::Call {\n+            func,\n+            args,\n+            from_hir_call: _,\n+            destination: _,\n+            cleanup: _,\n+            fn_span: _,\n+        } => {\n+            let fn_ty = func.ty(body, tcx);\n+            if let ty::FnDef(fn_def_id, _) = *fn_ty.kind() {\n+                // Allow unstable const if we opt in by using #[allow_internal_unstable]\n+                // on function or macro declaration.\n+                if !rustc_mir::const_eval::is_min_const_fn(tcx, fn_def_id)\n+                    && !rustc_mir::const_eval::is_unstable_const_fn(tcx, fn_def_id)\n+                        .map(|feature| {\n+                            span.allows_unstable(feature)\n+                                || lib_feature_allowed(tcx, def_id, feature)\n+                        })\n+                        .unwrap_or(false)\n+                {\n+                    return Err((\n+                        span,\n+                        format!(\n+                            \"can only call other `const fn` within a `const fn`, \\\n+                             but `{:?}` is not stable as `const fn`\",\n+                            func,\n+                        )\n+                        .into(),\n+                    ));\n+                }\n+\n+                // HACK: This is to \"unstabilize\" the `transmute` intrinsic\n+                // within const fns. `transmute` is allowed in all other const contexts.\n+                // This won't really scale to more intrinsics or functions. Let's allow const\n+                // transmutes in const fn before we add more hacks to this.\n+                if tcx.fn_sig(fn_def_id).abi() == RustIntrinsic\n+                    && tcx.item_name(fn_def_id) == sym::transmute\n+                    && !feature_allowed(tcx, def_id, sym::const_fn_transmute)\n+                {\n+                    return Err((\n+                        span,\n+                        \"can only call `transmute` from const items, not `const fn`\".into(),\n+                    ));\n+                }\n+\n+                check_operand(tcx, func, span, fn_def_id, body)?;\n+\n+                for arg in args {\n+                    check_operand(tcx, arg, span, fn_def_id, body)?;\n+                }\n+                Ok(())\n+            } else {\n+                Err((span, \"can only call other const fns within const fn\".into()))\n+            }\n+        }\n+\n+        TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n+            check_operand(tcx, cond, span, def_id, body)\n+        }\n+\n+        TerminatorKind::InlineAsm { .. } => {\n+            Err((span, \"cannot use inline assembly in const fn\".into()))\n+        }\n+    }\n+}"}]}