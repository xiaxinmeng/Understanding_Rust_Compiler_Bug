{"sha": "309710dece0cfb247938ff772dc84f37ffc71af3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwOTcxMGRlY2UwY2ZiMjQ3OTM4ZmY3NzJkYzg0ZjM3ZmZjNzFhZjM=", "commit": {"author": {"name": "Fabian Wolff", "email": "fabi.wolff@arcor.de", "date": "2021-05-06T19:15:12Z"}, "committer": {"name": "Fabian Wolff", "email": "fabi.wolff@arcor.de", "date": "2021-05-06T20:31:42Z"}, "message": "Fix stack overflow when checking for structural recursion", "tree": {"sha": "a23676538a0057364bf27825375b4fba9e40ddc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a23676538a0057364bf27825375b4fba9e40ddc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/309710dece0cfb247938ff772dc84f37ffc71af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/309710dece0cfb247938ff772dc84f37ffc71af3", "html_url": "https://github.com/rust-lang/rust/commit/309710dece0cfb247938ff772dc84f37ffc71af3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/309710dece0cfb247938ff772dc84f37ffc71af3/comments", "author": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "377d1a984cd2a53327092b90aa1d8b7e22d1e347", "url": "https://api.github.com/repos/rust-lang/rust/commits/377d1a984cd2a53327092b90aa1d8b7e22d1e347", "html_url": "https://github.com/rust-lang/rust/commit/377d1a984cd2a53327092b90aa1d8b7e22d1e347"}], "stats": {"total": 216, "additions": 199, "deletions": 17}, "files": [{"sha": "bf8d6335dad06f7fccf008d736cfe6d7bb105d9b", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 199, "deletions": 17, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/309710dece0cfb247938ff772dc84f37ffc71af3/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/309710dece0cfb247938ff772dc84f37ffc71af3/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=309710dece0cfb247938ff772dc84f37ffc71af3", "patch": "@@ -28,8 +28,18 @@ pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> R\n     // contains a different, structurally recursive type, maintain a stack\n     // of seen types and check recursion for each of them (issues #3008, #3779).\n     let mut seen: Vec<Ty<'_>> = Vec::new();\n+    let mut shadow_seen: Vec<Ty<'_>> = Vec::new();\n     let mut representable_cache = FxHashMap::default();\n-    let r = is_type_structurally_recursive(tcx, sp, &mut seen, &mut representable_cache, ty);\n+    let mut f_res = false;\n+    let r = is_type_structurally_recursive(\n+        tcx,\n+        sp,\n+        &mut seen,\n+        &mut shadow_seen,\n+        &mut representable_cache,\n+        ty,\n+        &mut f_res,\n+    );\n     debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n     r\n }\n@@ -48,21 +58,38 @@ fn are_inner_types_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<Ty<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    f_res: &mut bool,\n ) -> Representability {\n+    debug!(\"are_inner_types_recursive({:?}, {:?}, {:?})\", ty, seen, shadow_seen);\n     match ty.kind() {\n         ty::Tuple(..) => {\n             // Find non representable\n-            fold_repr(\n-                ty.tuple_fields().map(|ty| {\n-                    is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty)\n-                }),\n-            )\n+            fold_repr(ty.tuple_fields().map(|ty| {\n+                is_type_structurally_recursive(\n+                    tcx,\n+                    sp,\n+                    seen,\n+                    shadow_seen,\n+                    representable_cache,\n+                    ty,\n+                    f_res,\n+                )\n+            }))\n         }\n         // Fixed-length vectors.\n         // FIXME(#11924) Behavior undecided for zero-length vectors.\n-        ty::Array(ty, _) => is_type_structurally_recursive(tcx, sp, seen, representable_cache, ty),\n+        ty::Array(ty, _) => is_type_structurally_recursive(\n+            tcx,\n+            sp,\n+            seen,\n+            shadow_seen,\n+            representable_cache,\n+            ty,\n+            f_res,\n+        ),\n         ty::Adt(def, substs) => {\n             // Find non representable fields with their spans\n             fold_repr(def.all_fields().map(|field| {\n@@ -76,12 +103,142 @@ fn are_inner_types_recursive<'tcx>(\n                     Some(hir::Node::Field(field)) => field.ty.span,\n                     _ => sp,\n                 };\n-                match is_type_structurally_recursive(tcx, span, seen, representable_cache, ty) {\n-                    Representability::SelfRecursive(_) => {\n-                        Representability::SelfRecursive(vec![span])\n+\n+                let mut result = None;\n+\n+                // First, we check whether the field type per se is representable.\n+                // This catches cases as in #74224 and #84611. There is a special\n+                // case related to mutual recursion, though; consider this example:\n+                //\n+                //   struct A<T> {\n+                //       z: T,\n+                //       x: B<T>,\n+                //   }\n+                //\n+                //   struct B<T> {\n+                //       y: A<T>\n+                //   }\n+                //\n+                // Here, without the following special case, both A and B are\n+                // ContainsRecursive, which is a problem because we only report\n+                // errors for SelfRecursive. We fix this by detecting this special\n+                // case (shadow_seen.first() is the type we are originally\n+                // interested in, and if we ever encounter the same AdtDef again,\n+                // we know that it must be SelfRecursive) and \"forcibly\" returning\n+                // SelfRecursive (by setting f_res, which tells the calling\n+                // invocations of are_inner_types_representable to forward the\n+                // result without adjusting).\n+                if shadow_seen.len() > 1 && shadow_seen.len() > seen.len() {\n+                    match shadow_seen.first().map(|ty| ty.kind()) {\n+                        Some(ty::Adt(f_def, _)) => {\n+                            if f_def == def {\n+                                *f_res = true;\n+                                result = Some(Representability::SelfRecursive(vec![span]));\n+                            }\n+                        }\n+                        Some(_) => {\n+                            bug!(\"shadow_seen stack contains non-ADT type: {:?}\", ty);\n+                        }\n+                        None => unreachable!(),\n+                    }\n+                }\n+\n+                if result == None {\n+                    result = Some(Representability::Representable);\n+\n+                    // Now, we check whether the field types per se are representable, e.g.\n+                    // for struct Foo { x: Option<Foo> }, we first check whether Option<_>\n+                    // by itself is representable (which it is), and the nesting of Foo\n+                    // will be detected later. This is necessary for #74224 and #84611.\n+\n+                    // If we have encountered an ADT definition that we have not seen\n+                    // before (no need to check them twice), recurse to see whether that\n+                    // definition is SelfRecursive. If so, we must be ContainsRecursive.\n+                    if shadow_seen.iter().len() > 1\n+                        && !shadow_seen.iter().take(shadow_seen.iter().len() - 1).any(|seen_ty| {\n+                            match seen_ty.kind() {\n+                                ty::Adt(seen_def, _) => seen_def == def,\n+                                _ => {\n+                                    bug!(\"seen stack contains non-ADT type: {:?}\", seen_ty);\n+                                }\n+                            }\n+                        })\n+                    {\n+                        let adt_def_id = def.did;\n+                        let raw_adt_ty = tcx.type_of(adt_def_id);\n+                        debug!(\"are_inner_types_recursive: checking nested type: {:?}\", raw_adt_ty);\n+\n+                        // Check independently whether the ADT is SelfRecursive. If so,\n+                        // we must be ContainsRecursive (except for the special case\n+                        // mentioned above).\n+                        let mut nested_seen: Vec<Ty<'_>> = vec![];\n+                        result = Some(\n+                            match is_type_structurally_recursive(\n+                                tcx,\n+                                span,\n+                                &mut nested_seen,\n+                                shadow_seen,\n+                                representable_cache,\n+                                raw_adt_ty,\n+                                f_res,\n+                            ) {\n+                                Representability::SelfRecursive(_) => {\n+                                    if *f_res {\n+                                        Representability::SelfRecursive(vec![span])\n+                                    } else {\n+                                        Representability::ContainsRecursive\n+                                    }\n+                                }\n+                                x => x,\n+                            },\n+                        );\n+                    }\n+\n+                    // We only enter the following block if the type looks representable\n+                    // so far. This is necessary for cases such as this one (#74224):\n+                    //\n+                    //   struct A<T> {\n+                    //       x: T,\n+                    //       y: A<A<T>>,\n+                    //   }\n+                    //\n+                    //   struct B {\n+                    //       z: A<usize>\n+                    //   }\n+                    //\n+                    // When checking B, we recurse into A and check field y of type\n+                    // A<A<usize>>. We haven't seen this exact type before, so we recurse\n+                    // into A<A<usize>>, which contains, A<A<A<usize>>>, and so forth,\n+                    // ad infinitum. We can prevent this from happening by first checking\n+                    // A separately (the code above) and only checking for nested Bs if\n+                    // A actually looks representable (which it wouldn't in this example).\n+                    if result == Some(Representability::Representable) {\n+                        // Now, even if the type is representable (e.g. Option<_>),\n+                        // it might still contribute to a recursive type, e.g.:\n+                        //   struct Foo { x: Option<Option<Foo>> }\n+                        // These cases are handled by passing the full `seen`\n+                        // stack to is_type_structurally_recursive (instead of the\n+                        // empty `nested_seen` above):\n+                        result = Some(\n+                            match is_type_structurally_recursive(\n+                                tcx,\n+                                span,\n+                                seen,\n+                                shadow_seen,\n+                                representable_cache,\n+                                ty,\n+                                f_res,\n+                            ) {\n+                                Representability::SelfRecursive(_) => {\n+                                    Representability::SelfRecursive(vec![span])\n+                                }\n+                                x => x,\n+                            },\n+                        );\n                     }\n-                    x => x,\n                 }\n+\n+                result.unwrap()\n             }))\n         }\n         ty::Closure(..) => {\n@@ -106,8 +263,10 @@ fn is_type_structurally_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<Ty<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    f_res: &mut bool,\n ) -> Representability {\n     debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n     if let Some(representability) = representable_cache.get(ty) {\n@@ -118,8 +277,15 @@ fn is_type_structurally_recursive<'tcx>(\n         return representability.clone();\n     }\n \n-    let representability =\n-        is_type_structurally_recursive_inner(tcx, sp, seen, representable_cache, ty);\n+    let representability = is_type_structurally_recursive_inner(\n+        tcx,\n+        sp,\n+        seen,\n+        shadow_seen,\n+        representable_cache,\n+        ty,\n+        f_res,\n+    );\n \n     representable_cache.insert(ty, representability.clone());\n     representability\n@@ -129,12 +295,16 @@ fn is_type_structurally_recursive_inner<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n+    shadow_seen: &mut Vec<Ty<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    f_res: &mut bool,\n ) -> Representability {\n     match ty.kind() {\n         ty::Adt(def, _) => {\n             {\n+                debug!(\"is_type_structurally_recursive_inner: adt: {:?}, seen: {:?}\", ty, seen);\n+\n                 // Iterate through stack of previously seen types.\n                 let mut iter = seen.iter();\n \n@@ -158,8 +328,10 @@ fn is_type_structurally_recursive_inner<'tcx>(\n                 // will recurse infinitely for some inputs.\n                 //\n                 // It is important that we DO take generic parameters into account\n-                // here, so that code like this is considered SelfRecursive, not\n-                // ContainsRecursive:\n+                // here, because nesting e.g. Options is allowed (as long as the\n+                // definition of Option doesn't itself include an Option field, which\n+                // would be a case of SelfRecursive above). The following, too, counts\n+                // as SelfRecursive:\n                 //\n                 // struct Foo { Option<Option<Foo>> }\n \n@@ -174,13 +346,23 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             // For structs and enums, track all previously seen types by pushing them\n             // onto the 'seen' stack.\n             seen.push(ty);\n-            let out = are_inner_types_recursive(tcx, sp, seen, representable_cache, ty);\n+            shadow_seen.push(ty);\n+            let out = are_inner_types_recursive(\n+                tcx,\n+                sp,\n+                seen,\n+                shadow_seen,\n+                representable_cache,\n+                ty,\n+                f_res,\n+            );\n+            shadow_seen.pop();\n             seen.pop();\n             out\n         }\n         _ => {\n             // No need to push in other cases.\n-            are_inner_types_recursive(tcx, sp, seen, representable_cache, ty)\n+            are_inner_types_recursive(tcx, sp, seen, shadow_seen, representable_cache, ty, f_res)\n         }\n     }\n }"}]}