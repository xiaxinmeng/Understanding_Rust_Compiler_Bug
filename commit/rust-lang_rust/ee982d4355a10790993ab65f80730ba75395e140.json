{"sha": "ee982d4355a10790993ab65f80730ba75395e140", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlOTgyZDQzNTVhMTA3OTA5OTNhYjY1ZjgwNzMwYmE3NTM5NWUxNDA=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-23T20:47:15Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-28T09:00:03Z"}, "message": "fix translation of MSVC funclets that loop to their own start", "tree": {"sha": "408f300eceef34ff73afddb8b46e277ee2a936a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/408f300eceef34ff73afddb8b46e277ee2a936a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee982d4355a10790993ab65f80730ba75395e140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee982d4355a10790993ab65f80730ba75395e140", "html_url": "https://github.com/rust-lang/rust/commit/ee982d4355a10790993ab65f80730ba75395e140", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee982d4355a10790993ab65f80730ba75395e140/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6adfbaf2d38df2e39c94d07dd6563da92b732049", "url": "https://api.github.com/repos/rust-lang/rust/commits/6adfbaf2d38df2e39c94d07dd6563da92b732049", "html_url": "https://github.com/rust-lang/rust/commit/6adfbaf2d38df2e39c94d07dd6563da92b732049"}], "stats": {"total": 173, "additions": 93, "deletions": 80}, "files": [{"sha": "29ac650aa7053110e374dfa6859919913b9cf067", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=ee982d4355a10790993ab65f80730ba75395e140", "patch": "@@ -212,6 +212,13 @@ impl<I: Idx, T> IndexMut<I> for IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T> Default for IndexVec<I, T> {\n+    #[inline]\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     #[inline]\n     fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {"}, {"sha": "903c74edd1c5e10c2b37344bdda37499aa1e9114", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ee982d4355a10790993ab65f80730ba75395e140", "patch": "@@ -191,15 +191,6 @@ impl Funclet {\n     }\n }\n \n-impl Clone for Funclet {\n-    fn clone(&self) -> Funclet {\n-        Funclet {\n-            cleanuppad: self.cleanuppad,\n-            operand: OperandBundleDef::new(\"funclet\", &[self.cleanuppad]),\n-        }\n-    }\n-}\n-\n pub fn val_ty(v: ValueRef) -> Type {\n     unsafe {\n         Type::from_ref(llvm::LLVMTypeOf(v))"}, {"sha": "45afcf51b5203d18ae46287ad6484b2632771ce7", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=ee982d4355a10790993ab65f80730ba75395e140", "patch": "@@ -197,6 +197,16 @@ pub enum CleanupKind {\n     Internal { funclet: mir::BasicBlock }\n }\n \n+impl CleanupKind {\n+    pub fn funclet_bb(self, for_bb: mir::BasicBlock) -> Option<mir::BasicBlock> {\n+        match self {\n+            CleanupKind::NotCleanup => None,\n+            CleanupKind::Funclet => Some(for_bb),\n+            CleanupKind::Internal { funclet } => Some(funclet),\n+        }\n+    }\n+}\n+\n pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n                               mir: &mir::Mir<'tcx>) {"}, {"sha": "4926485a121256e95afca19ce19a057100384434", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ee982d4355a10790993ab65f80730ba75395e140", "patch": "@@ -19,104 +19,96 @@ use adt;\n use base::{self, Lifetime};\n use callee;\n use builder::Builder;\n-use common::{self, Funclet};\n-use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n+use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use machine::llalign_of_min;\n use meth;\n use monomorphize;\n use type_of;\n use type_::Type;\n \n-use rustc_data_structures::indexed_vec::IndexVec;\n use syntax::symbol::Symbol;\n \n use std::cmp;\n \n use super::{MirContext, LocalRef};\n-use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{Alignment, LvalueRef};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n-    pub fn trans_block(&mut self, bb: mir::BasicBlock,\n-        funclets: &IndexVec<mir::BasicBlock, Option<Funclet>>) {\n+    pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         let mut bcx = self.get_builder(bb);\n         let data = &self.mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n \n-        let funclet = match self.cleanup_kinds[bb] {\n-            CleanupKind::Internal { funclet } => funclets[funclet].as_ref(),\n-            _ => funclets[bb].as_ref(),\n-        };\n-\n         for statement in &data.statements {\n             bcx = self.trans_statement(bcx, statement);\n         }\n \n-        self.trans_terminator(bcx, bb, data.terminator(), funclet);\n+        self.trans_terminator(bcx, bb, data.terminator());\n     }\n \n     fn trans_terminator(&mut self,\n                         mut bcx: Builder<'a, 'tcx>,\n                         bb: mir::BasicBlock,\n-                        terminator: &mir::Terminator<'tcx>,\n-                        funclet: Option<&Funclet>)\n+                        terminator: &mir::Terminator<'tcx>)\n     {\n         debug!(\"trans_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n         let tcx = bcx.tcx();\n+        let span = terminator.source_info.span;\n+        let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n+        let funclet = funclet_bb.and_then(|funclet_bb| self.funclets[funclet_bb].as_ref());\n+\n         let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n         let cleanup_bundle = funclet.map(|l| l.bundle());\n \n-        let funclet_br = |this: &Self, bcx: Builder, bb: mir::BasicBlock| {\n-            let lltarget = this.blocks[bb];\n-            if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kinds[bb] {\n-                    CleanupKind::Funclet => {\n-                        // micro-optimization: generate a `ret` rather than a jump\n-                        // to a return block\n-                        bcx.cleanup_ret(cp, Some(lltarget));\n-                    }\n-                    CleanupKind::Internal { .. } => bcx.br(lltarget),\n-                    CleanupKind::NotCleanup => bug!(\"jump from cleanup bb to bb {:?}\", bb)\n+        let lltarget = |this: &mut Self, target: mir::BasicBlock| {\n+            let lltarget = this.blocks[target];\n+            let target_funclet = this.cleanup_kinds[target].funclet_bb(target);\n+            match (funclet_bb, target_funclet) {\n+                (None, None) => (lltarget, false),\n+                (Some(f), Some(t_f))\n+                    if f == t_f || !base::wants_msvc_seh(tcx.sess)\n+                    => (lltarget, false),\n+                (None, Some(_)) => {\n+                    // jump *into* cleanup - need a landing pad if GNU\n+                    (this.landing_pad_to(target), false)\n+                }\n+                (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", terminator),\n+                (Some(_), Some(_)) => {\n+                    (this.landing_pad_to(target), true)\n                 }\n-            } else {\n-                bcx.br(lltarget);\n             }\n         };\n \n         let llblock = |this: &mut Self, target: mir::BasicBlock| {\n-            let lltarget = this.blocks[target];\n-\n-            if let Some(cp) = cleanup_pad {\n-                match this.cleanup_kinds[target] {\n-                    CleanupKind::Funclet => {\n-                        // MSVC cross-funclet jump - need a trampoline\n+            let (lltarget, is_cleanupret) = lltarget(this, target);\n+            if is_cleanupret {\n+                // MSVC cross-funclet jump - need a trampoline\n+\n+                debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+                let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n+                let trampoline = this.new_block(name);\n+                trampoline.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n+                trampoline.llbb()\n+            } else {\n+                lltarget\n+            }\n+        };\n \n-                        debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n-                        let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = this.new_block(name);\n-                        trampoline.cleanup_ret(cp, Some(lltarget));\n-                        trampoline.llbb()\n-                    }\n-                    CleanupKind::Internal { .. } => lltarget,\n-                    CleanupKind::NotCleanup =>\n-                        bug!(\"jump from cleanup bb {:?} to bb {:?}\", bb, target)\n-                }\n+        let funclet_br = |this: &mut Self, bcx: Builder, target: mir::BasicBlock| {\n+            let (lltarget, is_cleanupret) = lltarget(this, target);\n+            if is_cleanupret {\n+                // micro-optimization: generate a `ret` rather than a jump\n+                // to a trampoline.\n+                bcx.cleanup_ret(cleanup_pad.unwrap(), Some(lltarget));\n             } else {\n-                if let (CleanupKind::NotCleanup, CleanupKind::Funclet) =\n-                    (this.cleanup_kinds[bb], this.cleanup_kinds[target])\n-                {\n-                    // jump *into* cleanup - need a landing pad if GNU\n-                    this.landing_pad_to(target)\n-                } else {\n-                    lltarget\n-                }\n+                bcx.br(lltarget);\n             }\n         };\n \n@@ -168,7 +160,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         };\n \n-        let span = terminator.source_info.span;\n         self.set_debug_loc(&bcx, terminator.source_info);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => {\n@@ -752,7 +743,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn landing_pad_uncached(&mut self, target_bb: BasicBlockRef) -> BasicBlockRef {\n         if base::wants_msvc_seh(self.ccx.sess()) {\n-            return target_bb;\n+            span_bug!(self.mir.span, \"landing pad was not inserted?\")\n         }\n \n         let bcx = self.new_block(\"cleanup\");"}, {"sha": "c54dfb375c0b6afba20c31cb8812c919c9ccd5f9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee982d4355a10790993ab65f80730ba75395e140/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ee982d4355a10790993ab65f80730ba75395e140", "patch": "@@ -69,6 +69,10 @@ pub struct MirContext<'a, 'tcx:'a> {\n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n+    /// When targeting MSVC, this stores the cleanup info for each funclet\n+    /// BB. This is initialized as we compute the funclets' head block in RPO.\n+    funclets: &'a IndexVec<mir::BasicBlock, Option<Funclet>>,\n+\n     /// This stores the landing-pad block for a given BB, computed lazily on GNU\n     /// and eagerly on MSVC.\n     landing_pads: IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n@@ -202,8 +206,11 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         debuginfo::create_function_debug_context(ccx, instance, sig, llfn, mir);\n     let bcx = Builder::new_block(ccx, llfn, \"start\");\n \n-    let cleanup_kinds = analyze::cleanup_kinds(&mir);\n+    if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n+        bcx.set_personality_fn(ccx.eh_personality());\n+    }\n \n+    let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n@@ -218,6 +225,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = debuginfo::create_mir_scopes(ccx, mir, &debug_context);\n+    let (landing_pads, funclets) = create_funclets(&bcx, &cleanup_kinds, &block_bcxs);\n \n     let mut mircx = MirContext {\n         mir: mir,\n@@ -228,7 +236,8 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         blocks: block_bcxs,\n         unreachable_block: None,\n         cleanup_kinds: cleanup_kinds,\n-        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n+        landing_pads: landing_pads,\n+        funclets: &funclets,\n         scopes: scopes,\n         locals: IndexVec::new(),\n         debug_context: debug_context,\n@@ -306,28 +315,13 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(&mircx.debug_context);\n \n-    let funclets: IndexVec<mir::BasicBlock, Option<Funclet>> =\n-    mircx.cleanup_kinds.iter_enumerated().map(|(bb, cleanup_kind)| {\n-        if let CleanupKind::Funclet = *cleanup_kind {\n-            let bcx = mircx.get_builder(bb);\n-            unsafe {\n-                llvm::LLVMSetPersonalityFn(mircx.llfn, mircx.ccx.eh_personality());\n-            }\n-            if base::wants_msvc_seh(ccx.sess()) {\n-                return Some(Funclet::new(bcx.cleanup_pad(None, &[])));\n-            }\n-        }\n-\n-        None\n-    }).collect();\n-\n     let rpo = traversal::reverse_postorder(&mir);\n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n-        mircx.trans_block(bb, &funclets);\n+        mircx.trans_block(bb);\n     }\n \n     // Remove blocks that haven't been visited, or have no\n@@ -343,6 +337,26 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     }\n }\n \n+fn create_funclets<'a, 'tcx>(\n+    bcx: &Builder<'a, 'tcx>,\n+    cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n+    block_bcxs: &IndexVec<mir::BasicBlock, BasicBlockRef>)\n+    -> (IndexVec<mir::BasicBlock, Option<BasicBlockRef>>,\n+        IndexVec<mir::BasicBlock, Option<Funclet>>)\n+{\n+    block_bcxs.iter_enumerated().zip(cleanup_kinds).map(|((bb, &llbb), cleanup_kind)| {\n+        match *cleanup_kind {\n+            CleanupKind::Funclet if base::wants_msvc_seh(bcx.sess()) => {\n+                let cleanup_bcx = bcx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n+                let cleanup = cleanup_bcx.cleanup_pad(None, &[]);\n+                cleanup_bcx.br(llbb);\n+                (Some(cleanup_bcx.llbb()), Some(Funclet::new(cleanup)))\n+            }\n+            _ => (None, None)\n+        }\n+    }).unzip()\n+}\n+\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect."}]}