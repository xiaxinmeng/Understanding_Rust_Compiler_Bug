{"sha": "e5a2cd526a6ad92b90dda81104abc7adf4c83495", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YTJjZDUyNmE2YWQ5MmI5MGRkYTgxMTA0YWJjN2FkZjRjODM0OTU=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-09T12:46:05Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T16:38:23Z"}, "message": "We don't use tyerr anymore\n\nThis however unearthed a bug, hence the FIXME and the workaround.", "tree": {"sha": "a2db8e413c45f97ac473d18d3998584274810cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2db8e413c45f97ac473d18d3998584274810cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5a2cd526a6ad92b90dda81104abc7adf4c83495", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a2cd526a6ad92b90dda81104abc7adf4c83495", "html_url": "https://github.com/rust-lang/rust/commit/e5a2cd526a6ad92b90dda81104abc7adf4c83495", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5a2cd526a6ad92b90dda81104abc7adf4c83495/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f08b16c030d89049e0633ced8665c317db83f03", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f08b16c030d89049e0633ced8665c317db83f03", "html_url": "https://github.com/rust-lang/rust/commit/8f08b16c030d89049e0633ced8665c317db83f03"}], "stats": {"total": 81, "additions": 46, "deletions": 35}, "files": [{"sha": "f94da2f3805ab29a774d9a888866baa7ba3b31ac", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e5a2cd526a6ad92b90dda81104abc7adf4c83495/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a2cd526a6ad92b90dda81104abc7adf4c83495/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=e5a2cd526a6ad92b90dda81104abc7adf4c83495", "patch": "@@ -242,7 +242,7 @@ use rustc_hir::{HirId, RangeEnd};\n use rustc_middle::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n@@ -1739,11 +1739,7 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// to a set of such vectors `m` - this is defined as there being a set of\n /// inputs that will match `v` but not any of the sets in `m`.\n ///\n-/// All the patterns at each column of the `matrix ++ v` matrix must\n-/// have the same type, except that wildcard (PatKind::Wild) patterns\n-/// with type `TyErr` are also allowed, even if the \"type of the column\"\n-/// is not `TyErr`. That is used to represent private fields, as using their\n-/// real type would assert that they are inhabited.\n+/// All the patterns at each column of the `matrix ++ v` matrix must have the same type.\n ///\n /// This is used both for reachability checking (if a pattern isn't useful in\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n@@ -1807,34 +1803,7 @@ crate fn is_useful<'p, 'tcx>(\n         return if any_is_useful { Useful(unreachable_pats) } else { NotUseful };\n     }\n \n-    let (ty, span) = matrix\n-        .heads()\n-        .map(|r| (r.ty, r.span))\n-        .find(|(ty, _)| !ty.references_error())\n-        .unwrap_or((v.head().ty, v.head().span));\n-    let pcx = PatCtxt {\n-        // TyErr is used to represent the type of wildcard patterns matching\n-        // against inaccessible (private) fields of structs, so that we won't\n-        // be able to observe whether the types of the struct's fields are\n-        // inhabited.\n-        //\n-        // If the field is truly inaccessible, then all the patterns\n-        // matching against it must be wildcard patterns, so its type\n-        // does not matter.\n-        //\n-        // However, if we are matching against non-wildcard patterns, we\n-        // need to know the real type of the field so we can specialize\n-        // against it. This primarily occurs through constants - they\n-        // can include contents for fields that are inaccessible at the\n-        // location of the match. In that case, the field's type is\n-        // inhabited - by the constant - so we can just use it.\n-        //\n-        // FIXME: this might lead to \"unstable\" behavior with macro hygiene\n-        // introducing uninhabited patterns for inaccessible fields. We\n-        // need to figure out how to model that.\n-        ty,\n-        span,\n-    };\n+    let pcx = PatCtxt { ty: v.head().ty, span: v.head().span };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n "}, {"sha": "b805e858aacd9b1eaf068e88f8c7e5fbc3ea204b", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e5a2cd526a6ad92b90dda81104abc7adf4c83495/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a2cd526a6ad92b90dda81104abc7adf4c83495/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=e5a2cd526a6ad92b90dda81104abc7adf4c83495", "patch": "@@ -186,8 +186,28 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         // Fourth, check for unreachable arms.\n         let matrix = check_arms(&mut cx, &inlined_arms, source);\n \n-        // Fifth, check if the match is exhaustive.\n+        // FIXME: getting the type using `node_type` means that if `f` has output type `!`, we\n+        // get `scrut_ty = !` instead of `bool` in the following:\n+        // ```\n+        // fn from(never: !) -> usize {\n+        //     match never {\n+        //         true => 1,\n+        //         false => 0,\n+        //     }\n+        // }\n+        // ```\n+        // If we use `expr_ty_adjusted` instead, then the following breaks, because we get\n+        // `scrut_ty = ()` instead of `!`.\n+        // ```\n+        // fn from(never: !) -> usize {\n+        //     match never {}\n+        // }\n+        // ```\n+        // As a workaround, we retrieve the type from the match arms when possible.\n         let scrut_ty = self.tables.node_type(scrut.hir_id);\n+        let scrut_ty = inlined_arms.iter().map(|(p, _, _)| p.ty).next().unwrap_or(scrut_ty);\n+\n+        // Fifth, check if the match is exhaustive.\n         // Note: An empty match isn't the same as an empty matrix for diagnostics purposes,\n         // since an empty matrix can occur when there are arms, if those arms all have guards.\n         let is_empty_match = inlined_arms.is_empty();"}, {"sha": "e2ff9ac87ef51efd5aacaab3a72df0bdf2fae787", "filename": "src/test/ui/pattern/usefulness/issue-71930-type-of-match-scrutinee.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e5a2cd526a6ad92b90dda81104abc7adf4c83495/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-71930-type-of-match-scrutinee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a2cd526a6ad92b90dda81104abc7adf4c83495/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-71930-type-of-match-scrutinee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-71930-type-of-match-scrutinee.rs?ref=e5a2cd526a6ad92b90dda81104abc7adf4c83495", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+// In PR 71930, it was discovered that the code to retrieve the inferred type of a match scrutinee\n+// was incorrect.\n+\n+fn f() -> ! {\n+    panic!()\n+}\n+\n+fn g() -> usize {\n+    match f() { // Should infer type `bool`\n+        false => 0,\n+        true => 1,\n+    }\n+}\n+\n+fn h() -> usize {\n+    match f() { // Should infer type `!`\n+    }\n+}\n+\n+fn main() {}"}]}