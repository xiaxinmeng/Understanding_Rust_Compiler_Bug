{"sha": "d4675aad5c5ff63b43e59618f8ab01236ae4f98a", "node_id": "C_kwDOAAsO6NoAKGQ0Njc1YWFkNWM1ZmY2M2I0M2U1OTYxOGY4YWIwMTIzNmFlNGY5OGE", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-08-28T02:05:22Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-10-02T22:57:56Z"}, "message": "Turn some comments into docs", "tree": {"sha": "27059f184098c55abbc95679bce84296934fe0a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27059f184098c55abbc95679bce84296934fe0a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4675aad5c5ff63b43e59618f8ab01236ae4f98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4675aad5c5ff63b43e59618f8ab01236ae4f98a", "html_url": "https://github.com/rust-lang/rust/commit/d4675aad5c5ff63b43e59618f8ab01236ae4f98a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4675aad5c5ff63b43e59618f8ab01236ae4f98a/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eec21d21763abbb76b8feac31265128a8e2691b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eec21d21763abbb76b8feac31265128a8e2691b0", "html_url": "https://github.com/rust-lang/rust/commit/eec21d21763abbb76b8feac31265128a8e2691b0"}], "stats": {"total": 114, "additions": 57, "deletions": 57}, "files": [{"sha": "f375af4837f75910ad3d12a0d33b24aa9b2f4ff6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/d4675aad5c5ff63b43e59618f8ab01236ae4f98a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4675aad5c5ff63b43e59618f8ab01236ae4f98a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=d4675aad5c5ff63b43e59618f8ab01236ae4f98a", "patch": "@@ -166,16 +166,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .clone()\n     }\n \n-    // This method calculates two things: Lifetime constraints of the form 'a: 'b,\n-    // and region constraints of the form ReVar: 'a\n-    //\n-    // This is essentially a simplified version of lexical_region_resolve. However,\n-    // handle_lifetimes determines what *needs be* true in order for an impl to hold.\n-    // lexical_region_resolve, along with much of the rest of the compiler, is concerned\n-    // with determining if a given set up constraints/predicates *are* met, given some\n-    // starting conditions (e.g., user-provided code). For this reason, it's easier\n-    // to perform the calculations we need on our own, rather than trying to make\n-    // existing inference/solver code do what we want.\n+    /// This method calculates two things: Lifetime constraints of the form `'a: 'b`,\n+    /// and region constraints of the form `RegionVid: 'a`\n+    ///\n+    /// This is essentially a simplified version of lexical_region_resolve. However,\n+    /// handle_lifetimes determines what *needs be* true in order for an impl to hold.\n+    /// lexical_region_resolve, along with much of the rest of the compiler, is concerned\n+    /// with determining if a given set up constraints/predicates *are* met, given some\n+    /// starting conditions (e.g., user-provided code). For this reason, it's easier\n+    /// to perform the calculations we need on our own, rather than trying to make\n+    /// existing inference/solver code do what we want.\n     fn handle_lifetimes<'cx>(\n         regions: &RegionConstraintData<'cx>,\n         names_map: &FxHashMap<Symbol, Lifetime>,\n@@ -410,15 +410,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .collect()\n     }\n \n-    // Converts the calculated ParamEnv and lifetime information to a clean::Generics, suitable for\n-    // display on the docs page. Cleaning the Predicates produces sub-optimal `WherePredicate`s,\n-    // so we fix them up:\n-    //\n-    // * Multiple bounds for the same type are coalesced into one: e.g., 'T: Copy', 'T: Debug'\n-    // becomes 'T: Copy + Debug'\n-    // * Fn bounds are handled specially - instead of leaving it as 'T: Fn(), <T as Fn::Output> =\n-    // K', we use the dedicated syntax 'T: Fn() -> K'\n-    // * We explicitly add a '?Sized' bound if we didn't find any 'Sized' predicates for a type\n+    /// Converts the calculated `ParamEnv` and lifetime information to a [`clean::Generics`](Generics), suitable for\n+    /// display on the docs page. Cleaning the `Predicates` produces sub-optimal [`WherePredicate`]s,\n+    /// so we fix them up:\n+    ///\n+    /// * Multiple bounds for the same type are coalesced into one: e.g., `T: Copy`, `T: Debug`\n+    /// becomes `T: Copy + Debug`\n+    /// * `Fn` bounds are handled specially - instead of leaving it as `T: Fn(), <T as Fn::Output> =\n+    /// K`, we use the dedicated syntax `T: Fn() -> K`\n+    /// * We explicitly add a `?Sized` bound if we didn't find any `Sized` predicates for a type\n     fn param_env_to_generics(\n         &mut self,\n         item_def_id: DefId,\n@@ -632,11 +632,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         Generics { params: generic_params, where_predicates: existing_predicates }\n     }\n \n-    // Ensure that the predicates are in a consistent order. The precise\n-    // ordering doesn't actually matter, but it's important that\n-    // a given set of predicates always appears in the same order -\n-    // both for visual consistency between 'rustdoc' runs, and to\n-    // make writing tests much easier\n+    /// Ensure that the predicates are in a consistent order. The precise\n+    /// ordering doesn't actually matter, but it's important that\n+    /// a given set of predicates always appears in the same order -\n+    /// both for visual consistency between 'rustdoc' runs, and to\n+    /// make writing tests much easier\n     #[inline]\n     fn sort_where_predicates(&self, mut predicates: &mut Vec<WherePredicate>) {\n         // We should never have identical bounds - and if we do,\n@@ -645,11 +645,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         self.unstable_debug_sort(&mut predicates);\n     }\n \n-    // Ensure that the bounds are in a consistent order. The precise\n-    // ordering doesn't actually matter, but it's important that\n-    // a given set of bounds always appears in the same order -\n-    // both for visual consistency between 'rustdoc' runs, and to\n-    // make writing tests much easier\n+    /// Ensure that the bounds are in a consistent order. The precise\n+    /// ordering doesn't actually matter, but it's important that\n+    /// a given set of bounds always appears in the same order -\n+    /// both for visual consistency between 'rustdoc' runs, and to\n+    /// make writing tests much easier\n     #[inline]\n     fn sort_where_bounds(&self, mut bounds: &mut Vec<GenericBound>) {\n         // We should never have identical bounds - and if we do,\n@@ -658,33 +658,33 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         self.unstable_debug_sort(&mut bounds);\n     }\n \n-    // This might look horrendously hacky, but it's actually not that bad.\n-    //\n-    // For performance reasons, we use several different FxHashMaps\n-    // in the process of computing the final set of where predicates.\n-    // However, the iteration order of a HashMap is completely unspecified.\n-    // In fact, the iteration of an FxHashMap can even vary between platforms,\n-    // since FxHasher has different behavior for 32-bit and 64-bit platforms.\n-    //\n-    // Obviously, it's extremely undesirable for documentation rendering\n-    // to be dependent on the platform it's run on. Apart from being confusing\n-    // to end users, it makes writing tests much more difficult, as predicates\n-    // can appear in any order in the final result.\n-    //\n-    // To solve this problem, we sort WherePredicates and GenericBounds\n-    // by their Debug string. The thing to keep in mind is that we don't really\n-    // care what the final order is - we're synthesizing an impl or bound\n-    // ourselves, so any order can be considered equally valid. By sorting the\n-    // predicates and bounds, however, we ensure that for a given codebase, all\n-    // auto-trait impls always render in exactly the same way.\n-    //\n-    // Using the Debug implementation for sorting prevents us from needing to\n-    // write quite a bit of almost entirely useless code (e.g., how should two\n-    // Types be sorted relative to each other). It also allows us to solve the\n-    // problem for both WherePredicates and GenericBounds at the same time. This\n-    // approach is probably somewhat slower, but the small number of items\n-    // involved (impls rarely have more than a few bounds) means that it\n-    // shouldn't matter in practice.\n+    /// This might look horrendously hacky, but it's actually not that bad.\n+    ///\n+    /// For performance reasons, we use several different FxHashMaps\n+    /// in the process of computing the final set of where predicates.\n+    /// However, the iteration order of a HashMap is completely unspecified.\n+    /// In fact, the iteration of an FxHashMap can even vary between platforms,\n+    /// since FxHasher has different behavior for 32-bit and 64-bit platforms.\n+    ///\n+    /// Obviously, it's extremely undesirable for documentation rendering\n+    /// to be dependent on the platform it's run on. Apart from being confusing\n+    /// to end users, it makes writing tests much more difficult, as predicates\n+    /// can appear in any order in the final result.\n+    ///\n+    /// To solve this problem, we sort WherePredicates and GenericBounds\n+    /// by their Debug string. The thing to keep in mind is that we don't really\n+    /// care what the final order is - we're synthesizing an impl or bound\n+    /// ourselves, so any order can be considered equally valid. By sorting the\n+    /// predicates and bounds, however, we ensure that for a given codebase, all\n+    /// auto-trait impls always render in exactly the same way.\n+    ///\n+    /// Using the Debug implementation for sorting prevents us from needing to\n+    /// write quite a bit of almost entirely useless code (e.g., how should two\n+    /// Types be sorted relative to each other). It also allows us to solve the\n+    /// problem for both WherePredicates and GenericBounds at the same time. This\n+    /// approach is probably somewhat slower, but the small number of items\n+    /// involved (impls rarely have more than a few bounds) means that it\n+    /// shouldn't matter in practice.\n     fn unstable_debug_sort<T: Debug>(&self, vec: &mut Vec<T>) {\n         vec.sort_by_cached_key(|x| format!(\"{:?}\", x))\n     }\n@@ -705,7 +705,7 @@ fn region_name(region: Region<'_>) -> Option<Symbol> {\n     }\n }\n \n-// Replaces all ReVars in a type with ty::Region's, using the provided map\n+/// Replaces all [`ty::RegionVid`]s in a type with [`ty::Region`]s, using the provided map.\n struct RegionReplacer<'a, 'tcx> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,\n     tcx: TyCtxt<'tcx>,"}]}