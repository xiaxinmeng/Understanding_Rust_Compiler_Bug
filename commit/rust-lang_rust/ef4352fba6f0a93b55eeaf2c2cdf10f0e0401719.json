{"sha": "ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNDM1MmZiYTZmMGE5M2I1NWVlYWYyYzJjZGYxMGYwZTA0MDE3MTk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-08T16:05:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:04Z"}, "message": "rustc_metadata: group information into less tags.", "tree": {"sha": "4eaf06ddbc5f68e0a0e3fe2e202e212ffe3fee72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eaf06ddbc5f68e0a0e3fe2e202e212ffe3fee72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "html_url": "https://github.com/rust-lang/rust/commit/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6742b239ac0e1fad2e3981b6201d5789b7298554", "url": "https://api.github.com/repos/rust-lang/rust/commits/6742b239ac0e1fad2e3981b6201d5789b7298554", "html_url": "https://github.com/rust-lang/rust/commit/6742b239ac0e1fad2e3981b6201d5789b7298554"}], "stats": {"total": 2505, "additions": 972, "deletions": 1533}, "files": [{"sha": "dec8ea8a29c3918afc091d940d70a57b8106a88e", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -18,15 +18,14 @@ pub enum Def {\n     Fn(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     Mod(DefId),\n-    ForeignMod(DefId),\n     Static(DefId, bool /* is_mutbl */),\n     Const(DefId),\n     AssociatedConst(DefId),\n     Local(DefId),\n-    Variant(DefId /* enum */, DefId /* variant */),\n+    Variant(DefId),\n     Enum(DefId),\n     TyAlias(DefId),\n-    AssociatedTy(DefId /* trait */, DefId),\n+    AssociatedTy(DefId),\n     Trait(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n@@ -101,8 +100,8 @@ pub struct Export {\n impl Def {\n     pub fn def_id(&self) -> DefId {\n         match *self {\n-            Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n-            Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n+            Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n+            Def::Variant(id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(id) |\n             Def::TyParam(id) | Def::Struct(id) | Def::Union(id) | Def::Trait(id) |\n             Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n             Def::Local(id) | Def::Upvar(id, ..) => {\n@@ -122,7 +121,6 @@ impl Def {\n         match *self {\n             Def::Fn(..) => \"function\",\n             Def::Mod(..) => \"module\",\n-            Def::ForeignMod(..) => \"foreign module\",\n             Def::Static(..) => \"static\",\n             Def::Variant(..) => \"variant\",\n             Def::Enum(..) => \"enum\","}, {"sha": "dec41fdfc3b50c35a4693339c61948d6488a3407", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -174,7 +174,7 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n             PatKind::Path(..) |\n             PatKind::Struct(..) => {\n                 match dm.get(&p.id) {\n-                    Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {\n+                    Some(&PathResolution { base_def: Def::Variant(id), .. }) => {\n                         variants.push(id);\n                     }\n                     _ => ()"}, {"sha": "87fdc858cf0f5e90b6724a132a3692cc10ccb8ff", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -135,11 +135,9 @@ pub trait CrateStore<'tcx> {\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>;\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n-    fn item_name(&self, def: DefId) -> ast::Name;\n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name>;\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n@@ -150,7 +148,7 @@ pub trait CrateStore<'tcx> {\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n-    fn method_arg_names(&self, did: DefId) -> Vec<String>;\n+    fn fn_arg_names(&self, did: DefId) -> Vec<String>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n@@ -211,7 +209,6 @@ pub trait CrateStore<'tcx> {\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n \n@@ -297,13 +294,11 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n-    fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name> { bug!(\"opt_item_name\") }\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n@@ -316,7 +311,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { bug!(\"trait_def\") }\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n-    fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n+    fn fn_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n@@ -393,8 +388,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     }\n     fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n         { bug!(\"struct_ctor_def_id\") }\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n-        { bug!(\"tuple_struct_definition_if_ctor\") }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n     fn item_children(&self, did: DefId) -> Vec<ChildItem> { bug!(\"item_children\") }\n "}, {"sha": "30a0c6a9dc93963fd4e2f0473f73038791fb6892", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -108,8 +108,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             _ if self.ignore_non_const_paths => (),\n             Def::PrimTy(_) => (),\n             Def::SelfTy(..) => (),\n-            Def::Variant(enum_id, variant_id) => {\n-                self.check_def_id(enum_id);\n+            Def::Variant(variant_id) => {\n+                if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n+                    self.check_def_id(enum_id);\n+                }\n                 if !self.ignore_variant_stack.contains(&variant_id) {\n                     self.check_def_id(variant_id);\n                 }"}, {"sha": "5b5c3da8f05b2eae0334c60879f5a8d7e0f2933d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -1003,7 +1003,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(enum_did, variant_did)) => {\n+                Some(Def::Variant(variant_did)) => {\n+                    let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n                     } else {"}, {"sha": "340a5ac8f87b73a03f6a06adb8360006ece44cfd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -529,7 +529,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n \n-          Def::Mod(_) | Def::ForeignMod(_) |\n+          Def::Mod(_) |\n           Def::Trait(_) | Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(_) |\n           Def::TyParam(..) |\n           Def::Label(_) | Def::SelfTy(..) |\n@@ -1077,18 +1077,23 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // alone) because PatKind::Struct can also refer to variants.\n         let cmt = match self.tcx().expect_def_or_none(pat.id) {\n             Some(Def::Err) => return Err(()),\n-            Some(Def::Variant(enum_did, variant_did))\n+            Some(Def::Variant(variant_did)) => {\n                 // univariant enums do not need downcasts\n-                if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n+                let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n+                if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n+                } else {\n+                    cmt\n                 }\n+            }\n             _ => cmt\n         };\n \n         match pat.node {\n           PatKind::TupleStruct(_, ref subpats, ddpos) => {\n             let expected_len = match self.tcx().expect_def(pat.id) {\n-                Def::Variant(enum_def, def_id) => {\n+                Def::Variant(def_id) => {\n+                    let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n                 Def::Struct(..) => {"}, {"sha": "0faf6750abd978fe86397b4ce84da78d34226596", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -1404,13 +1404,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Obtain the representation annotation for a struct definition.\n     pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {\n-            Rc::new(if did.is_local() {\n-                self.get_attrs(did).iter().flat_map(|meta| {\n-                    attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n-                }).collect()\n-            } else {\n-                self.sess.cstore.repr_attrs(did)\n-            })\n+            Rc::new(self.get_attrs(did).iter().flat_map(|meta| {\n+                attr::find_repr_attrs(self.sess.diagnostic(), meta).into_iter()\n+            }).collect())\n         })\n     }\n }"}, {"sha": "5f121b568c3af7ccd56037a02fe3ff260db3d86c", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns the def-id of `def_id`'s parent in the def tree. If\n     /// this returns `None`, then `def_id` represents a crate root or\n     /// inlined root.\n-    fn parent_def_id(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn parent_def_id(self, def_id: DefId) -> Option<DefId> {\n         let key = self.def_key(def_id);\n         key.parent.map(|index| DefId { krate: def_id.krate, index: index })\n     }"}, {"sha": "8171a99beb90fba3c3da0c43908182354c38726e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -193,7 +193,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         match *self {\n             ConstTraitItem(ref associated_const) => Def::AssociatedConst(associated_const.def_id),\n             MethodTraitItem(ref method) => Def::Method(method.def_id),\n-            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.container.id(), ty.def_id),\n+            TypeTraitItem(ref ty) => Def::AssociatedTy(ty.def_id),\n         }\n     }\n \n@@ -1666,7 +1666,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n-            Def::Variant(_, vid) => self.variant_with_id(vid),\n+            Def::Variant(vid) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n@@ -2325,7 +2325,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n         match def {\n-            Def::Variant(enum_did, did) => {\n+            Def::Variant(did) => {\n+                let enum_did = self.parent_def_id(did).unwrap();\n                 self.lookup_adt_def(enum_did).variant_with_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n@@ -2387,7 +2388,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n         } else {\n-            self.sess.cstore.item_name(id)\n+            self.sess.cstore.opt_item_name(id).unwrap_or_else(|| {\n+                bug!(\"item_name: no name for {:?}\", self.def_path(id));\n+            })\n         }\n     }\n \n@@ -2631,11 +2634,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n \n             // Record the trait->implementation mapping.\n-            if let Some(parent) = self.sess.cstore.impl_parent(impl_def_id) {\n-                def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-            } else {\n-                def.record_remote_impl(self, impl_def_id, trait_ref, trait_id);\n-            }\n+            let parent = self.sess.cstore.impl_parent(impl_def_id).unwrap_or(trait_id);\n+            def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n \n             // For any methods that use a default implementation, add them to\n             // the map. This is a bit unfortunate."}, {"sha": "eb74936d8c905380625a63e630a06f6a24934631", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -801,7 +801,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(_, id) => vec![Variant(id)],\n+                Def::Variant(id) => vec![Variant(id)],\n                 Def::Struct(..) | Def::Union(..) |\n                 Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n@@ -913,7 +913,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n                 def => span_bug!(pat_span, \"specialize: unexpected \\\n                                           definition {:?}\", def),\n@@ -925,7 +925,7 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n-                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => {\n                     match ddpos {\n                         Some(ddpos) => {"}, {"sha": "dce3882004c6740ebbbe5d9ee0f9967f4c5a4439", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -57,7 +57,6 @@ macro_rules! math {\n }\n \n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  enum_def: DefId,\n                                   variant_def: DefId)\n                                   -> Option<&'tcx Expr> {\n     fn variant_expr<'a>(variants: &'a [hir::Variant], id: ast::NodeId)\n@@ -70,8 +69,8 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         None\n     }\n \n-    if let Some(enum_node_id) = tcx.map.as_local_node_id(enum_def) {\n-        let variant_node_id = tcx.map.as_local_node_id(variant_def).unwrap();\n+    if let Some(variant_node_id) = tcx.map.as_local_node_id(variant_def) {\n+        let enum_node_id = tcx.map.get_parent(variant_node_id);\n         match tcx.map.find(enum_node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n@@ -289,7 +288,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             let path = match def {\n                 Def::Struct(def_id) => def_to_path(tcx, def_id),\n-                Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n+                Def::Variant(variant_did) => def_to_path(tcx, variant_did),\n                 Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n                     id: expr.id,\n                     node: PatKind::Lit(P(expr.clone())),\n@@ -808,8 +807,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Variant(enum_def, variant_def) => {\n-                  if let Some(const_expr) = lookup_variant_by_id(tcx, enum_def, variant_def) {\n+              Def::Variant(variant_def) => {\n+                  if let Some(const_expr) = lookup_variant_by_id(tcx, variant_def) {\n                       match eval_const_expr_partial(tcx, const_expr, ty_hint, None) {\n                           Ok(val) => val,\n                           Err(err) => {"}, {"sha": "9950f470a82c486fe78cf642af52d74db257509d", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -602,7 +602,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             // def-id is the same, so it suffices to hash the def-id\n             Def::Fn(..) |\n             Def::Mod(..) |\n-            Def::ForeignMod(..) |\n             Def::Static(..) |\n             Def::Variant(..) |\n             Def::Enum(..) |"}, {"sha": "518e6624412189ef200c2e2e03c8a0cfb452413e", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -18,7 +18,7 @@ use cstore::CrateMetadata;\n use decoder::DecodeContext;\n use encoder::EncodeContext;\n \n-use middle::cstore::{InlinedItem, InlinedItemRef};\n+use rustc::middle::cstore::{InlinedItem, InlinedItemRef};\n use rustc::hir::def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::TyCtxt;"}, {"sha": "e068395f729a46e1203abec1afe005c86f5dcaca", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 133, "deletions": 43, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -10,29 +10,36 @@\n \n #![allow(non_camel_case_types, non_upper_case_globals)]\n \n+use rustc::hir;\n+use rustc::hir::def;\n+use rustc::hir::def_id::{DefIndex, DefId};\n use rustc::ty;\n+use rustc::session::config::PanicStrategy;\n \n #[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Family {\n     ImmStatic,\n     MutStatic,\n+    ForeignImmStatic,\n+    ForeignMutStatic,\n     Fn,\n+    ForeignFn,\n     Method,\n     AssociatedType,\n     Type,\n     Mod,\n     ForeignMod,\n     Enum,\n-    Variant(ty::VariantKind),\n+    Variant,\n     Impl,\n     DefaultImpl,\n     Trait,\n-    Struct(ty::VariantKind),\n+    Struct,\n     Union,\n-    PublicField,\n-    InheritedField,\n+    Field,\n     Const,\n     AssociatedConst,\n+    Closure\n }\n \n // NB: increment this if you change the format of metadata such that\n@@ -48,68 +55,151 @@ pub fn rustc_version() -> String {\n     )\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct CrateInfo {\n+    pub name: String,\n+    pub triple: String,\n+    pub hash: hir::svh::Svh,\n+    pub disambiguator: String,\n+    pub panic_strategy: PanicStrategy,\n+    pub plugin_registrar_fn: Option<DefIndex>,\n+    pub macro_derive_registrar: Option<DefIndex>\n+}\n+\n pub mod root_tag {\n     pub const rustc_version: usize = 0x10f;\n-    pub const crate_deps: usize = 0x102;\n-    pub const crate_hash: usize = 0x103;\n-    pub const crate_crate_name: usize = 0x104;\n-    pub const crate_disambiguator: usize = 0x113;\n-    pub const items: usize = 0x100;\n+\n+    pub const crate_info: usize = 0x104;\n+\n     pub const index: usize = 0x110;\n     pub const xref_index: usize = 0x111;\n     pub const xref_data: usize = 0x112;\n-    pub const crate_triple: usize = 0x105;\n+    pub const crate_deps: usize = 0x102;\n     pub const dylib_dependency_formats: usize = 0x106;\n+    pub const native_libraries: usize = 0x10a;\n     pub const lang_items: usize = 0x107;\n     pub const lang_items_missing: usize = 0x76;\n     pub const impls: usize = 0x109;\n-    pub const native_libraries: usize = 0x10a;\n-    pub const plugin_registrar_fn: usize = 0x10b;\n-    pub const panic_strategy: usize = 0x114;\n-    pub const macro_derive_registrar: usize = 0x115;\n     pub const reachable_ids: usize = 0x10c;\n     pub const macro_defs: usize = 0x10e;\n     pub const codemap: usize = 0xa1;\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ModData {\n+    pub reexports: Vec<def::Export>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct VariantData {\n+    pub kind: ty::VariantKind,\n+    pub disr: u64,\n+\n+    /// If this is a struct's only variant, this\n+    /// is the index of the \"struct ctor\" item.\n+    pub struct_ctor: Option<DefIndex>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitData {\n+    pub unsafety: hir::Unsafety,\n+    pub paren_sugar: bool,\n+    pub has_default_impl: bool\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ImplData {\n+    pub polarity: hir::ImplPolarity,\n+    pub parent_impl: Option<DefId>,\n+    pub coerce_unsized_kind: Option<ty::adjustment::CustomCoerceUnsized>,\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitAssociatedData {\n+    pub has_default: bool\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ImplAssociatedData {\n+    pub defaultness: hir::Defaultness,\n+    pub constness: hir::Constness\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct FnData {\n+    pub constness: hir::Constness\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ClosureData {\n+    pub kind: ty::ClosureKind\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub enum EntryData {\n+    Other,\n+    Mod(ModData),\n+    Variant(VariantData),\n+    Trait(TraitData),\n+    Impl(ImplData),\n+    TraitAssociated(TraitAssociatedData),\n+    ImplAssociated(ImplAssociatedData),\n+    Fn(FnData),\n+    Closure(ClosureData)\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct TraitTypedData<'tcx> {\n+    pub trait_ref: ty::TraitRef<'tcx>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ImplTypedData<'tcx> {\n+    pub trait_ref: Option<ty::TraitRef<'tcx>>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct MethodTypedData<'tcx> {\n+    pub explicit_self: ty::ExplicitSelfCategory<'tcx>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct ClosureTypedData<'tcx> {\n+    pub ty: ty::ClosureTy<'tcx>\n+}\n+\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub enum EntryTypedData<'tcx> {\n+    Other,\n+    Trait(TraitTypedData<'tcx>),\n+    Impl(ImplTypedData<'tcx>),\n+    Method(MethodTypedData<'tcx>),\n+    Closure(ClosureTypedData<'tcx>)\n+}\n+\n pub mod item_tag {\n-    pub const name: usize = 0x20;\n-    pub const def_index: usize = 0x21;\n-    pub const family: usize = 0x24;\n-    pub const ty: usize = 0x25;\n-    pub const parent_item: usize = 0x28;\n-    pub const is_tuple_struct_ctor: usize = 0x29;\n-    pub const closure_kind: usize = 0x2a;\n-    pub const closure_ty: usize = 0x2b;\n     pub const def_key: usize = 0x2c;\n+    pub const family: usize = 0x24;\n     pub const attributes: usize = 0x101;\n-    pub const trait_ref: usize = 0x3b;\n-    pub const disr_val: usize = 0x3c;\n-    pub const fields: usize = 0x41;\n-    pub const variances: usize = 0x43;\n-    pub const trait_method_explicit_self: usize = 0x45;\n-    pub const ast: usize = 0x50;\n-    pub const mir: usize = 0x52;\n-    pub const trait_item_has_body: usize = 0x70;\n     pub const visibility: usize = 0x78;\n-    pub const inherent_impls: usize = 0x79;\n     pub const children: usize = 0x7b;\n-    pub const method_argument_names: usize = 0x85;\n     pub const stability: usize = 0x88;\n-    pub const repr: usize = 0x89;\n-    pub const struct_ctor: usize = 0x8b;\n+    pub const deprecation: usize = 0xa7;\n+\n+    pub const ty: usize = 0x25;\n+    pub const inherent_impls: usize = 0x79;\n+    pub const variances: usize = 0x43;\n     pub const generics: usize = 0x8f;\n     pub const predicates: usize = 0x95;\n-    pub const unsafety: usize = 0x9a;\n-    pub const polarity: usize = 0x9d;\n-    pub const paren_sugar: usize = 0xa0;\n     pub const super_predicates: usize = 0xa3;\n-    pub const defaulted_trait: usize = 0xa4;\n-    pub const impl_coerce_unsized_kind: usize = 0xa5;\n-    pub const constness: usize = 0xa6;\n-    pub const deprecation: usize = 0xa7;\n-    pub const defaultness: usize = 0xa8;\n-    pub const parent_impl: usize = 0xa9;\n+\n+    pub const ast: usize = 0x50;\n+    pub const mir: usize = 0x52;\n+\n+    pub const data: usize = 0x3c;\n+    pub const typed_data: usize = 0x3d;\n+\n+    pub const fn_arg_names: usize = 0x85;\n }\n \n /// The shorthand encoding of `Ty` uses `TypeVariants`' variant `usize`"}, {"sha": "dd6ef73ccdbd7e0f2f230f01d28506735ede1c30", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -12,6 +12,7 @@\n \n //! Validates all used crates and extern libraries and loads their metadata\n \n+use common::CrateInfo;\n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use decoder;\n use loader::{self, CratePaths};\n@@ -85,7 +86,7 @@ fn should_link(i: &ast::Item) -> bool {\n }\n \n #[derive(Debug)]\n-struct CrateInfo {\n+struct ExternCrateInfo {\n     ident: String,\n     name: String,\n     id: ast::NodeId,\n@@ -183,7 +184,7 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n+    fn extract_crate_info(&self, i: &ast::Item) -> Option<ExternCrateInfo> {\n         match i.node {\n             ast::ItemKind::ExternCrate(ref path_opt) => {\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n@@ -196,7 +197,7 @@ impl<'a> CrateReader<'a> {\n                     }\n                     None => i.ident.to_string(),\n                 };\n-                Some(CrateInfo {\n+                Some(ExternCrateInfo {\n                     ident: i.ident.to_string(),\n                     name: name,\n                     id: i.id,\n@@ -258,32 +259,28 @@ impl<'a> CrateReader<'a> {\n \n     fn verify_no_symbol_conflicts(&self,\n                                   span: Span,\n-                                  metadata: &MetadataBlob) {\n-        let disambiguator = decoder::get_crate_disambiguator(metadata.as_slice());\n-        let crate_name = decoder::get_crate_name(metadata.as_slice());\n-\n+                                  info: &CrateInfo) {\n         // Check for (potential) conflicts with the local crate\n-        if self.local_crate_name == crate_name &&\n-           self.sess.local_crate_disambiguator() == &disambiguator[..] {\n+        if self.local_crate_name == info.name &&\n+           self.sess.local_crate_disambiguator() == &info.disambiguator[..] {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n                          compiled with the same `-C metadata` arguments. This \\\n                          will result in symbol conflicts between the two.\",\n-                        crate_name)\n+                        info.name)\n         }\n \n-        let svh = decoder::get_crate_hash(metadata.as_slice());\n         // Check for conflicts with any crate loaded so far\n         self.cstore.iter_crate_data(|_, other| {\n-            if other.name() == crate_name && // same crate-name\n-               other.disambiguator() == disambiguator &&  // same crate-disambiguator\n-               other.hash() != svh { // but different SVH\n+            if other.name() == info.name && // same crate-name\n+               other.disambiguator() == info.disambiguator &&  // same crate-disambiguator\n+               other.hash() != info.hash { // but different SVH\n                 span_fatal!(self.sess, span, E0523,\n                         \"found two different crates with name `{}` that are \\\n                          not distinguished by differing `-C metadata`. This \\\n                          will result in symbol conflicts between the two.\",\n-                        crate_name)\n+                        info.name)\n             }\n         });\n     }\n@@ -298,7 +295,8 @@ impl<'a> CrateReader<'a> {\n                       -> (CrateNum, Rc<cstore::CrateMetadata>,\n                           cstore::CrateSource) {\n         info!(\"register crate `extern crate {} as {}`\", name, ident);\n-        self.verify_no_symbol_conflicts(span, &lib.metadata);\n+        let crate_info = decoder::get_crate_info(lib.metadata.as_slice());\n+        self.verify_no_symbol_conflicts(span, &crate_info);\n \n         // Claim this crate number and cache it\n         let cnum = self.next_crate_num;\n@@ -321,9 +319,15 @@ impl<'a> CrateReader<'a> {\n \n         let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), cnum, span);\n \n+        if crate_info.macro_derive_registrar.is_some() {\n+            self.sess.span_err(span, \"crates of the `rustc-macro` crate type \\\n+                                      cannot be linked at runtime\");\n+        }\n+\n         let cmeta = Rc::new(cstore::CrateMetadata {\n             name: name.to_string(),\n             extern_crate: Cell::new(None),\n+            info: crate_info,\n             index: decoder::load_index(metadata.as_slice()),\n             xref_index: decoder::load_xrefs(metadata.as_slice()),\n             key_map: decoder::load_key_map(metadata.as_slice()),\n@@ -334,11 +338,6 @@ impl<'a> CrateReader<'a> {\n             explicitly_linked: Cell::new(explicitly_linked),\n         });\n \n-        if decoder::get_derive_registrar_fn(cmeta.data.as_slice()).is_some() {\n-            self.sess.span_err(span, \"crates of the `rustc-macro` crate type \\\n-                                      cannot be linked at runtime\");\n-        }\n-\n         let source = cstore::CrateSource {\n             dylib: dylib,\n             rlib: rlib,\n@@ -416,13 +415,11 @@ impl<'a> CrateReader<'a> {\n         // Note that we only do this for target triple crates, though, as we\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n+        let crate_info = decoder::get_crate_info(library.metadata.as_slice());\n         if loader.triple == self.sess.opts.target_triple {\n-            let meta_hash = decoder::get_crate_hash(library.metadata.as_slice());\n-            let meta_name = decoder::get_crate_name(library.metadata.as_slice())\n-                                    .to_string();\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n-                if data.name() == meta_name && meta_hash == data.hash() {\n+                if data.name() == crate_info.name && crate_info.hash == data.hash() {\n                     assert!(loader.hash.is_none());\n                     info!(\"load success, going to previous cnum: {}\", cnum);\n                     result = LoadResult::Previous(cnum);\n@@ -497,7 +494,7 @@ impl<'a> CrateReader<'a> {\n         }).collect()\n     }\n \n-    fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n+    fn read_extension_crate(&mut self, span: Span, info: &ExternCrateInfo) -> ExtensionCrate {\n         info!(\"read extension crate {} `extern crate {} as {}` linked={}\",\n               info.id, info.name, info.ident, info.should_link);\n         let target_triple = &self.sess.opts.target_triple[..];\n@@ -570,11 +567,12 @@ impl<'a> CrateReader<'a> {\n         let ci = self.extract_crate_info(item).unwrap();\n         let ekrate = self.read_extension_crate(item.span, &ci);\n \n+        let crate_info = decoder::get_crate_info(ekrate.metadata.as_slice());\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut ret = Macros {\n             macro_rules: Vec::new(),\n             custom_derive_registrar: None,\n-            svh: decoder::get_crate_hash(ekrate.metadata.as_slice()),\n+            svh: crate_info.hash,\n             dylib: None,\n         };\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n@@ -619,7 +617,7 @@ impl<'a> CrateReader<'a> {\n             true\n         });\n \n-        match decoder::get_derive_registrar_fn(ekrate.metadata.as_slice()) {\n+        match crate_info.macro_derive_registrar {\n             Some(id) => ret.custom_derive_registrar = Some(id),\n \n             // If this crate is not a rustc-macro crate then we might be able to\n@@ -656,7 +654,7 @@ impl<'a> CrateReader<'a> {\n     /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n                                  -> Option<(PathBuf, Svh, DefIndex)> {\n-        let ekrate = self.read_extension_crate(span, &CrateInfo {\n+        let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n              name: name.to_string(),\n              ident: name.to_string(),\n              id: ast::DUMMY_NODE_ID,\n@@ -673,13 +671,10 @@ impl<'a> CrateReader<'a> {\n             span_fatal!(self.sess, span, E0456, \"{}\", &message[..]);\n         }\n \n-        let svh = decoder::get_crate_hash(ekrate.metadata.as_slice());\n-        let registrar =\n-            decoder::get_plugin_registrar_fn(ekrate.metadata.as_slice());\n-\n-        match (ekrate.dylib.as_ref(), registrar) {\n+        let crate_info = decoder::get_crate_info(ekrate.metadata.as_slice());\n+        match (ekrate.dylib.as_ref(), crate_info.plugin_registrar_fn) {\n             (Some(dylib), Some(reg)) => {\n-                Some((dylib.to_path_buf(), svh, reg))\n+                Some((dylib.to_path_buf(), crate_info.hash, reg))\n             }\n             (None, Some(_)) => {\n                 span_err!(self.sess, span, E0457,"}, {"sha": "f650155c03546a8af55447730f2f8626695ce512", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 23, "deletions": 69, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -14,10 +14,10 @@ use decoder;\n use encoder;\n use loader;\n \n-use middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate};\n-use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n+use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, ChildItem, ExternCrate};\n+use rustc::middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n-use middle::lang_items;\n+use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n \n@@ -77,12 +77,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_item_variances(&cdata, def.index)\n     }\n \n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_repr_attrs(&cdata, def.index)\n-    }\n-\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>\n     {\n@@ -136,23 +130,21 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_adt_def(&cdata, def.index, tcx)\n     }\n \n-    fn method_arg_names(&self, did: DefId) -> Vec<String>\n+    fn fn_arg_names(&self, did: DefId) -> Vec<String>\n     {\n         self.dep_graph.read(DepNode::MetaData(did));\n         let cdata = self.get_crate_data(did.krate);\n-        decoder::get_method_arg_names(&cdata, did.index)\n-    }\n-\n-    fn item_name(&self, def: DefId) -> ast::Name {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_name(&cdata, def.index)\n+        decoder::get_fn_arg_names(&cdata, did.index)\n     }\n \n     fn opt_item_name(&self, def: DefId) -> Option<ast::Name> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_name(&cdata, def.index)\n+        if def.index == CRATE_DEF_INDEX {\n+            Some(token::intern(&cdata.name()))\n+        } else {\n+            decoder::maybe_get_item_name(&cdata, def.index)\n+        }\n     }\n \n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>\n@@ -183,10 +175,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(def_id.krate);\n-        let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data, |def, _, _| {\n-            result.push(def.def_id());\n-        });\n+        let get_crate_data = &mut |cnum| self.get_crate_data(cnum);\n+        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data,\n+                                    &mut |def, _, _| result.push(def.def_id()));\n         result\n     }\n \n@@ -339,20 +330,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn crate_hash(&self, cnum: CrateNum) -> Svh\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_crate_hash(cdata.data())\n+        self.get_crate_hash(cnum)\n     }\n \n     fn crate_disambiguator(&self, cnum: CrateNum) -> token::InternedString\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        token::intern_and_get_ident(&decoder::get_crate_disambiguator(cdata.data()))\n+        token::intern_and_get_ident(&self.get_crate_data(cnum).disambiguator())\n     }\n \n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n     {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_plugin_registrar_fn(cdata.data()).map(|index| DefId {\n+        self.get_crate_data(cnum).info.plugin_registrar_fn.map(|index| DefId {\n             krate: cnum,\n             index: index\n         })\n@@ -412,13 +400,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_struct_ctor_def_id(&cdata, struct_def_id.index)\n     }\n \n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n-    {\n-        self.dep_graph.read(DepNode::MetaData(did));\n-        let cdata = self.get_crate_data(did.krate);\n-        decoder::get_tuple_struct_definition_if_ctor(&cdata, did.index)\n-    }\n-\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n@@ -431,8 +412,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.dep_graph.read(DepNode::MetaData(def_id));\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(def_id.krate);\n-        let get_crate_data = |cnum| self.get_crate_data(cnum);\n-        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data, |def, name, vis| {\n+        let get_crate_data = &mut |cnum| self.get_crate_data(cnum);\n+        decoder::each_child_of_item(&crate_data, def_id.index, get_crate_data,\n+                                    &mut |def, name, vis| {\n             result.push(ChildItem { def: def, name: name, vis: vis });\n         });\n         result\n@@ -497,45 +479,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         };\n \n         match inlined {\n-            decoder::FoundAst::NotFound => {\n+            None => {\n                 self.inlined_item_cache\n                     .borrow_mut()\n                     .insert(def_id, None);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Item(d, ref item)) => {\n+            Some(&InlinedItem::Item(d, ref item)) => {\n                 assert_eq!(d, def_id);\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }\n-            decoder::FoundAst::FoundParent(parent_did, item) => {\n-                let inlined_root_node_id = find_inlined_item_root(item.id);\n-                cache_inlined_item(parent_did, item.id, inlined_root_node_id);\n-\n-                match item.node {\n-                    hir::ItemEnum(ref ast_def, _) => {\n-                        let ast_vs = &ast_def.variants;\n-                        let ty_vs = &tcx.lookup_adt_def(parent_did).variants;\n-                        assert_eq!(ast_vs.len(), ty_vs.len());\n-                        for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n-                            cache_inlined_item(ty_v.did,\n-                                               ast_v.node.data.id(),\n-                                               inlined_root_node_id);\n-                        }\n-                    }\n-                    hir::ItemStruct(ref struct_def, _) => {\n-                        if struct_def.is_struct() {\n-                            bug!(\"instantiate_inline: called on a non-tuple struct\")\n-                        } else {\n-                            cache_inlined_item(def_id,\n-                                               struct_def.id(),\n-                                               inlined_root_node_id);\n-                        }\n-                    }\n-                    _ => bug!(\"instantiate_inline: item has a \\\n-                               non-enum, non-struct parent\")\n-                }\n-            }\n-            decoder::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n+            Some(&InlinedItem::TraitItem(_, ref trait_item)) => {\n                 let inlined_root_node_id = find_inlined_item_root(trait_item.id);\n                 cache_inlined_item(def_id, trait_item.id, inlined_root_node_id);\n \n@@ -548,7 +502,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                 tcx.impl_or_trait_items.borrow_mut()\n                    .insert(trait_item_def_id, ty_trait_item);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::ImplItem(_, ref impl_item)) => {\n+            Some(&InlinedItem::ImplItem(_, ref impl_item)) => {\n                 let inlined_root_node_id = find_inlined_item_root(impl_item.id);\n                 cache_inlined_item(def_id, impl_item.id, inlined_root_node_id);\n             }"}, {"sha": "c6cbe6db9098b00aa84db10e01b4b5a498a22104", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -39,9 +39,9 @@ use syntax::attr;\n use syntax::codemap;\n use syntax_pos;\n \n-pub use middle::cstore::{NativeLibraryKind, LinkagePreference};\n-pub use middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n-pub use middle::cstore::{CrateSource, LinkMeta};\n+pub use rustc::middle::cstore::{NativeLibraryKind, LinkagePreference};\n+pub use rustc::middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n+pub use rustc::middle::cstore::{CrateSource, LinkMeta};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -78,6 +78,7 @@ pub struct CrateMetadata {\n     pub cnum: CrateNum,\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n \n+    pub info: common::CrateInfo,\n     pub index: index::Index,\n     pub xref_index: index::DenseIndex,\n \n@@ -143,8 +144,7 @@ impl CStore {\n     }\n \n     pub fn get_crate_hash(&self, cnum: CrateNum) -> Svh {\n-        let cdata = self.get_crate_data(cnum);\n-        decoder::get_crate_hash(cdata.data())\n+        self.get_crate_data(cnum).hash()\n     }\n \n     pub fn set_crate_data(&self, cnum: CrateNum, data: Rc<CrateMetadata>) {\n@@ -299,11 +299,9 @@ impl CStore {\n \n impl CrateMetadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n-    pub fn name(&self) -> String { decoder::get_crate_name(self.data()) }\n-    pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n-    pub fn disambiguator(&self) -> String {\n-        decoder::get_crate_disambiguator(self.data())\n-    }\n+    pub fn name(&self) -> &str { &self.info.name }\n+    pub fn hash(&self) -> Svh { self.info.hash }\n+    pub fn disambiguator(&self) -> &str { &self.info.disambiguator }\n     pub fn imported_filemaps<'a>(&'a self, codemap: &codemap::CodeMap)\n                                  -> Ref<'a, Vec<ImportedFileMap>> {\n         let filemaps = self.codemap_import_info.borrow();\n@@ -352,7 +350,7 @@ impl CrateMetadata {\n     }\n \n     pub fn panic_strategy(&self) -> PanicStrategy {\n-        decoder::get_panic_strategy(self.data())\n+        self.info.panic_strategy.clone()\n     }\n }\n "}, {"sha": "f3283451b93b8efee4ba920fc8e80d84df1f47db", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 266, "deletions": 419, "changes": 685, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -15,25 +15,22 @@\n use astencode::decode_inlined_item;\n use cstore::{self, CrateMetadata};\n use common::*;\n-use common::Family::*;\n-use def_key;\n use index;\n \n use rustc::hir::def_id::CRATE_DEF_INDEX;\n use rustc::hir::svh::Svh;\n use rustc::hir::map as hir_map;\n-use rustc::hir::map::DefKey;\n+use rustc::hir::map::{DefKey, DefPathData};\n use rustc::util::nodemap::FnvHashMap;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n-use rustc::session::config::PanicStrategy;\n \n-use middle::cstore::{InlinedItem, LinkagePreference};\n-use rustc::hir::def::{self, Def};\n+use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n-use middle::lang_items;\n+use rustc::middle::lang_items;\n use rustc::ty::{ImplContainer, TraitContainer};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n \n use rustc_const_math::ConstInt;\n@@ -51,6 +48,7 @@ use rbml;\n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n use syntax::attr;\n use syntax::ast::{self, NodeId};\n+use syntax::parse::token;\n use syntax_pos::{self, Span, BytePos};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n@@ -101,12 +99,6 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n             self.decode()\n         })\n     }\n-\n-    pub fn seq_mut<'b, T: Decodable>(&'b mut self) -> impl Iterator<Item=T> + 'b {\n-        (0..self.read_usize().unwrap()).map(move |_| {\n-            self.decode()\n-        })\n-    }\n }\n \n macro_rules! decoder_methods {\n@@ -321,6 +313,13 @@ impl CrateMetadata {\n             Some(d) => d\n         }\n     }\n+\n+    fn local_def_id(&self, index: DefIndex) -> DefId {\n+        DefId {\n+            krate: self.cnum,\n+            index: index\n+        }\n+    }\n }\n \n pub fn load_index(data: &[u8]) -> index::Index {\n@@ -342,12 +341,10 @@ pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n // Go through each item in the metadata and create a map from that\n // item's def-key to the item's DefIndex.\n pub fn load_key_map(data: &[u8]) -> FnvHashMap<DefKey, DefIndex> {\n-    rbml::Doc::new(data).get(root_tag::items).children().map(|item_doc| {\n+    load_index(data).iter_enumerated(data).map(|(index, pos)| {\n         // load def-key from item\n-        let key = item_def_key(item_doc);\n-\n-        // load def-index from item\n-        (key, item_doc.get(item_tag::def_index).decoder().decode())\n+        let key = item_def_key(rbml::Doc::at(data, pos as usize));\n+        (key, index)\n     }).collect()\n }\n \n@@ -356,38 +353,27 @@ fn item_family(item: rbml::Doc) -> Family {\n }\n \n fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n-    match reader::maybe_get_doc(item, item_tag::visibility) {\n-        None => ty::Visibility::Public,\n-        Some(visibility_doc) => visibility_doc.decoder().decode()\n-    }\n+    item.get(item_tag::visibility).decoder().decode()\n }\n \n-fn item_defaultness(item: rbml::Doc) -> hir::Defaultness {\n-    match reader::maybe_get_doc(item, item_tag::defaultness) {\n-        None => hir::Defaultness::Default, // should occur only for default impls on traits\n-        Some(defaultness_doc) => defaultness_doc.decoder().decode()\n-    }\n-}\n+fn entry_data(doc: rbml::Doc, cdata: Cmd) -> EntryData {\n+    let mut dcx = doc.get(item_tag::data).decoder();\n+    dcx.cdata = Some(cdata);\n \n-fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<DefId> {\n-    reader::maybe_get_doc(d, item_tag::parent_item).map(|did| {\n-        let mut dcx = did.decoder();\n-        dcx.cdata = Some(cdata);\n-        dcx.decode()\n-    })\n+    dcx.decode()\n }\n \n-fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> DefId {\n-    let mut dcx = d.get(item_tag::parent_item).decoder();\n+fn entry_typed_data<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n+                              -> EntryTypedData<'tcx> {\n+    let mut dcx = doc.get(item_tag::typed_data).decoder();\n     dcx.cdata = Some(cdata);\n+    dcx.tcx = Some(tcx);\n+\n     dcx.decode()\n }\n \n-fn item_def_id(d: rbml::Doc, cdata: Cmd) -> DefId {\n-    DefId {\n-        krate: cdata.cnum,\n-        index: d.get(item_tag::def_index).decoder().decode()\n-    }\n+fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<DefId> {\n+    item_def_key(d).parent.map(|index| cdata.local_def_id(index))\n }\n \n fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n@@ -404,53 +390,63 @@ fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata:\n     })\n }\n \n-fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n-                           -> ty::TraitRef<'tcx> {\n-    let mut dcx = doc.decoder();\n-    dcx.tcx = Some(tcx);\n-    dcx.cdata = Some(cdata);\n-    dcx.decode()\n-}\n-\n fn item_name(item: rbml::Doc) -> ast::Name {\n     maybe_item_name(item).expect(\"no item in item_name\")\n }\n \n fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n-    reader::maybe_get_doc(item, item_tag::name).map(|name| {\n-        name.decoder().decode()\n-    })\n-}\n+    let name = match item_def_key(item).disambiguated_data.data {\n+        DefPathData::TypeNs(name) |\n+        DefPathData::ValueNs(name) |\n+        DefPathData::Module(name) |\n+        DefPathData::MacroDef(name) |\n+        DefPathData::TypeParam(name) |\n+        DefPathData::LifetimeDef(name) |\n+        DefPathData::EnumVariant(name) |\n+        DefPathData::Field(name) |\n+        DefPathData::Binding(name) => Some(name),\n+\n+        DefPathData::InlinedRoot(_) => bug!(\"unexpected DefPathData\"),\n+\n+        DefPathData::CrateRoot |\n+        DefPathData::Misc |\n+        DefPathData::Impl |\n+        DefPathData::ClosureExpr |\n+        DefPathData::StructCtor |\n+        DefPathData::Initializer |\n+        DefPathData::ImplTrait => None\n+    };\n \n-fn item_to_def(cdata: Cmd, item: rbml::Doc, did: DefId) -> Option<Def> {\n-    Some(match item_family(item) {\n-        Family::Const  => Def::Const(did),\n-        Family::AssociatedConst => Def::AssociatedConst(did),\n-        Family::ImmStatic => Def::Static(did, false),\n-        Family::MutStatic => Def::Static(did, true),\n-        Family::Struct(..) => Def::Struct(did),\n-        Family::Union => Def::Union(did),\n-        Family::Fn  => Def::Fn(did),\n-        Family::Method => Def::Method(did),\n-        Family::Type => Def::TyAlias(did),\n-        Family::AssociatedType => {\n-            Def::AssociatedTy(item_require_parent_item(cdata, item), did)\n-        }\n-        Family::Mod => Def::Mod(did),\n-        Family::ForeignMod => Def::ForeignMod(did),\n-        Family::Variant(..) => {\n-            Def::Variant(item_require_parent_item(cdata, item), did)\n-        }\n-        Family::Trait => Def::Trait(did),\n-        Family::Enum => Def::Enum(did),\n-\n-        Family::Impl |\n-        Family::DefaultImpl |\n-        Family::PublicField |\n-        Family::InheritedField => {\n-            return None\n-        }\n-    })\n+    name.map(|s| token::intern(&s))\n+}\n+\n+impl Family {\n+    fn to_def(&self, did: DefId) -> Option<Def> {\n+        Some(match *self {\n+            Family::Const  => Def::Const(did),\n+            Family::AssociatedConst => Def::AssociatedConst(did),\n+            Family::ImmStatic | Family::ForeignImmStatic => Def::Static(did, false),\n+            Family::MutStatic | Family::ForeignMutStatic => Def::Static(did, true),\n+            Family::Struct => Def::Struct(did),\n+            Family::Union => Def::Union(did),\n+            Family::Fn | Family::ForeignFn  => Def::Fn(did),\n+            Family::Method => Def::Method(did),\n+            Family::Type => Def::TyAlias(did),\n+            Family::AssociatedType => Def::AssociatedTy(did),\n+            Family::Mod => Def::Mod(did),\n+            Family::Variant => Def::Variant(did),\n+            Family::Trait => Def::Trait(did),\n+            Family::Enum => Def::Enum(did),\n+\n+            Family::ForeignMod |\n+            Family::Impl |\n+            Family::DefaultImpl |\n+            Family::Field |\n+            Family::Closure => {\n+                return None\n+            }\n+        })\n+    }\n }\n \n pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n@@ -459,130 +455,94 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n {\n     let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata);\n-    let unsafety = item_doc.get(item_tag::unsafety).decoder().decode();\n-    let paren_sugar = item_doc.get(item_tag::paren_sugar).decoder().decode();\n-    let trait_ref = doc_trait_ref(item_doc.get(item_tag::trait_ref), tcx, cdata);\n-    let def_path = def_path(cdata, item_id).unwrap();\n \n-    ty::TraitDef::new(unsafety, paren_sugar, generics, trait_ref,\n-                      def_path.deterministic_hash(tcx))\n+    let data = match entry_data(item_doc, cdata) {\n+        EntryData::Trait(data) => data,\n+        _ => bug!()\n+    };\n+    let typed_data = match entry_typed_data(item_doc, tcx, cdata) {\n+        EntryTypedData::Trait(data) => data,\n+        _ => bug!()\n+    };\n+\n+    ty::TraitDef::new(data.unsafety, data.paren_sugar, generics, typed_data.trait_ref,\n+                      def_path(cdata, item_id).unwrap().deterministic_hash(tcx)))\n+}\n+\n+fn get_variant<'tcx>(cdata: Cmd,\n+                     item: rbml::Doc,\n+                     index: DefIndex)\n+                     -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n+    let data = match entry_data(item, cdata) {\n+        EntryData::Variant(data) => data,\n+        _ => bug!()\n+    };\n+\n+    let mut dcx = item.get(item_tag::children).decoder();\n+    dcx.cdata = Some(cdata);\n+\n+    let fields = dcx.seq().map(|index| {\n+        let f = cdata.lookup_item(index);\n+        ty::FieldDefData::new(cdata.local_def_id(index),\n+                              item_name(f),\n+                              item_visibility(f))\n+    }).collect();\n+\n+    (ty::VariantDefData {\n+        did: cdata.local_def_id(data.struct_ctor.unwrap_or(index)),\n+        name: item_name(item),\n+        fields: fields,\n+        disr_val: ConstInt::Infer(data.disr),\n+        kind: data.kind,\n+    }, data.struct_ctor)\n }\n \n pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n                              item_id: DefIndex,\n                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> ty::AdtDefMaster<'tcx>\n {\n-    fn expect_variant_kind(family: Family) -> ty::VariantKind {\n-        match family {\n-            Struct(kind) | Variant(kind) => kind,\n-            Union => ty::VariantKind::Struct,\n-            _ => bug!(\"unexpected family: {:?}\", family),\n-        }\n-    }\n-    fn get_enum_variants<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::VariantDefData<'tcx, 'tcx>> {\n+    let doc = cdata.lookup_item(item_id);\n+    let did = cdata.local_def_id(item_id);\n+    let mut ctor_index = None;\n+    let family = item_family(doc);\n+    let variants = if family == Family::Enum {\n         let mut dcx = doc.get(item_tag::children).decoder();\n         dcx.cdata = Some(cdata);\n \n-        dcx.seq().map(|did: DefId| {\n-            let item = cdata.lookup_item(did.index);\n-            let disr = item.get(item_tag::disr_val).decoder().decode();\n-            ty::VariantDefData {\n-                did: did,\n-                name: item_name(item),\n-                fields: get_variant_fields(cdata, item),\n-                disr_val: ConstInt::Infer(disr),\n-                kind: expect_variant_kind(item_family(item)),\n-            }\n+        dcx.seq().map(|index| {\n+            let (variant, struct_ctor) = get_variant(cdata, cdata.lookup_item(index), index);\n+            assert_eq!(struct_ctor, None);\n+            variant\n         }).collect()\n-    }\n-    fn get_variant_fields<'tcx>(cdata: Cmd, doc: rbml::Doc) -> Vec<ty::FieldDefData<'tcx, 'tcx>> {\n-        let mut dcx = doc.get(item_tag::fields).decoder();\n-        dcx.cdata = Some(cdata);\n-\n-        dcx.seq().map(|did: DefId| {\n-            let f = cdata.lookup_item(did.index);\n-            let vis = match item_family(f) {\n-                PublicField => ty::Visibility::Public,\n-                InheritedField => ty::Visibility::PrivateExternal,\n-                _ => bug!()\n-            };\n-            ty::FieldDefData::new(did, item_name(f), vis)\n-        }).collect()\n-    }\n-    fn get_struct_variant<'tcx>(cdata: Cmd,\n-                                doc: rbml::Doc,\n-                                did: DefId) -> ty::VariantDefData<'tcx, 'tcx> {\n-        ty::VariantDefData {\n-            did: did,\n-            name: item_name(doc),\n-            fields: get_variant_fields(cdata, doc),\n-            disr_val: ConstInt::Infer(0),\n-            kind: expect_variant_kind(item_family(doc)),\n-        }\n-    }\n-\n-    let doc = cdata.lookup_item(item_id);\n-    let did = DefId { krate: cdata.cnum, index: item_id };\n-    let mut ctor_did = None;\n-    let (kind, variants) = match item_family(doc) {\n-        Enum => {\n-            (AdtKind::Enum, get_enum_variants(cdata, doc))\n-        }\n-        Struct(..) => {\n-            // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n-            ctor_did = reader::maybe_get_doc(doc, item_tag::struct_ctor).map(|ctor_doc| {\n-                let mut dcx = ctor_doc.decoder();\n-                dcx.cdata = Some(cdata);\n-                dcx.decode()\n-            });\n-            (AdtKind::Struct, vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n-        }\n-        Union => {\n-            (AdtKind::Union, vec![get_struct_variant(cdata, doc, did)])\n-        }\n-        _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\", item_family(doc), did)\n+    } else{\n+        let (variant, struct_ctor) = get_variant(cdata, doc, item_id);\n+        ctor_index = struct_ctor;\n+        vec![variant]\n+    };\n+    let kind = match family {\n+        Family::Enum => ty::AdtKind::Enum,\n+        Family::Struct => ty::AdtKind::Struct,\n+        Family::Union => ty::AdtKind::Union,\n+        _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n+                  family, did)\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n-    if let Some(ctor_did) = ctor_did {\n+    if let Some(ctor_index) = ctor_index {\n         // Make adt definition available through constructor id as well.\n-        tcx.insert_adt_def(ctor_did, adt);\n+        tcx.insert_adt_def(cdata.local_def_id(ctor_index), adt);\n     }\n \n     // this needs to be done *after* the variant is interned,\n     // to support recursive structures\n     for variant in &adt.variants {\n-        if variant.kind == ty::VariantKind::Tuple && adt.is_enum() {\n-            // tuple-like enum variant fields aren't real items - get the types\n-            // from the ctor.\n-            debug!(\"evaluating the ctor-type of {:?}\",\n-                   variant.name);\n-            let ctor_ty = get_type(cdata, variant.did.index, tcx);\n-            debug!(\"evaluating the ctor-type of {:?}.. {:?}\",\n-                   variant.name,\n-                   ctor_ty);\n-            let field_tys = match ctor_ty.sty {\n-                ty::TyFnDef(.., &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n-                    ref inputs, ..\n-                }), ..}) => {\n-                    // tuple-struct constructors don't have escaping regions\n-                    assert!(!inputs.has_escaping_regions());\n-                    inputs\n-                },\n-                _ => bug!(\"tuple-variant ctor is not an ADT\")\n-            };\n-            for (field, &ty) in variant.fields.iter().zip(field_tys.iter()) {\n-                field.fulfill_ty(ty);\n-            }\n-        } else {\n-            for field in &variant.fields {\n-                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n-                let ty = get_type(cdata, field.did.index, tcx);\n-                field.fulfill_ty(ty);\n-                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n-                       variant.name, field.name, ty);\n-            }\n+        for field in &variant.fields {\n+            debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n+            let ty = get_type(cdata, field.did.index, tcx);\n+            field.fulfill_ty(ty);\n+            debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n+                   variant.name, field.name, ty);\n         }\n     }\n \n@@ -641,46 +601,38 @@ pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n     item_visibility(cdata.lookup_item(id))\n }\n \n-pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n-    let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, item_tag::parent_impl).map(|doc| {\n-        let mut dcx = doc.decoder();\n-        dcx.cdata = Some(cdata);\n-        dcx.decode()\n-    })\n+fn get_impl_data(cdata: Cmd, id: DefIndex) -> ImplData {\n+    match entry_data(cdata.lookup_item(id), cdata) {\n+        EntryData::Impl(data) => data,\n+        _ => bug!()\n+    }\n }\n \n-pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n-    let item = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item, item_tag::repr).map_or(vec![], |doc| {\n-        doc.decoder().decode()\n-    })\n+pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n+    get_impl_data(cdata, id).parent_impl\n }\n \n pub fn get_impl_polarity(cdata: Cmd, id: DefIndex) -> hir::ImplPolarity {\n-    cdata.lookup_item(id).get(item_tag::polarity).decoder().decode()\n+    get_impl_data(cdata, id).polarity\n }\n \n pub fn get_custom_coerce_unsized_kind(\n     cdata: Cmd,\n     id: DefIndex)\n     -> Option<ty::adjustment::CustomCoerceUnsized>\n {\n-    let item_doc = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item_doc, item_tag::impl_coerce_unsized_kind).map(|kind_doc| {\n-        kind_doc.decoder().decode()\n-    })\n+    get_impl_data(cdata, id).coerce_unsized_kind\n }\n \n pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n                                 id: DefIndex,\n                                 tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                 -> Option<ty::TraitRef<'tcx>>\n {\n-    let item_doc = cdata.lookup_item(id);\n-    reader::maybe_get_doc(item_doc, item_tag::trait_ref).map(|tp| {\n-        doc_trait_ref(tp, tcx, cdata)\n-    })\n+    match entry_typed_data(cdata.lookup_item(id), tcx, cdata) {\n+        EntryTypedData::Impl(data) => data.trait_ref,\n+        _ => bug!()\n+    }\n }\n \n /// Iterates over the language items in the given crate.\n@@ -691,8 +643,8 @@ pub fn get_lang_items(cdata: Cmd) -> Vec<(DefIndex, usize)> {\n \n /// Iterates over each child of the given item.\n pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex,\n-                                mut get_crate_data: G,\n-                                mut callback: F)\n+                                mut get_crate_data: &mut G,\n+                                mut callback: &mut F)\n     where F: FnMut(Def, ast::Name, ty::Visibility),\n           G: FnMut(CrateNum) -> Rc<CrateMetadata>,\n {\n@@ -709,31 +661,24 @@ pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex,\n     dcx.cdata = Some(cdata);\n \n     // Iterate over all children.\n-    for child_def_id in dcx.seq_mut::<DefId>() {\n-        // This item may be in yet another crate if it was the child of a\n-        // reexport.\n-        let crate_data = if child_def_id.krate == cdata.cnum {\n-            None\n-        } else {\n-            Some(get_crate_data(child_def_id.krate))\n-        };\n-        let crate_data = match crate_data {\n-            Some(ref cdata) => &**cdata,\n-            None => cdata\n-        };\n-\n+    for child_index in dcx.seq::<DefIndex>() {\n         // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(child_def_id.index) {\n+        if let Some(child) = cdata.get_item(child_index) {\n             // Hand off the item to the callback.\n-            if let Some(def) = item_to_def(crate_data, child_item_doc, child_def_id) {\n-                let child_name = item_name(child_item_doc);\n-                let visibility = item_visibility(child_item_doc);\n-                callback(def, child_name, visibility);\n+            let family = item_family(child);\n+            if let Family::ForeignMod = family {\n+                each_child_of_item(cdata, child_index, get_crate_data, callback);\n+            } else if let Some(def) = family.to_def(cdata.local_def_id(child_index)) {\n+                callback(def, item_name(child), item_visibility(child));\n             }\n         }\n     }\n \n-    for exp in dcx.seq_mut::<def::Export>() {\n+    let reexports = match entry_data(item_doc, cdata) {\n+        EntryData::Mod(data) => data.reexports,\n+        _ => return\n+    };\n+    for exp in reexports {\n         // This reexport may be in yet another crate.\n         let crate_data = if exp.def_id.krate == cdata.cnum {\n             None\n@@ -746,9 +691,9 @@ pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex,\n         };\n \n         // Get the item.\n-        if let Some(child_item_doc) = crate_data.get_item(exp.def_id.index) {\n+        if let Some(child) = crate_data.get_item(exp.def_id.index) {\n             // Hand off the item to the callback.\n-            if let Some(def) = item_to_def(crate_data, child_item_doc, exp.def_id) {\n+            if let Some(def) = item_family(child).to_def(exp.def_id) {\n                 // These items have a public visibility because they're part of\n                 // a public re-export.\n                 callback(def, exp.name, ty::Visibility::Public);\n@@ -757,62 +702,21 @@ pub fn each_child_of_item<F, G>(cdata: Cmd, id: DefIndex,\n     }\n }\n \n-pub fn get_item_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n-    item_name(cdata.lookup_item(id))\n-}\n-\n pub fn maybe_get_item_name(cdata: Cmd, id: DefIndex) -> Option<ast::Name> {\n     maybe_item_name(cdata.lookup_item(id))\n }\n \n-pub enum FoundAst<'ast> {\n-    Found(&'ast InlinedItem),\n-    FoundParent(DefId, &'ast hir::Item),\n-    NotFound,\n-}\n-\n pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n-                                    -> FoundAst<'tcx> {\n+                                    -> Option<&'tcx InlinedItem> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n-    let item_did = item_def_id(item_doc, cdata);\n-    let parent_def_id = DefId {\n-        krate: cdata.cnum,\n-        index: def_key(cdata, id).parent.unwrap()\n-    };\n+    let item_did = cdata.local_def_id(id);\n+    let parent_def_id = cdata.local_def_id(def_key(cdata, id).parent.unwrap());\n     let mut parent_def_path = def_path(cdata, id).unwrap();\n     parent_def_path.data.pop();\n-    if let Some(ast_doc) = reader::maybe_get_doc(item_doc, item_tag::ast as usize) {\n-        let ii = decode_inlined_item(cdata,\n-                                     tcx,\n-                                     parent_def_path,\n-                                     parent_def_id,\n-                                     ast_doc,\n-                                     item_did);\n-        return FoundAst::Found(ii);\n-    } else if let Some(parent_did) = item_parent_item(cdata, item_doc) {\n-        // Remove the last element from the paths, since we are now\n-        // trying to inline the parent.\n-        let grandparent_def_id = DefId {\n-            krate: cdata.cnum,\n-            index: def_key(cdata, parent_def_id.index).parent.unwrap()\n-        };\n-        let mut grandparent_def_path = parent_def_path;\n-        grandparent_def_path.data.pop();\n-        let parent_doc = cdata.lookup_item(parent_did.index);\n-        if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, item_tag::ast as usize) {\n-            let ii = decode_inlined_item(cdata,\n-                                         tcx,\n-                                         grandparent_def_path,\n-                                         grandparent_def_id,\n-                                         ast_doc,\n-                                         parent_did);\n-            if let &InlinedItem::Item(_, ref i) = ii {\n-                return FoundAst::FoundParent(parent_did, i);\n-            }\n-        }\n-    }\n-    FoundAst::NotFound\n+    reader::maybe_get_doc(item_doc, item_tag::ast).map(|ast_doc| {\n+        decode_inlined_item(cdata, tcx, parent_def_path, parent_def_id, ast_doc, item_did)\n+    })\n }\n \n pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n@@ -837,41 +741,41 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n     })\n }\n \n-fn get_explicit_self<'a, 'tcx>(cdata: Cmd, item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                               -> ty::ExplicitSelfCategory<'tcx> {\n-    let mut dcx = item.get(item_tag::trait_method_explicit_self).decoder();\n-    dcx.cdata = Some(cdata);\n-    dcx.tcx = Some(tcx);\n-\n-    dcx.decode()\n-}\n-\n-pub fn get_trait_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n-    let doc = cdata.lookup_item(id);\n-    item_name(doc)\n-}\n-\n pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n+    let family = item_family(item_doc);\n \n-    let def_id = item_def_id(item_doc, cdata);\n+    match family {\n+        Family::AssociatedConst |\n+        Family::Method |\n+        Family::AssociatedType => {}\n \n-    let container_id = if let Some(id) = item_parent_item(cdata, item_doc) {\n-        id\n-    } else {\n-        return None;\n-    };\n+        _ => return None\n+    }\n+\n+    let def_id = cdata.local_def_id(id);\n+\n+    let container_id = item_parent_item(cdata, item_doc).unwrap();\n     let container = match item_family(cdata.lookup_item(container_id.index)) {\n-        Trait => TraitContainer(container_id),\n+        Family::Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n     };\n \n     let name = item_name(item_doc);\n     let vis = item_visibility(item_doc);\n-    let defaultness = item_defaultness(item_doc);\n \n-    Some(match item_family(item_doc) {\n+    let (defaultness, has_body) = match entry_data(item_doc, cdata) {\n+        EntryData::TraitAssociated(data) => {\n+            (hir::Defaultness::Default, data.has_default)\n+        }\n+        EntryData::ImplAssociated(data) => {\n+            (data.defaultness, true)\n+        }\n+        _ => bug!()\n+    };\n+\n+    Some(match family {\n         Family::AssociatedConst => {\n             let ty = doc_type(item_doc, tcx, cdata);\n             ty::ConstTraitItem(Rc::new(ty::AssociatedConst {\n@@ -881,7 +785,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                 defaultness: defaultness,\n                 def_id: def_id,\n                 container: container,\n-                has_value: item_doc.get(item_tag::trait_item_has_body).decoder().decode(),\n+                has_value: has_body,\n             }))\n         }\n         Family::Method => {\n@@ -894,8 +798,11 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                     \"the type {:?} of the method {:?} is not a function?\",\n                     ity, name)\n             };\n-            let explicit_self = get_explicit_self(cdata, item_doc, tcx);\n \n+            let explicit_self = match entry_typed_data(item_doc, tcx, cdata) {\n+                EntryTypedData::Method(data) => data.explicit_self,\n+                _ => bug!()\n+            };\n             ty::MethodTraitItem(Rc::new(ty::Method {\n                 name: name,\n                 generics: generics,\n@@ -904,7 +811,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                 explicit_self: explicit_self,\n                 vis: vis,\n                 defaultness: defaultness,\n-                has_body: item_doc.get(item_tag::trait_item_has_body).decoder().decode(),\n+                has_body: has_body,\n                 def_id: def_id,\n                 container: container,\n             }))\n@@ -920,7 +827,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                 container: container,\n             }))\n         }\n-        _ => return None\n+        _ => bug!()\n     })\n }\n \n@@ -931,49 +838,33 @@ pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n \n pub fn get_struct_ctor_def_id(cdata: Cmd, node_id: DefIndex) -> Option<DefId>\n {\n-    let item = cdata.lookup_item(node_id);\n-    reader::maybe_get_doc(item, item_tag::struct_ctor).map(|ctor_doc| {\n-        let mut dcx = ctor_doc.decoder();\n-        dcx.cdata = Some(cdata);\n-        dcx.decode()\n-    })\n-}\n+    let data = match entry_data(cdata.lookup_item(node_id), cdata) {\n+        EntryData::Variant(data) => data,\n+        _ => bug!()\n+    };\n \n-/// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n-/// the actual type definition, otherwise, return None\n-pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n-                                           node_id: DefIndex)\n-    -> Option<DefId>\n-{\n-    let item = cdata.lookup_item(node_id);\n-    reader::maybe_get_doc(item, item_tag::is_tuple_struct_ctor).and_then(|doc| {\n-        if doc.decoder().decode() {\n-            Some(item_require_parent_item(cdata, item))\n-        } else {\n-            None\n-        }\n-    })\n+    data.struct_ctor.map(|index| cdata.local_def_id(index))\n }\n \n pub fn get_item_attrs(cdata: Cmd,\n-                      orig_node_id: DefIndex)\n+                      node_id: DefIndex)\n                       -> Vec<ast::Attribute> {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n-    let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n-    let node_id = node_id.map(|x| x.index).unwrap_or(orig_node_id);\n-    let item = cdata.lookup_item(node_id);\n+    let mut item = cdata.lookup_item(node_id);\n+    let def_key = item_def_key(item);\n+    if def_key.disambiguated_data.data == DefPathData::StructCtor {\n+        item = cdata.lookup_item(def_key.parent.unwrap());\n+    }\n     get_attributes(item)\n }\n \n pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n-    let mut dcx = cdata.lookup_item(id).get(item_tag::fields).decoder();\n+    let mut dcx = cdata.lookup_item(id).get(item_tag::children).decoder();\n     dcx.cdata = Some(cdata);\n \n-    dcx.seq().map(|did: DefId| {\n-        item_name(cdata.lookup_item(did.index))\n-    }).collect()\n+    dcx.seq().map(|index| item_name(cdata.lookup_item(index))).collect()\n }\n \n fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n@@ -1019,36 +910,8 @@ fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n     Ok(())\n }\n \n-pub fn maybe_get_crate_hash(data: &[u8]) -> Option<Svh> {\n-    let cratedoc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(cratedoc, root_tag::crate_hash).map(|doc| {\n-        doc.decoder().decode()\n-    })\n-}\n-\n-pub fn get_crate_hash(data: &[u8]) -> Svh {\n-    rbml::Doc::new(data).get(root_tag::crate_hash).decoder().decode()\n-}\n-\n-pub fn maybe_get_crate_name(data: &[u8]) -> Option<String> {\n-    let cratedoc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(cratedoc, root_tag::crate_crate_name).map(|doc| {\n-        doc.decoder().decode()\n-    })\n-}\n-\n-pub fn get_crate_disambiguator(data: &[u8]) -> String {\n-    rbml::Doc::new(data).get(root_tag::crate_disambiguator).decoder().decode()\n-}\n-\n-pub fn get_crate_triple(data: &[u8]) -> Option<String> {\n-    let cratedoc = rbml::Doc::new(data);\n-    let triple_doc = reader::maybe_get_doc(cratedoc, root_tag::crate_triple);\n-    triple_doc.map(|s| s.decoder().decode())\n-}\n-\n-pub fn get_crate_name(data: &[u8]) -> String {\n-    maybe_get_crate_name(data).expect(\"no crate name in crate\")\n+pub fn get_crate_info(data: &[u8]) -> CrateInfo {\n+    rbml::Doc::new(data).get(root_tag::crate_info).decoder().decode()\n }\n \n pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Write) -> io::Result<()> {\n@@ -1118,9 +981,8 @@ pub fn get_trait_of_item(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n-    match item_family(parent_item_doc) {\n-        Trait => Some(item_def_id(parent_item_doc, cdata)),\n+    match item_family(cdata.lookup_item(parent_item_id.index)) {\n+        Family::Trait => Some(parent_item_id),\n         _ => None\n     }\n }\n@@ -1131,11 +993,6 @@ pub fn get_native_libraries(cdata: Cmd)\n     rbml::Doc::new(cdata.data()).get(root_tag::native_libraries).decoder().decode()\n }\n \n-pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n-    reader::maybe_get_doc(rbml::Doc::new(data), root_tag::plugin_registrar_fn)\n-        .map(|doc| doc.decoder().decode())\n-}\n-\n pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n     F: FnMut(ast::Name, Vec<ast::Attribute>, Span, String) -> bool,\n {\n@@ -1147,11 +1004,6 @@ pub fn each_exported_macro<F>(data: &[u8], mut f: F) where\n     }\n }\n \n-pub fn get_derive_registrar_fn(data: &[u8]) -> Option<DefIndex> {\n-    reader::maybe_get_doc(rbml::Doc::new(data), root_tag::macro_derive_registrar)\n-        .map(|doc| doc.decoder().decode())\n-}\n-\n pub fn get_dylib_dependency_formats(cdata: Cmd)\n     -> Vec<(CrateNum, LinkagePreference)>\n {\n@@ -1167,9 +1019,9 @@ pub fn get_missing_lang_items(cdata: Cmd) -> Vec<lang_items::LangItem> {\n     rbml::Doc::new(cdata.data()).get(root_tag::lang_items_missing).decoder().decode()\n }\n \n-pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n+pub fn get_fn_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n     let method_doc = cdata.lookup_item(id);\n-    match reader::maybe_get_doc(method_doc, item_tag::method_argument_names) {\n+    match reader::maybe_get_doc(method_doc, item_tag::fn_arg_names) {\n         Some(args_doc) => args_doc.decoder().decode(),\n         None => vec![],\n     }\n@@ -1178,24 +1030,16 @@ pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n pub fn get_reachable_ids(cdata: Cmd) -> Vec<DefId> {\n     let dcx = rbml::Doc::new(cdata.data()).get(root_tag::reachable_ids).decoder();\n \n-    dcx.seq().map(|index| {\n-        DefId {\n-            krate: cdata.cnum,\n-            index: index,\n-        }\n-    }).collect()\n+    dcx.seq().map(|index| cdata.local_def_id(index)).collect()\n }\n \n pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n-    match reader::maybe_get_doc(cdata.lookup_item(id), item_tag::constness) {\n-        None => false,\n-        Some(doc) => {\n-            match doc.decoder().decode() {\n-                hir::Constness::Const => true,\n-                hir::Constness::NotConst => false,\n-            }\n-        }\n-    }\n+    let constness = match entry_data(cdata.lookup_item(id), cdata) {\n+        EntryData::ImplAssociated(data) => data.constness,\n+        EntryData::Fn(data) => data.constness,\n+        _ => hir::Constness::NotConst\n+    };\n+    constness == hir::Constness::Const\n }\n \n pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n@@ -1207,8 +1051,15 @@ pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n         None => return false,\n     };\n     let applicable = match item_family(item_doc) {\n-        ImmStatic | MutStatic => true,\n-        Fn => get_generics(cdata, id, tcx).types.is_empty(),\n+        Family::ImmStatic |\n+        Family::MutStatic |\n+        Family::ForeignImmStatic |\n+        Family::ForeignMutStatic => true,\n+\n+        Family::Fn | Family::ForeignFn => {\n+            get_generics(cdata, id, tcx).types.is_empty()\n+        }\n+\n         _ => false,\n     };\n \n@@ -1221,13 +1072,12 @@ pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n }\n \n pub fn is_foreign_item(cdata: Cmd, id: DefIndex) -> bool {\n-    let item_doc = cdata.lookup_item(id);\n-    let parent_item_id = match item_parent_item(cdata, item_doc) {\n-        None => return false,\n-        Some(item_id) => item_id,\n-    };\n-    let parent_item_doc = cdata.lookup_item(parent_item_id.index);\n-    item_family(parent_item_doc) == ForeignMod\n+    match item_family(cdata.lookup_item(id)) {\n+        Family::ForeignImmStatic |\n+        Family::ForeignMutStatic |\n+        Family::ForeignFn => true,\n+        _ => false\n+    }\n }\n \n fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n@@ -1268,7 +1118,10 @@ fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n }\n \n pub fn is_defaulted_trait(cdata: Cmd, trait_id: DefIndex) -> bool {\n-    cdata.lookup_item(trait_id).get(item_tag::defaulted_trait).decoder().decode()\n+    match entry_data(cdata.lookup_item(trait_id), cdata) {\n+        EntryData::Trait(data) => data.has_default_impl,\n+        _ => bug!()\n+    }\n }\n \n pub fn is_default_impl(cdata: Cmd, impl_id: DefIndex) -> bool {\n@@ -1280,29 +1133,27 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<syntax_pos::FileMap> {\n }\n \n pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n-    cdata.lookup_item(closure_id).get(item_tag::closure_kind).decoder().decode()\n+    match entry_data(cdata.lookup_item(closure_id), cdata) {\n+        EntryData::Closure(data) => data.kind,\n+        _ => bug!()\n+    }\n }\n \n pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                             -> ty::ClosureTy<'tcx> {\n-    let closure_doc = cdata.lookup_item(closure_id);\n-    let closure_ty_doc = closure_doc.get(item_tag::closure_ty);\n-    let mut dcx = closure_ty_doc.decoder();\n-    dcx.tcx = Some(tcx);\n-    dcx.cdata = Some(cdata);\n-    dcx.decode()\n+    match entry_typed_data(cdata.lookup_item(closure_id), tcx, cdata) {\n+        EntryTypedData::Closure(data) => data.ty,\n+        _ => bug!()\n+    }\n }\n \n pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {\n     debug!(\"def_key: id={:?}\", id);\n-    let item_doc = cdata.lookup_item(id);\n-    item_def_key(item_doc)\n+    item_def_key(cdata.lookup_item(id))\n }\n \n fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n-    let simple_key = item_doc.get(item_tag::def_key).decoder().decode();\n-    let name = maybe_item_name(item_doc).map(|name| name.as_str());\n-    def_key::recover_def_key(simple_key, name)\n+    item_doc.get(item_tag::def_key).decoder().decode()\n }\n \n // Returns the path leading to the thing with this `id`. Note that\n@@ -1316,7 +1167,3 @@ pub fn def_path(cdata: Cmd, id: DefIndex) -> Option<hir_map::DefPath> {\n         None\n     }\n }\n-\n-pub fn get_panic_strategy(data: &[u8]) -> PanicStrategy {\n-    rbml::Doc::new(data).get(root_tag::panic_strategy).decoder().decode()\n-}"}, {"sha": "285ca2e4d4d4de2367259410dd9f09a3e291e73c", "filename": "src/librustc_metadata/def_key.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6742b239ac0e1fad2e3981b6201d5789b7298554/src%2Flibrustc_metadata%2Fdef_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6742b239ac0e1fad2e3981b6201d5789b7298554/src%2Flibrustc_metadata%2Fdef_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdef_key.rs?ref=6742b239ac0e1fad2e3981b6201d5789b7298554", "patch": "@@ -1,110 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::def_id::DefIndex;\n-use rustc::hir::map as hir_map;\n-use syntax::parse::token::InternedString;\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct DefKey {\n-    pub parent: Option<DefIndex>,\n-    pub disambiguated_data: DisambiguatedDefPathData,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct DisambiguatedDefPathData {\n-    pub data: DefPathData,\n-    pub disambiguator: u32,\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub enum DefPathData {\n-    CrateRoot,\n-    Misc,\n-    Impl,\n-    TypeNs,\n-    ValueNs,\n-    Module,\n-    MacroDef,\n-    ClosureExpr,\n-    TypeParam,\n-    LifetimeDef,\n-    EnumVariant,\n-    Field,\n-    StructCtor,\n-    Initializer,\n-    Binding,\n-    ImplTrait,\n-}\n-\n-pub fn simplify_def_key(key: hir_map::DefKey) -> DefKey {\n-    let data = DisambiguatedDefPathData {\n-        data: simplify_def_path_data(key.disambiguated_data.data),\n-        disambiguator: key.disambiguated_data.disambiguator,\n-    };\n-    DefKey {\n-        parent: key.parent,\n-        disambiguated_data: data,\n-    }\n-}\n-\n-fn simplify_def_path_data(data: hir_map::DefPathData) -> DefPathData {\n-    match data {\n-        hir_map::DefPathData::CrateRoot => DefPathData::CrateRoot,\n-        hir_map::DefPathData::InlinedRoot(_) => bug!(\"unexpected DefPathData\"),\n-        hir_map::DefPathData::Misc => DefPathData::Misc,\n-        hir_map::DefPathData::Impl => DefPathData::Impl,\n-        hir_map::DefPathData::TypeNs(_) => DefPathData::TypeNs,\n-        hir_map::DefPathData::ValueNs(_) => DefPathData::ValueNs,\n-        hir_map::DefPathData::Module(_) => DefPathData::Module,\n-        hir_map::DefPathData::MacroDef(_) => DefPathData::MacroDef,\n-        hir_map::DefPathData::ClosureExpr => DefPathData::ClosureExpr,\n-        hir_map::DefPathData::TypeParam(_) => DefPathData::TypeParam,\n-        hir_map::DefPathData::LifetimeDef(_) => DefPathData::LifetimeDef,\n-        hir_map::DefPathData::EnumVariant(_) => DefPathData::EnumVariant,\n-        hir_map::DefPathData::Field(_) => DefPathData::Field,\n-        hir_map::DefPathData::StructCtor => DefPathData::StructCtor,\n-        hir_map::DefPathData::Initializer => DefPathData::Initializer,\n-        hir_map::DefPathData::Binding(_) => DefPathData::Binding,\n-        hir_map::DefPathData::ImplTrait => DefPathData::ImplTrait,\n-    }\n-}\n-\n-pub fn recover_def_key(key: DefKey, name: Option<InternedString>) -> hir_map::DefKey {\n-    let data = hir_map::DisambiguatedDefPathData {\n-        data: recover_def_path_data(key.disambiguated_data.data, name),\n-        disambiguator: key.disambiguated_data.disambiguator,\n-    };\n-    hir_map::DefKey {\n-        parent: key.parent,\n-        disambiguated_data: data,\n-    }\n-}\n-\n-fn recover_def_path_data(data: DefPathData, name: Option<InternedString>) -> hir_map::DefPathData {\n-    match data {\n-        DefPathData::CrateRoot => hir_map::DefPathData::CrateRoot,\n-        DefPathData::Misc => hir_map::DefPathData::Misc,\n-        DefPathData::Impl => hir_map::DefPathData::Impl,\n-        DefPathData::TypeNs => hir_map::DefPathData::TypeNs(name.unwrap()),\n-        DefPathData::ValueNs => hir_map::DefPathData::ValueNs(name.unwrap()),\n-        DefPathData::Module => hir_map::DefPathData::Module(name.unwrap()),\n-        DefPathData::MacroDef => hir_map::DefPathData::MacroDef(name.unwrap()),\n-        DefPathData::ClosureExpr => hir_map::DefPathData::ClosureExpr,\n-        DefPathData::TypeParam => hir_map::DefPathData::TypeParam(name.unwrap()),\n-        DefPathData::LifetimeDef => hir_map::DefPathData::LifetimeDef(name.unwrap()),\n-        DefPathData::EnumVariant => hir_map::DefPathData::EnumVariant(name.unwrap()),\n-        DefPathData::Field => hir_map::DefPathData::Field(name.unwrap()),\n-        DefPathData::StructCtor => hir_map::DefPathData::StructCtor,\n-        DefPathData::Initializer => hir_map::DefPathData::Initializer,\n-        DefPathData::Binding => hir_map::DefPathData::Binding(name.unwrap()),\n-        DefPathData::ImplTrait => hir_map::DefPathData::ImplTrait,\n-    }\n-}"}, {"sha": "3ad9251b0721666d9c5569063ce4983847141032", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 371, "deletions": 698, "changes": 1069, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -16,15 +16,12 @@\n use astencode::encode_inlined_item;\n use common::*;\n use cstore;\n-use decoder;\n-use def_key;\n use index::{self, IndexData};\n \n-use middle::cstore::{InlinedItemRef, LinkMeta, LinkagePreference};\n+use rustc::middle::cstore::{InlinedItemRef, LinkMeta, LinkagePreference};\n use rustc::hir::def;\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n-use middle::dependency_format::Linkage;\n-use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n+use rustc::middle::dependency_format::Linkage;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n \n@@ -41,15 +38,14 @@ use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n-use syntax::ast::{self, NodeId, Name, CRATE_NODE_ID};\n+use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n use syntax;\n use rbml;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::intravisit::Visitor;\n use rustc::hir::intravisit;\n-use rustc::hir::map::DefKey;\n \n use super::index_builder::{FromId, IndexBuilder, Untracked};\n \n@@ -166,59 +162,29 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             Ok(())\n         }).unwrap();\n     }\n-}\n-\n-fn encode_name(ecx: &mut EncodeContext, name: Name) {\n-    ecx.start_tag(item_tag::name);\n-    name.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n-\n-fn encode_def_id(ecx: &mut EncodeContext, def_id: DefId) {\n-    assert!(def_id.is_local());\n-    ecx.start_tag(item_tag::def_index);\n-    def_id.index.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n-\n-fn encode_def_key(ecx: &mut EncodeContext, key: DefKey) {\n-    let simple_key = def_key::simplify_def_key(key);\n-    ecx.start_tag(item_tag::def_key);\n-    simple_key.encode(ecx);\n-    ecx.end_tag();\n-}\n-\n-/// For every DefId that we create a metadata item for, we include a\n-/// serialized copy of its DefKey, which allows us to recreate a path.\n-fn encode_def_id_and_key(ecx: &mut EncodeContext, def_id: DefId) {\n-    encode_def_id(ecx, def_id);\n-    let def_key = ecx.tcx.map.def_key(def_id);\n-    encode_def_key(ecx, def_key);\n-}\n \n-fn encode_trait_ref<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n-                              trait_ref: ty::TraitRef<'tcx>,\n-                              tag: usize) {\n-    ecx.start_tag(tag);\n-    trait_ref.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n+    /// For every DefId that we create a metadata item for, we include a\n+    /// serialized copy of its DefKey, which allows us to recreate a path.\n+    fn encode_def_key(&mut self, def_id: DefId) {\n+        self.start_tag(item_tag::def_key);\n+        self.tcx.map.def_key(def_id).encode(self);\n+        self.end_tag();\n+    }\n \n-// Item info table encoding\n-fn encode_family(ecx: &mut EncodeContext, f: Family) {\n-    ecx.start_tag(item_tag::family);\n-    f.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n+    // Item info table encoding\n+    fn encode_family(&mut self, f: Family) {\n+        self.start_tag(item_tag::family);\n+        f.encode(self).unwrap();\n+        self.end_tag();\n+    }\n \n-fn encode_item_variances(ecx: &mut EncodeContext, id: NodeId) {\n-    let v = ecx.tcx.item_variances(ecx.tcx.map.local_def_id(id));\n-    ecx.start_tag(item_tag::variances);\n-    v.encode(ecx);\n-    ecx.end_tag();\n-}\n+    fn encode_item_variances(&mut self, def_id: DefId) {\n+        let v = self.tcx.item_variances(def_id);\n+        self.start_tag(item_tag::variances);\n+        v.encode(self);\n+        self.end_tag();\n+    }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_bounds_and_type_for_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx;\n         self.encode_bounds_and_type(&tcx.lookup_item_type(def_id),\n@@ -238,37 +204,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.end_tag();\n     }\n \n-    fn encode_disr_val(&mut self,\n-                       disr_val: ty::Disr) {\n-        self.start_tag(item_tag::disr_val);\n-        disr_val.to_u64_unchecked().encode(self).unwrap();\n-        self.end_tag();\n-    }\n-\n-    fn encode_parent_item(&mut self, id: DefId) {\n-        self.start_tag(item_tag::parent_item);\n-        id.encode(self).unwrap();\n-        self.end_tag();\n-    }\n-\n-    fn encode_variant_fields(&mut self,\n-                             variant: ty::VariantDef) {\n-        self.start_tag(item_tag::fields);\n-        self.seq(&variant.fields, |_, f| f.did);\n+    fn encode_variant(&mut self, variant: ty::VariantDef,\n+                      struct_ctor: Option<DefIndex>)\n+                      -> EntryData {\n+        self.start_tag(item_tag::children);\n+        self.seq(&variant.fields, |_, f| {\n+            assert!(f.did.is_local());\n+            f.did.index\n+        });\n         self.end_tag();\n-    }\n-}\n \n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    fn encode_enum_variant_infos(&mut self, enum_did: DefId) {\n-        debug!(\"encode_enum_variant_info(enum_did={:?})\", enum_did);\n-        let def = self.tcx.lookup_adt_def(enum_did);\n-        self.encode_fields(enum_did);\n-        for (i, variant) in def.variants.iter().enumerate() {\n-            self.record(variant.did,\n-                        EncodeContext::encode_enum_variant_info,\n-                        (enum_did, Untracked(i)));\n-        }\n+        EntryData::Variant(VariantData {\n+            kind: variant.kind,\n+            disr: variant.disr_val.to_u64_unchecked(),\n+            struct_ctor: struct_ctor\n+        })\n     }\n }\n \n@@ -285,71 +235,67 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let def = tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n         let vid = variant.did;\n-        encode_def_id_and_key(self, vid);\n-        encode_family(self, Family::Variant(variant.kind));\n-        encode_name(self, variant.name);\n-        self.encode_parent_item(enum_did);\n+        self.encode_def_key(vid);\n+        self.encode_family(Family::Variant);\n \n         let enum_id = tcx.map.as_local_node_id(enum_did).unwrap();\n         let enum_vis = &tcx.map.expect_item(enum_id).vis;\n         self.encode_visibility(enum_vis);\n \n         let attrs = tcx.get_attrs(vid);\n         encode_attributes(self, &attrs);\n-        self.encode_repr_attrs(&attrs);\n+        encode_stability(self, vid);\n+\n+        let data = self.encode_variant(variant, None);\n+\n+        self.start_tag(item_tag::data);\n+        data.encode(self).unwrap();\n+        self.end_tag();\n \n-        let stab = tcx.lookup_stability(vid);\n-        let depr = tcx.lookup_deprecation(vid);\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n+        self.start_tag(item_tag::typed_data);\n+        EntryTypedData::Other.encode(self).unwrap();\n+        self.end_tag();\n \n-        self.encode_variant_fields(variant);\n-        self.encode_disr_val(variant.disr_val);\n         self.encode_bounds_and_type_for_item(vid);\n     }\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_mod(&mut self,\n-                           FromId(id, (md, attrs, name, vis)):\n-                           FromId<(&hir::Mod, &[ast::Attribute], Name, &hir::Visibility)>) {\n+                           FromId(id, (md, attrs, vis)):\n+                           FromId<(&hir::Mod, &[ast::Attribute], &hir::Visibility)>) {\n         let tcx = self.tcx;\n \n-        encode_def_id_and_key(self, tcx.map.local_def_id(id));\n-        encode_family(self, Family::Mod);\n-        encode_name(self, name);\n+        let def_id = tcx.map.local_def_id(id);\n+        self.encode_def_key(def_id);\n+        self.encode_family(Family::Mod);\n+        self.encode_visibility(vis);\n+        encode_stability(self, def_id);\n+        encode_attributes(self, attrs);\n         debug!(\"(encoding info for module) encoding info for module ID {}\", id);\n \n         // Encode info about all the module children.\n         self.start_tag(item_tag::children);\n         self.seq(&md.item_ids, |_, item_id| {\n-            tcx.map.local_def_id(item_id.id)\n+            tcx.map.local_def_id(item_id.id).index\n         });\n-\n-        // Encode the reexports of this module, if this module is public.\n-        match self.reexports.get(&id) {\n-            Some(exports) if *vis == hir::Public => exports.encode(self).unwrap(),\n-            _ => <[def::Export]>::encode(&[], self).unwrap()\n-        }\n         self.end_tag();\n \n-        self.encode_visibility(vis);\n-\n-        let stab = tcx.lookup_stability(tcx.map.local_def_id(id));\n-        let depr = tcx.lookup_deprecation(tcx.map.local_def_id(id));\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n+        // Encode the reexports of this module, if this module is public.\n+        let reexports = match self.reexports.get(&id) {\n+            Some(exports) if *vis == hir::Public => exports.clone(),\n+            _ => vec![]\n+        };\n \n-        encode_attributes(self, attrs);\n-    }\n+        self.start_tag(item_tag::data);\n+        EntryData::Mod(ModData {\n+            reexports: reexports\n+        }).encode(self).unwrap();\n+        self.end_tag();\n \n-    fn encode_struct_field_family(&mut self,\n-                                  visibility: ty::Visibility) {\n-        encode_family(self, if visibility.is_public() {\n-            Family::PublicField\n-        } else {\n-            Family::InheritedField\n-        });\n+        self.start_tag(item_tag::typed_data);\n+        EntryTypedData::Other.encode(self).unwrap();\n+        self.end_tag();\n     }\n \n     fn encode_visibility<T: HasVisibility>(&mut self, visibility: T) {\n@@ -380,18 +326,6 @@ impl HasVisibility for ty::Visibility {\n     }\n }\n \n-fn encode_constness(ecx: &mut EncodeContext, constness: hir::Constness) {\n-    ecx.start_tag(item_tag::constness);\n-    constness.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n-\n-fn encode_defaultness(ecx: &mut EncodeContext, defaultness: hir::Defaultness) {\n-    ecx.start_tag(item_tag::defaultness);\n-    defaultness.encode(ecx).unwrap();\n-    ecx.end_tag();\n-}\n-\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_fields(&mut self,\n                      adt_def_id: DefId) {\n@@ -424,48 +358,23 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let nm = field.name;\n         debug!(\"encode_field: encoding {} {:?}\", nm, field.did);\n \n-        self.encode_struct_field_family(field.vis);\n-        encode_name(self, nm);\n+        self.encode_family(Family::Field);\n+        self.encode_visibility(field.vis);\n         self.encode_bounds_and_type_for_item(field.did);\n-        encode_def_id_and_key(self, field.did);\n+        self.encode_def_key(field.did);\n \n         let variant_id = tcx.map.as_local_node_id(variant.did).unwrap();\n         let variant_data = tcx.map.expect_variant_data(variant_id);\n         encode_attributes(self, &variant_data.fields()[field_index].attrs);\n-\n-        let stab = tcx.lookup_stability(field.did);\n-        let depr = tcx.lookup_deprecation(field.did);\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n+        encode_stability(self, field.did);\n     }\n \n-    fn encode_struct_ctor(&mut self,\n-                          (struct_def_id, struct_node_id, ctor_node_id):\n-                          (DefId, ast::NodeId, ast::NodeId)) {\n-        let tcx = self.tcx;\n-        let def = tcx.lookup_adt_def(struct_def_id);\n-        let variant = def.struct_variant();\n-        let item = tcx.map.expect_item(struct_node_id);\n-        let ctor_def_id = tcx.map.local_def_id(ctor_node_id);\n-        encode_def_id_and_key(self, ctor_def_id);\n-        encode_family(self, Family::Struct(variant.kind));\n+    fn encode_struct_ctor(&mut self, ctor_def_id: DefId) {\n+        self.encode_def_key(ctor_def_id);\n+        self.encode_family(Family::Struct);\n         self.encode_bounds_and_type_for_item(ctor_def_id);\n-        encode_name(self, item.name);\n-        self.encode_parent_item(struct_def_id);\n-\n-        let stab = tcx.lookup_stability(ctor_def_id);\n-        let depr = tcx.lookup_deprecation(ctor_def_id);\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n-\n-        // indicate that this is a tuple struct ctor, because\n-        // downstream users will normally want the tuple struct\n-        // definition, but without this there is no way for them\n-        // to tell that they actually have a ctor rather than a\n-        // normal function\n-        self.start_tag(item_tag::is_tuple_struct_ctor);\n-        true.encode(self).unwrap();\n-        self.end_tag();\n+\n+        encode_stability(self, ctor_def_id);\n     }\n \n     fn encode_generics(&mut self,\n@@ -489,215 +398,137 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.end_tag();\n     }\n \n-    fn encode_method_ty_fields(&mut self, method_ty: &ty::Method<'tcx>) {\n-        encode_def_id_and_key(self, method_ty.def_id);\n-        encode_name(self, method_ty.name);\n-        self.encode_generics(&method_ty.generics, &method_ty.predicates);\n-        self.encode_visibility(method_ty.vis);\n-\n-        self.start_tag(item_tag::trait_method_explicit_self);\n-        method_ty.explicit_self.encode(self).unwrap();\n-        self.end_tag();\n-\n-        encode_family(self, Family::Method);\n-    }\n-\n-    fn encode_info_for_trait_item(&mut self,\n-                                  (trait_def_id, item_def_id, trait_item):\n-                                  (DefId, DefId, &hir::TraitItem)) {\n+    fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx;\n \n-        self.encode_parent_item(trait_def_id);\n-\n-        let stab = tcx.lookup_stability(item_def_id);\n-        let depr = tcx.lookup_deprecation(item_def_id);\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n+        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+        let ast_item = tcx.map.expect_trait_item(node_id);\n+        let trait_item = tcx.impl_or_trait_item(def_id);\n+        let (family, has_default, typed_data) = match trait_item {\n+            ty::ConstTraitItem(ref associated_const) => {\n+                self.encode_bounds_and_type_for_item(def_id);\n \n-        match tcx.impl_or_trait_item(item_def_id) {\n-            ty::ConstTraitItem(associated_const) => {\n-                encode_name(self, associated_const.name);\n-                encode_def_id_and_key(self, item_def_id);\n-                self.encode_visibility(associated_const.vis);\n+                let trait_def_id = trait_item.container().id();\n+                encode_inlined_item(self,\n+                                    InlinedItemRef::TraitItem(trait_def_id, ast_item));\n \n-                encode_family(self, Family::AssociatedConst);\n-                self.encode_bounds_and_type_for_item(item_def_id);\n+                (Family::AssociatedConst,\n+                associated_const.has_value,\n+                 EntryTypedData::Other)\n             }\n-            ty::MethodTraitItem(method_ty) => {\n-                self.encode_method_ty_fields(&method_ty);\n-                self.encode_bounds_and_type_for_item(item_def_id);\n-            }\n-            ty::TypeTraitItem(associated_type) => {\n-                encode_name(self, associated_type.name);\n-                encode_def_id_and_key(self, item_def_id);\n-                encode_family(self, Family::AssociatedType);\n+            ty::MethodTraitItem(ref method_ty) => {\n+                self.encode_bounds_and_type_for_item(def_id);\n \n+                (Family::Method,\n+                 method_ty.has_body,\n+                 EntryTypedData::Method(MethodTypedData {\n+                    explicit_self: method_ty.explicit_self\n+                 }))\n+            }\n+            ty::TypeTraitItem(ref associated_type) => {\n                 if let Some(ty) = associated_type.ty {\n                     self.encode_type(ty);\n                 }\n+\n+                (Family::AssociatedType, false, EntryTypedData::Other)\n             }\n-        }\n+        };\n \n-        encode_attributes(self, &trait_item.attrs);\n-        match trait_item.node {\n-            hir::ConstTraitItem(_, ref default) => {\n-                self.start_tag(item_tag::trait_item_has_body);\n-                default.is_some().encode(self).unwrap();\n-                self.end_tag();\n+        self.encode_def_key(def_id);\n+        self.encode_family(family);\n+        self.encode_visibility(trait_item.vis());\n \n-                encode_inlined_item(self,\n-                                    InlinedItemRef::TraitItem(trait_def_id, trait_item));\n-                self.encode_mir(item_def_id);\n-            }\n-            hir::MethodTraitItem(ref sig, ref body) => {\n-                self.start_tag(item_tag::trait_item_has_body);\n-                body.is_some().encode(self).unwrap();\n-                self.end_tag();\n+        encode_stability(self, def_id);\n+        encode_attributes(self, &ast_item.attrs);\n+        if let hir::MethodTraitItem(ref sig, _) = ast_item.node {\n+            self.encode_fn_arg_names(&sig.decl);\n+        };\n \n-                self.encode_mir(item_def_id);\n-                self.encode_method_argument_names(&sig.decl);\n-            }\n+        self.start_tag(item_tag::data);\n+        EntryData::TraitAssociated(TraitAssociatedData {\n+            has_default: has_default\n+        }).encode(self).unwrap();\n+        self.end_tag();\n \n-            hir::TypeTraitItem(..) => {}\n-        }\n+        self.start_tag(item_tag::typed_data);\n+        typed_data.encode(self).unwrap();\n+        self.end_tag();\n+\n+        self.encode_mir(def_id);\n     }\n \n-    fn encode_info_for_impl_item(&mut self,\n-                                 (impl_id, impl_item_def_id, ast_item):\n-                                 (NodeId, DefId, Option<&hir::ImplItem>)) {\n-        match self.tcx.impl_or_trait_item(impl_item_def_id) {\n-            ty::ConstTraitItem(ref associated_const) => {\n-                self.encode_info_for_associated_const(&associated_const,\n-                                                      impl_id,\n-                                                      ast_item)\n+    fn encode_info_for_impl_item(&mut self, def_id: DefId) {\n+        let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n+        let ast_item = self.tcx.map.expect_impl_item(node_id);\n+        let impl_item = self.tcx.impl_or_trait_item(def_id);\n+        let impl_def_id = impl_item.container().id();\n+        let (family, typed_data) = match impl_item {\n+            ty::ConstTraitItem(_) => {\n+                self.encode_bounds_and_type_for_item(def_id);\n+\n+                encode_inlined_item(self,\n+                                    InlinedItemRef::ImplItem(impl_def_id, ast_item));\n+                self.encode_mir(def_id);\n+\n+                (Family::AssociatedConst, EntryTypedData::Other)\n             }\n             ty::MethodTraitItem(ref method_type) => {\n-                self.encode_info_for_method(&method_type,\n-                                            impl_id,\n-                                            ast_item)\n+                self.encode_bounds_and_type_for_item(def_id);\n+\n+                (Family::Method,\n+                 EntryTypedData::Method(MethodTypedData {\n+                    explicit_self: method_type.explicit_self\n+                 }))\n             }\n             ty::TypeTraitItem(ref associated_type) => {\n-                self.encode_info_for_associated_type(&associated_type,\n-                                                     impl_id,\n-                                                     ast_item)\n-            }\n-        }\n-    }\n+                if let Some(ty) = associated_type.ty {\n+                    self.encode_type(ty);\n+                }\n \n-    fn encode_info_for_associated_const(&mut self,\n-                                        associated_const: &ty::AssociatedConst,\n-                                        parent_id: NodeId,\n-                                        impl_item_opt: Option<&hir::ImplItem>) {\n-        let tcx = self.tcx;\n-        debug!(\"encode_info_for_associated_const({:?},{:?})\",\n-               associated_const.def_id,\n-               associated_const.name);\n+                (Family::AssociatedType, EntryTypedData::Other)\n+            }\n+        };\n \n-        encode_def_id_and_key(self, associated_const.def_id);\n-        encode_name(self, associated_const.name);\n-        self.encode_visibility(associated_const.vis);\n-        encode_family(self, Family::AssociatedConst);\n+        self.encode_def_key(def_id);\n+        self.encode_family(family);\n+        self.encode_visibility(impl_item.vis());\n+        encode_attributes(self, &ast_item.attrs);\n+        encode_stability(self, def_id);\n+\n+        let constness = if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n+            if sig.constness == hir::Constness::Const {\n+                encode_inlined_item(\n+                    self,\n+                    InlinedItemRef::ImplItem(impl_def_id, ast_item));\n+            }\n \n-        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n+            let generics = self.tcx.lookup_generics(def_id);\n+            let types = generics.parent_types as usize + generics.types.len();\n+            let needs_inline = types > 0 || attr::requests_inline(&ast_item.attrs);\n+            if needs_inline || sig.constness == hir::Constness::Const {\n+                self.encode_mir(def_id);\n+            }\n+            self.encode_fn_arg_names(&sig.decl);\n+            sig.constness\n+        } else {\n+            hir::Constness::NotConst\n+        };\n \n-        self.start_tag(item_tag::trait_item_has_body);\n-        true.encode(self).unwrap();\n+        self.start_tag(item_tag::data);\n+        EntryData::ImplAssociated(ImplAssociatedData {\n+            defaultness: ast_item.defaultness,\n+            constness:constness\n+        }).encode(self).unwrap();\n         self.end_tag();\n \n-        self.encode_bounds_and_type_for_item(associated_const.def_id);\n-\n-        let stab = tcx.lookup_stability(associated_const.def_id);\n-        let depr = tcx.lookup_deprecation(associated_const.def_id);\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n-\n-        if let Some(ii) = impl_item_opt {\n-            encode_attributes(self, &ii.attrs);\n-            encode_defaultness(self, ii.defaultness);\n-            encode_inlined_item(self,\n-                                InlinedItemRef::ImplItem(tcx.map.local_def_id(parent_id),\n-                                                         ii));\n-            self.encode_mir(associated_const.def_id);\n-        }\n-    }\n-\n-    fn encode_info_for_method(&mut self,\n-                              m: &ty::Method<'tcx>,\n-                              parent_id: NodeId,\n-                              impl_item_opt: Option<&hir::ImplItem>) {\n-        let tcx = self.tcx;\n-\n-        debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n-               m.name);\n-        self.encode_method_ty_fields(m);\n-        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n-\n-        self.start_tag(item_tag::trait_item_has_body);\n-        true.encode(self).unwrap();\n+        self.start_tag(item_tag::typed_data);\n+        typed_data.encode(self).unwrap();\n         self.end_tag();\n-\n-        let stab = tcx.lookup_stability(m.def_id);\n-        let depr = tcx.lookup_deprecation(m.def_id);\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n-\n-        self.encode_bounds_and_type_for_item(m.def_id);\n-\n-        if let Some(impl_item) = impl_item_opt {\n-            if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                encode_attributes(self, &impl_item.attrs);\n-                let generics = tcx.lookup_generics(m.def_id);\n-                let types = generics.parent_types as usize + generics.types.len();\n-                let needs_inline = types > 0 || attr::requests_inline(&impl_item.attrs);\n-                if sig.constness == hir::Constness::Const {\n-                    encode_inlined_item(\n-                        self,\n-                        InlinedItemRef::ImplItem(tcx.map.local_def_id(parent_id),\n-                                                 impl_item));\n-                }\n-                if needs_inline || sig.constness == hir::Constness::Const {\n-                    self.encode_mir(m.def_id);\n-                }\n-                encode_constness(self, sig.constness);\n-                encode_defaultness(self, impl_item.defaultness);\n-                self.encode_method_argument_names(&sig.decl);\n-            }\n-        }\n-    }\n-\n-    fn encode_info_for_associated_type(&mut self,\n-                                       associated_type: &ty::AssociatedType<'tcx>,\n-                                       parent_id: NodeId,\n-                                       impl_item_opt: Option<&hir::ImplItem>) {\n-        let tcx = self.tcx;\n-        debug!(\"encode_info_for_associated_type({:?},{:?})\",\n-               associated_type.def_id,\n-               associated_type.name);\n-\n-        encode_def_id_and_key(self, associated_type.def_id);\n-        encode_name(self, associated_type.name);\n-        self.encode_visibility(associated_type.vis);\n-        encode_family(self, Family::AssociatedType);\n-        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n-\n-        let stab = tcx.lookup_stability(associated_type.def_id);\n-        let depr = tcx.lookup_deprecation(associated_type.def_id);\n-        encode_stability(self, stab);\n-        encode_deprecation(self, depr);\n-\n-        if let Some(ii) = impl_item_opt {\n-            encode_attributes(self, &ii.attrs);\n-            encode_defaultness(self, ii.defaultness);\n-        }\n-\n-        if let Some(ty) = associated_type.ty {\n-            self.encode_type(ty);\n-        }\n     }\n \n-    fn encode_method_argument_names(&mut self,\n+    fn encode_fn_arg_names(&mut self,\n                                     decl: &hir::FnDecl) {\n-        self.start_tag(item_tag::method_argument_names);\n+        self.start_tag(item_tag::fn_arg_names);\n \n         self.seq(&decl.inputs, |_, arg| {\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n@@ -710,18 +541,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.end_tag();\n     }\n \n-    fn encode_repr_attrs(&mut self,\n-                         attrs: &[ast::Attribute]) {\n-        let mut repr_attrs = Vec::new();\n-        for attr in attrs {\n-            repr_attrs.extend(attr::find_repr_attrs(self.tcx.sess.diagnostic(),\n-                                                    attr));\n-        }\n-        self.start_tag(item_tag::repr);\n-        repr_attrs.encode(self);\n-        self.end_tag();\n-    }\n-\n     fn encode_mir(&mut self, def_id: DefId) {\n         if let Some(mir) = self.mir_map.map.get(&def_id) {\n             self.start_tag(item_tag::mir as usize);\n@@ -742,16 +561,13 @@ fn encode_inherent_implementations(ecx: &mut EncodeContext,\n     ecx.end_tag();\n }\n \n-fn encode_stability(ecx: &mut EncodeContext, stab_opt: Option<&attr::Stability>) {\n-    stab_opt.map(|stab| {\n+fn encode_stability(ecx: &mut EncodeContext, def_id: DefId) {\n+    ecx.tcx.lookup_stability(def_id).map(|stab| {\n         ecx.start_tag(item_tag::stability);\n         stab.encode(ecx).unwrap();\n         ecx.end_tag();\n     });\n-}\n-\n-fn encode_deprecation(ecx: &mut EncodeContext, depr_opt: Option<attr::Deprecation>) {\n-    depr_opt.map(|depr| {\n+    ecx.tcx.lookup_deprecation(def_id).map(|depr| {\n         ecx.start_tag(item_tag::deprecation);\n         depr.encode(ecx).unwrap();\n         ecx.end_tag();\n@@ -794,272 +610,199 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         debug!(\"encoding info for item at {}\",\n                tcx.sess.codemap().span_to_string(item.span));\n \n-        let vis = &item.vis;\n-\n-        let (stab, depr) = tcx.dep_graph.with_task(DepNode::MetaData(def_id), || {\n-            (tcx.lookup_stability(tcx.map.local_def_id(item.id)),\n-             tcx.lookup_deprecation(tcx.map.local_def_id(item.id)))\n-        });\n-\n-        match item.node {\n+        let (family, data, typed_data) = match item.node {\n             hir::ItemStatic(_, m, _) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, if m == hir::MutMutable {\n-                    Family::MutStatic\n-                } else {\n-                    Family::ImmStatic\n-                });\n                 self.encode_bounds_and_type_for_item(def_id);\n-                encode_name(self, item.name);\n-                self.encode_visibility(vis);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n-                encode_attributes(self, &item.attrs);\n+\n+                if m == hir::MutMutable {\n+                    (Family::MutStatic, EntryData::Other, EntryTypedData::Other)\n+                } else {\n+                    (Family::ImmStatic, EntryData::Other, EntryTypedData::Other)\n+                }\n             }\n             hir::ItemConst(..) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Const);\n                 self.encode_bounds_and_type_for_item(def_id);\n-                encode_name(self, item.name);\n-                encode_attributes(self, &item.attrs);\n                 encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n                 self.encode_mir(def_id);\n-                self.encode_visibility(vis);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n+\n+                (Family::Const, EntryData::Other, EntryTypedData::Other)\n             }\n             hir::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Fn);\n                 let tps_len = generics.ty_params.len();\n                 self.encode_bounds_and_type_for_item(def_id);\n-                encode_name(self, item.name);\n-                encode_attributes(self, &item.attrs);\n                 let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n                 if constness == hir::Constness::Const {\n                     encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n                 }\n                 if needs_inline || constness == hir::Constness::Const {\n                     self.encode_mir(def_id);\n                 }\n-                encode_constness(self, constness);\n-                self.encode_visibility(vis);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n-                self.encode_method_argument_names(&decl);\n+                self.encode_fn_arg_names(&decl);\n+\n+                (Family::Fn, EntryData::Fn(FnData {\n+                    constness: constness\n+                 }), EntryTypedData::Other)\n             }\n             hir::ItemMod(ref m) => {\n-                self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, item.name, &item.vis)));\n+                self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, &item.vis)));\n+                return;\n             }\n             hir::ItemForeignMod(ref fm) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::ForeignMod);\n-                encode_name(self, item.name);\n-\n                 // Encode all the items in self module.\n                 self.start_tag(item_tag::children);\n                 self.seq(&fm.items, |_, foreign_item| {\n-                    tcx.map.local_def_id(foreign_item.id)\n+                    tcx.map.local_def_id(foreign_item.id).index\n                 });\n-                <[def::Export]>::encode(&[], self).unwrap();\n                 self.end_tag();\n \n-                self.encode_visibility(vis);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n+                (Family::ForeignMod, EntryData::Other, EntryTypedData::Other)\n             }\n             hir::ItemTy(..) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Type);\n                 self.encode_bounds_and_type_for_item(def_id);\n-                encode_name(self, item.name);\n-                self.encode_visibility(vis);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n+\n+                (Family::Type, EntryData::Other, EntryTypedData::Other)\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Enum);\n-                encode_item_variances(self, item.id);\n+                self.encode_item_variances(def_id);\n                 self.encode_bounds_and_type_for_item(def_id);\n-                encode_name(self, item.name);\n-                encode_attributes(self, &item.attrs);\n-                self.encode_repr_attrs(&item.attrs);\n \n                 self.start_tag(item_tag::children);\n                 self.seq(&enum_definition.variants, |_, v| {\n-                    tcx.map.local_def_id(v.node.data.id())\n+                    tcx.map.local_def_id(v.node.data.id()).index\n                 });\n-                <[def::Export]>::encode(&[], self).unwrap();\n                 self.end_tag();\n \n                 // Encode inherent implementations for self enumeration.\n                 encode_inherent_implementations(self, def_id);\n \n-                self.encode_visibility(vis);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n+                (Family::Enum, EntryData::Other, EntryTypedData::Other)\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n-                /* Index the class*/\n                 let def = tcx.lookup_adt_def(def_id);\n                 let variant = def.struct_variant();\n \n-                /* Now, make an item for the class itself */\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Struct(variant.kind));\n                 self.encode_bounds_and_type_for_item(def_id);\n \n-                encode_item_variances(self, item.id);\n-                encode_name(self, item.name);\n-                encode_attributes(self, &item.attrs);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n-                self.encode_visibility(vis);\n-                self.encode_repr_attrs(&item.attrs);\n+                self.encode_item_variances(def_id);\n \n                 /* Encode def_ids for each field and method\n                 for methods, write all the stuff get_trait_method\n                 needs to know*/\n-                self.encode_variant_fields(variant);\n+                let struct_ctor = if !struct_def.is_struct() {\n+                    Some(tcx.map.local_def_id(struct_def.id()).index)\n+                } else {\n+                    None\n+                };\n+                let data = self.encode_variant(variant, struct_ctor);\n \n                 // Encode inherent implementations for self structure.\n                 encode_inherent_implementations(self, def_id);\n \n-                if !struct_def.is_struct() {\n-                    let ctor_did = tcx.map.local_def_id(struct_def.id());\n-                    self.start_tag(item_tag::struct_ctor);\n-                    ctor_did.encode(self).unwrap();\n-                    self.end_tag();\n-                }\n+                (Family::Struct, data, EntryTypedData::Other)\n             }\n             hir::ItemUnion(..) => {\n-                let def = self.tcx.lookup_adt_def(def_id);\n-                let variant = def.struct_variant();\n-\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Union);\n                 self.encode_bounds_and_type_for_item(def_id);\n \n-                encode_item_variances(self, item.id);\n-                encode_name(self, item.name);\n-                encode_attributes(self, &item.attrs);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n-                self.encode_visibility(vis);\n-                self.encode_repr_attrs(&item.attrs);\n+                self.encode_item_variances(def_id);\n \n                 /* Encode def_ids for each field and method\n                 for methods, write all the stuff get_trait_method\n                 needs to know*/\n-                self.encode_variant_fields(variant);\n-\n-                encode_inlined_item(self, InlinedItemRef::Item(def_id, item));\n-                self.encode_mir(def_id);\n+                let def = self.tcx.lookup_adt_def(def_id);\n+                let data = self.encode_variant(def.struct_variant(), None);\n \n                 // Encode inherent implementations for self union.\n                 encode_inherent_implementations(self, def_id);\n+\n+                (Family::Union, data, EntryTypedData::Other)\n             }\n             hir::ItemDefaultImpl(..) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::DefaultImpl);\n-                encode_name(self, item.name);\n-\n-                let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(item.id)).unwrap();\n-                encode_trait_ref(self, trait_ref, item_tag::trait_ref);\n+                (Family::DefaultImpl, EntryData::Other,\n+                 EntryTypedData::Impl(ImplTypedData {\n+                    trait_ref: tcx.impl_trait_ref(def_id)\n+                 }))\n             }\n             hir::ItemImpl(_, polarity, ..) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Impl);\n                 self.encode_bounds_and_type_for_item(def_id);\n-                encode_name(self, item.name);\n-                encode_attributes(self, &item.attrs);\n-\n-                self.start_tag(item_tag::polarity);\n-                polarity.encode(self).unwrap();\n-                self.end_tag();\n \n-                match\n-                    tcx.custom_coerce_unsized_kinds\n-                       .borrow()\n-                       .get(&tcx.map.local_def_id(item.id))\n-                {\n-                    Some(&kind) => {\n-                        self.start_tag(item_tag::impl_coerce_unsized_kind);\n-                        kind.encode(self);\n-                        self.end_tag();\n-                    }\n-                    None => {}\n-                }\n+                let trait_ref = tcx.impl_trait_ref(def_id);\n+                let parent = if let Some(trait_ref) = trait_ref {\n+                    let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+                    trait_def.ancestors(def_id).skip(1).next().and_then(|node| {\n+                        match node {\n+                            specialization_graph::Node::Impl(parent) => Some(parent),\n+                            _ => None,\n+                        }\n+                    })\n+                } else {\n+                    None\n+                };\n \n                 self.start_tag(item_tag::children);\n-                tcx.impl_or_trait_items(def_id).encode(self).unwrap();\n-                <[def::Export]>::encode(&[], self).unwrap();\n+                self.seq(&tcx.impl_or_trait_items(def_id)[..], |_, &def_id| {\n+                    assert!(def_id.is_local());\n+                    def_id.index\n+                });\n                 self.end_tag();\n \n-                let did = tcx.map.local_def_id(item.id);\n-                if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n-                    encode_trait_ref(self, trait_ref, item_tag::trait_ref);\n-\n-                    let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n-                    let parent = trait_def.ancestors(did)\n-                                          .skip(1)\n-                                          .next()\n-                                          .and_then(|node| match node {\n-                                              specialization_graph::Node::Impl(parent) =>\n-                                                  Some(parent),\n-                                              _ => None,\n-                                          });\n-                    parent.map(|parent| {\n-                        self.start_tag(item_tag::parent_impl);\n-                        parent.encode(self).unwrap();\n-                        self.end_tag();\n-                    });\n-                }\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n+                (Family::Impl,\n+                 EntryData::Impl(ImplData {\n+                    polarity: polarity,\n+                    parent_impl: parent,\n+                    coerce_unsized_kind: tcx.custom_coerce_unsized_kinds.borrow()\n+                                            .get(&def_id).cloned()\n+                 }),\n+                 EntryTypedData::Impl(ImplTypedData {\n+                    trait_ref: trait_ref\n+                 }))\n             }\n             hir::ItemTrait(..) => {\n-                encode_def_id_and_key(self, def_id);\n-                encode_family(self, Family::Trait);\n-                encode_item_variances(self, item.id);\n+                self.encode_item_variances(def_id);\n                 let trait_def = tcx.lookup_trait_def(def_id);\n                 let trait_predicates = tcx.lookup_predicates(def_id);\n \n-                self.start_tag(item_tag::unsafety);\n-                trait_def.unsafety.encode(self).unwrap();\n-                self.end_tag();\n-\n-                self.start_tag(item_tag::paren_sugar);\n-                trait_def.paren_sugar.encode(self).unwrap();\n-                self.end_tag();\n-\n-                self.start_tag(item_tag::defaulted_trait);\n-                tcx.trait_has_default_impl(def_id).encode(self).unwrap();\n-                self.end_tag();\n-\n                 self.encode_generics(&trait_def.generics, &trait_predicates);\n                 self.encode_predicates(&tcx.lookup_super_predicates(def_id),\n                                        item_tag::super_predicates);\n-                encode_trait_ref(self, trait_def.trait_ref, item_tag::trait_ref);\n-                encode_name(self, item.name);\n-                encode_attributes(self, &item.attrs);\n-                self.encode_visibility(vis);\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n \n                 self.start_tag(item_tag::children);\n-                tcx.impl_or_trait_items(def_id).encode(self).unwrap();\n-                <[def::Export]>::encode(&[], self).unwrap();\n+                self.seq(&tcx.impl_or_trait_items(def_id)[..], |_, &def_id| {\n+                    assert!(def_id.is_local());\n+                    def_id.index\n+                });\n                 self.end_tag();\n \n                 // Encode inherent implementations for self trait.\n                 encode_inherent_implementations(self, def_id);\n+\n+                (Family::Trait,\n+                 EntryData::Trait(TraitData {\n+                    unsafety: trait_def.unsafety,\n+                    paren_sugar: trait_def.paren_sugar,\n+                    has_default_impl: tcx.trait_has_default_impl(def_id)\n+                 }),\n+                 EntryTypedData::Trait(TraitTypedData {\n+                    trait_ref: trait_def.trait_ref\n+                 }))\n             }\n             hir::ItemExternCrate(_) | hir::ItemUse(_) => {\n                 bug!(\"cannot encode info for item {:?}\", item)\n             }\n-        }\n+        };\n+\n+        self.encode_family(family);\n+        self.encode_def_key(def_id);\n+        self.encode_visibility(&item.vis);\n+        encode_attributes(self, &item.attrs);\n+        encode_stability(self, def_id);\n+\n+        self.start_tag(item_tag::data);\n+        data.encode(self).unwrap();\n+        self.end_tag();\n+\n+        self.start_tag(item_tag::typed_data);\n+        typed_data.encode(self).unwrap();\n+        self.end_tag();\n     }\n }\n \n@@ -1084,88 +827,52 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 // no sub-item recording needed in these cases\n             }\n             hir::ItemEnum(..) => {\n-                self.encode_enum_variant_infos(def_id);\n+                self.encode_fields(def_id);\n+\n+                let def = self.tcx.lookup_adt_def(def_id);\n+                for (i, variant) in def.variants.iter().enumerate() {\n+                    self.record(variant.did,\n+                                EncodeContext::encode_enum_variant_info,\n+                                (def_id, Untracked(i)));\n+                }\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n-                self.encode_addl_struct_info(def_id, struct_def.id(), item);\n+                self.encode_fields(def_id);\n+\n+                // If this is a tuple-like struct, encode the type of the constructor.\n+                match self.tcx.lookup_adt_def(def_id).struct_variant().kind {\n+                    ty::VariantKind::Struct => {\n+                        // no value for structs like struct Foo { ... }\n+                    }\n+                    ty::VariantKind::Tuple | ty::VariantKind::Unit => {\n+                        // there is a value for structs like `struct\n+                        // Foo()` and `struct Foo`\n+                        let ctor_def_id = self.tcx.map.local_def_id(struct_def.id());\n+                        self.record(ctor_def_id,\n+                                    EncodeContext::encode_struct_ctor,\n+                                    ctor_def_id);\n+                    }\n+                }\n             }\n             hir::ItemUnion(..) => {\n-                self.encode_addl_union_info(def_id);\n-            }\n-            hir::ItemImpl(.., ref ast_items) => {\n-                self.encode_addl_impl_info(def_id, item.id, ast_items);\n+                self.encode_fields(def_id);\n             }\n-            hir::ItemTrait(.., ref trait_items) => {\n-                self.encode_addl_trait_info(def_id, trait_items);\n-            }\n-        }\n-    }\n-\n-    fn encode_addl_struct_info(&mut self,\n-                               def_id: DefId,\n-                               struct_node_id: ast::NodeId,\n-                               item: &hir::Item) {\n-        let def = self.tcx.lookup_adt_def(def_id);\n-        let variant = def.struct_variant();\n-\n-        self.encode_fields(def_id);\n-\n-        // If this is a tuple-like struct, encode the type of the constructor.\n-        match variant.kind {\n-            ty::VariantKind::Struct => {\n-                // no value for structs like struct Foo { ... }\n+            hir::ItemImpl(..) => {\n+                for &trait_item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                    self.record(trait_item_def_id,\n+                                EncodeContext::encode_info_for_impl_item,\n+                                trait_item_def_id);\n+                }\n             }\n-            ty::VariantKind::Tuple | ty::VariantKind::Unit => {\n-                // there is a value for structs like `struct\n-                // Foo()` and `struct Foo`\n-                let ctor_def_id = self.tcx.map.local_def_id(struct_node_id);\n-                self.record(ctor_def_id,\n-                            EncodeContext::encode_struct_ctor,\n-                            (def_id, item.id, struct_node_id));\n+            hir::ItemTrait(..) => {\n+                for &item_def_id in &self.tcx.impl_or_trait_items(def_id)[..] {\n+                    self.record(item_def_id,\n+                                EncodeContext::encode_info_for_trait_item,\n+                                item_def_id);\n+                }\n             }\n         }\n     }\n-\n-    fn encode_addl_union_info(&mut self, def_id: DefId) {\n-        self.encode_fields(def_id);\n-    }\n-\n-    fn encode_addl_impl_info(&mut self,\n-                             def_id: DefId,\n-                             impl_id: ast::NodeId,\n-                             ast_items: &[hir::ImplItem]) {\n-        let items = self.tcx.impl_or_trait_items(def_id);\n-\n-        // Iterate down the trait items, emitting them. We rely on the\n-        // assumption that all of the actually implemented trait items\n-        // appear first in the impl structure, in the same order they do\n-        // in the ast. This is a little sketchy.\n-        let num_implemented_methods = ast_items.len();\n-        for (i, &trait_item_def_id) in items.iter().enumerate() {\n-            let ast_item = if i < num_implemented_methods {\n-                Some(&ast_items[i])\n-            } else {\n-                None\n-            };\n-\n-            self.record(trait_item_def_id,\n-                        EncodeContext::encode_info_for_impl_item,\n-                        (impl_id, trait_item_def_id, ast_item));\n-        }\n-    }\n-\n-    fn encode_addl_trait_info(&mut self,\n-                              def_id: DefId,\n-                              trait_items: &[hir::TraitItem]) {\n-        // Now output the trait item info for each trait item.\n-        let r = self.tcx.impl_or_trait_items(def_id);\n-        for (&item_def_id, trait_item) in r.iter().zip(trait_items) {\n-            assert!(item_def_id.is_local());\n-            self.record(item_def_id,\n-                        EncodeContext::encode_info_for_trait_item,\n-                        (def_id, item_def_id, trait_item));\n-        }\n-    }\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n@@ -1175,37 +882,30 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         debug!(\"writing foreign item {}\", tcx.node_path_str(nitem.id));\n \n-        encode_def_id_and_key(self, def_id);\n-        let parent_id = tcx.map.get_parent(nitem.id);\n-        self.encode_parent_item(tcx.map.local_def_id(parent_id));\n+        self.encode_def_key(def_id);\n         self.encode_visibility(&nitem.vis);\n-        match nitem.node {\n+        self.encode_bounds_and_type_for_item(def_id);\n+        let family = match nitem.node {\n             hir::ForeignItemFn(ref fndecl, _) => {\n-                encode_family(self, Family::Fn);\n-                self.encode_bounds_and_type_for_item(def_id);\n-                encode_name(self, nitem.name);\n-                encode_attributes(self, &nitem.attrs);\n-                let stab = tcx.lookup_stability(tcx.map.local_def_id(nitem.id));\n-                let depr = tcx.lookup_deprecation(tcx.map.local_def_id(nitem.id));\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n-                self.encode_method_argument_names(&fndecl);\n-            }\n-            hir::ForeignItemStatic(_, mutbl) => {\n-                encode_family(self, if mutbl {\n-                    Family::MutStatic\n-                } else {\n-                    Family::ImmStatic\n-                });\n-                self.encode_bounds_and_type_for_item(def_id);\n-                encode_attributes(self, &nitem.attrs);\n-                let stab = tcx.lookup_stability(tcx.map.local_def_id(nitem.id));\n-                let depr = tcx.lookup_deprecation(tcx.map.local_def_id(nitem.id));\n-                encode_stability(self, stab);\n-                encode_deprecation(self, depr);\n-                encode_name(self, nitem.name);\n+                self.encode_fn_arg_names(&fndecl);\n+\n+                Family::ForeignFn\n             }\n-        }\n+            hir::ForeignItemStatic(_, true) => Family::ForeignMutStatic,\n+            hir::ForeignItemStatic(_, false) => Family::ForeignImmStatic\n+        };\n+        self.encode_family(family);\n+\n+        self.start_tag(item_tag::data);\n+        EntryData::Other.encode(self).unwrap();\n+        self.end_tag();\n+\n+        self.start_tag(item_tag::typed_data);\n+        EntryTypedData::Other.encode(self).unwrap();\n+        self.end_tag();\n+\n+        encode_attributes(self, &nitem.attrs);\n+        encode_stability(self, def_id);\n     }\n }\n \n@@ -1267,21 +967,25 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) {\n-        encode_def_id_and_key(self, def_id);\n+        self.encode_def_key(def_id);\n         self.encode_bounds_and_type_for_item(def_id);\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) {\n         let tcx = self.tcx;\n-        encode_def_id_and_key(self, def_id);\n-        encode_name(self, syntax::parse::token::intern(\"<closure>\"));\n+        self.encode_def_key(def_id);\n+        self.encode_family(Family::Closure);\n \n-        self.start_tag(item_tag::closure_ty);\n-        tcx.tables.borrow().closure_tys[&def_id].encode(self).unwrap();\n+        self.start_tag(item_tag::data);\n+        EntryData::Closure(ClosureData {\n+            kind: tcx.closure_kind(def_id)\n+        }).encode(self).unwrap();\n         self.end_tag();\n \n-        self.start_tag(item_tag::closure_kind);\n-        tcx.closure_kind(def_id).encode(self).unwrap();\n+        self.start_tag(item_tag::typed_data);\n+        EntryTypedData::Closure(ClosureTypedData {\n+            ty: tcx.tables.borrow().closure_tys[&def_id].clone()\n+        }).encode(self).unwrap();\n         self.end_tag();\n \n         assert!(self.mir_map.map.contains_key(&def_id));\n@@ -1292,16 +996,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n fn encode_info_for_items(ecx: &mut EncodeContext) -> IndexData {\n     let krate = ecx.tcx.map.krate();\n \n-    ecx.start_tag(root_tag::items);\n+    // FIXME(eddyb) Avoid wrapping the items in a doc.\n+    ecx.start_tag(0).unwrap();\n \n     let items = {\n         let mut index = IndexBuilder::new(ecx);\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      EncodeContext::encode_info_for_mod,\n-                     FromId(CRATE_NODE_ID, (&krate.module,\n-                                            &krate.attrs,\n-                                            syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                                            &hir::Public)));\n+                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor {\n             index: index,\n         };\n@@ -1354,8 +1056,7 @@ fn encode_crate_deps(ecx: &mut EncodeContext, cstore: &cstore::CStore) {\n     // but is enough to get transitive crate dependencies working.\n     ecx.start_tag(root_tag::crate_deps);\n     ecx.seq(&get_ordered_deps(cstore), |_, &(_, ref dep)| {\n-        (dep.name(), decoder::get_crate_hash(dep.data()),\n-         dep.explicitly_linked.get())\n+        (dep.name(), dep.hash(), dep.explicitly_linked.get())\n     });\n     ecx.end_tag();\n }\n@@ -1406,18 +1107,6 @@ fn encode_native_libraries(ecx: &mut EncodeContext) {\n     ecx.end_tag();\n }\n \n-fn encode_plugin_registrar_fn(ecx: &mut EncodeContext) {\n-    match ecx.tcx.sess.plugin_registrar_fn.get() {\n-        Some(id) => {\n-            let def_id = ecx.tcx.map.local_def_id(id);\n-            ecx.start_tag(root_tag::plugin_registrar_fn);\n-            def_id.index.encode(ecx).unwrap();\n-            ecx.end_tag();\n-        }\n-        None => {}\n-    }\n-}\n-\n fn encode_codemap(ecx: &mut EncodeContext) {\n     let codemap = ecx.tcx.sess.codemap();\n     let all_filemaps = codemap.files.borrow();\n@@ -1448,15 +1137,6 @@ fn encode_macro_defs(ecx: &mut EncodeContext) {\n         (def.name, &def.attrs, def.span, body)\n     });\n     ecx.end_tag();\n-\n-    if ecx.tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro) {\n-        let id = ecx.tcx.sess.derive_registrar_fn.get().unwrap();\n-        let did = ecx.tcx.map.local_def_id(id);\n-\n-        ecx.start_tag(root_tag::macro_derive_registrar);\n-        did.index.encode(ecx).unwrap();\n-        ecx.end_tag();\n-    }\n }\n \n struct ImplVisitor<'a, 'tcx:'a> {\n@@ -1601,30 +1281,29 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     let tcx = ecx.tcx;\n     let link_meta = ecx.link_meta;\n \n-    ecx.start_tag(root_tag::crate_crate_name);\n-    link_meta.crate_name.encode(ecx).unwrap();\n-    ecx.end_tag();\n-\n-    ecx.start_tag(root_tag::crate_triple);\n-    tcx.sess.opts.target_triple.encode(ecx).unwrap();\n-    ecx.end_tag();\n-\n-    ecx.start_tag(root_tag::crate_hash);\n-    link_meta.crate_hash.encode(ecx).unwrap();\n-    ecx.end_tag();\n-\n-    ecx.start_tag(root_tag::crate_disambiguator);\n-    tcx.sess.local_crate_disambiguator().encode(ecx).unwrap();\n-    ecx.end_tag();\n-\n-    encode_dylib_dependency_formats(ecx);\n-\n-    ecx.start_tag(root_tag::panic_strategy);\n-    ecx.tcx.sess.opts.cg.panic.encode(ecx);\n+    ecx.start_tag(root_tag::crate_info);\n+    let is_rustc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeRustcMacro);\n+    CrateInfo {\n+        name: link_meta.crate_name.clone(),\n+        triple: tcx.sess.opts.target_triple.clone(),\n+        hash: link_meta.crate_hash,\n+        disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n+        panic_strategy: tcx.sess.opts.cg.panic.clone(),\n+        plugin_registrar_fn: tcx.sess.plugin_registrar_fn.get().map(|id| {\n+            tcx.map.local_def_id(id).index\n+        }),\n+        macro_derive_registrar: if is_rustc_macro {\n+            let id = tcx.sess.derive_registrar_fn.get().unwrap();\n+            Some(tcx.map.local_def_id(id).index)\n+        } else {\n+            None\n+        }\n+    }.encode(ecx).unwrap();\n     ecx.end_tag();\n \n     let mut i = ecx.position();\n     encode_crate_deps(ecx, ecx.cstore);\n+    encode_dylib_dependency_formats(ecx);\n     let dep_bytes = ecx.position() - i;\n \n     // Encode the language items.\n@@ -1637,11 +1316,6 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n     encode_native_libraries(ecx);\n     let native_lib_bytes = ecx.position() - i;\n \n-    // Encode the plugin registrar function\n-    i = ecx.position();\n-    encode_plugin_registrar_fn(ecx);\n-    let plugin_registrar_fn_bytes = ecx.position() - i;\n-\n     // Encode codemap\n     i = ecx.position();\n     encode_codemap(ecx);\n@@ -1689,7 +1363,6 @@ fn encode_metadata_inner(ecx: &mut EncodeContext) {\n         println!(\"             dep bytes: {}\", dep_bytes);\n         println!(\"       lang item bytes: {}\", lang_item_bytes);\n         println!(\"          native bytes: {}\", native_lib_bytes);\n-        println!(\"plugin registrar bytes: {}\", plugin_registrar_fn_bytes);\n         println!(\"         codemap bytes: {}\", codemap_bytes);\n         println!(\"       macro def bytes: {}\", macro_defs_bytes);\n         println!(\"            impl bytes: {}\", impl_bytes);"}, {"sha": "98a43c7639c3375655d788e7a4dfd4c7fcdc1031", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -53,6 +53,18 @@ impl Index {\n             Some(position)\n         }\n     }\n+\n+    pub fn iter_enumerated<'a>(&self, bytes: &'a [u8])\n+                               -> impl Iterator<Item=(DefIndex, u32)> + 'a {\n+        let words = bytes_to_words(&bytes[self.data_start..self.data_end]);\n+        words.iter().enumerate().filter_map(|(index, &position)| {\n+            if position == u32::MAX {\n+                None\n+            } else {\n+                Some((DefIndex::new(index), u32::from_be(position)))\n+            }\n+        })\n+    }\n }\n \n /// While we are generating the metadata, we also track the position"}, {"sha": "b46c5be9f8a877e458446745b03d42976e813885", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -51,26 +51,24 @@ extern crate rustc_const_math;\n #[cfg(test)]\n extern crate test;\n \n-pub mod rbml {\n+mod rbml {\n     pub mod writer;\n     pub mod reader;\n     pub use self::reader::Doc;\n }\n \n-pub use rustc::middle;\n+mod diagnostics;\n \n-pub mod diagnostics;\n-\n-pub mod astencode;\n-pub mod common;\n-pub mod def_key;\n-pub mod encoder;\n+mod astencode;\n+mod common;\n mod index_builder;\n-pub mod decoder;\n+mod index;\n+mod encoder;\n+mod decoder;\n+mod csearch;\n+\n pub mod creader;\n-pub mod csearch;\n pub mod cstore;\n-pub mod index;\n pub mod loader;\n pub mod macro_import;\n "}, {"sha": "47bf65bead9af328f45bccdc9ee426dd4e273b0b", "filename": "src/librustc_metadata/loader.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_metadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Floader.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -511,9 +511,8 @@ impl<'a> Context<'a> {\n                     if let Some((ref p, _)) = lib.rlib {\n                         err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    let data = lib.metadata.as_slice();\n-                    let name = decoder::get_crate_name(data);\n-                    note_crate_name(&mut err, &name);\n+                    let crate_info = decoder::get_crate_info(lib.metadata.as_slice());\n+                    note_crate_name(&mut err, &crate_info.name);\n                 }\n                 err.emit();\n                 None\n@@ -610,33 +609,27 @@ impl<'a> Context<'a> {\n             return None;\n         }\n \n+        let crate_info = decoder::get_crate_info(crate_data);\n         if self.should_match_name {\n-            match decoder::maybe_get_crate_name(crate_data) {\n-                Some(ref name) if self.crate_name == *name => {}\n-                _ => { info!(\"Rejecting via crate name\"); return None }\n+            if self.crate_name != crate_info.name {\n+                info!(\"Rejecting via crate name\"); return None;\n             }\n         }\n-        let hash = match decoder::maybe_get_crate_hash(crate_data) {\n-            None => { info!(\"Rejecting via lack of crate hash\"); return None; }\n-            Some(h) => h,\n-        };\n \n-        let triple = match decoder::get_crate_triple(crate_data) {\n-            None => { debug!(\"triple not present\"); return None }\n-            Some(t) => t,\n-        };\n-        if triple != self.triple {\n-            info!(\"Rejecting via crate triple: expected {} got {}\", self.triple, triple);\n+        if crate_info.triple != self.triple {\n+            info!(\"Rejecting via crate triple: expected {} got {}\",\n+                  self.triple, crate_info.triple);\n             self.rejected_via_triple.push(CrateMismatch {\n                 path: libpath.to_path_buf(),\n-                got: triple.to_string()\n+                got: crate_info.triple\n             });\n             return None;\n         }\n \n         if let Some(myhash) = self.hash {\n-            if *myhash != hash {\n-                info!(\"Rejecting via hash: expected {} got {}\", *myhash, hash);\n+            if *myhash != crate_info.hash {\n+                info!(\"Rejecting via hash: expected {} got {}\",\n+                      *myhash, crate_info.hash);\n                 self.rejected_via_hash.push(CrateMismatch {\n                     path: libpath.to_path_buf(),\n                     got: myhash.to_string()\n@@ -645,7 +638,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        Some(hash)\n+        Some(crate_info.hash)\n     }\n \n "}, {"sha": "6283ff2187ab8bbed00b8ff395d367627f26a409", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -271,7 +271,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n                         match cx.tcx.expect_def(fun.id) {\n-                            Def::Variant(_, variant_id) => {\n+                            Def::Variant(variant_id) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n                             Def::Struct(..) => {\n@@ -480,8 +480,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                     AdtKind::Enum => {\n                         match cx.tcx.expect_def(expr.id) {\n-                            Def::Variant(enum_id, variant_id) => {\n-                                debug_assert!(adt.did == enum_id);\n+                            Def::Variant(variant_id) => {\n                                 assert!(base.is_none());\n \n                                 let index = adt.variant_index_with_id(variant_id);\n@@ -688,13 +687,12 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             },\n             ref sty => bug!(\"unexpected sty: {:?}\", sty)\n         },\n-        Def::Variant(enum_id, variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n+        Def::Variant(variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A variant constructor. Should only be reached if not called in the same\n             // expression.\n             ty::TyFnDef(..) => variant_id,\n             // A unit variant, similar special case to the struct case above.\n             ty::TyAdt(adt_def, substs) => {\n-                debug_assert!(adt_def.did == enum_id);\n                 let index = adt_def.variant_index_with_id(variant_id);\n                 return ExprKind::Adt {\n                     adt_def: adt_def,"}, {"sha": "7b8446b184fb3725f4fd8fc2170c25a23a9cbe62", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -301,7 +301,8 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                        subpatterns: Vec<FieldPattern<'tcx>>)\n                        -> PatternKind<'tcx> {\n         match self.cx.tcx.expect_def(pat.id) {\n-            Def::Variant(enum_id, variant_id) => {\n+            Def::Variant(variant_id) => {\n+                let enum_id = self.cx.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     PatternKind::Variant {"}, {"sha": "0ab8e2d7fcd2812b50e8740fcf687c18629670b0", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -272,15 +272,13 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(Def::Variant(enum_id, variant_id)) => {\n-                        if let Some(enum_node_id) = self.ast_map.as_local_node_id(enum_id) {\n-                            if let hir::ItemEnum(ref enum_def, ref generics) = self.ast_map\n-                                .expect_item(enum_node_id)\n-                                .node {\n+                    Some(Def::Variant(variant_id)) => {\n+                        if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n+                            let variant = self.ast_map.expect_variant(variant_id);\n+                            let enum_id = self.ast_map.get_parent(variant_id);\n+                            let enum_item = self.ast_map.expect_item(enum_id);\n+                            if let hir::ItemEnum(ref enum_def, ref generics) = enum_item.node {\n                                 self.populate_enum_discriminants(enum_def);\n-                                let enum_id = self.ast_map.as_local_node_id(enum_id).unwrap();\n-                                let variant_id = self.ast_map.as_local_node_id(variant_id).unwrap();\n-                                let variant = self.ast_map.expect_variant(variant_id);\n                                 self.visit_variant(variant, generics, enum_id);\n                             } else {\n                                 span_bug!(e.span,"}, {"sha": "1b119fd008509c61ed7f8c2bf8f982b12c94f16e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -323,8 +323,13 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n             let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n                 Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n-                    if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n+                    if let Some(mut node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n+                        // Check the trait for associated types.\n+                        if let hir::map::NodeTraitItem(_) = self.ev.tcx.map.get(node_id) {\n+                            node_id = self.ev.tcx.map.get_parent(node_id);\n+                        }\n+\n                         let item = self.ev.tcx.map.expect_item(node_id);\n                         if let Def::TyAlias(..) = def {\n                             // Type aliases are substituted. Associated type aliases are not\n@@ -947,9 +952,14 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                     return\n                 }\n                 Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n-                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n+                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n                     // Non-local means public (private items can't leave their crate, modulo bugs)\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                    if let Some(mut node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                        // Check the trait for associated types.\n+                        if let hir::map::NodeTraitItem(_) = self.tcx.map.get(node_id) {\n+                            node_id = self.tcx.map.get_parent(node_id);\n+                        }\n+\n                         let item = self.tcx.map.expect_item(node_id);\n                         let vis = match self.substituted_alias_visibility(item, path) {\n                             Some(vis) => vis,"}, {"sha": "77a01aac73956ada114751690075288b9fab0b01", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -24,6 +24,7 @@ use {resolve_error, resolve_struct_error, ResolutionError};\n use rustc::middle::cstore::ChildItem;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::map::DefPathData;\n use rustc::ty;\n \n use std::cell::Cell;\n@@ -250,8 +251,7 @@ impl<'b> Resolver<'b> {\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n-                    let item_def_id = self.definitions.local_def_id(item.id);\n-                    self.build_reduced_graph_for_variant(variant, item_def_id, module, vis);\n+                    self.build_reduced_graph_for_variant(variant, module, vis);\n                 }\n             }\n \n@@ -314,7 +314,7 @@ impl<'b> Resolver<'b> {\n                             is_static_method = !sig.decl.has_self();\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n-                        TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),\n+                        TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n                         TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n                     };\n \n@@ -334,7 +334,6 @@ impl<'b> Resolver<'b> {\n     // type and value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n-                                       item_id: DefId,\n                                        parent: Module<'b>,\n                                        vis: ty::Visibility) {\n         let name = variant.node.name.name;\n@@ -346,7 +345,7 @@ impl<'b> Resolver<'b> {\n \n         // Variants are always treated as importable to allow them to be glob used.\n         // All variants are defined in both type and value namespaces as future-proofing.\n-        let def = Def::Variant(item_id, self.definitions.local_def_id(variant.node.data.id()));\n+        let def = Def::Variant(self.definitions.local_def_id(variant.node.data.id()));\n         self.define(parent, name, ValueNS, (def, variant.span, vis));\n         self.define(parent, name, TypeNS, (def, variant.span, vis));\n     }\n@@ -389,20 +388,12 @@ impl<'b> Resolver<'b> {\n \n     /// Builds the reduced graph for a single item in an external crate.\n     fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: ChildItem) {\n-        if let Def::ForeignMod(def_id) = child.def {\n-            // Foreign modules have no names. Recur and populate eagerly.\n-            for child in self.session.cstore.item_children(def_id) {\n-                self.build_reduced_graph_for_external_crate_def(parent, child);\n-            }\n-            return;\n-        }\n-\n         let def = child.def;\n         let name = child.name;\n         let vis = if parent.is_trait() { ty::Visibility::Public } else { child.vis };\n \n         match def {\n-            Def::Mod(_) | Def::ForeignMod(_) | Def::Enum(..) => {\n+            Def::Mod(_) | Def::Enum(..) => {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n                 let parent_link = ModuleParentLink(parent, name);\n@@ -434,7 +425,8 @@ impl<'b> Resolver<'b> {\n                 let trait_item_def_ids = self.session.cstore.impl_or_trait_items(def_id);\n                 for &trait_item_def in &trait_item_def_ids {\n                     let trait_item_name =\n-                        self.session.cstore.item_name(trait_item_def);\n+                        self.session.cstore.opt_item_name(trait_item_def)\n+                            .expect(\"opt_item_name returned None for trait\");\n \n                     debug!(\"(building reduced graph for external crate) ... adding trait item \\\n                             '{}'\",\n@@ -452,7 +444,9 @@ impl<'b> Resolver<'b> {\n                 let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n             }\n             Def::Struct(def_id)\n-                if self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_none() => {\n+                if self.session.cstore.def_key(def_id).disambiguated_data.data !=\n+                   DefPathData::StructCtor\n+                => {\n                 debug!(\"(building reduced graph for external crate) building type and value for {}\",\n                        name);\n                 let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));"}, {"sha": "016b621eabd4c598c79421e17240667754a4a777", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -2757,7 +2757,7 @@ impl<'a> Resolver<'a> {\n             if let Some(resolution) = self.def_map.get(&node_id) {\n                 match resolution.base_def {\n                     Def::Enum(did) | Def::TyAlias(did) | Def::Union(did) |\n-                    Def::Struct(did) | Def::Variant(_, did) if resolution.depth == 0 => {\n+                    Def::Struct(did) | Def::Variant(did) if resolution.depth == 0 => {\n                         if let Some(fields) = self.structs.get(&did) {\n                             if fields.iter().any(|&field_name| name == field_name) {\n                                 return Field;\n@@ -2826,7 +2826,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(path_res) = self.resolve_possibly_assoc_item(expr.id,\n                                                             maybe_qself.as_ref(), path, ValueNS) {\n                     // Check if struct variant\n-                    let is_struct_variant = if let Def::Variant(_, variant_id) = path_res.base_def {\n+                    let is_struct_variant = if let Def::Variant(variant_id) = path_res.base_def {\n                         self.structs.contains_key(&variant_id)\n                     } else {\n                         false"}, {"sha": "79fcff7d8a166471e43dfe956b88e9bb4b891daf", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -293,8 +293,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n \n         let def = self.tcx.expect_def(ref_id);\n         match def {\n-            Def::Mod(_) |\n-            Def::ForeignMod(_) => {\n+            Def::Mod(_) => {\n                 self.dumper.mod_ref(ModRefData {\n                     span: sub_span.expect(\"No span found for mod ref\"),\n                     ref_id: Some(def_id),"}, {"sha": "cbdce3229c7c76d96e6152384f7fde2cc5844b53", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -1373,7 +1373,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             item.expect(\"missing associated type\").def_id()\n         };\n \n-        (ty, Def::AssociatedTy(trait_did, item_did))\n+        (ty, Def::AssociatedTy(item_did))\n     }\n \n     fn qpath_to_ty(&self,\n@@ -1522,8 +1522,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 tcx.prohibit_type_params(base_segments);\n                 tcx.mk_self_type()\n             }\n-            Def::AssociatedTy(trait_did, _) => {\n+            Def::AssociatedTy(def_id) => {\n                 tcx.prohibit_type_params(&base_segments[..base_segments.len()-2]);\n+                let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(rscope,\n                                  span,\n                                  param_mode,"}, {"sha": "e38b865842e8a9e1c7ca73c4e97518920f65089b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -3224,7 +3224,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(type_did, _) | Def::Struct(type_did) | Def::Union(type_did) => {\n+            Def::Variant(did) => {\n+                let type_did = self.tcx.parent_def_id(did).unwrap();\n+                Some((type_did, self.tcx.expect_variant_def(def)))\n+            }\n+            Def::Struct(type_did) | Def::Union(type_did) => {\n                 Some((type_did, self.tcx.expect_variant_def(def)))\n             }\n             Def::TyAlias(did) => {\n@@ -4115,10 +4119,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Case 1 and 1b. Reference to a *type* or *enum variant*.\n             Def::Struct(def_id) |\n             Def::Union(def_id) |\n-            Def::Variant(_, def_id) |\n+            Def::Variant(def_id) |\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |\n-            Def::AssociatedTy(_, def_id) |\n+            Def::AssociatedTy(def_id) |\n             Def::Trait(def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n@@ -4166,7 +4170,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // here. If they do, an error will have been reported\n             // elsewhere. (I hope)\n             Def::Mod(..) |\n-            Def::ForeignMod(..) |\n             Def::PrimTy(..) |\n             Def::SelfTy(..) |\n             Def::TyParam(..) |"}, {"sha": "855b135b8636aa031c6eebb7c0eebad8810540df", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -17,6 +17,7 @@ use rustc::hir;\n \n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::DefPathData;\n use rustc::hir::print as pprust;\n use rustc::ty::{self, TyCtxt, VariantKind};\n use rustc::util::nodemap::FnvHashSet;\n@@ -82,7 +83,7 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         Def::Struct(did)\n                 // If this is a struct constructor, we skip it\n-                if tcx.sess.cstore.tuple_struct_definition_if_ctor(did).is_none() => {\n+                if tcx.def_key(did).disambiguated_data.data != DefPathData::StructCtor => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n@@ -497,17 +498,10 @@ fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // visit each node at most once.\n         let mut visited = FnvHashSet();\n         for item in tcx.sess.cstore.item_children(did) {\n-            match item.def {\n-                Def::ForeignMod(did) => {\n-                    fill_in(cx, tcx, did, items);\n-                }\n-                def => {\n-                    if item.vis == ty::Visibility::Public {\n-                        if !visited.insert(def) { continue }\n-                        if let Some(i) = try_inline_def(cx, tcx, def) {\n-                            items.extend(i)\n-                        }\n-                    }\n+            if item.vis == ty::Visibility::Public {\n+                if !visited.insert(item.def) { continue }\n+                if let Some(i) = try_inline_def(cx, tcx, item.def) {\n+                    items.extend(i)\n                 }\n             }\n         }"}, {"sha": "43a9b4e49e39377e330ccc67d175b3c2c751be6b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -1161,7 +1161,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n         let mut names = if cx.map.as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n-            cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n+            cx.tcx().sess.cstore.fn_arg_names(did).into_iter()\n         }.peekable();\n         FnDecl {\n             output: Return(sig.0.output.clean(cx)),\n@@ -2757,6 +2757,8 @@ fn resolve_type(cx: &DocContext,\n fn register_def(cx: &DocContext, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n+    let tcx = cx.tcx();\n+\n     let (did, kind) = match def {\n         Def::Fn(i) => (i, TypeFunction),\n         Def::TyAlias(i) => (i, TypeTypedef),\n@@ -2766,18 +2768,14 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Union(i) => (i, TypeUnion),\n         Def::Mod(i) => (i, TypeModule),\n         Def::Static(i, _) => (i, TypeStatic),\n-        Def::Variant(i, _) => (i, TypeEnum),\n+        Def::Variant(i) => (tcx.parent_def_id(i).unwrap(), TypeEnum),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeTrait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id\n         }\n         _ => return def.def_id()\n     };\n     if did.is_local() { return did }\n-    let tcx = match cx.tcx_opt() {\n-        Some(tcx) => tcx,\n-        None => return did\n-    };\n     inline::record_extern_fqn(cx, did, kind);\n     if let TypeTrait = kind {\n         let t = inline::build_external_trait(cx, tcx, did);"}, {"sha": "d93ca75a8da0233c898bfa51bda1d91839766892", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=ef4352fba6f0a93b55eeaf2c2cdf10f0e0401719", "patch": "@@ -68,7 +68,6 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n         for item in self.cstore.item_children(did) {\n             match item.def {\n                 Def::Mod(did) |\n-                Def::ForeignMod(did) |\n                 Def::Trait(did) |\n                 Def::Struct(did) |\n                 Def::Union(did) |\n@@ -84,9 +83,10 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn visit_item(&mut self, did: DefId, item: ChildItem) {\n-        let inherited_item_level = match item.def {\n-            Def::ForeignMod(..) => self.prev_level,\n-            _ => if item.vis == Visibility::Public { self.prev_level } else { None }\n+        let inherited_item_level = if item.vis == Visibility::Public {\n+            self.prev_level\n+        } else {\n+            None\n         };\n \n         let item_level = self.update(did, inherited_item_level);"}]}