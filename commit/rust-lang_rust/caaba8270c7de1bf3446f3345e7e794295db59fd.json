{"sha": "caaba8270c7de1bf3446f3345e7e794295db59fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYWJhODI3MGM3ZGUxYmYzNDQ2ZjMzNDVlN2U3OTQyOTVkYjU5ZmQ=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T09:53:31Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "move clone_on_copy to its own module", "tree": {"sha": "4847c62fc6032aaff23d0c4e967d7acafb934f00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4847c62fc6032aaff23d0c4e967d7acafb934f00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caaba8270c7de1bf3446f3345e7e794295db59fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caaba8270c7de1bf3446f3345e7e794295db59fd", "html_url": "https://github.com/rust-lang/rust/commit/caaba8270c7de1bf3446f3345e7e794295db59fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caaba8270c7de1bf3446f3345e7e794295db59fd/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "171c4c148540846c8aab4e1f0f491e8bfb892fcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/171c4c148540846c8aab4e1f0f491e8bfb892fcf", "html_url": "https://github.com/rust-lang/rust/commit/171c4c148540846c8aab4e1f0f491e8bfb892fcf"}], "stats": {"total": 215, "additions": 112, "deletions": 103}, "files": [{"sha": "4a130ed47db15bc00e6f3afc075c963f55a5a75d", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/caaba8270c7de1bf3446f3345e7e794295db59fd/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caaba8270c7de1bf3446f3345e7e794295db59fd/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=caaba8270c7de1bf3446f3345e7e794295db59fd", "patch": "@@ -0,0 +1,109 @@\n+use crate::utils::{is_copy, span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use std::iter;\n+\n+use super::CLONE_DOUBLE_REF;\n+use super::CLONE_ON_COPY;\n+\n+/// Checks for the `CLONE_ON_COPY` lint.\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if let ty::Ref(_, inner, _) = arg_ty.kind() {\n+        if let ty::Ref(_, innermost, _) = inner.kind() {\n+            span_lint_and_then(\n+                cx,\n+                CLONE_DOUBLE_REF,\n+                expr.span,\n+                &format!(\n+                    \"using `clone` on a double-reference; \\\n+                    this will copy the reference of type `{}` instead of cloning the inner type\",\n+                    ty\n+                ),\n+                |diag| {\n+                    if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n+                        let mut ty = innermost;\n+                        let mut n = 0;\n+                        while let ty::Ref(_, inner, _) = ty.kind() {\n+                            ty = inner;\n+                            n += 1;\n+                        }\n+                        let refs: String = iter::repeat('&').take(n + 1).collect();\n+                        let derefs: String = iter::repeat('*').take(n).collect();\n+                        let explicit = format!(\"<{}{}>::clone({})\", refs, ty, snip);\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"try dereferencing it\",\n+                            format!(\"{}({}{}).clone()\", refs, derefs, snip.deref()),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        diag.span_suggestion(\n+                            expr.span,\n+                            \"or try being explicit if you are sure, that you want to clone a reference\",\n+                            explicit,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                },\n+            );\n+            return; // don't report clone_on_copy\n+        }\n+    }\n+\n+    if is_copy(cx, ty) {\n+        let snip;\n+        if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n+            let parent = cx.tcx.hir().get_parent_node(expr.hir_id);\n+            match &cx.tcx.hir().get(parent) {\n+                hir::Node::Expr(parent) => match parent.kind {\n+                    // &*x is a nop, &x.clone() is not\n+                    hir::ExprKind::AddrOf(..) => return,\n+                    // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n+                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n+                        return;\n+                    },\n+\n+                    _ => {},\n+                },\n+                hir::Node::Stmt(stmt) => {\n+                    if let hir::StmtKind::Local(ref loc) = stmt.kind {\n+                        if let hir::PatKind::Ref(..) = loc.pat.kind {\n+                            // let ref y = *x borrows x, let ref y = x.clone() does not\n+                            return;\n+                        }\n+                    }\n+                },\n+                _ => {},\n+            }\n+\n+            // x.clone() might have dereferenced x, possibly through Deref impls\n+            if cx.typeck_results().expr_ty(arg) == ty {\n+                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n+            } else {\n+                let deref_count = cx\n+                    .typeck_results()\n+                    .expr_adjustments(arg)\n+                    .iter()\n+                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n+                    .count();\n+                let derefs: String = iter::repeat('*').take(deref_count).collect();\n+                snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n+            }\n+        } else {\n+            snip = None;\n+        }\n+        span_lint_and_then(\n+            cx,\n+            CLONE_ON_COPY,\n+            expr.span,\n+            &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n+            |diag| {\n+                if let Some((text, snip)) = snip {\n+                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "f248a09e18ef354a9e58495766d9fd2cdbc568f6", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 103, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/caaba8270c7de1bf3446f3345e7e794295db59fd/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caaba8270c7de1bf3446f3345e7e794295db59fd/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=caaba8270c7de1bf3446f3345e7e794295db59fd", "patch": "@@ -1,5 +1,6 @@\n mod bind_instead_of_map;\n mod bytes_nth;\n+mod clone_on_copy;\n mod clone_on_ref_ptr;\n mod expect_used;\n mod filetype_is_file;\n@@ -45,7 +46,6 @@ mod wrong_self_convention;\n mod zst_offset;\n \n use std::borrow::Cow;\n-use std::iter;\n \n use bind_instead_of_map::BindInsteadOfMap;\n use if_chain::if_chain;\n@@ -69,7 +69,7 @@ use crate::utils::{\n     is_type_diagnostic_item, iter_input_pats, last_path_segment, match_def_path, match_qpath, match_trait_method,\n     match_type, meets_msrv, method_calls, method_chain_args, path_to_local_id, paths, remove_blocks, return_ty,\n     single_segment_path, snippet, snippet_with_applicability, snippet_with_macro_callsite, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, strip_pat_refs, sugg, walk_ptrs_ty_depth, SpanlessEq,\n+    span_lint_and_help, span_lint_and_sugg, strip_pat_refs, walk_ptrs_ty_depth, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1781,7 +1781,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n                 let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.ident.name == sym::clone {\n-                    lint_clone_on_copy(cx, expr, &args[0], self_ty);\n+                    clone_on_copy::check(cx, expr, &args[0], self_ty);\n                     clone_on_ref_ptr::check(cx, expr, &args[0]);\n                 }\n                 if args.len() == 1 && method_call.ident.name == sym!(to_string) {\n@@ -2323,106 +2323,6 @@ fn lint_expect_fun_call(\n     );\n }\n \n-/// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n-    let ty = cx.typeck_results().expr_ty(expr);\n-    if let ty::Ref(_, inner, _) = arg_ty.kind() {\n-        if let ty::Ref(_, innermost, _) = inner.kind() {\n-            span_lint_and_then(\n-                cx,\n-                CLONE_DOUBLE_REF,\n-                expr.span,\n-                &format!(\n-                    \"using `clone` on a double-reference; \\\n-                    this will copy the reference of type `{}` instead of cloning the inner type\",\n-                    ty\n-                ),\n-                |diag| {\n-                    if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n-                        let mut ty = innermost;\n-                        let mut n = 0;\n-                        while let ty::Ref(_, inner, _) = ty.kind() {\n-                            ty = inner;\n-                            n += 1;\n-                        }\n-                        let refs: String = iter::repeat('&').take(n + 1).collect();\n-                        let derefs: String = iter::repeat('*').take(n).collect();\n-                        let explicit = format!(\"<{}{}>::clone({})\", refs, ty, snip);\n-                        diag.span_suggestion(\n-                            expr.span,\n-                            \"try dereferencing it\",\n-                            format!(\"{}({}{}).clone()\", refs, derefs, snip.deref()),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.span_suggestion(\n-                            expr.span,\n-                            \"or try being explicit if you are sure, that you want to clone a reference\",\n-                            explicit,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                },\n-            );\n-            return; // don't report clone_on_copy\n-        }\n-    }\n-\n-    if is_copy(cx, ty) {\n-        let snip;\n-        if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n-            let parent = cx.tcx.hir().get_parent_node(expr.hir_id);\n-            match &cx.tcx.hir().get(parent) {\n-                hir::Node::Expr(parent) => match parent.kind {\n-                    // &*x is a nop, &x.clone() is not\n-                    hir::ExprKind::AddrOf(..) => return,\n-                    // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n-                        return;\n-                    },\n-\n-                    _ => {},\n-                },\n-                hir::Node::Stmt(stmt) => {\n-                    if let hir::StmtKind::Local(ref loc) = stmt.kind {\n-                        if let hir::PatKind::Ref(..) = loc.pat.kind {\n-                            // let ref y = *x borrows x, let ref y = x.clone() does not\n-                            return;\n-                        }\n-                    }\n-                },\n-                _ => {},\n-            }\n-\n-            // x.clone() might have dereferenced x, possibly through Deref impls\n-            if cx.typeck_results().expr_ty(arg) == ty {\n-                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n-            } else {\n-                let deref_count = cx\n-                    .typeck_results()\n-                    .expr_adjustments(arg)\n-                    .iter()\n-                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n-                    .count();\n-                let derefs: String = iter::repeat('*').take(deref_count).collect();\n-                snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n-            }\n-        } else {\n-            snip = None;\n-        }\n-        span_lint_and_then(\n-            cx,\n-            CLONE_ON_COPY,\n-            expr.span,\n-            &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n-            |diag| {\n-                if let Some((text, snip)) = snip {\n-                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n-                }\n-            },\n-        );\n-    }\n-}\n-\n fn lint_unnecessary_fold(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n     fn check_fold_with_op(\n         cx: &LateContext<'_>,"}]}