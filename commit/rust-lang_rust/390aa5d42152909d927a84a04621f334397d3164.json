{"sha": "390aa5d42152909d927a84a04621f334397d3164", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MGFhNWQ0MjE1MjkwOWQ5MjdhODRhMDQ2MjFmMzM0Mzk3ZDMxNjQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-01T22:23:48Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-06-20T11:23:23Z"}, "message": "Introduce ParamName and use it in place of LifetimeName", "tree": {"sha": "9af14b6716b994243602552838dff3e3adb95583", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9af14b6716b994243602552838dff3e3adb95583"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/390aa5d42152909d927a84a04621f334397d3164", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/390aa5d42152909d927a84a04621f334397d3164", "html_url": "https://github.com/rust-lang/rust/commit/390aa5d42152909d927a84a04621f334397d3164", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/390aa5d42152909d927a84a04621f334397d3164/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59feafd9d8de7c458498f1a8de2bd8afc30f4fbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/59feafd9d8de7c458498f1a8de2bd8afc30f4fbd", "html_url": "https://github.com/rust-lang/rust/commit/59feafd9d8de7c458498f1a8de2bd8afc30f4fbd"}], "stats": {"total": 344, "additions": 170, "deletions": 174}, "files": [{"sha": "9c154d2e4af125c34c279b84f6b92f44fc4b3d60", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -433,10 +433,10 @@ pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.id);\n     match lifetime.name {\n-        LifetimeName::Name(name) => {\n+        LifetimeName::Param(ParamName::Plain(name)) => {\n             visitor.visit_name(lifetime.span, name);\n         }\n-        LifetimeName::Fresh(_) |\n+        LifetimeName::Param(ParamName::Fresh(_)) |\n         LifetimeName::Static |\n         LifetimeName::Implicit |\n         LifetimeName::Underscore => {}\n@@ -742,20 +742,13 @@ pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v ParamBou\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam) {\n     visitor.visit_id(param.id);\n+    match param.name {\n+        ParamName::Plain(name) => visitor.visit_name(param.span, name),\n+        ParamName::Fresh(_) => {}\n+    }\n     match param.kind {\n-        GenericParamKind::Lifetime { ref lt_name, .. } => {\n-            match lt_name {\n-                LifetimeName::Name(name) => {\n-                    visitor.visit_name(param.span, *name);\n-                }\n-                LifetimeName::Fresh(_) |\n-                LifetimeName::Static |\n-                LifetimeName::Implicit |\n-                LifetimeName::Underscore => {}\n-            }\n-        }\n+        GenericParamKind::Lifetime { .. } => {}\n         GenericParamKind::Type { ref default, ref attrs, .. } => {\n-            visitor.visit_name(param.span, param.name);\n             walk_list!(visitor, visit_ty, default);\n             walk_list!(visitor, visit_attribute, attrs.iter());\n         }"}, {"sha": "7ef72fd75423a43a0bd006e29baecc85ff86ed03", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -41,7 +41,7 @@\n //! in the HIR, especially for multiple identifiers.\n \n use dep_graph::DepGraph;\n-use hir;\n+use hir::{self, ParamName};\n use hir::HirVec;\n use hir::map::{DefKey, DefPathData, Definitions};\n use hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n@@ -125,7 +125,7 @@ pub struct LoweringContext<'a> {\n     // (i.e. it doesn't appear in the in_scope_lifetimes list), it is added\n     // to this list. The results of this list are then added to the list of\n     // lifetime definitions in the corresponding impl or function generics.\n-    lifetimes_to_define: Vec<(Span, hir::LifetimeName)>,\n+    lifetimes_to_define: Vec<(Span, ParamName)>,\n \n     // Whether or not in-band lifetimes are being collected. This is used to\n     // indicate whether or not we're in a place where new lifetimes will result\n@@ -678,13 +678,8 @@ impl<'a> LoweringContext<'a> {\n                 // that collisions are ok here and this shouldn't\n                 // really show up for end-user.\n                 let str_name = match hir_name {\n-                    hir::LifetimeName::Name(n) => n.as_str(),\n-                    hir::LifetimeName::Fresh(_) => keywords::UnderscoreLifetime.name().as_str(),\n-                    hir::LifetimeName::Implicit\n-                    | hir::LifetimeName::Underscore\n-                    | hir::LifetimeName::Static => {\n-                        span_bug!(span, \"unexpected in-band lifetime name: {:?}\", hir_name)\n-                    }\n+                    ParamName::Plain(name) => name.as_str(),\n+                    ParamName::Fresh(_) => keywords::UnderscoreLifetime.name().as_str(),\n                 };\n \n                 // Add a definition for the in-band lifetime def\n@@ -699,15 +694,12 @@ impl<'a> LoweringContext<'a> {\n \n                 hir::GenericParam {\n                     id: def_node_id,\n-                    name: hir_name.name(),\n+                    name: hir_name,\n                     span,\n                     pure_wrt_drop: false,\n                     bounds: vec![].into(),\n-                    kind: hir::GenericParamKind::Lifetime {\n-                        lt_name: hir_name,\n-                        in_band: true,\n-                        }\n-                    }\n+                    kind: hir::GenericParamKind::Lifetime { in_band: true }\n+                }\n             })\n             .chain(in_band_ty_params.into_iter())\n             .collect();\n@@ -728,7 +720,7 @@ impl<'a> LoweringContext<'a> {\n             return;\n         }\n \n-        let hir_name = hir::LifetimeName::Name(name);\n+        let hir_name = ParamName::Plain(name);\n \n         if self.lifetimes_to_define.iter().any(|(_, lt_name)| *lt_name == hir_name) {\n             return;\n@@ -739,10 +731,10 @@ impl<'a> LoweringContext<'a> {\n \n     /// When we have either an elided or `'_` lifetime in an impl\n     /// header, we convert it to\n-    fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> hir::LifetimeName {\n+    fn collect_fresh_in_band_lifetime(&mut self, span: Span) -> ParamName {\n         assert!(self.is_collecting_in_band_lifetimes);\n         let index = self.lifetimes_to_define.len();\n-        let hir_name = hir::LifetimeName::Fresh(index);\n+        let hir_name = ParamName::Fresh(index);\n         self.lifetimes_to_define.push((span, hir_name));\n         hir_name\n     }\n@@ -781,7 +773,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name),\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.name()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -1244,7 +1236,7 @@ impl<'a> LoweringContext<'a> {\n                         let name = Symbol::intern(&pprust::ty_to_string(t));\n                         self.in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n-                            name,\n+                            name: ParamName::Plain(name),\n                             span,\n                             pure_wrt_drop: false,\n                             bounds: hir_bounds,\n@@ -1359,9 +1351,10 @@ impl<'a> LoweringContext<'a> {\n \n             fn visit_generic_param(&mut self, param: &'v hir::GenericParam) {\n                 // Record the introduction of 'a in `for<'a> ...`\n-                if let hir::GenericParamKind::Lifetime { lt_name, .. } = param.kind {\n+                if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n                     // Introduce lifetimes one at a time so that we can handle\n                     // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`\n+                    let lt_name = hir::LifetimeName::Param(param.name);\n                     self.currently_bound_lifetimes.push(lt_name);\n                 }\n \n@@ -1379,14 +1372,12 @@ impl<'a> LoweringContext<'a> {\n                             return;\n                         }\n                     }\n-                    name @ hir::LifetimeName::Fresh(_) => name,\n-                    name @ hir::LifetimeName::Name(_) => name,\n+                    hir::LifetimeName::Param(_) => lifetime.name,\n                     hir::LifetimeName::Static => return,\n                 };\n \n                 if !self.currently_bound_lifetimes.contains(&name)\n-                    && !self.already_defined_lifetimes.contains(&name)\n-                {\n+                    && !self.already_defined_lifetimes.contains(&name) {\n                     self.already_defined_lifetimes.insert(name);\n \n                     self.output_lifetimes.push(hir::Lifetime {\n@@ -1409,16 +1400,23 @@ impl<'a> LoweringContext<'a> {\n                         lifetime.span,\n                     );\n \n+                    let name = match name {\n+                        hir::LifetimeName::Underscore => {\n+                            hir::ParamName::Plain(keywords::UnderscoreLifetime.name())\n+                        }\n+                        hir::LifetimeName::Param(param_name) => param_name,\n+                        _ => bug!(\"expected LifetimeName::Param or ParamName::Plain\"),\n+                    };\n+\n                     self.output_lifetime_params.push(hir::GenericParam {\n                         id: def_node_id,\n-                        name: name.name(),\n+                        name,\n                         span: lifetime.span,\n                         pure_wrt_drop: false,\n                         bounds: vec![].into(),\n                         kind: hir::GenericParamKind::Lifetime {\n-                            lt_name: name,\n                             in_band: false,\n-                            }\n+                        }\n                     });\n                 }\n             }\n@@ -1894,7 +1892,7 @@ impl<'a> LoweringContext<'a> {\n             x if x == \"'_\" => match self.anonymous_lifetime_mode {\n                 AnonymousLifetimeMode::CreateParameter => {\n                     let fresh_name = self.collect_fresh_in_band_lifetime(span);\n-                    self.new_named_lifetime(l.id, span, fresh_name)\n+                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(fresh_name))\n                 }\n \n                 AnonymousLifetimeMode::PassThrough => {\n@@ -1903,7 +1901,8 @@ impl<'a> LoweringContext<'a> {\n             },\n             name => {\n                 self.maybe_collect_in_band_lifetime(span, name);\n-                self.new_named_lifetime(l.id, span, hir::LifetimeName::Name(name))\n+                let param_name = ParamName::Plain(name);\n+                self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(param_name))\n             }\n         }\n     }\n@@ -1942,16 +1941,17 @@ impl<'a> LoweringContext<'a> {\n                 self.is_collecting_in_band_lifetimes = false;\n \n                 let lt = self.lower_lifetime(&Lifetime { id: param.id, ident: param.ident });\n+                let param_name = match lt.name {\n+                    hir::LifetimeName::Param(param_name) => param_name,\n+                    _ => hir::ParamName::Plain(lt.name.name()),\n+                };\n                 let param = hir::GenericParam {\n                     id: lt.id,\n-                    name: lt.name.name(),\n+                    name: param_name,\n                     span: lt.span,\n                     pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n                     bounds,\n-                    kind: hir::GenericParamKind::Lifetime {\n-                        lt_name: lt.name,\n-                        in_band: false,\n-                    }\n+                    kind: hir::GenericParamKind::Lifetime { in_band: false }\n                 };\n \n                 self.is_collecting_in_band_lifetimes = was_collecting_in_band;\n@@ -1977,7 +1977,7 @@ impl<'a> LoweringContext<'a> {\n \n                 hir::GenericParam {\n                     id: self.lower_node_id(param.id).node_id,\n-                    name,\n+                    name: hir::ParamName::Plain(name),\n                     span: param.ident.span,\n                     pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n                     bounds,\n@@ -4193,7 +4193,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::Lifetime {\n                     id: self.next_id().node_id,\n                     span,\n-                    name: fresh_name,\n+                    name: hir::LifetimeName::Param(fresh_name),\n                 }\n             }\n "}, {"sha": "5ea9348403a9436226a9f1df493d33fbc24d319b", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -497,7 +497,7 @@ impl<'hir> Map<'hir> {\n             NodeGenericParam(param) => {\n                 Some(match param.kind {\n                     GenericParamKind::Lifetime { .. } => Def::Local(param.id),\n-                    GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id))\n+                    GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id)),\n                 })\n             }\n         }\n@@ -616,11 +616,8 @@ impl<'hir> Map<'hir> {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeGenericParam(param) => param.name,\n-            _ => {\n-                bug!(\"ty_param_name: {} not a type parameter\",\n-                    self.node_to_string(id))\n-            }\n+            NodeGenericParam(param) => param.name.name(),\n+            _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n \n@@ -957,7 +954,7 @@ impl<'hir> Map<'hir> {\n             NodeVariant(v) => v.node.name,\n             NodeField(f) => f.ident.name,\n             NodeLifetime(lt) => lt.name.name(),\n-            NodeGenericParam(param) => param.name,\n+            NodeGenericParam(param) => param.name.name(),\n             NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))"}, {"sha": "ab7e8c4e81341c59bf4a7474f6ddaf5c0eed961b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -201,12 +201,9 @@ pub struct Lifetime {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n-pub enum LifetimeName {\n-    /// User typed nothing. e.g. the lifetime in `&u32`.\n-    Implicit,\n-\n-    /// User typed `'_`.\n-    Underscore,\n+pub enum ParamName {\n+    /// Some user-given name like `T` or `'x`.\n+    Plain(Name),\n \n     /// Synthetic name generated when user elided a lifetime in an impl header,\n     /// e.g. the lifetimes in cases like these:\n@@ -222,22 +219,40 @@ pub enum LifetimeName {\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n     Fresh(usize),\n+}\n+\n+impl ParamName {\n+    pub fn name(&self) -> Name {\n+        match *self {\n+            ParamName::Plain(name) => name,\n+            ParamName::Fresh(_) => keywords::UnderscoreLifetime.name(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+pub enum LifetimeName {\n+    /// User-given names or fresh (synthetic) names.\n+    Param(ParamName),\n+\n+    /// User typed nothing. e.g. the lifetime in `&u32`.\n+    Implicit,\n+\n+    /// User typed `'_`.\n+    Underscore,\n \n     /// User wrote `'static`\n     Static,\n-\n-    /// Some user-given name like `'x`\n-    Name(Name),\n }\n \n impl LifetimeName {\n     pub fn name(&self) -> Name {\n         use self::LifetimeName::*;\n         match *self {\n             Implicit => keywords::Invalid.name(),\n-            Fresh(_) | Underscore => keywords::UnderscoreLifetime.name(),\n+            Underscore => keywords::UnderscoreLifetime.name(),\n             Static => keywords::StaticLifetime.name(),\n-            Name(name) => name,\n+            Param(param_name) => param_name.name(),\n         }\n     }\n \n@@ -251,7 +266,7 @@ impl LifetimeName {\n             // in the compiler is concerned -- `Fresh(_)` variants act\n             // equivalently to \"some fresh name\". They correspond to\n             // early-bound regions on an impl, in other words.\n-            Fresh(_) | Static | Name(_) => false,\n+            Param(_) | Static => false,\n         }\n     }\n \n@@ -449,7 +464,6 @@ pub type ParamBounds = HirVec<ParamBound>;\n pub enum GenericParamKind {\n     /// A lifetime definition, eg `'a: 'b + 'c + 'd`.\n     Lifetime {\n-        lt_name: LifetimeName,\n         // Indicates that the lifetime definition was synthetically added\n         // as a result of an in-band lifetime usage like:\n         // `fn foo(x: &'a u8) -> &'a u8 { x }`\n@@ -465,7 +479,7 @@ pub enum GenericParamKind {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct GenericParam {\n     pub id: NodeId,\n-    pub name: Name,\n+    pub name: ParamName,\n     pub bounds: ParamBounds,\n     pub span: Span,\n     pub pure_wrt_drop: bool,"}, {"sha": "56a4c2d3cb56717f45041367d571458059f479fc", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -2115,7 +2115,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_generic_param(&mut self, param: &GenericParam) -> io::Result<()> {\n-        self.print_name(param.name)?;\n+        self.print_name(param.name.name())?;\n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n                 let mut sep = \":\";"}, {"sha": "51934ad8e6a8cd5bdfab41d4db08bddf7e092654", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -142,12 +142,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n+impl_stable_hash_for!(enum hir::ParamName {\n+    Plain(name),\n+    Fresh(index)\n+});\n+\n impl_stable_hash_for!(enum hir::LifetimeName {\n+    Param(param_name),\n     Implicit,\n     Underscore,\n-    Fresh(index),\n     Static,\n-    Name(name)\n });\n \n impl_stable_hash_for!(struct hir::Label {\n@@ -209,8 +213,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::GenericParamKind {\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n-            hir::GenericParamKind::Lifetime { lt_name, in_band } => {\n-                lt_name.hash_stable(hcx, hasher);\n+            hir::GenericParamKind::Lifetime { in_band } => {\n                 in_band.hash_stable(hcx, hasher);\n             }\n             hir::GenericParamKind::Type { ref default, synthetic, attrs } => {"}, {"sha": "2461a1436bced1592817ea04980cc8d505e1c0e6", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 67, "deletions": 80, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -18,7 +18,7 @@\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::Map;\n-use hir::{GenericArg, ItemLocalId, LifetimeName};\n+use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName};\n use ty::{self, TyCtxt, GenericParamDefKind};\n \n use errors::DiagnosticBuilder;\n@@ -30,6 +30,7 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n \n@@ -81,42 +82,37 @@ pub enum Region {\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n-fn new_region(hir_map: &Map, param: &hir::GenericParam)\n-    -> (hir::LifetimeName, DefId, LifetimeDefOrigin) {\n+fn new_region(hir_map: &Map, param: &GenericParam) -> (DefId, LifetimeDefOrigin) {\n     let def_id = hir_map.local_def_id(param.id);\n-    let (lt_name, origin) = match param.kind {\n-        GenericParamKind::Lifetime { lt_name, in_band, .. } => {\n-            (lt_name, LifetimeDefOrigin::from_is_in_band(in_band))\n+    let origin = match param.kind {\n+        GenericParamKind::Lifetime { in_band, .. } => {\n+            LifetimeDefOrigin::from_is_in_band(in_band)\n         }\n         _ => bug!(\"expected a lifetime param\"),\n     };\n-    (lt_name, def_id, origin)\n+    (def_id, origin)\n }\n \n impl Region {\n-    fn early(\n-        hir_map: &Map,\n-        index: &mut u32,\n-        param: &hir::GenericParam,\n-    ) -> (hir::LifetimeName, Region) {\n+    fn early(hir_map: &Map, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n-        let (name, def_id, origin) = new_region(hir_map, param);\n+        let (def_id, origin) = new_region(hir_map, param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (name, Region::EarlyBound(i, def_id, origin))\n+        (param.name, Region::EarlyBound(i, def_id, origin))\n     }\n \n-    fn late(hir_map: &Map, param: &hir::GenericParam) -> (hir::LifetimeName, Region) {\n+    fn late(hir_map: &Map, param: &GenericParam) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n-        let (name, def_id, origin) = new_region(hir_map, param);\n+        let (def_id, origin) = new_region(hir_map, param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param,\n             depth,\n             def_id,\n             origin,\n         );\n-        (name, Region::LateBound(depth, def_id, origin))\n+        (param.name, Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -277,7 +273,7 @@ enum Scope<'a> {\n     /// it should be shifted by the number of `Binder`s in between the\n     /// declaration `Binder` and the location it's referenced from.\n     Binder {\n-        lifetimes: FxHashMap<hir::LifetimeName, Region>,\n+        lifetimes: FxHashMap<hir::ParamName, Region>,\n \n         /// if we extend this scope with another scope, what is the next index\n         /// we should use for an early-bound region?\n@@ -619,7 +615,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // cc #48468\n                         self.resolve_elided_lifetimes(vec![lifetime], false)\n                     }\n-                    LifetimeName::Fresh(_) | LifetimeName::Static | LifetimeName::Name(_) => {\n+                    LifetimeName::Param(_) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n@@ -695,10 +691,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n-                            if let hir::LifetimeName::Underscore = name {\n-                                // Pick the elided lifetime \"definition\" if one exists\n-                                // and use it to make an elision scope.\n-                                elision = Some(reg);\n+                            if let hir::ParamName::Plain(param_name) = name {\n+                                if param_name == keywords::UnderscoreLifetime.name() {\n+                                    // Pick the elided lifetime \"definition\" if one exists\n+                                    // and use it to make an elision scope.\n+                                    elision = Some(reg);\n+                                } else {\n+                                    lifetimes.insert(name, reg);\n+                                }\n                             } else {\n                                 lifetimes.insert(name, reg);\n                             }\n@@ -1180,7 +1180,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                     ref lifetimes, s, ..\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n+                    let param_name = hir::ParamName::Plain(label);\n+                    if let Some(def) = lifetimes.get(&param_name) {\n                         let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -1222,7 +1223,7 @@ fn compute_object_lifetime_defaults(\n                                 generics.params.iter().find_map(|param| match param.kind {\n                                         GenericParamKind::Lifetime { .. } => {\n                                             if i == 0 {\n-                                                return Some(param.name.to_string());\n+                                                return Some(param.name.name().to_string());\n                                             }\n                                             i -= 1;\n                                             None\n@@ -1299,8 +1300,8 @@ fn object_lifetime_defaults_for_item(\n                         Set1::One(Region::Static)\n                     } else {\n                         generics.params.iter().filter_map(|param| match param.kind {\n-                            GenericParamKind::Lifetime { lt_name, in_band, .. } => {\n-                                Some((param.id, lt_name, in_band))\n+                            GenericParamKind::Lifetime { in_band } => {\n+                                Some((param.id, hir::LifetimeName::Param(param.name), in_band))\n                             }\n                             _ => None,\n                         })\n@@ -1402,7 +1403,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n                         }\n                         hir::map::NodeGenericParam(param) => {\n-                            Some((param.id, param.span, param.name))\n+                            Some((param.id, param.span, param.name.name()))\n                         }\n                         _ => None,\n                     } {\n@@ -1425,7 +1426,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n                         }\n                         hir::map::NodeGenericParam(param) => {\n-                            Some((param.id, param.span, param.name))\n+                            Some((param.id, param.span, param.name.name()))\n                         }\n                         _ => None,\n                     } {\n@@ -1573,10 +1574,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder {\n-                    ref lifetimes, s, ..\n-                } => {\n-                    if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n+                Scope::Binder { ref lifetimes, s, .. } => {\n+                    let name = match lifetime_ref.name {\n+                        LifetimeName::Param(param_name) => param_name,\n+                        _ => bug!(\"expected LifetimeName::Param\"),\n+                    };\n+                    if let Some(&def) = lifetimes.get(&name) {\n                         break Some(def.shifted(late_depth));\n                     } else {\n                         late_depth += 1;\n@@ -2235,13 +2238,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n     fn check_lifetime_params(&mut self, old_scope: ScopeRef, params: &'tcx [hir::GenericParam]) {\n         let lifetimes: Vec<_> = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { lt_name, .. } => Some((param, lt_name)),\n+            GenericParamKind::Lifetime { .. } => Some((param, param.name)),\n             _ => None,\n         }).collect();\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n-            match lifetime_i_name {\n-                hir::LifetimeName::Static | hir::LifetimeName::Underscore => {\n-                    let name = lifetime_i.name;\n+            if let hir::ParamName::Plain(_) = lifetime_i_name {\n+                let name = lifetime_i_name.name();\n+                if name == keywords::UnderscoreLifetime.name() ||\n+                   name == keywords::StaticLifetime.name() {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         lifetime_i.span,\n@@ -2255,9 +2259,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     );\n                     err.emit();\n                 }\n-                hir::LifetimeName::Fresh(_)\n-                | hir::LifetimeName::Implicit\n-                | hir::LifetimeName::Name(_) => {}\n             }\n \n             // It is a hard error to shadow a lifetime within the same scope.\n@@ -2268,10 +2269,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         lifetime_j.span,\n                         E0263,\n                         \"lifetime name `{}` declared twice in the same scope\",\n-                        lifetime_j.name\n+                        lifetime_j.name.name()\n                     ).span_label(lifetime_j.span, \"declared twice\")\n-                        .span_label(lifetime_i.span, \"previous declaration here\")\n-                        .emit();\n+                     .span_label(lifetime_i.span, \"previous declaration here\")\n+                     .emit();\n                 }\n             }\n \n@@ -2293,25 +2294,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                         hir::LifetimeName::Static => {\n                             self.insert_lifetime(lt, Region::Static);\n-                            self.tcx\n-                                .sess\n-                                .struct_span_warn(\n-                                    lifetime_i.span.to(lt.span),\n-                                    &format!(\n-                                        \"unnecessary lifetime parameter `{}`\",\n-                                        lifetime_i.name\n-                                    ),\n-                                )\n-                                .help(&format!(\n-                                    \"you can use the `'static` lifetime directly, in place \\\n-                                     of `{}`\",\n-                                    lifetime_i.name\n-                                ))\n-                                .emit();\n+                            self.tcx.sess.struct_span_warn(\n+                                lifetime_i.span.to(lt.span),\n+                                &format!(\n+                                    \"unnecessary lifetime parameter `{}`\",\n+                                    lifetime_i.name.name(),\n+                                ),\n+                            ).help(&format!(\n+                                \"you can use the `'static` lifetime directly, in place \\\n+                                    of `{}`\",\n+                                lifetime_i.name.name(),\n+                            )).emit();\n                         }\n-                        hir::LifetimeName::Fresh(_)\n-                        | hir::LifetimeName::Implicit\n-                        | hir::LifetimeName::Name(_) => {\n+                        hir::LifetimeName::Param(_)\n+                        | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n                     }\n@@ -2328,7 +2324,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     ) {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n-            if param.name == label {\n+            if param.name.name() == label {\n                 signal_shadowing_problem(\n                     self.tcx,\n                     label,\n@@ -2339,11 +2335,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        let name = match param.kind {\n-            GenericParamKind::Lifetime { lt_name, .. } => lt_name,\n-            _ => bug!(\"expected lifetime param\"),\n-        };\n-\n         loop {\n             match *old_scope {\n                 Scope::Body { s, .. }\n@@ -2359,12 +2350,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder {\n                     ref lifetimes, s, ..\n                 } => {\n-                    if let Some(&def) = lifetimes.get(&name) {\n+                    if let Some(&def) = lifetimes.get(&param.name) {\n                         let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n-                            param.name,\n+                            param.name.name(),\n                             original_lifetime(self.tcx.hir.span(node_id)),\n                             shadower_lifetime(&param),\n                         );\n@@ -2515,10 +2506,10 @@ fn insert_late_bound_lifetimes(\n \n     for param in &generics.params {\n         match param.kind {\n-            hir::GenericParamKind::Lifetime { lt_name, .. } => {\n+            hir::GenericParamKind::Lifetime { .. } => {\n                 if !param.bounds.is_empty() {\n                     // `'a: 'b` means both `'a` and `'b` are referenced\n-                    appears_in_where_clause.regions.insert(lt_name);\n+                    appears_in_where_clause.regions.insert(hir::LifetimeName::Param(param.name));\n                 }\n             }\n             hir::GenericParamKind::Type { .. } => {}\n@@ -2535,25 +2526,21 @@ fn insert_late_bound_lifetimes(\n     // - do not appear in the where-clauses\n     // - are not implicitly captured by `impl Trait`\n     for param in &generics.params {\n-        let name = match param.kind {\n-            GenericParamKind::Lifetime { lt_name, .. } => lt_name,\n-            _ => continue,\n-        };\n-\n+        let lt_name = hir::LifetimeName::Param(param.name);\n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&name) {\n+        if appears_in_where_clause.regions.contains(&lt_name) {\n             continue;\n         }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&name)\n-            && appears_in_output.regions.contains(&name)\n+        if !constrained_by_input.regions.contains(&lt_name)\n+            && appears_in_output.regions.contains(&lt_name)\n         {\n             continue;\n         }\n \n         debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n-               name,\n+               param.name.name(),\n                param.id);\n \n         let inserted = map.late_bound.insert(param.id);"}, {"sha": "8f8fe04fd8e019c9ab653ece9f90d1526297eae4", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n             GenericParamKind::Lifetime { .. } => {}\n             GenericParamKind::Type { synthetic, .. } => {\n                 if synthetic.is_none() {\n-                    self.check_case(cx, \"type parameter\", param.name, param.span);\n+                    self.check_case(cx, \"type parameter\", param.name.name(), param.span);\n                 }\n             }\n         }\n@@ -258,7 +258,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n-                self.check_snake_case(cx, \"lifetime\", &param.name.as_str(), Some(param.span));\n+                let name = param.name.name().as_str();\n+                self.check_snake_case(cx, \"lifetime\", &name, Some(param.span));\n             }\n             GenericParamKind::Type { .. } => {}\n         }"}, {"sha": "003c6c4fb74d2b15caae1e708e2e86cc1f0fac57", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -5195,7 +5195,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for (&used, param) in types_used.iter().zip(types) {\n         if !used {\n             struct_span_err!(tcx.sess, param.span, E0091, \"type parameter `{}` is unused\",\n-                             param.name)\n+                             param.name.name())\n                 .span_label(param.span, \"unused type parameter\")\n                 .emit();\n         }"}, {"sha": "c4b20699cee582dfee3016babac4c2529195ba9f", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -632,7 +632,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         let param = &ast_generics.params[index];\n-        report_bivariance(tcx, param.span, param.name);\n+        report_bivariance(tcx, param.span, param.name.name());\n     }\n }\n "}, {"sha": "eb18916e7815303674a4bb799f9bb9b361a262f0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -898,7 +898,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     params.extend(early_lifetimes.enumerate().map(|(i, param)| {\n         ty::GenericParamDef {\n-            name: param.name.as_interned_str(),\n+            name: param.name.name().as_interned_str(),\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(param.id),\n             pure_wrt_drop: param.pure_wrt_drop,\n@@ -914,7 +914,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut i = 0;\n     params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n         GenericParamKind::Type { ref default, synthetic, .. } => {\n-            if param.name == keywords::SelfType.name() {\n+            if param.name.name() == keywords::SelfType.name() {\n                 span_bug!(param.span,  \"`Self` should not be the name of a regular parameter\");\n             }\n \n@@ -931,7 +931,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             let ty_param = ty::GenericParamDef {\n                 index: type_start + i as u32,\n-                name: param.name.as_interned_str(),\n+                name: param.name.name().as_interned_str(),\n                 def_id: tcx.hir.local_def_id(param.id),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Type {\n@@ -1437,7 +1437,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: tcx.hir.local_def_id(param.id),\n             index,\n-            name: param.name.as_interned_str(),\n+            name: param.name.name().as_interned_str(),\n         }));\n         index += 1;\n \n@@ -1461,7 +1461,8 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for param in &ast_generics.params {\n         match param.kind {\n             GenericParamKind::Type { .. } => {\n-                let param_ty = ty::ParamTy::new(index, param.name.as_interned_str()).to_ty(tcx);\n+                let name = param.name.name().as_interned_str();\n+                let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n                 index += 1;\n \n                 let sized = SizedByDefault::Yes;"}, {"sha": "0874e921f4173c4fae872d2e8c5781e02bf643b8", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -251,15 +251,15 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             match param.kind {\n                 ty::GenericParamDefKind::Lifetime => {\n                     let name = if param.name == \"\" {\n-                        hir::LifetimeName::Static\n+                        hir::ParamName::Plain(keywords::StaticLifetime.name())\n                     } else {\n-                        hir::LifetimeName::Name(param.name.as_symbol())\n+                        hir::ParamName::Plain(param.name.as_symbol())\n                     };\n \n                     args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n                         id: ast::DUMMY_NODE_ID,\n                         span: DUMMY_SP,\n-                        name,\n+                        name: hir::LifetimeName::Param(name),\n                     }));\n                 }\n                 ty::GenericParamDefKind::Type {..} => {"}, {"sha": "2b02c639b954ad735417b2dd7275eb9f6eabe89c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390aa5d42152909d927a84a04621f334397d3164/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=390aa5d42152909d927a84a04621f334397d3164", "patch": "@@ -1678,13 +1678,13 @@ impl Clean<Lifetime> for hir::GenericParam {\n                         _ => panic!(),\n                     });\n                     let name = bounds.next().unwrap().name.name();\n-                    let mut s = format!(\"{}: {}\", self.name, name);\n+                    let mut s = format!(\"{}: {}\", self.name.name(), name);\n                     for bound in bounds {\n                         s.push_str(&format!(\" + {}\", bound.name.name()));\n                     }\n                     Lifetime(s)\n                 } else {\n-                    Lifetime(self.name.to_string())\n+                    Lifetime(self.name.name().to_string())\n                 }\n             }\n             _ => panic!(),\n@@ -1897,18 +1897,18 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n                         _ => panic!(),\n                     });\n                     let name = bounds.next().unwrap().name.name();\n-                    let mut s = format!(\"{}: {}\", self.name, name);\n+                    let mut s = format!(\"{}: {}\", self.name.name(), name);\n                     for bound in bounds {\n                         s.push_str(&format!(\" + {}\", bound.name.name()));\n                     }\n                     s\n                 } else {\n-                    self.name.to_string()\n+                    self.name.name().to_string()\n                 };\n                 (name, GenericParamDefKind::Lifetime)\n             }\n             hir::GenericParamKind::Type { ref default, synthetic, .. } => {\n-                (self.name.clean(cx), GenericParamDefKind::Type {\n+                (self.name.name().clean(cx), GenericParamDefKind::Type {\n                     did: cx.tcx.hir.local_def_id(self.id),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),"}]}