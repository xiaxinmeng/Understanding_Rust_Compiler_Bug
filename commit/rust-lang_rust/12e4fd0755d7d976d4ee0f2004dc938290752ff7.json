{"sha": "12e4fd0755d7d976d4ee0f2004dc938290752ff7", "node_id": "C_kwDOAAsO6NoAKDEyZTRmZDA3NTVkN2Q5NzZkNGVlMGYyMDA0ZGM5MzgyOTA3NTJmZjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T07:57:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-31T07:57:09Z"}, "message": "Auto merge of #101225 - matthiaskrgr:rollup-9s1chas, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #100970 (Allow deriving multipart suggestions)\n - #100984 (Reinstate preloading of some dll imports)\n - #101011 (Use getentropy when possible on all Apple platforms)\n - #101025 (Add tier-3 support for powerpc64 and riscv64 openbsd)\n - #101049 (Remove span fatal from ast lowering)\n - #101100 (Make call suggestions more general and more accurate)\n - #101171 (Fix UB from misalignment and provenance widening in `std::sys::windows`)\n - #101185 (Tweak `WellFormedLoc`s a bit)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2a88229f6a91bb1741d22d923002d1b253346689", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a88229f6a91bb1741d22d923002d1b253346689"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12e4fd0755d7d976d4ee0f2004dc938290752ff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12e4fd0755d7d976d4ee0f2004dc938290752ff7", "html_url": "https://github.com/rust-lang/rust/commit/12e4fd0755d7d976d4ee0f2004dc938290752ff7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12e4fd0755d7d976d4ee0f2004dc938290752ff7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f442f8ba174fd4233a14ef4d7b577aa907db594", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f442f8ba174fd4233a14ef4d7b577aa907db594", "html_url": "https://github.com/rust-lang/rust/commit/7f442f8ba174fd4233a14ef4d7b577aa907db594"}, {"sha": "49ed325759ca51034fb965b161a06edf9a33e73c", "url": "https://api.github.com/repos/rust-lang/rust/commits/49ed325759ca51034fb965b161a06edf9a33e73c", "html_url": "https://github.com/rust-lang/rust/commit/49ed325759ca51034fb965b161a06edf9a33e73c"}], "stats": {"total": 2561, "additions": 1639, "deletions": 922}, "files": [{"sha": "4adeaef9bbfa832d708a5275c5209229c105c37f", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -327,3 +327,10 @@ pub struct ArbitraryExpressionInPattern {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(SessionDiagnostic, Clone, Copy)]\n+#[diag(ast_lowering::inclusive_range_with_no_end)]\n+pub struct InclusiveRangeWithNoEnd {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "176047616881f4a62da9610497adfe3f2b13832b", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n use super::errors::{\n     AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n     BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignemnt,\n-    GeneratorTooManyParameters, NotSupportedForLifetimeBinderAsyncClosure, RustcBoxAttributeError,\n-    UnderscoreExprLhsAssign,\n+    GeneratorTooManyParameters, InclusiveRangeWithNoEnd, NotSupportedForLifetimeBinderAsyncClosure,\n+    RustcBoxAttributeError, UnderscoreExprLhsAssign,\n };\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n@@ -1264,7 +1264,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             (Some(..), Some(..), HalfOpen) => hir::LangItem::Range,\n             (None, Some(..), Closed) => hir::LangItem::RangeToInclusive,\n             (Some(..), Some(..), Closed) => unreachable!(),\n-            (_, None, Closed) => self.diagnostic().span_fatal(span, \"inclusive range with no end\"),\n+            (start, None, Closed) => {\n+                self.tcx.sess.emit_err(InclusiveRangeWithNoEnd { span });\n+                match start {\n+                    Some(..) => hir::LangItem::RangeFrom,\n+                    None => hir::LangItem::RangeFull,\n+                }\n+            }\n         };\n \n         let fields = self.arena.alloc_from_iter("}, {"sha": "30a87740c7f9b16c56f2d0261b61cdf761448d14", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -36,6 +36,8 @@\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "f2790531aba44de40e247d6d7a8b4d956fd08684", "filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -129,3 +129,5 @@ ast_lowering_not_supported_for_lifetime_binder_async_closure =\n \n ast_lowering_arbitrary_expression_in_pattern =\n     arbitrary expressions aren't allowed in patterns\n+\n+ast_lowering_inclusive_range_with_no_end = inclusive range with no end"}, {"sha": "f75e2596f361b7549233878bccf2aa570baf3c5e", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -686,19 +686,12 @@ impl Diagnostic {\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        assert!(!suggestion.is_empty());\n-        self.push_suggestion(CodeSuggestion {\n-            substitutions: vec![Substitution {\n-                parts: suggestion\n-                    .into_iter()\n-                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                    .collect(),\n-            }],\n-            msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n-            style: SuggestionStyle::CompletelyHidden,\n+        self.multipart_suggestion_with_style(\n+            msg,\n+            suggestion,\n             applicability,\n-        });\n-        self\n+            SuggestionStyle::CompletelyHidden,\n+        )\n     }\n \n     /// Prints out a message with a suggested edit of the code."}, {"sha": "68abdd0bad1ff06165317a28d1f20392b33ba96e", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1249,9 +1249,13 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags\n-            .treat_err_as_bug\n-            .map_or(false, |c| self.err_count() + self.lint_err_count >= c.get())\n+        self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                >= c.get()\n+        })\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n@@ -1407,7 +1411,14 @@ impl HandlerInner {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n-        if self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() + 1 >= c.get()) {\n+        if self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                + 1\n+                >= c.get()\n+        }) {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n         }"}, {"sha": "9c6530c8a08438e8afc2eaddced942affe1df3db", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -41,7 +41,8 @@ macro_rules! pluralize {\n /// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n /// to determine whether it should be automatically applied or if the user should be consulted\n /// before applying the suggestion.\n-#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable, Serialize, Deserialize)]\n+#[derive(Copy, Clone, Debug, Hash, Encodable, Decodable, Serialize, Deserialize)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub enum Applicability {\n     /// The suggestion is definitely what the user intended, or maintains the exact meaning of the code.\n     /// This suggestion should be automatically applied."}, {"sha": "28e092c1eb72c1c9205068aa388bc5d912dc0a8c", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -342,10 +342,10 @@ fn main() {\n     };\n \n     // RISC-V GCC erroneously requires libatomic for sub-word\n-    // atomic operations. FreeBSD uses Clang as its system\n+    // atomic operations. Some BSD uses Clang as its system\n     // compiler and provides no libatomic in its base system so\n     // does not want this.\n-    if !target.contains(\"freebsd\") && target.starts_with(\"riscv\") {\n+    if target.starts_with(\"riscv\") && !target.contains(\"freebsd\") && !target.contains(\"openbsd\") {\n         println!(\"cargo:rustc-link-lib=atomic\");\n     }\n "}, {"sha": "8b40e295bd8a7aa33c4e5a52034d61adb2065cbc", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 446, "deletions": 254, "changes": 700, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -12,7 +12,7 @@ use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::fmt;\n use std::str::FromStr;\n-use syn::{parse_quote, spanned::Spanned, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n /// Which kind of suggestion is being created?\n@@ -28,8 +28,41 @@ enum SubdiagnosticSuggestionKind {\n     Verbose,\n }\n \n+impl FromStr for SubdiagnosticSuggestionKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"\" => Ok(SubdiagnosticSuggestionKind::Normal),\n+            \"_short\" => Ok(SubdiagnosticSuggestionKind::Short),\n+            \"_hidden\" => Ok(SubdiagnosticSuggestionKind::Hidden),\n+            \"_verbose\" => Ok(SubdiagnosticSuggestionKind::Verbose),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl SubdiagnosticSuggestionKind {\n+    pub fn to_suggestion_style(&self) -> TokenStream {\n+        match self {\n+            SubdiagnosticSuggestionKind::Normal => {\n+                quote! { rustc_errors::SuggestionStyle::ShowCode }\n+            }\n+            SubdiagnosticSuggestionKind::Short => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeInline }\n+            }\n+            SubdiagnosticSuggestionKind::Hidden => {\n+                quote! { rustc_errors::SuggestionStyle::HideCodeAlways }\n+            }\n+            SubdiagnosticSuggestionKind::Verbose => {\n+                quote! { rustc_errors::SuggestionStyle::ShowAlways }\n+            }\n+        }\n+    }\n+}\n+\n /// Which kind of subdiagnostic is being created from a variant?\n-#[derive(Clone, Copy)]\n+#[derive(Clone)]\n enum SubdiagnosticKind {\n     /// `#[label(...)]`\n     Label,\n@@ -40,31 +73,9 @@ enum SubdiagnosticKind {\n     /// `#[warning(...)]`\n     Warn,\n     /// `#[suggestion{,_short,_hidden,_verbose}]`\n-    Suggestion(SubdiagnosticSuggestionKind),\n-}\n-\n-impl FromStr for SubdiagnosticKind {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"label\" => Ok(SubdiagnosticKind::Label),\n-            \"note\" => Ok(SubdiagnosticKind::Note),\n-            \"help\" => Ok(SubdiagnosticKind::Help),\n-            \"warning\" => Ok(SubdiagnosticKind::Warn),\n-            \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n-            \"suggestion_short\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n-            }\n-            \"suggestion_hidden\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden))\n-            }\n-            \"suggestion_verbose\" => {\n-                Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose))\n-            }\n-            _ => Err(()),\n-        }\n-    }\n+    Suggestion { suggestion_kind: SubdiagnosticSuggestionKind, code: TokenStream },\n+    /// `#[multipart_suggestion{,_short,_hidden,_verbose}]`\n+    MultipartSuggestion { suggestion_kind: SubdiagnosticSuggestionKind },\n }\n \n impl quote::IdentFragment for SubdiagnosticKind {\n@@ -74,17 +85,9 @@ impl quote::IdentFragment for SubdiagnosticKind {\n             SubdiagnosticKind::Note => write!(f, \"note\"),\n             SubdiagnosticKind::Help => write!(f, \"help\"),\n             SubdiagnosticKind::Warn => write!(f, \"warn\"),\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n-                write!(f, \"suggestion\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short) => {\n-                write!(f, \"suggestion_short\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Hidden) => {\n-                write!(f, \"suggestion_hidden\")\n-            }\n-            SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Verbose) => {\n-                write!(f, \"suggestion_verbose\")\n+            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n+            SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                write!(f, \"multipart_suggestion_with_style\")\n             }\n         }\n     }\n@@ -148,11 +151,9 @@ impl<'a> SessionSubdiagnosticDerive<'a> {\n                     variant,\n                     span,\n                     fields: fields_map,\n-                    kind: None,\n-                    slug: None,\n-                    code: None,\n                     span_field: None,\n                     applicability: None,\n+                    has_suggestion_parts: false,\n                 };\n                 builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n             });\n@@ -193,21 +194,15 @@ struct SessionSubdiagnosticDeriveBuilder<'a> {\n     /// derive builder.\n     fields: HashMap<String, TokenStream>,\n \n-    /// Subdiagnostic kind of the type/variant.\n-    kind: Option<(SubdiagnosticKind, proc_macro::Span)>,\n-\n-    /// Slug of the subdiagnostic - corresponds to the Fluent identifier for the message - from the\n-    /// `#[kind(slug)]` attribute on the type or variant.\n-    slug: Option<(Path, proc_macro::Span)>,\n-    /// If a suggestion, the code to suggest as a replacement - from the `#[kind(code = \"...\")]`\n-    /// attribute on the type or variant.\n-    code: Option<(TokenStream, proc_macro::Span)>,\n-\n     /// Identifier for the binding to the `#[primary_span]` field.\n     span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n     /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n     /// `rustc_errors::Applicability::*` variant directly.\n     applicability: Option<(TokenStream, proc_macro::Span)>,\n+\n+    /// Set to true when a `#[suggestion_part]` field is encountered, used to generate an error\n+    /// during finalization if still `false`.\n+    has_suggestion_parts: bool,\n }\n \n impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n@@ -217,275 +212,472 @@ impl<'a> HasFieldMap for SessionSubdiagnosticDeriveBuilder<'a> {\n }\n \n impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n-    fn identify_kind(&mut self) -> Result<(), DiagnosticDeriveError> {\n+    fn identify_kind(\n+        &mut self,\n+    ) -> Result<Option<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n+        let mut kind_slug = None;\n+\n         for attr in self.variant.ast().attrs {\n             let span = attr.span().unwrap();\n \n             let name = attr.path.segments.last().unwrap().ident.to_string();\n             let name = name.as_str();\n \n             let meta = attr.parse_meta()?;\n-            let kind = match meta {\n-                Meta::List(MetaList { ref nested, .. }) => {\n-                    let mut nested_iter = nested.into_iter();\n-                    if let Some(nested_attr) = nested_iter.next() {\n-                        match nested_attr {\n-                            NestedMeta::Meta(Meta::Path(path)) => {\n-                                self.slug.set_once((path.clone(), span));\n-                            }\n-                            NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                                if matches!(\n-                                    meta.path().segments.last().unwrap().ident.to_string().as_str(),\n-                                    \"code\" | \"applicability\"\n-                                ) =>\n-                            {\n-                                // don't error for valid follow-up attributes\n-                            }\n-                            nested_attr => {\n-                                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                    diag.help(\n-                                        \"first argument of the attribute should be the diagnostic \\\n-                                         slug\",\n-                                    )\n-                                })\n-                            }\n-                        };\n-                    }\n+            let Meta::List(MetaList { ref nested, .. }) = meta else {\n+                throw_invalid_attr!(attr, &meta);\n+            };\n \n-                    for nested_attr in nested_iter {\n-                        let meta = match nested_attr {\n-                            NestedMeta::Meta(ref meta) => meta,\n-                            _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-                        };\n-\n-                        let span = meta.span().unwrap();\n-                        let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-                        let nested_name = nested_name.as_str();\n-\n-                        match meta {\n-                            Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                                match nested_name {\n-                                    \"code\" => {\n-                                        let formatted_str = self.build_format(&s.value(), s.span());\n-                                        self.code.set_once((formatted_str, span));\n-                                    }\n-                                    \"applicability\" => {\n-                                        let value = match Applicability::from_str(&s.value()) {\n-                                            Ok(v) => v,\n-                                            Err(()) => {\n-                                                span_err(span, \"invalid applicability\").emit();\n-                                                Applicability::Unspecified\n-                                            }\n-                                        };\n-                                        self.applicability.set_once((quote! { #value }, span));\n-                                    }\n-                                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                        diag.help(\n-                                            \"only `code` and `applicability` are valid nested \\\n-                                             attributes\",\n-                                        )\n-                                    }),\n-                                }\n-                            }\n-                            _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                                if matches!(meta, Meta::Path(_)) {\n-                                    diag.help(\n-                                        \"a diagnostic slug must be the first argument to the \\\n-                                         attribute\",\n-                                    )\n-                                } else {\n-                                    diag\n-                                }\n-                            }),\n-                        }\n+            let mut kind = match name {\n+                \"label\" => SubdiagnosticKind::Label,\n+                \"note\" => SubdiagnosticKind::Note,\n+                \"help\" => SubdiagnosticKind::Help,\n+                \"warning\" => SubdiagnosticKind::Warn,\n+                _ => {\n+                    if let Some(suggestion_kind) =\n+                        name.strip_prefix(\"suggestion\").and_then(|s| s.parse().ok())\n+                    {\n+                        SubdiagnosticKind::Suggestion { suggestion_kind, code: TokenStream::new() }\n+                    } else if let Some(suggestion_kind) =\n+                        name.strip_prefix(\"multipart_suggestion\").and_then(|s| s.parse().ok())\n+                    {\n+                        SubdiagnosticKind::MultipartSuggestion { suggestion_kind }\n+                    } else {\n+                        throw_invalid_attr!(attr, &meta);\n                     }\n-\n-                    let Ok(kind) = SubdiagnosticKind::from_str(name) else {\n-                        throw_invalid_attr!(attr, &meta)\n-                    };\n-\n-                    kind\n                 }\n-                _ => throw_invalid_attr!(attr, &meta),\n             };\n \n-            if matches!(\n-                kind,\n-                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n-            ) && self.code.is_some()\n-            {\n-                throw_span_err!(\n-                    span,\n-                    &format!(\"`code` is not a valid nested attribute of a `{}` attribute\", name)\n-                );\n+            let mut slug = None;\n+            let mut code = None;\n+\n+            let mut nested_iter = nested.into_iter();\n+            if let Some(nested_attr) = nested_iter.next() {\n+                match nested_attr {\n+                    NestedMeta::Meta(Meta::Path(path)) => {\n+                        slug.set_once((path.clone(), span));\n+                    }\n+                    NestedMeta::Meta(meta @ Meta::NameValue(_))\n+                        if matches!(\n+                            meta.path().segments.last().unwrap().ident.to_string().as_str(),\n+                            \"code\" | \"applicability\"\n+                        ) =>\n+                    {\n+                        // Don't error for valid follow-up attributes.\n+                    }\n+                    nested_attr => {\n+                        throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                            diag.help(\n+                                \"first argument of the attribute should be the diagnostic \\\n+                                 slug\",\n+                            )\n+                        })\n+                    }\n+                };\n             }\n \n-            if matches!(\n-                kind,\n-                SubdiagnosticKind::Label | SubdiagnosticKind::Help | SubdiagnosticKind::Note\n-            ) && self.applicability.is_some()\n-            {\n-                throw_span_err!(\n-                    span,\n-                    &format!(\n-                        \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n-                        name\n-                    )\n-                );\n+            for nested_attr in nested_iter {\n+                let meta = match nested_attr {\n+                    NestedMeta::Meta(ref meta) => meta,\n+                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                };\n+\n+                let span = meta.span().unwrap();\n+                let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                let nested_name = nested_name.as_str();\n+\n+                let value = match meta {\n+                    Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n+                    Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n+                    }),\n+                    _ => throw_invalid_nested_attr!(attr, &nested_attr),\n+                };\n+\n+                match nested_name {\n+                    \"code\" => {\n+                        if matches!(kind, SubdiagnosticKind::Suggestion { .. }) {\n+                            let formatted_str = self.build_format(&value.value(), value.span());\n+                            code.set_once((formatted_str, span));\n+                        } else {\n+                            span_err(\n+                                span,\n+                                &format!(\n+                                    \"`code` is not a valid nested attribute of a `{}` attribute\",\n+                                    name\n+                                ),\n+                            )\n+                            .emit();\n+                        }\n+                    }\n+                    \"applicability\" => {\n+                        if matches!(\n+                            kind,\n+                            SubdiagnosticKind::Suggestion { .. }\n+                                | SubdiagnosticKind::MultipartSuggestion { .. }\n+                        ) {\n+                            let value =\n+                                Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n+                                    span_err(span, \"invalid applicability\").emit();\n+                                    Applicability::Unspecified\n+                                });\n+                            self.applicability.set_once((quote! { #value }, span));\n+                        } else {\n+                            span_err(\n+                                span,\n+                                &format!(\n+                                    \"`applicability` is not a valid nested attribute of a `{}` attribute\",\n+                                    name\n+                                )\n+                            ).emit();\n+                        }\n+                    }\n+                    _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                        diag.help(\"only `code` and `applicability` are valid nested attributes\")\n+                    }),\n+                }\n             }\n \n-            if self.slug.is_none() {\n+            let Some((slug, _)) = slug else {\n                 throw_span_err!(\n                     span,\n                     &format!(\n                         \"diagnostic slug must be first argument of a `#[{}(...)]` attribute\",\n                         name\n                     )\n                 );\n+            };\n+\n+            match kind {\n+                SubdiagnosticKind::Suggestion { code: ref mut code_field, .. } => {\n+                    let Some((code, _)) = code else {\n+                        throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\");\n+                    };\n+                    *code_field = code;\n+                }\n+                SubdiagnosticKind::Label\n+                | SubdiagnosticKind::Note\n+                | SubdiagnosticKind::Help\n+                | SubdiagnosticKind::Warn\n+                | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n             }\n \n-            self.kind.set_once((kind, span));\n+            kind_slug.set_once(((kind, slug), span))\n         }\n \n-        Ok(())\n+        Ok(kind_slug.map(|(kind_slug, _)| kind_slug))\n+    }\n+\n+    /// Generates the code for a field with no attributes.\n+    fn generate_field_set_arg(&mut self, binding: &BindingInfo<'_>) -> TokenStream {\n+        let ast = binding.ast();\n+        assert_eq!(ast.attrs.len(), 0, \"field with attribute used as diagnostic arg\");\n+\n+        let diag = &self.diag;\n+        let ident = ast.ident.as_ref().unwrap();\n+        quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #binding\n+            );\n+        }\n     }\n \n-    fn generate_field_code(\n+    /// Generates the necessary code for all attributes on a field.\n+    fn generate_field_attr_code(\n         &mut self,\n         binding: &BindingInfo<'_>,\n-        is_suggestion: bool,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        kind: &SubdiagnosticKind,\n+    ) -> TokenStream {\n         let ast = binding.ast();\n+        assert!(ast.attrs.len() > 0, \"field without attributes generating attr code\");\n \n+        // Abstract over `Vec<T>` and `Option<T>` fields using `FieldInnerTy`, which will\n+        // apply the generated code on each element in the `Vec` or `Option`.\n         let inner_ty = FieldInnerTy::from_type(&ast.ty);\n-        let info = FieldInfo {\n-            binding: binding,\n-            ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n-            span: &ast.span(),\n-        };\n+        ast.attrs\n+            .iter()\n+            .map(|attr| {\n+                let info = FieldInfo {\n+                    binding,\n+                    ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n+                    span: &ast.span(),\n+                };\n \n-        for attr in &ast.attrs {\n-            let name = attr.path.segments.last().unwrap().ident.to_string();\n-            let name = name.as_str();\n-            let span = attr.span().unwrap();\n+                let generated = self\n+                    .generate_field_code_inner(kind, attr, info)\n+                    .unwrap_or_else(|v| v.to_compile_error());\n \n-            let meta = attr.parse_meta()?;\n-            match meta {\n-                Meta::Path(_) => match name {\n-                    \"primary_span\" => {\n-                        report_error_if_not_applied_to_span(attr, &info)?;\n-                        self.span_field.set_once((binding.binding.clone(), span));\n-                        return Ok(quote! {});\n-                    }\n-                    \"applicability\" if is_suggestion => {\n-                        report_error_if_not_applied_to_applicability(attr, &info)?;\n-                        let binding = binding.binding.clone();\n-                        self.applicability.set_once((quote! { #binding }, span));\n-                        return Ok(quote! {});\n-                    }\n-                    \"applicability\" => {\n-                        span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n-                        return Ok(quote! {});\n-                    }\n-                    \"skip_arg\" => {\n-                        return Ok(quote! {});\n-                    }\n-                    _ => throw_invalid_attr!(attr, &meta, |diag| {\n+                inner_ty.with(binding, generated)\n+            })\n+            .collect()\n+    }\n+\n+    fn generate_field_code_inner(\n+        &mut self,\n+        kind: &SubdiagnosticKind,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let meta = attr.parse_meta()?;\n+        match meta {\n+            Meta::Path(path) => self.generate_field_code_inner_path(kind, attr, info, path),\n+            Meta::List(list @ MetaList { .. }) => {\n+                self.generate_field_code_inner_list(kind, attr, info, list)\n+            }\n+            _ => throw_invalid_attr!(attr, &meta),\n+        }\n+    }\n+\n+    /// Generates the code for a `[Meta::Path]`-like attribute on a field (e.g. `#[primary_span]`).\n+    fn generate_field_code_inner_path(\n+        &mut self,\n+        kind: &SubdiagnosticKind,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        path: Path,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+        let ident = &path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n+        let name = name.as_str();\n+\n+        match name {\n+            \"skip_arg\" => Ok(quote! {}),\n+            \"primary_span\" => {\n+                if matches!(kind, SubdiagnosticKind::MultipartSuggestion { .. }) {\n+                    throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n                         diag.help(\n-                            \"only `primary_span`, `applicability` and `skip_arg` are valid field \\\n-                             attributes\",\n+                            \"multipart suggestions use one or more `#[suggestion_part]`s rather \\\n+                            than one `#[primary_span]`\",\n                         )\n-                    }),\n-                },\n-                _ => throw_invalid_attr!(attr, &meta),\n+                    })\n+                }\n+\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+\n+                let binding = info.binding.binding.clone();\n+                self.span_field.set_once((binding, span));\n+\n+                Ok(quote! {})\n             }\n+            \"suggestion_part\" => {\n+                self.has_suggestion_parts = true;\n+\n+                match kind {\n+                    SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                        span_err(\n+                            span,\n+                            \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\",\n+                        )\n+                        .emit();\n+                        Ok(quote! {})\n+                    }\n+                    SubdiagnosticKind::Label\n+                    | SubdiagnosticKind::Note\n+                    | SubdiagnosticKind::Help\n+                    | SubdiagnosticKind::Warn\n+                    | SubdiagnosticKind::Suggestion { .. } => {\n+                        throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                            diag.help(\n+                                \"`#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\",\n+                            )\n+                        });\n+                    }\n+                }\n+            }\n+            \"applicability\" => {\n+                if let SubdiagnosticKind::Suggestion { .. }\n+                | SubdiagnosticKind::MultipartSuggestion { .. } = kind\n+                {\n+                    report_error_if_not_applied_to_applicability(attr, &info)?;\n+\n+                    let binding = info.binding.binding.clone();\n+                    self.applicability.set_once((quote! { #binding }, span));\n+                } else {\n+                    span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n+                }\n+\n+                Ok(quote! {})\n+            }\n+            _ => throw_invalid_attr!(attr, &Meta::Path(path), |diag| {\n+                let span_attr = if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n+                    \"suggestion_part\"\n+                } else {\n+                    \"primary_span\"\n+                };\n+                diag.help(format!(\n+                    \"only `{span_attr}`, `applicability` and `skip_arg` are valid field attributes\",\n+                ))\n+            }),\n         }\n+    }\n \n-        let ident = ast.ident.as_ref().unwrap();\n+    /// Generates the code for a `[Meta::List]`-like attribute on a field (e.g.\n+    /// `#[suggestion_part(code = \"...\")]`).\n+    fn generate_field_code_inner_list(\n+        &mut self,\n+        kind: &SubdiagnosticKind,\n+        attr: &Attribute,\n+        info: FieldInfo<'_>,\n+        list: MetaList,\n+    ) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let span = attr.span().unwrap();\n+        let ident = &list.path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n+        let name = name.as_str();\n+\n+        match name {\n+            \"suggestion_part\" => {\n+                if !matches!(kind, SubdiagnosticKind::MultipartSuggestion { .. }) {\n+                    throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                        diag.help(\n+                            \"`#[suggestion_part(...)]` is only valid in multipart suggestions\",\n+                        )\n+                    })\n+                }\n \n-        let diag = &self.diag;\n-        let generated = quote! {\n-            #diag.set_arg(\n-                stringify!(#ident),\n-                #binding\n-            );\n-        };\n+                self.has_suggestion_parts = true;\n+\n+                report_error_if_not_applied_to_span(attr, &info)?;\n+\n+                let mut code = None;\n+                for nested_attr in list.nested.iter() {\n+                    let NestedMeta::Meta(ref meta) = nested_attr else {\n+                        throw_invalid_nested_attr!(attr, &nested_attr);\n+                    };\n+\n+                    let span = meta.span().unwrap();\n+                    let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n+                    let nested_name = nested_name.as_str();\n+\n+                    let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) = meta else {\n+                        throw_invalid_nested_attr!(attr, &nested_attr);\n+                    };\n+\n+                    match nested_name {\n+                        \"code\" => {\n+                            let formatted_str = self.build_format(&value.value(), value.span());\n+                            code.set_once((formatted_str, span));\n+                        }\n+                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n+                            diag.help(\"`code` is the only valid nested attribute\")\n+                        }),\n+                    }\n+                }\n+\n+                let Some((code, _)) = code else {\n+                    span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n+                        .emit();\n+                    return Ok(quote! {});\n+                };\n+                let binding = info.binding;\n \n-        Ok(inner_ty.with(binding, generated))\n+                Ok(quote! { suggestions.push((#binding, #code)); })\n+            }\n+            _ => throw_invalid_attr!(attr, &Meta::List(list), |diag| {\n+                let span_attr = if let SubdiagnosticKind::MultipartSuggestion { .. } = kind {\n+                    \"suggestion_part\"\n+                } else {\n+                    \"primary_span\"\n+                };\n+                diag.help(format!(\n+                    \"only `{span_attr}`, `applicability` and `skip_arg` are valid field attributes\",\n+                ))\n+            }),\n+        }\n     }\n \n-    fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n-        self.identify_kind()?;\n-        let Some(kind) = self.kind.map(|(kind, _)| kind) else {\n+    pub fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n+        let Some((kind, slug)) = self.identify_kind()? else {\n             throw_span_err!(\n                 self.variant.ast().ident.span().unwrap(),\n                 \"subdiagnostic kind not specified\"\n             );\n         };\n \n-        let is_suggestion = matches!(kind, SubdiagnosticKind::Suggestion(_));\n-\n-        let mut args = TokenStream::new();\n-        for binding in self.variant.bindings() {\n-            let arg = self\n-                .generate_field_code(binding, is_suggestion)\n-                .unwrap_or_else(|v| v.to_compile_error());\n-            args.extend(arg);\n-        }\n-\n-        // Missing slug errors will already have been reported.\n-        let slug = self\n-            .slug\n-            .as_ref()\n-            .map(|(slug, _)| slug.clone())\n-            .unwrap_or_else(|| parse_quote! { you::need::to::specify::a::slug });\n-        let code = match self.code.as_ref() {\n-            Some((code, _)) => Some(quote! { #code }),\n-            None if is_suggestion => {\n-                span_err(self.span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                Some(quote! { /* macro error */ \"...\" })\n+        let init = match &kind {\n+            SubdiagnosticKind::Label\n+            | SubdiagnosticKind::Note\n+            | SubdiagnosticKind::Help\n+            | SubdiagnosticKind::Warn\n+            | SubdiagnosticKind::Suggestion { .. } => quote! {},\n+            SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                quote! { let mut suggestions = Vec::new(); }\n             }\n-            None => None,\n         };\n \n+        let attr_args: TokenStream = self\n+            .variant\n+            .bindings()\n+            .iter()\n+            .filter(|binding| !binding.ast().attrs.is_empty())\n+            .map(|binding| self.generate_field_attr_code(binding, &kind))\n+            .collect();\n+\n         let span_field = self.span_field.as_ref().map(|(span, _)| span);\n-        let applicability = match self.applicability.clone() {\n-            Some((applicability, _)) => Some(applicability),\n-            None if is_suggestion => {\n-                span_err(self.span, \"suggestion without `applicability`\").emit();\n-                Some(quote! { rustc_errors::Applicability::Unspecified })\n-            }\n-            None => None,\n-        };\n+        let applicability = self.applicability.take().map_or_else(\n+            || quote! { rustc_errors::Applicability::Unspecified },\n+            |(applicability, _)| applicability,\n+        );\n \n         let diag = &self.diag;\n         let name = format_ident!(\"{}{}\", if span_field.is_some() { \"span_\" } else { \"\" }, kind);\n         let message = quote! { rustc_errors::fluent::#slug };\n-        let call = if matches!(kind, SubdiagnosticKind::Suggestion(..)) {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message, #code, #applicability); }\n-            } else {\n-                span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n-                quote! { unreachable!(); }\n+        let call = match kind {\n+            SubdiagnosticKind::Suggestion { suggestion_kind, code } => {\n+                if let Some(span) = span_field {\n+                    let style = suggestion_kind.to_suggestion_style();\n+\n+                    quote! { #diag.#name(#span, #message, #code, #applicability, #style); }\n+                } else {\n+                    span_err(self.span, \"suggestion without `#[primary_span]` field\").emit();\n+                    quote! { unreachable!(); }\n+                }\n             }\n-        } else if matches!(kind, SubdiagnosticKind::Label) {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message); }\n-            } else {\n-                span_err(self.span, \"label without `#[primary_span]` field\").emit();\n-                quote! { unreachable!(); }\n+            SubdiagnosticKind::MultipartSuggestion { suggestion_kind } => {\n+                if !self.has_suggestion_parts {\n+                    span_err(\n+                        self.span,\n+                        \"multipart suggestion without any `#[suggestion_part(...)]` fields\",\n+                    )\n+                    .emit();\n+                }\n+\n+                let style = suggestion_kind.to_suggestion_style();\n+\n+                quote! { #diag.#name(#message, suggestions, #applicability, #style); }\n             }\n-        } else {\n-            if let Some(span) = span_field {\n-                quote! { #diag.#name(#span, #message); }\n-            } else {\n-                quote! { #diag.#name(#message); }\n+            SubdiagnosticKind::Label => {\n+                if let Some(span) = span_field {\n+                    quote! { #diag.#name(#span, #message); }\n+                } else {\n+                    span_err(self.span, \"label without `#[primary_span]` field\").emit();\n+                    quote! { unreachable!(); }\n+                }\n+            }\n+            _ => {\n+                if let Some(span) = span_field {\n+                    quote! { #diag.#name(#span, #message); }\n+                } else {\n+                    quote! { #diag.#name(#message); }\n+                }\n             }\n         };\n \n+        let plain_args: TokenStream = self\n+            .variant\n+            .bindings()\n+            .iter()\n+            .filter(|binding| binding.ast().attrs.is_empty())\n+            .map(|binding| self.generate_field_set_arg(binding))\n+            .collect();\n+\n         Ok(quote! {\n+            #init\n+            #attr_args\n             #call\n-            #args\n+            #plain_args\n         })\n     }\n }"}, {"sha": "20ee5dfc7279844b171ab30f71fd380fc101b0ed", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -171,8 +171,13 @@ decl_derive!(\n         suggestion_short,\n         suggestion_hidden,\n         suggestion_verbose,\n+        multipart_suggestion,\n+        multipart_suggestion_short,\n+        multipart_suggestion_hidden,\n+        multipart_suggestion_verbose,\n         // field attributes\n         skip_arg,\n         primary_span,\n+        suggestion_part,\n         applicability)] => diagnostics::session_subdiagnostic_derive\n );"}, {"sha": "57555433f55b745b54247219bbd1846116c16463", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -844,6 +844,12 @@ impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for Vec<T> {\n     }\n }\n \n+impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for &[T] {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         self.try_map_id(|t| t.try_fold_with(folder))"}, {"sha": "aa73625ff810cc6a100823be9817de4cf2cc826e", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -944,9 +944,11 @@ supported_targets! {\n \n     (\"aarch64-unknown-openbsd\", aarch64_unknown_openbsd),\n     (\"i686-unknown-openbsd\", i686_unknown_openbsd),\n+    (\"powerpc-unknown-openbsd\", powerpc_unknown_openbsd),\n+    (\"powerpc64-unknown-openbsd\", powerpc64_unknown_openbsd),\n+    (\"riscv64gc-unknown-openbsd\", riscv64gc_unknown_openbsd),\n     (\"sparc64-unknown-openbsd\", sparc64_unknown_openbsd),\n     (\"x86_64-unknown-openbsd\", x86_64_unknown_openbsd),\n-    (\"powerpc-unknown-openbsd\", powerpc_unknown_openbsd),\n \n     (\"aarch64-unknown-netbsd\", aarch64_unknown_netbsd),\n     (\"armv6-unknown-netbsd-eabihf\", armv6_unknown_netbsd_eabihf),"}, {"sha": "9cb3a67dc58b3d8b0ef3f1b1a04c4862d3c80cbe", "filename": "compiler/rustc_target/src/spec/powerpc64_unknown_openbsd.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fpowerpc64_unknown_openbsd.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -0,0 +1,17 @@\n+use crate::abi::Endian;\n+use crate::spec::{LinkerFlavor, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    let mut base = super::openbsd_base::opts();\n+    base.cpu = \"ppc64\".into();\n+    base.add_pre_link_args(LinkerFlavor::Gcc, &[\"-m64\"]);\n+    base.max_atomic_width = Some(64);\n+\n+    Target {\n+        llvm_target: \"powerpc64-unknown-openbsd\".into(),\n+        pointer_width: 64,\n+        data_layout: \"E-m:e-i64:64-n32:64\".into(),\n+        arch: \"powerpc64\".into(),\n+        options: TargetOptions { endian: Endian::Big, mcount: \"_mcount\".into(), ..base },\n+    }\n+}"}, {"sha": "cd10f3afaac06362542da6b58d332f1ee2b929bf", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_openbsd.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_openbsd.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -0,0 +1,18 @@\n+use crate::spec::{CodeModel, Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        llvm_target: \"riscv64-unknown-openbsd\".into(),\n+        pointer_width: 64,\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        arch: \"riscv64\".into(),\n+        options: TargetOptions {\n+            code_model: Some(CodeModel::Medium),\n+            cpu: \"generic-rv64\".into(),\n+            features: \"+m,+a,+f,+d,+c\".into(),\n+            llvm_abiname: \"lp64d\".into(),\n+            max_atomic_width: Some(64),\n+            ..super::openbsd_base::opts()\n+        },\n+    }\n+}"}, {"sha": "f6596950c2a0deb1588da939c3e868914c4dc4e6", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 42, "deletions": 60, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -21,7 +21,6 @@ use crate::errors::{\n };\n use crate::type_error_struct;\n \n-use super::suggest_call_constructor;\n use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n@@ -44,7 +43,7 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::error::TypeError::FieldMisMatch;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TypeVisitable};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -2141,15 +2140,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n     ) -> Ty<'tcx> {\n         debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n-        let expr_t = self.check_expr(base);\n-        let expr_t = self.structurally_resolved_type(base.span, expr_t);\n+        let base_ty = self.check_expr(base);\n+        let base_ty = self.structurally_resolved_type(base.span, base_ty);\n         let mut private_candidate = None;\n-        let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n-            debug!(\"base_t: {:?}\", base_t);\n-            match base_t.kind() {\n+        let mut autoderef = self.autoderef(expr.span, base_ty);\n+        while let Some((deref_base_ty, _)) = autoderef.next() {\n+            debug!(\"deref_base_ty: {:?}\", deref_base_ty);\n+            match deref_base_ty.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n-                    debug!(\"struct named {:?}\", base_t);\n+                    debug!(\"struct named {:?}\", deref_base_ty);\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident_and_get_scope(field, base_def.did(), self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n@@ -2197,23 +2196,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, expr_t, field, did);\n+            self.ban_private_field_access(expr, base_ty, field, did);\n             return field_ty;\n         }\n \n         if field.name == kw::Empty {\n-        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n-            self.ban_take_value_of_method(expr, expr_t, field);\n-        } else if !expr_t.is_primitive_ty() {\n-            self.ban_nonexisting_field(field, base, expr, expr_t);\n+        } else if self.method_exists(field, base_ty, expr.hir_id, true) {\n+            self.ban_take_value_of_method(expr, base_ty, field);\n+        } else if !base_ty.is_primitive_ty() {\n+            self.ban_nonexisting_field(field, base, expr, base_ty);\n         } else {\n             let field_name = field.to_string();\n             let mut err = type_error_struct!(\n                 self.tcx().sess,\n                 field.span,\n-                expr_t,\n+                base_ty,\n                 E0610,\n-                \"`{expr_t}` is a primitive type and therefore doesn't have fields\",\n+                \"`{base_ty}` is a primitive type and therefore doesn't have fields\",\n             );\n             let is_valid_suffix = |field: &str| {\n                 if field == \"f32\" || field == \"f64\" {\n@@ -2251,7 +2250,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     None\n                 }\n             };\n-            if let ty::Infer(ty::IntVar(_)) = expr_t.kind()\n+            if let ty::Infer(ty::IntVar(_)) = base_ty.kind()\n                 && let ExprKind::Lit(Spanned {\n                     node: ast::LitKind::Int(_, ast::LitIntType::Unsuffixed),\n                     ..\n@@ -2280,35 +2279,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx().ty_error()\n     }\n \n-    fn check_call_constructor(\n-        &self,\n-        err: &mut Diagnostic,\n-        base: &'tcx hir::Expr<'tcx>,\n-        def_id: DefId,\n-    ) {\n-        if let Some(local_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_id);\n-            let node = self.tcx.hir().get(hir_id);\n-\n-            if let Some(fields) = node.tuple_fields() {\n-                let kind = match self.tcx.opt_def_kind(local_id) {\n-                    Some(DefKind::Ctor(of, _)) => of,\n-                    _ => return,\n-                };\n-\n-                suggest_call_constructor(base.span, kind, fields.len(), err);\n-            }\n-        } else {\n-            // The logic here isn't smart but `associated_item_def_ids`\n-            // doesn't work nicely on local.\n-            if let DefKind::Ctor(of, _) = self.tcx.def_kind(def_id) {\n-                let parent_def_id = self.tcx.parent(def_id);\n-                let fields = self.tcx.associated_item_def_ids(parent_def_id);\n-                suggest_call_constructor(base.span, of, fields.len(), err);\n-            }\n-        }\n-    }\n-\n     fn suggest_await_on_field_access(\n         &self,\n         err: &mut Diagnostic,\n@@ -2351,40 +2321,52 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_nonexisting_field(\n         &self,\n-        field: Ident,\n+        ident: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n-        expr_t: Ty<'tcx>,\n+        base_ty: Ty<'tcx>,\n     ) {\n         debug!(\n-            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, expr_ty={:?}\",\n-            field, base, expr, expr_t\n+            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, base_ty={:?}\",\n+            ident, base, expr, base_ty\n         );\n-        let mut err = self.no_such_field_err(field, expr_t, base.hir_id);\n+        let mut err = self.no_such_field_err(ident, base_ty, base.hir_id);\n \n-        match *expr_t.peel_refs().kind() {\n+        match *base_ty.peel_refs().kind() {\n             ty::Array(_, len) => {\n-                self.maybe_suggest_array_indexing(&mut err, expr, base, field, len);\n+                self.maybe_suggest_array_indexing(&mut err, expr, base, ident, len);\n             }\n             ty::RawPtr(..) => {\n-                self.suggest_first_deref_field(&mut err, expr, base, field);\n+                self.suggest_first_deref_field(&mut err, expr, base, ident);\n             }\n             ty::Adt(def, _) if !def.is_enum() => {\n-                self.suggest_fields_on_recordish(&mut err, def, field, expr.span);\n+                self.suggest_fields_on_recordish(&mut err, def, ident, expr.span);\n             }\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n             ty::Opaque(_, _) => {\n-                self.suggest_await_on_field_access(&mut err, field, base, expr_t.peel_refs());\n-            }\n-            ty::FnDef(def_id, _) => {\n-                self.check_call_constructor(&mut err, base, def_id);\n+                self.suggest_await_on_field_access(&mut err, ident, base, base_ty.peel_refs());\n             }\n             _ => {}\n         }\n \n-        if field.name == kw::Await {\n+        self.suggest_fn_call(&mut err, base, base_ty, |output_ty| {\n+            if let ty::Adt(def, _) = output_ty.kind() && !def.is_enum() {\n+                def.non_enum_variant().fields.iter().any(|field| {\n+                    field.ident(self.tcx) == ident\n+                        && field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx)\n+                })\n+            } else if let ty::Tuple(tys) = output_ty.kind()\n+                && let Ok(idx) = ident.as_str().parse::<usize>()\n+            {\n+                idx < tys.len()\n+            } else {\n+                false\n+            }\n+        });\n+\n+        if ident.name == kw::Await {\n             // We know by construction that `<expr>.await` is either on Rust 2015\n             // or results in `ExprKind::Await`. Suggest switching the edition to 2018.\n             err.note(\"to `.await` a `Future`, switch to Rust 2018 or later\");"}, {"sha": "939f4612d44ef6688010343717549e3ce8a0d2a6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 214, "deletions": 55, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,6 +2,7 @@ use super::FnCtxt;\n use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n+use hir::def_id::DefId;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -61,70 +62,51 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pointing_at_return_type\n     }\n \n-    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n-    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n+    /// When encountering an fn-like type, try accessing the output of the type\n+    /// // and suggesting calling it if it satisfies a predicate (i.e. if the\n+    /// output has a method or a field):\n     /// ```compile_fail,E0308\n     /// fn foo(x: usize) -> usize { x }\n     /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n     /// ```\n-    fn suggest_fn_call(\n+    pub(crate) fn suggest_fn_call(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        can_satisfy: impl FnOnce(Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let (def_id, output, inputs) = match *found.kind() {\n-            ty::FnDef(def_id, _) => {\n-                let fn_sig = found.fn_sig(self.tcx);\n-                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len())\n-            }\n-            ty::Closure(def_id, substs) => {\n-                let fn_sig = substs.as_closure().sig();\n-                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len() - 1)\n-            }\n-            ty::Opaque(def_id, substs) => {\n-                let sig = self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            args.len(),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                });\n-                if let Some((output, inputs)) = sig {\n-                    (def_id, output, inputs)\n-                } else {\n-                    return false;\n-                }\n-            }\n-            _ => return false,\n-        };\n-\n-        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n-        let output = self.normalize_associated_types_in(expr.span, output);\n-        if !output.is_ty_var() && self.can_coerce(output, expected) {\n-            let (sugg_call, mut applicability) = match inputs {\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(expr, found)\n+            else { return false; };\n+        if can_satisfy(output) {\n+            let (sugg_call, mut applicability) = match inputs.len() {\n                 0 => (\"\".to_string(), Applicability::MachineApplicable),\n                 1..=4 => (\n-                    (0..inputs).map(|_| \"_\").collect::<Vec<_>>().join(\", \"),\n-                    Applicability::MachineApplicable,\n+                    inputs\n+                        .iter()\n+                        .map(|ty| {\n+                            if ty.is_suggestable(self.tcx, false) {\n+                                format!(\"/* {ty} */\")\n+                            } else {\n+                                \"\".to_string()\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"),\n+                    Applicability::HasPlaceholders,\n                 ),\n-                _ => (\"...\".to_string(), Applicability::HasPlaceholders),\n+                _ => (\"/* ... */\".to_string(), Applicability::HasPlaceholders),\n             };\n \n-            let msg = match self.tcx.def_kind(def_id) {\n-                DefKind::Fn => \"call this function\",\n-                DefKind::Closure | DefKind::OpaqueTy => \"call this closure\",\n-                DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\",\n-                DefKind::Ctor(CtorOf::Variant, _) => \"instantiate this tuple variant\",\n-                _ => \"call this function\",\n+            let msg = match def_id_or_name {\n+                DefIdOrName::DefId(def_id) => match self.tcx.def_kind(def_id) {\n+                    DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\".to_string(),\n+                    DefKind::Ctor(CtorOf::Variant, _) => {\n+                        \"instantiate this tuple variant\".to_string()\n+                    }\n+                    kind => format!(\"call this {}\", kind.descr(def_id)),\n+                },\n+                DefIdOrName::Name(name) => format!(\"call this {name}\"),\n             };\n \n             let sugg = match expr.kind {\n@@ -161,6 +143,179 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    fn extract_callable_info(\n+        &self,\n+        expr: &Expr<'_>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n+        // Autoderef is useful here because sometimes we box callables, etc.\n+        let Some((def_id_or_name, output, inputs)) = self.autoderef(expr.span, found).silence_errors().find_map(|(found, _)| {\n+            match *found.kind() {\n+                ty::FnPtr(fn_sig) =>\n+                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n+                ty::FnDef(def_id, _) => {\n+                    let fn_sig = found.fn_sig(self.tcx);\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n+                }\n+                ty::Closure(def_id, substs) => {\n+                    let fn_sig = substs.as_closure().sig();\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n+                }\n+                ty::Opaque(def_id, substs) => {\n+                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::DefId(def_id),\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Dynamic(data, _) => {\n+                    data.iter().find_map(|pred| {\n+                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n+                        && Some(proj.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        // for existential projection, substs are shifted over by 1\n+                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::Name(\"trait object\"),\n+                                pred.rebind(proj.term.ty().unwrap()),\n+                                pred.rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Param(param) => {\n+                    let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n+                    self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n+                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && proj.projection_ty.self_ty() == found\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::DefId(def_id),\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                _ => None,\n+            }\n+        }) else { return None; };\n+\n+        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n+        let inputs = inputs\n+            .skip_binder()\n+            .iter()\n+            .map(|ty| {\n+                self.replace_bound_vars_with_fresh_vars(\n+                    expr.span,\n+                    infer::FnCall,\n+                    inputs.rebind(*ty),\n+                )\n+            })\n+            .collect();\n+\n+        // We don't want to register any extra obligations, which should be\n+        // implied by wf, but also because that would possibly result in\n+        // erroneous errors later on.\n+        let infer::InferOk { value: output, obligations: _ } =\n+            self.normalize_associated_types_in_as_infer_ok(expr.span, output);\n+\n+        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+    }\n+\n+    pub fn suggest_two_fn_call(\n+        &self,\n+        err: &mut Diagnostic,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        lhs_ty: Ty<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_ty: Ty<'tcx>,\n+        can_satisfy: impl FnOnce(Ty<'tcx>, Ty<'tcx>) -> bool,\n+    ) -> bool {\n+        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_expr, lhs_ty)\n+            else { return false; };\n+        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_expr, rhs_ty)\n+            else { return false; };\n+\n+        if can_satisfy(lhs_output_ty, rhs_output_ty) {\n+            let mut sugg = vec![];\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            for (expr, inputs) in [(lhs_expr, lhs_inputs), (rhs_expr, rhs_inputs)] {\n+                let (sugg_call, this_applicability) = match inputs.len() {\n+                    0 => (\"\".to_string(), Applicability::MachineApplicable),\n+                    1..=4 => (\n+                        inputs\n+                            .iter()\n+                            .map(|ty| {\n+                                if ty.is_suggestable(self.tcx, false) {\n+                                    format!(\"/* {ty} */\")\n+                                } else {\n+                                    \"/* value */\".to_string()\n+                                }\n+                            })\n+                            .collect::<Vec<_>>()\n+                            .join(\", \"),\n+                        Applicability::HasPlaceholders,\n+                    ),\n+                    _ => (\"/* ... */\".to_string(), Applicability::HasPlaceholders),\n+                };\n+\n+                applicability = applicability.max(this_applicability);\n+\n+                match expr.kind {\n+                    hir::ExprKind::Call(..)\n+                    | hir::ExprKind::Path(..)\n+                    | hir::ExprKind::Index(..)\n+                    | hir::ExprKind::Lit(..) => {\n+                        sugg.extend([(expr.span.shrink_to_hi(), format!(\"({sugg_call})\"))]);\n+                    }\n+                    hir::ExprKind::Closure { .. } => {\n+                        // Might be `{ expr } || { bool }`\n+                        applicability = Applicability::MaybeIncorrect;\n+                        sugg.extend([\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                        ]);\n+                    }\n+                    _ => {\n+                        sugg.extend([\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                        ]);\n+                    }\n+                }\n+            }\n+\n+            err.multipart_suggestion_verbose(\n+                format!(\"use parentheses to call these\"),\n+                sugg,\n+                applicability,\n+            );\n+\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     pub fn suggest_deref_ref_or_into(\n         &self,\n         err: &mut Diagnostic,\n@@ -178,12 +333,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n-        } else if let (ty::FnDef(def_id, ..), true) =\n-            (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n+        } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n+            && let ty::FnDef(def_id, ..) = &found.kind()\n+            && let Some(sp) = self.tcx.hir().span_if_local(*def_id)\n         {\n-            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n-                err.span_label(sp, format!(\"{found} defined here\"));\n-            }\n+            err.span_label(sp, format!(\"{found} defined here\"));\n         } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {\n@@ -911,3 +1065,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+enum DefIdOrName {\n+    DefId(DefId),\n+    Name(&'static str),\n+}"}, {"sha": "e99782fdc652c5e668064787420e8a96b4d70890", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -31,7 +31,7 @@ use std::cmp::Ordering;\n use std::iter;\n \n use super::probe::{Mode, ProbeScope};\n-use super::{super::suggest_call_constructor, CandidateSource, MethodError, NoMatchData};\n+use super::{CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn is_fn_ty(&self, ty: Ty<'tcx>, span: Span) -> bool {\n@@ -363,44 +363,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                if self.is_fn_ty(rcvr_ty, span) {\n-                    if let SelfSource::MethodCall(expr) = source {\n-                        let suggest = if let ty::FnDef(def_id, _) = rcvr_ty.kind() {\n-                            if let Some(local_id) = def_id.as_local() {\n-                                let hir_id = tcx.hir().local_def_id_to_hir_id(local_id);\n-                                let node = tcx.hir().get(hir_id);\n-                                let fields = node.tuple_fields();\n-                                if let Some(fields) = fields\n-                                    && let Some(DefKind::Ctor(of, _)) = self.tcx.opt_def_kind(local_id) {\n-                                        Some((fields.len(), of))\n-                                } else {\n-                                    None\n-                                }\n-                            } else {\n-                                // The logic here isn't smart but `associated_item_def_ids`\n-                                // doesn't work nicely on local.\n-                                if let DefKind::Ctor(of, _) = tcx.def_kind(def_id) {\n-                                    let parent_def_id = tcx.parent(*def_id);\n-                                    Some((tcx.associated_item_def_ids(parent_def_id).len(), of))\n-                                } else {\n-                                    None\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        };\n-\n-                        // If the function is a tuple constructor, we recommend that they call it\n-                        if let Some((fields, kind)) = suggest {\n-                            suggest_call_constructor(expr.span, kind, fields, &mut err);\n-                        } else {\n-                            // General case\n-                            err.span_label(\n-                                expr.span,\n-                                \"this is a function, perhaps you wish to call it\",\n-                            );\n-                        }\n-                    }\n+                if let SelfSource::MethodCall(rcvr_expr) = source {\n+                    self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n+                        let call_expr = self\n+                            .tcx\n+                            .hir()\n+                            .expect_expr(self.tcx.hir().get_parent_node(rcvr_expr.hir_id));\n+                        let probe = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            output_ty,\n+                            call_expr,\n+                            ProbeScope::AllTraits,\n+                        );\n+                        probe.is_ok()\n+                    });\n                 }\n \n                 let mut custom_span_label = false;"}, {"sha": "3281dd8298bc3000526cc5bb55fdd577e9235933", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -96,7 +96,6 @@ use check::{check_abi, check_fn, check_mod_item_types};\n pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::*;\n-use hir::def::CtorOf;\n pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;\n@@ -960,31 +959,3 @@ fn has_expected_num_generic_args<'tcx>(\n         generics.count() == expected + if generics.has_self { 1 } else { 0 }\n     })\n }\n-\n-/// Suggests calling the constructor of a tuple struct or enum variant\n-///\n-/// * `snippet` - The snippet of code that references the constructor\n-/// * `span` - The span of the snippet\n-/// * `params` - The number of parameters the constructor accepts\n-/// * `err` - A mutable diagnostic builder to add the suggestion to\n-fn suggest_call_constructor(span: Span, kind: CtorOf, params: usize, err: &mut Diagnostic) {\n-    // Note: tuple-structs don't have named fields, so just use placeholders\n-    let args = vec![\"_\"; params].join(\", \");\n-    let applicable = if params > 0 {\n-        Applicability::HasPlaceholders\n-    } else {\n-        // When n = 0, it's an empty-tuple struct/enum variant\n-        // so we trivially know how to construct it\n-        Applicability::MachineApplicable\n-    };\n-    let kind = match kind {\n-        CtorOf::Struct => \"a struct\",\n-        CtorOf::Variant => \"an enum variant\",\n-    };\n-    err.span_label(span, &format!(\"this is the constructor of {kind}\"));\n-    err.multipart_suggestion(\n-        \"call the constructor\",\n-        vec![(span.shrink_to_lo(), \"(\".to_string()), (span.shrink_to_hi(), format!(\")({args})\"))],\n-        applicable,\n-    );\n-}"}, {"sha": "952086e898fc70011fa22d1a19402c0bfab75bb5", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 40, "deletions": 88, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -410,26 +410,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n                         let mut err = struct_span_err!(self.tcx.sess, op.span, E0369, \"{message}\");\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n-                            self.add_type_neq_err_label(\n-                                &mut err,\n-                                lhs_expr.span,\n-                                lhs_ty,\n-                                rhs_ty,\n-                                rhs_expr,\n-                                op,\n-                                is_assign,\n-                                expected,\n-                            );\n-                            self.add_type_neq_err_label(\n-                                &mut err,\n-                                rhs_expr.span,\n-                                rhs_ty,\n-                                lhs_ty,\n-                                lhs_expr,\n-                                op,\n-                                is_assign,\n-                                expected,\n-                            );\n+                            err.span_label(lhs_expr.span, lhs_ty.to_string());\n+                            err.span_label(rhs_expr.span, rhs_ty.to_string());\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n                         (err, missing_trait, use_output)\n@@ -468,17 +450,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n \n+                let is_compatible = |lhs_ty, rhs_ty| {\n+                    self.lookup_op_method(\n+                        lhs_ty,\n+                        Some(rhs_ty),\n+                        Some(rhs_expr),\n+                        Op::Binary(op, is_assign),\n+                        expected,\n+                    )\n+                    .is_ok()\n+                };\n+\n                 // We should suggest `a + b` => `*a + b` if `a` is copy, and suggest\n                 // `a += b` => `*a += b` if a is a mut ref.\n-                if is_assign == IsAssign::Yes\n-                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n-                        suggest_deref_binop(lhs_deref_ty);\n+                if !op.span.can_be_used_for_suggestions() {\n+                    // Suppress suggestions when lhs and rhs are not in the same span as the error\n+                } else if is_assign == IsAssign::Yes\n+                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty)\n+                {\n+                    suggest_deref_binop(lhs_deref_ty);\n                 } else if is_assign == IsAssign::No\n-                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind() {\n-                    if self.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n+                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind()\n+                {\n+                    if self.type_is_copy_modulo_regions(\n+                        self.param_env,\n+                        *lhs_deref_ty,\n+                        lhs_expr.span,\n+                    ) {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n+                } else if self.suggest_fn_call(&mut err, lhs_expr, lhs_ty, |lhs_ty| {\n+                    is_compatible(lhs_ty, rhs_ty)\n+                }) || self.suggest_fn_call(&mut err, rhs_expr, rhs_ty, |rhs_ty| {\n+                    is_compatible(lhs_ty, rhs_ty)\n+                }) || self.suggest_two_fn_call(\n+                    &mut err,\n+                    rhs_expr,\n+                    rhs_ty,\n+                    lhs_expr,\n+                    lhs_ty,\n+                    |lhs_ty, rhs_ty| is_compatible(lhs_ty, rhs_ty),\n+                ) {\n+                    // Cool\n                 }\n+\n                 if let Some(missing_trait) = missing_trait {\n                     let mut visitor = TypeParamVisitor(vec![]);\n                     visitor.visit_ty(lhs_ty);\n@@ -548,69 +563,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (lhs_ty, rhs_ty, return_ty)\n     }\n \n-    /// If one of the types is an uncalled function and calling it would yield the other type,\n-    /// suggest calling the function. Returns `true` if suggestion would apply (even if not given).\n-    fn add_type_neq_err_label(\n-        &self,\n-        err: &mut Diagnostic,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-        other_ty: Ty<'tcx>,\n-        other_expr: &'tcx hir::Expr<'tcx>,\n-        op: hir::BinOp,\n-        is_assign: IsAssign,\n-        expected: Expectation<'tcx>,\n-    ) -> bool /* did we suggest to call a function because of missing parentheses? */ {\n-        err.span_label(span, ty.to_string());\n-        if let FnDef(def_id, _) = *ty.kind() {\n-            if !self.tcx.has_typeck_results(def_id) {\n-                return false;\n-            }\n-            // FIXME: Instead of exiting early when encountering bound vars in\n-            // the function signature, consider keeping the binder here and\n-            // propagating it downwards.\n-            let Some(fn_sig) = self.tcx.fn_sig(def_id).no_bound_vars() else {\n-                return false;\n-            };\n-\n-            let other_ty = if let FnDef(def_id, _) = *other_ty.kind() {\n-                if !self.tcx.has_typeck_results(def_id) {\n-                    return false;\n-                }\n-                // We're emitting a suggestion, so we can just ignore regions\n-                self.tcx.fn_sig(def_id).skip_binder().output()\n-            } else {\n-                other_ty\n-            };\n-\n-            if self\n-                .lookup_op_method(\n-                    fn_sig.output(),\n-                    Some(other_ty),\n-                    Some(other_expr),\n-                    Op::Binary(op, is_assign),\n-                    expected,\n-                )\n-                .is_ok()\n-            {\n-                let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n-                    (\"( /* arguments */ )\", Applicability::HasPlaceholders)\n-                } else {\n-                    (\"()\", Applicability::MaybeIncorrect)\n-                };\n-\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"you might have forgotten to call this function\",\n-                    variable_snippet,\n-                    applicability,\n-                );\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     /// Provide actionable suggestions when trying to add two strings with incorrect types,\n     /// like `&str + &str`, `String + String` and `&str + &String`.\n     ///"}, {"sha": "ba42453bd60e920286239085eeb96203479087a8", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1262,7 +1262,11 @@ fn check_impl<'tcx>(\n             }\n             None => {\n                 let self_ty = tcx.type_of(item.def_id);\n-                let self_ty = wfcx.normalize(item.span, None, self_ty);\n+                let self_ty = wfcx.normalize(\n+                    item.span,\n+                    Some(WellFormedLoc::Ty(item.hir_id().expect_owner())),\n+                    self_ty,\n+                );\n                 wfcx.register_wf_obligation(\n                     ast_self_ty.span,\n                     Some(WellFormedLoc::Ty(item.hir_id().expect_owner())),\n@@ -1307,7 +1311,11 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n                     if !ty.needs_subst() {\n-                        wfcx.register_wf_obligation(tcx.def_span(param.def_id), None, ty.into());\n+                        wfcx.register_wf_obligation(\n+                            tcx.def_span(param.def_id),\n+                            Some(WellFormedLoc::Ty(param.def_id.expect_local())),\n+                            ty.into(),\n+                        );\n                     }\n                 }\n             }\n@@ -1512,7 +1520,14 @@ fn check_fn_or_method<'tcx>(\n         );\n     }\n \n-    wfcx.register_wf_obligation(hir_decl.output.span(), None, sig.output().into());\n+    wfcx.register_wf_obligation(\n+        hir_decl.output.span(),\n+        Some(WellFormedLoc::Param {\n+            function: def_id,\n+            param_idx: sig.inputs().len().try_into().unwrap(),\n+        }),\n+        sig.output().into(),\n+    );\n \n     check_where_clauses(wfcx, span, def_id);\n }"}, {"sha": "7b080dc2942e06afb03b6642821be02055e5a6cc", "filename": "compiler/rustc_typeck/src/hir_wf_check.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fhir_wf_check.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -140,6 +140,10 @@ fn diagnostic_hir_wf_check<'tcx>(\n             hir::Node::ForeignItem(ForeignItem {\n                 kind: ForeignItemKind::Static(ty, _), ..\n             }) => Some(*ty),\n+            hir::Node::GenericParam(hir::GenericParam {\n+                kind: hir::GenericParamKind::Type { default: Some(ty), .. },\n+                ..\n+            }) => Some(*ty),\n             ref node => bug!(\"Unexpected node {:?}\", node),\n         },\n         WellFormedLoc::Param { function: _, param_idx } => {"}, {"sha": "40885417308b80a2007591f17af0984a44215831", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 56, "deletions": 38, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -137,11 +137,9 @@ mod imp {\n     }\n }\n \n-#[cfg(target_os = \"macos\")]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n mod imp {\n-    use crate::fs::File;\n-    use crate::io::Read;\n-    use crate::sys::os::errno;\n+    use crate::io;\n     use crate::sys::weak::weak;\n     use libc::{c_int, c_void, size_t};\n \n@@ -155,22 +153,72 @@ mod imp {\n                 for s in v.chunks_mut(256) {\n                     let ret = unsafe { f(s.as_mut_ptr() as *mut c_void, s.len()) };\n                     if ret == -1 {\n-                        panic!(\"unexpected getentropy error: {}\", errno());\n+                        panic!(\"unexpected getentropy error: {}\", io::Error::last_os_error());\n                     }\n                 }\n                 true\n             })\n             .unwrap_or(false)\n     }\n \n+    #[cfg(target_os = \"macos\")]\n+    fn fallback_fill_bytes(v: &mut [u8]) {\n+        use crate::fs::File;\n+        use crate::io::Read;\n+\n+        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n+        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n+    }\n+\n+    // On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n+    // `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n+    // from `/dev/random` and which runs on its own thread accessed via GCD.\n+    //\n+    // This is very heavyweight compared to the alternatives, but they may not be usable:\n+    // - `getentropy` was added in iOS 10, but we support a minimum of iOS 7\n+    // - `/dev/urandom` is not accessible inside the iOS app sandbox.\n+    //\n+    // Therefore `SecRandomCopyBytes` is only used on older iOS versions where no\n+    // better options are present.\n+    #[cfg(target_os = \"ios\")]\n+    fn fallback_fill_bytes(v: &mut [u8]) {\n+        use crate::ptr;\n+\n+        enum SecRandom {}\n+\n+        #[allow(non_upper_case_globals)]\n+        const kSecRandomDefault: *const SecRandom = ptr::null();\n+\n+        extern \"C\" {\n+            fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n+        }\n+\n+        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n+        if ret == -1 {\n+            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n+        }\n+    }\n+\n+    // All supported versions of watchOS (>= 5) have support for `getentropy`.\n+    #[cfg(target_os = \"watchos\")]\n+    #[cold]\n+    fn fallback_fill_bytes(_: &mut [u8]) {\n+        unreachable!()\n+    }\n+\n     pub fn fill_bytes(v: &mut [u8]) {\n         if getentropy_fill_bytes(v) {\n             return;\n         }\n \n-        // for older macos which doesn't support getentropy\n-        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n-        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n+        // Older macOS versions (< 10.12) don't support `getentropy`. Fallback to\n+        // reading from `/dev/urandom` on these systems.\n+        //\n+        // Older iOS versions (< 10) don't support it either. Fallback to\n+        // `SecRandomCopyBytes` on these systems. On watchOS, this is unreachable\n+        // because the minimum supported version is 5 while `getentropy` became accessible\n+        // in 3.\n+        fallback_fill_bytes(v)\n     }\n }\n \n@@ -189,36 +237,6 @@ mod imp {\n     }\n }\n \n-// On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n-// `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n-// from `/dev/random` and which runs on its own thread accessed via GCD.\n-// This seems needlessly heavyweight for the purposes of generating two u64s\n-// once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n-// only used on iOS where direct access to `/dev/urandom` is blocked by the\n-// sandbox.\n-#[cfg(any(target_os = \"ios\", target_os = \"watchos\"))]\n-mod imp {\n-    use crate::io;\n-    use crate::ptr;\n-    use libc::{c_int, size_t};\n-\n-    enum SecRandom {}\n-\n-    #[allow(non_upper_case_globals)]\n-    const kSecRandomDefault: *const SecRandom = ptr::null();\n-\n-    extern \"C\" {\n-        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n-    }\n-\n-    pub fn fill_bytes(v: &mut [u8]) {\n-        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n-        if ret == -1 {\n-            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n-        }\n-    }\n-}\n-\n #[cfg(any(target_os = \"freebsd\", target_os = \"netbsd\"))]\n mod imp {\n     use crate::ptr;"}, {"sha": "c99c8efe4367f18ce174bc6c64d2e8abd66901f3", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -228,8 +228,6 @@ pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n pub const MSG_PEEK: c_int = 0x2;\n \n-pub const LOAD_LIBRARY_SEARCH_SYSTEM32: u32 = 0x800;\n-\n #[repr(C)]\n #[derive(Copy, Clone)]\n pub struct linger {\n@@ -503,6 +501,8 @@ pub struct FILE_END_OF_FILE_INFO {\n     pub EndOfFile: LARGE_INTEGER,\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `rest` field!\n #[repr(C)]\n pub struct REPARSE_DATA_BUFFER {\n     pub ReparseTag: c_uint,\n@@ -511,6 +511,8 @@ pub struct REPARSE_DATA_BUFFER {\n     pub rest: (),\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `PathBuffer` field!\n #[repr(C)]\n pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub SubstituteNameOffset: c_ushort,\n@@ -521,6 +523,8 @@ pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub PathBuffer: WCHAR,\n }\n \n+/// NB: Use carefully! In general using this as a reference is likely to get the\n+/// provenance wrong for the `PathBuffer` field!\n #[repr(C)]\n pub struct MOUNT_POINT_REPARSE_BUFFER {\n     pub SubstituteNameOffset: c_ushort,\n@@ -1032,7 +1036,6 @@ extern \"system\" {\n     pub fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;\n     pub fn GetModuleHandleA(lpModuleName: LPCSTR) -> HMODULE;\n     pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n-    pub fn LoadLibraryExA(lplibfilename: *const i8, hfile: HANDLE, dwflags: u32) -> HINSTANCE;\n \n     pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n     pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);"}, {"sha": "7dff81ecb8ddeebb6e4d938dad632c198727dc78", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -21,9 +21,52 @@\n \n use crate::ffi::{c_void, CStr};\n use crate::ptr::NonNull;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n+use crate::sync::atomic::Ordering;\n use crate::sys::c;\n \n+// This uses a static initializer to preload some imported functions.\n+// The CRT (C runtime) executes static initializers before `main`\n+// is called (for binaries) and before `DllMain` is called (for DLLs).\n+//\n+// It works by contributing a global symbol to the `.CRT$XCT` section.\n+// The linker builds a table of all static initializer functions.\n+// The CRT startup code then iterates that table, calling each\n+// initializer function.\n+//\n+// NOTE: User code should instead use .CRT$XCU to reliably run after std's initializer.\n+// If you're reading this and would like a guarantee here, please\n+// file an issue for discussion; currently we don't guarantee any functionality\n+// before main.\n+// See https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization?view=msvc-170\n+#[used]\n+#[link_section = \".CRT$XCT\"]\n+static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n+\n+/// Preload some imported functions.\n+///\n+/// Note that any functions included here will be unconditionally loaded in\n+/// the final binary, regardless of whether or not they're actually used.\n+///\n+/// Therefore, this should be limited to `compat_fn_optional` functions which\n+/// must be preloaded or any functions where lazier loading demonstrates a\n+/// negative performance impact in practical situations.\n+///\n+/// Currently we only preload `WaitOnAddress` and `WakeByAddressSingle`.\n+unsafe extern \"C\" fn init() {\n+    // In an exe this code is executed before main() so is single threaded.\n+    // In a DLL the system's loader lock will be held thereby synchronizing\n+    // access. So the same best practices apply here as they do to running in DllMain:\n+    // https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices\n+    //\n+    // DO NOT do anything interesting or complicated in this function! DO NOT call\n+    // any Rust functions or CRT functions if those functions touch any global state,\n+    // because this function runs during global initialization. For example, DO NOT\n+    // do any dynamic allocation, don't call LoadLibrary, etc.\n+\n+    // Attempt to preload the synch functions.\n+    load_synch_functions();\n+}\n+\n /// Helper macro for creating CStrs from literals and symbol names.\n macro_rules! ansi_str {\n     (sym $ident:ident) => {{\n@@ -75,20 +118,6 @@ impl Module {\n         NonNull::new(module).map(Self)\n     }\n \n-    /// Load the library (if not already loaded)\n-    ///\n-    /// # Safety\n-    ///\n-    /// The module must not be unloaded.\n-    pub unsafe fn load_system_library(name: &CStr) -> Option<Self> {\n-        let module = c::LoadLibraryExA(\n-            name.as_ptr(),\n-            crate::ptr::null_mut(),\n-            c::LOAD_LIBRARY_SEARCH_SYSTEM32,\n-        );\n-        NonNull::new(module).map(Self)\n-    }\n-\n     // Try to get the address of a function.\n     pub fn proc_address(self, name: &CStr) -> Option<NonNull<c_void>> {\n         // SAFETY:\n@@ -182,14 +211,10 @@ macro_rules! compat_fn_optional {\n \n                 #[inline(always)]\n                 pub fn option() -> Option<F> {\n-                    let f = PTR.load(Ordering::Acquire);\n-                    if !f.is_null() { Some(unsafe { mem::transmute(f) }) } else { try_load() }\n-                }\n-\n-                #[cold]\n-                fn try_load() -> Option<F> {\n-                    $load_functions;\n-                    NonNull::new(PTR.load(Ordering::Acquire)).map(|f| unsafe { mem::transmute(f) })\n+                    // Miri does not understand the way we do preloading\n+                    // therefore load the function here instead.\n+                    #[cfg(miri)] $load_functions;\n+                    NonNull::new(PTR.load(Ordering::Relaxed)).map(|f| unsafe { mem::transmute(f) })\n                 }\n             }\n         )+\n@@ -205,17 +230,14 @@ pub(super) fn load_synch_functions() {\n \n         // Try loading the library and all the required functions.\n         // If any step fails, then they all fail.\n-        let library = unsafe { Module::load_system_library(MODULE_NAME) }?;\n+        let library = unsafe { Module::new(MODULE_NAME) }?;\n         let wait_on_address = library.proc_address(WAIT_ON_ADDRESS)?;\n         let wake_by_address_single = library.proc_address(WAKE_BY_ADDRESS_SINGLE)?;\n \n-        c::WaitOnAddress::PTR.store(wait_on_address.as_ptr(), Ordering::Release);\n-        c::WakeByAddressSingle::PTR.store(wake_by_address_single.as_ptr(), Ordering::Release);\n+        c::WaitOnAddress::PTR.store(wait_on_address.as_ptr(), Ordering::Relaxed);\n+        c::WakeByAddressSingle::PTR.store(wake_by_address_single.as_ptr(), Ordering::Relaxed);\n         Some(())\n     }\n \n-    // Try to load the module but skip loading if a previous attempt failed.\n-    static LOAD_MODULE: AtomicBool = AtomicBool::new(true);\n-    let module_loaded = LOAD_MODULE.load(Ordering::Acquire) && try_load().is_some();\n-    LOAD_MODULE.store(module_loaded, Ordering::Release)\n+    try_load();\n }"}, {"sha": "0aa7c50ded1c7acfca41ad6c67eaa0dd463171e1", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -11,7 +11,7 @@ use crate::slice;\n use crate::sync::Arc;\n use crate::sys::handle::Handle;\n use crate::sys::time::SystemTime;\n-use crate::sys::{c, cvt};\n+use crate::sys::{c, cvt, Align8};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::thread;\n \n@@ -326,9 +326,9 @@ impl File {\n             cvt(c::GetFileInformationByHandle(self.handle.as_raw_handle(), &mut info))?;\n             let mut reparse_tag = 0;\n             if info.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                let mut b = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                    reparse_tag = buf.ReparseTag;\n+                    reparse_tag = (*buf).ReparseTag;\n                 }\n             }\n             Ok(FileAttr {\n@@ -389,9 +389,9 @@ impl File {\n             attr.file_size = info.AllocationSize as u64;\n             attr.number_of_links = Some(info.NumberOfLinks);\n             if attr.file_type().is_reparse_point() {\n-                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                let mut b = Align8([0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n                 if let Ok((_, buf)) = self.reparse_point(&mut b) {\n-                    attr.reparse_tag = buf.ReparseTag;\n+                    attr.reparse_tag = (*buf).ReparseTag;\n                 }\n             }\n             Ok(attr)\n@@ -458,48 +458,57 @@ impl File {\n         Ok(Self { handle: self.handle.try_clone()? })\n     }\n \n-    fn reparse_point<'a>(\n+    // NB: returned pointer is derived from `space`, and has provenance to\n+    // match. A raw pointer is returned rather than a reference in order to\n+    // avoid narrowing provenance to the actual `REPARSE_DATA_BUFFER`.\n+    fn reparse_point(\n         &self,\n-        space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE],\n-    ) -> io::Result<(c::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n+        space: &mut Align8<[u8]>,\n+    ) -> io::Result<(c::DWORD, *const c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n             let mut bytes = 0;\n             cvt({\n+                // Grab this in advance to avoid it invalidating the pointer\n+                // we get from `space.0.as_mut_ptr()`.\n+                let len = space.0.len();\n                 c::DeviceIoControl(\n                     self.handle.as_raw_handle(),\n                     c::FSCTL_GET_REPARSE_POINT,\n                     ptr::null_mut(),\n                     0,\n-                    space.as_mut_ptr() as *mut _,\n-                    space.len() as c::DWORD,\n+                    space.0.as_mut_ptr().cast(),\n+                    len as c::DWORD,\n                     &mut bytes,\n                     ptr::null_mut(),\n                 )\n             })?;\n-            Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n+            const _: () = assert!(core::mem::align_of::<c::REPARSE_DATA_BUFFER>() <= 8);\n+            Ok((bytes, space.0.as_ptr().cast::<c::REPARSE_DATA_BUFFER>()))\n         }\n     }\n \n     fn readlink(&self) -> io::Result<PathBuf> {\n-        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let mut space = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n         let (_bytes, buf) = self.reparse_point(&mut space)?;\n         unsafe {\n-            let (path_buffer, subst_off, subst_len, relative) = match buf.ReparseTag {\n+            let (path_buffer, subst_off, subst_len, relative) = match (*buf).ReparseTag {\n                 c::IO_REPARSE_TAG_SYMLINK => {\n                     let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n-                        &buf.rest as *const _ as *const _;\n+                        ptr::addr_of!((*buf).rest).cast();\n+                    assert!(info.is_aligned());\n                     (\n-                        &(*info).PathBuffer as *const _ as *const u16,\n+                        ptr::addr_of!((*info).PathBuffer).cast::<u16>(),\n                         (*info).SubstituteNameOffset / 2,\n                         (*info).SubstituteNameLength / 2,\n                         (*info).Flags & c::SYMLINK_FLAG_RELATIVE != 0,\n                     )\n                 }\n                 c::IO_REPARSE_TAG_MOUNT_POINT => {\n                     let info: *const c::MOUNT_POINT_REPARSE_BUFFER =\n-                        &buf.rest as *const _ as *const _;\n+                        ptr::addr_of!((*buf).rest).cast();\n+                    assert!(info.is_aligned());\n                     (\n-                        &(*info).PathBuffer as *const _ as *const u16,\n+                        ptr::addr_of!((*info).PathBuffer).cast::<u16>(),\n                         (*info).SubstituteNameOffset / 2,\n                         (*info).SubstituteNameLength / 2,\n                         false,\n@@ -649,18 +658,18 @@ impl File {\n \n /// A buffer for holding directory entries.\n struct DirBuff {\n-    buffer: Vec<u8>,\n+    buffer: Box<Align8<[u8; Self::BUFFER_SIZE]>>,\n }\n impl DirBuff {\n+    const BUFFER_SIZE: usize = 1024;\n     fn new() -> Self {\n-        const BUFFER_SIZE: usize = 1024;\n-        Self { buffer: vec![0_u8; BUFFER_SIZE] }\n+        Self { buffer: Box::new(Align8([0u8; Self::BUFFER_SIZE])) }\n     }\n     fn capacity(&self) -> usize {\n-        self.buffer.len()\n+        self.buffer.0.len()\n     }\n     fn as_mut_ptr(&mut self) -> *mut u8 {\n-        self.buffer.as_mut_ptr().cast()\n+        self.buffer.0.as_mut_ptr().cast()\n     }\n     /// Returns a `DirBuffIter`.\n     fn iter(&self) -> DirBuffIter<'_> {\n@@ -669,7 +678,7 @@ impl DirBuff {\n }\n impl AsRef<[u8]> for DirBuff {\n     fn as_ref(&self) -> &[u8] {\n-        &self.buffer\n+        &self.buffer.0\n     }\n }\n \n@@ -697,9 +706,12 @@ impl<'a> Iterator for DirBuffIter<'a> {\n         // used to get the file name slice.\n         let (name, is_directory, next_entry) = unsafe {\n             let info = buffer.as_ptr().cast::<c::FILE_ID_BOTH_DIR_INFO>();\n+            // Guaranteed to be aligned in documentation for\n+            // https://docs.microsoft.com/en-us/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info\n+            assert!(info.is_aligned());\n             let next_entry = (*info).NextEntryOffset as usize;\n             let name = crate::slice::from_raw_parts(\n-                (*info).FileName.as_ptr().cast::<u16>(),\n+                ptr::addr_of!((*info).FileName).cast::<u16>(),\n                 (*info).FileNameLength as usize / size_of::<u16>(),\n             );\n             let is_directory = ((*info).FileAttributes & c::FILE_ATTRIBUTE_DIRECTORY) != 0;\n@@ -1337,9 +1349,10 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n     let h = f.as_inner().as_raw_handle();\n \n     unsafe {\n-        let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-        let db = data.as_mut_ptr() as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n-        let buf = &mut (*db).ReparseTarget as *mut c::WCHAR;\n+        let mut data = Align8([0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE]);\n+        let data_ptr = data.0.as_mut_ptr();\n+        let db = data_ptr.cast::<c::REPARSE_MOUNTPOINT_DATA_BUFFER>();\n+        let buf = ptr::addr_of_mut!((*db).ReparseTarget).cast::<c::WCHAR>();\n         let mut i = 0;\n         // FIXME: this conversion is very hacky\n         let v = br\"\\??\\\";\n@@ -1359,7 +1372,7 @@ fn symlink_junction_inner(original: &Path, junction: &Path) -> io::Result<()> {\n         cvt(c::DeviceIoControl(\n             h as *mut _,\n             c::FSCTL_SET_REPARSE_POINT,\n-            data.as_ptr() as *mut _,\n+            data_ptr.cast(),\n             (*db).ReparseDataLength + 8,\n             ptr::null_mut(),\n             0,"}, {"sha": "340cae4066bf44deb42f872769a37ffea7333afb", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -329,3 +329,11 @@ pub fn abort_internal() -> ! {\n     }\n     crate::intrinsics::abort();\n }\n+\n+/// Align the inner value to 8 bytes.\n+///\n+/// This is enough for almost all of the buffers we're likely to work with in\n+/// the Windows APIs we use.\n+#[repr(C, align(8))]\n+#[derive(Copy, Clone)]\n+pub(crate) struct Align8<T: ?Sized>(pub T);"}, {"sha": "e1cc8d671d7fe892a0048627a1b3ba2e3bbad846", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -432,12 +432,13 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n         }\n \n-        if target.starts_with(\"riscv\") && !target.contains(\"freebsd\") {\n+        if target.starts_with(\"riscv\") && !target.contains(\"freebsd\") && !target.contains(\"openbsd\")\n+        {\n             // RISC-V GCC erroneously requires linking against\n             // `libatomic` when using 1-byte and 2-byte C++\n             // atomics but the LLVM build system check cannot\n             // detect this. Therefore it is set manually here.\n-            // FreeBSD uses Clang as its system compiler and\n+            // Some BSD uses Clang as its system compiler and\n             // provides no libatomic in its base system so does\n             // not want this.\n             ldflags.exe.push(\" -latomic\");"}, {"sha": "742fbe11d9c6fbab4ae13be216ad7a35e65643c8", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -277,13 +277,15 @@ target | std | host | notes\n `powerpc64-unknown-linux-musl` | ? |  |\n `powerpc64-wrs-vxworks` | ? |  |\n `powerpc64le-unknown-linux-musl` | ? |  |\n+[`powerpc64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | OpenBSD/powerpc64\n `riscv32gc-unknown-linux-gnu` |   |   | RISC-V Linux (kernel 5.4, glibc 2.33)\n `riscv32gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 5.4, musl + RISCV32 support patches)\n `riscv32im-unknown-none-elf` | * |  | Bare RISC-V (RV32IM ISA)\n [`riscv32imac-unknown-xous-elf`](platform-support/riscv32imac-unknown-xous-elf.md) | ? |  | RISC-V Xous (RV32IMAC ISA)\n `riscv32imc-esp-espidf` | \u2713 |  | RISC-V ESP-IDF\n `riscv64gc-unknown-freebsd` |   |   | RISC-V FreeBSD\n `riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)\n+[`riscv64gc-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | OpenBSD/riscv64\n `s390x-unknown-linux-musl` |  |  | S390x Linux (kernel 3.2, MUSL)\n `sparc-unknown-linux-gnu` | \u2713 |  | 32-bit SPARC Linux\n `sparc64-unknown-netbsd` | \u2713 | \u2713 | NetBSD/sparc64"}, {"sha": "4ce80157dbf9c04762024da82394fda3814532ad", "filename": "src/doc/rustc/src/platform-support/openbsd.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fopenbsd.md", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fopenbsd.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fopenbsd.md?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -12,6 +12,8 @@ The target names follow this format: `$ARCH-unknown-openbsd`, where `$ARCH` spec\n |--------------------------------|-------------|------------------|\n | `aarch64-unknown-openbsd`      | libc++      | [64-bit ARM systems](https://www.openbsd.org/arm64.html)  |\n | `i686-unknown-openbsd`         | libc++      | [Standard PC and clones based on the Intel i386 architecture and compatible processors](https://www.openbsd.org/i386.html) |\n+| `powerpc64-unknown-openbsd`    | libc++      | [IBM POWER-based PowerNV systems](https://www.openbsd.org/powerpc64.html) |\n+| `riscv64gc-unknown-openbsd`    | libc++      | [64-bit RISC-V systems](https://www.openbsd.org/riscv64.html) |\n | `sparc64-unknown-openbsd`      | estdc++     | [Sun UltraSPARC and Fujitsu SPARC64 systems](https://www.openbsd.org/sparc64.html) |\n | `x86_64-unknown-openbsd`       | libc++      | [AMD64-based systems](https://www.openbsd.org/amd64.html) |\n "}, {"sha": "89eaec78c6f1169b041f56958b2f61091b5212f8", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 134, "deletions": 22, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -167,8 +167,8 @@ enum P {\n #[derive(SessionSubdiagnostic)]\n enum Q {\n     #[bar]\n-//~^ ERROR `#[bar]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -179,8 +179,8 @@ enum Q {\n #[derive(SessionSubdiagnostic)]\n enum R {\n     #[bar = \"...\"]\n-//~^ ERROR `#[bar = ...]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar = ...]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -191,8 +191,8 @@ enum R {\n #[derive(SessionSubdiagnostic)]\n enum S {\n     #[bar = 4]\n-//~^ ERROR `#[bar = ...]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar = ...]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -203,8 +203,8 @@ enum S {\n #[derive(SessionSubdiagnostic)]\n enum T {\n     #[bar(\"...\")]\n-//~^ ERROR `#[bar(\"...\")]` is not a valid attribute\n-//~^^ ERROR cannot find attribute `bar` in this scope\n+    //~^ ERROR `#[bar(...)]` is not a valid attribute\n+    //~^^ ERROR cannot find attribute `bar` in this scope\n     A {\n         #[primary_span]\n         span: Span,\n@@ -215,7 +215,7 @@ enum T {\n #[derive(SessionSubdiagnostic)]\n enum U {\n     #[label(code = \"...\")]\n-//~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n+    //~^ ERROR diagnostic slug must be first argument of a `#[label(...)]` attribute\n     A {\n         #[primary_span]\n         span: Span,\n@@ -232,7 +232,7 @@ enum V {\n         var: String,\n     },\n     B {\n-//~^ ERROR subdiagnostic kind not specified\n+    //~^ ERROR subdiagnostic kind not specified\n         #[primary_span]\n         span: Span,\n         var: String,\n@@ -310,10 +310,8 @@ union AC {\n #[derive(SessionSubdiagnostic)]\n #[label(parser::add_paren)]\n //~^ NOTE previously specified here\n-//~^^ NOTE previously specified here\n #[label(parser::add_paren)]\n //~^ ERROR specified multiple times\n-//~^^ ERROR specified multiple times\n struct AD {\n     #[primary_span]\n     span: Span,\n@@ -331,16 +329,16 @@ struct AE {\n #[label(parser::add_paren)]\n struct AF {\n     #[primary_span]\n-//~^ NOTE previously specified here\n+    //~^ NOTE previously specified here\n     span_a: Span,\n     #[primary_span]\n-//~^ ERROR specified multiple times\n+    //~^ ERROR specified multiple times\n     span_b: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n struct AG {\n-//~^ ERROR subdiagnostic kind not specified\n+    //~^ ERROR subdiagnostic kind not specified\n     #[primary_span]\n     span: Span,\n }\n@@ -392,27 +390,25 @@ struct AK {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n-//~^ NOTE previously specified here\n+    //~^ NOTE previously specified here\n     applicability_a: Applicability,\n     #[applicability]\n-//~^ ERROR specified multiple times\n+    //~^ ERROR specified multiple times\n     applicability_b: Applicability,\n }\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `applicability`\n struct AL {\n     #[primary_span]\n     span: Span,\n     #[applicability]\n-//~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n+    //~^ ERROR the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n     applicability: Span,\n }\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `applicability`\n struct AM {\n     #[primary_span]\n     span: Span,\n@@ -448,8 +444,7 @@ struct AQ;\n \n #[derive(SessionSubdiagnostic)]\n #[suggestion(parser::add_paren, code = \"...\")]\n-//~^ ERROR suggestion without `applicability`\n-//~^^ ERROR suggestion without `#[primary_span]` field\n+//~^ ERROR suggestion without `#[primary_span]` field\n struct AR {\n     var: String,\n }\n@@ -519,3 +514,120 @@ struct AZ {\n     #[primary_span]\n     span: Span,\n }\n+\n+#[derive(SessionSubdiagnostic)]\n+#[suggestion(parser::add_paren, code = \"...\")]\n+//~^ ERROR suggestion without `#[primary_span]` field\n+struct BA {\n+    #[suggestion_part]\n+    //~^ ERROR `#[suggestion_part]` is not a valid attribute\n+    span: Span,\n+    #[suggestion_part(code = \"...\")]\n+    //~^ ERROR `#[suggestion_part(...)]` is not a valid attribute\n+    span2: Span,\n+    #[applicability]\n+    applicability: Applicability,\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+//~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n+//~| ERROR `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n+struct BBa {\n+    var: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BBb {\n+    #[suggestion_part]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span1: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BBc {\n+    #[suggestion_part()]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span1: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren)]\n+//~^ ERROR multipart suggestion without any `#[suggestion_part(...)]` fields\n+struct BC {\n+    #[primary_span]\n+    //~^ ERROR `#[primary_span]` is not a valid attribute\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren)]\n+struct BD {\n+    #[suggestion_part]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span1: Span,\n+    #[suggestion_part()]\n+    //~^ ERROR `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+    span2: Span,\n+    #[suggestion_part(foo = \"bar\")]\n+    //~^ ERROR `#[suggestion_part(foo = ...)]` is not a valid attribute\n+    span4: Span,\n+    #[suggestion_part(code = \"...\")]\n+    //~^ ERROR the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+    s1: String,\n+    #[suggestion_part()]\n+    //~^ ERROR the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+    s2: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BE {\n+    #[suggestion_part(code = \"...\", code = \",,,\")]\n+    //~^ ERROR specified multiple times\n+    //~| NOTE previously specified here\n+    span: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BF {\n+    #[suggestion_part(code = \"(\")]\n+    first: Span,\n+    #[suggestion_part(code = \")\")]\n+    second: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren)]\n+struct BG {\n+    #[applicability]\n+    appl: Applicability,\n+    #[suggestion_part(code = \"(\")]\n+    first: Span,\n+    #[suggestion_part(code = \")\")]\n+    second: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+//~^ NOTE previously specified here\n+struct BH {\n+    #[applicability]\n+    //~^ ERROR specified multiple times\n+    appl: Applicability,\n+    #[suggestion_part(code = \"(\")]\n+    first: Span,\n+    #[suggestion_part(code = \")\")]\n+    second: Span,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+struct BI {\n+    #[suggestion_part(code = \"\")]\n+    spans: Vec<Span>,\n+}"}, {"sha": "75a34f44bbe7241bb61e0a293eac4ef41ae06c60", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 158, "deletions": 78, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -65,16 +65,16 @@ LL | #[label()]\n    | ^^^^^^^^^^\n \n error: `code` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:137:1\n+  --> $DIR/subdiagnostic-derive.rs:137:28\n    |\n LL | #[label(parser::add_paren, code = \"...\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^^\n \n error: `applicability` is not a valid nested attribute of a `label` attribute\n-  --> $DIR/subdiagnostic-derive.rs:146:1\n+  --> $DIR/subdiagnostic-derive.rs:146:28\n    |\n LL | #[label(parser::add_paren, applicability = \"machine-applicable\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsupported type attribute for subdiagnostic enum\n   --> $DIR/subdiagnostic-derive.rs:155:1\n@@ -100,13 +100,11 @@ error: `#[bar = ...]` is not a valid attribute\n LL |     #[bar = 4]\n    |     ^^^^^^^^^^\n \n-error: `#[bar(\"...\")]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:205:11\n+error: `#[bar(...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:205:5\n    |\n LL |     #[bar(\"...\")]\n-   |           ^^^^^\n-   |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   |     ^^^^^^^^^^^^^\n \n error: diagnostic slug must be first argument of a `#[label(...)]` attribute\n   --> $DIR/subdiagnostic-derive.rs:217:5\n@@ -163,6 +161,8 @@ error: `#[bar(...)]` is not a valid attribute\n    |\n LL |     #[bar(\"...\")]\n    |     ^^^^^^^^^^^^^\n+   |\n+   = help: only `primary_span`, `applicability` and `skip_arg` are valid field attributes\n \n error: unexpected unsupported untagged union\n   --> $DIR/subdiagnostic-derive.rs:304:1\n@@ -175,19 +175,7 @@ LL | | }\n    | |_^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:314:1\n-   |\n-LL | #[label(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:311:1\n-   |\n-LL | #[label(parser::add_paren)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:314:1\n+  --> $DIR/subdiagnostic-derive.rs:313:1\n    |\n LL | #[label(parser::add_paren)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -199,141 +187,233 @@ LL | #[label(parser::add_paren)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(parser::add_paren)]` is not a valid attribute\n-  --> $DIR/subdiagnostic-derive.rs:323:28\n+  --> $DIR/subdiagnostic-derive.rs:321:28\n    |\n LL | #[label(parser::add_paren, parser::add_paren)]\n    |                            ^^^^^^^^^^^^^^^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:336:5\n+  --> $DIR/subdiagnostic-derive.rs:334:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:333:5\n+  --> $DIR/subdiagnostic-derive.rs:331:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: subdiagnostic kind not specified\n-  --> $DIR/subdiagnostic-derive.rs:342:8\n+  --> $DIR/subdiagnostic-derive.rs:340:8\n    |\n LL | struct AG {\n    |        ^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:379:47\n+  --> $DIR/subdiagnostic-derive.rs:377:47\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                               ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:379:33\n+  --> $DIR/subdiagnostic-derive.rs:377:33\n    |\n LL | #[suggestion(parser::add_paren, code = \"...\", code = \"...\")]\n    |                                 ^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/subdiagnostic-derive.rs:397:5\n+  --> $DIR/subdiagnostic-derive.rs:395:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/subdiagnostic-derive.rs:394:5\n+  --> $DIR/subdiagnostic-derive.rs:392:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n error: the `#[applicability]` attribute can only be applied to fields of type `Applicability`\n-  --> $DIR/subdiagnostic-derive.rs:408:5\n+  --> $DIR/subdiagnostic-derive.rs:405:5\n    |\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:403:1\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:418:1\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n-LL | |\n-LL | | struct AL {\n-LL | |     #[primary_span]\n-...  |\n-LL | |     applicability: Span,\n-LL | | }\n-   | |_^\n+LL | #[suggestion(parser::add_paren)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: invalid applicability\n+  --> $DIR/subdiagnostic-derive.rs:428:46\n+   |\n+LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^\n \n-error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:414:1\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:446:1\n    |\n LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct AM {\n-LL | |     #[primary_span]\n-LL | |     span: Span,\n+LL | | struct AR {\n+LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: suggestion without `code = \"...\"`\n-  --> $DIR/subdiagnostic-derive.rs:422:1\n+error: unsupported type attribute for subdiagnostic enum\n+  --> $DIR/subdiagnostic-derive.rs:460:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:480:39\n+   |\n+LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                       ^^^^^^^\n+\n+error: `var` doesn't refer to a field on this type\n+  --> $DIR/subdiagnostic-derive.rs:499:43\n+   |\n+LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^\n+\n+error: `#[suggestion_part]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:522:5\n+   |\n+LL |     #[suggestion_part]\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `#[suggestion_part(...)]` is only valid in multipart suggestions, use `#[primary_span]` instead\n+\n+error: `#[suggestion_part(...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:525:5\n+   |\n+LL |     #[suggestion_part(code = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-LL | / #[suggestion(parser::add_paren)]\n+   = help: `#[suggestion_part(...)]` is only valid in multipart suggestions\n+\n+error: suggestion without `#[primary_span]` field\n+  --> $DIR/subdiagnostic-derive.rs:519:1\n+   |\n+LL | / #[suggestion(parser::add_paren, code = \"...\")]\n LL | |\n-LL | | struct AN {\n-LL | |     #[primary_span]\n+LL | | struct BA {\n+LL | |     #[suggestion_part]\n ...  |\n-LL | |     applicability: Applicability,\n+LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: invalid applicability\n-  --> $DIR/subdiagnostic-derive.rs:432:46\n+error: `code` is not a valid nested attribute of a `multipart_suggestion` attribute\n+  --> $DIR/subdiagnostic-derive.rs:534:43\n    |\n-LL | #[suggestion(parser::add_paren, code =\"...\", applicability = \"foo\")]\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^\n+LL | #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^^^^^^\n \n-error: suggestion without `applicability`\n-  --> $DIR/subdiagnostic-derive.rs:450:1\n+error: multipart suggestion without any `#[suggestion_part(...)]` fields\n+  --> $DIR/subdiagnostic-derive.rs:534:1\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL | / #[multipart_suggestion(parser::add_paren, code = \"...\", applicability = \"machine-applicable\")]\n LL | |\n LL | |\n-LL | | struct AR {\n+LL | | struct BBa {\n LL | |     var: String,\n LL | | }\n    | |_^\n \n-error: suggestion without `#[primary_span]` field\n-  --> $DIR/subdiagnostic-derive.rs:450:1\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:544:5\n    |\n-LL | / #[suggestion(parser::add_paren, code = \"...\")]\n+LL |     #[suggestion_part]\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:552:5\n+   |\n+LL |     #[suggestion_part()]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[primary_span]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:561:5\n+   |\n+LL |     #[primary_span]\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: multipart suggestions use one or more `#[suggestion_part]`s rather than one `#[primary_span]`\n+\n+error: multipart suggestion without any `#[suggestion_part(...)]` fields\n+  --> $DIR/subdiagnostic-derive.rs:558:1\n+   |\n+LL | / #[multipart_suggestion(parser::add_paren)]\n LL | |\n+LL | | struct BC {\n+LL | |     #[primary_span]\n LL | |\n-LL | | struct AR {\n-LL | |     var: String,\n+LL | |     span: Span,\n LL | | }\n    | |_^\n \n-error: unsupported type attribute for subdiagnostic enum\n-  --> $DIR/subdiagnostic-derive.rs:465:1\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:569:5\n    |\n-LL | #[label]\n-   | ^^^^^^^^\n+LL |     #[suggestion_part]\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:485:39\n+error: `#[suggestion_part(...)]` attribute without `code = \"...\"`\n+  --> $DIR/subdiagnostic-derive.rs:572:5\n    |\n-LL | #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                       ^^^^^^^\n+LL |     #[suggestion_part()]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n \n-error: `var` doesn't refer to a field on this type\n-  --> $DIR/subdiagnostic-derive.rs:504:43\n+error: `#[suggestion_part(foo = ...)]` is not a valid attribute\n+  --> $DIR/subdiagnostic-derive.rs:575:23\n    |\n-LL |     #[suggestion(parser::add_paren, code =\"{var}\", applicability = \"machine-applicable\")]\n-   |                                           ^^^^^^^\n+LL |     #[suggestion_part(foo = \"bar\")]\n+   |                       ^^^^^^^^^^^\n+   |\n+   = help: `code` is the only valid nested attribute\n+\n+error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+  --> $DIR/subdiagnostic-derive.rs:578:5\n+   |\n+LL |     #[suggestion_part(code = \"...\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the `#[suggestion_part(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n+  --> $DIR/subdiagnostic-derive.rs:581:5\n+   |\n+LL |     #[suggestion_part()]\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:589:37\n+   |\n+LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n+   |                                     ^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:589:23\n+   |\n+LL |     #[suggestion_part(code = \"...\", code = \",,,\")]\n+   |                       ^^^^^^^^^^^^\n+\n+error: specified multiple times\n+  --> $DIR/subdiagnostic-derive.rs:619:5\n+   |\n+LL |     #[applicability]\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+note: previously specified here\n+  --> $DIR/subdiagnostic-derive.rs:616:43\n+   |\n+LL | #[multipart_suggestion(parser::add_paren, applicability = \"machine-applicable\")]\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n@@ -395,6 +475,6 @@ error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 52 previous errors\n+error: aborting due to 64 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "3f180cf4f1f891ca81f235cb4114acd427a24697", "filename": "src/test/ui/associated-types/substs-ppaux.normal.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -11,7 +11,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>();\n    |                                                                         ++\n@@ -29,7 +29,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>();\n    |                                                                          ++\n@@ -47,7 +47,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<'static, 'static, u8>>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz();\n    |                                                        ++"}, {"sha": "16dd29de2c5438d9a7f695f7656e94d88fc17bf7", "filename": "src/test/ui/associated-types/substs-ppaux.verbose.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -11,7 +11,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>();\n    |                                                                         ++\n@@ -29,7 +29,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<ReStatic, ReStatic>>::bar::<ReStatic, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>();\n    |                                                                          ++\n@@ -47,7 +47,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz();\n    |                                                        ++"}, {"sha": "a334bd8562593d9f4550968b107579a0d982a0f6", "filename": "src/test/ui/binop/issue-77910-2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -5,6 +5,11 @@ LL |     if foo == y {}\n    |        --- ^^ - _\n    |        |\n    |        for<'r> fn(&'r i32) -> &'r i32 {foo}\n+   |\n+help: use parentheses to call this function\n+   |\n+LL |     if foo(/* &i32 */) == y {}\n+   |           ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "d76c697fe737d907019fdeeb7d2ddba4b01b8438", "filename": "src/test/ui/feature-gates/feature-gate-object_safe_for_dispatch.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-object_safe_for_dispatch.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -13,10 +13,10 @@ LL | trait NonObjectSafe1: Sized {}\n    |       this trait cannot be made into an object...\n \n error[E0038]: the trait `NonObjectSafe2` cannot be made into an object\n-  --> $DIR/feature-gate-object_safe_for_dispatch.rs:22:36\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:22:45\n    |\n LL | fn return_non_object_safe_ref() -> &'static dyn NonObjectSafe2 {\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `NonObjectSafe2` cannot be made into an object\n+   |                                             ^^^^^^^^^^^^^^^^^^ `NonObjectSafe2` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/feature-gate-object_safe_for_dispatch.rs:7:8\n@@ -50,10 +50,10 @@ LL |     fn foo<T>(&self);\n    = help: consider moving `foo` to another trait\n \n error[E0038]: the trait `NonObjectSafe4` cannot be made into an object\n-  --> $DIR/feature-gate-object_safe_for_dispatch.rs:31:35\n+  --> $DIR/feature-gate-object_safe_for_dispatch.rs:31:47\n    |\n LL | fn return_non_object_safe_rc() -> std::rc::Rc<dyn NonObjectSafe4> {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `NonObjectSafe4` cannot be made into an object\n+   |                                               ^^^^^^^^^^^^^^^^^^ `NonObjectSafe4` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/feature-gate-object_safe_for_dispatch.rs:15:22"}, {"sha": "df838cb11810578e8ec10274324269c48750cf43", "filename": "src/test/ui/fn/fn-compare-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -6,14 +6,10 @@ LL |     let x = f == g;\n    |             |\n    |             fn() {f}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call these\n    |\n-LL |     let x = f() == g;\n-   |              ++\n-help: you might have forgotten to call this function\n-   |\n-LL |     let x = f == g();\n-   |                   ++\n+LL |     let x = f() == g();\n+   |              ++     ++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-compare-mismatch.rs:4:18"}, {"sha": "2a674d3c1d23dea4ee5f1859c779a48fd02bb183", "filename": "src/test/ui/fn/fn-trait-formatting.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffn%2Ffn-trait-formatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffn%2Ffn-trait-formatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Ffn-trait-formatting.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -8,6 +8,10 @@ LL |     let _: () = Box::new(|_: isize| {}) as Box<dyn FnOnce(isize)>;\n    |\n    = note: expected unit type `()`\n                  found struct `Box<dyn FnOnce(isize)>`\n+help: use parentheses to call this trait object\n+   |\n+LL |     let _: () = (Box::new(|_: isize| {}) as Box<dyn FnOnce(isize)>)(/* isize */);\n+   |                 +                                                 ++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-trait-formatting.rs:10:17\n@@ -19,6 +23,10 @@ LL |     let _: () = Box::new(|_: isize, isize| {}) as Box<dyn Fn(isize, isize)>\n    |\n    = note: expected unit type `()`\n                  found struct `Box<dyn Fn(isize, isize)>`\n+help: use parentheses to call this trait object\n+   |\n+LL |     let _: () = (Box::new(|_: isize, isize| {}) as Box<dyn Fn(isize, isize)>)(/* isize */, /* isize */);\n+   |                 +                                                           +++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-trait-formatting.rs:14:17"}, {"sha": "49a514a8b4e3461007e609d85d42a5522cdb4a81", "filename": "src/test/ui/functions-closures/fn-help-with-err.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,16 +1,28 @@\n // This test case checks the behavior of typeck::check::method::suggest::is_fn on Ty::Error.\n+\n+struct Foo;\n+\n+trait Bar {\n+    //~^ NOTE `Bar` defines an item `bar`, perhaps you need to implement it\n+    //~| NOTE `Bar` defines an item `bar`, perhaps you need to implement it\n+    fn bar(&self) {}\n+}\n+\n+impl Bar for Foo {}\n+\n fn main() {\n     let arc = std::sync::Arc::new(oops);\n     //~^ ERROR cannot find value `oops` in this scope\n     //~| NOTE not found\n-    // The error \"note: this is a function, perhaps you wish to call it\" MUST NOT appear.\n-    arc.blablabla();\n-    //~^ ERROR no method named `blablabla`\n+    arc.bar();\n+    //~^ ERROR no method named `bar`\n     //~| NOTE method not found\n-    let arc2 = std::sync::Arc::new(|| 1);\n-    // The error \"note: this is a function, perhaps you wish to call it\" SHOULD appear\n-    arc2.blablabla();\n-    //~^ ERROR no method named `blablabla`\n+    //~| HELP items from traits can only be used if the trait is implemented and in scope\n+\n+    let arc2 = std::sync::Arc::new(|| Foo);\n+    arc2.bar();\n+    //~^ ERROR no method named `bar`\n     //~| NOTE method not found\n-    //~| NOTE this is a function, perhaps you wish to call it\n+    //~| HELP items from traits can only be used if the trait is implemented and in scope\n+    //~| HELP use parentheses to call this closure\n }"}, {"sha": "2296666219eef2fbb284e11e7699db91b4adb20d", "filename": "src/test/ui/functions-closures/fn-help-with-err.stderr", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,22 +1,38 @@\n error[E0425]: cannot find value `oops` in this scope\n-  --> $DIR/fn-help-with-err.rs:3:35\n+  --> $DIR/fn-help-with-err.rs:14:35\n    |\n LL |     let arc = std::sync::Arc::new(oops);\n    |                                   ^^^^ not found in this scope\n \n-error[E0599]: no method named `blablabla` found for struct `Arc<_>` in the current scope\n-  --> $DIR/fn-help-with-err.rs:7:9\n+error[E0599]: no method named `bar` found for struct `Arc<_>` in the current scope\n+  --> $DIR/fn-help-with-err.rs:17:9\n    |\n-LL |     arc.blablabla();\n-   |         ^^^^^^^^^ method not found in `Arc<_>`\n+LL |     arc.bar();\n+   |         ^^^ method not found in `Arc<_>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Bar` defines an item `bar`, perhaps you need to implement it\n+  --> $DIR/fn-help-with-err.rs:5:1\n+   |\n+LL | trait Bar {\n+   | ^^^^^^^^^\n \n-error[E0599]: no method named `blablabla` found for struct `Arc<[closure@$DIR/fn-help-with-err.rs:10:36: 10:38]>` in the current scope\n-  --> $DIR/fn-help-with-err.rs:12:10\n+error[E0599]: no method named `bar` found for struct `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>` in the current scope\n+  --> $DIR/fn-help-with-err.rs:23:10\n+   |\n+LL |     arc2.bar();\n+   |          ^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Bar` defines an item `bar`, perhaps you need to implement it\n+  --> $DIR/fn-help-with-err.rs:5:1\n+   |\n+LL | trait Bar {\n+   | ^^^^^^^^^\n+help: use parentheses to call this closure\n    |\n-LL |     arc2.blablabla();\n-   |     ---- ^^^^^^^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:10:36: 10:38]>`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+LL |     arc2().bar();\n+   |         ++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "687dbe65e6c381405950d54d0b13db584eac5bc7", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-dyn-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -21,10 +21,10 @@ LL |     fn foo() -> Self where Self: Sized;\n    |                      +++++++++++++++++\n \n error[E0038]: the trait `NotObjectSafe` cannot be made into an object\n-  --> $DIR/object-unsafe-trait-in-return-position-dyn-trait.rs:28:13\n+  --> $DIR/object-unsafe-trait-in-return-position-dyn-trait.rs:28:17\n    |\n LL | fn cat() -> Box<dyn NotObjectSafe> {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ `NotObjectSafe` cannot be made into an object\n+   |                 ^^^^^^^^^^^^^^^^^ `NotObjectSafe` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-unsafe-trait-in-return-position-dyn-trait.rs:3:8"}, {"sha": "c10a856d83ba8758303350e2694ff012f8445c3b", "filename": "src/test/ui/impl-trait/suggest-calling-rpit-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -11,7 +11,7 @@ LL | fn opaque() -> impl Fn() -> i32 {\n    |\n    = note:     expected type `i32`\n            found opaque type `impl Fn() -> i32`\n-help: use parentheses to call this closure\n+help: use parentheses to call this opaque type\n    |\n LL |     opaque()()\n    |             ++"}, {"sha": "9ee7654a0885d836fb6c42292af24c1827807681", "filename": "src/test/ui/issues/issue-35241.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -13,8 +13,8 @@ LL | fn test() -> Foo { Foo }\n              found fn item `fn(u32) -> Foo {Foo}`\n help: use parentheses to instantiate this tuple struct\n    |\n-LL | fn test() -> Foo { Foo(_) }\n-   |                       +++\n+LL | fn test() -> Foo { Foo(/* u32 */) }\n+   |                       +++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "b10273f14bd0338c4a2a6c2c4831e7c92519af7d", "filename": "src/test/ui/issues/issue-57362-1.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,9 +2,7 @@ error[E0599]: no method named `f` found for fn pointer `fn(&u8)` in the current\n   --> $DIR/issue-57362-1.rs:20:7\n    |\n LL |     a.f();\n-   |     - ^ method not found in `fn(&u8)`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |       ^ method not found in `fn(&u8)`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Trait` defines an item `f`, perhaps you need to implement it"}, {"sha": "e5368ddf1e5760b88b1b071a3319af0939110b6d", "filename": "src/test/ui/issues/issue-59488.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -6,7 +6,7 @@ LL |     foo > 12;\n    |     |\n    |     fn() -> i32 {foo}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call this function\n    |\n LL |     foo() > 12;\n    |        ++\n@@ -28,10 +28,10 @@ LL |     bar > 13;\n    |     |\n    |     fn(i64) -> i64 {bar}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call this function\n    |\n-LL |     bar( /* arguments */ ) > 13;\n-   |        +++++++++++++++++++\n+LL |     bar(/* i64 */) > 13;\n+   |        +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-59488.rs:18:11\n@@ -50,14 +50,10 @@ LL |     foo > foo;\n    |     |\n    |     fn() -> i32 {foo}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call these\n    |\n-LL |     foo() > foo;\n-   |        ++\n-help: you might have forgotten to call this function\n-   |\n-LL |     foo > foo();\n-   |              ++\n+LL |     foo() > foo();\n+   |        ++      ++\n \n error[E0369]: binary operation `>` cannot be applied to type `fn() -> i32 {foo}`\n   --> $DIR/issue-59488.rs:25:9"}, {"sha": "9239385e6436904b5235e8bc657dfa283c9b4077", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -8,11 +8,6 @@ LL |     assert_eq!(a, 0);\n    |     {integer}\n    |\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: you might have forgotten to call this function\n-  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |                 if !(*left_val() == *right_val) {\n-   |                               ++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n@@ -21,7 +16,7 @@ LL |     assert_eq!(a, 0);\n    |     ^^^^^^^^^^^^^^^^ expected fn item, found integer\n    |\n    = note: expected fn item `fn() -> i32 {a}`\n-                 found type `i32`\n+                 found type `{integer}`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `fn() -> i32 {a}` doesn't implement `Debug`"}, {"sha": "5f94c9284ea6699c1443b8dfcf4cca166cae45b2", "filename": "src/test/ui/object-safety/object-safety-associated-consts.curr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-associated-consts.curr.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-associated-consts.rs:12:30\n+  --> $DIR/object-safety-associated-consts.rs:12:31\n    |\n LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-   |                              ^^^^^^^^ `Bar` cannot be made into an object\n+   |                               ^^^^^^^ `Bar` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-associated-consts.rs:9:11"}, {"sha": "29ffb5448427d42ee4a0358728cc922b8640fb8b", "filename": "src/test/ui/object-safety/object-safety-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-bounds.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `X` cannot be made into an object\n-  --> $DIR/object-safety-bounds.rs:7:11\n+  --> $DIR/object-safety-bounds.rs:7:15\n    |\n LL | fn f() -> Box<dyn X<U = u32>> {\n-   |           ^^^^^^^^^^^^^^^^^^^ `X` cannot be made into an object\n+   |               ^^^^^^^^^^^^^^ `X` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-bounds.rs:4:13"}, {"sha": "45810375263978b9d7664b3d150c1af8789e151d", "filename": "src/test/ui/object-safety/object-safety-generics.curr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-generics.curr.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-generics.rs:18:30\n+  --> $DIR/object-safety-generics.rs:18:31\n    |\n LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-   |                              ^^^^^^^^ `Bar` cannot be made into an object\n+   |                               ^^^^^^^ `Bar` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-generics.rs:10:8\n@@ -14,10 +14,10 @@ LL |     fn bar<T>(&self, t: T);\n    = help: consider moving `bar` to another trait\n \n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-generics.rs:24:39\n+  --> $DIR/object-safety-generics.rs:24:40\n    |\n LL | fn make_bar_explicit<T:Bar>(t: &T) -> &dyn Bar {\n-   |                                       ^^^^^^^^ `Bar` cannot be made into an object\n+   |                                        ^^^^^^^ `Bar` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-generics.rs:10:8"}, {"sha": "de430a89bf82b6ff7a985ee23590df1c3ecedf07", "filename": "src/test/ui/object-safety/object-safety-mentions-Self.curr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-mentions-Self.curr.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-mentions-Self.rs:22:30\n+  --> $DIR/object-safety-mentions-Self.rs:22:31\n    |\n LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-   |                              ^^^^^^^^ `Bar` cannot be made into an object\n+   |                               ^^^^^^^ `Bar` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-mentions-Self.rs:11:22\n@@ -14,10 +14,10 @@ LL |     fn bar(&self, x: &Self);\n    = help: consider moving `bar` to another trait\n \n error[E0038]: the trait `Baz` cannot be made into an object\n-  --> $DIR/object-safety-mentions-Self.rs:28:30\n+  --> $DIR/object-safety-mentions-Self.rs:28:31\n    |\n LL | fn make_baz<T:Baz>(t: &T) -> &dyn Baz {\n-   |                              ^^^^^^^^ `Baz` cannot be made into an object\n+   |                               ^^^^^^^ `Baz` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-mentions-Self.rs:15:22"}, {"sha": "1b025229e543ee159e20be60d78f98415137c361", "filename": "src/test/ui/object-safety/object-safety-no-static.curr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-no-static.curr.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/object-safety-no-static.rs:12:18\n+  --> $DIR/object-safety-no-static.rs:12:22\n    |\n LL | fn diverges() -> Box<dyn Foo> {\n-   |                  ^^^^^^^^^^^^ `Foo` cannot be made into an object\n+   |                      ^^^^^^^ `Foo` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-no-static.rs:9:8"}, {"sha": "b019264128e7668e926b564822291774e196f15b", "filename": "src/test/ui/object-safety/object-safety-sized-2.curr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized-2.curr.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-sized-2.rs:14:30\n+  --> $DIR/object-safety-sized-2.rs:14:31\n    |\n LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-   |                              ^^^^^^^^ `Bar` cannot be made into an object\n+   |                               ^^^^^^^ `Bar` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-sized-2.rs:9:18"}, {"sha": "97481312142fb7959cb44bda0c7044c315658a0a", "filename": "src/test/ui/object-safety/object-safety-sized.curr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.curr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.curr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-safety%2Fobject-safety-sized.curr.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0038]: the trait `Bar` cannot be made into an object\n-  --> $DIR/object-safety-sized.rs:12:30\n+  --> $DIR/object-safety-sized.rs:12:31\n    |\n LL | fn make_bar<T:Bar>(t: &T) -> &dyn Bar {\n-   |                              ^^^^^^^^ `Bar` cannot be made into an object\n+   |                               ^^^^^^^ `Bar` cannot be made into an object\n    |\n note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n   --> $DIR/object-safety-sized.rs:8:13"}, {"sha": "7cf32775a33ef3363aa23bcf53517798bd7be233", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -329,8 +329,8 @@ LL |         let _: Z = Z::Fn;\n            found fn item `fn(u8) -> Z {Z::Fn}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |         let _: Z = Z::Fn(_);\n-   |                         +++\n+LL |         let _: Z = Z::Fn(/* u8 */);\n+   |                         ++++++++++\n \n error[E0618]: expected function, found enum variant `Z::Unit`\n   --> $DIR/privacy-enum-ctor.rs:31:17\n@@ -364,8 +364,8 @@ LL |     let _: E = m::E::Fn;\n            found fn item `fn(u8) -> E {E::Fn}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |     let _: E = m::E::Fn(_);\n-   |                        +++\n+LL |     let _: E = m::E::Fn(/* u8 */);\n+   |                        ++++++++++\n \n error[E0618]: expected function, found enum variant `m::E::Unit`\n   --> $DIR/privacy-enum-ctor.rs:47:16\n@@ -399,8 +399,8 @@ LL |     let _: E = E::Fn;\n            found fn item `fn(u8) -> E {E::Fn}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |     let _: E = E::Fn(_);\n-   |                     +++\n+LL |     let _: E = E::Fn(/* u8 */);\n+   |                     ++++++++++\n \n error[E0618]: expected function, found enum variant `E::Unit`\n   --> $DIR/privacy-enum-ctor.rs:55:16"}, {"sha": "d19e4596a0cc1ba060c85b4e7757e6978ecea149", "filename": "src/test/ui/suggestions/call-boxed.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut x = 1i32;\n+    let y = Box::new(|| 1);\n+    x = y;\n+    //~^ ERROR mismatched types\n+    //~| HELP use parentheses to call this closure\n+}"}, {"sha": "9b619ac9a3f502fcc4983655dec8070c4362bd77", "filename": "src/test/ui/suggestions/call-boxed.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/call-boxed.rs:4:9\n+   |\n+LL |     let mut x = 1i32;\n+   |                 ---- expected due to this value\n+LL |     let y = Box::new(|| 1);\n+   |                      -- the found closure\n+LL |     x = y;\n+   |         ^ expected `i32`, found struct `Box`\n+   |\n+   = note: expected type `i32`\n+            found struct `Box<[closure@$DIR/call-boxed.rs:3:22: 3:24]>`\n+help: use parentheses to call this closure\n+   |\n+LL |     x = y();\n+   |          ++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "25ced84dd3783e4bed2cc6a842d4f1ef55212142", "filename": "src/test/ui/suggestions/call-on-missing.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -0,0 +1,39 @@\n+struct Foo { i: i32 }\n+\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+\n+fn foo() -> Foo {\n+    Foo { i: 1 }\n+}\n+\n+fn main() {\n+    foo.bar();\n+    //~^ ERROR no method named `bar`\n+    //~| HELP use parentheses to call this function\n+\n+    foo.i;\n+    //~^ ERROR no field `i`\n+    //~| HELP use parentheses to call this function\n+\n+    let callable = Box::new(|| Foo { i: 1 }) as Box<dyn Fn() -> Foo>;\n+\n+    callable.bar();\n+    //~^ ERROR no method named `bar`\n+    //~| HELP use parentheses to call this trait object\n+\n+    callable.i;\n+    //~^ ERROR no field `i`\n+    //~| HELP use parentheses to call this trait object\n+}\n+\n+fn type_param<T: Fn() -> Foo>(t: T) {\n+    t.bar();\n+    //~^ ERROR no method named `bar`\n+    //~| HELP use parentheses to call this type parameter\n+\n+    t.i;\n+    //~^ ERROR no field `i`\n+    //~| HELP use parentheses to call this type parameter\n+}"}, {"sha": "ca9abc7e906891513b16bc1d9e8a94eb0d5d41d2", "filename": "src/test/ui/suggestions/call-on-missing.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -0,0 +1,75 @@\n+error[E0599]: no method named `bar` found for fn item `fn() -> Foo {foo}` in the current scope\n+  --> $DIR/call-on-missing.rs:12:9\n+   |\n+LL |     foo.bar();\n+   |         ^^^ method not found in `fn() -> Foo {foo}`\n+   |\n+help: use parentheses to call this function\n+   |\n+LL |     foo().bar();\n+   |        ++\n+\n+error[E0609]: no field `i` on type `fn() -> Foo {foo}`\n+  --> $DIR/call-on-missing.rs:16:9\n+   |\n+LL |     foo.i;\n+   |         ^\n+   |\n+help: use parentheses to call this function\n+   |\n+LL |     foo().i;\n+   |        ++\n+\n+error[E0599]: no method named `bar` found for struct `Box<dyn Fn() -> Foo>` in the current scope\n+  --> $DIR/call-on-missing.rs:22:14\n+   |\n+LL |     callable.bar();\n+   |              ^^^ method not found in `Box<dyn Fn() -> Foo>`\n+   |\n+help: use parentheses to call this trait object\n+   |\n+LL |     callable().bar();\n+   |             ++\n+\n+error[E0609]: no field `i` on type `Box<dyn Fn() -> Foo>`\n+  --> $DIR/call-on-missing.rs:26:14\n+   |\n+LL |     callable.i;\n+   |              ^ unknown field\n+   |\n+help: use parentheses to call this trait object\n+   |\n+LL |     callable().i;\n+   |             ++\n+\n+error[E0599]: no method named `bar` found for type parameter `T` in the current scope\n+  --> $DIR/call-on-missing.rs:32:7\n+   |\n+LL | fn type_param<T: Fn() -> Foo>(t: T) {\n+   |               - method `bar` not found for this type parameter\n+LL |     t.bar();\n+   |       ^^^ method not found in `T`\n+   |\n+help: use parentheses to call this type parameter\n+   |\n+LL |     t().bar();\n+   |      ++\n+\n+error[E0609]: no field `i` on type `T`\n+  --> $DIR/call-on-missing.rs:36:7\n+   |\n+LL | fn type_param<T: Fn() -> Foo>(t: T) {\n+   |               - type parameter 'T' declared here\n+...\n+LL |     t.i;\n+   |       ^\n+   |\n+help: use parentheses to call this type parameter\n+   |\n+LL |     t().i;\n+   |      ++\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0599, E0609.\n+For more information about an error, try `rustc --explain E0599`."}, {"sha": "3c7b895e337e72c8ee20a9e38dbd4f964dcc2d52", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -33,8 +33,8 @@ LL |     let _: usize = foo;\n            found fn item `fn(usize, usize) -> usize {foo}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = foo(_, _);\n-   |                       ++++++\n+LL |     let _: usize = foo(/* usize */, /* usize */);\n+   |                       ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:30:16\n@@ -51,8 +51,8 @@ LL |     let _: S = S;\n              found fn item `fn(usize, usize) -> S {S}`\n help: use parentheses to instantiate this tuple struct\n    |\n-LL |     let _: S = S(_, _);\n-   |                 ++++++\n+LL |     let _: S = S(/* usize */, /* usize */);\n+   |                 ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:31:20\n@@ -103,10 +103,10 @@ LL |     let _: usize = T::baz;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize, usize) -> usize {<_ as T>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = T::baz(_, _);\n-   |                          ++++++\n+LL |     let _: usize = T::baz(/* usize */, /* usize */);\n+   |                          ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:34:20\n@@ -121,10 +121,10 @@ LL |     let _: usize = T::bat;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<_ as T>::bat}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = T::bat(_);\n-   |                          +++\n+LL |     let _: usize = T::bat(/* usize */);\n+   |                          +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:35:16\n@@ -141,8 +141,8 @@ LL |     let _: E = E::A;\n            found fn item `fn(usize) -> E {E::A}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |     let _: E = E::A(_);\n-   |                    +++\n+LL |     let _: E = E::A(/* usize */);\n+   |                    +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:37:20\n@@ -157,10 +157,10 @@ LL |     let _: usize = X::baz;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize, usize) -> usize {<X as T>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::baz(_, _);\n-   |                          ++++++\n+LL |     let _: usize = X::baz(/* usize */, /* usize */);\n+   |                          ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:38:20\n@@ -175,10 +175,10 @@ LL |     let _: usize = X::bat;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<X as T>::bat}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bat(_);\n-   |                          +++\n+LL |     let _: usize = X::bat(/* usize */);\n+   |                          +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:39:20\n@@ -193,10 +193,10 @@ LL |     let _: usize = X::bax;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<X as T>::bax}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bax(_);\n-   |                          +++\n+LL |     let _: usize = X::bax(/* usize */);\n+   |                          +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:40:20\n@@ -211,10 +211,10 @@ LL |     let _: usize = X::bach;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<X as T>::bach}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bach(_);\n-   |                           +++\n+LL |     let _: usize = X::bach(/* usize */);\n+   |                           +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:41:20\n@@ -229,10 +229,10 @@ LL |     let _: usize = X::ban;\n    |\n    = note: expected type `usize`\n            found fn item `for<'r> fn(&'r X) -> usize {<X as T>::ban}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::ban(_);\n-   |                          +++\n+LL |     let _: usize = X::ban(/* &X */);\n+   |                          ++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:42:20\n@@ -247,10 +247,10 @@ LL |     let _: usize = X::bal;\n    |\n    = note: expected type `usize`\n            found fn item `for<'r> fn(&'r X) -> usize {<X as T>::bal}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bal(_);\n-   |                          +++\n+LL |     let _: usize = X::bal(/* &X */);\n+   |                          ++++++++++\n \n error[E0615]: attempted to take value of method `ban` on type `X`\n   --> $DIR/fn-or-tuple-struct-without-args.rs:43:22"}, {"sha": "cf77c057d46d4b5babce2b4b9e23d96f786982f6", "filename": "src/test/ui/type/type-check-defaults.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: a value of type `i32` cannot be built from an iterator over elements of type `i32`\n-  --> $DIR/type-check-defaults.rs:6:19\n+  --> $DIR/type-check-defaults.rs:6:23\n    |\n LL | struct WellFormed<Z = Foo<i32, i32>>(Z);\n-   |                   ^^^^^^^^^^^^^^^^^ value of type `i32` cannot be built from `std::iter::Iterator<Item=i32>`\n+   |                       ^^^^^^^^^^^^^ value of type `i32` cannot be built from `std::iter::Iterator<Item=i32>`\n    |\n    = help: the trait `FromIterator<i32>` is not implemented for `i32`\n note: required by a bound in `Foo`\n@@ -12,10 +12,10 @@ LL | struct Foo<T, U: FromIterator<T>>(T, U);\n    |                  ^^^^^^^^^^^^^^^ required by this bound in `Foo`\n \n error[E0277]: a value of type `i32` cannot be built from an iterator over elements of type `i32`\n-  --> $DIR/type-check-defaults.rs:8:27\n+  --> $DIR/type-check-defaults.rs:8:38\n    |\n LL | struct WellFormedNoBounds<Z:?Sized = Foo<i32, i32>>(Z);\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^ value of type `i32` cannot be built from `std::iter::Iterator<Item=i32>`\n+   |                                      ^^^^^^^^^^^^^ value of type `i32` cannot be built from `std::iter::Iterator<Item=i32>`\n    |\n    = help: the trait `FromIterator<i32>` is not implemented for `i32`\n note: required by a bound in `Foo`"}, {"sha": "a837a7d2d62d178833e6607ad3e12b2ec53fecf5", "filename": "src/test/ui/typeck/issue-29124.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-29124.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-29124.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-29124.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,17 +2,13 @@ error[E0599]: no method named `x` found for fn item `fn() -> Ret {Obj::func}` in\n   --> $DIR/issue-29124.rs:15:15\n    |\n LL |     Obj::func.x();\n-   |     --------- ^ method not found in `fn() -> Ret {Obj::func}`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |               ^ method not found in `fn() -> Ret {Obj::func}`\n \n error[E0599]: no method named `x` found for fn item `fn() -> Ret {func}` in the current scope\n   --> $DIR/issue-29124.rs:17:10\n    |\n LL |     func.x();\n-   |     ---- ^ method not found in `fn() -> Ret {func}`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |          ^ method not found in `fn() -> Ret {func}`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "be68ad32ae55bb35e1b097361f86492acee30df5", "filename": "src/test/ui/typeck/issue-87181/empty-tuple-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -4,7 +4,7 @@ struct Bar<T> {\n \n struct Foo();\n impl Foo {\n-    fn foo() { }\n+    fn foo(&self) { }\n }\n \n fn main() {"}, {"sha": "a18c54a29b52c0e875b580fa15e0b069b5acc6bb", "filename": "src/test/ui/typeck/issue-87181/empty-tuple-method.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,11 +2,9 @@ error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo}` in the\n   --> $DIR/empty-tuple-method.rs:12:15\n    |\n LL |     thing.bar.foo();\n-   |     --------- ^^^ method not found in `fn() -> Foo {Foo}`\n-   |     |\n-   |     this is the constructor of a struct\n+   |               ^^^ method not found in `fn() -> Foo {Foo}`\n    |\n-help: call the constructor\n+help: use parentheses to instantiate this tuple struct\n    |\n LL |     (thing.bar)().foo();\n    |     +         +++"}, {"sha": "d87f99c3c5a193dc3ba7f3382744d43bdf8dced4", "filename": "src/test/ui/typeck/issue-87181/enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -6,7 +6,7 @@ enum Foo{\n     Tup()\n }\n impl Foo {\n-    fn foo() { }\n+    fn foo(&self) { }\n }\n \n fn main() {"}, {"sha": "90641410d8e967430f568da85b4507012eb2cd48", "filename": "src/test/ui/typeck/issue-87181/enum-variant.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,11 +2,9 @@ error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo::Tup}` i\n   --> $DIR/enum-variant.rs:14:15\n    |\n LL |     thing.bar.foo();\n-   |     --------- ^^^ method not found in `fn() -> Foo {Foo::Tup}`\n-   |     |\n-   |     this is the constructor of an enum variant\n+   |               ^^^ method not found in `fn() -> Foo {Foo::Tup}`\n    |\n-help: call the constructor\n+help: use parentheses to instantiate this tuple variant\n    |\n LL |     (thing.bar)().foo();\n    |     +         +++"}, {"sha": "c1ca26ee9af1dc84ca41784e4834b60c2b2f737f", "filename": "src/test/ui/typeck/issue-87181/tuple-field.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,14 +2,12 @@ error[E0609]: no field `0` on type `fn(char, u16) -> Foo {Foo}`\n   --> $DIR/tuple-field.rs:12:15\n    |\n LL |     thing.bar.0;\n-   |     --------- ^\n-   |     |\n-   |     this is the constructor of a struct\n+   |               ^\n    |\n-help: call the constructor\n+help: use parentheses to instantiate this tuple struct\n    |\n-LL |     (thing.bar)(_, _).0;\n-   |     +         +++++++\n+LL |     (thing.bar)(/* char */, /* u16 */).0;\n+   |     +         ++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "e27c41858d322e181021cf02313543d6a25264e2", "filename": "src/test/ui/typeck/issue-87181/tuple-method.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,14 +2,7 @@ error[E0599]: no method named `foo` found for fn item `fn(u8, i32) -> Foo {Foo}`\n   --> $DIR/tuple-method.rs:12:15\n    |\n LL |     thing.bar.foo();\n-   |     --------- ^^^ method not found in `fn(u8, i32) -> Foo {Foo}`\n-   |     |\n-   |     this is the constructor of a struct\n-   |\n-help: call the constructor\n-   |\n-LL |     (thing.bar)(_, _).foo();\n-   |     +         +++++++\n+   |               ^^^ method not found in `fn(u8, i32) -> Foo {Foo}`\n \n error: aborting due to previous error\n "}, {"sha": "0d4d87ef47e2b99db2886049828f3ee0ac59997b", "filename": "src/test/ui/typeck/issue-96738.stderr", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,27 +2,13 @@ error[E0599]: no method named `nonexistent_method` found for fn item `fn(_) -> O\n   --> $DIR/issue-96738.rs:2:10\n    |\n LL |     Some.nonexistent_method();\n-   |     ---- ^^^^^^^^^^^^^^^^^^ method not found in `fn(_) -> Option<_> {Option::<_>::Some}`\n-   |     |\n-   |     this is the constructor of an enum variant\n-   |\n-help: call the constructor\n-   |\n-LL |     (Some)(_).nonexistent_method();\n-   |     +    ++++\n+   |          ^^^^^^^^^^^^^^^^^^ method not found in `fn(_) -> Option<_> {Option::<_>::Some}`\n \n error[E0609]: no field `nonexistent_field` on type `fn(_) -> Option<_> {Option::<_>::Some}`\n   --> $DIR/issue-96738.rs:3:10\n    |\n LL |     Some.nonexistent_field;\n-   |     ---- ^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     this is the constructor of an enum variant\n-   |\n-help: call the constructor\n-   |\n-LL |     (Some)(_).nonexistent_field;\n-   |     +    ++++\n+   |          ^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e5ca0edd7a91c62826aa111d4be9dada4161bb37", "filename": "src/test/ui/unboxed-closures/unboxed-closures-static-call-wrong-trait.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -2,9 +2,7 @@ error[E0599]: no method named `call` found for closure `[closure@$DIR/unboxed-cl\n   --> $DIR/unboxed-closures-static-call-wrong-trait.rs:7:10\n    |\n LL |     mut_.call((0, ));\n-   |     ---- ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |          ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]`\n \n error: aborting due to previous error\n "}, {"sha": "9bd3cc7711b84777124ca566bf7117162934c422", "filename": "src/test/ui/wf/wf-trait-fn-ret.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12e4fd0755d7d976d4ee0f2004dc938290752ff7/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-ret.stderr?ref=12e4fd0755d7d976d4ee0f2004dc938290752ff7", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `Self: Eq` is not satisfied\n-  --> $DIR/wf-trait-fn-ret.rs:10:22\n+  --> $DIR/wf-trait-fn-ret.rs:10:23\n    |\n LL |     fn bar(&self) -> &Bar<Self>;\n-   |                      ^^^^^^^^^^ the trait `Eq` is not implemented for `Self`\n+   |                       ^^^^^^^^^ the trait `Eq` is not implemented for `Self`\n    |\n note: required by a bound in `Bar`\n   --> $DIR/wf-trait-fn-ret.rs:7:14"}]}