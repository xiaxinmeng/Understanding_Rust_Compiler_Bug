{"sha": "063a005459a3ece4022e1fdb6400548c7ad2358e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2M2EwMDU0NTlhM2VjZTQwMjJlMWZkYjY0MDA1NDhjN2FkMjM1OGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T17:31:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T17:31:25Z"}, "message": "auto merge of #8669 : lkuper/rust/infer-refactor, r=nikomatsakis\n\nThis commit removes the \"super_*\" functions from\r\ntypeck::infer::combine, and adds them as default methods on the\r\nCombine trait instead, making it possible to remove a lot of\r\nboilerplate from the various impls of Combine.\r\n\r\nI've been wanting to do this for over a year.  In fact, it was my\r\noriginal motivation for default methods!\r\n\r\nIt might be possible to tighten things up even more, but this is the\r\nbulk of it.", "tree": {"sha": "167835381de505dd715ef4e4ce42b9b4066e17e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/167835381de505dd715ef4e4ce42b9b4066e17e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/063a005459a3ece4022e1fdb6400548c7ad2358e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/063a005459a3ece4022e1fdb6400548c7ad2358e", "html_url": "https://github.com/rust-lang/rust/commit/063a005459a3ece4022e1fdb6400548c7ad2358e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/063a005459a3ece4022e1fdb6400548c7ad2358e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5003f607ec7386ba9a150e1bafb7d389de62d9ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/5003f607ec7386ba9a150e1bafb7d389de62d9ff", "html_url": "https://github.com/rust-lang/rust/commit/5003f607ec7386ba9a150e1bafb7d389de62d9ff"}, {"sha": "3613c22c8cb9ee37955352c1fde79457c0a211f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3613c22c8cb9ee37955352c1fde79457c0a211f6", "html_url": "https://github.com/rust-lang/rust/commit/3613c22c8cb9ee37955352c1fde79457c0a211f6"}], "stats": {"total": 717, "additions": 250, "deletions": 467}, "files": [{"sha": "2dd7a4e88b127f0b35fe94801300efd20238d742", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 250, "deletions": 278, "changes": 528, "blob_url": "https://github.com/rust-lang/rust/blob/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=063a005459a3ece4022e1fdb6400548c7ad2358e", "patch": "@@ -12,20 +12,12 @@\n // Type combining\n //\n // There are three type combiners: sub, lub, and glb.  Each implements\n-// the trait `combine` and contains methods for combining two\n+// the trait `Combine` and contains methods for combining two\n // instances of various things and yielding a new instance.  These\n // combiner methods always yield a `result<T>`---failure is propagated\n-// upward using `chain()` methods.\n-//\n-// There is a lot of common code for these operations, which is\n-// abstracted out into functions named `super_X()` which take a combiner\n-// instance as the first parameter.  This would be better implemented\n-// using traits.  For this system to work properly, you should not\n-// call the `super_X(foo, ...)` functions directly, but rather call\n-// `foo.X(...)`.  The implementation of `X()` can then choose to delegate\n-// to the `super` routine or to do other things.\n-// (FIXME (#2794): revise this paragraph once default methods in traits\n-// are working.)\n+// upward using `chain()` methods.  There is a lot of common code for\n+// these operations, implemented as default methods on the `Combine`\n+// trait.\n //\n // In reality, the sub operation is rather different from lub/glb, but\n // they are combined into one trait to avoid duplication (they used to\n@@ -88,34 +80,264 @@ pub trait Combine {\n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n+\n+    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+\n+        // Note: type parameters are always treated as *invariant*\n+        // (otherwise the type system would be unsound).  In the\n+        // future we could allow type parameters to declare a\n+        // variance.\n+\n+        if vec::same_length(as_, bs) {\n+            result::fold_(as_.iter().zip(bs.iter())\n+                          .map(|(a, b)| eq_tys(self, *a, *b)))\n+                .then(|| Ok(as_.to_owned()))\n+        } else {\n+            Err(ty::terr_ty_param_size(expected_found(self,\n+                                                      as_.len(),\n+                                                      bs.len())))\n+        }\n+    }\n+\n     fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n-               -> cres<Option<ty::t>>;\n+               -> cres<Option<ty::t>> {\n+\n+        match (a, b) {\n+            (None, None) => {\n+                Ok(None)\n+            }\n+            (Some(a), Some(b)) => {\n+                // FIXME(#5781) this should be eq_tys\n+                // eq_tys(self, a, b).then(|| Ok(Some(a)) )\n+                self.contratys(a, b).chain(|t| Ok(Some(t)))\n+            }\n+            (None, Some(_)) |\n+                (Some(_), None) => {\n+                // I think it should never happen that we unify two\n+                // substs and one of them has a self_ty and one\n+                // doesn't...? I could be wrong about this.\n+                self.infcx().tcx.sess.bug(\n+                                          fmt!(\"substitution a had a self_ty \\\n+                                               and substitution b didn't, \\\n+                                               or vice versa\"));\n+            }\n+        }\n+    }\n+\n     fn substs(&self, generics: &ty::Generics, as_: &ty::substs,\n-              bs: &ty::substs) -> cres<ty::substs>;\n+              bs: &ty::substs) -> cres<ty::substs> {\n+\n+        fn relate_region_params<C:Combine>(\n+                                           this: &C,\n+                                           generics: &ty::Generics,\n+                                           a: &ty::RegionSubsts,\n+                                           b: &ty::RegionSubsts)\n+            -> cres<ty::RegionSubsts>\n+            {\n+            match (a, b) {\n+                (&ty::ErasedRegions, _) |\n+                    (_, &ty::ErasedRegions) => {\n+                    Ok(ty::ErasedRegions)\n+                }\n+\n+                (&ty::NonerasedRegions(ref a_rs),\n+                 &ty::NonerasedRegions(ref b_rs)) => {\n+                    match generics.region_param {\n+                        None => {\n+                            assert!(a_rs.is_empty());\n+                            assert!(b_rs.is_empty());\n+                            Ok(ty::NonerasedRegions(opt_vec::Empty))\n+                        }\n+\n+                        Some(variance) => {\n+                            assert_eq!(a_rs.len(), 1);\n+                            assert_eq!(b_rs.len(), 1);\n+                            let a_r = *a_rs.get(0);\n+                            let b_r = *b_rs.get(0);\n+\n+                            match variance {\n+                                ty::rv_invariant => {\n+                                    do eq_regions(this, a_r, b_r).then {\n+                                        Ok(ty::NonerasedRegions(opt_vec::with(a_r)))\n+                                    }\n+                                }\n+\n+                                ty::rv_covariant => {\n+                                    do this.regions(a_r, b_r).chain |r| {\n+                                        Ok(ty::NonerasedRegions(opt_vec::with(r)))\n+                                    }\n+                                }\n+\n+                                ty::rv_contravariant => {\n+                                    do this.contraregions(a_r, b_r).chain |r| {\n+                                        Ok(ty::NonerasedRegions(opt_vec::with(r)))\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        do self.tps(as_.tps, bs.tps).chain |tps| {\n+            do self.self_tys(as_.self_ty, bs.self_ty).chain |self_ty| {\n+                do relate_region_params(self,\n+                                        generics,\n+                                        &as_.regions,\n+                                        &bs.regions).chain |regions| {\n+                    Ok(substs {\n+                            regions: regions,\n+                            self_ty: self_ty,\n+                            tps: tps.clone()\n+                        })\n+                }\n+            }\n+        }\n+    }\n+\n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n-                   b: &ty::BareFnTy) -> cres<ty::BareFnTy>;\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+        let purity = if_ok!(self.purities(a.purity, b.purity));\n+        let abi = if_ok!(self.abis(a.abis, b.abis));\n+        let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n+        Ok(ty::BareFnTy {purity: purity,\n+                abis: abi,\n+                sig: sig})\n+    }\n+\n     fn closure_tys(&self, a: &ty::ClosureTy,\n-                   b: &ty::ClosureTy) -> cres<ty::ClosureTy>;\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+\n+        let p = if_ok!(self.sigils(a.sigil, b.sigil));\n+        let r = if_ok!(self.contraregions(a.region, b.region));\n+        let purity = if_ok!(self.purities(a.purity, b.purity));\n+        let onceness = if_ok!(self.oncenesses(a.onceness, b.onceness));\n+        let bounds = if_ok!(self.bounds(a.bounds, b.bounds));\n+        let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n+        Ok(ty::ClosureTy {purity: purity,\n+                sigil: p,\n+                onceness: onceness,\n+                region: r,\n+                bounds: bounds,\n+                sig: sig})\n+    }\n+\n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n-    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field>;\n-    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n+\n+    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n+        if a.ident == b.ident {\n+            self.mts(&a.mt, &b.mt)\n+                .chain(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n+                .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n+        } else {\n+            Err(ty::terr_record_fields(\n+                                       expected_found(self,\n+                                                      a.ident,\n+                                                      b.ident)))\n+        }\n+    }\n+\n+    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        do self.contratys(a, b).chain |t| {\n+            Ok(t)\n+        }\n+    }\n+\n+    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        if p1 == p2 {\n+            Ok(p1)\n+        } else {\n+            Err(ty::terr_sigil_mismatch(expected_found(self, p1, p2)))\n+        }\n+    }\n+\n     fn purities(&self, a: purity, b: purity) -> cres<purity>;\n-    fn abis(&self, a: AbiSet, b: AbiSet) -> cres<AbiSet>;\n+\n+    fn abis(&self, a: AbiSet, b: AbiSet) -> cres<AbiSet> {\n+        if a == b {\n+            Ok(a)\n+        } else {\n+            Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n+        }\n+    }\n+\n     fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness>;\n     fn bounds(&self, a: BuiltinBounds, b: BuiltinBounds) -> cres<BuiltinBounds>;\n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                   -> cres<ty::Region>;\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n+\n     fn vstores(&self, vk: ty::terr_vstore_kind,\n-               a: ty::vstore, b: ty::vstore) -> cres<ty::vstore>;\n+               a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n+\n+        debug!(\"%s.vstores(a=%?, b=%?)\", self.tag(), a, b);\n+\n+        match (a, b) {\n+            (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n+                do self.contraregions(a_r, b_r).chain |r| {\n+                    Ok(ty::vstore_slice(r))\n+                }\n+            }\n+\n+            _ if a == b => {\n+                Ok(a)\n+            }\n+\n+            _ => {\n+                Err(ty::terr_vstores_differ(vk, expected_found(self, a, b)))\n+            }\n+        }\n+    }\n+\n     fn trait_stores(&self,\n                     vk: ty::terr_vstore_kind,\n                     a: ty::TraitStore,\n                     b: ty::TraitStore)\n-                 -> cres<ty::TraitStore>;\n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>;\n+                 -> cres<ty::TraitStore> {\n+\n+        debug!(\"%s.trait_stores(a=%?, b=%?)\", self.tag(), a, b);\n+\n+        match (a, b) {\n+            (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n+                do self.contraregions(a_r, b_r).chain |r| {\n+                    Ok(ty::RegionTraitStore(r))\n+                }\n+            }\n+\n+            _ if a == b => {\n+                Ok(a)\n+            }\n+\n+            _ => {\n+                Err(ty::terr_trait_stores_differ(vk, expected_found(self, a, b)))\n+            }\n+        }\n+\n+    }\n+\n+    fn trait_refs(&self,\n+                  a: &ty::TraitRef,\n+                  b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        // Different traits cannot be related\n+\n+        // - NOTE in the future, expand out subtraits!\n+\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(\n+                                expected_found(self, a.def_id, b.def_id)))\n+        } else {\n+            let tcx = self.infcx().tcx;\n+            let trait_def = ty::lookup_trait_def(tcx, a.def_id);\n+            let substs = if_ok!(self.substs(&trait_def.generics,\n+                                            &a.substs,\n+                                            &b.substs));\n+            Ok(ty::TraitRef {\n+                    def_id: a.def_id,\n+                    substs: substs\n+                })\n+        }\n+    }\n }\n \n pub struct CombineFields {\n@@ -193,238 +415,9 @@ pub fn eq_opt_regions<C:Combine>(\n     }\n }\n \n-pub fn super_substs<C:Combine>(\n-    this: &C, generics: &ty::Generics,\n-    a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n-\n-    fn relate_region_params<C:Combine>(\n-        this: &C,\n-        generics: &ty::Generics,\n-        a: &ty::RegionSubsts,\n-        b: &ty::RegionSubsts)\n-        -> cres<ty::RegionSubsts>\n-    {\n-        match (a, b) {\n-            (&ty::ErasedRegions, _) |\n-            (_, &ty::ErasedRegions) => {\n-                Ok(ty::ErasedRegions)\n-            }\n-\n-            (&ty::NonerasedRegions(ref a_rs),\n-             &ty::NonerasedRegions(ref b_rs)) => {\n-                match generics.region_param {\n-                    None => {\n-                        assert!(a_rs.is_empty());\n-                        assert!(b_rs.is_empty());\n-                        Ok(ty::NonerasedRegions(opt_vec::Empty))\n-                    }\n-\n-                    Some(variance) => {\n-                        assert_eq!(a_rs.len(), 1);\n-                        assert_eq!(b_rs.len(), 1);\n-                        let a_r = *a_rs.get(0);\n-                        let b_r = *b_rs.get(0);\n-\n-                        match variance {\n-                            ty::rv_invariant => {\n-                                do eq_regions(this, a_r, b_r).then {\n-                                    Ok(ty::NonerasedRegions(opt_vec::with(a_r)))\n-                                }\n-                            }\n-\n-                            ty::rv_covariant => {\n-                                do this.regions(a_r, b_r).chain |r| {\n-                                    Ok(ty::NonerasedRegions(opt_vec::with(r)))\n-                                }\n-                            }\n-\n-                            ty::rv_contravariant => {\n-                                do this.contraregions(a_r, b_r).chain |r| {\n-                                    Ok(ty::NonerasedRegions(opt_vec::with(r)))\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    do this.tps(a.tps, b.tps).chain |tps| {\n-        do this.self_tys(a.self_ty, b.self_ty).chain |self_ty| {\n-            do relate_region_params(this,\n-                                    generics,\n-                                    &a.regions,\n-                                    &b.regions).chain |regions| {\n-                Ok(substs {\n-                    regions: regions,\n-                    self_ty: self_ty,\n-                    tps: tps.clone()\n-                })\n-            }\n-        }\n-    }\n-}\n-\n-pub fn super_tps<C:Combine>(\n-    this: &C, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n-\n-    // Note: type parameters are always treated as *invariant*\n-    // (otherwise the type system would be unsound).  In the\n-    // future we could allow type parameters to declare a\n-    // variance.\n-\n-    if vec::same_length(as_, bs) {\n-        result::fold_(as_.iter().zip(bs.iter())\n-                      .map(|(a, b)| eq_tys(this, *a, *b)))\n-            .then(|| Ok(as_.to_owned()))\n-    } else {\n-        Err(ty::terr_ty_param_size(\n-            expected_found(this, as_.len(), bs.len())))\n-    }\n-}\n-\n-pub fn super_self_tys<C:Combine>(\n-    this: &C, a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n-\n-    match (a, b) {\n-      (None, None) => {\n-        Ok(None)\n-      }\n-      (Some(a), Some(b)) => {\n-          // FIXME(#5781) this should be eq_tys\n-          // eq_tys(this, a, b).then(|| Ok(Some(a)) )\n-          this.contratys(a, b).chain(|t| Ok(Some(t)))\n-      }\n-      (None, Some(_)) |\n-      (Some(_), None) => {\n-        // I think it should never happen that we unify two substs and\n-        // one of them has a self_ty and one doesn't...? I could be\n-        // wrong about this.\n-          this.infcx().tcx.sess.bug(\n-              fmt!(\"substitution a had a self_ty and substitution b didn't, \\\n-                    or vice versa\"));\n-      }\n-    }\n-}\n-\n-pub fn super_sigils<C:Combine>(\n-    this: &C, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-    if p1 == p2 {\n-        Ok(p1)\n-    } else {\n-        Err(ty::terr_sigil_mismatch(expected_found(this, p1, p2)))\n-    }\n-}\n-\n-pub fn super_flds<C:Combine>(\n-    this: &C, a: ty::field, b: ty::field) -> cres<ty::field> {\n-\n-    if a.ident == b.ident {\n-        this.mts(&a.mt, &b.mt)\n-            .chain(|mt| Ok(ty::field {ident: a.ident, mt: mt}) )\n-            .chain_err(|e| Err(ty::terr_in_field(@e, a.ident)) )\n-    } else {\n-        Err(ty::terr_record_fields(\n-            expected_found(this, a.ident, b.ident)))\n-    }\n-}\n-\n-pub fn super_args<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n-    do this.contratys(a, b).chain |t| {\n-        Ok(t)\n-    }\n-}\n-\n-pub fn super_vstores<C:Combine>(this: &C,\n-                                vk: ty::terr_vstore_kind,\n-                                a: ty::vstore,\n-                                b: ty::vstore)\n-                                -> cres<ty::vstore> {\n-    debug!(\"%s.super_vstores(a=%?, b=%?)\", this.tag(), a, b);\n-\n-    match (a, b) {\n-      (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n-        do this.contraregions(a_r, b_r).chain |r| {\n-            Ok(ty::vstore_slice(r))\n-        }\n-      }\n-\n-      _ if a == b => {\n-        Ok(a)\n-      }\n-\n-      _ => {\n-        Err(ty::terr_vstores_differ(vk, expected_found(this, a, b)))\n-      }\n-    }\n-}\n-\n-pub fn super_trait_stores<C:Combine>(this: &C,\n-                                     vk: ty::terr_vstore_kind,\n-                                     a: ty::TraitStore,\n-                                     b: ty::TraitStore)\n-                                  -> cres<ty::TraitStore> {\n-    debug!(\"%s.super_vstores(a=%?, b=%?)\", this.tag(), a, b);\n-\n-    match (a, b) {\n-      (ty::RegionTraitStore(a_r), ty::RegionTraitStore(b_r)) => {\n-        do this.contraregions(a_r, b_r).chain |r| {\n-            Ok(ty::RegionTraitStore(r))\n-        }\n-      }\n-\n-      _ if a == b => {\n-        Ok(a)\n-      }\n-\n-      _ => {\n-        Err(ty::terr_trait_stores_differ(vk, expected_found(this, a, b)))\n-      }\n-    }\n-}\n-\n-pub fn super_closure_tys<C:Combine>(\n-    this: &C, a_f: &ty::ClosureTy, b_f: &ty::ClosureTy) -> cres<ty::ClosureTy>\n-{\n-    let p = if_ok!(this.sigils(a_f.sigil, b_f.sigil));\n-    let r = if_ok!(this.contraregions(a_f.region, b_f.region));\n-    let purity = if_ok!(this.purities(a_f.purity, b_f.purity));\n-    let onceness = if_ok!(this.oncenesses(a_f.onceness, b_f.onceness));\n-    let bounds = if_ok!(this.bounds(a_f.bounds, b_f.bounds));\n-    let sig = if_ok!(this.fn_sigs(&a_f.sig, &b_f.sig));\n-    Ok(ty::ClosureTy {purity: purity,\n-                      sigil: p,\n-                      onceness: onceness,\n-                      region: r,\n-                      bounds: bounds,\n-                      sig: sig})\n-}\n-\n-pub fn super_abis<C:Combine>(\n-    this: &C, a: AbiSet, b: AbiSet) -> cres<AbiSet>\n-{\n-    if a == b {\n-        Ok(a)\n-    } else {\n-        Err(ty::terr_abi_mismatch(expected_found(this, a, b)))\n-    }\n-}\n-\n-pub fn super_bare_fn_tys<C:Combine>(\n-    this: &C, a_f: &ty::BareFnTy, b_f: &ty::BareFnTy) -> cres<ty::BareFnTy>\n-{\n-    let purity = if_ok!(this.purities(a_f.purity, b_f.purity));\n-    let abi = if_ok!(this.abis(a_f.abis, b_f.abis));\n-    let sig = if_ok!(this.fn_sigs(&a_f.sig, &b_f.sig));\n-    Ok(ty::BareFnTy {purity: purity,\n-                     abis: abi,\n-                     sig: sig})\n-}\n-\n pub fn super_fn_sigs<C:Combine>(\n-    this: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n-{\n+    this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+\n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n         if vec::same_length(a_args, b_args) {\n             result::collect(a_args.iter().zip(b_args.iter())\n@@ -434,9 +427,9 @@ pub fn super_fn_sigs<C:Combine>(\n         }\n     }\n \n-    do argvecs(this, a_f.inputs, b_f.inputs)\n+    do argvecs(this, a.inputs, b.inputs)\n             .chain |inputs| {\n-        do this.tys(a_f.output, b_f.output).chain |output| {\n+        do this.tys(a.output, b.output).chain |output| {\n             Ok(FnSig {bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n                       inputs: inputs.clone(),\n                       output: output})\n@@ -638,24 +631,3 @@ pub fn super_tys<C:Combine>(\n         Ok(ty::mk_mach_float(val))\n     }\n }\n-\n-pub fn super_trait_refs<C:Combine>(\n-    this: &C, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef>\n-{\n-    // Different traits cannot be related\n-\n-    // - NOTE in the future, expand out subtraits!\n-\n-    if a.def_id != b.def_id {\n-        Err(ty::terr_traits(\n-            expected_found(this, a.def_id, b.def_id)))\n-    } else {\n-        let tcx = this.infcx().tcx;\n-        let trait_def = ty::lookup_trait_def(tcx, a.def_id);\n-        let substs = if_ok!(this.substs(&trait_def.generics, &a.substs, &b.substs));\n-        Ok(ty::TraitRef {\n-            def_id: a.def_id,\n-            substs: substs\n-        })\n-    }\n-}"}, {"sha": "2e337f5f57b74b465d49c8ac5699b1963955a551", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=063a005459a3ece4022e1fdb6400548c7ad2358e", "patch": "@@ -21,11 +21,9 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::isr_alist;\n-use syntax::ast;\n use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n-use syntax::abi::AbiSet;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n \n@@ -139,29 +137,6 @@ impl Combine for Glb {\n         super_lattice_tys(self, a, b)\n     }\n \n-    // Traits please (FIXME: #2794):\n-\n-    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(self, a, b)\n-    }\n-\n-    fn vstores(&self, vk: ty::terr_vstore_kind,\n-               a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(self, vk, a, b)\n-    }\n-\n-    fn trait_stores(&self,\n-                    vk: ty::terr_vstore_kind,\n-                    a: ty::TraitStore,\n-                    b: ty::TraitStore)\n-                 -> cres<ty::TraitStore> {\n-        super_trait_stores(self, vk, a, b)\n-    }\n-\n-    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_args(self, a, b)\n-    }\n-\n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n@@ -290,42 +265,4 @@ impl Combine for Glb {\n             this.infcx.region_vars.new_bound()\n         }\n     }\n-\n-    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-        super_sigils(self, p1, p2)\n-    }\n-\n-    fn abis(&self, p1: AbiSet, p2: AbiSet) -> cres<AbiSet> {\n-        super_abis(self, p1, p2)\n-    }\n-\n-    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n-                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        super_bare_fn_tys(self, a, b)\n-    }\n-\n-    fn closure_tys(&self, a: &ty::ClosureTy,\n-                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n-        super_closure_tys(self, a, b)\n-    }\n-\n-    fn substs(&self,\n-              generics: &ty::Generics,\n-              as_: &ty::substs,\n-              bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, generics, as_, bs)\n-    }\n-\n-    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(self, as_, bs)\n-    }\n-\n-    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n-               -> cres<Option<ty::t>> {\n-        super_self_tys(self, a, b)\n-    }\n-\n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n-        super_trait_refs(self, a, b)\n-    }\n }"}, {"sha": "4f38e2aaac6b6f524e78a5bec325647a4e58b59b", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=063a005459a3ece4022e1fdb6400548c7ad2358e", "patch": "@@ -24,8 +24,6 @@ use middle::typeck::isr_alist;\n use util::ppaux::mt_to_str;\n \n use extra::list;\n-use syntax::abi::AbiSet;\n-use syntax::ast;\n use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n@@ -206,69 +204,7 @@ impl Combine for Lub {\n         }\n     }\n \n-    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n-                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        super_bare_fn_tys(self, a, b)\n-    }\n-\n-    fn closure_tys(&self, a: &ty::ClosureTy,\n-                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n-        super_closure_tys(self, a, b)\n-    }\n-\n-    // Traits please (FIXME: #2794):\n-\n-    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil)\n-             -> cres<ast::Sigil> {\n-        super_sigils(self, p1, p2)\n-    }\n-\n-    fn abis(&self, p1: AbiSet, p2: AbiSet) -> cres<AbiSet> {\n-        super_abis(self, p1, p2)\n-    }\n-\n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         super_lattice_tys(self, a, b)\n     }\n-\n-    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(self, a, b)\n-    }\n-\n-    fn vstores(&self, vk: ty::terr_vstore_kind,\n-               a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(self, vk, a, b)\n-    }\n-\n-    fn trait_stores(&self,\n-                    vk: ty::terr_vstore_kind,\n-                    a: ty::TraitStore,\n-                    b: ty::TraitStore)\n-                 -> cres<ty::TraitStore> {\n-        super_trait_stores(self, vk, a, b)\n-    }\n-\n-    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_args(self, a, b)\n-    }\n-\n-    fn substs(&self,\n-              generics: &ty::Generics,\n-              as_: &ty::substs,\n-              bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, generics, as_, bs)\n-    }\n-\n-    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(self, as_, bs)\n-    }\n-\n-    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n-               -> cres<Option<ty::t>> {\n-        super_self_tys(self, a, b)\n-    }\n-\n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n-        super_trait_refs(self, a, b)\n-    }\n }"}, {"sha": "5a4ea1c9f1f58e3f56c3b228d1fb121a268769ce", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/063a005459a3ece4022e1fdb6400548c7ad2358e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=063a005459a3ece4022e1fdb6400548c7ad2358e", "patch": "@@ -26,8 +26,6 @@ use util::ppaux::bound_region_to_str;\n \n use extra::list::Nil;\n use extra::list;\n-use syntax::abi::AbiSet;\n-use syntax::ast;\n use syntax::ast::{Onceness, m_const, purity};\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n@@ -225,64 +223,4 @@ impl Combine for Sub {\n         ret\n     }\n \n-    // Traits please (FIXME: #2794):\n-\n-    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-        super_sigils(self, p1, p2)\n-    }\n-\n-    fn abis(&self, p1: AbiSet, p2: AbiSet) -> cres<AbiSet> {\n-        super_abis(self, p1, p2)\n-    }\n-\n-    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(self, a, b)\n-    }\n-\n-    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n-                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        super_bare_fn_tys(self, a, b)\n-    }\n-\n-    fn closure_tys(&self, a: &ty::ClosureTy,\n-                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n-        super_closure_tys(self, a, b)\n-    }\n-\n-    fn vstores(&self, vk: ty::terr_vstore_kind,\n-               a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(self, vk, a, b)\n-    }\n-\n-    fn trait_stores(&self,\n-                    vk: ty::terr_vstore_kind,\n-                    a: ty::TraitStore,\n-                    b: ty::TraitStore)\n-                    -> cres<ty::TraitStore> {\n-        super_trait_stores(self, vk, a, b)\n-    }\n-\n-    fn args(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_args(self, a, b)\n-    }\n-\n-    fn substs(&self,\n-              generics: &ty::Generics,\n-              as_: &ty::substs,\n-              bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(self, generics, as_, bs)\n-    }\n-\n-    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(self, as_, bs)\n-    }\n-\n-    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n-               -> cres<Option<ty::t>> {\n-        super_self_tys(self, a, b)\n-    }\n-\n-    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n-        super_trait_refs(self, a, b)\n-    }\n }"}]}