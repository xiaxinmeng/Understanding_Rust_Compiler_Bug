{"sha": "d2faba28c027a9e5f5925b403bfbdb34062624f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZmFiYTI4YzAyN2E5ZTVmNTkyNWI0MDNiZmJkYjM0MDYyNjI0ZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-21T02:40:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-21T02:40:40Z"}, "message": "Auto merge of #28552 - apasel422:issue-28527, r=Manishearth\n\nCloses #28527.\r\n\r\nr? @Manishearth", "tree": {"sha": "0cbfb5e7e856bf80f1daf692df61a350460b3c4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cbfb5e7e856bf80f1daf692df61a350460b3c4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2faba28c027a9e5f5925b403bfbdb34062624f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2faba28c027a9e5f5925b403bfbdb34062624f0", "html_url": "https://github.com/rust-lang/rust/commit/d2faba28c027a9e5f5925b403bfbdb34062624f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2faba28c027a9e5f5925b403bfbdb34062624f0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0418a43fa3ce430d18e87c66afb2185395f354d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0418a43fa3ce430d18e87c66afb2185395f354d6", "html_url": "https://github.com/rust-lang/rust/commit/0418a43fa3ce430d18e87c66afb2185395f354d6"}, {"sha": "85b8b447fa3c6fc4aa2e7d957ac15357d0cb3861", "url": "https://api.github.com/repos/rust-lang/rust/commits/85b8b447fa3c6fc4aa2e7d957ac15357d0cb3861", "html_url": "https://github.com/rust-lang/rust/commit/85b8b447fa3c6fc4aa2e7d957ac15357d0cb3861"}], "stats": {"total": 253, "additions": 114, "deletions": 139}, "files": [{"sha": "7b2b2c9012608e34d1c51183d87dd31cdaa973c1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d2faba28c027a9e5f5925b403bfbdb34062624f0", "patch": "@@ -28,7 +28,6 @@ pub use self::Item_::*;\n pub use self::KleeneOp::*;\n pub use self::Lit_::*;\n pub use self::LitIntType::*;\n-pub use self::Mac_::*;\n pub use self::MacStmtStyle::*;\n pub use self::MetaItem_::*;\n pub use self::Mutability::*;\n@@ -1132,12 +1131,13 @@ pub type Mac = Spanned<Mac_>;\n /// is being invoked, and the vector of token-trees contains the source\n /// of the macro invocation.\n ///\n-/// There's only one flavor, now, so this could presumably be simplified.\n+/// NB: the additional ident for a macro_rules-style macro is actually\n+/// stored in the enclosing item. Oog.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Mac_ {\n-    // NB: the additional ident for a macro_rules-style macro is actually\n-    // stored in the enclosing item. Oog.\n-    MacInvocTT(Path, Vec<TokenTree>, SyntaxContext),   // new macro-invocation\n+pub struct Mac_ {\n+    pub path: Path,\n+    pub tts: Vec<TokenTree>,\n+    pub ctxt: SyntaxContext,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "6e0fbbec770c69a592fed2f4e3f6df6590da0285", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 75, "deletions": 88, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d2faba28c027a9e5f5925b403bfbdb34062624f0", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast::{Block, Crate, DeclLocal, ExprMac, PatMac};\n-use ast::{Local, Ident, MacInvocTT};\n+use ast::{Local, Ident, Mac_};\n use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtDecl, StmtMac};\n use ast::{StmtExpr, StmtSemi};\n use ast::TokenTree;\n@@ -509,78 +509,75 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n     F: for<'a> FnOnce(Box<MacResult+'a>) -> Option<T>,\n     G: FnOnce(T, Mrk) -> T,\n {\n-    match mac.node {\n-        // it would almost certainly be cleaner to pass the whole\n-        // macro invocation in, rather than pulling it apart and\n-        // marking the tts and the ctxt separately. This also goes\n-        // for the other three macro invocation chunks of code\n-        // in this file.\n-        // Token-tree macros:\n-        MacInvocTT(pth, tts, _) => {\n-            if pth.segments.len() > 1 {\n-                fld.cx.span_err(pth.span,\n-                                \"expected macro name without module \\\n-                                separators\");\n-                // let compilation continue\n-                return None;\n-            }\n-            let extname = pth.segments[0].identifier.name;\n-            match fld.cx.syntax_env.find(&extname) {\n-                None => {\n-                    fld.cx.span_err(\n-                        pth.span,\n-                        &format!(\"macro undefined: '{}!'\",\n-                                &extname));\n+    // it would almost certainly be cleaner to pass the whole\n+    // macro invocation in, rather than pulling it apart and\n+    // marking the tts and the ctxt separately. This also goes\n+    // for the other three macro invocation chunks of code\n+    // in this file.\n+\n+    let Mac_ { path: pth, tts, .. } = mac.node;\n+    if pth.segments.len() > 1 {\n+        fld.cx.span_err(pth.span,\n+                        \"expected macro name without module \\\n+                        separators\");\n+        // let compilation continue\n+        return None;\n+    }\n+    let extname = pth.segments[0].identifier.name;\n+    match fld.cx.syntax_env.find(&extname) {\n+        None => {\n+            fld.cx.span_err(\n+                pth.span,\n+                &format!(\"macro undefined: '{}!'\",\n+                        &extname));\n \n-                    // let compilation continue\n-                    None\n-                }\n-                Some(rc) => match *rc {\n-                    NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n-                        fld.cx.bt_push(ExpnInfo {\n-                                call_site: span,\n-                                callee: NameAndSpan {\n-                                    format: MacroBang(extname),\n-                                    span: exp_span,\n-                                    allow_internal_unstable: allow_internal_unstable,\n-                                },\n-                            });\n-                        let fm = fresh_mark();\n-                        let marked_before = mark_tts(&tts[..], fm);\n-\n-                        // The span that we pass to the expanders we want to\n-                        // be the root of the call stack. That's the most\n-                        // relevant span and it's the actual invocation of\n-                        // the macro.\n-                        let mac_span = fld.cx.original_span();\n-\n-                        let opt_parsed = {\n-                            let expanded = expandfun.expand(fld.cx,\n-                                                            mac_span,\n-                                                            &marked_before[..]);\n-                            parse_thunk(expanded)\n-                        };\n-                        let parsed = match opt_parsed {\n-                            Some(e) => e,\n-                            None => {\n-                                fld.cx.span_err(\n-                                    pth.span,\n-                                    &format!(\"non-expression macro in expression position: {}\",\n-                                            extname\n-                                            ));\n-                                return None;\n-                            }\n-                        };\n-                        Some(mark_thunk(parsed,fm))\n-                    }\n-                    _ => {\n+            // let compilation continue\n+            None\n+        }\n+        Some(rc) => match *rc {\n+            NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n+                fld.cx.bt_push(ExpnInfo {\n+                        call_site: span,\n+                        callee: NameAndSpan {\n+                            format: MacroBang(extname),\n+                            span: exp_span,\n+                            allow_internal_unstable: allow_internal_unstable,\n+                        },\n+                    });\n+                let fm = fresh_mark();\n+                let marked_before = mark_tts(&tts[..], fm);\n+\n+                // The span that we pass to the expanders we want to\n+                // be the root of the call stack. That's the most\n+                // relevant span and it's the actual invocation of\n+                // the macro.\n+                let mac_span = fld.cx.original_span();\n+\n+                let opt_parsed = {\n+                    let expanded = expandfun.expand(fld.cx,\n+                                                    mac_span,\n+                                                    &marked_before[..]);\n+                    parse_thunk(expanded)\n+                };\n+                let parsed = match opt_parsed {\n+                    Some(e) => e,\n+                    None => {\n                         fld.cx.span_err(\n                             pth.span,\n-                            &format!(\"'{}' is not a tt-style macro\",\n-                                    extname));\n-                        None\n+                            &format!(\"non-expression macro in expression position: {}\",\n+                                    extname\n+                                    ));\n+                        return None;\n                     }\n-                }\n+                };\n+                Some(mark_thunk(parsed,fm))\n+            }\n+            _ => {\n+                fld.cx.span_err(\n+                    pth.span,\n+                    &format!(\"'{}' is not a tt-style macro\",\n+                            extname));\n+                None\n             }\n         }\n     }\n@@ -684,15 +681,11 @@ fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(it: P<ast::Item>,\n                        fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n-    let (extname, path_span, tts, span, attrs, ident) = it.and_then(|it| { match it.node {\n-        ItemMac(codemap::Spanned {\n-            node: MacInvocTT(pth, tts, _),\n-            ..\n-        }) => {\n-            (pth.segments[0].identifier.name, pth.span, tts, it.span, it.attrs, it.ident)\n-        }\n+    let (extname, path_span, tts, span, attrs, ident) = it.and_then(|it| match it.node {\n+        ItemMac(codemap::Spanned { node: Mac_ { path, tts, .. }, .. }) =>\n+            (path.segments[0].identifier.name, path.span, tts, it.span, it.attrs, it.ident),\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n-    }});\n+    });\n \n     let fm = fresh_mark();\n     let items = {\n@@ -1060,11 +1053,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     }\n     p.map(|ast::Pat {node, span, ..}| {\n         let (pth, tts) = match node {\n-            PatMac(mac) => match mac.node {\n-                MacInvocTT(pth, tts, _) => {\n-                    (pth, tts)\n-                }\n-            },\n+            PatMac(mac) => (mac.node.path, mac.node.tts),\n             _ => unreachable!()\n         };\n         if pth.segments.len() > 1 {\n@@ -1646,12 +1635,10 @@ impl Folder for Marker {\n     }\n     fn fold_mac(&mut self, Spanned {node, span}: ast::Mac) -> ast::Mac {\n         Spanned {\n-            node: match node {\n-                MacInvocTT(path, tts, ctxt) => {\n-                    MacInvocTT(self.fold_path(path),\n-                               self.fold_tts(&tts[..]),\n-                               mtwt::apply_mark(self.mark, ctxt))\n-                }\n+            node: Mac_ {\n+                path: self.fold_path(node.path),\n+                tts: self.fold_tts(&node.tts),\n+                ctxt: mtwt::apply_mark(self.mark, node.ctxt),\n             },\n             span: span,\n         }"}, {"sha": "be95b58bf881e5c7af4132b388160d033ca0a2fa", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d2faba28c027a9e5f5925b403bfbdb34062624f0", "patch": "@@ -666,7 +666,7 @@ struct MacroVisitor<'a> {\n \n impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n     fn visit_mac(&mut self, mac: &ast::Mac) {\n-        let ast::MacInvocTT(ref path, _, _) = mac.node;\n+        let path = &mac.node.path;\n         let id = path.segments.last().unwrap().identifier;\n \n         // Issue 22234: If you add a new case here, make sure to also"}, {"sha": "e97c763ca4cdc5a82da21dbf8eb529f99d7fc155", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d2faba28c027a9e5f5925b403bfbdb34062624f0", "patch": "@@ -567,10 +567,10 @@ pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fl\n \n pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n-        node: match node {\n-            MacInvocTT(p, tts, ctxt) => {\n-                MacInvocTT(fld.fold_path(p), fld.fold_tts(&tts), ctxt)\n-            }\n+        node: Mac_ {\n+            path: fld.fold_path(node.path),\n+            tts: fld.fold_tts(&node.tts),\n+            ctxt: node.ctxt,\n         },\n         span: fld.new_span(span)\n     }"}, {"sha": "279c987fcba6567c5b69b6d0c7dfe9e4948aea00", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d2faba28c027a9e5f5925b403bfbdb34062624f0", "patch": "@@ -1090,10 +1090,7 @@ mod tests {\n             \"foo!( fn main() { body } )\".to_string(), vec![], &sess);\n \n         let tts = match expr.node {\n-            ast::ExprMac(ref mac) => {\n-                let ast::MacInvocTT(_, ref tts, _) = mac.node;\n-                tts.clone()\n-            }\n+            ast::ExprMac(ref mac) => mac.node.tts.clone(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "6220bd6fa6fb1ee77f1565030fb13a23eb07e034", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d2faba28c027a9e5f5925b403bfbdb34062624f0", "patch": "@@ -37,7 +37,7 @@ use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitByteStr};\n use ast::{LitStr, LitInt, Local};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n-use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n+use ast::{MutImmutable, MutMutable, Mac_, MatchSource};\n use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatQPath, PatMac, PatRange};\n@@ -1381,7 +1381,7 @@ impl<'a> Parser<'a> {\n                                                      seq_sep_none(),\n                                                      |p| p.parse_token_tree()));\n                 let hi = self.span.hi;\n-                TyMac(spanned(lo, hi, MacInvocTT(path, tts, EMPTY_CTXT)))\n+                TyMac(spanned(lo, hi, Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT }))\n             } else {\n                 // NAMED TYPE\n                 TyPath(None, path)\n@@ -2203,9 +2203,7 @@ impl<'a> Parser<'a> {\n \n                         return Ok(self.mk_mac_expr(lo,\n                                                    hi,\n-                                                   MacInvocTT(pth,\n-                                                              tts,\n-                                                              EMPTY_CTXT)));\n+                                                   Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -3289,7 +3287,7 @@ impl<'a> Parser<'a> {\n                         let delim = try!(self.expect_open_delim());\n                         let tts = try!(self.parse_seq_to_end(&token::CloseDelim(delim),\n                                 seq_sep_none(), |p| p.parse_token_tree()));\n-                        let mac = MacInvocTT(path, tts, EMPTY_CTXT);\n+                        let mac = Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT };\n                         pat = PatMac(codemap::Spanned {node: mac, span: self.span});\n                     } else {\n                         // Parse ident @ pat\n@@ -3557,7 +3555,7 @@ impl<'a> Parser<'a> {\n                 spanned(lo, hi,\n                         StmtMac(P(spanned(lo,\n                                           hi,\n-                                          MacInvocTT(pth, tts, EMPTY_CTXT))),\n+                                          Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n                                   style))\n             } else {\n                 // if it has a special ident, it's definitely an item\n@@ -3576,7 +3574,8 @@ impl<'a> Parser<'a> {\n                     P(spanned(lo, hi, DeclItem(\n                         self.mk_item(\n                             lo, hi, id /*id is good here*/,\n-                            ItemMac(spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT))),\n+                            ItemMac(spanned(lo, hi,\n+                                            Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n                             Inherited, Vec::new(/*no attrs*/))))),\n                     ast::DUMMY_NODE_ID))\n             }\n@@ -4524,7 +4523,7 @@ impl<'a> Parser<'a> {\n             let tts = try!(self.parse_seq_to_end(&token::CloseDelim(delim),\n                                             seq_sep_none(),\n                                             |p| p.parse_token_tree()));\n-            let m_ = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n+            let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m_,\n                                                 span: mk_sp(self.span.lo,\n                                                             self.span.hi) };\n@@ -5606,7 +5605,7 @@ impl<'a> Parser<'a> {\n                                             seq_sep_none(),\n                                             |p| p.parse_token_tree()));\n             // single-variant-enum... :\n-            let m = ast::MacInvocTT(pth, tts, EMPTY_CTXT);\n+            let m = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };"}, {"sha": "915abd4c0eb387f3fc3dc0da3fc5642aa7844739", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2faba28c027a9e5f5925b403bfbdb34062624f0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d2faba28c027a9e5f5925b403bfbdb34062624f0", "patch": "@@ -1307,16 +1307,14 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            // I think it's reasonable to hide the context here:\n-            ast::ItemMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n-                                            ..}) => {\n+            ast::ItemMac(codemap::Spanned { ref node, .. }) => {\n                 try!(self.print_visibility(item.vis));\n-                try!(self.print_path(pth, false, 0));\n+                try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(&tts[..]));\n+                try!(self.print_tts(&node.tts[..]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end());\n@@ -1599,14 +1597,13 @@ impl<'a> State<'a> {\n             ast::TypeImplItem(ref ty) => {\n                 try!(self.print_associated_type(ii.ident, None, Some(ty)));\n             }\n-            ast::MacImplItem(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n-                                                ..}) => {\n+            ast::MacImplItem(codemap::Spanned { ref node, .. }) => {\n                 // code copied from ItemMac:\n-                try!(self.print_path(pth, false, 0));\n+                try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(&tts[..]));\n+                try!(self.print_tts(&node.tts[..]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end())\n@@ -1765,23 +1762,18 @@ impl<'a> State<'a> {\n \n     pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n                      -> io::Result<()> {\n-        match m.node {\n-            // I think it's reasonable to hide the ctxt here:\n-            ast::MacInvocTT(ref pth, ref tts, _) => {\n-                try!(self.print_path(pth, false, 0));\n-                try!(word(&mut self.s, \"!\"));\n-                match delim {\n-                    token::Paren => try!(self.popen()),\n-                    token::Bracket => try!(word(&mut self.s, \"[\")),\n-                    token::Brace => try!(self.bopen()),\n-                }\n-                try!(self.print_tts(tts));\n-                match delim {\n-                    token::Paren => self.pclose(),\n-                    token::Bracket => word(&mut self.s, \"]\"),\n-                    token::Brace => self.bclose(m.span),\n-                }\n-            }\n+        try!(self.print_path(&m.node.path, false, 0));\n+        try!(word(&mut self.s, \"!\"));\n+        match delim {\n+            token::Paren => try!(self.popen()),\n+            token::Bracket => try!(word(&mut self.s, \"[\")),\n+            token::Brace => try!(self.bopen()),\n+        }\n+        try!(self.print_tts(&m.node.tts));\n+        match delim {\n+            token::Paren => self.pclose(),\n+            token::Bracket => word(&mut self.s, \"]\"),\n+            token::Brace => self.bclose(m.span),\n         }\n     }\n "}]}