{"sha": "d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "node_id": "C_kwDOAAsO6NoAKGQzMDU3YjVjYTc4Y2MwNTgyM2YyZGM3NWNiNzc0YmJmZmM1NDAzYTY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-04T22:47:04Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-08T23:02:50Z"}, "message": "Rename `FieldInfo` fields.\n\nUse `self_exprs` and `other_selflike_exprs` in a manner similar to the\nprevious commit.", "tree": {"sha": "088a43dcf64bf2a1c53403e852313d14a9cb9145", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/088a43dcf64bf2a1c53403e852313d14a9cb9145"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "html_url": "https://github.com/rust-lang/rust/commit/d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7", "html_url": "https://github.com/rust-lang/rust/commit/32c9ffb9ccb1dae15d473c8c4462eb80b4d35fc7"}], "stats": {"total": 104, "additions": 59, "deletions": 45}, "files": [{"sha": "a45b6e0407a93a2a0601e25badd565d7e3b2ad2d", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -161,7 +161,7 @@ fn cs_clone(\n     let all_fields;\n     let fn_path = cx.std_path(&[sym::clone, sym::Clone, sym::clone]);\n     let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo<'_>| {\n-        let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n+        let args = vec![cx.expr_addr_of(field.span, field.self_expr.clone())];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n "}, {"sha": "a60db068f27de6c3985e909bb1eac2829aa32981", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -74,17 +74,19 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_f, other_fs| {\n+        |cx, span, old, self_expr, other_selflike_exprs| {\n             // match new {\n             //     ::std::cmp::Ordering::Equal => old,\n             //     cmp => cmp\n             // }\n             let new = {\n-                let [other_f] = other_fs else {\n+                let [other_expr] = other_selflike_exprs else {\n                     cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n                 };\n-                let args =\n-                    vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                let args = vec![\n+                    cx.expr_addr_of(span, self_expr),\n+                    cx.expr_addr_of(span, other_expr.clone()),\n+                ];\n                 cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n@@ -94,13 +96,15 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         |cx, args| match args {\n-            Some((span, self_f, other_fs)) => {\n+            Some((span, self_expr, other_selflike_exprs)) => {\n                 let new = {\n-                    let [other_f] = other_fs else {\n+                    let [other_expr] = other_selflike_exprs else {\n                             cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n                         };\n-                    let args =\n-                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                    let args = vec![\n+                        cx.expr_addr_of(span, self_expr),\n+                        cx.expr_addr_of(span, other_expr.clone()),\n+                    ];\n                     cx.expr_call_global(span, cmp_path.clone(), args)\n                 };\n "}, {"sha": "a18d78b8476c533d3e25e42bad8544b695a56512", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -23,25 +23,28 @@ pub fn expand_deriving_partial_eq(\n         combiner: BinOpKind,\n         base: bool,\n     ) -> BlockOrExpr {\n-        let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n-            let [other_f] = other_fs else {\n+        let op = |cx: &mut ExtCtxt<'_>,\n+                  span: Span,\n+                  self_expr: P<Expr>,\n+                  other_selflike_exprs: &[P<Expr>]| {\n+            let [other_expr] = other_selflike_exprs else {\n                 cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n             };\n \n-            cx.expr_binary(span, op, self_f, other_f.clone())\n+            cx.expr_binary(span, op, self_expr, other_expr.clone())\n         };\n \n         let expr = cs_fold(\n             true, // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let eq = op(cx, span, self_f, other_fs);\n+            |cx, span, subexpr, self_expr, other_selflike_exprs| {\n+                let eq = op(cx, span, self_expr, other_selflike_exprs);\n                 cx.expr_binary(span, combiner, subexpr, eq)\n             },\n             |cx, args| {\n                 match args {\n-                    Some((span, self_f, other_fs)) => {\n+                    Some((span, self_expr, other_selflike_exprs)) => {\n                         // Special-case the base case to generate cleaner code.\n-                        op(cx, span, self_f, other_fs)\n+                        op(cx, span, self_expr, other_selflike_exprs)\n                     }\n                     None => cx.expr_bool(span, base),\n                 }"}, {"sha": "b809eaf8eecac7127884959957c119fa0fe672ac", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -72,19 +72,21 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_f, other_fs| {\n+        |cx, span, old, self_expr, other_selflike_exprs| {\n             // match new {\n             //     Some(::std::cmp::Ordering::Equal) => old,\n             //     cmp => cmp\n             // }\n \n             let new = {\n-                let [other_f] = other_fs else {\n+                let [other_expr] = other_selflike_exprs else {\n                     cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\");\n                 };\n \n-                let args =\n-                    vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                let args = vec![\n+                    cx.expr_addr_of(span, self_expr),\n+                    cx.expr_addr_of(span, other_expr.clone()),\n+                ];\n \n                 cx.expr_call_global(span, partial_cmp_path.clone(), args)\n             };\n@@ -95,13 +97,15 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n             cx.expr_match(span, new, vec![eq_arm, neq_arm])\n         },\n         |cx: &mut ExtCtxt<'_>, args: Option<(Span, P<Expr>, &[P<Expr>])>| match args {\n-            Some((span, self_f, other_fs)) => {\n+            Some((span, self_expr, other_selflike_exprs)) => {\n                 let new = {\n-                    let [other_f] = other_fs else {\n+                    let [other_expr] = other_selflike_exprs else {\n                             cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n                         };\n-                    let args =\n-                        vec![cx.expr_addr_of(span, self_f), cx.expr_addr_of(span, other_f.clone())];\n+                    let args = vec![\n+                        cx.expr_addr_of(span, self_expr),\n+                        cx.expr_addr_of(span, other_expr.clone()),\n+                    ];\n                     cx.expr_call_global(span, partial_cmp_path.clone(), args)\n                 };\n "}, {"sha": "b99198054def8a1fde8099e8b8330a32421d8f36", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -96,7 +96,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n                 args.push(name);\n             }\n             // Use double indirection to make sure this works for unsized types\n-            let field = cx.expr_addr_of(field.span, field.self_.clone());\n+            let field = cx.expr_addr_of(field.span, field.self_expr.clone());\n             let field = cx.expr_addr_of(field.span, field);\n             args.push(field);\n         }\n@@ -116,7 +116,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n             }\n \n             // Use double indirection to make sure this works for unsized types\n-            let value_ref = cx.expr_addr_of(field.span, field.self_.clone());\n+            let value_ref = cx.expr_addr_of(field.span, field.self_expr.clone());\n             value_exprs.push(cx.expr_addr_of(field.span, value_ref));\n         }\n "}, {"sha": "49dbe51f7626c720e102f5bd324f63d81e23e843", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -168,12 +168,12 @@ fn encodable_substructure(\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n-            for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n+            for (i, &FieldInfo { name, ref self_expr, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n                     Some(id) => id.name,\n                     None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n-                let self_ref = cx.expr_addr_of(span, self_.clone());\n+                let self_ref = cx.expr_addr_of(span, self_expr.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n                 let call = cx.expr_call_global(\n@@ -237,8 +237,8 @@ fn encodable_substructure(\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n-                for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n-                    let self_ref = cx.expr_addr_of(span, self_.clone());\n+                for (i, &FieldInfo { ref self_expr, span, .. }) in fields.iter().enumerate() {\n+                    let self_ref = cx.expr_addr_of(span, self_expr.clone());\n                     let enc =\n                         cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                     let lambda = cx.lambda1(span, enc, blkarg);"}, {"sha": "6ee7f72f9a4abba91c71e2aa5ec362b98b2d6838", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -258,10 +258,10 @@ pub struct FieldInfo<'a> {\n     pub name: Option<Ident>,\n     /// The expression corresponding to this field of `self`\n     /// (specifically, a reference to it).\n-    pub self_: P<Expr>,\n+    pub self_expr: P<Expr>,\n     /// The expressions corresponding to references to this field in\n-    /// the other `Self` arguments.\n-    pub other: Vec<P<Expr>>,\n+    /// the other selflike arguments.\n+    pub other_selflike_exprs: Vec<P<Expr>>,\n     /// The attributes on the field\n     pub attrs: &'a [ast::Attribute],\n }\n@@ -1080,13 +1080,13 @@ impl<'a> MethodDef<'a> {\n         let fields = if !raw_fields.is_empty() {\n             let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n-            let mut other_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n+            let mut nonself_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n             first_field\n-                .map(|(span, opt_id, field, attrs)| FieldInfo {\n+                .map(|(span, opt_id, expr, attrs)| FieldInfo {\n                     span: span.with_ctxt(trait_.span.ctxt()),\n                     name: opt_id,\n-                    self_: field,\n-                    other: other_fields\n+                    self_expr: expr,\n+                    other_selflike_exprs: nonself_fields\n                         .iter_mut()\n                         .map(|l| {\n                             let (.., ex, _) = l.next().unwrap();\n@@ -1289,7 +1289,7 @@ impl<'a> MethodDef<'a> {\n                         // and pull out getter for same field in each\n                         // of them (using `field_index` tracked above).\n                         // That is the heart of the transposition.\n-                        let others = selflike_pats_idents\n+                        let other_selflike_exprs = selflike_pats_idents\n                             .iter()\n                             .map(|fields| {\n                                 let (_, _opt_ident, ref other_getter_expr, _) = fields[field_index];\n@@ -1307,8 +1307,8 @@ impl<'a> MethodDef<'a> {\n                         FieldInfo {\n                             span,\n                             name: opt_ident,\n-                            self_: self_getter_expr,\n-                            other: others,\n+                            self_expr: self_getter_expr,\n+                            other_selflike_exprs,\n                             attrs,\n                         }\n                     })\n@@ -1712,24 +1712,25 @@ where\n             let (base, rest) = match (all_fields.is_empty(), use_foldl) {\n                 (false, true) => {\n                     let (first, rest) = all_fields.split_first().unwrap();\n-                    let args = (first.span, first.self_.clone(), &first.other[..]);\n+                    let args =\n+                        (first.span, first.self_expr.clone(), &first.other_selflike_exprs[..]);\n                     (b(cx, Some(args)), rest)\n                 }\n                 (false, false) => {\n                     let (last, rest) = all_fields.split_last().unwrap();\n-                    let args = (last.span, last.self_.clone(), &last.other[..]);\n+                    let args = (last.span, last.self_expr.clone(), &last.other_selflike_exprs[..]);\n                     (b(cx, Some(args)), rest)\n                 }\n                 (true, _) => (b(cx, None), &all_fields[..]),\n             };\n \n             if use_foldl {\n                 rest.iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n+                    f(cx, field.span, old, field.self_expr.clone(), &field.other_selflike_exprs)\n                 })\n             } else {\n                 rest.iter().rev().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_.clone(), &field.other)\n+                    f(cx, field.span, old, field.self_expr.clone(), &field.other_selflike_exprs)\n                 })\n             }\n         }"}, {"sha": "2213cd6d37d2d9c80177b3f1c8692be2876e805c", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3057b5ca78cc05823f2dc75cb774bbffc5403a6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=d3057b5ca78cc05823f2dc75cb774bbffc5403a6", "patch": "@@ -82,7 +82,9 @@ fn hash_substructure(\n     };\n \n     stmts.extend(\n-        fields.iter().map(|FieldInfo { ref self_, span, .. }| call_hash(*span, self_.clone())),\n+        fields\n+            .iter()\n+            .map(|FieldInfo { ref self_expr, span, .. }| call_hash(*span, self_expr.clone())),\n     );\n     BlockOrExpr::new_stmts(stmts)\n }"}]}