{"sha": "54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YzBlZGNmZTg1ZTc4MTFhODUwMWIzNGRjMmY4ZmJlOWI4YWNiNTE=", "commit": {"author": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2018-04-21T18:24:55Z"}, "committer": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2018-04-21T18:51:58Z"}, "message": "Add smaller check_unformatted to write.rs and fix precision,width,align false positive", "tree": {"sha": "ac2e950f8f6326079c6f79e31099124be1e80b4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac2e950f8f6326079c6f79e31099124be1e80b4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51", "html_url": "https://github.com/rust-lang/rust/commit/54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51/comments", "author": null, "committer": null, "parents": [{"sha": "8ccaa83e90f3520ae919c206eed92121f603763f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ccaa83e90f3520ae919c206eed92121f603763f", "html_url": "https://github.com/rust-lang/rust/commit/8ccaa83e90f3520ae919c206eed92121f603763f"}], "stats": {"total": 61, "additions": 54, "deletions": 7}, "files": [{"sha": "67c72bd98593943082ce91e848414edd16765c7a", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 54, "deletions": 7, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=54c0edcfe85e7811a8501b34dc2f8fbe9b8acb51", "patch": "@@ -7,7 +7,7 @@ use syntax::ptr;\n use syntax::symbol::InternedString;\n use syntax_pos::Span;\n use utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint, span_lint_and_sugg};\n-use utils::{opt_def_id, paths};\n+use utils::{opt_def_id, paths, last_path_segment};\n \n /// **What it does:** This lint warns when you use `println!(\"\")` to\n /// print a newline.\n@@ -266,7 +266,6 @@ fn check_print_variants<'a, 'tcx>(\n             };\n \n             span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n-\n             if_chain! {\n                 // ensure we're calling Arguments::new_v1\n                 if args.len() == 1;\n@@ -339,7 +338,9 @@ where\n     F: Fn(Span),\n {\n     if_chain! {\n-        if args.len() > 1;\n+        if args.len() >= 2;\n+\n+        // the match statement\n         if let ExprAddrOf(_, ref match_expr) = args[1].node;\n         if let ExprMatch(ref matchee, ref arms, _) = match_expr.node;\n         if let ExprTup(ref tup) = matchee.node;\n@@ -355,15 +356,31 @@ where\n                     if let ExprLit(_) = tup_val.node;\n \n                     // next, check the corresponding match arm body to ensure\n-                    // this is \"{}\", or DISPLAY_FMT_METHOD\n+                    // this is DISPLAY_FMT_METHOD\n                     if let ExprCall(_, ref body_args) = arm_body_exprs[idx].node;\n                     if body_args.len() == 2;\n                     if let ExprPath(ref body_qpath) = body_args[1].node;\n                     if let Some(fun_def_id) = opt_def_id(resolve_node(cx, body_qpath, body_args[1].hir_id));\n-                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD) ||\n-                       match_def_path(cx.tcx, fun_def_id, &paths::DEBUG_FMT_METHOD);\n+                    if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n                     then {\n-                        lint_fn(tup_val.span);\n+                        if args.len() == 2 {\n+                            lint_fn(tup_val.span);\n+                        } \n+\n+                        // ensure the format str has no options (e.g., width, precision, alignment, etc.)\n+                        // and is just \"{}\"\n+                        if_chain! {\n+                            if args.len() == 3;\n+                            if let ExprAddrOf(_, ref format_expr) = args[2].node;\n+                            if let ExprArray(ref format_exprs) = format_expr.node;\n+                            if format_exprs.len() >= 1;\n+                            if let ExprStruct(_, ref fields, _) = format_exprs[idx].node;\n+                            if let Some(format_field) = fields.iter().find(|f| f.name.node == \"format\");\n+                            if check_unformatted(&format_field.expr);\n+                            then {\n+                                lint_fn(tup_val.span);\n+                            }\n+                        }\n                     }\n                 }\n             }\n@@ -438,3 +455,33 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n     }\n     false\n }\n+\n+/// Checks if the expression matches\n+/// ```rust,ignore\n+/// &[_ {\n+///    format: _ {\n+///         width: _::Implied,\n+///         ...\n+///    },\n+///    ...,\n+/// }]\n+/// ```\n+pub fn check_unformatted(format_field: &Expr) -> bool {\n+    if_chain! {\n+        if let ExprStruct(_, ref fields, _) = format_field.node;\n+        if let Some(width_field) = fields.iter().find(|f| f.name.node == \"width\");\n+        if let ExprPath(ref qpath) = width_field.expr.node;\n+        if last_path_segment(qpath).name == \"Implied\";\n+        if let Some(align_field) = fields.iter().find(|f| f.name.node == \"align\");\n+        if let ExprPath(ref qpath) = align_field.expr.node;\n+        if last_path_segment(qpath).name == \"Unknown\";\n+        if let Some(precision_field) = fields.iter().find(|f| f.name.node == \"precision\");\n+        if let ExprPath(ref qpath_precision) = precision_field.expr.node;\n+        if last_path_segment(qpath_precision).name == \"Implied\";\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}]}