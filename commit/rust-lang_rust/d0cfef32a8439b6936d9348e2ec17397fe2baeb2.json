{"sha": "d0cfef32a8439b6936d9348e2ec17397fe2baeb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwY2ZlZjMyYTg0MzliNjkzNmQ5MzQ4ZTJlYzE3Mzk3ZmUyYmFlYjI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T15:54:44Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T15:54:44Z"}, "message": "Unify the various slice constructors", "tree": {"sha": "427cd0033b37715ba783221a0b72c899d91e76dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/427cd0033b37715ba783221a0b72c899d91e76dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0cfef32a8439b6936d9348e2ec17397fe2baeb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0cfef32a8439b6936d9348e2ec17397fe2baeb2", "html_url": "https://github.com/rust-lang/rust/commit/d0cfef32a8439b6936d9348e2ec17397fe2baeb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0cfef32a8439b6936d9348e2ec17397fe2baeb2/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b420a9dc476d23e54a0b3733cad173866a1fb1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b420a9dc476d23e54a0b3733cad173866a1fb1d", "html_url": "https://github.com/rust-lang/rust/commit/5b420a9dc476d23e54a0b3733cad173866a1fb1d"}], "stats": {"total": 181, "additions": 99, "deletions": 82}, "files": [{"sha": "2ccddabfb2f41ed81223701ff65ae2a3885d3e88", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 99, "deletions": 82, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d0cfef32a8439b6936d9348e2ec17397fe2baeb2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0cfef32a8439b6936d9348e2ec17397fe2baeb2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d0cfef32a8439b6936d9348e2ec17397fe2baeb2", "patch": "@@ -225,6 +225,7 @@\n ///       anything special (because we know none of the integers are actually wildcards: i.e., we\n ///       can't span wildcards using ranges).\n use self::Constructor::*;\n+use self::SliceKind::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n@@ -582,6 +583,23 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum SliceKind {\n+    /// Array patterns of length `n`.\n+    FixedLen(u64),\n+    /// Slice patterns. Captures any array constructor of `length >= i + j`.\n+    VarLen(u64, u64),\n+}\n+\n+impl SliceKind {\n+    fn arity(self) -> u64 {\n+        match self {\n+            FixedLen(length) => length,\n+            VarLen(prefix, suffix) => prefix + suffix,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n@@ -595,26 +613,20 @@ enum Constructor<'tcx> {\n     IntRange(IntRange<'tcx>),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n-    /// Array patterns of length `n`.\n-    FixedLenSlice(u64),\n-    /// Array patterns of length `len`, but for which we only care about the `prefix` first values\n-    /// and the `suffix` last values. This avoids unnecessarily going through values we know to be\n-    /// uninteresting, which can be a major problem for large arrays.\n-    LazyFixedLenSlice {\n-        len: u64, // The actual length of the array\n-        prefix: u64,\n-        suffix: u64,\n+    /// Array and slice patterns.\n+    Slice {\n+        // The length of the type of the pattern, if fixed.\n+        type_len: Option<u64>,\n+        kind: SliceKind,\n     },\n-    /// Slice patterns. Captures any array constructor of `length >= i + j`.\n-    VarLenSlice(u64, u64),\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n-            FixedLenSlice { .. } | LazyFixedLenSlice { .. } | VarLenSlice { .. } => true,\n+            Slice { .. } => true,\n             _ => false,\n         }\n     }\n@@ -643,71 +655,89 @@ impl<'tcx> Constructor<'tcx> {\n             Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n-            &FixedLenSlice(self_len) | &LazyFixedLenSlice { len: self_len, .. } => {\n+            &Slice { type_len: Some(self_len), .. } | &Slice { kind: FixedLen(self_len), .. } => {\n                 let overlaps = |c: &Constructor<'_>| match *c {\n-                    FixedLenSlice(len) | LazyFixedLenSlice { len, .. } => len == self_len,\n-                    VarLenSlice(prefix, suffix) => prefix + suffix <= self_len,\n+                    Slice { type_len: Some(len), .. } | Slice { kind: FixedLen(len), .. } => {\n+                        len == self_len\n+                    }\n+                    Slice { type_len: None, kind: VarLen(prefix, suffix) } => {\n+                        prefix + suffix <= self_len\n+                    }\n                     _ => false,\n                 };\n                 if other_ctors.iter().any(overlaps) { vec![] } else { vec![self.clone()] }\n             }\n-            VarLenSlice(..) => {\n+            Slice { type_len: None, kind: VarLen(..) } => {\n                 let mut remaining_ctors = vec![self.clone()];\n \n                 // For each used ctor, subtract from the current set of constructors.\n                 // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-                // Remember, `VarLenSlice(i, j)` covers the union of `FixedLenSlice` from\n+                // Remember, `VarLen(i, j)` covers the union of `FixedLen` from\n                 // `i + j` to infinity.\n                 for neg_ctor in other_ctors {\n                     remaining_ctors = remaining_ctors\n                         .into_iter()\n                         .flat_map(|pos_ctor| -> SmallVec<[Constructor<'tcx>; 1]> {\n                             // Compute `pos_ctor \\ neg_ctor`.\n                             match pos_ctor {\n-                                FixedLenSlice(pos_len) => match *neg_ctor {\n-                                    FixedLenSlice(neg_len)\n-                                    | LazyFixedLenSlice { len: neg_len, .. }\n+                                Slice { type_len: Some(pos_len), .. }\n+                                | Slice { kind: FixedLen(pos_len), .. } => match *neg_ctor {\n+                                    Slice { type_len: Some(neg_len), .. }\n+                                    | Slice { kind: FixedLen(neg_len), .. }\n                                         if neg_len == pos_len =>\n                                     {\n                                         smallvec![]\n                                     }\n-                                    VarLenSlice(neg_prefix, neg_suffix)\n-                                        if neg_prefix + neg_suffix <= pos_len =>\n-                                    {\n-                                        smallvec![]\n-                                    }\n+                                    Slice {\n+                                        type_len: None,\n+                                        kind: VarLen(neg_prefix, neg_suffix),\n+                                    } if neg_prefix + neg_suffix <= pos_len => smallvec![],\n                                     _ => smallvec![pos_ctor],\n                                 },\n-                                VarLenSlice(pos_prefix, pos_suffix) => {\n+                                Slice { type_len: None, kind: VarLen(pos_prefix, pos_suffix) } => {\n                                     let pos_len = pos_prefix + pos_suffix;\n                                     match *neg_ctor {\n-                                        FixedLenSlice(neg_len)\n-                                        | LazyFixedLenSlice { len: neg_len, .. }\n+                                        Slice { type_len: Some(neg_len), .. }\n+                                        | Slice { kind: FixedLen(neg_len), .. }\n                                             if neg_len >= pos_len =>\n                                         {\n                                             (pos_len..neg_len)\n-                                                .map(FixedLenSlice)\n+                                                .map(|l| Slice {\n+                                                    type_len: None,\n+                                                    kind: FixedLen(l),\n+                                                })\n                                                 // We know that `neg_len + 1 >= pos_len >=\n                                                 // pos_suffix`.\n-                                                .chain(Some(VarLenSlice(\n-                                                    neg_len + 1 - pos_suffix,\n-                                                    pos_suffix,\n-                                                )))\n+                                                .chain(Some(Slice {\n+                                                    type_len: None,\n+                                                    kind: VarLen(\n+                                                        neg_len + 1 - pos_suffix,\n+                                                        pos_suffix,\n+                                                    ),\n+                                                }))\n                                                 .collect()\n                                         }\n-                                        VarLenSlice(neg_prefix, neg_suffix) => {\n+                                        Slice {\n+                                            type_len: None,\n+                                            kind: VarLen(neg_prefix, neg_suffix),\n+                                        } => {\n                                             let neg_len = neg_prefix + neg_suffix;\n                                             if neg_len <= pos_len {\n                                                 smallvec![]\n                                             } else {\n-                                                (pos_len..neg_len).map(FixedLenSlice).collect()\n+                                                (pos_len..neg_len)\n+                                                    .map(|l| Slice {\n+                                                        type_len: None,\n+                                                        kind: FixedLen(l),\n+                                                    })\n+                                                    .collect()\n                                             }\n                                         }\n                                         _ => smallvec![pos_ctor],\n                                     }\n                                 }\n                                 _ => bug!(\n-                                    \"unexpected ctor while subtracting from VarLenSlice: {:?}\",\n+                                    \"unexpected ctor while subtracting from VarLen: {:?}\",\n                                     pos_ctor\n                                 ),\n                             }\n@@ -815,7 +845,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => vec![],\n             },\n-            FixedLenSlice(_) | LazyFixedLenSlice { .. } | VarLenSlice(..) => match ty.kind {\n+            Slice { .. } => match ty.kind {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = self.arity(cx, ty);\n                     (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n@@ -845,10 +875,7 @@ impl<'tcx> Constructor<'tcx> {\n                 }\n                 _ => 0,\n             },\n-            FixedLenSlice(length) => *length,\n-            VarLenSlice(prefix, suffix) | LazyFixedLenSlice { prefix, suffix, .. } => {\n-                prefix + suffix\n-            }\n+            Slice { kind, .. } => kind.arity(),\n             ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => 0,\n         }\n     }\n@@ -903,13 +930,15 @@ impl<'tcx> Constructor<'tcx> {\n                 ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n                 _ => PatKind::Wild,\n             },\n-            FixedLenSlice(_) => {\n+            Slice { kind: FixedLen(_), .. } => {\n                 PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n             }\n-            LazyFixedLenSlice { len, prefix, suffix } if prefix + suffix == *len => {\n+            Slice { type_len: Some(len), kind: VarLen(prefix, suffix) }\n+                if prefix + suffix == *len =>\n+            {\n                 PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n             }\n-            VarLenSlice(prefix, _) | LazyFixedLenSlice { prefix, .. } => {\n+            Slice { kind: VarLen(prefix, _), .. } => {\n                 let prefix = subpatterns.by_ref().take(*prefix as usize).collect();\n                 let suffix = subpatterns.collect();\n                 let wild = Pat::wildcard_from_ty(ty);\n@@ -1130,15 +1159,15 @@ fn all_constructors<'a, 'tcx>(\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n                 vec![]\n             } else {\n-                vec![LazyFixedLenSlice { len, prefix: 0, suffix: 0 }]\n+                vec![Slice { type_len: Some(len), kind: VarLen(0, 0) }]\n             }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n         ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n-                vec![FixedLenSlice(0)]\n+                vec![Slice { type_len: None, kind: FixedLen(0) }]\n             } else {\n-                vec![VarLenSlice(0, 0)]\n+                vec![Slice { type_len: None, kind: VarLen(0, 0) }]\n             }\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n@@ -1719,27 +1748,18 @@ fn pat_constructor<'tcx>(\n                 Some(FloatRange(lo, hi, end))\n             }\n         }\n-        PatKind::Array { ref prefix, ref slice, ref suffix } => {\n-            let len = match pat.ty.kind {\n-                ty::Array(_, length) => length.eval_usize(tcx, param_env),\n-                _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pat.ty),\n+        PatKind::Array { ref prefix, ref slice, ref suffix }\n+        | PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            let type_len = match pat.ty.kind {\n+                ty::Array(_, length) => Some(length.eval_usize(tcx, param_env)),\n+                ty::Slice(_) => None,\n+                _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n             };\n             let prefix = prefix.len() as u64;\n             let suffix = suffix.len() as u64;\n-            if slice.is_some() {\n-                Some(LazyFixedLenSlice { len, prefix, suffix })\n-            } else {\n-                Some(FixedLenSlice(len))\n-            }\n-        }\n-        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            let prefix = prefix.len() as u64;\n-            let suffix = suffix.len() as u64;\n-            if slice.is_some() {\n-                Some(VarLenSlice(prefix, suffix))\n-            } else {\n-                Some(FixedLenSlice(prefix + suffix))\n-            }\n+            let kind =\n+                if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n+            Some(Slice { type_len, kind })\n         }\n         PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n@@ -1955,8 +1975,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                         .map(IntRange),\n                 );\n             }\n-            VarLenSlice(self_prefix, self_suffix)\n-            | LazyFixedLenSlice { prefix: self_prefix, suffix: self_suffix, .. } => {\n+            Slice { kind: VarLen(self_prefix, self_suffix), type_len } => {\n                 // The exhaustiveness-checking paper does not include any details on\n                 // checking variable-length slice patterns. However, they are matched\n                 // by an infinite collection of fixed-length array patterns.\n@@ -2065,28 +2084,26 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     max_prefix_len = max_fixed_len + 1 - max_suffix_len;\n                 }\n \n-                match ctor {\n-                    LazyFixedLenSlice { len, .. } => {\n-                        if max_prefix_len + max_suffix_len < len {\n-                            split_ctors.push(LazyFixedLenSlice {\n-                                len,\n-                                prefix: max_prefix_len,\n-                                suffix: max_suffix_len,\n-                            });\n+                match type_len {\n+                    Some(len) => {\n+                        let kind = if max_prefix_len + max_suffix_len < len {\n+                            VarLen(max_prefix_len, max_suffix_len)\n                         } else {\n-                            split_ctors.push(FixedLenSlice(len));\n-                        }\n+                            FixedLen(len)\n+                        };\n+                        split_ctors.push(Slice { type_len, kind });\n                     }\n-                    _ => {\n+                    None => {\n                         // `ctor` originally covered the range `(self_prefix + self_suffix..infinity)`. We\n                         // now split it into two: lengths smaller than `max_prefix_len + max_suffix_len`\n                         // are treated independently as fixed-lengths slices, and lengths above are\n-                        // captured by a final VarLenSlice constructor.\n+                        // captured by a final VarLen constructor.\n                         split_ctors.extend(\n                             (self_prefix + self_suffix..max_prefix_len + max_suffix_len)\n-                                .map(FixedLenSlice),\n+                                .map(|len| Slice { type_len, kind: FixedLen(len) }),\n                         );\n-                        split_ctors.push(VarLenSlice(max_prefix_len, max_suffix_len));\n+                        split_ctors\n+                            .push(Slice { type_len, kind: VarLen(max_prefix_len, max_suffix_len) });\n                     }\n                 }\n             }\n@@ -2307,7 +2324,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n-            FixedLenSlice(..) | LazyFixedLenSlice { .. } | VarLenSlice(..) => {\n+            Slice { .. } => {\n                 let pat_len = prefix.len() + suffix.len();\n                 if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n                     if slice_count == 0 || slice.is_some() {"}]}