{"sha": "224dff4e15f1195c1cdbd85d9080e13b14a151e2", "node_id": "C_kwDOAAsO6NoAKDIyNGRmZjRlMTVmMTE5NWMxY2RiZDg1ZDkwODBlMTNiMTRhMTUxZTI", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-10-31T04:39:16Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-10-31T06:06:21Z"}, "message": "add acquire when init once is already complete", "tree": {"sha": "a16416772667d681bc1865b687295ebc0cdaf2cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a16416772667d681bc1865b687295ebc0cdaf2cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/224dff4e15f1195c1cdbd85d9080e13b14a151e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/224dff4e15f1195c1cdbd85d9080e13b14a151e2", "html_url": "https://github.com/rust-lang/rust/commit/224dff4e15f1195c1cdbd85d9080e13b14a151e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/224dff4e15f1195c1cdbd85d9080e13b14a151e2/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc", "html_url": "https://github.com/rust-lang/rust/commit/c162fd36d250f1a76e00ffa55b9d827d0db7e0bc"}], "stats": {"total": 79, "additions": 59, "deletions": 20}, "files": [{"sha": "b1443662e2b7fdc7be6b8f336e224a336994c9da", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/224dff4e15f1195c1cdbd85d9080e13b14a151e2/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/224dff4e15f1195c1cdbd85d9080e13b14a151e2/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=224dff4e15f1195c1cdbd85d9080e13b14a151e2", "patch": "@@ -141,18 +141,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Wake up everyone.\n         // need to take the queue to avoid having `this` be borrowed multiple times\n         for waiter in std::mem::take(&mut init_once.waiters) {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n             this.unblock_thread(waiter.thread);\n \n             // Call callback, with the woken-up thread as `current`.\n             this.set_active_thread(waiter.thread);\n+            this.init_once_acquire(id);\n             waiter.callback.call(this)?;\n             this.set_active_thread(current_thread);\n         }\n@@ -172,26 +165,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         );\n \n         // Each complete happens-before the end of the wait\n-        // FIXME: should this really induce synchronization? If we think of it as a lock, then yes,\n-        // but the docs don't talk about such details.\n         if let Some(data_race) = &this.machine.data_race {\n             data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n         }\n \n         // Wake up one waiting thread, so they can go ahead and try to init this.\n         if let Some(waiter) = init_once.waiters.pop_front() {\n-            // End of the wait happens-before woken-up thread.\n-            if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_acquire(\n-                    &this.machine.threads.sync.init_onces[id].data_race,\n-                    waiter.thread,\n-                );\n-            }\n-\n             this.unblock_thread(waiter.thread);\n \n             // Call callback, with the woken-up thread as `current`.\n             this.set_active_thread(waiter.thread);\n+            this.init_once_acquire(id);\n             waiter.callback.call(this)?;\n             this.set_active_thread(current_thread);\n         } else {\n@@ -201,4 +185,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    /// Synchronize with the previous completion or failure of an InitOnce.\n+    /// This is required to prevent data races.\n+    #[inline]\n+    fn init_once_acquire(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_acquire(\n+                &this.machine.threads.sync.init_onces[id].data_race,\n+                current_thread,\n+            );\n+        }\n+    }\n }"}, {"sha": "f8980e188b45b303efd1b447930b9ba8e2c90440", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/224dff4e15f1195c1cdbd85d9080e13b14a151e2/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/224dff4e15f1195c1cdbd85d9080e13b14a151e2/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=224dff4e15f1195c1cdbd85d9080e13b14a151e2", "patch": "@@ -177,8 +177,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     Box::new(Callback { init_once_id: id, pending_place }),\n                 )\n             }\n-            InitOnceStatus::Complete =>\n-                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n+            InitOnceStatus::Complete => {\n+                this.init_once_acquire(id);\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?;\n+            }\n         }\n \n         // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock)."}, {"sha": "6e5129acaf853c47c0e2fadc6f27506b172a8895", "filename": "src/tools/miri/tests/pass/concurrency/windows_init_once.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/224dff4e15f1195c1cdbd85d9080e13b14a151e2/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/224dff4e15f1195c1cdbd85d9080e13b14a151e2/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_init_once.rs?ref=224dff4e15f1195c1cdbd85d9080e13b14a151e2", "patch": "@@ -131,8 +131,46 @@ fn retry_on_fail() {\n     waiter2.join().unwrap();\n }\n \n+fn no_data_race_after_complete() {\n+    let mut init_once = null_mut();\n+    let mut pending = 0;\n+\n+    unsafe {\n+        assert_eq!(InitOnceBeginInitialize(&mut init_once, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, TRUE);\n+    }\n+\n+    let init_once_ptr = SendPtr(&mut init_once);\n+\n+    let mut place = 0;\n+    let place_ptr = SendPtr(&mut place);\n+\n+    let reader = thread::spawn(move || unsafe {\n+        let mut pending = 0;\n+\n+        assert_eq!(InitOnceBeginInitialize(init_once_ptr.0, 0, &mut pending, null_mut()), TRUE);\n+        assert_eq!(pending, FALSE);\n+        // this should not data race\n+        place_ptr.0.read()\n+    });\n+\n+    unsafe {\n+        // this should not data race\n+        place_ptr.0.write(1);\n+    }\n+\n+    unsafe {\n+        assert_eq!(InitOnceComplete(init_once_ptr.0, 0, null_mut()), TRUE);\n+    }\n+    //println!(\"complete\");\n+\n+    // run reader\n+    assert_eq!(reader.join().unwrap(), 1);\n+}\n+\n fn main() {\n     single_thread();\n     block_until_complete();\n     retry_on_fail();\n+    no_data_race_after_complete();\n }"}]}