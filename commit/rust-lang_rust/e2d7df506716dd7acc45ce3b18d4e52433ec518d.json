{"sha": "e2d7df506716dd7acc45ce3b18d4e52433ec518d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZDdkZjUwNjcxNmRkN2FjYzQ1Y2UzYjE4ZDRlNTI0MzNlYzUxOGQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-24T16:12:56Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-29T13:09:31Z"}, "message": "Privatize a bunch of methods", "tree": {"sha": "c99973a092203925cda2abccc8019957fe3c4a94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c99973a092203925cda2abccc8019957fe3c4a94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2d7df506716dd7acc45ce3b18d4e52433ec518d", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d7df506716dd7acc45ce3b18d4e52433ec518d", "html_url": "https://github.com/rust-lang/rust/commit/e2d7df506716dd7acc45ce3b18d4e52433ec518d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2d7df506716dd7acc45ce3b18d4e52433ec518d/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ec39423dd0d02f81866b675dd9299972e1b9af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec39423dd0d02f81866b675dd9299972e1b9af5", "html_url": "https://github.com/rust-lang/rust/commit/8ec39423dd0d02f81866b675dd9299972e1b9af5"}], "stats": {"total": 192, "additions": 96, "deletions": 96}, "files": [{"sha": "6295711e28230a03cdc08cc9d4c456daa3986ba6", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e2d7df506716dd7acc45ce3b18d4e52433ec518d/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d7df506716dd7acc45ce3b18d4e52433ec518d/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=e2d7df506716dd7acc45ce3b18d4e52433ec518d", "patch": "@@ -172,7 +172,7 @@ pub enum Token {\n }\n \n impl Token {\n-    pub fn is_eof(&self) -> bool {\n+    crate fn is_eof(&self) -> bool {\n         match *self {\n             Token::Eof => true,\n             _ => false,\n@@ -223,13 +223,13 @@ fn buf_str(buf: &[BufEntry], left: usize, right: usize, lim: usize) -> String {\n }\n \n #[derive(Copy, Clone)]\n-pub enum PrintStackBreak {\n+crate enum PrintStackBreak {\n     Fits,\n     Broken(Breaks),\n }\n \n #[derive(Copy, Clone)]\n-pub struct PrintStackElem {\n+crate struct PrintStackElem {\n     offset: isize,\n     pbreak: PrintStackBreak\n }\n@@ -386,7 +386,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    pub fn check_stream(&mut self) -> io::Result<()> {\n+    crate fn check_stream(&mut self) -> io::Result<()> {\n         debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -405,24 +405,24 @@ impl<'a> Printer<'a> {\n         Ok(())\n     }\n \n-    pub fn scan_push(&mut self, x: usize) {\n+    crate fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n         self.scan_stack.push_front(x);\n     }\n \n-    pub fn scan_pop(&mut self) -> usize {\n+    crate fn scan_pop(&mut self) -> usize {\n         self.scan_stack.pop_front().unwrap()\n     }\n \n-    pub fn scan_top(&mut self) -> usize {\n+    crate fn scan_top(&mut self) -> usize {\n         *self.scan_stack.front().unwrap()\n     }\n \n-    pub fn scan_pop_bottom(&mut self) -> usize {\n+    crate fn scan_pop_bottom(&mut self) -> usize {\n         self.scan_stack.pop_back().unwrap()\n     }\n \n-    pub fn advance_right(&mut self) {\n+    crate fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_max_len;\n         // Extend the buf if necessary.\n@@ -432,7 +432,7 @@ impl<'a> Printer<'a> {\n         assert_ne!(self.right, self.left);\n     }\n \n-    pub fn advance_left(&mut self) -> io::Result<()> {\n+    crate fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.buf[self.left].size);\n \n@@ -467,7 +467,7 @@ impl<'a> Printer<'a> {\n         Ok(())\n     }\n \n-    pub fn check_stack(&mut self, k: isize) {\n+    crate fn check_stack(&mut self, k: isize) {\n         if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n             match self.buf[x].token {\n@@ -495,20 +495,20 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    pub fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n+    crate fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n         debug!(\"NEWLINE {}\", amount);\n         let ret = writeln!(self.out);\n         self.pending_indentation = 0;\n         self.indent(amount);\n         ret\n     }\n \n-    pub fn indent(&mut self, amount: isize) {\n+    crate fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n \n-    pub fn get_top(&mut self) -> PrintStackElem {\n+    crate fn get_top(&mut self) -> PrintStackElem {\n         match self.print_stack.last() {\n             Some(el) => *el,\n             None => PrintStackElem {\n@@ -518,7 +518,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    pub fn print_begin(&mut self, b: BeginToken, l: isize) -> io::Result<()> {\n+    crate fn print_begin(&mut self, b: BeginToken, l: isize) -> io::Result<()> {\n         if l > self.space {\n             let col = self.margin - self.space + b.offset;\n             debug!(\"print Begin -> push broken block at col {}\", col);\n@@ -536,15 +536,15 @@ impl<'a> Printer<'a> {\n         Ok(())\n     }\n \n-    pub fn print_end(&mut self) -> io::Result<()> {\n+    crate fn print_end(&mut self) -> io::Result<()> {\n         debug!(\"print End -> pop End\");\n         let print_stack = &mut self.print_stack;\n         assert!(!print_stack.is_empty());\n         print_stack.pop().unwrap();\n         Ok(())\n     }\n \n-    pub fn print_break(&mut self, b: BreakToken, l: isize) -> io::Result<()> {\n+    crate fn print_break(&mut self, b: BreakToken, l: isize) -> io::Result<()> {\n         let top = self.get_top();\n         match top.pbreak {\n             PrintStackBreak::Fits => {\n@@ -578,7 +578,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    pub fn print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+    crate fn print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n         debug!(\"print String({})\", s);\n         // assert!(len <= space);\n         self.space -= len;\n@@ -603,7 +603,7 @@ impl<'a> Printer<'a> {\n         write!(self.out, \"{}\", s)\n     }\n \n-    pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n+    crate fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n         debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.buf,\n@@ -625,15 +625,15 @@ impl<'a> Printer<'a> {\n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n-    pub fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n+    crate fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n         self.pretty_print_begin(BeginToken {\n             offset: indent as isize,\n             breaks: b\n         })\n     }\n \n     /// Inconsistent breaking box\n-    pub fn ibox(&mut self, indent: usize) -> io::Result<()> {\n+    crate fn ibox(&mut self, indent: usize) -> io::Result<()> {\n         self.rbox(indent, Breaks::Inconsistent)\n     }\n \n@@ -649,7 +649,7 @@ impl<'a> Printer<'a> {\n         })\n     }\n \n-    pub fn end(&mut self) -> io::Result<()> {\n+    crate fn end(&mut self) -> io::Result<()> {\n         self.pretty_print_end()\n     }\n \n@@ -667,7 +667,7 @@ impl<'a> Printer<'a> {\n         self.break_offset(n, 0)\n     }\n \n-    pub fn zerobreak(&mut self) -> io::Result<()> {\n+    crate fn zerobreak(&mut self) -> io::Result<()> {\n         self.spaces(0)\n     }\n \n@@ -683,7 +683,7 @@ impl<'a> Printer<'a> {\n         Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n     }\n \n-    pub fn hardbreak_tok() -> Token {\n+    crate fn hardbreak_tok() -> Token {\n         Self::hardbreak_tok_offset(0)\n     }\n }"}, {"sha": "0937d24cb29dfe64a0a59d38f047406728bc318d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e2d7df506716dd7acc45ce3b18d4e52433ec518d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d7df506716dd7acc45ce3b18d4e52433ec518d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e2d7df506716dd7acc45ce3b18d4e52433ec518d", "patch": "@@ -66,9 +66,9 @@ fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a>\n     }\n }\n \n-pub const INDENT_UNIT: usize = 4;\n+crate const INDENT_UNIT: usize = 4;\n \n-pub const DEFAULT_COLUMNS: usize = 78;\n+crate const DEFAULT_COLUMNS: usize = 78;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n@@ -254,7 +254,7 @@ pub fn token_to_string(token: &Token) -> String {\n     token_kind_to_string(&token.kind)\n }\n \n-pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n+crate fn nonterminal_to_string(nt: &Nonterminal) -> String {\n     match *nt {\n         token::NtExpr(ref e)        => expr_to_string(e),\n         token::NtMeta(ref e)        => meta_item_to_string(e),\n@@ -805,12 +805,12 @@ impl<'a> State<'a> {\n         self.s.cbox(u)\n     }\n \n-    pub fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n+    crate fn word_nbsp<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         self.s.word(w)?;\n         self.nbsp()\n     }\n \n-    pub fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n+    crate fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) -> io::Result<()> {\n         let w = w.into();\n         // outer-box is consistent\n         self.cbox(INDENT_UNIT)?;\n@@ -823,16 +823,16 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn bopen(&mut self) -> io::Result<()> {\n+    crate fn bopen(&mut self) -> io::Result<()> {\n         self.s.word(\"{\")?;\n         self.end() // close the head-box\n     }\n \n-    pub fn bclose_(&mut self, span: syntax_pos::Span,\n+    crate fn bclose_(&mut self, span: syntax_pos::Span,\n                    indented: usize) -> io::Result<()> {\n         self.bclose_maybe_open(span, indented, true)\n     }\n-    pub fn bclose_maybe_open(&mut self, span: syntax_pos::Span,\n+    crate fn bclose_maybe_open(&mut self, span: syntax_pos::Span,\n                              indented: usize, close_box: bool) -> io::Result<()> {\n         self.maybe_print_comment(span.hi())?;\n         self.break_offset_if_not_bol(1, -(indented as isize))?;\n@@ -842,18 +842,18 @@ impl<'a> State<'a> {\n         }\n         Ok(())\n     }\n-    pub fn bclose(&mut self, span: syntax_pos::Span) -> io::Result<()> {\n+    crate fn bclose(&mut self, span: syntax_pos::Span) -> io::Result<()> {\n         self.bclose_(span, INDENT_UNIT)\n     }\n \n-    pub fn in_cbox(&self) -> bool {\n+    crate fn in_cbox(&self) -> bool {\n         match self.boxes.last() {\n             Some(&last_box) => last_box == pp::Breaks::Consistent,\n             None => false\n         }\n     }\n \n-    pub fn break_offset_if_not_bol(&mut self, n: usize,\n+    crate fn break_offset_if_not_bol(&mut self, n: usize,\n                                    off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n             self.s.break_offset(n, off)\n@@ -880,7 +880,7 @@ impl<'a> State<'a> {\n \n \n \n-    pub fn commasep_cmnt<T, F, G>(&mut self,\n+    crate fn commasep_cmnt<T, F, G>(&mut self,\n                                   b: Breaks,\n                                   elts: &[T],\n                                   mut op: F,\n@@ -905,12 +905,12 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn commasep_exprs(&mut self, b: Breaks,\n+    crate fn commasep_exprs(&mut self, b: Breaks,\n                           exprs: &[P<ast::Expr>]) -> io::Result<()> {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n-    pub fn print_mod(&mut self, _mod: &ast::Mod,\n+    crate fn print_mod(&mut self, _mod: &ast::Mod,\n                      attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_inner_attributes(attrs)?;\n         for item in &_mod.items {\n@@ -919,7 +919,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod,\n+    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod,\n                              attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_inner_attributes(attrs)?;\n         for item in &nmod.items {\n@@ -928,23 +928,23 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_opt_lifetime(&mut self, lifetime: &Option<ast::Lifetime>) -> io::Result<()> {\n+    crate fn print_opt_lifetime(&mut self, lifetime: &Option<ast::Lifetime>) -> io::Result<()> {\n         if let Some(lt) = *lifetime {\n             self.print_lifetime(lt)?;\n             self.nbsp()?;\n         }\n         Ok(())\n     }\n \n-    pub fn print_generic_arg(&mut self, generic_arg: &GenericArg) -> io::Result<()> {\n+    crate fn print_generic_arg(&mut self, generic_arg: &GenericArg) -> io::Result<()> {\n         match generic_arg {\n             GenericArg::Lifetime(lt) => self.print_lifetime(*lt),\n             GenericArg::Type(ty) => self.print_type(ty),\n             GenericArg::Const(ct) => self.print_expr(&ct.value),\n         }\n     }\n \n-    pub fn print_type(&mut self, ty: &ast::Ty) -> io::Result<()> {\n+    crate fn print_type(&mut self, ty: &ast::Ty) -> io::Result<()> {\n         self.maybe_print_comment(ty.span.lo())?;\n         self.ibox(0)?;\n         match ty.node {\n@@ -1036,7 +1036,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_foreign_item(&mut self,\n+    crate fn print_foreign_item(&mut self,\n                               item: &ast::ForeignItem) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(item.span.lo())?;\n@@ -1119,7 +1119,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Pretty-print an item\n-    pub fn print_item(&mut self, item: &ast::Item) -> io::Result<()> {\n+    crate fn print_item(&mut self, item: &ast::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(item.span.lo())?;\n         self.print_outer_attributes(&item.attrs)?;\n@@ -1398,7 +1398,7 @@ impl<'a> State<'a> {\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n-    pub fn print_enum_def(&mut self, enum_definition: &ast::EnumDef,\n+    crate fn print_enum_def(&mut self, enum_definition: &ast::EnumDef,\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: syntax_pos::Span,\n                           visibility: &ast::Visibility) -> io::Result<()> {\n@@ -1410,7 +1410,7 @@ impl<'a> State<'a> {\n         self.print_variants(&enum_definition.variants, span)\n     }\n \n-    pub fn print_variants(&mut self,\n+    crate fn print_variants(&mut self,\n                           variants: &[ast::Variant],\n                           span: syntax_pos::Span) -> io::Result<()> {\n         self.bopen()?;\n@@ -1427,7 +1427,7 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: &ast::Visibility) -> io::Result<()> {\n+    crate fn print_visibility(&mut self, vis: &ast::Visibility) -> io::Result<()> {\n         match vis.node {\n             ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n             ast::VisibilityKind::Crate(sugar) => match sugar {\n@@ -1446,14 +1446,14 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_defaultness(&mut self, defaultness: ast::Defaultness) -> io::Result<()> {\n+    crate fn print_defaultness(&mut self, defaultness: ast::Defaultness) -> io::Result<()> {\n         if let ast::Defaultness::Default = defaultness {\n             self.word_nbsp(\"default\")?;\n         }\n         Ok(())\n     }\n \n-    pub fn print_struct(&mut self,\n+    crate fn print_struct(&mut self,\n                         struct_def: &ast::VariantData,\n                         generics: &ast::Generics,\n                         ident: ast::Ident,\n@@ -1505,7 +1505,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n+    crate fn print_variant(&mut self, v: &ast::Variant) -> io::Result<()> {\n         self.head(\"\")?;\n         let generics = ast::Generics::default();\n         self.print_struct(&v.node.data, &generics, v.node.ident, v.span, false)?;\n@@ -1519,7 +1519,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_method_sig(&mut self,\n+    crate fn print_method_sig(&mut self,\n                             ident: ast::Ident,\n                             generics: &ast::Generics,\n                             m: &ast::MethodSig,\n@@ -1532,7 +1532,7 @@ impl<'a> State<'a> {\n                       vis)\n     }\n \n-    pub fn print_trait_item(&mut self, ti: &ast::TraitItem)\n+    crate fn print_trait_item(&mut self, ti: &ast::TraitItem)\n                             -> io::Result<()> {\n         self.ann.pre(self, AnnNode::SubItem(ti.id))?;\n         self.hardbreak_if_not_bol()?;\n@@ -1579,7 +1579,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ti.id))\n     }\n \n-    pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n+    crate fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, AnnNode::SubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n         self.maybe_print_comment(ii.span.lo())?;\n@@ -1613,7 +1613,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ii.id))\n     }\n \n-    pub fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n+    crate fn print_stmt(&mut self, st: &ast::Stmt) -> io::Result<()> {\n         self.maybe_print_comment(st.span.lo())?;\n         match st.node {\n             ast::StmtKind::Local(ref loc) => {\n@@ -1659,32 +1659,32 @@ impl<'a> State<'a> {\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n-    pub fn print_block(&mut self, blk: &ast::Block) -> io::Result<()> {\n+    crate fn print_block(&mut self, blk: &ast::Block) -> io::Result<()> {\n         self.print_block_with_attrs(blk, &[])\n     }\n \n-    pub fn print_block_unclosed(&mut self, blk: &ast::Block) -> io::Result<()> {\n+    crate fn print_block_unclosed(&mut self, blk: &ast::Block) -> io::Result<()> {\n         self.print_block_unclosed_indent(blk, INDENT_UNIT)\n     }\n \n-    pub fn print_block_unclosed_with_attrs(&mut self, blk: &ast::Block,\n+    crate fn print_block_unclosed_with_attrs(&mut self, blk: &ast::Block,\n                                             attrs: &[ast::Attribute])\n                                            -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, false)\n     }\n \n-    pub fn print_block_unclosed_indent(&mut self, blk: &ast::Block,\n+    crate fn print_block_unclosed_indent(&mut self, blk: &ast::Block,\n                                        indented: usize) -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, indented, &[], false)\n     }\n \n-    pub fn print_block_with_attrs(&mut self,\n+    crate fn print_block_with_attrs(&mut self,\n                                   blk: &ast::Block,\n                                   attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, true)\n     }\n \n-    pub fn print_block_maybe_unclosed(&mut self,\n+    crate fn print_block_maybe_unclosed(&mut self,\n                                       blk: &ast::Block,\n                                       indented: usize,\n                                       attrs: &[ast::Attribute],\n@@ -1716,7 +1716,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Print a `let pats = scrutinee` expression.\n-    pub fn print_let(&mut self, pats: &[P<ast::Pat>], scrutinee: &ast::Expr) -> io::Result<()> {\n+    crate fn print_let(&mut self, pats: &[P<ast::Pat>], scrutinee: &ast::Expr) -> io::Result<()> {\n         self.s.word(\"let \")?;\n \n         self.print_pats(pats)?;\n@@ -1761,7 +1761,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n+    crate fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n                     elseopt: Option<&ast::Expr>) -> io::Result<()> {\n         self.head(\"if\")?;\n \n@@ -1772,7 +1772,7 @@ impl<'a> State<'a> {\n         self.print_else(elseopt)\n     }\n \n-    pub fn print_mac(&mut self, m: &ast::Mac) -> io::Result<()> {\n+    crate fn print_mac(&mut self, m: &ast::Mac) -> io::Result<()> {\n         self.print_path(&m.node.path, false, 0)?;\n         self.s.word(\"!\")?;\n         match m.node.delim {\n@@ -1798,13 +1798,13 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n+    crate fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n         self.print_expr_cond_paren(expr, expr.precedence().order() < prec)\n     }\n \n     /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n     /// `if cond { ... }`.\n-    pub fn print_expr_as_cond(&mut self, expr: &ast::Expr) -> io::Result<()> {\n+    crate fn print_expr_as_cond(&mut self, expr: &ast::Expr) -> io::Result<()> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr))\n     }\n \n@@ -1989,7 +1989,7 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n-    pub fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> {\n+    crate fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> {\n         self.print_expr_outer_attr_style(expr, true)\n     }\n \n@@ -2330,7 +2330,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_local_decl(&mut self, loc: &ast::Local) -> io::Result<()> {\n+    crate fn print_local_decl(&mut self, loc: &ast::Local) -> io::Result<()> {\n         self.print_pat(&loc.pat)?;\n         if let Some(ref ty) = loc.ty {\n             self.word_space(\":\")?;\n@@ -2339,7 +2339,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n+    crate fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n         if ident.is_raw_guess() {\n             self.s.word(format!(\"r#{}\", ident))?;\n         } else {\n@@ -2348,16 +2348,16 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Ident(&ident))\n     }\n \n-    pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n+    crate fn print_usize(&mut self, i: usize) -> io::Result<()> {\n         self.s.word(i.to_string())\n     }\n \n-    pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n+    crate fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n         self.s.word(name.as_str().to_string())?;\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n \n-    pub fn print_for_decl(&mut self, loc: &ast::Local,\n+    crate fn print_for_decl(&mut self, loc: &ast::Local,\n                           coll: &ast::Expr) -> io::Result<()> {\n         self.print_local_decl(loc)?;\n         self.s.space()?;\n@@ -2484,7 +2484,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_pat(&mut self, pat: &ast::Pat) -> io::Result<()> {\n+    crate fn print_pat(&mut self, pat: &ast::Pat) -> io::Result<()> {\n         self.maybe_print_comment(pat.span.lo())?;\n         self.ann.pre(self, AnnNode::Pat(pat))?;\n         /* Pat isn't normalized, but the beauty of it\n@@ -2705,7 +2705,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_fn(&mut self,\n+    crate fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n                     header: ast::FnHeader,\n                     name: Option<ast::Ident>,\n@@ -2722,7 +2722,7 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl)\n+    crate fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl)\n         -> io::Result<()> {\n         self.popen()?;\n         self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n@@ -2731,7 +2731,7 @@ impl<'a> State<'a> {\n         self.print_fn_output(decl)\n     }\n \n-    pub fn print_fn_block_args(\n+    crate fn print_fn_block_args(\n             &mut self,\n             decl: &ast::FnDecl)\n             -> io::Result<()> {\n@@ -2754,31 +2754,31 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_movability(&mut self, movability: ast::Movability)\n+    crate fn print_movability(&mut self, movability: ast::Movability)\n                                 -> io::Result<()> {\n         match movability {\n             ast::Movability::Static => self.word_space(\"static\"),\n             ast::Movability::Movable => Ok(()),\n         }\n     }\n \n-    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n+    crate fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n                                 -> io::Result<()> {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\")?;\n         }\n         Ok(())\n     }\n \n-    pub fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy)\n+    crate fn print_capture_clause(&mut self, capture_clause: ast::CaptureBy)\n                                 -> io::Result<()> {\n         match capture_clause {\n             ast::CaptureBy::Value => self.word_space(\"move\"),\n             ast::CaptureBy::Ref => Ok(()),\n         }\n     }\n \n-    pub fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound])\n+    crate fn print_type_bounds(&mut self, prefix: &'static str, bounds: &[ast::GenericBound])\n                              -> io::Result<()> {\n         if !bounds.is_empty() {\n             self.s.word(prefix)?;\n@@ -2807,11 +2807,11 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_lifetime(&mut self, lifetime: ast::Lifetime) -> io::Result<()> {\n+    crate fn print_lifetime(&mut self, lifetime: ast::Lifetime) -> io::Result<()> {\n         self.print_name(lifetime.ident.name)\n     }\n \n-    pub fn print_lifetime_bounds(&mut self, lifetime: ast::Lifetime, bounds: &ast::GenericBounds)\n+    crate fn print_lifetime_bounds(&mut self, lifetime: ast::Lifetime, bounds: &ast::GenericBounds)\n         -> io::Result<()>\n     {\n         self.print_lifetime(lifetime)?;\n@@ -2830,7 +2830,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_generic_params(\n+    crate fn print_generic_params(\n         &mut self,\n         generic_params: &[ast::GenericParam]\n     ) -> io::Result<()> {\n@@ -2876,7 +2876,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_where_clause(&mut self, where_clause: &ast::WhereClause)\n+    crate fn print_where_clause(&mut self, where_clause: &ast::WhereClause)\n                               -> io::Result<()> {\n         if where_clause.predicates.is_empty() {\n             return Ok(())\n@@ -2920,7 +2920,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_use_tree(&mut self, tree: &ast::UseTree) -> io::Result<()> {\n+    crate fn print_use_tree(&mut self, tree: &ast::UseTree) -> io::Result<()> {\n         match tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 self.print_path(&tree.prefix, false, 0)?;\n@@ -2954,20 +2954,20 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_mutability(&mut self,\n+    crate fn print_mutability(&mut self,\n                             mutbl: ast::Mutability) -> io::Result<()> {\n         match mutbl {\n             ast::Mutability::Mutable => self.word_nbsp(\"mut\"),\n             ast::Mutability::Immutable => Ok(()),\n         }\n     }\n \n-    pub fn print_mt(&mut self, mt: &ast::MutTy) -> io::Result<()> {\n+    crate fn print_mt(&mut self, mt: &ast::MutTy) -> io::Result<()> {\n         self.print_mutability(mt.mutbl)?;\n         self.print_type(&mt.ty)\n     }\n \n-    pub fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) -> io::Result<()> {\n+    crate fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         match input.ty.node {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat)?,\n@@ -2992,7 +2992,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn print_fn_output(&mut self, decl: &ast::FnDecl) -> io::Result<()> {\n+    crate fn print_fn_output(&mut self, decl: &ast::FnDecl) -> io::Result<()> {\n         if let ast::FunctionRetTy::Default(..) = decl.output {\n             return Ok(());\n         }\n@@ -3013,7 +3013,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_ty_fn(&mut self,\n+    crate fn print_ty_fn(&mut self,\n                        abi: abi::Abi,\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n@@ -3041,7 +3041,7 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n-    pub fn maybe_print_trailing_comment(&mut self, span: syntax_pos::Span,\n+    crate fn maybe_print_trailing_comment(&mut self, span: syntax_pos::Span,\n                                         next_pos: Option<BytePos>)\n         -> io::Result<()> {\n         let cm = match self.cm {\n@@ -3060,7 +3060,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_remaining_comments(&mut self) -> io::Result<()> {\n+    crate fn print_remaining_comments(&mut self) -> io::Result<()> {\n         // If there aren't any remaining comments, then we need to manually\n         // make sure there is a line break at the end.\n         if self.next_comment().is_none() {\n@@ -3072,7 +3072,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n+    crate fn print_opt_abi_and_extern_if_nondefault(&mut self,\n                                                   opt_abi: Option<Abi>)\n         -> io::Result<()> {\n         match opt_abi {\n@@ -3085,7 +3085,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_extern_opt_abi(&mut self,\n+    crate fn print_extern_opt_abi(&mut self,\n                                 opt_abi: Option<Abi>) -> io::Result<()> {\n         match opt_abi {\n             Some(abi) => {\n@@ -3096,7 +3096,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_fn_header_info(&mut self,\n+    crate fn print_fn_header_info(&mut self,\n                                 header: ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n         self.s.word(visibility_qualified(vis, \"\"))?;\n@@ -3117,14 +3117,14 @@ impl<'a> State<'a> {\n         self.s.word(\"fn\")\n     }\n \n-    pub fn print_unsafety(&mut self, s: ast::Unsafety) -> io::Result<()> {\n+    crate fn print_unsafety(&mut self, s: ast::Unsafety) -> io::Result<()> {\n         match s {\n             ast::Unsafety::Normal => Ok(()),\n             ast::Unsafety::Unsafe => self.word_nbsp(\"unsafe\"),\n         }\n     }\n \n-    pub fn print_is_auto(&mut self, s: ast::IsAuto) -> io::Result<()> {\n+    crate fn print_is_auto(&mut self, s: ast::IsAuto) -> io::Result<()> {\n         match s {\n             ast::IsAuto::Yes => self.word_nbsp(\"auto\"),\n             ast::IsAuto::No => Ok(()),"}]}