{"sha": "f9695a6256a2473636d3e16b5347cddf592fd00d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5Njk1YTYyNTZhMjQ3MzYzNmQzZTE2YjUzNDdjZGRmNTkyZmQwMGQ=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-05-19T21:27:03Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2014-05-20T00:08:05Z"}, "message": "rustc: Better resolve errors for &T, &mut T, remove failure condition.", "tree": {"sha": "45f9d7493b34f6c8b0e4518ede520c376a7fc6f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45f9d7493b34f6c8b0e4518ede520c376a7fc6f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9695a6256a2473636d3e16b5347cddf592fd00d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9695a6256a2473636d3e16b5347cddf592fd00d", "html_url": "https://github.com/rust-lang/rust/commit/f9695a6256a2473636d3e16b5347cddf592fd00d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9695a6256a2473636d3e16b5347cddf592fd00d/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ba7bd10c9c537687ca393eca0b323569309b83a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ba7bd10c9c537687ca393eca0b323569309b83a", "html_url": "https://github.com/rust-lang/rust/commit/1ba7bd10c9c537687ca393eca0b323569309b83a"}], "stats": {"total": 270, "additions": 252, "deletions": 18}, "files": [{"sha": "cd3375799a3ca8b1f489043af98aaed9f4096c3c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f9695a6256a2473636d3e16b5347cddf592fd00d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9695a6256a2473636d3e16b5347cddf592fd00d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f9695a6256a2473636d3e16b5347cddf592fd00d", "patch": "@@ -4891,6 +4891,25 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n+        #[deriving(Eq)]\n+        enum FallbackChecks {\n+            Everything,\n+            OnlyTraitAndStatics\n+        }\n+\n+        fn extract_path_and_node_id(t: &Ty, allow: FallbackChecks)\n+                                                    -> Option<(Path, NodeId, FallbackChecks)> {\n+            match t.node {\n+                TyPath(ref path, _, node_id) => Some((path.clone(), node_id, allow)),\n+                TyPtr(mut_ty) => extract_path_and_node_id(mut_ty.ty, OnlyTraitAndStatics),\n+                TyRptr(_, mut_ty) => extract_path_and_node_id(mut_ty.ty, allow),\n+                // This doesn't handle the remaining `Ty` variants as they are not\n+                // that commonly the self_type, it might be interesting to provide\n+                // support for those in future.\n+                _ => None,\n+            }\n+        }\n+\n         fn get_module(this: &mut Resolver, span: Span, ident_path: &[ast::Ident])\n                             -> Option<Rc<Module>> {\n             let root = this.current_module.clone();\n@@ -4918,27 +4937,29 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        let (path, node_id) = match self.current_self_type {\n-            Some(ref ty) => match ty.node {\n-                TyPath(ref path, _, node_id) => (path.clone(), node_id),\n-                _ => unreachable!(),\n+        let (path, node_id, allowed) = match self.current_self_type {\n+            Some(ref ty) => match extract_path_and_node_id(ty, Everything) {\n+                Some(x) => x,\n+                None => return NoSuggestion,\n             },\n             None => return NoSuggestion,\n         };\n \n-        // Look for a field with the same name in the current self_type.\n-        match self.def_map.borrow().find(&node_id) {\n-             Some(&DefTy(did))\n-            | Some(&DefStruct(did))\n-            | Some(&DefVariant(_, did, _)) => match self.structs.find(&did) {\n-                None => {}\n-                Some(fields) => {\n-                    if fields.iter().any(|&field_name| name == field_name) {\n-                        return Field;\n+        if allowed == Everything {\n+            // Look for a field with the same name in the current self_type.\n+            match self.def_map.borrow().find(&node_id) {\n+                 Some(&DefTy(did))\n+                | Some(&DefStruct(did))\n+                | Some(&DefVariant(_, did, _)) => match self.structs.find(&did) {\n+                    None => {}\n+                    Some(fields) => {\n+                        if fields.iter().any(|&field_name| name == field_name) {\n+                            return Field;\n+                        }\n                     }\n-                }\n-            },\n-            _ => {} // Self type didn't resolve properly\n+                },\n+                _ => {} // Self type didn't resolve properly\n+            }\n         }\n \n         let ident_path = path.segments.iter().map(|seg| seg.identifier).collect::<Vec<_>>();\n@@ -4955,8 +4976,8 @@ impl<'a> Resolver<'a> {\n                                 FromTrait(_) => unreachable!()\n                             }\n                         }\n-                        Some(DefMethod(_, None)) => return Method,\n-                        Some(DefMethod(_, _)) => return TraitMethod,\n+                        Some(DefMethod(_, None)) if allowed == Everything => return Method,\n+                        Some(DefMethod(_, Some(_))) => return TraitMethod,\n                         _ => ()\n                     }\n                 }"}, {"sha": "8b7267ab7766438d4611cdbf01e622e6eab36664", "filename": "src/test/compile-fail/issue-14254.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f9695a6256a2473636d3e16b5347cddf592fd00d/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9695a6256a2473636d3e16b5347cddf592fd00d/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14254.rs?ref=f9695a6256a2473636d3e16b5347cddf592fd00d", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn bar(&self);\n+    fn baz(&self) { }\n+    fn bah(_: Option<Self>) { }\n+}\n+\n+struct BarTy {\n+    x : int,\n+    y : f64,\n+}\n+\n+impl BarTy {\n+    fn a() {}\n+    fn b(&self) {}\n+}\n+\n+impl Foo for *BarTy {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        a;\n+        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+    }\n+}\n+\n+impl<'a> Foo for &'a BarTy {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        x;\n+        //~^ ERROR: unresolved name `x`. Did you mean `self.x`?\n+        y;\n+        //~^ ERROR: unresolved name `y`. Did you mean `self.y`?\n+        a;\n+        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        bah;\n+        //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n+        b;\n+        //~^ ERROR: unresolved name `b`. Did you mean to call `self.b`?\n+    }\n+}\n+\n+impl<'a> Foo for &'a mut BarTy {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        x;\n+        //~^ ERROR: unresolved name `x`. Did you mean `self.x`?\n+        y;\n+        //~^ ERROR: unresolved name `y`. Did you mean `self.y`?\n+        a;\n+        //~^ ERROR: unresolved name `a`. Did you mean to call `BarTy::a`?\n+        bah;\n+        //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n+        b;\n+        //~^ ERROR: unresolved name `b`. Did you mean to call `self.b`?\n+    }\n+}\n+\n+impl Foo for Box<BarTy> {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        bah;\n+        //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n+    }\n+}\n+\n+impl Foo for *int {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        bah;\n+        //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n+    }\n+}\n+\n+impl<'a> Foo for &'a int {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        bah;\n+        //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n+    }\n+}\n+\n+impl<'a> Foo for &'a mut int {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        bah;\n+        //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n+    }\n+}\n+\n+impl Foo for Box<int> {\n+    fn bar(&self) {\n+        baz();\n+        //~^ ERROR: unresolved name `baz`. Did you mean to call `self.baz`?\n+        bah;\n+        //~^ ERROR: unresolved name `bah`. Did you mean to call `Foo::bah`?\n+    }\n+}"}, {"sha": "a3ead0a66858169724e4232ba5b9caaa3e499f9d", "filename": "src/test/run-pass/issue-14254.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f9695a6256a2473636d3e16b5347cddf592fd00d/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9695a6256a2473636d3e16b5347cddf592fd00d/src%2Ftest%2Frun-pass%2Fissue-14254.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14254.rs?ref=f9695a6256a2473636d3e16b5347cddf592fd00d", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn bar(&self);\n+    fn baz(&self) { }\n+    fn bah(_: Option<Self>) { }\n+}\n+\n+struct BarTy {\n+    x : int,\n+    y : f64,\n+}\n+\n+impl BarTy {\n+    fn a() {}\n+    fn b(&self) {}\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl Foo for *BarTy {\n+    fn bar(&self) {\n+        self.baz();\n+        BarTy::a();\n+        Foo::bah(None::<*BarTy>);\n+    }\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl<'a> Foo for &'a BarTy {\n+    fn bar(&self) {\n+        self.baz();\n+        self.x;\n+        self.y;\n+        BarTy::a();\n+        Foo::bah(None::<&BarTy>);\n+        self.b();\n+    }\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl<'a> Foo for &'a mut BarTy {\n+    fn bar(&self) {\n+        self.baz();\n+        self.x;\n+        self.y;\n+        BarTy::a();\n+        Foo::bah(None::<&mut BarTy>);\n+        self.b();\n+    }\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl Foo for Box<BarTy> {\n+    fn bar(&self) {\n+        self.baz();\n+        Foo::bah(None::<Box<BarTy>>);\n+    }\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl Foo for *int {\n+    fn bar(&self) {\n+        self.baz();\n+        Foo::bah(None::<*int>);\n+    }\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl<'a> Foo for &'a int {\n+    fn bar(&self) {\n+        self.baz();\n+        Foo::bah(None::<&int>);\n+    }\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl<'a> Foo for &'a mut int {\n+    fn bar(&self) {\n+        self.baz();\n+        Foo::bah(None::<&mut int>);\n+    }\n+}\n+\n+// If these fail, it's necessary to update middle::resolve and the cfail tests.\n+impl Foo for Box<int> {\n+    fn bar(&self) {\n+        self.baz();\n+        Foo::bah(None::<Box<int>>);\n+    }\n+}\n+\n+fn main() {}"}]}