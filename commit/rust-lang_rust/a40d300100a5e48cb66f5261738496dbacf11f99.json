{"sha": "a40d300100a5e48cb66f5261738496dbacf11f99", "node_id": "C_kwDOAAsO6NoAKGE0MGQzMDAxMDBhNWU0OGNiNjZmNTI2MTczODQ5NmRiYWNmMTFmOTk", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-09-05T08:19:12Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2022-09-05T08:19:12Z"}, "message": "std: clarify semantics of SGX parker", "tree": {"sha": "33623f1674c80b2b547314cb5890809b7c0fcc77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33623f1674c80b2b547314cb5890809b7c0fcc77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a40d300100a5e48cb66f5261738496dbacf11f99", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmMVsQAACgkQcE4BSbAZ\nSzy82Q/+KlbeCc/NFCiSlviYXsWi31LAo+HjFAE5A9cGDheGyHB1b2YXx22DUvjY\nJ8B8yR7c8tplXYi92YQprB/R4IByCeIH6d4GsCTUGtWBt1q10xSKXlbimyDkAmY4\nljzFnL5fbdqIyYfIqyZ/BlkLMOx2+0yOYIknFdJslIW5bB158pfA54cdMyJYfd5E\n+7Tb3rPIlj/y7NhSv1ps39TGSIsv8jmyRLcv2wLY1fO1O6EDVLviiM7qXj3pg3B7\n0y5htTh+yvQSpWvN6py0+DopPEn3oD0SMs5U8mcHEUt9RrrVkK9kd6XYIuWU6ACK\nNnKi/eEP3bngfmsqGvfVTWGdRTkcVBjVd4eS7IvJCGxkcvpXW6x7szMBg0nOlq5n\npUAimWDghTAH1Ry/iQsIXxFV7IHrebisjCADyTNBB+Ci7zHokDhzQXnoZlrXD/5x\nPwZDqas77x04Z3zH3uJIXuAt399ep823xE56B6ZlFm22sN4YBlF+wIzwqlLnfoL8\nXfqyHvUwqQSBvkZZQaRTKHRIt6IF6vhZJQP7Jnnf3Vw7ad7DkPtFKicMS2VBEXV7\nkMC6VQ1OHV1Tjb5rBrxMvmix7EcSaqky/sO2PHWHsmx4QC9DFNjy2JZgpJafvnJy\n0x+IaxV6JFFRcTJvbljLllTWC8x/ws+isRokuNGn85/Rcq4d1JY=\n=RTaV\n-----END PGP SIGNATURE-----", "payload": "tree 33623f1674c80b2b547314cb5890809b7c0fcc77\nparent 633d46d0245bf7f60b341c8df8da230c0b689396\nauthor joboet <jonasboettiger@icloud.com> 1662365952 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1662365952 +0200\n\nstd: clarify semantics of SGX parker\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a40d300100a5e48cb66f5261738496dbacf11f99", "html_url": "https://github.com/rust-lang/rust/commit/a40d300100a5e48cb66f5261738496dbacf11f99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a40d300100a5e48cb66f5261738496dbacf11f99/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "633d46d0245bf7f60b341c8df8da230c0b689396", "url": "https://api.github.com/repos/rust-lang/rust/commits/633d46d0245bf7f60b341c8df8da230c0b689396", "html_url": "https://github.com/rust-lang/rust/commit/633d46d0245bf7f60b341c8df8da230c0b689396"}], "stats": {"total": 44, "additions": 29, "deletions": 15}, "files": [{"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a40d300100a5e48cb66f5261738496dbacf11f99/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a40d300100a5e48cb66f5261738496dbacf11f99/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=a40d300100a5e48cb66f5261738496dbacf11f99", "patch": "@@ -9,11 +9,17 @@ use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n use crate::time::Duration;\n use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n \n-const EMPTY: *mut u8 = ptr::invalid_mut(0);\n-/// The TCS structure must be page-aligned, so this cannot be a valid pointer\n-const NOTIFIED: *mut u8 = ptr::invalid_mut(1);\n+// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n+// be valid pointers\n+const EMPTY: *mut u8 = ptr::invalid_mut(1);\n+const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n \n pub struct Parker {\n+    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n+    /// A state change to NOTIFIED must be done with release ordering\n+    /// and be observed with acquire ordering so that operations after\n+    /// `thread::park` returns will not occur before the unpark message\n+    /// was sent.\n     state: AtomicPtr<u8>,\n }\n \n@@ -30,23 +36,28 @@ impl Parker {\n \n     // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n     pub unsafe fn park(self: Pin<&Self>) {\n-        let tcs = thread::current().as_ptr();\n-\n         if self.state.load(Acquire) != NOTIFIED {\n-            if self.state.compare_exchange(EMPTY, tcs, Acquire, Acquire).is_ok() {\n-                // Loop to guard against spurious wakeups.\n-                loop {\n+            let mut prev = EMPTY;\n+            loop {\n+                // Guard against changing TCS addresses by always setting the state to\n+                // the current value.\n+                let tcs = thread::current().as_ptr();\n+                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n                     let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n                     assert!(event & EV_UNPARK == EV_UNPARK);\n-                    if self.state.load(Acquire) == NOTIFIED {\n-                        break;\n-                    }\n+                    prev = tcs;\n+                } else {\n+                    // The state was definitely changed by another thread at this point.\n+                    // The only time this occurs is when the state is changed to NOTIFIED.\n+                    // We observed this change with acquire ordering, so we can simply\n+                    // change the state to EMPTY with a relaxed store.\n+                    break;\n                 }\n             }\n         }\n \n         // At this point, the token was definately read with acquire ordering,\n-        // so this can be a store.\n+        // so this can be a relaxed store.\n         self.state.store(EMPTY, Relaxed);\n     }\n \n@@ -56,7 +67,7 @@ impl Parker {\n         let tcs = thread::current().as_ptr();\n \n         if self.state.load(Acquire) != NOTIFIED {\n-            if self.state.compare_exchange(EMPTY, tcs, Acquire, Acquire).is_ok() {\n+            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n                 match usercalls::wait(EV_UNPARK, timeout) {\n                     Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n                     Err(e) => {\n@@ -85,8 +96,11 @@ impl Parker {\n         if !matches!(state, EMPTY | NOTIFIED) {\n             // There is a thread waiting, wake it up.\n             let tcs = NonNull::new(state).unwrap();\n-            // This will fail if the thread has already terminated by the time the signal is send,\n-            // but that is OK.\n+            // This will fail if the thread has already terminated or its TCS is destroyed\n+            // by the time the signal is sent, but that is fine. If another thread receives\n+            // the same TCS, it will receive this notification as a spurious wakeup, but\n+            // all users of `wait` should and (internally) do guard against those where\n+            // necessary.\n             let _ = usercalls::send(EV_UNPARK, Some(tcs));\n         }\n     }"}]}