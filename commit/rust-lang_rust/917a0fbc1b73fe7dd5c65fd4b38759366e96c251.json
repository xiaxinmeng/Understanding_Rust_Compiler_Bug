{"sha": "917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxN2EwZmJjMWI3M2ZlN2RkNWM2NWZkNGIzODc1OTM2NmU5NmMyNTE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-04T12:18:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-04T13:55:46Z"}, "message": "Rename `PathResolution` to `PartialRes`\n\nDon't use `PartialRes` when `Res` is enough", "tree": {"sha": "3d79fa50c49132a63ccadd32bd73a04efd040d31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d79fa50c49132a63ccadd32bd73a04efd040d31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "html_url": "https://github.com/rust-lang/rust/commit/917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0a6ddfe10a1b0002e76c82696c8a093d87dc155", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0a6ddfe10a1b0002e76c82696c8a093d87dc155", "html_url": "https://github.com/rust-lang/rust/commit/d0a6ddfe10a1b0002e76c82696c8a093d87dc155"}], "stats": {"total": 233, "additions": 103, "deletions": 130}, "files": [{"sha": "6ff0c0fbb5008d97ba481a6d6168ab3a34827c83", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "patch": "@@ -1,5 +1,5 @@\n use crate::hir::def_id::DefId;\n-use crate::util::nodemap::{NodeMap, DefIdMap};\n+use crate::util::nodemap::DefIdMap;\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::ast::NodeId;\n@@ -151,7 +151,9 @@ pub enum Res<Id = hir::HirId> {\n     Err,\n }\n \n-/// The result of resolving a path before lowering to HIR.\n+/// The result of resolving a path before lowering to HIR,\n+/// with \"module\" segments resolved and associated item\n+/// segments deferred to type checking.\n /// `base_res` is the resolution of the resolved part of the\n /// path, `unresolved_segments` is the number of unresolved\n /// segments.\n@@ -166,19 +168,21 @@ pub enum Res<Id = hir::HirId> {\n ///       base_res        unresolved_segments = 2\n /// ```\n #[derive(Copy, Clone, Debug)]\n-pub struct PathResolution {\n+pub struct PartialRes {\n     base_res: Res<NodeId>,\n     unresolved_segments: usize,\n }\n \n-impl PathResolution {\n-    pub fn new(res: Res<NodeId>) -> Self {\n-        PathResolution { base_res: res, unresolved_segments: 0 }\n+impl PartialRes {\n+    #[inline]\n+    pub fn new(base_res: Res<NodeId>) -> Self {\n+        PartialRes { base_res, unresolved_segments: 0 }\n     }\n \n-    pub fn with_unresolved_segments(res: Res<NodeId>, mut unresolved_segments: usize) -> Self {\n-        if res == Res::Err { unresolved_segments = 0 }\n-        PathResolution { base_res: res, unresolved_segments: unresolved_segments }\n+    #[inline]\n+    pub fn with_unresolved_segments(base_res: Res<NodeId>, mut unresolved_segments: usize) -> Self {\n+        if base_res == Res::Err { unresolved_segments = 0 }\n+        PartialRes { base_res, unresolved_segments }\n     }\n \n     #[inline]\n@@ -269,17 +273,10 @@ impl<T> PerNS<Option<T>> {\n     }\n }\n \n-/// Definition mapping\n-pub type ResMap = NodeMap<PathResolution>;\n-\n /// This is the replacement export map. It maps a module to all of the exports\n /// within.\n pub type ExportMap<Id> = DefIdMap<Vec<Export<Id>>>;\n \n-/// Map used to track the `use` statements within a scope, matching it with all the items in every\n-/// namespace.\n-pub type ImportMap = NodeMap<PerNS<Option<PathResolution>>>;\n-\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct Export<Id> {\n     /// The name of the target."}, {"sha": "9ae9995be43bac0e34e671edb72a33de1a4082bb", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "patch": "@@ -37,7 +37,7 @@ use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n-use crate::hir::def::{Res, DefKind, PathResolution, PerNS};\n+use crate::hir::def::{Res, DefKind, PartialRes, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n@@ -145,11 +145,11 @@ pub trait Resolver {\n         is_value: bool,\n     ) -> hir::Path;\n \n-    /// Obtain the resolution for a `NodeId`.\n-    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n+    /// Obtain resolution for a `NodeId` with a single resolution.\n+    fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n-    /// Obtain the possible resolutions for the given `use` statement.\n-    fn get_import(&mut self, id: NodeId) -> PerNS<Option<PathResolution>>;\n+    /// Obtain per-namespace resolutions for `use` statement with the given `NoedId`.\n+    fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n \n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     /// This should only return `None` during testing.\n@@ -821,7 +821,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expect_full_res(&mut self, id: NodeId) -> Res<NodeId> {\n-        self.resolver.get_resolution(id).map_or(Res::Err, |pr| {\n+        self.resolver.get_partial_res(id).map_or(Res::Err, |pr| {\n             if pr.unresolved_segments() != 0 {\n                 bug!(\"path not fully resolved: {:?}\", pr);\n             }\n@@ -830,12 +830,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expect_full_res_from_use(&mut self, id: NodeId) -> impl Iterator<Item = Res<NodeId>> {\n-        self.resolver.get_import(id).present_items().map(|pr| {\n-            if pr.unresolved_segments() != 0 {\n-                bug!(\"path not fully resolved: {:?}\", pr);\n-            }\n-            pr.base_res()\n-        })\n+        self.resolver.get_import_res(id).present_items()\n     }\n \n     fn diagnostic(&self) -> &errors::Handler {\n@@ -1842,13 +1837,13 @@ impl<'a> LoweringContext<'a> {\n         let qself_position = qself.as_ref().map(|q| q.position);\n         let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n \n-        let resolution = self.resolver\n-            .get_resolution(id)\n-            .unwrap_or_else(|| PathResolution::new(Res::Err));\n+        let partial_res = self.resolver\n+            .get_partial_res(id)\n+            .unwrap_or_else(|| PartialRes::new(Res::Err));\n \n-        let proj_start = p.segments.len() - resolution.unresolved_segments();\n+        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n         let path = P(hir::Path {\n-            res: self.lower_res(resolution.base_res()),\n+            res: self.lower_res(partial_res.base_res()),\n             segments: p.segments[..proj_start]\n                 .iter()\n                 .enumerate()\n@@ -1869,7 +1864,7 @@ impl<'a> LoweringContext<'a> {\n                         krate: def_id.krate,\n                         index: this.def_key(def_id).parent.expect(\"missing parent\"),\n                     };\n-                    let type_def_id = match resolution.base_res() {\n+                    let type_def_id = match partial_res.base_res() {\n                         Res::Def(DefKind::AssociatedTy, def_id) if i + 2 == proj_start => {\n                             Some(parent_def_id(self, def_id))\n                         }\n@@ -1886,7 +1881,7 @@ impl<'a> LoweringContext<'a> {\n                         }\n                         _ => None,\n                     };\n-                    let parenthesized_generic_args = match resolution.base_res() {\n+                    let parenthesized_generic_args = match partial_res.base_res() {\n                         // `a::b::Trait(Args)`\n                         Res::Def(DefKind::Trait, _)\n                             if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n@@ -1940,7 +1935,7 @@ impl<'a> LoweringContext<'a> {\n \n         // Simple case, either no projections, or only fully-qualified.\n         // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if resolution.unresolved_segments() == 0 {\n+        if partial_res.unresolved_segments() == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n \n@@ -2792,7 +2787,7 @@ impl<'a> LoweringContext<'a> {\n                                     && bound_pred.bound_generic_params.is_empty() =>\n                             {\n                                 if let Some(Res::Def(DefKind::TyParam, def_id)) = self.resolver\n-                                    .get_resolution(bound_pred.bounded_ty.id)\n+                                    .get_partial_res(bound_pred.bounded_ty.id)\n                                     .map(|d| d.base_res())\n                                 {\n                                     if let Some(node_id) =\n@@ -3946,7 +3941,7 @@ impl<'a> LoweringContext<'a> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n             PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                match self.resolver.get_resolution(p.id).map(|d| d.base_res()) {\n+                match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n                     // `None` can occur in body-less function signatures\n                     res @ None | res @ Some(Res::Local(_)) => {\n                         let canonical_id = match res {"}, {"sha": "7399245b0a00fc8c9e6754ef5bdfb37423fe4056", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "patch": "@@ -2142,7 +2142,7 @@ pub enum UseKind {\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n /// trait being referred to but just a unique NodeId that serves as a key\n-/// within the ResMap.\n+/// within the resolution map.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: Path,"}, {"sha": "131f26663c70b9dfbd77e97847323ce76e0562fa", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 69, "deletions": 87, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "patch": "@@ -24,7 +24,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{\n-    self, DefKind, PathResolution, CtorKind, CtorOf, NonMacroAttrKind, ResMap, ImportMap, ExportMap\n+    self, DefKind, PartialRes, CtorKind, CtorOf, NonMacroAttrKind, ExportMap\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n@@ -821,7 +821,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n                 let self_ty = keywords::SelfUpper.ident();\n                 let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n                               .map_or(Res::Err, |d| d.res());\n-                self.record_res(ty.id, PathResolution::new(res));\n+                self.record_partial_res(ty.id, PartialRes::new(res));\n             }\n             _ => (),\n         }\n@@ -1146,7 +1146,7 @@ impl ModuleOrUniformRoot<'_> {\n #[derive(Clone, Debug)]\n enum PathResult<'a> {\n     Module(ModuleOrUniformRoot<'a>),\n-    NonModule(PathResolution),\n+    NonModule(PartialRes),\n     Indeterminate,\n     Failed {\n         span: Span,\n@@ -1659,8 +1659,11 @@ pub struct Resolver<'a> {\n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n-    res_map: ResMap,\n-    import_map: ImportMap,\n+    /// Resolutions for nodes that have a single resolution.\n+    partial_res_map: NodeMap<PartialRes>,\n+    /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n+    import_res_map: NodeMap<PerNS<Option<Res>>>,\n+\n     pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n     pub export_map: ExportMap<NodeId>,\n@@ -1830,12 +1833,12 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         self.resolve_hir_path(&path, is_value)\n     }\n \n-    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n-        self.res_map.get(&id).cloned()\n+    fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n+        self.partial_res_map.get(&id).cloned()\n     }\n \n-    fn get_import(&mut self, id: NodeId) -> PerNS<Option<PathResolution>> {\n-        self.import_map.get(&id).cloned().unwrap_or_default()\n+    fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res>> {\n+        self.import_res_map.get(&id).cloned().unwrap_or_default()\n     }\n \n     fn definitions(&mut self) -> &mut Definitions {\n@@ -1919,7 +1922,7 @@ impl<'a> Resolver<'a> {\n \n         let segments: Vec<_> = segments.iter().map(|seg| {\n             let mut hir_seg = hir::PathSegment::from_ident(seg.ident);\n-            hir_seg.res = Some(self.res_map.get(&seg.id).map_or(def::Res::Err, |p| {\n+            hir_seg.res = Some(self.partial_res_map.get(&seg.id).map_or(def::Res::Err, |p| {\n                 p.base_res().map_id(|_| panic!(\"unexpected node_id\"))\n             }));\n             hir_seg\n@@ -2019,8 +2022,8 @@ impl<'a> Resolver<'a> {\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n-            res_map: Default::default(),\n-            import_map: Default::default(),\n+            partial_res_map: Default::default(),\n+            import_res_map: Default::default(),\n             freevars: Default::default(),\n             freevars_seen: Default::default(),\n             export_map: FxHashMap::default(),\n@@ -2705,7 +2708,7 @@ impl<'a> Resolver<'a> {\n                                 self.definitions.local_def_id(param.id),\n                             );\n                             function_type_rib.bindings.insert(ident, res);\n-                            self.record_res(param.id, PathResolution::new(res));\n+                            self.record_partial_res(param.id, PartialRes::new(res));\n                         }\n                         GenericParamKind::Const { .. } => {\n                             let ident = param.ident.modern();\n@@ -2726,7 +2729,7 @@ impl<'a> Resolver<'a> {\n                                 self.definitions.local_def_id(param.id),\n                             );\n                             function_value_rib.bindings.insert(ident, res);\n-                            self.record_res(param.id, PathResolution::new(res));\n+                            self.record_partial_res(param.id, PartialRes::new(res));\n                         }\n                     }\n                 }\n@@ -2994,7 +2997,8 @@ impl<'a> Resolver<'a> {\n \n         pat.walk(&mut |pat| {\n             if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.res_map.get(&pat.id).map(|res| res.base_res()) {\n+                if sub_pat.is_some() || match self.partial_res_map.get(&pat.id)\n+                                                                  .map(|res| res.base_res()) {\n                     Some(Res::Local(..)) => true,\n                     _ => false,\n                 } {\n@@ -3146,7 +3150,7 @@ impl<'a> Resolver<'a> {\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n                      bindings: &mut FxHashMap<Ident, NodeId>)\n-                     -> PathResolution {\n+                     -> Res {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n         // must not add it if it's in the bindings map\n@@ -3193,7 +3197,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        PathResolution::new(res)\n+        res\n     }\n \n     fn resolve_pattern(&mut self,\n@@ -3213,7 +3217,7 @@ impl<'a> Resolver<'a> {\n                     let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n                                                                       None, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n-                    let resolution = binding.map(NameBinding::res).and_then(|res| {\n+                    let res = binding.map(NameBinding::res).and_then(|res| {\n                         let is_syntactic_ambiguity = opt_pat.is_none() &&\n                             bmode == BindingMode::ByValue(Mutability::Immutable);\n                         match res {\n@@ -3222,7 +3226,7 @@ impl<'a> Resolver<'a> {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n                                 self.record_use(ident, ValueNS, binding.unwrap(), false);\n-                                Some(PathResolution::new(res))\n+                                Some(res)\n                             }\n                             Res::Def(DefKind::Ctor(..), _)\n                             | Res::Def(DefKind::Const, _)\n@@ -3254,7 +3258,7 @@ impl<'a> Resolver<'a> {\n                         self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n                     });\n \n-                    self.record_res(pat.id, resolution);\n+                    self.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n \n                 PatKind::TupleStruct(ref path, ..) => {\n@@ -3286,35 +3290,15 @@ impl<'a> Resolver<'a> {\n                           id: NodeId,\n                           qself: Option<&QSelf>,\n                           path: &Path,\n-                          source: PathSource<'_>)\n-                          -> PathResolution {\n-        self.smart_resolve_path_with_crate_lint(id, qself, path, source, CrateLint::SimplePath(id))\n-    }\n-\n-    /// A variant of `smart_resolve_path` where you also specify extra\n-    /// information about where the path came from; this extra info is\n-    /// sometimes needed for the lint that recommends rewriting\n-    /// absolute paths to `crate`, so that it knows how to frame the\n-    /// suggestion. If you are just resolving a path like `foo::bar`\n-    /// that appears in an arbitrary location, then you just want\n-    /// `CrateLint::SimplePath`, which is what `smart_resolve_path`\n-    /// already provides.\n-    fn smart_resolve_path_with_crate_lint(\n-        &mut self,\n-        id: NodeId,\n-        qself: Option<&QSelf>,\n-        path: &Path,\n-        source: PathSource<'_>,\n-        crate_lint: CrateLint\n-    ) -> PathResolution {\n+                          source: PathSource<'_>) {\n         self.smart_resolve_path_fragment(\n             id,\n             qself,\n             &Segment::from_path(path),\n             path.span,\n             source,\n-            crate_lint,\n-        )\n+            CrateLint::SimplePath(id),\n+        );\n     }\n \n     fn smart_resolve_path_fragment(&mut self,\n@@ -3324,7 +3308,7 @@ impl<'a> Resolver<'a> {\n                                    span: Span,\n                                    source: PathSource<'_>,\n                                    crate_lint: CrateLint)\n-                                   -> PathResolution {\n+                                   -> PartialRes {\n         let ns = source.namespace();\n         let is_expected = &|res| source.is_expected(res);\n \n@@ -3334,10 +3318,10 @@ impl<'a> Resolver<'a> {\n             let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n             let better = res.is_some();\n             this.use_injections.push(UseError { err, candidates, node_id, better });\n-            err_path_resolution()\n+            PartialRes::new(Res::Err)\n         };\n \n-        let resolution = match self.resolve_qpath_anywhere(\n+        let partial_res = match self.resolve_qpath_anywhere(\n             id,\n             qself,\n             path,\n@@ -3347,14 +3331,14 @@ impl<'a> Resolver<'a> {\n             source.global_by_default(),\n             crate_lint,\n         ) {\n-            Some(resolution) if resolution.unresolved_segments() == 0 => {\n-                if is_expected(resolution.base_res()) || resolution.base_res() == Res::Err {\n-                    resolution\n+            Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n+                if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n+                    partial_res\n                 } else {\n                     // Add a temporary hack to smooth the transition to new struct ctor\n                     // visibility rules. See #38932 for more details.\n                     let mut res = None;\n-                    if let Res::Def(DefKind::Struct, def_id) = resolution.base_res() {\n+                    if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n                         if let Some((ctor_res, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_res) && self.is_accessible(ctor_vis) {\n@@ -3363,15 +3347,15 @@ impl<'a> Resolver<'a> {\n                                     \"private struct constructors are not usable through \\\n                                      re-exports in outer modules\",\n                                 );\n-                                res = Some(PathResolution::new(ctor_res));\n+                                res = Some(PartialRes::new(ctor_res));\n                             }\n                         }\n                     }\n \n-                    res.unwrap_or_else(|| report_errors(self, Some(resolution.base_res())))\n+                    res.unwrap_or_else(|| report_errors(self, Some(partial_res.base_res())))\n                 }\n             }\n-            Some(resolution) if source.defer_to_typeck() => {\n+            Some(partial_res) if source.defer_to_typeck() => {\n                 // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n@@ -3399,16 +3383,16 @@ impl<'a> Resolver<'a> {\n                         hm.insert(span, span);\n                     }\n                 }\n-                resolution\n+                partial_res\n             }\n             _ => report_errors(self, None)\n         };\n \n         if let PathSource::TraitItem(..) = source {} else {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n-            self.record_res(id, resolution);\n+            self.record_partial_res(id, partial_res);\n         }\n-        resolution\n+        partial_res\n     }\n \n     /// Only used in a specific case of type ascription suggestions\n@@ -3523,7 +3507,7 @@ impl<'a> Resolver<'a> {\n         defer_to_typeck: bool,\n         global_by_default: bool,\n         crate_lint: CrateLint,\n-    ) -> Option<PathResolution> {\n+    ) -> Option<PartialRes> {\n         let mut fin_res = None;\n         // FIXME: can't resolve paths in macro namespace yet, macros are\n         // processed by the little special hack below.\n@@ -3532,9 +3516,10 @@ impl<'a> Resolver<'a> {\n                 match self.resolve_qpath(id, qself, path, ns, span, global_by_default, crate_lint) {\n                     // If defer_to_typeck, then resolution > no resolution,\n                     // otherwise full resolution > partial resolution > no resolution.\n-                    Some(res) if res.unresolved_segments() == 0 || defer_to_typeck =>\n-                        return Some(res),\n-                    res => if fin_res.is_none() { fin_res = res },\n+                    Some(partial_res) if partial_res.unresolved_segments() == 0 ||\n+                                         defer_to_typeck =>\n+                        return Some(partial_res),\n+                    partial_res => if fin_res.is_none() { fin_res = partial_res },\n                 };\n             }\n         }\n@@ -3545,7 +3530,7 @@ impl<'a> Resolver<'a> {\n             self.macro_use_prelude.get(&path[0].ident.name).cloned()\n                                   .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n-            return Some(PathResolution::new(Res::Def(\n+            return Some(PartialRes::new(Res::Def(\n                 DefKind::Macro(MacroKind::Bang),\n                 DefId::local(CRATE_DEF_INDEX),\n             )));\n@@ -3563,7 +3548,7 @@ impl<'a> Resolver<'a> {\n         span: Span,\n         global_by_default: bool,\n         crate_lint: CrateLint,\n-    ) -> Option<PathResolution> {\n+    ) -> Option<PartialRes> {\n         debug!(\n             \"resolve_qpath(id={:?}, qself={:?}, path={:?}, \\\n              ns={:?}, span={:?}, global_by_default={:?})\",\n@@ -3580,7 +3565,7 @@ impl<'a> Resolver<'a> {\n                 // This is a case like `<T>::B`, where there is no\n                 // trait to resolve.  In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n-                return Some(PathResolution::with_unresolved_segments(\n+                return Some(PartialRes::with_unresolved_segments(\n                     Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)), path.len()\n                 ));\n             }\n@@ -3600,7 +3585,7 @@ impl<'a> Resolver<'a> {\n             // name from a fully qualified path, and this also\n             // contains the full span (the `CrateLint::QPathTrait`).\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let res = self.smart_resolve_path_fragment(\n+            let partial_res = self.smart_resolve_path_fragment(\n                 id,\n                 None,\n                 &path[..=qself.position],\n@@ -3615,8 +3600,9 @@ impl<'a> Resolver<'a> {\n             // The remaining segments (the `C` in our example) will\n             // have to be resolved by type-check, since that requires doing\n             // trait resolution.\n-            return Some(PathResolution::with_unresolved_segments(\n-                res.base_res(), res.unresolved_segments() + path.len() - qself.position - 1\n+            return Some(PartialRes::with_unresolved_segments(\n+                partial_res.base_res(),\n+                partial_res.unresolved_segments() + path.len() - qself.position - 1,\n             ));\n         }\n \n@@ -3629,7 +3615,7 @@ impl<'a> Resolver<'a> {\n         ) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n-                PathResolution::new(module.res().unwrap())\n+                PartialRes::new(module.res().unwrap())\n             }\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n             // don't report an error right away, but try to fallback to a primitive type.\n@@ -3649,13 +3635,13 @@ impl<'a> Resolver<'a> {\n                        self.primitive_type_table.primitive_types\n                            .contains_key(&path[0].ident.name) => {\n                 let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n-                PathResolution::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n+                PartialRes::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n             }\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                PathResolution::new(module.res().unwrap()),\n+                PartialRes::new(module.res().unwrap()),\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve { label, suggestion });\n-                err_path_resolution()\n+                PartialRes::new(Res::Err)\n             }\n             PathResult::Module(..) | PathResult::Failed { .. } => return None,\n             PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n@@ -3731,9 +3717,9 @@ impl<'a> Resolver<'a> {\n             let record_segment_res = |this: &mut Self, res| {\n                 if record_used {\n                     if let Some(id) = id {\n-                        if !this.res_map.contains_key(&id) {\n+                        if !this.partial_res_map.contains_key(&id) {\n                             assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_res(id, PathResolution::new(res));\n+                            this.record_partial_res(id, PartialRes::new(res));\n                         }\n                     }\n                 }\n@@ -3837,7 +3823,7 @@ impl<'a> Resolver<'a> {\n                     Some(LexicalScopeBinding::Res(res))\n                             if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) => {\n                         record_segment_res(self, res);\n-                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res, path.len() - 1\n                         ));\n                     }\n@@ -3864,17 +3850,17 @@ impl<'a> Resolver<'a> {\n                             ).emit();\n                         }\n                         let res = Res::NonMacroAttr(NonMacroAttrKind::Tool);\n-                        return PathResult::NonModule(PathResolution::new(res));\n+                        return PathResult::NonModule(PartialRes::new(res));\n                     } else if res == Res::Err {\n-                        return PathResult::NonModule(err_path_resolution());\n+                        return PathResult::NonModule(PartialRes::new(Res::Err));\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n                         self.lint_if_path_starts_with_module(\n                             crate_lint,\n                             path,\n                             path_span,\n                             second_binding,\n                         );\n-                        return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                        return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res, path.len() - i - 1\n                         ));\n                     } else {\n@@ -3897,7 +3883,7 @@ impl<'a> Resolver<'a> {\n                 Err(Determined) => {\n                     if let Some(ModuleOrUniformRoot::Module(module)) = module {\n                         if opt_ns.is_some() && !module.is_normal() {\n-                            return PathResult::NonModule(PathResolution::with_unresolved_segments(\n+                            return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                                 module.res().unwrap(), path.len() - i\n                             ));\n                         }\n@@ -3928,7 +3914,7 @@ impl<'a> Resolver<'a> {\n                             (format!(\"maybe a missing `extern crate {};`?\", ident), None)\n                         } else {\n                             // the parser will already have complained about the keyword being used\n-                            return PathResult::NonModule(err_path_resolution());\n+                            return PathResult::NonModule(PartialRes::new(Res::Err));\n                         }\n                     } else if i == 0 {\n                         (format!(\"use of undeclared type or module `{}`\", ident), None)\n@@ -4177,7 +4163,7 @@ impl<'a> Resolver<'a> {\n         if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n             if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n                 // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.res_map.get(&node_id) {\n+                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n                     match resolution.base_res() {\n                         Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n                                 if resolution.unresolved_segments() == 0 => {\n@@ -4398,15 +4384,15 @@ impl<'a> Resolver<'a> {\n                             });\n                             find_best_match_for_name(names, &*ident.as_str(), None)\n                         });\n-                        self.record_res(expr.id, err_path_resolution());\n+                        self.record_partial_res(expr.id, PartialRes::new(Res::Err));\n                         resolve_error(self,\n                                       label.ident.span,\n                                       ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n                                                                        close_match));\n                     }\n                     Some(Res::Label(id)) => {\n                         // Since this res is a label, it is never read.\n-                        self.record_res(expr.id, PathResolution::new(Res::Label(id)));\n+                        self.record_partial_res(expr.id, PartialRes::new(Res::Label(id)));\n                         self.unused_labels.remove(&id);\n                     }\n                     Some(_) => {\n@@ -4858,9 +4844,9 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    fn record_res(&mut self, node_id: NodeId, resolution: PathResolution) {\n+    fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n-        if let Some(prev_res) = self.res_map.insert(node_id, resolution) {\n+        if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n             panic!(\"path resolved multiple times ({:?} before, {:?} now)\", prev_res, resolution);\n         }\n     }\n@@ -5483,10 +5469,6 @@ fn module_to_string(module: Module<'_>) -> Option<String> {\n                         .collect::<Vec<_>>()))\n }\n \n-fn err_path_resolution() -> PathResolution {\n-    PathResolution::new(Res::Err)\n-}\n-\n #[derive(Copy, Clone, Debug)]\n enum CrateLint {\n     /// Do not issue the lint."}, {"sha": "9e6b8d035458de88d7e3ac31d6c0c4a230400251", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/917a0fbc1b73fe7dd5c65fd4b38759366e96c251/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=917a0fbc1b73fe7dd5c65fd4b38759366e96c251", "patch": "@@ -21,7 +21,7 @@ use rustc::lint::builtin::{\n     UNUSED_IMPORTS,\n };\n use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::def::{self, DefKind, PathResolution, Export};\n+use rustc::hir::def::{self, DefKind, PartialRes, Export};\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n@@ -1233,8 +1233,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     res = Res::Err;\n                 }\n             }\n-            let import = this.import_map.entry(directive.id).or_default();\n-            import[ns] = Some(PathResolution::new(res));\n+            this.import_res_map.entry(directive.id).or_default()[ns] = Some(res);\n         });\n \n         self.check_for_redundant_imports(\n@@ -1371,7 +1370,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n \n         // Record the destination of this import\n-        self.record_res(directive.id, PathResolution::new(module.res().unwrap()));\n+        self.record_partial_res(directive.id, PartialRes::new(module.res().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording re-exports,"}]}