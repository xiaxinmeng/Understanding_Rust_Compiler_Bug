{"sha": "c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMjA2NGQxNTNkY2NiMmQ2NmM1MTU4ZTBjN2VlYjZhOGJiY2EwZjU=", "commit": {"author": {"name": "Youngmin Yoo", "email": "youngmin.yoo@samsung.com", "date": "2013-05-08T10:48:26Z"}, "committer": {"name": "Youngmin Yoo", "email": "youngmin.yoo@samsung.com", "date": "2013-05-09T05:20:04Z"}, "message": "librustc: rename vec::each(var) to var.each", "tree": {"sha": "a4c0caa021a909f333d830cf4b28a30904165c4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4c0caa021a909f333d830cf4b28a30904165c4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "html_url": "https://github.com/rust-lang/rust/commit/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/comments", "author": {"login": "recrack", "id": 329213, "node_id": "MDQ6VXNlcjMyOTIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/329213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/recrack", "html_url": "https://github.com/recrack", "followers_url": "https://api.github.com/users/recrack/followers", "following_url": "https://api.github.com/users/recrack/following{/other_user}", "gists_url": "https://api.github.com/users/recrack/gists{/gist_id}", "starred_url": "https://api.github.com/users/recrack/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/recrack/subscriptions", "organizations_url": "https://api.github.com/users/recrack/orgs", "repos_url": "https://api.github.com/users/recrack/repos", "events_url": "https://api.github.com/users/recrack/events{/privacy}", "received_events_url": "https://api.github.com/users/recrack/received_events", "type": "User", "site_admin": false}, "committer": {"login": "recrack", "id": 329213, "node_id": "MDQ6VXNlcjMyOTIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/329213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/recrack", "html_url": "https://github.com/recrack", "followers_url": "https://api.github.com/users/recrack/followers", "following_url": "https://api.github.com/users/recrack/following{/other_user}", "gists_url": "https://api.github.com/users/recrack/gists{/gist_id}", "starred_url": "https://api.github.com/users/recrack/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/recrack/subscriptions", "organizations_url": "https://api.github.com/users/recrack/orgs", "repos_url": "https://api.github.com/users/recrack/repos", "events_url": "https://api.github.com/users/recrack/events{/privacy}", "received_events_url": "https://api.github.com/users/recrack/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "841f4ceaf41687f1e59b1e56a7737bc478a88e06", "url": "https://api.github.com/repos/rust-lang/rust/commits/841f4ceaf41687f1e59b1e56a7737bc478a88e06", "html_url": "https://github.com/rust-lang/rust/commit/841f4ceaf41687f1e59b1e56a7737bc478a88e06"}], "stats": {"total": 100, "additions": 49, "deletions": 51}, "files": [{"sha": "6c02ece9289ae495bead05c04fe0a7a860240e29", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -1084,7 +1084,7 @@ fn encode_index<T>(ebml_w: &mut writer::Encoder,\n     for buckets.each |bucket| {\n         bucket_locs.push(ebml_w.writer.tell());\n         ebml_w.start_tag(tag_index_buckets_bucket);\n-        for vec::each(**bucket) |elt| {\n+        for (**bucket).each |elt| {\n             ebml_w.start_tag(tag_index_buckets_bucket_elt);\n             assert!(elt.pos < 0xffff_ffff);\n             writer.write_be_u32(elt.pos as u32);"}, {"sha": "3abe5b22e1a1c2c1fcf0a669e5ed87ac259cdaae", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -17,7 +17,6 @@ use core::hashmap::HashMap;\n use core::io::WriterUtil;\n use core::io;\n use core::uint;\n-use core::vec;\n use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::*;\n@@ -398,7 +397,7 @@ fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n }\n \n fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n-    for vec::each(*bs) |bound| {\n+    for (*bs).each |bound| {\n         match *bound {\n           ty::bound_owned => w.write_char('S'),\n           ty::bound_copy => w.write_char('C'),"}, {"sha": "09232b5bba823d925996b1acb5e0cbf441ba8f55", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -366,7 +366,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n         }\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n-            for vec::each(*variants) |v| {\n+            for (*variants).each |v| {\n                 if !found.contains(&(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }"}, {"sha": "0050e0f81c756570c74b49c803c2b551c8ffbb4d", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -235,7 +235,7 @@ fn check_fn(\n }\n \n fn check_arm(a: &arm, cx: Context, v: visit::vt<Context>) {\n-    for vec::each(a.pats) |p| {\n+    for a.pats.each |p| {\n         do pat_util::pat_bindings(cx.tcx.def_map, *p) |mode, id, span, _pth| {\n             if mode == bind_by_copy {\n                 let t = ty::node_id_to_type(cx.tcx, id);"}, {"sha": "5c3bb6ca401a669dfab5c5569a03ad6a8488cbdd", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -4630,7 +4630,7 @@ pub impl Resolver {\n         }\n \n         let mut smallest = 0;\n-        for vec::eachi(maybes) |i, &other| {\n+        for maybes.eachi |i, &other| {\n \n             values[i] = str::levdistance(name, other);\n \n@@ -4664,7 +4664,7 @@ pub impl Resolver {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n-                      for vec::each(class_def.fields) |field| {\n+                      for class_def.fields.each |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _) => {"}, {"sha": "3a6424efe1d2290b702f4da04468b762f7e18618", "filename": "src/librustc/middle/resolve_stage0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_stage0.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -4681,7 +4681,7 @@ pub impl Resolver {\n         }\n \n         let mut smallest = 0;\n-        for vec::eachi(maybes) |i, &other| {\n+        for maybes.eachi |i, &other| {\n \n             values[i] = str::levdistance(name, other);\n \n@@ -4715,7 +4715,7 @@ pub impl Resolver {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n-                      for vec::each(class_def.fields) |field| {\n+                      for class_def.fields.each |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _) => {"}, {"sha": "1443a7ef304072dac03360095607a0b26e06d21d", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -283,7 +283,7 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n     match ccx.tcx.def_map.get_copy(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(ccx.tcx, enum_id);\n-            for vec::each(*variants) |v| {\n+            for (*variants).each |v| {\n                 if var_id == v.id {\n                     return var(v.disr_val,\n                                adt::represent_node(bcx, pat_id))\n@@ -349,7 +349,7 @@ pub fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n }\n \n pub fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n-    for vec::each(m) |br| {\n+    for m.each |br| {\n         match br.pats[col].node {\n           ast::pat_ident(_, _, Some(_)) => return true,\n           _ => ()\n@@ -418,7 +418,7 @@ pub fn enter_match<'r>(bcx: block,\n     let _indenter = indenter();\n \n     let mut result = ~[];\n-    for vec::each(m) |br| {\n+    for m.each |br| {\n         match e(br.pats[col]) {\n             Some(sub) => {\n                 let pats =\n@@ -934,7 +934,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n                                        col: uint)\n                                     -> ~[ast::ident] {\n     let mut fields: ~[ast::ident] = ~[];\n-    for vec::each(m) |br| {\n+    for m.each |br| {\n         match br.pats[col].node {\n           ast::pat_struct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n@@ -973,7 +973,7 @@ pub fn root_pats_as_necessary(mut bcx: block,\n                               col: uint,\n                               val: ValueRef)\n                            -> block {\n-    for vec::each(m) |br| {\n+    for m.each |br| {\n         let pat_id = br.pats[col].id;\n         if pat_id != 0 {\n             let datum = Datum {val: val, ty: node_id_type(bcx, pat_id),\n@@ -1042,14 +1042,14 @@ pub fn pick_col(m: &[@Match]) -> uint {\n         }\n     }\n     let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n-    for vec::each(m) |br| {\n+    for m.each |br| {\n         let mut i = 0u;\n-        for vec::each(br.pats) |p| { scores[i] += score(*p); i += 1u; }\n+        for br.pats.each |p| { scores[i] += score(*p); i += 1u; }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n     let mut i = 0u;\n-    for vec::each(scores) |score| {\n+    for scores.each |score| {\n         let score = *score;\n \n         // Irrefutable columns always go first, they'd only be duplicated in\n@@ -1306,7 +1306,7 @@ pub fn compile_submatch(bcx: block,\n     let ccx = *bcx.fcx.ccx;\n     let mut pat_id = 0;\n     let mut pat_span = dummy_sp();\n-    for vec::each(m) |br| {\n+    for m.each |br| {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n@@ -1438,7 +1438,7 @@ pub fn compile_submatch(bcx: block,\n             }\n         }\n     }\n-    for vec::each(opts) |o| {\n+    for opts.each |o| {\n         match *o {\n             range(_, _) => { kind = compare; break }\n             _ => ()\n@@ -1460,7 +1460,7 @@ pub fn compile_submatch(bcx: block,\n     let mut i = 0u;\n \n     // Compile subtrees for each option\n-    for vec::each(opts) |opt| {\n+    for opts.each |opt| {\n         i += 1u;\n         let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n@@ -1631,7 +1631,7 @@ pub fn trans_match_inner(scope_cx: block,\n     }\n \n     let mut arm_datas = ~[], matches = ~[];\n-    for vec::each(arms) |arm| {\n+    for arms.each |arm| {\n         let body = scope_block(bcx, arm.body.info(), ~\"case_body\");\n \n         // Create the bindings map, which is a mapping from each binding name\n@@ -1670,7 +1670,7 @@ pub fn trans_match_inner(scope_cx: block,\n                                  arm: arm,\n                                  bindings_map: bindings_map};\n         arm_datas.push(arm_data);\n-        for vec::each(arm.pats) |p| {\n+        for arm.pats.each |p| {\n             matches.push(@Match {pats: ~[*p], data: arm_data});\n         }\n     }\n@@ -1793,7 +1793,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                                                     vinfo.disr_val,\n                                                     val);\n                     for sub_pats.each |sub_pat| {\n-                        for vec::eachi(args.vals) |i, argval| {\n+                        for args.vals.eachi |i, argval| {\n                             bcx = bind_irrefutable_pat(bcx,\n                                                        sub_pat[i],\n                                                        *argval,"}, {"sha": "77a90e22150875b0ec886cb50a7ae9a80e9d46ca", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -668,7 +668,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n-              for vec::eachi(field_tys) |i, field_ty| {\n+              for field_tys.eachi |i, field_ty| {\n                   let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n@@ -709,7 +709,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                         n_variants);\n                   let next_cx = sub_block(cx, ~\"enum-iter-next\");\n \n-                  for vec::each(*variants) |variant| {\n+                  for (*variants).each |variant| {\n                       let variant_cx =\n                           sub_block(cx, ~\"enum-iter-variant-\" +\n                                     int::to_str(variant.disr_val));\n@@ -888,7 +888,7 @@ pub fn need_invoke(bcx: block) -> bool {\n         match cur.kind {\n             block_scope(inf) => {\n                 let inf = &mut *inf; // FIXME(#5074) workaround old borrowck\n-                for vec::each(inf.cleanups) |cleanup| {\n+                for inf.cleanups.each |cleanup| {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n@@ -1391,7 +1391,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<NodeInfo>,\n }\n \n pub fn block_locals(b: &ast::blk, it: &fn(@ast::local)) {\n-    for vec::each(b.node.stmts) |s| {\n+    for b.node.stmts.each |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n             match d.node {\n@@ -1973,7 +1973,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n            repr, ty_to_str(ccx.tcx, enum_ty));\n \n     adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n-    for vec::eachi(args) |i, va| {\n+    for args.eachi |i, va| {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get(),\n@@ -2072,7 +2072,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::node_id, vi: @~[ty::VariantInfo],\n                       i: &mut uint) {\n-    for vec::each(enum_definition.variants) |variant| {\n+    for enum_definition.variants.each |variant| {\n         let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n@@ -2559,7 +2559,7 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n                                                  node: it.id });\n         let mut i = 0;\n         let path = item_path(ccx, it);\n-        for vec::each((*enum_definition).variants) |variant| {\n+        for (*enum_definition).variants.each |variant| {\n             let p = vec::append(/*bad*/copy path, ~[\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)"}, {"sha": "4da2199501f528175f2d6194631f8eee280e519d", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -161,7 +161,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                        cls: &mut [x86_64_reg_class], i: uint,\n                        off: uint) {\n         let mut field_off = off;\n-        for vec::each(tys) |ty| {\n+        for tys.each |ty| {\n             field_off = align(field_off, *ty);\n             classify(*ty, cls, i, field_off);\n             field_off += ty_size(*ty);\n@@ -283,7 +283,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n fn llreg_ty(cls: &[x86_64_reg_class]) -> TypeRef {\n     fn llvec_len(cls: &[x86_64_reg_class]) -> uint {\n         let mut len = 1u;\n-        for vec::each(cls) |c| {\n+        for cls.each |c| {\n             if *c != sseup_class {\n                 break;\n             }\n@@ -370,7 +370,7 @@ fn x86_64_tys(atys: &[TypeRef],\n \n     let mut arg_tys = ~[];\n     let mut attrs = ~[];\n-    for vec::each(atys) |t| {\n+    for atys.each |t| {\n         let (ty, attr) = x86_64_ty(*t, is_pass_byval, ByValAttribute);\n         arg_tys.push(ty);\n         attrs.push(attr);"}, {"sha": "e5e60b2d4ac334d692d55dca307fb25f0148b9b3", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -631,7 +631,7 @@ pub fn trans_args(cx: block,\n     match args {\n       ArgExprs(arg_exprs) => {\n         let last = arg_exprs.len() - 1u;\n-        for vec::eachi(arg_exprs) |i, arg_expr| {\n+        for arg_exprs.eachi |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n                                arg_tys[i],"}, {"sha": "8b72ddda044c7e92928c177fbe2e1b60edce3694", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -34,7 +34,7 @@ pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     do block_locals(b) |local| {\n         bcx = alloc_local(bcx, local);\n     };\n-    for vec::each(b.node.stmts) |s| {\n+    for b.node.stmts.each |s| {\n         debuginfo::update_source_pos(bcx, b.span);\n         bcx = trans_stmt(bcx, *s);\n     }\n@@ -107,7 +107,7 @@ pub fn trans_if(bcx: block,\n pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n     let out = sub_block(parent_bcx, ~\"join\");\n     let mut reachable = false;\n-    for vec::each(in_cxs) |bcx| {\n+    for in_cxs.each |bcx| {\n         if !bcx.unreachable {\n             Br(*bcx, out.llbb);\n             reachable = true;"}, {"sha": "29227b7c95a32a85c032d504d1a660349b7c7831", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -1264,7 +1264,7 @@ fn trans_adt(bcx: block, repr: &adt::Repr, discr: int,\n         }\n     }\n \n-    for vec::each(temp_cleanups) |cleanup| {\n+    for temp_cleanups.each |cleanup| {\n         revoke_clean(bcx, *cleanup);\n     }\n     return bcx;"}, {"sha": "7eea65e458f1ed0a20e87703c834c1ffc6e7af4e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -294,7 +294,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         Some(abi) => abi,\n     };\n \n-    for vec::each(foreign_mod.items) |&foreign_item| {\n+    for foreign_mod.items.each |&foreign_item| {\n         match foreign_item.node {\n             ast::foreign_item_fn(*) => {\n                 let id = foreign_item.id;"}, {"sha": "f20af0409c53c8199df287042187d3eb7c58a066", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -51,7 +51,7 @@ pub fn trans_impl(ccx: @CrateContext, path: path, name: ast::ident,\n \n     if !generics.ty_params.is_empty() { return; }\n     let sub_path = vec::append_one(path, path_name(name));\n-    for vec::each(methods) |method| {\n+    for methods.each |method| {\n         if method.generics.ty_params.len() == 0u {\n             let llfn = get_item_val(ccx, method.id);\n             let path = vec::append_one(/*bad*/copy sub_path,"}, {"sha": "d9bf25bf37786e7ff67d2d129ede101efa11c82f", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -28,7 +28,6 @@ use util::common::indenter;\n use util::ppaux::ty_to_str;\n \n use core::option::None;\n-use core::vec;\n use syntax::ast;\n use syntax::codemap;\n \n@@ -395,7 +394,7 @@ pub fn write_content(bcx: block,\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n                         temp_cleanups.push(lleltptr);\n                     }\n-                    for vec::each(temp_cleanups) |cleanup| {\n+                    for temp_cleanups.each |cleanup| {\n                         revoke_clean(bcx, *cleanup);\n                     }\n                 }"}, {"sha": "f1c3a42d1583e9173bf0e3c34ff3506cb6cd8e18", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -77,7 +77,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n         ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-            for vec::each(sig.inputs) |arg| {\n+            for sig.inputs.each |arg| {\n                 type_needs(cx, use_repr, arg.ty);\n             }\n         }\n@@ -213,7 +213,7 @@ pub fn type_needs_inner(cx: Context,\n                 if list::find(enums_seen, |id| *id == did).is_none() {\n                     let seen = @Cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n-                        for vec::each(v.args) |aty| {\n+                        for v.args.each |aty| {\n                             let t = ty::subst(cx.ccx.tcx, &(*substs), *aty);\n                             type_needs_inner(cx, use_, t, seen);\n                         }"}, {"sha": "2daba3212e1c3c56accbe68b5cd51dd63ffadc28", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -1740,7 +1740,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             true\n           }\n           ty_enum(did, ref substs) => {\n-            for vec::each(*enum_variants(cx, did)) |v| {\n+            for (*enum_variants(cx, did)).each |v| {\n                 for v.args.each |aty| {\n                     let t = subst(cx, substs, *aty);\n                     needs_unwind_cleanup |=\n@@ -2335,7 +2335,7 @@ pub fn type_structurally_contains(cx: ctxt,\n     if test(sty) { return true; }\n     match *sty {\n       ty_enum(did, ref substs) => {\n-        for vec::each(*enum_variants(cx, did)) |variant| {\n+        for (*enum_variants(cx, did)).each |variant| {\n             for variant.args.each |aty| {\n                 let sty = subst(cx, substs, *aty);\n                 if type_structurally_contains(cx, sty, test) { return true; }\n@@ -2431,7 +2431,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n-        for vec::each(*variants) |variant| {\n+        for (*variants).each |variant| {\n             let tup_ty = mk_tup(cx, /*bad*/copy variant.args);\n \n             // Perform any type parameter substitutions."}, {"sha": "2869c3737c9374ae5eb8fd50d816798ead4f0f9e", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -228,7 +228,7 @@ fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n \n     match e.node {\n         ast::expr_fn_block(ref decl, _) => {\n-            for vec::each(decl.inputs) |input| {\n+            for decl.inputs.each |input| {\n                 let _ = resolve_type_vars_for_node(wbcx, e.span, input.id);\n             }\n         }"}, {"sha": "8349e16d2c44047d9efa6d3c4787950ed485b37b", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=c02064d153dccb2d66c5158e0c7eeb6a8bbca0f5", "patch": "@@ -1572,8 +1572,8 @@ pub impl RegionVarBindings {\n             return;\n         }\n \n-        for vec::each(lower_bounds) |lower_bound| {\n-            for vec::each(upper_bounds) |upper_bound| {\n+        for lower_bounds.each |lower_bound| {\n+            for upper_bounds.each |upper_bound| {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n \n@@ -1629,8 +1629,8 @@ pub impl RegionVarBindings {\n             return;\n         }\n \n-        for vec::each(upper_bounds) |upper_bound_1| {\n-            for vec::each(upper_bounds) |upper_bound_2| {\n+        for upper_bounds.each |upper_bound_1| {\n+            for upper_bounds.each |upper_bound_2| {\n                 match self.glb_concrete_regions(upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}"}]}