{"sha": "4f1dcb34dffc26a23fa8c2cac69a31d7557fd173", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMWRjYjM0ZGZmYzI2YTIzZmE4YzJjYWM2OWEzMWQ3NTU3ZmQxNzM=", "commit": {"author": {"name": "Michal 'vorner' Vaner", "email": "vorner@vorner.cz", "date": "2019-05-19T10:46:37Z"}, "committer": {"name": "Michal 'vorner' Vaner", "email": "vorner@vorner.cz", "date": "2019-05-26T06:53:59Z"}, "message": "rc::Weak::{as,from,into}_raw\n\nMethods on the Weak to access it as a raw pointer to the data.", "tree": {"sha": "3c854f8eec017f40f98704c984b8e9cb223dd1d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c854f8eec017f40f98704c984b8e9cb223dd1d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEQ8wy/3jh6tM0kr/e9wDQwBnkxm8FAlzqOAcACgkQ9wDQwBnk\nxm+ypQ//Tqrubz3wvt4LI1zOPxd3XnskZ4SffmB8kRK9IKQtPCv9nfG3Bb3XyCc4\nomNEcxj2GxuCqUpz6LgVwkpOrkPvEWWsEfuP6oXurKXCfBGj7wWEEzb02PsBSDTx\nN9MAeNyzzbsxGRk9BXozr1N+Ro1047EqVVbOxDepg6Zg3gfF4rXhw+1p3AQ7iw3l\n8r3VFTXGnU0LADq2a4duX5TnaEvx78+nEejcnMmnIXUR89NT8D4OTh6L2JlGBJ0+\n+f62ImbMTd4fX8IsW4k/atu7MfrDNInj5x/v8BTaWObt6jqZGhODwOjCDnJtBSrL\n8JDJGUuPruXGzuxJF50ntAiiMtZKfTZIe4FxmpC6uhiJg47FekO3gx5Kfmfxvgdl\n0+QRiIkILCUcz0VmBqRxJqQ+YBwyHAjGvnSdKdGRwKT25WX/+IbGiqavP8P18Xyl\n/KhrfDcQNwKqY62pyY1ZawaSmxksYfCDa9arysCuUQQlrZWe1Pi4v7UIk1ztyPIg\nfX1A+wJ+NjU3eJEX2kBG0rI+e8HosOG53XMVGTQCOqFMiGWa1yVBxOovNabvYRmQ\nQTLikty96J1ZauC+r43x2+J8jF/PvA9WBf5c0P+qy1O7GzjpZCToWu3pbf1NV5Ly\nNuvEEQoa1y7uNaZw62fLAqIPob4/mG2oe6sVAiR7XXKh2q3Wn/I=\n=JdAW\n-----END PGP SIGNATURE-----", "payload": "tree 3c854f8eec017f40f98704c984b8e9cb223dd1d0\nparent f9d328d7ffa17ab78eaa62a2976033a7176886d9\nauthor Michal 'vorner' Vaner <vorner@vorner.cz> 1558262797 +0200\ncommitter Michal 'vorner' Vaner <vorner@vorner.cz> 1558853639 +0200\n\nrc::Weak::{as,from,into}_raw\n\nMethods on the Weak to access it as a raw pointer to the data.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173", "html_url": "https://github.com/rust-lang/rust/commit/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173/comments", "author": {"login": "vorner", "id": 11783500, "node_id": "MDQ6VXNlcjExNzgzNTAw", "avatar_url": "https://avatars.githubusercontent.com/u/11783500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vorner", "html_url": "https://github.com/vorner", "followers_url": "https://api.github.com/users/vorner/followers", "following_url": "https://api.github.com/users/vorner/following{/other_user}", "gists_url": "https://api.github.com/users/vorner/gists{/gist_id}", "starred_url": "https://api.github.com/users/vorner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vorner/subscriptions", "organizations_url": "https://api.github.com/users/vorner/orgs", "repos_url": "https://api.github.com/users/vorner/repos", "events_url": "https://api.github.com/users/vorner/events{/privacy}", "received_events_url": "https://api.github.com/users/vorner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vorner", "id": 11783500, "node_id": "MDQ6VXNlcjExNzgzNTAw", "avatar_url": "https://avatars.githubusercontent.com/u/11783500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vorner", "html_url": "https://github.com/vorner", "followers_url": "https://api.github.com/users/vorner/followers", "following_url": "https://api.github.com/users/vorner/following{/other_user}", "gists_url": "https://api.github.com/users/vorner/gists{/gist_id}", "starred_url": "https://api.github.com/users/vorner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vorner/subscriptions", "organizations_url": "https://api.github.com/users/vorner/orgs", "repos_url": "https://api.github.com/users/vorner/repos", "events_url": "https://api.github.com/users/vorner/events{/privacy}", "received_events_url": "https://api.github.com/users/vorner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9d328d7ffa17ab78eaa62a2976033a7176886d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d328d7ffa17ab78eaa62a2976033a7176886d9", "html_url": "https://github.com/rust-lang/rust/commit/f9d328d7ffa17ab78eaa62a2976033a7176886d9"}], "stats": {"total": 162, "additions": 156, "deletions": 6}, "files": [{"sha": "1f357a719bb43880725e51309349591dd1777156", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 156, "deletions": 6, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4f1dcb34dffc26a23fa8c2cac69a31d7557fd173", "patch": "@@ -239,7 +239,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker::{self, Unpin, Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -416,11 +416,7 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the RcBox.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<RcBox<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n@@ -1262,6 +1258,143 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const RcBox<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Rc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Rc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Rc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Rc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Rc`]: struct.Rc.html\n+    /// [`Weak`]: struct.Weak.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Rc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut RcBox<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n@@ -2007,3 +2140,20 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> { }\n+\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the RcBox.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}]}