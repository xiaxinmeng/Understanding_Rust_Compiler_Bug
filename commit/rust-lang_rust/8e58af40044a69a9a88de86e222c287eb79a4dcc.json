{"sha": "8e58af40044a69a9a88de86e222c287eb79a4dcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNThhZjQwMDQ0YTY5YTlhODhkZTg2ZTIyMmMyODdlYjc5YTRkY2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-22T01:15:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-23T20:55:45Z"}, "message": "Fallout in stdlib, rustdoc, rustc, etc. For most maps, converted uses of\n`[]` on maps to `get` in rustc, since stage0 and stage1+ disagree about\nhow to use `[]`.", "tree": {"sha": "f9d5247df0659d045afc7b98da401a2b969a91cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9d5247df0659d045afc7b98da401a2b969a91cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e58af40044a69a9a88de86e222c287eb79a4dcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e58af40044a69a9a88de86e222c287eb79a4dcc", "html_url": "https://github.com/rust-lang/rust/commit/8e58af40044a69a9a88de86e222c287eb79a4dcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e58af40044a69a9a88de86e222c287eb79a4dcc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a", "html_url": "https://github.com/rust-lang/rust/commit/b4d4daf007753dfb04d87b1ffe1c2ad2d8811d5a"}], "stats": {"total": 404, "additions": 245, "deletions": 159}, "files": [{"sha": "755f564621a0f7dd8c467958ca6331e8038a6883", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -264,7 +264,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n-    /// assert_eq!(map[1], \"b\");\n+    /// assert_eq!(map[&1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -326,7 +326,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// map.insert(37, \"b\");\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n+    /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {"}, {"sha": "5b8a5f029762ee418411afc00e736150ff14d171", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1522,6 +1522,7 @@ macro_rules! node_slice_impl {\n             }\n \n             /// Returns a sub-slice with elements starting with `min_key`.\n+            #[cfg(stage0)]\n             pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1549,7 +1550,37 @@ macro_rules! node_slice_impl {\n                 }\n             }\n \n+            /// Returns a sub-slice with elements starting with `min_key`.\n+            #[cfg(not(stage0))]\n+            pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                // \\___|___|___|___/  slice_from(&0); pos = 0\n+                //     \\___|___|___/  slice_from(&2); pos = 1\n+                //     |___|___|___/  slice_from(&3); pos = 1; result.head_is_edge = false\n+                //         \\___|___/  slice_from(&4); pos = 2\n+                //             \\___/  slice_from(&6); pos = 3\n+                //                \\|/ slice_from(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(min_key);\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$index(pos ..)\n+                    },\n+                    keys: &self.keys[pos ..],\n+                    vals: self.vals.$index(pos ..),\n+                    head_is_edge: !pos_is_kv,\n+                    tail_is_edge: self.tail_is_edge,\n+                }\n+            }\n+\n             /// Returns a sub-slice with elements up to and including `max_key`.\n+            #[cfg(stage0)]\n             pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1577,6 +1608,36 @@ macro_rules! node_slice_impl {\n                     tail_is_edge: !pos_is_kv,\n                 }\n             }\n+\n+            /// Returns a sub-slice with elements up to and including `max_key`.\n+            #[cfg(not(stage0))]\n+            pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                //\\|/  |   |   |   |  slice_to(&0); pos = 0\n+                // \\___/   |   |   |  slice_to(&2); pos = 1\n+                // \\___|___|   |   |  slice_to(&3); pos = 1; result.tail_is_edge = false\n+                // \\___|___/   |   |  slice_to(&4); pos = 2\n+                // \\___|___|___/   |  slice_to(&6); pos = 3\n+                // \\___|___|___|___/  slice_to(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(max_key);\n+                let pos = pos + if pos_is_kv { 1 } else { 0 };\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$index(.. (pos + 1))\n+                    },\n+                    keys: &self.keys[..pos],\n+                    vals: self.vals.$index(.. pos),\n+                    head_is_edge: self.head_is_edge,\n+                    tail_is_edge: !pos_is_kv,\n+                }\n+            }\n         }\n \n         impl<'a, K: 'a, V: 'a> $NodeSlice<'a, K, V> {"}, {"sha": "2499853ace1e3b5daec09f0a0e34a620450691d9", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -111,7 +111,7 @@ impl CStore {\n     }\n \n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n-        (*self.metas.borrow())[cnum].clone()\n+        self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {"}, {"sha": "fa8d0b2a56e4ee34b8e062ed0bac19948f730897", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -375,7 +375,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in &**implementations {\n-                for &method_did in &*(*impl_items)[*base_impl_did] {\n+                for &method_did in impl_items.get(base_impl_did).unwrap() {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n@@ -1175,7 +1175,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n-        let items = &(*impl_items)[def_id];\n+        let items = impl_items.get(&def_id).unwrap();\n \n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n@@ -1816,7 +1816,7 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if let ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let def_id = self.ecx.tcx.def_map.borrow()[trait_ref.ref_id].def_id();\n+            let def_id = self.ecx.tcx.def_map.borrow().get(&trait_ref.ref_id).unwrap().def_id();\n \n             // Load eagerly if this is an implementation of the Drop trait\n             // or if the trait is not defined in this crate."}, {"sha": "801350e8a1e9c1d50d29d9f28d66f9c7add566ad", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1228,7 +1228,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     var_id: var_id,\n                     closure_expr_id: id\n                 };\n-                let upvar_capture = tcx.upvar_capture_map.borrow()[upvar_id].clone();\n+                let upvar_capture = tcx.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone();\n                 var_id.encode(rbml_w);\n                 upvar_capture.encode(rbml_w);\n             })"}, {"sha": "97cd9456098b1bbab4fb5b8947975d9d46af1399", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -874,7 +874,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -892,7 +892,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n \n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let class_id = match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\"}, {"sha": "f9598237ff460805cc0494475f97820ff385fb3d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -150,7 +150,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n         ast::ExprCall(ref callee, ref args) => {\n-            let def = tcx.def_map.borrow()[callee.id];\n+            let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }"}, {"sha": "6d4d759476ed5330edde04b58b498f294dc99498", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n                                   pats: &[codemap::Spanned<ast::FieldPat>]) {\n-        let id = match self.tcx.def_map.borrow()[lhs.id].full_def() {\n+        let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n                 match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n@@ -496,7 +496,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in &**impl_list {\n-                    for item_did in &(*impl_items)[*impl_did] {\n+                    for item_did in &*impl_items.get(impl_did).unwrap() {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {\n                             return true;"}, {"sha": "5d970c59f639bd5e3b4a289a7419ce7ddb52dfd0", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = (*self.tcx.method_map.borrow())[method_call].ty;\n+                let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "97314b57ef656802a6b773495566051c7a27978c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1012,7 +1012,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = def_map.borrow()[pat.id].full_def();\n+                let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, Init);"}, {"sha": "553e3601806677ed1bc37f4ba22ddc4a9fbe7a3e", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1533,7 +1533,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.borrow()[edge.data].clone()\n+                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone()\n                         });\n                     }\n                 }"}, {"sha": "705f20559afde27711c2c0934f7aba5c68aa5df0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -448,7 +448,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ast::ExprPath(..) => {\n-        let def = ir.tcx.def_map.borrow()[expr.id].full_def();\n+        let def = ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -1302,7 +1302,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n+        match self.ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n@@ -1564,7 +1564,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             ast::ExprPath(..) => {\n-                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n+                if let DefLocal(nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n+                                                                   .unwrap()\n+                                                                   .full_def() {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "bdcfc67f92b997a370cad0693f2eab1f729c626f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -531,7 +531,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(..) => {\n-            let def = self.tcx().def_map.borrow()[expr.id].full_def();\n+            let def = self.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n "}, {"sha": "1bd45b5fc86017cd5a8afea2c994c2e181397d9e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match (*self.tcx.method_map.borrow())[method_call].origin {\n+                match (*self.tcx.method_map.borrow()).get(&method_call).unwrap().origin {\n                     ty::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "d12b737619c8db4d1086a2dab3422f346ff8bb39", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -319,7 +319,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n         ast::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n-            let trait_did = tcx.def_map.borrow()[t.ref_id].def_id();\n+            let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n             let trait_items = ty::trait_items(tcx, trait_did);\n \n             for impl_item in impl_items {"}, {"sha": "a9504910ac162e798d4609d8d327bdafb7e2f0a0", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -854,10 +854,10 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     let impl_items_map = selcx.tcx().impl_items.borrow();\n     let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n \n-    let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+    let impl_items = impl_items_map.get(&impl_vtable.impl_def_id).unwrap();\n     let mut impl_ty = None;\n     for impl_item in impl_items {\n-        let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+        let assoc_type = match *impl_or_trait_items_map.get(&impl_item.def_id()).unwrap() {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n             ty::MethodTraitItem(..) => { continue; }\n         };"}, {"sha": "5088b733c4abb60f807d698d0a947ed4aae0eb34", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -2667,22 +2667,22 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        self.closure_kinds.borrow()[def_id]\n+        *self.closure_kinds.borrow().get(&def_id).unwrap()\n     }\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n                         substs: &subst::Substs<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.closure_tys.borrow()[def_id].subst(self, substs)\n+        self.closure_tys.borrow().get(&def_id).unwrap().subst(self, substs)\n     }\n \n     pub fn type_parameter_def(&self,\n                               node_id: ast::NodeId)\n                               -> TypeParameterDef<'tcx>\n     {\n-        self.ty_param_defs.borrow()[node_id].clone()\n+        self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n }\n \n@@ -6540,7 +6540,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.upvar_capture_map.borrow()[upvar_id].clone())\n+        Some(self.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n }\n "}, {"sha": "2834fce5278c85ab7b3caf36f3de0a47425e6a30", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -486,7 +486,7 @@ impl<'tcx> MoveData<'tcx> {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n-                    let path = self.path_map.borrow()[path.loan_path];\n+                    let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n                     self.kill_moves(path, kill_scope.node_id(), dfcx_moves);\n                 }\n                 LpExtend(..) => {}"}, {"sha": "f788a02adc4c03b9426cfb05775b3add3e141d50", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -418,7 +418,7 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow()[id].full_def() {\n+        match self.cx.tcx.def_map.borrow().get(&id).unwrap().full_def() {\n             def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `isize` in foreign module, while \\"}, {"sha": "2e7fe91365a13475dabf5e99106be2e2b82421dd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(..) => {\n-                        match self.tcx.def_map.borrow()[ty.id].full_def() {\n+                        match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n@@ -317,7 +317,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             ast::ItemTy(ref ty, _) if public_first => {\n                 if let ast::TyPath(..) = ty.node {\n-                    match self.tcx.def_map.borrow()[ty.id].full_def() {\n+                    match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n@@ -349,7 +349,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n-            for export in &self.export_map[id] {\n+            for export in self.export_map.get(&id).unwrap() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // if we've reached the root, then everything was allowable and this\n             // access is public.\n             if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = self.parents[closest_private_id];\n+            closest_private_id = *self.parents.get(&closest_private_id).unwrap();\n \n             // If we reached the top, then we were public all the way down and\n             // we can allow this access.\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = self.parents[id];\n+        let parent = *self.parents.get(&id).unwrap();\n         debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n \n         // After finding `did`'s closest private member, we roll ourselves back\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 _ => {}\n             }\n \n-            cur = self.parents[cur];\n+            cur = *self.parents.get(&cur).unwrap();\n         }\n     }\n \n@@ -622,7 +622,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             ast::TyPath(..) => {}\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n-                        let def = self.tcx.def_map.borrow()[ty.id].full_def();\n+                        let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n                         let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Ident) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let path_res = self.tcx.def_map.borrow()[path_id];\n+        let path_res = *self.tcx.def_map.borrow().get(&path_id).unwrap();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n@@ -881,7 +881,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow()[expr.id].full_def() {\n+                        match self.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields {\n                                     self.check_field(expr.span, variant_id,"}, {"sha": "679f1ce79b28c7165bcfbeaf156af8aeefff6084", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1141,9 +1141,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // involves just passing the right -l flag.\n \n     let data = if dylib {\n-        &trans.crate_formats[config::CrateTypeDylib]\n+        trans.crate_formats.get(&config::CrateTypeDylib).unwrap()\n     } else {\n-        &trans.crate_formats[config::CrateTypeExecutable]\n+        trans.crate_formats.get(&config::CrateTypeExecutable).unwrap()\n     };\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of"}, {"sha": "6a55d6d4adfe3df53e1c625a62c8ad8f6f3f27df", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -219,7 +219,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id));\n         }\n-        let def = self.analysis.ty_cx.def_map.borrow()[ref_id].full_def();\n+        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -232,7 +232,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id));\n         }\n-        let def = def_map[ref_id].full_def();\n+        let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n@@ -269,8 +269,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.collecting = false;\n             let span_utils = self.span.clone();\n             for &(id, ref p, _, _) in &self.collected_paths {\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[id]);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types.borrow().get(&id).unwrap());\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -431,8 +433,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"{}::{}\", qualname, name);\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[field.node.id]);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types.borrow().get(&field.node.id).unwrap());\n                 match self.span.sub_span_before_token(field.span, token::Colon) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -789,7 +793,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span,\n                                &format!(\"def_map has no key for {} in visit_expr\", id));\n         }\n-        let def = def_map[id].full_def();\n+        let def = def_map.get(&id).unwrap().full_def();\n         let sub_span = self.span.span_for_last_ident(span);\n         match def {\n             def::DefUpvar(..) |\n@@ -832,7 +836,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                  .ty_cx\n                                                  .impl_items\n                                                  .borrow();\n-                            Some((*impl_items)[def_id]\n+                            Some(impl_items.get(&def_id)\n+                                           .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n                                                 ty::impl_or_trait_item(\n@@ -941,7 +946,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n-        let method_callee = &(*method_map)[ty::MethodCall::expr(ex.id)];\n+        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |\n             ty::MethodStaticClosure(def_id) => {\n@@ -1001,7 +1006,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n                 visit::walk_path(self, path);\n \n-                let def = self.analysis.ty_cx.def_map.borrow()[p.id].full_def();\n+                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n                     def::DefConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n@@ -1113,7 +1118,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n-                            for n in &glob_map[item.id] {\n+                            for n in glob_map.get(&item.id).unwrap() {\n                                 if name_string.len() > 0 {\n                                     name_string.push_str(\", \");\n                                 }\n@@ -1406,7 +1411,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n                                            id));\n             }\n-            let def = def_map[id].full_def();\n+            let def = def_map.get(&id).unwrap().full_def();\n             match def {\n                 def::DefLocal(id)  => {\n                     let value = if *immut {\n@@ -1467,7 +1472,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         for &(id, ref p, ref immut, _) in &self.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id]);\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "eb759393ac6eca125f2432641e792c9d37575c2d", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1017,7 +1017,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => {\n             let data = &m[0].data;\n             for &(ref ident, ref value_ptr) in &m[0].bound_ptrs {\n-                let binfo = data.bindings_map[*ident];\n+                let binfo = *data.bindings_map.get(ident).unwrap();\n                 call_lifetime_start(bcx, binfo.llmatch);\n                 if binfo.trmode == TrByRef && type_is_fat_ptr(bcx.tcx(), binfo.ty) {\n                     expr::copy_fat_ptr(bcx, *value_ptr, binfo.llmatch);"}, {"sha": "bdc810bd837469918a752e552a03062b3b3b405e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -269,7 +269,7 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n-    ccx.tcx().closure_kinds.borrow()[closure_id]\n+    *ccx.tcx().closure_kinds.borrow().get(&closure_id).unwrap()\n }\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2322,7 +2322,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.static_values().borrow()[item.id].clone();\n+              let v = ccx.static_values().borrow().get(&item.id).unwrap().clone();\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");"}, {"sha": "088a34857e753a8991be403b55d93da17de960b4", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -511,7 +511,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             let ref_ty = match node {\n                 ExprId(id) => ty::node_id_to_type(tcx, id),\n                 MethodCallKey(method_call) => {\n-                    (*tcx.method_map.borrow())[method_call].ty\n+                    tcx.method_map.borrow().get(&method_call).unwrap().ty\n                 }\n             };\n             let ref_ty = monomorphize::apply_param_substs(tcx,"}, {"sha": "8754d50597bd0c977180f6b0dab3f83e5d50e8a5", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -709,7 +709,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.tcx().upvar_capture_map.borrow()[upvar_id].clone())\n+        Some(self.tcx().upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n@@ -1213,7 +1213,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ty::node_id_item_substs(tcx, id).substs\n         }\n         MethodCallKey(method_call) => {\n-            (*tcx.method_map.borrow())[method_call].substs.clone()\n+            tcx.method_map.borrow().get(&method_call).unwrap().substs.clone()\n         }\n     };\n "}, {"sha": "f0947cd4712426247e409b432e9e07576260ac41", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -187,7 +187,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Special-case constants to cache a common global for all uses.\n     match expr.node {\n         ast::ExprPath(..) => {\n-            let def = ccx.tcx().def_map.borrow()[expr.id].full_def();\n+            let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n                 def::DefConst(def_id) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n@@ -665,7 +665,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprPath(..) => {\n-            let def = cx.tcx().def_map.borrow()[e.id].full_def();\n+            let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -751,7 +751,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.static_values().borrow()[id].clone();\n+        let v = ccx.static_values().borrow().get(&id).unwrap().clone();\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {"}, {"sha": "28ac7da3cfce8e8a21b3a0f558ec22576b63762a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -126,7 +126,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return datum.store_to_dest(bcx, dest, expr.id);\n     }\n \n-    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n     if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n         if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n@@ -209,7 +209,7 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n-    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n     let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n     let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n         let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n@@ -1405,7 +1405,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    let def = tcx.def_map.borrow()[node_id].full_def();\n+                    let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(tcx, enum_id, variant_id);\n@@ -1961,7 +1961,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<Dest>,\n                                    autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n+    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).unwrap().ty;\n     callee::trans_call_inner(bcx,\n                              expr.debug_loc(),\n                              monomorphize_type(bcx, method_ty),\n@@ -1982,10 +1982,12 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                          dest: Option<Dest>)\n                                          -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n-    let method_type = (*bcx.tcx()\n-                           .method_map\n-                           .borrow())[method_call]\n-                           .ty;\n+    let method_type = bcx.tcx()\n+                         .method_map\n+                         .borrow()\n+                         .get(&method_call)\n+                         .unwrap()\n+                         .ty;\n     let mut all_args = vec!(callee);\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,"}, {"sha": "71900855266e9f4e7fc1b411d13cd65909460e11", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1046,7 +1046,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return (tcx.types.err, ty_path_def);\n     };\n \n-    let ty_param_name = tcx.ty_param_defs.borrow()[ty_param_node_id].name;\n+    let ty_param_name = tcx.ty_param_defs.borrow().get(&ty_param_node_id).unwrap().name;\n \n     let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n         Ok(v) => v,"}, {"sha": "e71386a9b42b1838ad57120b20b653cfb04337f3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -119,7 +119,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-            let const_did = tcx.def_map.borrow()[pat.id].def_id();\n+            let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n             let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n@@ -163,7 +163,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = pcx.map[path.node];\n+            let canon_id = *pcx.map.get(&path.node).unwrap();\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n                 demand::eqtype(fcx, pat.span, ct, typ);\n@@ -449,7 +449,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].full_def();\n+    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let (enum_def_id, variant_def_id) = match def {\n         def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n@@ -518,7 +518,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].full_def();\n+    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n "}, {"sha": "f319adac1a16e60ecaedbe15126171e8b569e557", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>\n     {\n-        self.inh.closure_tys.borrow()[def_id].subst(self.tcx(), substs)\n+        self.inh.closure_tys.borrow().get(&def_id).unwrap().subst(self.tcx(), substs)\n     }\n \n     fn closure_upvars(&self,\n@@ -549,7 +549,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         debug!(\"Local variable {} is assigned type {}\",\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n-                   self.fcx.inh.locals.borrow()[local.id].clone()));\n+                   self.fcx.inh.locals.borrow().get(&local.id).unwrap().clone()));\n         visit::walk_local(self, local);\n     }\n \n@@ -565,7 +565,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 debug!(\"Pattern binding {} is assigned to {} with type {}\",\n                        token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_string(\n-                           self.fcx.inh.locals.borrow()[p.id].clone()),\n+                           self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n                        var_ty.repr(self.fcx.tcx()));\n             }\n         }\n@@ -3327,7 +3327,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let mut missing_fields = Vec::new();\n                 for class_field in field_types {\n                     let name = class_field.name;\n-                    let (_, seen) = class_field_map[name];\n+                    let (_, seen) = *class_field_map.get(&name).unwrap();\n                     if !seen {\n                         missing_fields.push(\n                             format!(\"`{}`\", &token::get_name(name)))\n@@ -4428,7 +4428,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = (*fcx.ccx.tcx.tcache.borrow())[local_def(id)].ty;\n+    let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n "}, {"sha": "340cca7d47e7a395619bb5ae60ce9d1724e800a6", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -448,7 +448,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         let closure_def_id = ast_util::local_def(closure_id);\n         let mut closure_kinds = self.fcx.inh.closure_kinds.borrow_mut();\n-        let existing_kind = closure_kinds[closure_def_id];\n+        let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n \n         debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n                closure_id, existing_kind, new_kind);"}, {"sha": "ffd99ff2eece081f7390195ea24506fe83ebb302", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> TypeScheme<'tcx> {\n-        self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n+        self.crate_context.tcx.tcache.borrow().get(&impl_did).unwrap().clone()\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n@@ -387,7 +387,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         };\n \n         for &impl_did in &*trait_impls.borrow() {\n-            let items = &(*impl_items)[impl_did];\n+            let items = impl_items.get(&impl_did).unwrap();\n             if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;"}, {"sha": "6be45b26751de55af22bffe8bbb9a478802fb950", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -194,7 +194,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n     fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n         let def_id = local_def(method_id);\n-        match self.tcx.impl_or_trait_items.borrow()[def_id] {\n+        match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n             ty::TypeTraitItem(..) => {\n                 self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n@@ -545,7 +545,7 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   -> bool\n {\n     if let ast::TyPath(None, _) = ast_ty.node {\n-        let path_res = tcx.def_map.borrow()[ast_ty.id];\n+        let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n         match path_res.base_def {\n             def::DefSelfTy(node_id) =>\n                 path_res.depth == 0 && node_id == param_id,\n@@ -1040,9 +1040,13 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n-                let inputs: Vec<_> = struct_def.fields.iter().map(\n-                        |field| (*tcx.tcache.borrow())[\n-                            local_def(field.node.id)].ty).collect();\n+                let inputs: Vec<_> =\n+                    struct_def.fields\n+                              .iter()\n+                              .map(|field| tcx.tcache.borrow().get(&local_def(field.node.id))\n+                                                              .unwrap()\n+                                                              .ty)\n+                              .collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n                                                 &inputs[..],"}, {"sha": "4d15abb91dc148f5044498eae7a42de4ded5e3d9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -290,7 +290,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n             if ast_util::is_local(did) || cache.inlined.contains(&did) {\n                 Some(repeat(\"../\").take(loc.len()).collect::<String>())\n             } else {\n-                match cache.extern_locations[did.krate] {\n+                match cache.extern_locations[&did.krate] {\n                     render::Remote(ref s) => Some(s.to_string()),\n                     render::Local => {\n                         Some(repeat(\"../\").take(loc.len()).collect::<String>())\n@@ -404,11 +404,11 @@ fn primitive_link(f: &mut fmt::Formatter,\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n-            let path = &m.paths[ast::DefId {\n+            let path = &m.paths[&ast::DefId {\n                 krate: cnum,\n                 node: ast::CRATE_NODE_ID,\n             }];\n-            let loc = match m.extern_locations[cnum] {\n+            let loc = match m.extern_locations[&cnum] {\n                 render::Remote(ref s) => Some(s.to_string()),\n                 render::Local => {\n                     let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());"}, {"sha": "5ceb0238aa081b05397c06e8cb86f13b783d9907", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -1404,8 +1404,8 @@ impl<'a> Item<'a> {\n         // located, then we return `None`.\n         } else {\n             let cache = cache();\n-            let path = &cache.external_paths[self.item.def_id];\n-            let root = match cache.extern_locations[self.item.def_id.krate] {\n+            let path = &cache.external_paths[&self.item.def_id];\n+            let root = match cache.extern_locations[&self.item.def_id.krate] {\n                 Remote(ref s) => s.to_string(),\n                 Local => self.cx.root_path.clone(),\n                 Unknown => return None,\n@@ -1863,7 +1863,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n-                    let path = &cache.external_paths[it.def_id];\n+                    let path = &cache.external_paths[&it.def_id];\n                     path[..path.len() - 1].connect(\"/\")\n                 },\n                 ty = shortty(it).to_static_str(),"}, {"sha": "11e10cc2aa7a16cf004fdb8933d7e47283df978d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = tcx.def_map.borrow()[id].def_id();\n+        let def = tcx.def_map.borrow()[&id].def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}, {"sha": "b2fd8a8e6164f5e21e9367f7b6d710e7efc6877e", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -745,7 +745,7 @@ mod dynamic_tests {\n         thread_local!(static FOO: RefCell<HashMap<i32, i32>> = map());\n \n         FOO.with(|map| {\n-            assert_eq!(map.borrow()[1], 2);\n+            assert_eq!(map.borrow()[&1], 2);\n         });\n     }\n "}, {"sha": "2fe77bf7a5411cbff2ed0c49a6acfeb769e32491", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n                                                   *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            names[self.name_positions[*name]] =\n+            names[*self.name_positions.get(name).unwrap()] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));"}, {"sha": "5940b791843797cacf97c7225dd9a413e27d74c8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -236,7 +236,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n                                      argument_gram);\n \n     // Extract the arguments:\n-    let lhses = match *argument_map[lhs_nm] {\n+    let lhses = match **argument_map.get(&lhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n@@ -245,7 +245,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         check_lhs_nt_follows(cx, &**lhs, def.span);\n     }\n \n-    let rhses = match *argument_map[rhs_nm] {\n+    let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };"}, {"sha": "604a3e69a21767909233a369c61149385b64a07a", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -19,6 +19,6 @@ pub type header_map = HashMap<String, Rc<RefCell<Vec<Rc<String>>>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let data = req[\"METHOD\".to_string()].clone();\n+  let data = req[&\"METHOD\".to_string()].clone();\n   let _x = data.borrow().clone()[0].clone();\n }"}, {"sha": "18db50a831ca8d5b840168b96550869729573054", "filename": "src/test/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -33,7 +33,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n \n     let mac_expr = match TokenTree::parse(cx, &mbe_matcher[..], args) {\n         Success(map) => {\n-            match (&*map[str_to_ident(\"matched\")], &*map[str_to_ident(\"pat\")]) {\n+            match (&*map[&str_to_ident(\"matched\")], &*map[&str_to_ident(\"pat\")]) {\n                 (&MatchedNonterminal(NtExpr(ref matched_expr)),\n                  &MatchedSeq(ref pats, seq_sp)) => {\n                     let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt|"}, {"sha": "bee56c9bf390bb17092d20dc86324435decad8e7", "filename": "src/test/compile-fail/borrowck-overloaded-index-and-overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -19,7 +19,7 @@ struct MyVec<T> { x: T }\n \n impl<T> Index<usize> for MyVec<T> {\n     type Output = T;\n-    fn index(&self, _: &usize) -> &T {\n+    fn index(&self, _: usize) -> &T {\n         &self.x\n     }\n }"}, {"sha": "55a6e2ac7b8d6755f8bd2bcac6da1e07105a5d8e", "filename": "src/test/compile-fail/borrowck-overloaded-index-autoderef.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -18,6 +18,7 @@ struct Foo {\n     y: isize,\n }\n \n+#[cfg(stage0)]\n impl Index<String> for Foo {\n     type Output = isize;\n \n@@ -30,8 +31,20 @@ impl Index<String> for Foo {\n     }\n }\n \n-impl IndexMut<String> for Foo {\n-    fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut isize {\n+impl<'a> Index<&'a String> for Foo {\n+    type Output = isize;\n+\n+    fn index(&self, z: &String) -> &isize {\n+        if *z == \"x\" {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl<'a> IndexMut<&'a String> for Foo {\n+    fn index_mut(&mut self, z: &String) -> &mut isize {\n         if *z == \"x\" {\n             &mut self.x\n         } else {\n@@ -41,51 +54,51 @@ impl IndexMut<String> for Foo {\n }\n \n fn test1(mut f: Box<Foo>, s: String) {\n-    let _p = &mut f[s];\n-    let _q = &f[s]; //~ ERROR cannot borrow\n+    let _p = &mut f[&s];\n+    let _q = &f[&s]; //~ ERROR cannot borrow\n }\n \n fn test2(mut f: Box<Foo>, s: String) {\n-    let _p = &mut f[s];\n-    let _q = &mut f[s]; //~ ERROR cannot borrow\n+    let _p = &mut f[&s];\n+    let _q = &mut f[&s]; //~ ERROR cannot borrow\n }\n \n struct Bar {\n     foo: Foo\n }\n \n fn test3(mut f: Box<Bar>, s: String) {\n-    let _p = &mut f.foo[s];\n-    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+    let _p = &mut f.foo[&s];\n+    let _q = &mut f.foo[&s]; //~ ERROR cannot borrow\n }\n \n fn test4(mut f: Box<Bar>, s: String) {\n-    let _p = &f.foo[s];\n-    let _q = &f.foo[s];\n+    let _p = &f.foo[&s];\n+    let _q = &f.foo[&s];\n }\n \n fn test5(mut f: Box<Bar>, s: String) {\n-    let _p = &f.foo[s];\n-    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+    let _p = &f.foo[&s];\n+    let _q = &mut f.foo[&s]; //~ ERROR cannot borrow\n }\n \n fn test6(mut f: Box<Bar>, g: Foo, s: String) {\n-    let _p = &f.foo[s];\n+    let _p = &f.foo[&s];\n     f.foo = g; //~ ERROR cannot assign\n }\n \n fn test7(mut f: Box<Bar>, g: Bar, s: String) {\n-    let _p = &f.foo[s];\n+    let _p = &f.foo[&s];\n     *f = g; //~ ERROR cannot assign\n }\n \n fn test8(mut f: Box<Bar>, g: Foo, s: String) {\n-    let _p = &mut f.foo[s];\n+    let _p = &mut f.foo[&s];\n     f.foo = g; //~ ERROR cannot assign\n }\n \n fn test9(mut f: Box<Bar>, g: Bar, s: String) {\n-    let _p = &mut f.foo[s];\n+    let _p = &mut f.foo[&s];\n     *f = g; //~ ERROR cannot assign\n }\n "}, {"sha": "021ef7343cbb4432f028f51e030967d23a98db43", "filename": "src/test/compile-fail/dst-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-index.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -20,7 +20,7 @@ struct S;\n impl Index<usize> for S {\n     type Output = str;\n \n-    fn index<'a>(&'a self, _: &usize) -> &'a str {\n+    fn index(&self, _: usize) -> &str {\n         \"hello\"\n     }\n }\n@@ -31,7 +31,7 @@ struct T;\n impl Index<usize> for T {\n     type Output = Debug + 'static;\n \n-    fn index<'a>(&'a self, idx: &usize) -> &'a (Debug + 'static) {\n+    fn index<'a>(&'a self, idx: usize) -> &'a (Debug + 'static) {\n         static x: usize = 42;\n         &x\n     }"}, {"sha": "9539486118b812efd53a8c98368ab85b7528ef9d", "filename": "src/test/run-pass/dst-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-index.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -19,7 +19,7 @@ struct S;\n impl Index<uint> for S {\n     type Output = str;\n \n-    fn index<'a>(&'a self, _: &uint) -> &'a str {\n+    fn index<'a>(&'a self, _: uint) -> &'a str {\n         \"hello\"\n     }\n }\n@@ -29,7 +29,7 @@ struct T;\n impl Index<uint> for T {\n     type Output = Debug + 'static;\n \n-    fn index<'a>(&'a self, idx: &uint) -> &'a (Debug + 'static) {\n+    fn index<'a>(&'a self, idx: uint) -> &'a (Debug + 'static) {\n         static X: uint = 42;\n         &X as &(Debug + 'static)\n     }"}, {"sha": "76a5b6488b5a300a69265155008c56d9905b5365", "filename": "src/test/run-pass/issue-15734.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15734.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -29,15 +29,15 @@ impl<T> Mat<T> {\n impl<T> Index<(uint, uint)> for Mat<T> {\n     type Output = T;\n \n-    fn index<'a>(&'a self, &(row, col): &(uint, uint)) -> &'a T {\n+    fn index<'a>(&'a self, (row, col): (uint, uint)) -> &'a T {\n         &self.data[row * self.cols + col]\n     }\n }\n \n impl<'a, T> Index<(uint, uint)> for &'a Mat<T> {\n     type Output = T;\n \n-    fn index<'b>(&'b self, index: &(uint, uint)) -> &'b T {\n+    fn index<'b>(&'b self, index: (uint, uint)) -> &'b T {\n         (*self).index(index)\n     }\n }\n@@ -47,16 +47,16 @@ struct Row<M> { mat: M, row: uint, }\n impl<T, M: Index<(uint, uint), Output=T>> Index<uint> for Row<M> {\n     type Output = T;\n \n-    fn index<'a>(&'a self, col: &uint) -> &'a T {\n-        &self.mat[(self.row, *col)]\n+    fn index<'a>(&'a self, col: uint) -> &'a T {\n+        &self.mat[(self.row, col)]\n     }\n }\n \n fn main() {\n     let m = Mat::new(vec!(1, 2, 3, 4, 5, 6), 3);\n     let r = m.row(1);\n \n-    assert!(r.index(&2) == &6);\n+    assert!(r.index(2) == &6);\n     assert!(r[2] == 6);\n     assert!(r[2] == 6);\n     assert!(6 == r[2]);"}, {"sha": "b04ae0edbed87b20f791ca3bb893652e94c9e250", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -16,7 +16,7 @@ extern crate collections;\n use std::collections::HashMap;\n \n fn add_interfaces(managed_ip: String, device: HashMap<String, int>)  {\n-     println!(\"{}, {}\", managed_ip, device[\"interfaces\".to_string()]);\n+     println!(\"{}, {}\", managed_ip, device[\"interfaces\"]);\n }\n \n pub fn main() {}"}, {"sha": "619bd08141fb62259766fb2d856cfbe96ef340d3", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -56,8 +56,7 @@ fn add_interface(_store: int, managed_ip: String, data: json::Json) -> (String,\n \n fn add_interfaces(store: int, managed_ip: String, device: HashMap<String, json::Json>)\n -> Vec<(String, object)> {\n-    match device[\"interfaces\".to_string()]\n-    {\n+    match device[\"interfaces\"] {\n         Json::Array(ref interfaces) =>\n         {\n           interfaces.iter().map(|interface| {\n@@ -67,7 +66,7 @@ fn add_interfaces(store: int, managed_ip: String, device: HashMap<String, json::\n         _ =>\n         {\n             println!(\"Expected list for {} interfaces, found {}\", managed_ip,\n-                   device[\"interfaces\".to_string()]);\n+                     device[\"interfaces\"]);\n             Vec::new()\n         }\n     }"}, {"sha": "7016e28f2ee022800ad3831037e59df33bb6b4df", "filename": "src/test/run-pass/issue-5521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-5521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-5521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5521.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -17,7 +17,7 @@ fn bar(a: foo::map) {\n     if false {\n         panic!();\n     } else {\n-        let _b = &(*a)[2];\n+        let _b = &(*a)[&2];\n     }\n }\n "}, {"sha": "78318e083ba404a09b5de94293eb0b0591bd95d3", "filename": "src/test/run-pass/issue-7660.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7660.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -21,6 +21,6 @@ pub fn main() {\n     let mut m: HashMap<int, A> = HashMap::new();\n     m.insert(1, A(0, 0));\n \n-    let A(ref _a, ref _b) = m[1];\n-    let (a, b) = match m[1] { A(ref _a, ref _b) => (_a, _b) };\n+    let A(ref _a, ref _b) = m[&1];\n+    let (a, b) = match m[&1] { A(ref _a, ref _b) => (_a, _b) };\n }"}, {"sha": "801e71b3038622f504f7c3c738d9eb5798f84c4b", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -52,8 +52,8 @@ impl ops::Not for Point {\n impl ops::Index<bool> for Point {\n     type Output = int;\n \n-    fn index(&self, x: &bool) -> &int {\n-        if *x {\n+    fn index(&self, x: bool) -> &int {\n+        if x {\n             &self.x\n         } else {\n             &self.y"}, {"sha": "b5c9962fe9c3f4d37ef9ff1c9c9483f41904a89d", "filename": "src/test/run-pass/overloaded-index-assoc-list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -28,7 +28,7 @@ impl<K,V> AssociationList<K,V> {\n     }\n }\n \n-impl<K: PartialEq + std::fmt::Debug, V:Clone> Index<K> for AssociationList<K,V> {\n+impl<'a, K: PartialEq + std::fmt::Debug, V:Clone> Index<&'a K> for AssociationList<K,V> {\n     type Output = V;\n \n     fn index<'a>(&'a self, index: &K) -> &'a V {\n@@ -49,9 +49,9 @@ pub fn main() {\n     list.push(foo.clone(), 22);\n     list.push(bar.clone(), 44);\n \n-    assert!(list[foo] == 22);\n-    assert!(list[bar] == 44);\n+    assert!(list[&foo] == 22);\n+    assert!(list[&bar] == 44);\n \n-    assert!(list[foo] == 22);\n-    assert!(list[bar] == 44);\n+    assert!(list[&foo] == 22);\n+    assert!(list[&bar] == 44);\n }"}, {"sha": "107f0fbc20904b8e4b0fe18d744b5b2040441350", "filename": "src/test/run-pass/overloaded-index-autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -23,8 +23,8 @@ struct Foo {\n impl Index<int> for Foo {\n     type Output = int;\n \n-    fn index(&self, z: &int) -> &int {\n-        if *z == 0 {\n+    fn index(&self, z: int) -> &int {\n+        if z == 0 {\n             &self.x\n         } else {\n             &self.y\n@@ -33,8 +33,8 @@ impl Index<int> for Foo {\n }\n \n impl IndexMut<int> for Foo {\n-    fn index_mut(&mut self, z: &int) -> &mut int {\n-        if *z == 0 {\n+    fn index_mut(&mut self, z: int) -> &mut int {\n+        if z == 0 {\n             &mut self.x\n         } else {\n             &mut self.y"}, {"sha": "f01e5541c423b11d2034a77f9bbe557533ffe6e5", "filename": "src/test/run-pass/overloaded-index-in-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -25,8 +25,8 @@ struct Bar {\n impl Index<int> for Foo {\n     type Output = int;\n \n-    fn index(&self, z: &int) -> &int {\n-        if *z == 0 {\n+    fn index(&self, z: int) -> &int {\n+        if z == 0 {\n             &self.x\n         } else {\n             &self.y"}, {"sha": "60e0ed9bfdd0f6298b56c26864542da9cd4ecf26", "filename": "src/test/run-pass/overloaded-index.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -18,8 +18,8 @@ struct Foo {\n impl Index<int> for Foo {\n     type Output = int;\n \n-    fn index(&self, z: &int) -> &int {\n-        if *z == 0 {\n+    fn index(&self, z: int) -> &int {\n+        if z == 0 {\n             &self.x\n         } else {\n             &self.y\n@@ -28,8 +28,8 @@ impl Index<int> for Foo {\n }\n \n impl IndexMut<int> for Foo {\n-    fn index_mut(&mut self, z: &int) -> &mut int {\n-        if *z == 0 {\n+    fn index_mut(&mut self, z: int) -> &mut int {\n+        if z == 0 {\n             &mut self.x\n         } else {\n             &mut self.y"}, {"sha": "ee9bb80356164504e1dcee563bbc0478316f863c", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e58af40044a69a9a88de86e222c287eb79a4dcc/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=8e58af40044a69a9a88de86e222c287eb79a4dcc", "patch": "@@ -21,53 +21,53 @@ struct Foo;\n \n impl Index<Range<Foo>> for Foo {\n     type Output = Foo;\n-    fn index(&self, index: &Range<Foo>) -> &Foo {\n+    fn index(&self, index: Range<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl Index<RangeTo<Foo>> for Foo {\n     type Output = Foo;\n-    fn index(&self, index: &RangeTo<Foo>) -> &Foo {\n+    fn index(&self, index: RangeTo<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl Index<RangeFrom<Foo>> for Foo {\n     type Output = Foo;\n-    fn index(&self, index: &RangeFrom<Foo>) -> &Foo {\n+    fn index(&self, index: RangeFrom<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl Index<RangeFull> for Foo {\n     type Output = Foo;\n-    fn index(&self, _index: &RangeFull) -> &Foo {\n+    fn index(&self, _index: RangeFull) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n \n impl IndexMut<Range<Foo>> for Foo {\n-    fn index_mut(&mut self, index: &Range<Foo>) -> &mut Foo {\n+    fn index_mut(&mut self, index: Range<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl IndexMut<RangeTo<Foo>> for Foo {\n-    fn index_mut(&mut self, index: &RangeTo<Foo>) -> &mut Foo {\n+    fn index_mut(&mut self, index: RangeTo<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl IndexMut<RangeFrom<Foo>> for Foo {\n-    fn index_mut(&mut self, index: &RangeFrom<Foo>) -> &mut Foo {\n+    fn index_mut(&mut self, index: RangeFrom<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl IndexMut<RangeFull> for Foo {\n-    fn index_mut(&mut self, _index: &RangeFull) -> &mut Foo {\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }"}]}