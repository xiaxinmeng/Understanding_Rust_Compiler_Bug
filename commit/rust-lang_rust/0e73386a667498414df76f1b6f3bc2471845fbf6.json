{"sha": "0e73386a667498414df76f1b6f3bc2471845fbf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNzMzODZhNjY3NDk4NDE0ZGY3NmYxYjZmM2JjMjQ3MTg0NWZiZjY=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-06-12T12:39:12Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-07-19T21:37:48Z"}, "message": "Use sharded maps for interning", "tree": {"sha": "922cc5d73f9a79a36643c3d388faea4de72fb2f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/922cc5d73f9a79a36643c3d388faea4de72fb2f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e73386a667498414df76f1b6f3bc2471845fbf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e73386a667498414df76f1b6f3bc2471845fbf6", "html_url": "https://github.com/rust-lang/rust/commit/0e73386a667498414df76f1b6f3bc2471845fbf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e73386a667498414df76f1b6f3bc2471845fbf6/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01", "html_url": "https://github.com/rust-lang/rust/commit/e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01"}], "stats": {"total": 226, "additions": 149, "deletions": 77}, "files": [{"sha": "f1550b9d756a528fb52a729964f09da82164e796", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0e73386a667498414df76f1b6f3bc2471845fbf6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e73386a667498414df76f1b6f3bc2471845fbf6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0e73386a667498414df76f1b6f3bc2471845fbf6", "patch": "@@ -46,14 +46,14 @@ use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use errors::DiagnosticBuilder;\n-use rustc_data_structures::interner::HashInterner;\n use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::SyncDroplessArena;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n+use rustc_data_structures::sharded::ShardedHashMap;\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -88,7 +88,7 @@ impl AllArenas {\n     }\n }\n \n-type InternedSet<'tcx, T> = Lock<FxHashMap<Interned<'tcx, T>, ()>>;\n+type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc are allocated from\n@@ -135,7 +135,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     fn intern_ty(&self,\n         st: TyKind<'tcx>\n     ) -> Ty<'tcx> {\n-        self.type_.borrow_mut().intern(st, |st| {\n+        self.type_.intern(st, |st| {\n             let flags = super::flags::FlagComputation::for_sty(&st);\n \n             let ty_struct = TyS {\n@@ -924,7 +924,7 @@ impl<'tcx> CommonTypes<'tcx> {\n impl<'tcx> CommonLifetimes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonLifetimes<'tcx> {\n         let mk = |r| {\n-            interners.region.borrow_mut().intern(r, |r| {\n+            interners.region.intern(r, |r| {\n                 Interned(interners.arena.alloc(r))\n             }).0\n         };\n@@ -940,7 +940,7 @@ impl<'tcx> CommonLifetimes<'tcx> {\n impl<'tcx> CommonConsts<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>, types: &CommonTypes<'tcx>) -> CommonConsts<'tcx> {\n         let mk_const = |c| {\n-            interners.const_.borrow_mut().intern(c, |c| {\n+            interners.const_.intern(c, |c| {\n                 Interned(interners.arena.alloc(c))\n             }).0\n         };\n@@ -1053,14 +1053,14 @@ pub struct GlobalCtxt<'tcx> {\n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n \n-    stability_interner: Lock<FxHashMap<&'tcx attr::Stability, ()>>,\n+    stability_interner: ShardedHashMap<&'tcx attr::Stability, ()>,\n \n     /// Stores the value of constants (and deduplicates the actual memory)\n-    allocation_interner: Lock<FxHashMap<&'tcx Allocation, ()>>,\n+    allocation_interner: ShardedHashMap<&'tcx Allocation, ()>,\n \n     pub alloc_map: Lock<interpret::AllocMap<'tcx>>,\n \n-    layout_interner: Lock<FxHashMap<&'tcx LayoutDetails, ()>>,\n+    layout_interner: ShardedHashMap<&'tcx LayoutDetails, ()>,\n \n     /// A general purpose channel to throw data out the back towards LLVM worker\n     /// threads.\n@@ -1103,7 +1103,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_const_alloc(self, alloc: Allocation) -> &'tcx Allocation {\n-        self.allocation_interner.borrow_mut().intern(alloc, |alloc| {\n+        self.allocation_interner.intern(alloc, |alloc| {\n             self.arena.alloc(alloc)\n         })\n     }\n@@ -1117,13 +1117,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n-        self.stability_interner.borrow_mut().intern(stab, |stab| {\n+        self.stability_interner.intern(stab, |stab| {\n             self.arena.alloc(stab)\n         })\n     }\n \n     pub fn intern_layout(self, layout: LayoutDetails) -> &'tcx LayoutDetails {\n-        self.layout_interner.borrow_mut().intern(layout, |layout| {\n+        self.layout_interner.intern(layout, |layout| {\n             self.arena.alloc(layout)\n         })\n     }\n@@ -2023,7 +2023,9 @@ macro_rules! sty_debug_print {\n                 };\n                 $(let mut $variant = total;)*\n \n-                for &Interned(t) in tcx.interners.type_.borrow().keys() {\n+                let shards = tcx.interners.type_.lock_shards();\n+                let types = shards.iter().flat_map(|shard| shard.keys());\n+                for &Interned(t) in types {\n                     let variant = match t.sty {\n                         ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n                             ty::Float(..) | ty::Str | ty::Never => continue,\n@@ -2074,11 +2076,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             Generator, GeneratorWitness, Dynamic, Closure, Tuple, Bound,\n             Param, Infer, UnnormalizedProjection, Projection, Opaque, Foreign);\n \n-        println!(\"InternalSubsts interner: #{}\", self.interners.substs.borrow().len());\n-        println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n-        println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n-        println!(\"Allocation interner: #{}\", self.allocation_interner.borrow().len());\n-        println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n+        println!(\"InternalSubsts interner: #{}\", self.interners.substs.len());\n+        println!(\"Region interner: #{}\", self.interners.region.len());\n+        println!(\"Stability interner: #{}\", self.stability_interner.len());\n+        println!(\"Allocation interner: #{}\", self.allocation_interner.len());\n+        println!(\"Layout interner: #{}\", self.layout_interner.len());\n     }\n }\n \n@@ -2207,7 +2209,7 @@ macro_rules! intern_method {\n             pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n                 let key = ($alloc_to_key)(&v);\n \n-                self.interners.$name.borrow_mut().intern_ref(key, || {\n+                self.interners.$name.intern_ref(key, || {\n                     Interned($alloc_method(&self.interners.arena, v))\n \n                 }).0"}, {"sha": "36ccbb704a733bc255bbda36b521e4ec0a742e41", "filename": "src/librustc_data_structures/interner.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01/src%2Flibrustc_data_structures%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01/src%2Flibrustc_data_structures%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Finterner.rs?ref=e3cebcb3bd4ffaf86bb0cdfd2af5b7e698717b01", "patch": "@@ -1,58 +0,0 @@\n-use std::hash::Hash;\n-use std::hash::BuildHasher;\n-use std::hash::Hasher;\n-use std::collections::HashMap;\n-use std::collections::hash_map::RawEntryMut;\n-use std::borrow::Borrow;\n-\n-pub trait HashInterner<K: Eq + Hash> {\n-    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq;\n-\n-    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq;\n-}\n-\n-impl<K: Eq + Hash + Copy, S: BuildHasher> HashInterner<K> for HashMap<K, (), S> {\n-    #[inline]\n-    fn intern_ref<Q: ?Sized, F: FnOnce() -> K>(&mut self, value: &Q, make: F) -> K\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n-    {\n-        let mut hasher = self.hasher().build_hasher();\n-        value.hash(&mut hasher);\n-        let hash = hasher.finish();\n-        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, value);\n-\n-        match entry {\n-            RawEntryMut::Occupied(e) => *e.key(),\n-            RawEntryMut::Vacant(e) => {\n-                let v = make();\n-                e.insert_hashed_nocheck(hash, v, ());\n-                v\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn intern<Q, F: FnOnce(Q) -> K>(&mut self, value: Q, make: F) -> K\n-        where K: Borrow<Q>,\n-              Q: Hash + Eq\n-    {\n-        let mut hasher = self.hasher().build_hasher();\n-        value.hash(&mut hasher);\n-        let hash = hasher.finish();\n-        let entry = self.raw_entry_mut().from_key_hashed_nocheck(hash, &value);\n-\n-        match entry {\n-            RawEntryMut::Occupied(e) => *e.key(),\n-            RawEntryMut::Vacant(e) => {\n-                let v = make(value);\n-                e.insert_hashed_nocheck(hash, v, ());\n-                v\n-            }\n-        }\n-    }\n-}"}, {"sha": "a2407681e6d3f6f90c7babf9111ee8a7d06cb07a", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e73386a667498414df76f1b6f3bc2471845fbf6/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e73386a667498414df76f1b6f3bc2471845fbf6/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=0e73386a667498414df76f1b6f3bc2471845fbf6", "patch": "@@ -77,7 +77,6 @@ pub mod flock;\n pub mod fx;\n pub mod graph;\n pub mod indexed_vec;\n-pub mod interner;\n pub mod jobserver;\n pub mod obligation_forest;\n pub mod owning_ref;\n@@ -89,6 +88,7 @@ pub use ena::snapshot_vec;\n pub mod sorted_map;\n #[macro_use] pub mod stable_hasher;\n pub mod sync;\n+pub mod sharded;\n pub mod tiny_list;\n pub mod thin_vec;\n pub mod transitive_relation;"}, {"sha": "31cb22098b8e93b905fe23f07e287e9c3abdf3ca", "filename": "src/librustc_data_structures/sharded.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0e73386a667498414df76f1b6f3bc2471845fbf6/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e73386a667498414df76f1b6f3bc2471845fbf6/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=0e73386a667498414df76f1b6f3bc2471845fbf6", "patch": "@@ -0,0 +1,128 @@\n+use std::hash::{Hasher, Hash};\n+use std::mem;\n+use std::borrow::Borrow;\n+use std::collections::hash_map::RawEntryMut;\n+use crate::fx::{FxHasher, FxHashMap};\n+use crate::sync::{Lock, LockGuard};\n+\n+#[derive(Clone, Default)]\n+#[cfg_attr(parallel_compiler, repr(align(64)))]\n+struct CacheAligned<T>(T);\n+\n+#[cfg(parallel_compiler)]\n+// 32 shards is sufficient to reduce contention on an 8-core Ryzen 7 1700,\n+// but this should be tested on higher core count CPUs. How the `Sharded` type gets used\n+// may also affect the ideal nunber of shards.\n+const SHARD_BITS: usize = 5;\n+\n+#[cfg(not(parallel_compiler))]\n+const SHARD_BITS: usize = 0;\n+\n+const SHARDS: usize = 1 << SHARD_BITS;\n+\n+/// An array of cache-line aligned inner locked structures with convenience methods.\n+#[derive(Clone)]\n+pub struct Sharded<T> {\n+    shards: [CacheAligned<Lock<T>>; SHARDS],\n+}\n+\n+impl<T: Default> Default for Sharded<T> {\n+    #[inline]\n+    fn default() -> Self {\n+        let mut shards: mem::MaybeUninit<[CacheAligned<Lock<T>>; SHARDS]> =\n+            mem::MaybeUninit::uninit();\n+        let first = shards.as_mut_ptr() as *mut CacheAligned<Lock<T>>;\n+        unsafe {\n+            for i in 0..SHARDS {\n+                first.add(i).write(CacheAligned(Lock::new(T::default())));\n+            }\n+            Sharded {\n+                shards: shards.assume_init(),\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> Sharded<T> {\n+    #[inline]\n+    pub fn get_shard_by_value<K: Hash + ?Sized>(&self, val: &K) -> &Lock<T> {\n+        if SHARDS == 1 {\n+            &self.shards[0].0\n+        } else {\n+            self.get_shard_by_hash(make_hash(val))\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get_shard_by_hash(&self, hash: u64) -> &Lock<T> {\n+        let hash_len = mem::size_of::<usize>();\n+        // Ignore the top 7 bits as hashbrown uses these and get the next SHARD_BITS highest bits.\n+        // hashbrown also uses the lowest bits, so we can't use those\n+        let bits = (hash >> (hash_len * 8 - 7 - SHARD_BITS)) as usize;\n+        let i = bits % SHARDS;\n+        &self.shards[i].0\n+    }\n+\n+    pub fn lock_shards(&self) -> Vec<LockGuard<'_, T>> {\n+        (0..SHARDS).map(|i| self.shards[i].0.lock()).collect()\n+    }\n+\n+    pub fn try_lock_shards(&self) -> Option<Vec<LockGuard<'_, T>>> {\n+        (0..SHARDS).map(|i| self.shards[i].0.try_lock()).collect()\n+    }\n+}\n+\n+pub type ShardedHashMap<K, V> = Sharded<FxHashMap<K, V>>;\n+\n+impl<K: Eq + Hash, V> ShardedHashMap<K, V> {\n+    pub fn len(&self) -> usize {\n+        self.lock_shards().iter().map(|shard| shard.len()).sum()\n+    }\n+}\n+\n+impl<K: Eq + Hash + Copy> ShardedHashMap<K, ()> {\n+    #[inline]\n+    pub fn intern_ref<Q: ?Sized>(&self, value: &Q, make: impl FnOnce() -> K) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let hash = make_hash(value);\n+        let mut shard = self.get_shard_by_hash(hash).lock();\n+        let entry = shard.raw_entry_mut().from_key_hashed_nocheck(hash, value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make();\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn intern<Q>(&self, value: Q, make: impl FnOnce(Q) -> K) -> K\n+        where K: Borrow<Q>,\n+              Q: Hash + Eq\n+    {\n+        let hash = make_hash(&value);\n+        let mut shard = self.get_shard_by_hash(hash).lock();\n+        let entry = shard.raw_entry_mut().from_key_hashed_nocheck(hash, &value);\n+\n+        match entry {\n+            RawEntryMut::Occupied(e) => *e.key(),\n+            RawEntryMut::Vacant(e) => {\n+                let v = make(value);\n+                e.insert_hashed_nocheck(hash, v, ());\n+                v\n+            }\n+        }\n+    }\n+}\n+\n+#[inline]\n+fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n+    let mut state = FxHasher::default();\n+    val.hash(&mut state);\n+    state.finish()\n+}"}]}