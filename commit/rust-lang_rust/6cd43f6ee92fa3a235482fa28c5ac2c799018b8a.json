{"sha": "6cd43f6ee92fa3a235482fa28c5ac2c799018b8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZDQzZjZlZTkyZmEzYTIzNTQ4MmZhMjhjNWFjMmM3OTkwMThiOGE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T01:46:18Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T08:09:24Z"}, "message": "Rename `source` -> `name` in `finalize_import`.", "tree": {"sha": "33324da89c592ec42b7f6c2a4eff2d0bfb80cbb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33324da89c592ec42b7f6c2a4eff2d0bfb80cbb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a", "html_url": "https://github.com/rust-lang/rust/commit/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11c38fdce08d3fa38cb9a6a585215ce8957da3a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c38fdce08d3fa38cb9a6a585215ce8957da3a9", "html_url": "https://github.com/rust-lang/rust/commit/11c38fdce08d3fa38cb9a6a585215ce8957da3a9"}], "stats": {"total": 41, "additions": 20, "deletions": 21}, "files": [{"sha": "04702d02555e1daec11fc70bfa830674cf22a2ef", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd43f6ee92fa3a235482fa28c5ac2c799018b8a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=6cd43f6ee92fa3a235482fa28c5ac2c799018b8a", "patch": "@@ -571,7 +571,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             Failed(err) => return Failed(err),\n         };\n \n-        let (source, value_result, type_result) = match directive.subclass {\n+        let (name, value_result, type_result) = match directive.subclass {\n             SingleImport { source, ref value_result, ref type_result, .. } =>\n                 (source, value_result.get(), type_result.get()),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n@@ -584,34 +584,34 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n             if let Ok(binding) = result {\n-                self.record_use(source, ns, binding);\n+                self.record_use(name, ns, binding);\n             }\n         }\n \n         if value_result.is_err() && type_result.is_err() {\n             let (value_result, type_result);\n-            value_result = self.resolve_name_in_module(module, source, ValueNS, false, Some(span));\n-            type_result = self.resolve_name_in_module(module, source, TypeNS, false, Some(span));\n+            value_result = self.resolve_name_in_module(module, name, ValueNS, false, Some(span));\n+            type_result = self.resolve_name_in_module(module, name, TypeNS, false, Some(span));\n \n             return if let (Failed(_), Failed(_)) = (value_result, type_result) {\n                 let resolutions = module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref name, _), resolution)| {\n-                    if *name == source { return None; } // Never suggest the same name\n+                let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n+                    if *n == name { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n-                        NameResolution { binding: Some(_), .. } => Some(name),\n+                        NameResolution { binding: Some(_), .. } => Some(n),\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n-                        _ => Some(name),\n+                        _ => Some(n),\n                     }\n                 });\n-                let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n+                let lev_suggestion = match find_best_match_for_name(names, &name.as_str(), None) {\n                     Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                     None => \"\".to_owned(),\n                 };\n                 let module_str = module_to_string(module);\n                 let msg = if &module_str == \"???\" {\n-                    format!(\"There is no `{}` in the crate root{}\", source, lev_suggestion)\n+                    format!(\"There is no `{}` in the crate root{}\", name, lev_suggestion)\n                 } else {\n-                    format!(\"There is no `{}` in `{}`{}\", source, module_str, lev_suggestion)\n+                    format!(\"There is no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n                 };\n                 Failed(Some((directive.span, msg)))\n             } else {\n@@ -623,9 +623,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         match (value_result, type_result) {\n             (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n-                let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n-                                        source);\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let note_msg =\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n                 struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n@@ -635,15 +635,14 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n-                                       source);\n+                                       name);\n                     self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n                 } else {\n-                    let mut err = struct_span_err!(self.session, directive.span, E0365,\n-                                                     \"`{}` is private, and cannot be reexported\",\n-                                                     source);\n-                    err.span_label(directive.span, &format!(\"reexport of private `{}`\", source));\n-                    err.note(&format!(\"consider declaring type or module `{}` with `pub`\", source));\n-                    err.emit();\n+                    struct_span_err!(self.session, directive.span, E0365,\n+                                     \"`{}` is private, and cannot be reexported\", name)\n+                        .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n+                        .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                        .emit();\n                 }\n             }\n "}]}