{"sha": "944723b7731ec1eacdbc1946009bcd51d17a6301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NDcyM2I3NzMxZWMxZWFjZGJjMTk0NjAwOWJjZDUxZDE3YTYzMDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-28T23:21:10Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-04T15:14:44Z"}, "message": "process cycles as soon as they are detected\n\nWe used to wait for the recursion limit, but that might well be too\nlong!", "tree": {"sha": "6a5e97c79c0bdbef93a496a711d3484bc7527e84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a5e97c79c0bdbef93a496a711d3484bc7527e84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/944723b7731ec1eacdbc1946009bcd51d17a6301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/944723b7731ec1eacdbc1946009bcd51d17a6301", "html_url": "https://github.com/rust-lang/rust/commit/944723b7731ec1eacdbc1946009bcd51d17a6301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/944723b7731ec1eacdbc1946009bcd51d17a6301/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f92ce2e9fe56942e0fd6a18d0e11bc4a9bdf8ddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f92ce2e9fe56942e0fd6a18d0e11bc4a9bdf8ddd", "html_url": "https://github.com/rust-lang/rust/commit/f92ce2e9fe56942e0fd6a18d0e11bc4a9bdf8ddd"}], "stats": {"total": 316, "additions": 187, "deletions": 129}, "files": [{"sha": "6f3cc49daf2a62017dc60c56414ceea17608ef31", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 162, "deletions": 124, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/944723b7731ec1eacdbc1946009bcd51d17a6301/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944723b7731ec1eacdbc1946009bcd51d17a6301/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=944723b7731ec1eacdbc1946009bcd51d17a6301", "patch": "@@ -320,103 +320,172 @@ impl<'tcx> FulfillmentContext<'tcx> {\n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              mut backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                               -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n                                         FulfillmentErrorCode<'tcx>>\n {\n-    match process_predicate1(selcx, pending_obligation, backtrace.clone(), region_obligations) {\n-        Ok(Some(v)) => {\n-            // FIXME(#30977) The code below is designed to detect (and\n-            // permit) DAGs, while still ensuring that the reasoning\n-            // is acyclic. However, it does a few things\n-            // suboptimally. For example, it refreshes type variables\n-            // a lot, probably more than needed, but also less than\n-            // you might want.\n-            //\n-            //   - more than needed: I want to be very sure we don't\n-            //     accidentally treat a cycle as a DAG, so I am\n-            //     refreshing type variables as we walk the ancestors;\n-            //     but we are going to repeat this a lot, which is\n-            //     sort of silly, and it would be nicer to refresh\n-            //     them *in place* so that later predicate processing\n-            //     can benefit from the same work;\n-            //   - less than you might want: we only add items in the cache here,\n-            //     but maybe we learn more about type variables and could add them into\n-            //     the cache later on.\n-\n-            let tcx = selcx.tcx();\n-\n-            // Compute a little FnvHashSet for the ancestors. We only\n-            // do this the first time that we care.\n-            let mut cache = None;\n-            let mut is_ancestor = |predicate: &ty::Predicate<'tcx>| {\n-                if cache.is_none() {\n-                    let mut c = FnvHashSet();\n-                    for ancestor in backtrace.by_ref() {\n-                        // Ugh. This just feels ridiculously\n-                        // inefficient.  But we need to compare\n-                        // predicates without being concerned about\n-                        // the vagaries of type inference, so for now\n-                        // just ensure that they are always\n-                        // up-to-date. (I suppose we could just use a\n-                        // snapshot and check if they are unifiable?)\n-                        let resolved_predicate =\n-                            selcx.infcx().resolve_type_vars_if_possible(\n-                                &ancestor.obligation.predicate);\n-                        c.insert(resolved_predicate);\n-                    }\n-                    cache = Some(c);\n+    match process_predicate1(selcx, pending_obligation, region_obligations) {\n+        Ok(Some(v)) => process_child_obligations(selcx,\n+                                                 tree_cache,\n+                                                 &pending_obligation.obligation,\n+                                                 backtrace,\n+                                                 v),\n+        Ok(None) => Ok(None),\n+        Err(e) => Err(e)\n+    }\n+}\n+\n+fn process_child_obligations<'a,'tcx>(\n+    selcx: &mut SelectionContext<'a,'tcx>,\n+    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n+    pending_obligation: &PredicateObligation<'tcx>,\n+    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+    child_obligations: Vec<PredicateObligation<'tcx>>)\n+    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n+              FulfillmentErrorCode<'tcx>>\n+{\n+    // FIXME(#30977) The code below is designed to detect (and\n+    // permit) DAGs, while still ensuring that the reasoning\n+    // is acyclic. However, it does a few things\n+    // suboptimally. For example, it refreshes type variables\n+    // a lot, probably more than needed, but also less than\n+    // you might want.\n+    //\n+    //   - more than needed: I want to be very sure we don't\n+    //     accidentally treat a cycle as a DAG, so I am\n+    //     refreshing type variables as we walk the ancestors;\n+    //     but we are going to repeat this a lot, which is\n+    //     sort of silly, and it would be nicer to refresh\n+    //     them *in place* so that later predicate processing\n+    //     can benefit from the same work;\n+    //   - less than you might want: we only add items in the cache here,\n+    //     but maybe we learn more about type variables and could add them into\n+    //     the cache later on.\n+\n+    let tcx = selcx.tcx();\n+\n+    let mut ancestor_set = AncestorSet::new(&backtrace);\n+\n+    let pending_predicate_obligations: Vec<_> =\n+        child_obligations\n+        .into_iter()\n+        .filter_map(|obligation| {\n+            // Probably silly, but remove any inference\n+            // variables. This is actually crucial to the ancestor\n+            // check marked (*) below, but it's not clear that it\n+            // makes sense to ALWAYS do it.\n+            let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n+\n+            // Screen out obligations that we know globally\n+            // are true.\n+            if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n+                return None;\n+            }\n+\n+            // Check whether this obligation appears\n+            // somewhere else in the tree. If not, we have to\n+            // process it for sure.\n+            if !tree_cache.is_duplicate_or_add(&obligation.predicate) {\n+                return Some(PendingPredicateObligation {\n+                    obligation: obligation,\n+                    stalled_on: vec![]\n+                });\n+            }\n+\n+            debug!(\"process_child_obligations: duplicate={:?}\",\n+                   obligation.predicate);\n+\n+            // OK, the obligation appears elsewhere in the tree.\n+            // This is either a fatal error or else something we can\n+            // ignore. If the obligation appears in our *ancestors*\n+            // (rather than some more distant relative), that\n+            // indicates a cycle. Cycles are either considered\n+            // resolved (if this is a coinductive case) or a fatal\n+            // error.\n+            if let Some(index) = ancestor_set.has(selcx.infcx(), &obligation.predicate) {\n+                //                            ~~~ (*) see above\n+                debug!(\"process_child_obligations: cycle index = {}\", index);\n+\n+                if coinductive_match(selcx, &obligation, &backtrace) {\n+                    debug!(\"process_child_obligations: coinductive match\");\n+                    None\n+                } else {\n+                    let backtrace = backtrace.clone();\n+                    let cycle: Vec<_> =\n+                        iter::once(&obligation)\n+                        .chain(Some(pending_obligation))\n+                        .chain(backtrace.take(index + 1).map(|p| &p.obligation))\n+                        .cloned()\n+                        .collect();\n+                    report_overflow_error_cycle(selcx.infcx(), &cycle);\n                 }\n+            } else {\n+                // Not a cycle. Just ignore this obligation then,\n+                // we're already in the process of proving it.\n+                debug!(\"process_child_obligations: not a cycle\");\n+                None\n+            }\n+        })\n+        .collect();\n \n-                cache.as_ref().unwrap().contains(predicate)\n-            };\n+    Ok(Some(pending_predicate_obligations))\n+}\n+\n+struct AncestorSet<'b, 'tcx: 'b> {\n+    populated: bool,\n+    cache: FnvHashMap<ty::Predicate<'tcx>, usize>,\n+    backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n+}\n \n-            let pending_predicate_obligations: Vec<_> =\n-                v.into_iter()\n-                 .filter_map(|obligation| {\n-                     // Probably silly, but remove any inference\n-                     // variables. This is actually crucial to the\n-                     // ancestor check below, but it's not clear that\n-                     // it makes sense to ALWAYS do it.\n-                     let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n-\n-                     // Screen out obligations that we know globally\n-                     // are true. This should really be the DAG check\n-                     // mentioned above.\n-                     if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n-                         return None;\n-                     }\n-\n-                     // Check whether this obligation appears somewhere else in the tree.\n-                     if tree_cache.is_duplicate_or_add(&obligation.predicate) {\n-                         // If the obligation appears as a parent,\n-                         // allow it, because that is a cycle.\n-                         // Otherwise though we can just ignore\n-                         // it. Note that we have to be careful around\n-                         // inference variables here -- for the\n-                         // purposes of the ancestor check, we retain\n-                         // the invariant that all type variables are\n-                         // fully refreshed.\n-                         if !is_ancestor(&obligation.predicate) {\n-                             return None;\n-                         }\n-                     }\n-\n-                     Some(PendingPredicateObligation {\n-                         obligation: obligation,\n-                         stalled_on: vec![]\n-                     })\n-                 })\n-                 .collect();\n-\n-            Ok(Some(pending_predicate_obligations))\n+impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n+    fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n+        AncestorSet {\n+            populated: false,\n+            cache: FnvHashMap(),\n+            backtrace: backtrace.clone(),\n         }\n-        Ok(None) => Ok(None),\n-        Err(e) => Err(e)\n     }\n-}\n \n+    /// Checks whether any of the ancestors in the backtrace are equal\n+    /// to `predicate` (`predicate` is assumed to be fully\n+    /// type-resolved).  Returns `None` if not; otherwise, returns\n+    /// `Some` with the index within the backtrace.\n+    fn has<'a>(&mut self,\n+               infcx: &InferCtxt<'a, 'tcx>,\n+               predicate: &ty::Predicate<'tcx>)\n+               -> Option<usize> {\n+        // the first time, we have to populate the cache\n+        if !self.populated {\n+            let backtrace = self.backtrace.clone();\n+            for (index, ancestor) in backtrace.enumerate() {\n+                // Ugh. This just feels ridiculously\n+                // inefficient.  But we need to compare\n+                // predicates without being concerned about\n+                // the vagaries of type inference, so for now\n+                // just ensure that they are always\n+                // up-to-date. (I suppose we could just use a\n+                // snapshot and check if they are unifiable?)\n+                let resolved_predicate =\n+                    infcx.resolve_type_vars_if_possible(\n+                        &ancestor.obligation.predicate);\n+\n+                // Though we try to avoid it, it can happen that a\n+                // cycle already exists in the predecessors. This\n+                // happens if the type variables were not fully known\n+                // at the time that the ancestors were pushed. We'll\n+                // just ignore such cycles for now, on the premise\n+                // that they will repeat themselves and we'll deal\n+                // with them properly then.\n+                self.cache.entry(resolved_predicate)\n+                          .or_insert(index);\n+            }\n+            self.populated = true;\n+        }\n+\n+        self.cache.get(predicate).cloned()\n+    }\n+}\n \n /// Return the set of type variables contained in a trait ref\n fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n@@ -438,7 +507,6 @@ fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n /// - `Err` if the predicate does not hold\n fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                               backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                                region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n                                -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n                                          FulfillmentErrorCode<'tcx>>\n@@ -461,16 +529,6 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n \n     let obligation = &mut pending_obligation.obligation;\n \n-    // If we exceed the recursion limit, take a moment to look for a\n-    // cycle so we can give a better error report from here, where we\n-    // have more context.\n-    let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n-    if obligation.recursion_depth >= recursion_limit {\n-        if let Some(cycle) = scan_for_cycle(obligation, &backtrace) {\n-            report_overflow_error_cycle(selcx.infcx(), &cycle);\n-        }\n-    }\n-\n     if obligation.predicate.has_infer_types() {\n         obligation.predicate = selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n     }\n@@ -481,10 +539,6 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 return Ok(Some(vec![]));\n             }\n \n-            if coinductive_match(selcx, obligation, data, &backtrace) {\n-                return Ok(Some(vec![]));\n-            }\n-\n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(Some(vtable)) => {\n@@ -616,10 +670,15 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n ///   also defaulted traits.\n fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                               top_obligation: &PredicateObligation<'tcx>,\n-                              top_data: &ty::PolyTraitPredicate<'tcx>,\n                               backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n                               -> bool\n {\n+    // only trait predicates can be coinductive matches\n+    let top_data = match top_obligation.predicate {\n+        ty::Predicate::Trait(ref data) => data,\n+        _ => return false\n+    };\n+\n     if selcx.tcx().trait_has_default_impl(top_data.def_id()) {\n         debug!(\"coinductive_match: top_data={:?}\", top_data);\n         for bt_obligation in backtrace.clone() {\n@@ -647,27 +706,6 @@ fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     false\n }\n \n-fn scan_for_cycle<'a,'tcx>(top_obligation: &PredicateObligation<'tcx>,\n-                           backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n-                           -> Option<Vec<PredicateObligation<'tcx>>>\n-{\n-    let mut map = FnvHashMap();\n-    let all_obligations =\n-        || iter::once(top_obligation)\n-               .chain(backtrace.clone()\n-                               .map(|p| &p.obligation));\n-    for (index, bt_obligation) in all_obligations().enumerate() {\n-        if let Some(&start) = map.get(&bt_obligation.predicate) {\n-            // Found a cycle starting at position `start` and running\n-            // until the current position (`index`).\n-            return Some(all_obligations().skip(start).take(index - start + 1).cloned().collect());\n-        } else {\n-            map.insert(bt_obligation.predicate.clone(), index);\n-        }\n-    }\n-    None\n-}\n-\n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n                                     r_b: ty::Region,\n                                     cause: ObligationCause<'tcx>,"}, {"sha": "8af243afc22996b064c55ecc24e68aec2c7d82c4", "filename": "src/test/compile-fail/issue-32326.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/944723b7731ec1eacdbc1946009bcd51d17a6301/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944723b7731ec1eacdbc1946009bcd51d17a6301/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32326.rs?ref=944723b7731ec1eacdbc1946009bcd51d17a6301", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #32326. We ran out of memory because we\n+// attempted to expand this case up to the recursion limit, and 2^N is\n+// too big.\n+\n+enum Expr { //~ ERROR E0072\n+    Plus(Expr, Expr),\n+    Literal(i64),\n+}\n+\n+fn main() { }"}, {"sha": "3d7c4868e96fe3bff3e62da72e0752ecc45c519a", "filename": "src/test/compile-fail/sized-cycle-note.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/944723b7731ec1eacdbc1946009bcd51d17a6301/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944723b7731ec1eacdbc1946009bcd51d17a6301/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs?ref=944723b7731ec1eacdbc1946009bcd51d17a6301", "patch": "@@ -20,11 +20,11 @@ struct Baz { q: Option<Foo> }\n \n struct Foo { q: Option<Baz> }\n //~^ ERROR recursive type `Foo` has infinite size\n-//~| type `Foo` is embedded within `std::option::Option<Foo>`...\n-//~| ...which in turn is embedded within `std::option::Option<Foo>`...\n-//~| ...which in turn is embedded within `Baz`...\n-//~| ...which in turn is embedded within `std::option::Option<Baz>`...\n-//~| ...which in turn is embedded within `Foo`, completing the cycle.\n+//~| NOTE type `Foo` is embedded within `std::option::Option<Foo>`...\n+//~| NOTE ...which in turn is embedded within `std::option::Option<Foo>`...\n+//~| NOTE ...which in turn is embedded within `Baz`...\n+//~| NOTE ...which in turn is embedded within `std::option::Option<Baz>`...\n+//~| NOTE ...which in turn is embedded within `Foo`, completing the cycle.\n \n impl Foo { fn bar(&self) {} }\n "}]}