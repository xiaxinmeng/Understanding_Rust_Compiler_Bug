{"sha": "37601131a0ffc49e93b8797020429a980520171c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NjAxMTMxYTBmZmM0OWU5M2I4Nzk3MDIwNDI5YTk4MDUyMDE3MWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-15T20:09:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-23T20:46:02Z"}, "message": "Make the `Fn` traits inherit from one another and remove the bridging\nimpls.\n\nThis requires:\n\n1. modifying trait selection a bit so that when we synthesize impls for\n   fn pointers and closures;\n2. adding code to trans so that we can synthesize a `FnMut`/`FnOnce`\n   impl for a `Fn` closure and so forth.", "tree": {"sha": "a12fdb96398c503fd0719784e6457d5944a4a28f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a12fdb96398c503fd0719784e6457d5944a4a28f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37601131a0ffc49e93b8797020429a980520171c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37601131a0ffc49e93b8797020429a980520171c", "html_url": "https://github.com/rust-lang/rust/commit/37601131a0ffc49e93b8797020429a980520171c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37601131a0ffc49e93b8797020429a980520171c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0aad7dd4fad8d7e2e2f877a511a637258949597", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0aad7dd4fad8d7e2e2f877a511a637258949597", "html_url": "https://github.com/rust-lang/rust/commit/b0aad7dd4fad8d7e2e2f877a511a637258949597"}], "stats": {"total": 697, "additions": 495, "deletions": 202}, "files": [{"sha": "fc3f4b426d8615700fd85442a6adb7408ca3b388", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -1136,6 +1136,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[cfg(stage0)]\n pub trait Fn<Args> {\n     /// The returned type after the call operator is used.\n     type Output;\n@@ -1144,10 +1145,21 @@ pub trait Fn<Args> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n+/// A version of the call operator that takes an immutable receiver.\n+#[lang=\"fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[cfg(not(stage0))]\n+pub trait Fn<Args> : FnMut<Args> {\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[cfg(stage0)]\n pub trait FnMut<Args> {\n     /// The returned type after the call operator is used.\n     type Output;\n@@ -1156,6 +1168,16 @@ pub trait FnMut<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n+/// A version of the call operator that takes a mutable receiver.\n+#[lang=\"fn_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[cfg(not(stage0))]\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1168,6 +1190,7 @@ pub trait FnOnce<Args> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n+#[cfg(stage0)]\n impl<F: ?Sized, A> FnMut<A> for F\n     where F : Fn<A>\n {\n@@ -1178,6 +1201,7 @@ impl<F: ?Sized, A> FnMut<A> for F\n     }\n }\n \n+#[cfg(stage0)]\n impl<F,A> FnOnce<A> for F\n     where F : FnMut<A>\n {"}, {"sha": "dd7144636dfb7ea4dd7c16e6d641fd781517c6d2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -29,7 +29,7 @@ use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n use num::Int;\n-use ops::{Fn, FnMut};\n+use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n@@ -524,6 +524,7 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n+#[cfg(stage0)]\n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     type Output = u8;\n \n@@ -533,6 +534,32 @@ impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Fn<(&'a u8,)> for BytesDeref {\n+    #[inline]\n+    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n+        *ptr\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a> FnMut<(&'a u8,)> for BytesDeref {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, (ptr,): (&'a u8,)) -> u8 {\n+        Fn::call(&*self, (ptr,))\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a> FnOnce<(&'a u8,)> for BytesDeref {\n+    type Output = u8;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(self, (ptr,): (&'a u8,)) -> u8 {\n+        Fn::call(&self, (ptr,))\n+    }\n+}\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n struct CharSplits<'a, P: Pattern<'a>> {\n     /// The slice remaining to be iterated"}, {"sha": "b4f21492ca10b0c95a9bb678c91e89c5f15780c9", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -789,10 +789,13 @@ fn confirm_callable_candidate<'cx,'tcx>(\n            obligation.repr(tcx),\n            fn_sig.repr(tcx));\n \n+    // the `Output` associated type is declared on `FnOnce`\n+    let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n+\n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) =\n         util::closure_trait_ref_and_return_type(tcx,\n-                                                obligation.predicate.trait_ref.def_id,\n+                                                fn_once_def_id,\n                                                 obligation.predicate.trait_ref.self_ty(),\n                                                 fn_sig,\n                                                 flag);"}, {"sha": "764e342a0c5af353dfde0a112d4764f92e45202f", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -1071,7 +1071,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.closure_typer.closure_kind(closure_def_id) {\n             Some(closure_kind) => {\n                 debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n-                if closure_kind == kind {\n+                if closure_kind.extends(kind) {\n                     candidates.vec.push(ClosureCandidate(closure_def_id, substs.clone()));\n                 }\n             }\n@@ -1090,10 +1090,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n-        // We provide a `Fn` impl for fn pointers. There is no need to provide\n-        // the other traits (e.g. `FnMut`) since those are provided by blanket\n-        // impls.\n-        if Some(obligation.predicate.def_id()) != self.tcx().lang_items.fn_trait() {\n+        // We provide impl of all fn traits for fn pointers.\n+        if self.tcx().lang_items.fn_trait_kind(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n "}, {"sha": "4b8c4ee88c05da0189238958223157e8147eff3f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -2461,8 +2461,11 @@ pub struct ItemSubsts<'tcx> {\n     pub substs: Substs<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ClosureKind {\n+    // Warning: Ordering is significant here! The ordering is chosen\n+    // because the trait Fn is a subtrait of FnMut and so in turn, and\n+    // hence we order it so that Fn < FnMut < FnOnce.\n     FnClosureKind,\n     FnMutClosureKind,\n     FnOnceClosureKind,\n@@ -2484,6 +2487,20 @@ impl ClosureKind {\n             Err(err) => cx.sess.fatal(&err[..]),\n         }\n     }\n+\n+    /// True if this a type that impls this closure kind\n+    /// must also implement `other`.\n+    pub fn extends(self, other: ty::ClosureKind) -> bool {\n+        match (self, other) {\n+            (FnClosureKind, FnClosureKind) => true,\n+            (FnClosureKind, FnMutClosureKind) => true,\n+            (FnClosureKind, FnOnceClosureKind) => true,\n+            (FnMutClosureKind, FnMutClosureKind) => true,\n+            (FnMutClosureKind, FnOnceClosureKind) => true,\n+            (FnOnceClosureKind, FnOnceClosureKind) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n pub trait ClosureTyper<'tcx> {"}, {"sha": "07c94097e2df8a17cb2c7d5720998ba04c639d57", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -264,24 +264,36 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// but for the bare function type given.\n pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_kind: ty::ClosureKind,\n     bare_fn_ty: Ty<'tcx>)\n     -> ValueRef\n {\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n+    // Normalize the type for better caching.\n     let bare_fn_ty = common::erase_regions(tcx, &bare_fn_ty);\n-    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n+\n+    // If this is an impl of `Fn` or `FnMut` trait, the receiver is `&self`.\n+    let is_by_ref = match closure_kind {\n+        ty::FnClosureKind | ty::FnMutClosureKind => true,\n+        ty::FnOnceClosureKind => false,\n+    };\n+    let bare_fn_ty_maybe_ref = if is_by_ref {\n+        ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty)\n+    } else {\n+        bare_fn_ty\n+    };\n+\n+    // Check if we already trans'd this shim.\n+    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n         Some(&llval) => { return llval; }\n         None => { }\n     }\n \n     debug!(\"trans_fn_pointer_shim(bare_fn_ty={})\",\n            bare_fn_ty.repr(tcx));\n \n-    // This is an impl of `Fn` trait, so receiver is `&self`.\n-    let bare_fn_ty_ref = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty);\n-\n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n     let (opt_def_id, sig) =\n@@ -306,7 +318,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                          unsafety: ast::Unsafety::Normal,\n                                          abi: synabi::RustCall,\n                                          sig: ty::Binder(ty::FnSig {\n-                                             inputs: vec![bare_fn_ty_ref,\n+                                             inputs: vec![bare_fn_ty_maybe_ref,\n                                                           tuple_input_ty],\n                                              output: sig.output,\n                                              variadic: false\n@@ -337,8 +349,11 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer\n-    let llfnpointer =\n-        Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32));\n+    let llfnpointer = if is_by_ref {\n+        Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32))\n+    } else {\n+        get_param(fcx.llfn, fcx.arg_pos(0) as u32)\n+    };\n \n     // the remaining arguments will be the untupled values\n     let llargs: Vec<_> =\n@@ -361,7 +376,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n-    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n+    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n \n     llfn\n }"}, {"sha": "5a48b8e4bce1d37acb4ae77844ff80a2e674c864", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 193, "deletions": 11, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -8,24 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::ValueRef;\n+use arena::TypedArena;\n+use back::link::{self, mangle_internal_name_by_path_and_seq};\n+use llvm::{ValueRef, get_param};\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n use trans::build::*;\n-use trans::cleanup::{CleanupMethods, ScopeId};\n+use trans::callee::{self, ArgVals, Callee, TraitItem, MethodData};\n+use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n-use trans::datum::{Datum, rvalue_scratch_datum};\n-use trans::datum::{Rvalue, ByValue};\n-use trans::debuginfo;\n+use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue, ByValue};\n+use trans::debuginfo::{self, DebugLoc};\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n use middle::ty::{self, ClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n+use util::ppaux::Repr;\n \n+use syntax::abi::RustCall;\n use syntax::ast;\n use syntax::ast_util;\n \n@@ -239,11 +242,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // Create the closure.\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n-        let upvar_slot_dest = adt::trans_field_ptr(bcx,\n-                                                   &*repr,\n-                                                   dest_addr,\n-                                                   0,\n-                                                   i);\n+        let upvar_slot_dest = adt::trans_field_ptr(bcx, &*repr, dest_addr, 0, i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n@@ -259,3 +258,186 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n     Some(bcx)\n }\n+\n+pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                      closure_def_id: ast::DefId,\n+                                      substs: Substs<'tcx>,\n+                                      node: ExprOrMethodCall,\n+                                      param_substs: &'tcx Substs<'tcx>,\n+                                      trait_closure_kind: ty::ClosureKind)\n+                                      -> ValueRef\n+{\n+    // The substitutions should have no type parameters remaining\n+    // after passing through fulfill_obligation\n+    let llfn = callee::trans_fn_ref_with_substs(ccx,\n+                                                closure_def_id,\n+                                                node,\n+                                                param_substs,\n+                                                substs.clone()).val;\n+\n+    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n+    // then adapt the self type\n+    let closure_kind = ccx.tcx().closure_kind(closure_def_id);\n+    trans_closure_adapter_shim(ccx,\n+                               closure_def_id,\n+                               substs,\n+                               closure_kind,\n+                               trait_closure_kind,\n+                               llfn)\n+}\n+\n+fn trans_closure_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: Substs<'tcx>,\n+    llfn_closure_kind: ty::ClosureKind,\n+    trait_closure_kind: ty::ClosureKind,\n+    llfn: ValueRef)\n+    -> ValueRef\n+{\n+    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n+    let tcx = ccx.tcx();\n+\n+    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n+           trait_closure_kind={:?}, \\\n+           llfn={})\",\n+           llfn_closure_kind,\n+           trait_closure_kind,\n+           ccx.tn().val_to_string(llfn));\n+\n+    match (llfn_closure_kind, trait_closure_kind) {\n+        (ty::FnClosureKind, ty::FnClosureKind) |\n+        (ty::FnMutClosureKind, ty::FnMutClosureKind) |\n+        (ty::FnOnceClosureKind, ty::FnOnceClosureKind) => {\n+            // No adapter needed.\n+            llfn\n+        }\n+        (ty::FnClosureKind, ty::FnMutClosureKind) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            llfn\n+        }\n+        (ty::FnClosureKind, ty::FnOnceClosureKind) |\n+        (ty::FnMutClosureKind, ty::FnOnceClosureKind) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n+        }\n+        _ => {\n+            tcx.sess.bug(&format!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                                  llfn_closure_kind,\n+                                  trait_closure_kind));\n+        }\n+    }\n+}\n+\n+fn trans_fn_once_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: Substs<'tcx>,\n+    llreffn: ValueRef)\n+    -> ValueRef\n+{\n+    debug!(\"trans_fn_once_adapter_shim(closure_def_id={}, substs={}, llreffn={})\",\n+           closure_def_id.repr(ccx.tcx()),\n+           substs.repr(ccx.tcx()),\n+           ccx.tn().val_to_string(llreffn));\n+\n+    let tcx = ccx.tcx();\n+    let typer = NormalizingClosureTyper::new(tcx);\n+\n+    // Find a version of the closure type. Substitute static for the\n+    // region since it doesn't really matter.\n+    let substs = tcx.mk_substs(substs);\n+    let closure_ty = ty::mk_closure(tcx, closure_def_id, substs);\n+    let ref_closure_ty = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), closure_ty);\n+\n+    // Make a version with the type of by-ref closure.\n+    let ty::ClosureTy { unsafety, abi, mut sig } = typer.closure_type(closure_def_id, substs);\n+    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n+    let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n+                                                               abi: abi,\n+                                                               sig: sig.clone() });\n+    let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={}\",\n+           llref_fn_ty.repr(tcx));\n+\n+    // Make a version of the closure type with the same arguments, but\n+    // with argument #0 being by value.\n+    assert_eq!(abi, RustCall);\n+    sig.0.inputs[0] = closure_ty;\n+    let llonce_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n+                                                                abi: abi,\n+                                                                sig: sig });\n+    let llonce_fn_ty = ty::mk_bare_fn(tcx, None, llonce_bare_fn_ty);\n+\n+    // Create the by-value helper.\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n+    let lloncefn = decl_internal_rust_fn(ccx, llonce_fn_ty, &function_name);\n+\n+    let sig = ty::erase_late_bound_regions(tcx, &llonce_bare_fn_ty.sig);\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      lloncefn,\n+                      ast::DUMMY_NODE_ID,\n+                      false,\n+                      sig.output,\n+                      substs,\n+                      None,\n+                      &block_arena);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n+\n+    // the first argument (`self`) will be the (by value) closure env.\n+    let self_scope = fcx.push_custom_cleanup_scope();\n+    let self_scope_id = CustomScope(self_scope);\n+    let rvalue_mode = datum::appropriate_rvalue_mode(ccx, closure_ty);\n+    let llself = get_param(lloncefn, fcx.arg_pos(0) as u32);\n+    let env_datum = Datum::new(llself, closure_ty, Rvalue::new(rvalue_mode));\n+    let env_datum = unpack_datum!(bcx,\n+                                  env_datum.to_lvalue_datum_in_scope(bcx, \"self\",\n+                                                                     self_scope_id));\n+\n+    debug!(\"trans_fn_once_adapter_shim: env_datum={}\",\n+           bcx.val_to_string(env_datum.val));\n+\n+    // the remaining arguments will be packed up in a tuple.\n+    let input_tys = match sig.inputs[1].sty {\n+        ty::ty_tup(ref tys) => &**tys,\n+        _ => bcx.sess().bug(&format!(\"trans_fn_once_adapter_shim: not rust-call! \\\n+                                      closure_def_id={}\",\n+                                     closure_def_id.repr(tcx)))\n+    };\n+    let llargs: Vec<_> =\n+        input_tys.iter()\n+                 .enumerate()\n+                 .map(|(i, _)| get_param(lloncefn, fcx.arg_pos(i+1) as u32))\n+                 .collect();\n+\n+    let dest =\n+        fcx.llretslotptr.get().map(\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n+\n+    let callee_data = TraitItem(MethodData { llfn: llreffn,\n+                                             llself: env_datum.val });\n+\n+    bcx = callee::trans_call_inner(bcx,\n+                                   DebugLoc::None,\n+                                   llref_fn_ty,\n+                                   |bcx, _| Callee { bcx: bcx, data: callee_data },\n+                                   ArgVals(&llargs),\n+                                   dest).bcx;\n+\n+    fcx.pop_custom_cleanup_scope(self_scope);\n+\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n+\n+    lloncefn\n+}"}, {"sha": "aa038f8ddca3148d51e15f047d2daeab516ab4f4", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -17,11 +17,13 @@ use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n+use middle::ty::ClosureTyper;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::*;\n use trans::callee;\n use trans::cleanup;\n+use trans::closure;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n@@ -358,19 +360,21 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableClosure(closure_def_id, substs) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n-            let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                closure_def_id,\n-                                                MethodCallKey(method_call),\n-                                                bcx.fcx.param_substs,\n-                                                substs).val;\n-\n+            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = closure::trans_closure_method(bcx.ccx(),\n+                                                     closure_def_id,\n+                                                     substs,\n+                                                     MethodCallKey(method_call),\n+                                                     bcx.fcx.param_substs,\n+                                                     trait_closure_kind);\n             Callee {\n                 bcx: bcx,\n                 data: Fn(llfn),\n             }\n         }\n         traits::VtableFnPointer(fn_ty) => {\n-            let llfn = trans_fn_pointer_shim(bcx.ccx(), fn_ty);\n+            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = trans_fn_pointer_shim(bcx.ccx(), trait_closure_kind, fn_ty);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableObject(ref data) => {\n@@ -645,9 +649,6 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let sig =\n-        ty::erase_late_bound_regions(bcx.tcx(), &fty.sig);\n-\n     let dest =\n         fcx.llretslotptr.get().map(\n             |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n@@ -714,17 +715,18 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 emit_vtable_methods(ccx, id, substs, param_substs).into_iter()\n             }\n             traits::VtableClosure(closure_def_id, substs) => {\n-                let llfn = trans_fn_ref_with_substs(\n-                    ccx,\n-                    closure_def_id,\n-                    ExprId(0),\n-                    param_substs,\n-                    substs).val;\n-\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n+                let llfn = closure::trans_closure_method(ccx,\n+                                                         closure_def_id,\n+                                                         substs,\n+                                                         ExprId(0),\n+                                                         param_substs,\n+                                                         trait_closure_kind);\n                 vec![llfn].into_iter()\n             }\n             traits::VtableFnPointer(bare_fn_ty) => {\n-                vec![trans_fn_pointer_shim(ccx, bare_fn_ty)].into_iter()\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n+                vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n             }\n             traits::VtableObject(ref data) => {\n                 // this would imply that the Self type being erased is"}, {"sha": "4f06346fb45cc53d199b91969504693fa6e6d4da", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 133, "deletions": 110, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -55,7 +55,7 @@ use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, RegionEscape, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n@@ -608,24 +608,16 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n     poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n-    let mut projections = Vec::new();\n-\n-    // The trait reference introduces a binding level here, so\n-    // we need to shift the `rscope`. It'd be nice if we could\n-    // do away with this rscope stuff and work this knowledge\n-    // into resolve_lifetimes, as we do with non-omitted\n-    // lifetimes. Oh well, not there yet.\n-    let shifted_rscope = ShiftedRscope::new(rscope);\n-\n-    let trait_ref = instantiate_trait_ref(this, &shifted_rscope,\n-                                          &ast_trait_ref.trait_ref,\n-                                          None, self_ty, Some(&mut projections));\n-\n-    for projection in projections {\n-        poly_projections.push(ty::Binder(projection));\n-    }\n-\n-    ty::Binder(trait_ref)\n+    let trait_ref = &ast_trait_ref.trait_ref;\n+    let trait_def_id = trait_def_id(this, trait_ref);\n+    ast_path_to_poly_trait_ref(this,\n+                               rscope,\n+                               trait_ref.path.span,\n+                               PathParamMode::Explicit,\n+                               trait_def_id,\n+                               self_ty,\n+                               trait_ref.path.segments.last().unwrap(),\n+                               poly_projections)\n }\n \n /// Instantiates the path for the given trait reference, assuming that it's\n@@ -634,31 +626,27 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n ///\n /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n /// are disallowed. Otherwise, they are pushed onto the vector given.\n-pub fn instantiate_trait_ref<'tcx>(\n+pub fn instantiate_mono_trait_ref<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     trait_ref: &ast::TraitRef,\n-    impl_id: Option<ast::NodeId>,\n-    self_ty: Option<Ty<'tcx>>,\n-    projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n+    self_ty: Option<Ty<'tcx>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n+    let trait_def_id = trait_def_id(this, trait_ref);\n+    ast_path_to_mono_trait_ref(this,\n+                               rscope,\n+                               trait_ref.path.span,\n+                               PathParamMode::Explicit,\n+                               trait_def_id,\n+                               self_ty,\n+                               trait_ref.path.segments.last().unwrap())\n+}\n+\n+fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> ast::DefId {\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n-        def::DefTrait(trait_def_id) => {\n-            let trait_ref = ast_path_to_trait_ref(this,\n-                                                  rscope,\n-                                                  path.span,\n-                                                  PathParamMode::Explicit,\n-                                                  trait_def_id,\n-                                                  self_ty,\n-                                                  path.segments.last().unwrap(),\n-                                                  projections);\n-            if let Some(id) = impl_id {\n-                this.tcx().impl_trait_refs.borrow_mut().insert(id, trait_ref.clone());\n-            }\n-            trait_ref\n-        }\n+        def::DefTrait(trait_def_id) => trait_def_id,\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n                         path.user_string(this.tcx()));\n@@ -676,35 +664,96 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n-    // we are introducing a binder here, so shift the\n-    // anonymous regions depth to account for that\n-    let shifted_rscope = ShiftedRscope::new(rscope);\n-\n-    let mut tmp = Vec::new();\n-    let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n-                                                     &shifted_rscope,\n-                                                     span,\n-                                                     param_mode,\n-                                                     trait_def_id,\n-                                                     None,\n-                                                     trait_segment,\n-                                                     Some(&mut tmp)));\n-    projections.extend(tmp.into_iter().map(ty::Binder));\n-    trait_ref\n+    ast_path_to_poly_trait_ref(this,\n+                               rscope,\n+                               span,\n+                               param_mode,\n+                               trait_def_id,\n+                               None,\n+                               trait_segment,\n+                               projections)\n }\n \n-fn ast_path_to_trait_ref<'a,'tcx>(\n+fn ast_path_to_poly_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     trait_segment: &ast::PathSegment,\n-    mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n-    -> Rc<ty::TraitRef<'tcx>>\n+    poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+    -> ty::PolyTraitRef<'tcx>\n+{\n+    // The trait reference introduces a binding level here, so\n+    // we need to shift the `rscope`. It'd be nice if we could\n+    // do away with this rscope stuff and work this knowledge\n+    // into resolve_lifetimes, as we do with non-omitted\n+    // lifetimes. Oh well, not there yet.\n+    let shifted_rscope = &ShiftedRscope::new(rscope);\n+\n+    let (substs, assoc_bindings) =\n+        create_substs_for_ast_trait_ref(this,\n+                                        shifted_rscope,\n+                                        span,\n+                                        param_mode,\n+                                        trait_def_id,\n+                                        self_ty,\n+                                        trait_segment);\n+    let poly_trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_def_id, substs)));\n+\n+    {\n+        let converted_bindings =\n+            assoc_bindings\n+            .iter()\n+            .filter_map(|binding| {\n+                // specify type to assert that error was already reported in Err case:\n+                let predicate: Result<_, ErrorReported> =\n+                    ast_type_binding_to_poly_projection_predicate(this,\n+                                                                  poly_trait_ref.clone(),\n+                                                                  self_ty,\n+                                                                  binding);\n+                predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n+            });\n+        poly_projections.extend(converted_bindings);\n+    }\n+\n+    poly_trait_ref\n+}\n+\n+fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+                                       rscope: &RegionScope,\n+                                       span: Span,\n+                                       param_mode: PathParamMode,\n+                                       trait_def_id: ast::DefId,\n+                                       self_ty: Option<Ty<'tcx>>,\n+                                       trait_segment: &ast::PathSegment)\n+                                       -> Rc<ty::TraitRef<'tcx>>\n {\n-    debug!(\"ast_path_to_trait_ref {:?}\", trait_segment);\n+    let (substs, assoc_bindings) =\n+        create_substs_for_ast_trait_ref(this,\n+                                        rscope,\n+                                        span,\n+                                        param_mode,\n+                                        trait_def_id,\n+                                        self_ty,\n+                                        trait_segment);\n+    prohibit_projections(this.tcx(), &assoc_bindings);\n+    Rc::new(ty::TraitRef::new(trait_def_id, substs))\n+}\n+\n+fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+                                            rscope: &RegionScope,\n+                                            span: Span,\n+                                            param_mode: PathParamMode,\n+                                            trait_def_id: ast::DefId,\n+                                            self_ty: Option<Ty<'tcx>>,\n+                                            trait_segment: &ast::PathSegment)\n+                                            -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n+{\n+    debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n+           trait_segment);\n+\n     let trait_def = match this.get_trait_def(span, trait_def_id) {\n         Ok(trait_def) => trait_def,\n         Err(ErrorReported) => {\n@@ -752,34 +801,16 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                                             self_ty,\n                                             types,\n                                             regions);\n-    let substs = this.tcx().mk_substs(substs);\n \n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n-\n-    match projections {\n-        None => {\n-            prohibit_projections(this.tcx(), &assoc_bindings);\n-        }\n-        Some(ref mut v) => {\n-            for binding in &assoc_bindings {\n-                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(),\n-                                                               self_ty, binding) {\n-                    Ok(pp) => { v.push(pp); }\n-                    Err(ErrorReported) => { }\n-                }\n-            }\n-        }\n-    }\n-\n-    trait_ref\n+    (this.tcx().mk_substs(substs), assoc_bindings)\n }\n \n-fn ast_type_binding_to_projection_predicate<'tcx>(\n+fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     this: &AstConv<'tcx>,\n-    mut trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    mut trait_ref: ty::PolyTraitRef<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n-    -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n+    -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n {\n     let tcx = this.tcx();\n \n@@ -800,14 +831,14 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n     // Simple case: X is defined in the current trait.\n-    if this.trait_defines_associated_type_named(trait_ref.def_id, binding.item_name) {\n-        return Ok(ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                trait_ref: trait_ref,\n+    if this.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n+        return Ok(ty::Binder(ty::ProjectionPredicate {      // <-------------------+\n+            projection_ty: ty::ProjectionTy {               //                     |\n+                trait_ref: trait_ref.skip_binder().clone(), // Binder moved here --+\n                 item_name: binding.item_name,\n             },\n             ty: binding.ty,\n-        });\n+        }));\n     }\n \n     // Otherwise, we have to walk through the supertraits to find\n@@ -820,17 +851,17 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n \n     let dummy_self_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n     if self_ty.is_none() { // if converting for an object type\n-        let mut dummy_substs = trait_ref.substs.clone();\n-        assert!(dummy_substs.self_ty().is_none());\n-        dummy_substs.types.push(SelfSpace, dummy_self_ty);\n-        trait_ref = Rc::new(ty::TraitRef::new(trait_ref.def_id,\n-                                              tcx.mk_substs(dummy_substs)));\n+        let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n+        assert!(dummy_substs.self_ty().is_none());                     //                    |\n+        dummy_substs.types.push(SelfSpace, dummy_self_ty);             //                    |\n+        trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_ref.def_id(), // <------------+\n+                                                         tcx.mk_substs(dummy_substs))));\n     }\n \n-    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id));\n+    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id()));\n \n     let mut candidates: Vec<ty::PolyTraitRef> =\n-        traits::supertraits(tcx, trait_ref.to_poly_trait_ref())\n+        traits::supertraits(tcx, trait_ref.clone())\n         .filter(|r| this.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n         .collect();\n \n@@ -865,21 +896,13 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n         }\n     };\n \n-    if ty::binds_late_bound_regions(tcx, &candidate) {\n-        span_err!(tcx.sess, binding.span, E0219,\n-            \"associated type `{}` defined in higher-ranked supertrait `{}`\",\n-                    token::get_name(binding.item_name),\n-                    candidate.user_string(tcx));\n-        return Err(ErrorReported);\n-    }\n-\n-    Ok(ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy {\n-            trait_ref: candidate.0,\n+    Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n+        projection_ty: ty::ProjectionTy {               //                           |\n+            trait_ref: candidate.skip_binder().clone(), // binder is moved up here --+\n             item_name: binding.item_name,\n         },\n         ty: binding.ty,\n-    })\n+    }))\n }\n \n fn ast_path_to_ty<'tcx>(\n@@ -1134,14 +1157,14 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n \n-    let trait_ref = ast_path_to_trait_ref(this,\n-                                          rscope,\n-                                          span,\n-                                          param_mode,\n-                                          trait_def_id,\n-                                          Some(self_ty),\n-                                          trait_segment,\n-                                          None);\n+    let trait_ref =\n+        ast_path_to_mono_trait_ref(this,\n+                                   rscope,\n+                                   span,\n+                                   param_mode,\n+                                   trait_def_id,\n+                                   Some(self_ty),\n+                                   trait_segment);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n "}, {"sha": "d2a06fcf9909138d1a1b354350c9dc1ea903b5ce", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -16,6 +16,7 @@ use astconv;\n use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n+use std::cmp;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n@@ -109,15 +110,11 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n         ty::ty_trait(ref object_type) => {\n             let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n                                                                          fcx.tcx().types.err);\n-            let expectations =\n-                proj_bounds.iter()\n-                           .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n-                           .next();\n-\n-            match expectations {\n-                Some((sig, kind)) => (Some(sig), Some(kind)),\n-                None => (None, None)\n-            }\n+            let sig = proj_bounds.iter()\n+                                 .filter_map(|pb| deduce_sig_from_projection(fcx, pb))\n+                                 .next();\n+            let kind = fcx.tcx().lang_items.fn_trait_kind(object_type.principal_def_id());\n+            (sig, kind)\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n             deduce_expectations_from_obligations(fcx, vid)\n@@ -136,7 +133,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n     let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n-    let expected_sig_and_kind =\n+    let expected_sig =\n         fulfillment_cx\n         .pending_obligations()\n         .iter()\n@@ -150,7 +147,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 ty::Predicate::Projection(ref proj_predicate) => {\n                     let trait_ref = proj_predicate.to_poly_trait_ref();\n                     self_type_matches_expected_vid(fcx, trait_ref, expected_vid)\n-                        .and_then(|_| deduce_expectations_from_projection(fcx, proj_predicate))\n+                        .and_then(|_| deduce_sig_from_projection(fcx, proj_predicate))\n                 }\n                 _ => {\n                     None\n@@ -159,14 +156,10 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         })\n         .next();\n \n-    match expected_sig_and_kind {\n-        Some((sig, kind)) => { return (Some(sig), Some(kind)); }\n-        None => { }\n-    }\n-\n     // Even if we can't infer the full signature, we may be able to\n     // infer the kind. This can occur if there is a trait-reference\n-    // like `F : Fn<A>`.\n+    // like `F : Fn<A>`. Note that due to subtyping we could encounter\n+    // many viable options, so pick the most restrictive.\n     let expected_kind =\n         fulfillment_cx\n         .pending_obligations()\n@@ -183,54 +176,61 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 .and_then(|trait_ref| self_type_matches_expected_vid(fcx, trait_ref, expected_vid))\n                 .and_then(|trait_ref| fcx.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n         })\n-        .next();\n+        .fold(None, pick_most_restrictive_closure_kind);\n+\n+    (expected_sig, expected_kind)\n+}\n \n-    (None, expected_kind)\n+fn pick_most_restrictive_closure_kind(best: Option<ty::ClosureKind>,\n+                                      cur: ty::ClosureKind)\n+                                      -> Option<ty::ClosureKind>\n+{\n+    match best {\n+        None => Some(cur),\n+        Some(best) => Some(cmp::min(best, cur))\n+    }\n }\n \n /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n /// everything we need to know about a closure.\n-fn deduce_expectations_from_projection<'a,'tcx>(\n+fn deduce_sig_from_projection<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     projection: &ty::PolyProjectionPredicate<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+    -> Option<ty::FnSig<'tcx>>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_expectations_from_projection({})\",\n+    debug!(\"deduce_sig_from_projection({})\",\n            projection.repr(tcx));\n \n     let trait_ref = projection.to_poly_trait_ref();\n \n-    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n-        Some(k) => k,\n-        None => { return None; }\n-    };\n-\n-    debug!(\"found object type {:?}\", kind);\n+    if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n+        return None;\n+    }\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n-    debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n     let input_tys = match arg_param_ty.sty {\n         ty::ty_tup(ref tys) => { (*tys).clone() }\n         _ => { return None; }\n     };\n-    debug!(\"input_tys {}\", input_tys.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr(tcx));\n \n     let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n-    debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n     let fn_sig = ty::FnSig {\n         inputs: input_tys,\n         output: ty::FnConverging(ret_param_ty),\n         variadic: false\n     };\n-    debug!(\"fn_sig {}\", fn_sig.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: fn_sig {}\", fn_sig.repr(tcx));\n \n-    return Some((fn_sig, kind));\n+    Some(fn_sig)\n }\n \n fn self_type_matches_expected_vid<'a,'tcx>("}, {"sha": "b95e0ce8cb3c59e512d65101884e5fbd1d9b1697", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -725,7 +725,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             };\n \n             // this closure doesn't implement the right kind of `Fn` trait\n-            if closure_kind != kind {\n+            if !closure_kind.extends(kind) {\n                 continue;\n             }\n "}, {"sha": "8744df0e20249dd61aa3fefb43a26fd1024dd93e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37601131a0ffc49e93b8797020429a980520171c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=37601131a0ffc49e93b8797020429a980520171c", "patch": "@@ -784,14 +784,15 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                    &enum_definition.variants);\n         },\n         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n-            let trait_ref = astconv::instantiate_trait_ref(&ccx.icx(&()),\n-                                                           &ExplicitRscope,\n-                                                           ast_trait_ref,\n-                                                           Some(it.id),\n-                                                           None,\n-                                                           None);\n+            let trait_ref =\n+                astconv::instantiate_mono_trait_ref(&ccx.icx(&()),\n+                                                    &ExplicitRscope,\n+                                                    ast_trait_ref,\n+                                                    None);\n \n             ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n+\n+            tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n         }\n         ast::ItemImpl(_, _,\n                       ref generics,\n@@ -890,13 +891,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n             }\n \n-            if let Some(ref trait_ref) = *opt_trait_ref {\n-                astconv::instantiate_trait_ref(&ccx.icx(&ty_predicates),\n-                                               &ExplicitRscope,\n-                                               trait_ref,\n-                                               Some(it.id),\n-                                               Some(selfty),\n-                                               None);\n+            if let Some(ref ast_trait_ref) = *opt_trait_ref {\n+                let trait_ref =\n+                    astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n+                                                        &ExplicitRscope,\n+                                                        ast_trait_ref,\n+                                                        Some(selfty));\n+\n+                tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n             }\n \n             enforce_impl_ty_params_are_constrained(tcx,"}]}