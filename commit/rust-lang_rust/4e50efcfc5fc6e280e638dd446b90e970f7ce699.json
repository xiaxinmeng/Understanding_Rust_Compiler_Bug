{"sha": "4e50efcfc5fc6e280e638dd446b90e970f7ce699", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNTBlZmNmYzVmYzZlMjgwZTYzOGRkNDQ2YjkwZTk3MGY3Y2U2OTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-18T18:02:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-18T18:34:47Z"}, "message": "Strongly-typed generic methods for editing nodes", "tree": {"sha": "a80f7620fc7b8c5ed66dba7853634035b5b71312", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a80f7620fc7b8c5ed66dba7853634035b5b71312"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e50efcfc5fc6e280e638dd446b90e970f7ce699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e50efcfc5fc6e280e638dd446b90e970f7ce699", "html_url": "https://github.com/rust-lang/rust/commit/4e50efcfc5fc6e280e638dd446b90e970f7ce699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e50efcfc5fc6e280e638dd446b90e970f7ce699/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12c952f8010afb583989a6e72f81ded4aa9110d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/12c952f8010afb583989a6e72f81ded4aa9110d2", "html_url": "https://github.com/rust-lang/rust/commit/12c952f8010afb583989a6e72f81ded4aa9110d2"}], "stats": {"total": 96, "additions": 49, "deletions": 47}, "files": [{"sha": "1e34db5ae9c030a91e200e7c14608685bb729f04", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4e50efcfc5fc6e280e638dd446b90e970f7ce699/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e50efcfc5fc6e280e638dd446b90e970f7ce699/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=4e50efcfc5fc6e280e638dd446b90e970f7ce699", "patch": "@@ -23,7 +23,7 @@ impl ast::BinExpr {\n     pub fn replace_op(&self, op: SyntaxKind) -> Option<ast::BinExpr> {\n         let op_node: SyntaxElement = self.op_details()?.0.into();\n         let to_insert: Option<SyntaxElement> = Some(make::token(op).into());\n-        Some(replace_children(self, single_node(op_node), to_insert))\n+        Some(self.replace_children(single_node(op_node), to_insert))\n     }\n }\n \n@@ -39,10 +39,10 @@ impl ast::FnDef {\n         } else {\n             to_insert.push(make::tokens::single_space().into());\n             to_insert.push(body.syntax().clone().into());\n-            return insert_children(self, InsertPosition::Last, to_insert);\n+            return self.insert_children(InsertPosition::Last, to_insert);\n         };\n         to_insert.push(body.syntax().clone().into());\n-        replace_children(self, single_node(old_body_or_semi), to_insert)\n+        self.replace_children(single_node(old_body_or_semi), to_insert)\n     }\n }\n \n@@ -75,7 +75,7 @@ impl ast::ItemList {\n         let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n         let to_insert: ArrayVec<[SyntaxElement; 2]> =\n             [ws.ws().into(), item.syntax().clone().into()].into();\n-        insert_children(self, position, to_insert)\n+        self.insert_children(position, to_insert)\n     }\n \n     fn l_curly(&self) -> Option<SyntaxElement> {\n@@ -106,8 +106,8 @@ impl ast::ItemList {\n         let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n         let to_insert = iter::once(ws.ws().into());\n         match existing_ws {\n-            None => insert_children(self, InsertPosition::After(l_curly), to_insert),\n-            Some(ws) => replace_children(self, single_node(ws), to_insert),\n+            None => self.insert_children(InsertPosition::After(l_curly), to_insert),\n+            Some(ws) => self.replace_children(single_node(ws), to_insert),\n         }\n     }\n }\n@@ -184,7 +184,7 @@ impl ast::RecordFieldList {\n             InsertPosition::After(anchor) => after_field!(anchor),\n         };\n \n-        insert_children(self, position, to_insert)\n+        self.insert_children(position, to_insert)\n     }\n \n     fn l_curly(&self) -> Option<SyntaxElement> {\n@@ -203,16 +203,15 @@ impl ast::TypeParam {\n             Some(it) => it.syntax().clone().into(),\n             None => colon.clone().into(),\n         };\n-        replace_children(self, colon.into()..=end, iter::empty())\n+        self.replace_children(colon.into()..=end, iter::empty())\n     }\n }\n \n impl ast::Path {\n     #[must_use]\n     pub fn with_segment(&self, segment: ast::PathSegment) -> ast::Path {\n         if let Some(old) = self.segment() {\n-            return replace_children(\n-                self,\n+            return self.replace_children(\n                 single_node(old.syntax().clone()),\n                 iter::once(segment.syntax().clone().into()),\n             );\n@@ -234,8 +233,7 @@ impl ast::PathSegment {\n \n     fn _with_type_args(&self, type_args: ast::TypeArgList, turbo: bool) -> ast::PathSegment {\n         if let Some(old) = self.type_arg_list() {\n-            return replace_children(\n-                self,\n+            return self.replace_children(\n                 single_node(old.syntax().clone()),\n                 iter::once(type_args.syntax().clone().into()),\n             );\n@@ -245,15 +243,15 @@ impl ast::PathSegment {\n             to_insert.push(make::token(T![::]).into());\n         }\n         to_insert.push(type_args.syntax().clone().into());\n-        insert_children(self, InsertPosition::Last, to_insert)\n+        self.insert_children(InsertPosition::Last, to_insert)\n     }\n }\n \n impl ast::UseItem {\n     #[must_use]\n     pub fn with_use_tree(&self, use_tree: ast::UseTree) -> ast::UseItem {\n         if let Some(old) = self.use_tree() {\n-            return replace_descendants(self, iter::once((old, use_tree)));\n+            return self.replace_descendants(iter::once((old, use_tree)));\n         }\n         self.clone()\n     }\n@@ -263,15 +261,15 @@ impl ast::UseTree {\n     #[must_use]\n     pub fn with_path(&self, path: ast::Path) -> ast::UseTree {\n         if let Some(old) = self.path() {\n-            return replace_descendants(self, iter::once((old, path)));\n+            return self.replace_descendants(iter::once((old, path)));\n         }\n         self.clone()\n     }\n \n     #[must_use]\n     pub fn with_use_tree_list(&self, use_tree_list: ast::UseTreeList) -> ast::UseTree {\n         if let Some(old) = self.use_tree_list() {\n-            return replace_descendants(self, iter::once((old, use_tree_list)));\n+            return self.replace_descendants(iter::once((old, use_tree_list)));\n         }\n         self.clone()\n     }\n@@ -295,19 +293,6 @@ fn strip_attrs_and_docs_inner(mut node: SyntaxNode) -> SyntaxNode {\n     node\n }\n \n-#[must_use]\n-pub fn replace_descendants<N: AstNode, D: AstNode>(\n-    parent: &N,\n-    replacement_map: impl IntoIterator<Item = (D, D)>,\n-) -> N {\n-    let map = replacement_map\n-        .into_iter()\n-        .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n-        .collect::<FxHashMap<SyntaxElement, _>>();\n-    let new_syntax = algo::replace_descendants(parent.syntax(), |n| map.get(n).cloned());\n-    N::cast(new_syntax).unwrap()\n-}\n-\n #[derive(Debug, Clone, Copy)]\n pub struct IndentLevel(pub u8);\n \n@@ -411,31 +396,48 @@ fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n     iter::successors(Some(token), |token| token.prev_token())\n }\n \n-#[must_use]\n-fn insert_children<N: AstNode>(\n-    parent: &N,\n-    position: InsertPosition<SyntaxElement>,\n-    to_insert: impl IntoIterator<Item = SyntaxElement>,\n-) -> N {\n-    let new_syntax = algo::insert_children(parent.syntax(), position, to_insert);\n-    N::cast(new_syntax).unwrap()\n+pub trait AstNodeEdit: AstNode + Sized {\n+    #[must_use]\n+    fn insert_children(\n+        &self,\n+        position: InsertPosition<SyntaxElement>,\n+        to_insert: impl IntoIterator<Item = SyntaxElement>,\n+    ) -> Self {\n+        let new_syntax = algo::insert_children(self.syntax(), position, to_insert);\n+        Self::cast(new_syntax).unwrap()\n+    }\n+\n+    #[must_use]\n+    fn replace_children(\n+        &self,\n+        to_replace: RangeInclusive<SyntaxElement>,\n+        to_insert: impl IntoIterator<Item = SyntaxElement>,\n+    ) -> Self {\n+        let new_syntax = algo::replace_children(self.syntax(), to_replace, to_insert);\n+        Self::cast(new_syntax).unwrap()\n+    }\n+\n+    #[must_use]\n+    fn replace_descendants<D: AstNode>(\n+        &self,\n+        replacement_map: impl IntoIterator<Item = (D, D)>,\n+    ) -> Self {\n+        let map = replacement_map\n+            .into_iter()\n+            .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n+            .collect::<FxHashMap<SyntaxElement, _>>();\n+        let new_syntax = algo::replace_descendants(self.syntax(), |n| map.get(n).cloned());\n+        Self::cast(new_syntax).unwrap()\n+    }\n }\n \n+impl<N: AstNode> AstNodeEdit for N {}\n+\n fn single_node(element: impl Into<SyntaxElement>) -> RangeInclusive<SyntaxElement> {\n     let element = element.into();\n     element.clone()..=element\n }\n \n-#[must_use]\n-fn replace_children<N: AstNode>(\n-    parent: &N,\n-    to_replace: RangeInclusive<SyntaxElement>,\n-    to_insert: impl IntoIterator<Item = SyntaxElement>,\n-) -> N {\n-    let new_syntax = algo::replace_children(parent.syntax(), to_replace, to_insert);\n-    N::cast(new_syntax).unwrap()\n-}\n-\n #[test]\n fn test_increase_indent() {\n     let arm_list = {"}]}