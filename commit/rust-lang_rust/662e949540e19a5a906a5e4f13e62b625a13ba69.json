{"sha": "662e949540e19a5a906a5e4f13e62b625a13ba69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MmU5NDk1NDBlMTlhNWE5MDZhNWU0ZjEzZTYyYjYyNWExM2JhNjk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-09T19:27:03Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-09T19:27:03Z"}, "message": "rustc: Alias fix part 1 -- Separate out AST modes from typechecker modes, and introduce an \"either value or alias\" mode", "tree": {"sha": "42bf133c560e0dd3351344c8adcc32fddeae8f5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42bf133c560e0dd3351344c8adcc32fddeae8f5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/662e949540e19a5a906a5e4f13e62b625a13ba69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/662e949540e19a5a906a5e4f13e62b625a13ba69", "html_url": "https://github.com/rust-lang/rust/commit/662e949540e19a5a906a5e4f13e62b625a13ba69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/662e949540e19a5a906a5e4f13e62b625a13ba69/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc879a4e1e72295ad46a482f7abadc41005340e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc879a4e1e72295ad46a482f7abadc41005340e3", "html_url": "https://github.com/rust-lang/rust/commit/bc879a4e1e72295ad46a482f7abadc41005340e3"}], "stats": {"total": 134, "additions": 63, "deletions": 71}, "files": [{"sha": "75d837132b560c38b219cfb64c527a533484e12f", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=662e949540e19a5a906a5e4f13e62b625a13ba69", "patch": "@@ -249,9 +249,9 @@ fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n     assert (next(st) as char == '[');\n     let vec[ty.arg] inputs = vec();\n     while (peek(st) as char != ']') {\n-        auto mode = ast.val;\n+        auto mode = ty.mo_val;\n         if (peek(st) as char == '&') {\n-            mode = ast.alias;\n+            mode = ty.mo_alias;\n             st.pos = st.pos + 1u;\n         }\n         inputs += vec(rec(mode=mode, ty=parse_ty(st, sd)));"}, {"sha": "c4563cf2b19c678ea10ace7924e1a3f605f74286", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=662e949540e19a5a906a5e4f13e62b625a13ba69", "patch": "@@ -241,7 +241,7 @@ mod Encode {\n     fn enc_ty_fn(IO.writer w, @ctxt cx, vec[ty.arg] args, ty.t out) {\n         w.write_char('[');\n         for (ty.arg arg in args) {\n-            if (arg.mode == ast.alias) { w.write_char('&'); }\n+            if (arg.mode == ty.mo_alias) { w.write_char('&'); }\n             enc_ty(w, cx, arg.ty);\n         }\n         w.write_char(']');"}, {"sha": "08cebc58b94b7977c95cd70484c0d60534a8000e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=662e949540e19a5a906a5e4f13e62b625a13ba69", "patch": "@@ -605,12 +605,12 @@ fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(cx.tcx, arg.ty)) {\n-            assert (arg.mode == ast.alias);\n+            assert (arg.mode == ty.mo_alias);\n             atys += vec(T_typaram_ptr(cx.tn));\n         } else {\n             let TypeRef t;\n             alt (arg.mode) {\n-                case (ast.alias) {\n+                case (ty.mo_alias) {\n                     t = T_ptr(type_of_inner(cx, arg.ty));\n                 }\n                 case (_) {\n@@ -675,7 +675,8 @@ fn type_of_fn_full(@crate_ctxt cx,\n         atys +=\n             vec(T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n-                                          vec(rec(mode=ast.alias, ty=output)),\n+                                          vec(rec(mode=ty.mo_alias,\n+                                                  ty=output)),\n                                           ty.mk_nil(cx.tcx), 0u)));\n     }\n \n@@ -829,7 +830,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n     alt (ty.struct(cx.ccx.tcx, arg.ty)) {\n         case (ty.ty_param(_)) {\n-            if (arg.mode == ast.alias) {\n+            if (arg.mode == ty.mo_alias) {\n                 ret T_typaram_ptr(cx.ccx.tn);\n             }\n         }\n@@ -839,7 +840,7 @@ fn type_of_arg(@local_ctxt cx, &ty.arg arg) -> TypeRef {\n     }\n \n     auto typ;\n-    if (arg.mode == ast.alias) {\n+    if (arg.mode == ty.mo_alias) {\n         typ = T_ptr(type_of_inner(cx.ccx, arg.ty));\n     } else {\n         typ = type_of_inner(cx.ccx, arg.ty);\n@@ -3712,7 +3713,7 @@ fn trans_for_each(@block_ctxt cx,\n     auto iter_body_llty =\n         type_of_fn_full(lcx.ccx, ast.proto_fn,\n                         none[TypeRef],\n-                        vec(rec(mode=ast.alias, ty=decl_ty)),\n+                        vec(rec(mode=ty.mo_alias, ty=decl_ty)),\n                         ty.mk_nil(lcx.ccx.tcx), 0u);\n \n     let ValueRef lliterbody = decl_internal_fastcall_fn(lcx.ccx.llmod,\n@@ -4482,7 +4483,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n                 bcx = bound_arg.bcx;\n                 auto val = bound_arg.val;\n \n-                if (out_arg.mode == ast.val) {\n+                if (out_arg.mode == ty.mo_val) {\n                     if (type_is_immediate(cx.ccx, e_ty)) {\n                         val = bcx.build.Load(val);\n                         bcx = take_ty(bcx, val, e_ty).bcx;\n@@ -4492,7 +4493,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n                     }\n                 } else if (ty.type_contains_params(cx.ccx.tcx,\n                                                    out_arg.ty)) {\n-                    assert (out_arg.mode == ast.alias);\n+                    assert (out_arg.mode == ty.mo_alias);\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n \n@@ -4505,7 +4506,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n \n                 if (ty.type_contains_params(cx.ccx.tcx, out_arg.ty)) {\n-                    assert (out_arg.mode == ast.alias);\n+                    assert (out_arg.mode == ty.mo_alias);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n                                                        llout_arg_ty);\n                 }\n@@ -4745,7 +4746,7 @@ fn trans_arg_expr(@block_ctxt cx,\n         auto re = trans_expr(bcx, e);\n         val = re.val;\n         bcx = re.bcx;\n-    } else if (arg.mode == ast.alias) {\n+    } else if (arg.mode == ty.mo_alias) {\n         let lval_result lv;\n         if (ty.is_lval(e)) {\n             lv = trans_lval(bcx, e);\n@@ -4772,13 +4773,13 @@ fn trans_arg_expr(@block_ctxt cx,\n         bcx = re.bcx;\n     }\n \n-    if (arg.mode != ast.alias) {\n+    if (arg.mode != ty.mo_alias) {\n         bcx = take_ty(bcx, val, e_ty).bcx;\n     }\n \n     if (ty.type_contains_params(cx.fcx.lcx.ccx.tcx, arg.ty)) {\n         auto lldestty = lldestty0;\n-        if (arg.mode == ast.val) {\n+        if (arg.mode == ty.mo_val) {\n             // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n             if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n                 lldestty = T_ptr(lldestty);\n@@ -4787,7 +4788,7 @@ fn trans_arg_expr(@block_ctxt cx,\n         val = bcx.build.PointerCast(val, lldestty);\n     }\n \n-    if (arg.mode == ast.val) {\n+    if (arg.mode == ty.mo_val) {\n         // FIXME: we'd prefer to use &&, but rustboot doesn't like it\n         if (ty.type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n             // Until here we've been treating structures by pointer;\n@@ -5496,7 +5497,7 @@ fn trans_put(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n         case (none[@ast.expr]) { }\n         case (some[@ast.expr](?x)) {\n             auto e_ty = ty.expr_ty(cx.fcx.lcx.ccx.tcx, x);\n-            auto arg = rec(mode=ast.alias, ty=e_ty);\n+            auto arg = rec(mode=ty.mo_alias, ty=e_ty);\n             auto arg_tys = type_of_explicit_args(cx.fcx.lcx.ccx, vec(arg));\n             auto r = trans_arg_expr(bcx, arg, arg_tys.(0), x);\n             bcx = r.bcx;\n@@ -6362,10 +6363,7 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n     // Translate obj ctor args to function arguments.\n     let vec[ast.arg] fn_args = vec();\n     for (ast.obj_field f in ob.fields) {\n-        fn_args += vec(rec(mode=ast.alias,\n-                           ty=f.ty,\n-                           ident=f.ident,\n-                           id=f.id));\n+        fn_args += vec(rec(mode=ast.alias, ty=f.ty, ident=f.ident, id=f.id));\n     }\n \n     auto fcx = new_fn_ctxt(cx, llctor_decl);\n@@ -6814,8 +6812,8 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n     fn convert_arg_to_i32(@block_ctxt cx,\n                           ValueRef v,\n                           ty.t t,\n-                          ast.mode mode) -> ValueRef {\n-        if (mode == ast.val) {\n+                          ty.mode mode) -> ValueRef {\n+        if (mode == ty.mo_val) {\n             if (ty.type_is_integral(cx.fcx.lcx.ccx.tcx, t)) {\n                 auto lldsttype = T_int();\n                 auto llsrctype = type_of(cx.fcx.lcx.ccx, t);\n@@ -6875,7 +6873,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n             call_args += vec(llarg);\n         }\n \n-        if (arg.mode == ast.val) {\n+        if (arg.mode == ty.mo_val) {\n             drop_args += vec(tup(llarg, arg.ty));\n         }\n "}, {"sha": "b67f11839f27a83bc128af9076f898e384940a09", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=662e949540e19a5a906a5e4f13e62b625a13ba69", "patch": "@@ -35,7 +35,13 @@ import util.typestate_ann.ts_ann;\n \n // Data types\n \n-type arg = rec(ast.mode mode, t ty);\n+tag mode {\n+    mo_val;\n+    mo_alias;\n+    mo_either;\n+}\n+\n+type arg = rec(mode mode, t ty);\n type field = rec(ast.ident ident, mt mt);\n type method = rec(ast.proto proto,\n                   ast.ident ident,\n@@ -500,12 +506,12 @@ fn path_to_str(&ast.path pth) -> str {\n \n fn ty_to_str(ctxt cx, &t typ) -> str {\n \n-    fn fn_input_to_str(ctxt cx, &rec(ast.mode mode, t ty) input) -> str {\n+    fn fn_input_to_str(ctxt cx, &rec(mode mode, t ty) input) -> str {\n         auto s;\n-        if (mode_is_alias(input.mode)) {\n-            s = \"&\";\n-        } else {\n-            s = \"\";\n+        alt (input.mode) {\n+            case (mo_val) { s = \"\"; }\n+            case (mo_alias) { s = \"&\"; }\n+            case (mo_either) { s = \"?\"; }\n         }\n \n         ret s + ty_to_str(cx, input.ty);\n@@ -827,15 +833,6 @@ fn copy_cname(ctxt cx, t struct_ty, t cname_ty) -> t {\n     ret gen_ty_full(cx, struct(cx, struct_ty), cname_ty.cname);\n }\n \n-// FIXME: remove me when == works on these tags.\n-fn mode_is_alias(ast.mode m) -> bool {\n-    alt (m) {\n-        case (ast.val) { ret false; }\n-        case (ast.alias) { ret true; }\n-    }\n-    fail;\n-}\n-\n fn type_is_nil(ctxt cx, t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_nil) { ret true; }\n@@ -1272,23 +1269,6 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         }\n     }\n \n-    fn equal_mode(ast.mode a, ast.mode b) -> bool {\n-        alt (a) {\n-            case (ast.val) {\n-                alt (b) {\n-                    case (ast.val) { ret true; }\n-                    case (_) { ret false; }\n-                }\n-            }\n-            case (ast.alias) {\n-                alt (b) {\n-                    case (ast.alias) { ret true; }\n-                    case (_) { ret false; }\n-                }\n-            }\n-        }\n-    }\n-\n     fn equal_mt(&mt a, &mt b) -> bool {\n         ret equal_mut(a.mut, b.mut) && eq_ty(a.ty, b.ty);\n     }\n@@ -1303,7 +1283,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         auto i = 0u;\n         while (i < len) {\n             auto arg_a = args_a.(i); auto arg_b = args_b.(i);\n-            if (!equal_mode(arg_a.mode, arg_b.mode)) { ret false; }\n+            if (arg_a.mode != arg_b.mode) { ret false; }\n             if (!eq_ty(arg_a.ty, arg_b.ty)) { ret false; }\n             i += 1u;\n         }\n@@ -2117,12 +2097,13 @@ mod Unify {\n             auto actual_input = actual_inputs.(i);\n \n             // This should be safe, I think?\n+            // FIXME: It's not. At all.\n             auto result_mode;\n-            if (mode_is_alias(expected_input.mode) ||\n-                mode_is_alias(actual_input.mode)) {\n-                result_mode = ast.alias;\n+            if (expected_input.mode == mo_alias ||\n+                    actual_input.mode == mo_alias) {\n+                result_mode = mo_alias;\n             } else {\n-                result_mode = ast.val;\n+                result_mode = mo_val;\n             }\n \n             auto result = unify_step(cx, actual_input.ty, expected_input.ty);"}, {"sha": "aeb5f8a228be83743ba78e79384d59954a2466d4", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=662e949540e19a5a906a5e4f13e62b625a13ba69", "patch": "@@ -19,7 +19,9 @@ import middle.ty.block_ty;\n import middle.ty.expr_ty;\n import middle.ty.field;\n import middle.ty.method;\n-import middle.ty.mode_is_alias;\n+import middle.ty.mo_val;\n+import middle.ty.mo_alias;\n+import middle.ty.mo_either;\n import middle.ty.pat_ty;\n import middle.ty.path_to_str;\n import middle.ty.struct;\n@@ -210,15 +212,25 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n     ret ast.ann_type(t, ty_substs_opt, none[@ts_ann]);\n }\n \n+fn ast_mode_to_mode(ast.mode mode) -> ty.mode {\n+    auto ty_mode;\n+    alt (mode) {\n+        case (ast.val) { ty_mode = mo_val; }\n+        case (ast.alias) { ty_mode = mo_alias; }\n+    }\n+    ret ty_mode;\n+}\n+\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n     fn ast_arg_to_arg(ty.ctxt tcx,\n                       ty_getter getter,\n                       &rec(ast.mode mode, @ast.ty ty) arg)\n-            -> rec(ast.mode mode, ty.t ty) {\n-        ret rec(mode=arg.mode, ty=ast_ty_to_ty(tcx, getter, arg.ty));\n+            -> rec(ty.mode mode, ty.t ty) {\n+        auto ty_mode = ast_mode_to_mode(arg.mode);\n+        ret rec(mode=ty_mode, ty=ast_ty_to_ty(tcx, getter, arg.ty));\n     }\n \n     fn ast_mt_to_mt(ty.ctxt tcx,\n@@ -430,8 +442,9 @@ mod Collect {\n     }\n \n     fn ty_of_arg(@ctxt cx, &ast.arg a) -> arg {\n+        auto ty_mode = ast_mode_to_mode(a.mode);\n         auto f = bind getter(cx, _);\n-        ret rec(mode=a.mode, ty=ast_ty_to_ty(cx.tcx, f, a.ty));\n+        ret rec(mode=ty_mode, ty=ast_ty_to_ty(cx.tcx, f, a.ty));\n     }\n \n     fn ty_of_method(@ctxt cx, &@ast.method m) -> method {\n@@ -468,7 +481,7 @@ mod Collect {\n         for (ast.obj_field f in obj_info.fields) {\n             auto g = bind getter(cx, _);\n             auto t_field = ast_ty_to_ty(cx.tcx, g, f.ty);\n-            Vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n+            Vec.push[arg](t_inputs, rec(mode=ty.mo_alias, ty=t_field));\n         }\n \n         cx.type_cache.insert(obj_ty_id, t_obj);\n@@ -601,7 +614,7 @@ mod Collect {\n                 let vec[arg] args = vec();\n                 for (ast.variant_arg va in variant.node.args) {\n                     auto arg_ty = ast_ty_to_ty(cx.tcx, f, va.ty);\n-                    args += vec(rec(mode=ast.alias, ty=arg_ty));\n+                    args += vec(rec(mode=ty.mo_alias, ty=arg_ty));\n                 }\n                 auto tag_t = ty.mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 result_ty = ty.mk_fn(cx.tcx, ast.proto_fn, args, tag_t);\n@@ -1754,7 +1767,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                     args_0 += vec(some[@ast.expr](a_0));\n \n                     // FIXME: this breaks aliases. We need a ty_fn_arg.\n-                    auto arg_ty = rec(mode=ast.val,\n+                    auto arg_ty = rec(mode=mo_val,\n                                       ty=expr_ty(fcx.ccx.tcx, a_0));\n                     Vec.push[arg](arg_tys_0, arg_ty);\n                 }\n@@ -1763,7 +1776,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                     // FIXME: breaks aliases too?\n                     auto typ = next_ty_var(fcx.ccx);\n-                    Vec.push[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n+                    Vec.push[arg](arg_tys_0, rec(mode=mo_val, ty=typ));\n                 }\n             }\n         }\n@@ -2869,7 +2882,7 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, ast.ident ident, &ast._fn f,\n     let vec[arg] inputs = vec();\n     for (ast.arg arg in f.decl.inputs) {\n         auto input_ty = ast_ty_to_ty_crate(ccx, arg.ty);\n-        inputs += vec(rec(mode=arg.mode, ty=input_ty));\n+        inputs += vec(rec(mode=ast_mode_to_mode(arg.mode), ty=input_ty));\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);"}, {"sha": "d767672f7ab0bcbd6dfcdc16284e4833cf1d01d3", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/662e949540e19a5a906a5e4f13e62b625a13ba69/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=662e949540e19a5a906a5e4f13e62b625a13ba69", "patch": "@@ -939,7 +939,7 @@ fn print_ty_fn(ps s, ast.proto proto, Option.t[str] id,\n     }\n     popen_h(s);\n     fn print_arg(ps s, &ast.ty_arg input) {\n-        if (middle.ty.mode_is_alias(input.mode)) {wrd(s.s, \"&\");}\n+        if (input.mode == ast.alias) {wrd(s.s, \"&\");}\n         print_type(s, input.ty);\n     }\n     auto f = print_arg;"}]}