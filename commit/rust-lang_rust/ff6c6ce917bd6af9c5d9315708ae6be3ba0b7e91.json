{"sha": "ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmNmM2Y2U5MTdiZDZhZjljNWQ5MzE1NzA4YWU2YmUzYmEwYjdlOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-28T05:38:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-28T05:38:53Z"}, "message": "Auto merge of #27280 - bluss:siphash-perf, r=alexcrichton\n\nImprove siphash performance for longer data\r\n\r\nUse `ptr::copy_nonoverlapping` (aka memcpy) to load an u64 from the\r\nbyte stream. This is correct for any alignment, and the compiler will\r\nuse the appropriate instruction to load the data.\r\n\r\nAlso contains small tweaks that should benefit hashing short data too,\r\nboth the commit that removes a variable and the autovectorization of\r\nthe hash state initialization (in SipHash::reset).\r\n\r\nBenchmarks show that hashing longer data benefits for the improved word loading.\r\n\r\nBefore (using benchmarks from the first commit in the PR):\r\n\r\nThe before benchmark is a bit noisy.\r\n\r\n```\r\ntest hash::sip::bench_bytes_4                              ... bench:          41 ns/iter (+/- 0) = 97 MB/s\r\ntest hash::sip::bench_bytes_7                              ... bench:          49 ns/iter (+/- 2) = 142 MB/s\r\ntest hash::sip::bench_bytes_8                              ... bench:          42 ns/iter (+/- 4) = 190 MB/s\r\ntest hash::sip::bench_bytes_a_16                           ... bench:          57 ns/iter (+/- 14) = 280 MB/s\r\ntest hash::sip::bench_bytes_b_32                           ... bench:          85 ns/iter (+/- 74) = 376 MB/s\r\ntest hash::sip::bench_bytes_c_128                          ... bench:         278 ns/iter (+/- 33) = 460 MB/s\r\ntest hash::sip::bench_long_str                             ... bench:         825 ns/iter (+/- 103)\r\ntest hash::sip::bench_str_of_8_bytes                       ... bench:         151 ns/iter (+/- 66)\r\ntest hash::sip::bench_str_over_8_bytes                     ... bench:          59 ns/iter (+/- 3)\r\ntest hash::sip::bench_str_under_8_bytes                    ... bench:          47 ns/iter (+/- 56)\r\ntest hash::sip::bench_u32                                  ... bench:          39 ns/iter (+/- 93) = 205 MB/s\r\ntest hash::sip::bench_u32_keyed                            ... bench:          40 ns/iter (+/- 88) = 200 MB/s\r\ntest hash::sip::bench_u64                                  ... bench:          54 ns/iter (+/- 96) = 148 MB/s\r\n```\r\n\r\nAfter:\r\n\r\n```\r\ntest hash::sip::bench_bytes_4                              ... bench:          41 ns/iter (+/- 3) = 97 MB/s\r\ntest hash::sip::bench_bytes_7                              ... bench:          48 ns/iter (+/- 0) = 145 MB/s\r\ntest hash::sip::bench_bytes_8                              ... bench:          35 ns/iter (+/- 1) = 228 MB/s\r\ntest hash::sip::bench_bytes_a_16                           ... bench:          45 ns/iter (+/- 1) = 355 MB/s\r\ntest hash::sip::bench_bytes_b_32                           ... bench:          60 ns/iter (+/- 0) = 533 MB/s\r\ntest hash::sip::bench_bytes_c_128                          ... bench:         161 ns/iter (+/- 5) = 795 MB/s\r\ntest hash::sip::bench_long_str                             ... bench:         514 ns/iter (+/- 5)\r\ntest hash::sip::bench_str_of_8_bytes                       ... bench:          44 ns/iter (+/- 0)\r\ntest hash::sip::bench_str_over_8_bytes                     ... bench:          51 ns/iter (+/- 0)\r\ntest hash::sip::bench_str_under_8_bytes                    ... bench:          52 ns/iter (+/- 6)\r\ntest hash::sip::bench_u32                                  ... bench:          40 ns/iter (+/- 2) = 200 MB/s\r\ntest hash::sip::bench_u32_keyed                            ... bench:          39 ns/iter (+/- 1) = 205 MB/s\r\ntest hash::sip::bench_u64                                  ... bench:          36 ns/iter (+/- 1) = 222 MB/s\r\n```", "tree": {"sha": "e776547b1684622690f605dbfa84beb34e15a9c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e776547b1684622690f605dbfa84beb34e15a9c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91", "html_url": "https://github.com/rust-lang/rust/commit/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ca511cf63c3611ffae9218945724c1b32025688", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca511cf63c3611ffae9218945724c1b32025688", "html_url": "https://github.com/rust-lang/rust/commit/9ca511cf63c3611ffae9218945724c1b32025688"}, {"sha": "27c44ce9c3be36d49b829e3dfbdcc983bddd727d", "url": "https://api.github.com/repos/rust-lang/rust/commits/27c44ce9c3be36d49b829e3dfbdcc983bddd727d", "html_url": "https://github.com/rust-lang/rust/commit/27c44ce9c3be36d49b829e3dfbdcc983bddd727d"}], "stats": {"total": 116, "additions": 109, "deletions": 7}, "files": [{"sha": "93bdadff549ae5398d49bb2a3b84393fb10b06df", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91", "patch": "@@ -10,6 +10,7 @@\n \n //! An implementation of SipHash 2-4.\n \n+use ptr;\n use prelude::*;\n use super::Hasher;\n \n@@ -31,9 +32,13 @@ pub struct SipHasher {\n     k0: u64,\n     k1: u64,\n     length: usize, // how many bytes we've processed\n+    // v0, v2 and v1, v3 show up in pairs in the algorithm,\n+    // and simd implementations of SipHash will use vectors\n+    // of v02 and v13. By placing them in this order in the struct,\n+    // the compiler can pick up on just a few simd optimizations by itself.\n     v0: u64,      // hash state\n-    v1: u64,\n     v2: u64,\n+    v1: u64,\n     v3: u64,\n     tail: u64, // unprocessed bytes le\n     ntail: usize,  // how many bytes in tail are valid\n@@ -65,6 +70,20 @@ macro_rules! u8to64_le {\n     });\n }\n \n+/// Load a full u64 word from a byte stream, in LE order. Use\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load u64 from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+8\n+#[inline]\n+unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n+    debug_assert!(i + 8 <= buf.len());\n+    let mut data = 0u64;\n+    ptr::copy_nonoverlapping(buf.get_unchecked(i),\n+                             &mut data as *mut _ as *mut u8, 8);\n+    data.to_le()\n+}\n+\n macro_rules! rotl {\n     ($x:expr, $b:expr) =>\n     (($x << $b) | ($x >> (64_i32.wrapping_sub($b))))\n@@ -146,12 +165,11 @@ impl SipHasher {\n \n         // Buffered tail is now flushed, process new input.\n         let len = length - needed;\n-        let end = len & (!0x7);\n         let left = len & 0x7;\n \n         let mut i = needed;\n-        while i < end {\n-            let mi = u8to64_le!(msg, i);\n+        while i < len - left {\n+            let mi = unsafe { load_u64_le(msg, i) };\n \n             self.v3 ^= mi;\n             compress!(self.v0, self.v1, self.v2, self.v3);"}, {"sha": "9b6cedd25b741a43071d70c2d71f59bf47388dcb", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 87, "deletions": 3, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=ff6c6ce917bd6af9c5d9315708ae6be3ba0b7e91", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use test::Bencher;\n+use test::{Bencher, black_box};\n \n use core::hash::{Hash, Hasher};\n use core::hash::SipHasher;\n@@ -57,6 +57,12 @@ fn hash_with_keys<T: Hash>(k1: u64, k2: u64, x: &T) -> u64 {\n     st.finish()\n }\n \n+fn hash_bytes(x: &[u8]) -> u64 {\n+    let mut s = SipHasher::default();\n+    Hasher::write(&mut s, x);\n+    s.finish()\n+}\n+\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash() {\n@@ -266,10 +272,88 @@ officia deserunt mollit anim id est laborum.\";\n     })\n }\n \n+#[bench]\n+fn bench_u32(b: &mut Bencher) {\n+    let u = 162629500u32;\n+    let u = black_box(u);\n+    b.iter(|| {\n+        hash(&u)\n+    });\n+    b.bytes = 8;\n+}\n+\n+#[bench]\n+fn bench_u32_keyed(b: &mut Bencher) {\n+    let u = 162629500u32;\n+    let u = black_box(u);\n+    let k1 = black_box(0x1);\n+    let k2 = black_box(0x2);\n+    b.iter(|| {\n+        hash_with_keys(k1, k2, &u)\n+    });\n+    b.bytes = 8;\n+}\n+\n #[bench]\n fn bench_u64(b: &mut Bencher) {\n     let u = 16262950014981195938u64;\n+    let u = black_box(u);\n     b.iter(|| {\n-        assert_eq!(hash(&u), 5254097107239593357);\n-    })\n+        hash(&u)\n+    });\n+    b.bytes = 8;\n+}\n+\n+#[bench]\n+fn bench_bytes_4(b: &mut Bencher) {\n+    let data = black_box([b' '; 4]);\n+    b.iter(|| {\n+        hash_bytes(&data)\n+    });\n+    b.bytes = 4;\n+}\n+\n+#[bench]\n+fn bench_bytes_7(b: &mut Bencher) {\n+    let data = black_box([b' '; 7]);\n+    b.iter(|| {\n+        hash_bytes(&data)\n+    });\n+    b.bytes = 7;\n+}\n+\n+#[bench]\n+fn bench_bytes_8(b: &mut Bencher) {\n+    let data = black_box([b' '; 8]);\n+    b.iter(|| {\n+        hash_bytes(&data)\n+    });\n+    b.bytes = 8;\n+}\n+\n+#[bench]\n+fn bench_bytes_a_16(b: &mut Bencher) {\n+    let data = black_box([b' '; 16]);\n+    b.iter(|| {\n+        hash_bytes(&data)\n+    });\n+    b.bytes = 16;\n+}\n+\n+#[bench]\n+fn bench_bytes_b_32(b: &mut Bencher) {\n+    let data = black_box([b' '; 32]);\n+    b.iter(|| {\n+        hash_bytes(&data)\n+    });\n+    b.bytes = 32;\n+}\n+\n+#[bench]\n+fn bench_bytes_c_128(b: &mut Bencher) {\n+    let data = black_box([b' '; 128]);\n+    b.iter(|| {\n+        hash_bytes(&data)\n+    });\n+    b.bytes = 128;\n }"}]}