{"sha": "3b0d4813ab461ec81eab8980bb884691c97c5a35", "node_id": "C_kwDOAAsO6NoAKDNiMGQ0ODEzYWI0NjFlYzgxZWFiODk4MGJiODg0NjkxYzk3YzVhMzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T21:28:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T21:28:24Z"}, "message": "Auto merge of #98187 - mystor:fast_span_call_site, r=eddyb\n\nproc_macro/bridge: cache static spans in proc_macro's client thread-local state\n\nThis is the second part of https://github.com/rust-lang/rust/pull/86822, split off as requested in https://github.com/rust-lang/rust/pull/86822#pullrequestreview-1008655452. This patch removes the RPC calls required for the very common operations of `Span::call_site()`, `Span::def_site()` and `Span::mixed_site()`.\n\nSome notes:\n\nThis part is one of the ones I don't love as a final solution from a design standpoint, because I don't like how the spans are serialized immediately at macro invocation. I think a more elegant solution might've been to reserve special IDs for `call_site`, `def_site`, and `mixed_site` at compile time (either starting at 1 or from `u32::MAX`) and making reading a Span handle automatically map these IDs to the relevant values, rather than doing extra serialization.\n\nThis would also have an advantage for potential future work to allow `proc_macro` to operate more independently from the compiler (e.g. to reduce the necessity of `proc-macro2`), as methods like `Span::call_site()` could be made to function without access to the compiler backend.\n\nThat was unfortunately tricky to do at the time, as this was the first part I wrote of the patches. After the later part (#98188, #98189), the other uses of `InternedStore` are removed meaning that a custom serialization strategy for `Span` is easier to implement.\n\nIf we want to go that path, we'll still need the majority of the work to split the bridge object and introduce the `Context` trait for free methods, and it will be easier to do after `Span` is the only user of `InternedStore` (after #98189).", "tree": {"sha": "e8deb2a029e36304d2fd6cebbf00659fc4d92576", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8deb2a029e36304d2fd6cebbf00659fc4d92576"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b0d4813ab461ec81eab8980bb884691c97c5a35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0d4813ab461ec81eab8980bb884691c97c5a35", "html_url": "https://github.com/rust-lang/rust/commit/3b0d4813ab461ec81eab8980bb884691c97c5a35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b0d4813ab461ec81eab8980bb884691c97c5a35/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c80c4b8fdcf3da69cd483e2fec172c9b1f95842c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c80c4b8fdcf3da69cd483e2fec172c9b1f95842c", "html_url": "https://github.com/rust-lang/rust/commit/c80c4b8fdcf3da69cd483e2fec172c9b1f95842c"}, {"sha": "e32ee19b3a03acd2dbd427c12cb4bcfd0c5d9881", "url": "https://api.github.com/repos/rust-lang/rust/commits/e32ee19b3a03acd2dbd427c12cb4bcfd0c5d9881", "html_url": "https://github.com/rust-lang/rust/commit/e32ee19b3a03acd2dbd427c12cb4bcfd0c5d9881"}], "stats": {"total": 270, "additions": 168, "deletions": 102}, "files": [{"sha": "6b9bc0ab54bf3b6d2bbfae29e32cb519ba31ca79", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3b0d4813ab461ec81eab8980bb884691c97c5a35/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0d4813ab461ec81eab8980bb884691c97c5a35/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=3b0d4813ab461ec81eab8980bb884691c97c5a35", "patch": "@@ -14,7 +14,7 @@ use rustc_span::def_id::CrateNum;\n use rustc_span::symbol::{self, kw, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n \n-use pm::bridge::{server, TokenTree};\n+use pm::bridge::{server, ExpnGlobals, TokenTree};\n use pm::{Delimiter, Level, LineColumn, Spacing};\n use std::ops::Bound;\n use std::{ascii, panic};\n@@ -370,7 +370,7 @@ impl<'a, 'b> Rustc<'a, 'b> {\n     }\n \n     fn lit(&mut self, kind: token::LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Literal {\n-        Literal { lit: token::Lit::new(kind, symbol, suffix), span: server::Span::call_site(self) }\n+        Literal { lit: token::Lit::new(kind, symbol, suffix), span: self.call_site }\n     }\n }\n \n@@ -547,7 +547,7 @@ impl server::Group for Rustc<'_, '_> {\n         Group {\n             delimiter,\n             stream: stream.unwrap_or_default(),\n-            span: DelimSpan::from_single(server::Span::call_site(self)),\n+            span: DelimSpan::from_single(self.call_site),\n             flatten: false,\n         }\n     }\n@@ -579,7 +579,7 @@ impl server::Group for Rustc<'_, '_> {\n \n impl server::Punct for Rustc<'_, '_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n-        Punct::new(ch, spacing == Spacing::Joint, server::Span::call_site(self))\n+        Punct::new(ch, spacing == Spacing::Joint, self.call_site)\n     }\n \n     fn as_char(&mut self, punct: Self::Punct) -> char {\n@@ -829,18 +829,6 @@ impl server::Span for Rustc<'_, '_> {\n         }\n     }\n \n-    fn def_site(&mut self) -> Self::Span {\n-        self.def_site\n-    }\n-\n-    fn call_site(&mut self) -> Self::Span {\n-        self.call_site\n-    }\n-\n-    fn mixed_site(&mut self) -> Self::Span {\n-        self.mixed_site\n-    }\n-\n     fn source_file(&mut self, span: Self::Span) -> Self::SourceFile {\n         self.sess().source_map().lookup_char_pos(span.lo()).file\n     }\n@@ -926,3 +914,13 @@ impl server::Span for Rustc<'_, '_> {\n         })\n     }\n }\n+\n+impl server::Server for Rustc<'_, '_> {\n+    fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n+        ExpnGlobals {\n+            def_site: self.def_site,\n+            call_site: self.call_site,\n+            mixed_site: self.mixed_site,\n+        }\n+    }\n+}"}, {"sha": "74b4a91662bb550587e706cdc58c676904ba0106", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 85, "deletions": 55, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=3b0d4813ab461ec81eab8980bb884691c97c5a35", "patch": "@@ -230,6 +230,20 @@ impl Clone for SourceFile {\n     }\n }\n \n+impl Span {\n+    pub(crate) fn def_site() -> Span {\n+        Bridge::with(|bridge| bridge.globals.def_site)\n+    }\n+\n+    pub(crate) fn call_site() -> Span {\n+        Bridge::with(|bridge| bridge.globals.call_site)\n+    }\n+\n+    pub(crate) fn mixed_site() -> Span {\n+        Bridge::with(|bridge| bridge.globals.mixed_site)\n+    }\n+}\n+\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.debug())\n@@ -263,6 +277,21 @@ macro_rules! define_client_side {\n }\n with_api!(self, self, define_client_side);\n \n+struct Bridge<'a> {\n+    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n+    /// used for making requests.\n+    cached_buffer: Buffer,\n+\n+    /// Server-side function that the client uses to make requests.\n+    dispatch: closure::Closure<'a, Buffer, Buffer>,\n+\n+    /// Provided globals for this macro expansion.\n+    globals: ExpnGlobals<Span>,\n+}\n+\n+impl<'a> !Send for Bridge<'a> {}\n+impl<'a> !Sync for Bridge<'a> {}\n+\n enum BridgeState<'a> {\n     /// No server is currently connected to this client.\n     NotConnected,\n@@ -305,34 +334,6 @@ impl BridgeState<'_> {\n }\n \n impl Bridge<'_> {\n-    pub(crate) fn is_available() -> bool {\n-        BridgeState::with(|state| match state {\n-            BridgeState::Connected(_) | BridgeState::InUse => true,\n-            BridgeState::NotConnected => false,\n-        })\n-    }\n-\n-    fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n-        let force_show_panics = self.force_show_panics;\n-        // Hide the default panic output within `proc_macro` expansions.\n-        // NB. the server can't do this because it may use a different libstd.\n-        static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n-        HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n-            let prev = panic::take_hook();\n-            panic::set_hook(Box::new(move |info| {\n-                let show = BridgeState::with(|state| match state {\n-                    BridgeState::NotConnected => true,\n-                    BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n-                });\n-                if show {\n-                    prev(info)\n-                }\n-            }));\n-        });\n-\n-        BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n-    }\n-\n     fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n         BridgeState::with(|state| match state {\n             BridgeState::NotConnected => {\n@@ -346,6 +347,13 @@ impl Bridge<'_> {\n     }\n }\n \n+pub(crate) fn is_available() -> bool {\n+    BridgeState::with(|state| match state {\n+        BridgeState::Connected(_) | BridgeState::InUse => true,\n+        BridgeState::NotConnected => false,\n+    })\n+}\n+\n /// A client-side RPC entry-point, which may be using a different `proc_macro`\n /// from the one used by the server, but can be invoked compatibly.\n ///\n@@ -363,7 +371,7 @@ pub struct Client<I, O> {\n     // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n \n-    pub(super) run: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+    pub(super) run: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n \n     pub(super) _marker: PhantomData<fn(I) -> O>,\n }\n@@ -375,40 +383,62 @@ impl<I, O> Clone for Client<I, O> {\n     }\n }\n \n+fn maybe_install_panic_hook(force_show_panics: bool) {\n+    // Hide the default panic output within `proc_macro` expansions.\n+    // NB. the server can't do this because it may use a different libstd.\n+    static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n+    HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n+        let prev = panic::take_hook();\n+        panic::set_hook(Box::new(move |info| {\n+            let show = BridgeState::with(|state| match state {\n+                BridgeState::NotConnected => true,\n+                BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n+            });\n+            if show {\n+                prev(info)\n+            }\n+        }));\n+    });\n+}\n+\n /// Client-side helper for handling client panics, entering the bridge,\n /// deserializing input and serializing output.\n // FIXME(eddyb) maybe replace `Bridge::enter` with this?\n fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n-    mut bridge: Bridge<'_>,\n+    config: BridgeConfig<'_>,\n     f: impl FnOnce(A) -> R,\n ) -> Buffer {\n-    // The initial `cached_buffer` contains the input.\n-    let mut buf = bridge.cached_buffer.take();\n+    let BridgeConfig { input: mut buf, dispatch, force_show_panics, .. } = config;\n \n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        bridge.enter(|| {\n-            let reader = &mut &buf[..];\n-            let input = A::decode(reader, &mut ());\n-\n-            // Put the `cached_buffer` back in the `Bridge`, for requests.\n-            Bridge::with(|bridge| bridge.cached_buffer = buf.take());\n-\n-            let output = f(input);\n-\n-            // Take the `cached_buffer` back out, for the output value.\n-            buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n-\n-            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n-            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n-            // having handles outside the `bridge.enter(|| ...)` scope, and\n-            // to catch panics that could happen while encoding the success.\n-            //\n-            // Note that panics should be impossible beyond this point, but\n-            // this is defensively trying to avoid any accidental panicking\n-            // reaching the `extern \"C\"` (which should `abort` but might not\n-            // at the moment, so this is also potentially preventing UB).\n-            buf.clear();\n-            Ok::<_, ()>(output).encode(&mut buf, &mut ());\n+        maybe_install_panic_hook(force_show_panics);\n+\n+        let reader = &mut &buf[..];\n+        let (globals, input) = <(ExpnGlobals<Span>, A)>::decode(reader, &mut ());\n+\n+        // Put the buffer we used for input back in the `Bridge` for requests.\n+        let new_state =\n+            BridgeState::Connected(Bridge { cached_buffer: buf.take(), dispatch, globals });\n+\n+        BRIDGE_STATE.with(|state| {\n+            state.set(new_state, || {\n+                let output = f(input);\n+\n+                // Take the `cached_buffer` back out, for the output value.\n+                buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n+\n+                // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n+                // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n+                // having handles outside the `bridge.enter(|| ...)` scope, and\n+                // to catch panics that could happen while encoding the success.\n+                //\n+                // Note that panics should be impossible beyond this point, but\n+                // this is defensively trying to avoid any accidental panicking\n+                // reaching the `extern \"C\"` (which should `abort` but might not\n+                // at the moment, so this is also potentially preventing UB).\n+                buf.clear();\n+                Ok::<_, ()>(output).encode(&mut buf, &mut ());\n+            })\n         })\n     }))\n     .map_err(PanicMessage::from)"}, {"sha": "3bdc9007cd2e9b133b3ced391e7ea218c8955f6f", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=3b0d4813ab461ec81eab8980bb884691c97c5a35", "patch": "@@ -151,9 +151,6 @@ macro_rules! with_api {\n             },\n             Span {\n                 fn debug($self: $S::Span) -> String;\n-                fn def_site() -> $S::Span;\n-                fn call_site() -> $S::Span;\n-                fn mixed_site() -> $S::Span;\n                 fn source_file($self: $S::Span) -> $S::SourceFile;\n                 fn parent($self: $S::Span) -> Option<$S::Span>;\n                 fn source($self: $S::Span) -> $S::Span;\n@@ -213,16 +210,15 @@ use buffer::Buffer;\n pub use rpc::PanicMessage;\n use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n \n-/// An active connection between a server and a client.\n-/// The server creates the bridge (`Bridge::run_server` in `server.rs`),\n-/// then passes it to the client through the function pointer in the `run`\n-/// field of `client::Client`. The client holds its copy of the `Bridge`\n+/// Configuration for establishing an active connection between a server and a\n+/// client.  The server creates the bridge config (`run_server` in `server.rs`),\n+/// then passes it to the client through the function pointer in the `run` field\n+/// of `client::Client`. The client constructs a local `Bridge` from the config\n /// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n #[repr(C)]\n-pub struct Bridge<'a> {\n-    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n-    /// used for making requests, but also for passing input to client.\n-    cached_buffer: Buffer,\n+pub struct BridgeConfig<'a> {\n+    /// Buffer used to pass initial input to the client.\n+    input: Buffer,\n \n     /// Server-side function that the client uses to make requests.\n     dispatch: closure::Closure<'a, Buffer, Buffer>,\n@@ -379,6 +375,25 @@ rpc_encode_decode!(\n );\n \n macro_rules! mark_compound {\n+    (struct $name:ident <$($T:ident),+> { $($field:ident),* $(,)? }) => {\n+        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n+            type Unmarked = $name <$($T::Unmarked),+>;\n+            fn mark(unmarked: Self::Unmarked) -> Self {\n+                $name {\n+                    $($field: Mark::mark(unmarked.$field)),*\n+                }\n+            }\n+        }\n+\n+        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n+            type Unmarked = $name <$($T::Unmarked),+>;\n+            fn unmark(self) -> Self::Unmarked {\n+                $name {\n+                    $($field: Unmark::unmark(self.$field)),*\n+                }\n+            }\n+        }\n+    };\n     (enum $name:ident <$($T:ident),+> { $($variant:ident $(($field:ident))?),* $(,)? }) => {\n         impl<$($T: Mark),+> Mark for $name <$($T),+> {\n             type Unmarked = $name <$($T::Unmarked),+>;\n@@ -449,3 +464,16 @@ compound_traits!(\n         Literal(tt),\n     }\n );\n+\n+/// Globals provided alongside the initial inputs for a macro expansion.\n+/// Provides values such as spans which are used frequently to avoid RPC.\n+#[derive(Clone)]\n+pub struct ExpnGlobals<S> {\n+    pub def_site: S,\n+    pub call_site: S,\n+    pub mixed_site: S,\n+}\n+\n+compound_traits!(\n+    struct ExpnGlobals<Sp> { def_site, call_site, mixed_site }\n+);"}, {"sha": "907ad256e4b432683671ffdb7158b71e2f774b7b", "filename": "library/proc_macro/src/bridge/selfless_reify.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs?ref=3b0d4813ab461ec81eab8980bb884691c97c5a35", "patch": "@@ -75,9 +75,10 @@ macro_rules! define_reify_functions {\n define_reify_functions! {\n     fn _reify_to_extern_c_fn_unary<A, R> for extern \"C\" fn(arg: A) -> R;\n \n-    // HACK(eddyb) this abstraction is used with `for<'a> fn(Bridge<'a>) -> T`\n-    // but that doesn't work with just `reify_to_extern_c_fn_unary` because of\n-    // the `fn` pointer type being \"higher-ranked\" (i.e. the `for<'a>` binder).\n-    // FIXME(eddyb) try to remove the lifetime from `Bridge`, that'd help.\n-    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::Bridge<'_>) -> R;\n+    // HACK(eddyb) this abstraction is used with `for<'a> fn(BridgeConfig<'a>)\n+    // -> T` but that doesn't work with just `reify_to_extern_c_fn_unary`\n+    // because of the `fn` pointer type being \"higher-ranked\" (i.e. the\n+    // `for<'a>` binder).\n+    // FIXME(eddyb) try to remove the lifetime from `BridgeConfig`, that'd help.\n+    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::BridgeConfig<'_>) -> R;\n }"}, {"sha": "1b7657eab703400f598afeb9c49f9392b0ad0b93", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=3b0d4813ab461ec81eab8980bb884691c97c5a35", "patch": "@@ -38,14 +38,21 @@ macro_rules! declare_server_traits {\n             $(associated_fn!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n         })*\n \n-        pub trait Server: Types $(+ $name)* {}\n-        impl<S: Types $(+ $name)*> Server for S {}\n+        pub trait Server: Types $(+ $name)* {\n+            fn globals(&mut self) -> ExpnGlobals<Self::Span>;\n+        }\n     }\n }\n with_api!(Self, self_, declare_server_traits);\n \n pub(super) struct MarkedTypes<S: Types>(S);\n \n+impl<S: Server> Server for MarkedTypes<S> {\n+    fn globals(&mut self) -> ExpnGlobals<Self::Span> {\n+        <_>::mark(Server::globals(&mut self.0))\n+    }\n+}\n+\n macro_rules! define_mark_types_impls {\n     ($($name:ident {\n         $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n@@ -120,7 +127,7 @@ pub trait ExecutionStrategy {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer;\n }\n@@ -132,13 +139,13 @@ impl ExecutionStrategy for SameThread {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         let mut dispatch = |buf| dispatcher.dispatch(buf);\n \n-        run_client(Bridge {\n-            cached_buffer: input,\n+        run_client(BridgeConfig {\n+            input,\n             dispatch: (&mut dispatch).into(),\n             force_show_panics,\n             _marker: marker::PhantomData,\n@@ -156,7 +163,7 @@ impl ExecutionStrategy for CrossThread1 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         use std::sync::mpsc::channel;\n@@ -170,8 +177,8 @@ impl ExecutionStrategy for CrossThread1 {\n                 res_rx.recv().unwrap()\n             };\n \n-            run_client(Bridge {\n-                cached_buffer: input,\n+            run_client(BridgeConfig {\n+                input,\n                 dispatch: (&mut dispatch).into(),\n                 force_show_panics,\n                 _marker: marker::PhantomData,\n@@ -193,7 +200,7 @@ impl ExecutionStrategy for CrossThread2 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         use std::sync::{Arc, Mutex};\n@@ -219,8 +226,8 @@ impl ExecutionStrategy for CrossThread2 {\n                 }\n             };\n \n-            let r = run_client(Bridge {\n-                cached_buffer: input,\n+            let r = run_client(BridgeConfig {\n+                input,\n                 dispatch: (&mut dispatch).into(),\n                 force_show_panics,\n                 _marker: marker::PhantomData,\n@@ -258,14 +265,16 @@ fn run_server<\n     handle_counters: &'static client::HandleCounters,\n     server: S,\n     input: I,\n-    run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+    run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n     force_show_panics: bool,\n ) -> Result<O, PanicMessage> {\n     let mut dispatcher =\n         Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n \n+    let globals = dispatcher.server.globals();\n+\n     let mut buf = Buffer::new();\n-    input.encode(&mut buf, &mut dispatcher.handle_store);\n+    (globals, input).encode(&mut buf, &mut dispatcher.handle_store);\n \n     buf = strategy.run_bridge_and_client(&mut dispatcher, buf, run_client, force_show_panics);\n "}, {"sha": "771ee50e138617fc1528b680664f04b3b9f15bc5", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0d4813ab461ec81eab8980bb884691c97c5a35/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=3b0d4813ab461ec81eab8980bb884691c97c5a35", "patch": "@@ -60,7 +60,7 @@ use std::{error, fmt, iter};\n /// inside of a procedural macro, false if invoked from any other binary.\n #[stable(feature = \"proc_macro_is_available\", since = \"1.57.0\")]\n pub fn is_available() -> bool {\n-    bridge::Bridge::is_available()\n+    bridge::client::is_available()\n }\n \n /// The main type provided by this crate, representing an abstract stream of"}]}