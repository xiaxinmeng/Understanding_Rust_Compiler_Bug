{"sha": "4a6c9463683b5903de5e13c59b48914206754152", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNmM5NDYzNjgzYjU5MDNkZTVlMTNjNTliNDg5MTQyMDY3NTQxNTI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-12T23:57:38Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-15T13:21:03Z"}, "message": "Generalise cases of explicit iteration of specific kinds", "tree": {"sha": "8568d75b093af9a9ab7e73e6c5dd3c3ec5f786e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8568d75b093af9a9ab7e73e6c5dd3c3ec5f786e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a6c9463683b5903de5e13c59b48914206754152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a6c9463683b5903de5e13c59b48914206754152", "html_url": "https://github.com/rust-lang/rust/commit/4a6c9463683b5903de5e13c59b48914206754152", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a6c9463683b5903de5e13c59b48914206754152/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cadf96e8e1523ed5928fd476f34e1b34c445afbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/cadf96e8e1523ed5928fd476f34e1b34c445afbe", "html_url": "https://github.com/rust-lang/rust/commit/cadf96e8e1523ed5928fd476f34e1b34c445afbe"}], "stats": {"total": 329, "additions": 210, "deletions": 119}, "files": [{"sha": "5b6b0284de5204deb88103ed8e617682da1fb588", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -374,8 +374,8 @@ impl<'a> LoweringContext<'a> {\n \n                 if item_lowered {\n                     let item_lifetimes = match self.lctx.items.get(&item.id).unwrap().node {\n-                        hir::Item_::ItemImpl(_, _, _, ref generics, ..)\n-                        | hir::Item_::ItemTrait(_, _, ref generics, ..) => {\n+                        hir::Item_::ItemImpl(_, _, _, ref generics, .. ) |\n+                        hir::Item_::ItemTrait(_, _, ref generics, .. ) => {\n                             generics.lifetimes().cloned().collect::<Vec<_>>()\n                         }\n                         _ => Vec::new(),"}, {"sha": "a12506afb21f3e1017b60f13fba7759ee1e6929b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -667,8 +667,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for lt_def in generics.lifetimes() {\n                     let (lt_name, region) = Region::early(&self.tcx.hir, &mut index, &lt_def);\n                     if let hir::LifetimeName::Underscore = lt_name {\n-                        // Pick the elided lifetime \"definition\" if one exists and use it to make an\n-                        // elision scope.\n+                        // Pick the elided lifetime \"definition\" if one exists and use it to make\n+                        // an elision scope.\n                         elision = Some(region);\n                     } else {\n                         lifetimes.insert(lt_name, region);"}, {"sha": "0dfb4572c35affca5ad0f22b2c375f2833b775b4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -382,8 +382,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             let name = param.name.to_string();\n             let ty = trait_ref.substs.type_for_def(param);\n             let ty_str = ty.to_string();\n-            flags.push((name.clone(),\n-                        Some(ty_str.clone())));\n+            flags.push((name.clone(), Some(ty_str.clone())));\n         }\n \n         if let Some(true) = self_ty.ty_to_def_id().map(|def_id| def_id.is_local()) {"}, {"sha": "3fc95e9518fb427e7baa5b461781d566832fc703", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -11,7 +11,7 @@\n use fmt_macros::{Parser, Piece, Position};\n \n use hir::def_id::DefId;\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, GenericParamDef};\n use util::common::ErrorReported;\n use util::nodemap::FxHashMap;\n \n@@ -243,7 +243,6 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let parser = Parser::new(&self.0);\n-        let mut types = generics.types();\n         let mut result = Ok(());\n         for token in parser {\n             match token {\n@@ -254,8 +253,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                     // `{ThisTraitsName}` is allowed\n                     Position::ArgumentNamed(s) if s == name => (),\n                     // So is `{A}` if A is a type parameter\n-                    Position::ArgumentNamed(s) => match types.find(|t| {\n-                        t.name == s\n+                    Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n+                        if let GenericParamDef::Type(ty) = param {\n+                            ty.name == s\n+                        } else {\n+                            false\n+                        }\n                     }) {\n                         Some(_) => (),\n                         None => {\n@@ -289,8 +292,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         let trait_str = tcx.item_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);\n         let generic_map = generics.types().map(|param| {\n-            (param.name.to_string(),\n-             trait_ref.substs.type_for_def(param).to_string())\n+            (param.name.to_string(), trait_ref.substs.type_for_def(param).to_string())\n         }).collect::<FxHashMap<String, String>>();\n \n         let parser = Parser::new(&self.0);"}, {"sha": "f7d09b5070c1074f18d55e4df0d30dcce4366895", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -757,6 +757,18 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n+#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum Kind {\n+    Lifetime,\n+    Type,\n+}\n+\n+impl Kind {\n+    pub fn iter<'a>() -> impl Iterator<Item = &'a Kind> {\n+        [Kind::Lifetime, Kind::Type].into_iter()\n+    }\n+}\n+\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum GenericParamDef {\n     Lifetime(RegionParamDef),\n@@ -799,6 +811,23 @@ impl<'a, 'gcx, 'tcx> Generics {\n         self.parent_count + self.params.len()\n     }\n \n+    pub fn param_counts(&self) -> FxHashMap<Kind, usize> {\n+        let mut param_counts: FxHashMap<_, _> = FxHashMap();\n+        Kind::iter().for_each(|kind| {\n+            param_counts.insert(*kind, 0);\n+        });\n+\n+        for param in self.params.iter() {\n+            let key = match param {\n+                GenericParamDef::Type(_) => Kind::Type,\n+                GenericParamDef::Lifetime(_) => Kind::Lifetime,\n+            };\n+            *param_counts.get_mut(&key).unwrap() += 1;\n+        }\n+\n+        param_counts\n+    }\n+\n     pub fn lifetimes(&self) -> impl DoubleEndedIterator<Item = &RegionParamDef> {\n         self.params.iter().filter_map(|p| {\n             if let GenericParamDef::Lifetime(lt) = p {"}, {"sha": "c6a2dccac4952c64ad6c935066eb83ae9e9fa66b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -19,8 +19,8 @@ use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyGenerator, TyGeneratorWitness, TyForeign, TyProjection, TyAnon};\n use ty::{TyDynamic, TyInt, TyUint, TyInfer};\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use util::nodemap::FxHashSet;\n+use ty::{self, Ty, TyCtxt, TypeFoldable, Kind};\n+use util::nodemap::{FxHashSet, FxHashMap};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -256,8 +256,10 @@ impl PrintContext {\n         let verbose = self.is_verbose;\n         let mut num_supplied_defaults = 0;\n         let mut has_self = false;\n-        let mut num_regions = 0;\n-        let mut num_types = 0;\n+        let mut param_counts = FxHashMap();\n+        Kind::iter().for_each(|kind| {\n+            param_counts.insert(*kind, 0);\n+        });\n         let mut is_value_path = false;\n         let fn_trait_kind = ty::tls::with(|tcx| {\n             // Unfortunately, some kinds of items (e.g., closures) don't have\n@@ -303,17 +305,17 @@ impl PrintContext {\n                 }\n             }\n             let mut generics = tcx.generics_of(item_def_id);\n+            let child_param_counts = generics.param_counts();\n             let mut path_def_id = did;\n             has_self = generics.has_self;\n \n             let mut child_types = 0;\n             if let Some(def_id) = generics.parent {\n                 // Methods.\n                 assert!(is_value_path);\n-                child_types = generics.types().count();\n+                child_types = child_param_counts[&Kind::Type];\n                 generics = tcx.generics_of(def_id);\n-                num_regions = generics.lifetimes().count();\n-                num_types = generics.types().count();\n+                param_counts = generics.param_counts();\n \n                 if has_self {\n                     print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n@@ -328,8 +330,7 @@ impl PrintContext {\n                     assert_eq!(has_self, false);\n                 } else {\n                     // Types and traits.\n-                    num_regions = generics.lifetimes().count();\n-                    num_types = generics.types().count();\n+                    param_counts = child_param_counts;\n                 }\n             }\n \n@@ -401,10 +402,11 @@ impl PrintContext {\n             Ok(())\n         };\n \n-        print_regions(f, \"<\", 0, num_regions)?;\n+        print_regions(f, \"<\", 0, param_counts[&Kind::Lifetime])?;\n \n-        let tps = substs.types().take(num_types - num_supplied_defaults)\n-                                .skip(has_self as usize);\n+        let tps = substs.types()\n+                        .take(param_counts[&Kind::Type] - num_supplied_defaults)\n+                        .skip(has_self as usize);\n \n         for ty in tps {\n             start_or_continue(f, \"<\", \", \")?;\n@@ -435,10 +437,10 @@ impl PrintContext {\n                 write!(f, \"::{}\", item_name)?;\n             }\n \n-            print_regions(f, \"::<\", num_regions, usize::MAX)?;\n+            print_regions(f, \"::<\", param_counts[&Kind::Lifetime], usize::MAX)?;\n \n             // FIXME: consider being smart with defaults here too\n-            for ty in substs.types().skip(num_types) {\n+            for ty in substs.types().skip(param_counts[&Kind::Type]) {\n                 start_or_continue(f, \"::<\", \", \")?;\n                 ty.print_display(f, self)?;\n             }"}, {"sha": "d50c74da31302a1638b369f7cd746cdb20dcb1ed", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -26,6 +26,7 @@ use llvm::debuginfo::{DIFile, DIType, DIScope, DIBuilderRef, DISubprogram, DIArr\n use rustc::hir::TransFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum};\n use rustc::ty::subst::Substs;\n+use rustc::ty::{Kind, GenericParamDef};\n \n use abi::Abi;\n use common::CodegenCx;\n@@ -390,7 +391,14 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n \n         // Again, only create type information if full debuginfo is enabled\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n-            let names = get_type_parameter_names(cx, generics);\n+            let names = get_parameter_names(cx, generics);\n+            let names = names.iter().flat_map(|(kind, param)| {\n+                if kind == &Kind::Type {\n+                    Some(param)\n+                } else {\n+                    None\n+                }\n+            });\n             substs.types().zip(names).map(|(ty, name)| {\n                 let actual_type = cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n@@ -413,11 +421,18 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         return create_DIArray(DIB(cx), &template_params[..]);\n     }\n \n-    fn get_type_parameter_names(cx: &CodegenCx, generics: &ty::Generics) -> Vec<InternedString> {\n+    fn get_parameter_names(cx: &CodegenCx,\n+                           generics: &ty::Generics)\n+                           -> Vec<(Kind, InternedString)> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {\n-            get_type_parameter_names(cx, cx.tcx.generics_of(def_id))\n+            get_parameter_names(cx, cx.tcx.generics_of(def_id))\n         });\n-        names.extend(generics.types().map(|param| param.name));\n+        names.extend(generics.params.iter().map(|param| {\n+            match param {\n+                GenericParamDef::Lifetime(lt) => (Kind::Lifetime, lt.name.as_str()),\n+                GenericParamDef::Type(ty) => (Kind::Type, ty.name),\n+            }\n+        }));\n         names\n     }\n "}, {"sha": "44b0ebf7f01167b4704f080b7ce0540c8e5d3ab6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -96,7 +96,7 @@ use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n+use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate, GenericParamDef};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n@@ -1239,7 +1239,8 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n         } else {\n             for item in &m.items {\n                 let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n-                if generics.types().count() != 0 {\n+                let param_counts = generics.param_counts();\n+                if generics.params.len() - param_counts[&ty::Kind::Lifetime] != 0 {\n                     let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n                         \"foreign items may not have type parameters\");\n                     err.span_label(item.span, \"can't have type parameters\");\n@@ -4799,7 +4800,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Skip over the lifetimes in the same segment.\n             if let Some((_, generics)) = segment {\n-                i -= generics.lifetimes().count();\n+                i -= generics.param_counts()[&ty::Kind::Lifetime];\n             }\n \n             if let Some(ast_ty) = types.get(i) {\n@@ -4917,18 +4918,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             format!(\"{} type parameter{}\", n, if n == 1 { \"\" } else { \"s\" })\n         };\n \n-        // Check provided type parameters.\n-        let type_defs = segment.map_or(vec![], |(_, generics)| {\n-            if generics.parent.is_none() {\n-                generics.types().skip(generics.has_self as usize).collect()\n-            } else {\n-                generics.types().collect()\n-            }\n-        });\n-        let required_len = type_defs.iter().take_while(|d| !d.has_default).count();\n-        if types.len() > type_defs.len() {\n-            let span = types[type_defs.len()].span;\n-            let expected_text = count_type_params(type_defs.len());\n+        // Check provided parameters.\n+        let (ty_non_def_req_len, ty_req_len, lt_req_len) =\n+            segment.map_or((0, 0, 0), |(_, generics)| {\n+                let params_count = generics.param_counts();\n+\n+                let offset_type_params = generics.parent.is_none() && generics.has_self;\n+                let type_params = params_count[&ty::Kind::Type] - offset_type_params as usize;\n+                let type_params_barring_defaults =\n+                    type_params - generics.params.iter().filter(|param| {\n+                        if let GenericParamDef::Type(ty) = param {\n+                            ty.has_default\n+                        } else {\n+                            false\n+                        }\n+                    }).count();\n+\n+                (type_params_barring_defaults, type_params, params_count[&ty::Kind::Lifetime])\n+            });\n+\n+        if types.len() > ty_req_len {\n+            let span = types[ty_req_len].span;\n+            let expected_text = count_type_params(ty_req_len);\n             let actual_text = count_type_params(types.len());\n             struct_span_err!(self.tcx.sess, span, E0087,\n                              \"too many type parameters provided: \\\n@@ -4941,8 +4952,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type parameters, we force instantiate_value_path to\n             // use inference variables instead of the provided types.\n             *segment = None;\n-        } else if types.len() < required_len && !infer_types && !supress_mismatch_error {\n-            let expected_text = count_type_params(required_len);\n+        } else if types.len() < ty_non_def_req_len && !infer_types && !supress_mismatch_error {\n+            let expected_text = count_type_params(ty_non_def_req_len);\n             let actual_text = count_type_params(types.len());\n             struct_span_err!(self.tcx.sess, span, E0089,\n                              \"too few type parameters provided: \\\n@@ -4956,10 +4967,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             AstConv::prohibit_projection(self, bindings[0].span);\n         }\n \n-        // Check provided lifetime parameters.\n-        let lifetime_defs = segment.map_or(vec![], |(_, generics)| generics.lifetimes().collect());\n-        let required_len = lifetime_defs.len();\n-\n         // Prohibit explicit lifetime arguments if late bound lifetime parameters are present.\n         let has_late_bound_lifetime_defs =\n             segment.map_or(None, |(_, generics)| generics.has_late_bound_regions);\n@@ -4968,8 +4975,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let primary_msg = \"cannot specify lifetime arguments explicitly \\\n                                if late bound lifetime parameters are present\";\n             let note_msg = \"the late bound lifetime parameter is introduced here\";\n-            if !is_method_call && (lifetimes.len() > required_len ||\n-                                   lifetimes.len() < required_len && !infer_lifetimes) {\n+            if !is_method_call && (lifetimes.len() > lt_req_len ||\n+                                   lifetimes.len() < lt_req_len && !infer_lifetimes) {\n                 let mut err = self.tcx.sess.struct_span_err(lifetimes[0].span, primary_msg);\n                 err.span_note(span_late, note_msg);\n                 err.emit();\n@@ -4983,18 +4990,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        if lifetimes.len() > required_len {\n-            let span = lifetimes[required_len].span;\n-            let expected_text = count_lifetime_params(required_len);\n+        if lifetimes.len() > lt_req_len {\n+            let span = lifetimes[lt_req_len].span;\n+            let expected_text = count_lifetime_params(lt_req_len);\n             let actual_text = count_lifetime_params(lifetimes.len());\n             struct_span_err!(self.tcx.sess, span, E0088,\n                              \"too many lifetime parameters provided: \\\n                               expected at most {}, found {}\",\n                              expected_text, actual_text)\n                 .span_label(span, format!(\"expected {}\", expected_text))\n                 .emit();\n-        } else if lifetimes.len() < required_len && !infer_lifetimes {\n-            let expected_text = count_lifetime_params(required_len);\n+        } else if lifetimes.len() < lt_req_len && !infer_lifetimes {\n+            let expected_text = count_lifetime_params(lt_req_len);\n             let actual_text = count_lifetime_params(lifetimes.len());\n             struct_span_err!(self.tcx.sess, span, E0090,\n                              \"too few lifetime parameters provided: \\\n@@ -5010,16 +5017,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span,\n                         segment: &mut Option<(&hir::PathSegment, &ty::Generics)>)\n                         -> bool {\n-        use hir::SyntheticTyParamKind::*;\n-\n         let segment = segment.map(|(path_segment, generics)| {\n             let explicit = !path_segment.infer_types;\n-            let impl_trait = generics.types().any(|ty_param| {\n-                                                 match ty_param.synthetic {\n-                                                     Some(ImplTrait) => true,\n-                                                     _ => false,\n-                                                 }\n-                                             });\n+            let impl_trait = generics.params.iter().any(|param| {\n+                if let ty::GenericParamDef::Type(ty) = param {\n+                    if let Some(hir::SyntheticTyParamKind::ImplTrait) = ty.synthetic {\n+                        return true;\n+                    }\n+                }\n+                false\n+            });\n \n             if explicit && impl_trait {\n                 let mut err = struct_span_err! {\n@@ -5086,12 +5093,22 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if generics.ty_params().next().is_none() { return; }\n     let mut tps_used = vec![false; generics.ty_params().count()];\n \n-    let lifetime_count = generics.lifetimes().count();\n+    let mut param_counts = FxHashMap();\n+    param_counts.insert(ty::Kind::Type, 0);\n+    param_counts.insert(ty::Kind::Lifetime, 0);\n+\n+    for param in generics.params.iter() {\n+        let key = match param {\n+            hir::GenericParamDef::Type(_) => ty::Kind::Type,\n+            hir::GenericParamDef::Lifetime(_) => ty::Kind::Lifetime,\n+        };\n+        *param_counts.get_mut(&key).unwrap() += 1;\n+    }\n \n     for leaf_ty in ty.walk() {\n-        if let ty::TyParam(ty::ParamTy {idx, ..}) = leaf_ty.sty {\n+        if let ty::TyParam(ty::ParamTy {idx, .. }) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n-            tps_used[idx as usize - lifetime_count] = true;\n+            tps_used[idx as usize - param_counts[&ty::Kind::Lifetime]] = true;\n         } else if let ty::TyError = leaf_ty.sty {\n             // If there already another error, do not emit an error for not using a type Parameter\n             assert!(tcx.sess.err_count() > 0);"}, {"sha": "fa1ac49232ac02a9dee06ddeee28bdee0a351821", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -11,6 +11,8 @@\n use check::{Inherited, FnCtxt};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n+use ty::GenericParamDef;\n+\n use hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Lift, Ty, TyCtxt};\n@@ -187,7 +189,7 @@ fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 fcx.register_wf_obligation(ty, span, code.clone());\n             }\n             ty::AssociatedKind::Method => {\n-                reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n+                reject_shadowing_parameters(fcx.tcx, item.def_id);\n                 let sig = fcx.tcx.fn_sig(item.def_id);\n                 let sig = fcx.normalize_associated_types_in(span, &sig);\n                 check_fn_or_method(tcx, fcx, span, sig,\n@@ -638,23 +640,37 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n+fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n     let generics = tcx.generics_of(def_id);\n     let parent = tcx.generics_of(generics.parent.unwrap());\n-    let impl_params: FxHashMap<_, _> = parent.types()\n-                                             .map(|tp| (tp.name, tp.def_id))\n-                                             .collect();\n-\n-    for method_param in generics.types() {\n-        if impl_params.contains_key(&method_param.name) {\n+    let impl_params: FxHashMap<_, _> =\n+        parent.params.iter()\n+                     .flat_map(|param| {\n+                         match param {\n+                             GenericParamDef::Lifetime(_) => None,\n+                             GenericParamDef::Type(ty) => Some((ty.name, ty.def_id)),\n+                         }\n+                     })\n+                     .collect();\n+\n+    for method_param in generics.params.iter() {\n+        // Shadowing is currently permitted with lifetimes.\n+        if let GenericParamDef::Lifetime(_) = method_param {\n+            continue;\n+        }\n+        let (name, def_id) = match method_param {\n+            GenericParamDef::Lifetime(_) => continue,\n+            GenericParamDef::Type(ty) => (ty.name, ty.def_id),\n+        };\n+        if impl_params.contains_key(&name) {\n             // Tighten up the span to focus on only the shadowing type\n-            let type_span = tcx.def_span(method_param.def_id);\n+            let type_span = tcx.def_span(def_id);\n \n             // The expectation here is that the original trait declaration is\n             // local so it should be okay to just unwrap everything.\n-            let trait_def_id = impl_params[&method_param.name];\n+            let trait_def_id = impl_params[&name];\n             let trait_decl_span = tcx.def_span(trait_def_id);\n-            error_194(tcx, type_span, trait_decl_span, &method_param.name.as_str()[..]);\n+            error_194(tcx, type_span, trait_decl_span, &name[..]);\n         }\n     }\n }"}, {"sha": "b1981c0650441b3691fca5c396fde43581e90f70", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -224,33 +224,33 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n     }\n \n     fn generics_to_path_params(&self, generics: ty::Generics) -> hir::PathParameters {\n-        let lifetimes = HirVec::from_vec(\n-            generics.lifetimes()\n-                    .map(|p| {\n-                        let name = if p.name == \"\" {\n-                            hir::LifetimeName::Static\n-                        } else {\n-                            hir::LifetimeName::Name(p.name.as_symbol())\n-                        };\n+        let mut lifetimes = vec![];\n+        let mut types = vec![];\n+\n+        for param in generics.params.iter() {\n+            match param {\n+                ty::GenericParamDef::Lifetime(lt) => {\n+                    let name = if lt.name == \"\" {\n+                        hir::LifetimeName::Static\n+                    } else {\n+                        hir::LifetimeName::Name(lt.name.as_symbol())\n+                    };\n \n-                        hir::Lifetime {\n-                            id: ast::DUMMY_NODE_ID,\n-                            span: DUMMY_SP,\n-                            name,\n-                        }\n-                    })\n-                    .collect(),\n-        );\n-        let types = HirVec::from_vec(\n-            generics.types()\n-                    .into_iter()\n-                    .map(|p| P(self.ty_param_to_ty(p.clone())))\n-                    .collect(),\n-        );\n+                    lifetimes.push(hir::Lifetime {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: DUMMY_SP,\n+                        name,\n+                    });\n+                }\n+                ty::GenericParamDef::Type(ty) => {\n+                    types.push(P(self.ty_param_to_ty(ty.clone())));\n+                }\n+            }\n+        }\n \n         hir::PathParameters {\n-            lifetimes: lifetimes,\n-            types: types,\n+            lifetimes: HirVec::from_vec(lifetimes),\n+            types: HirVec::from_vec(types),\n             bindings: HirVec::new(),\n             parenthesized: false,\n         }"}, {"sha": "d1db5185f194a9996ef2cde86a0edaebbadfda61", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6c9463683b5903de5e13c59b48914206754152/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4a6c9463683b5903de5e13c59b48914206754152", "patch": "@@ -41,7 +41,7 @@ use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::def_id::DefIndexAddressSpace;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n+use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind, Kind};\n use rustc::middle::stability;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_typeck::hir_ty_to_ty;\n@@ -2675,20 +2675,31 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     provided_params.with_parameters(|provided_params| {\n-                        for (i, ty_param) in generics.ty_params().enumerate() {\n-                            let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                            if let Some(ty) = provided_params.types.get(i).cloned() {\n-                                ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n-                            } else if let Some(default) = ty_param.default.clone() {\n-                                ty_substs.insert(ty_param_def, default.into_inner().clean(cx));\n-                            }\n-                        }\n-\n-                        for (i, lt_param) in generics.lifetimes().enumerate() {\n-                            if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n-                                if !lt.is_elided() {\n-                                    let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n-                                    lt_substs.insert(lt_def_id, lt.clean(cx));\n+                        let mut indices = FxHashMap();\n+                        for param in generics.params.iter() {\n+                            match param {\n+                                GenericParamDef::Type(ty_param) => {\n+                                    let i = indices.entry(Kind::Type).or_insert(0);\n+                                    let ty_param_def =\n+                                        Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n+                                    if let Some(ty) = provided_params.types.get(*i).cloned() {\n+                                        ty_substs.insert(ty_param_def, ty.into_inner().clean(cx));\n+                                    } else if let Some(default) = ty_param.default.clone() {\n+                                        ty_substs.insert(ty_param_def,\n+                                                         default.into_inner().clean(cx));\n+                                    }\n+                                    *i += 1;\n+                                }\n+                                GenericParamDef::Lifetime(lt_param) => {\n+                                    let i = indices.entry(Kind::Type).or_insert(0);\n+                                    if let Some(lt) = provided_params.lifetimes.get(*i).cloned() {\n+                                        if !lt.is_elided() {\n+                                            let lt_def_id =\n+                                                cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n+                                            lt_substs.insert(lt_def_id, lt.clean(cx));\n+                                        }\n+                                    }\n+                                    *i += 1;\n                                 }\n                             }\n                         }"}]}