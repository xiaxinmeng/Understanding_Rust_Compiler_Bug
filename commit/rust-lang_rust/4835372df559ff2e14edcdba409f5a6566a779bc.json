{"sha": "4835372df559ff2e14edcdba409f5a6566a779bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MzUzNzJkZjU1OWZmMmUxNGVkY2RiYTQwOWY1YTY1NjZhNzc5YmM=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-08T09:50:04Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-09-08T09:50:04Z"}, "message": "made shadow_unrelated allow, added previous binding span note, fixed #319", "tree": {"sha": "ee65e133a9135971dc55436f7dedc64980147b0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee65e133a9135971dc55436f7dedc64980147b0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4835372df559ff2e14edcdba409f5a6566a779bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4835372df559ff2e14edcdba409f5a6566a779bc", "html_url": "https://github.com/rust-lang/rust/commit/4835372df559ff2e14edcdba409f5a6566a779bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4835372df559ff2e14edcdba409f5a6566a779bc/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5d953bf7df9e91d96c36182b651693cf01ce0bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d953bf7df9e91d96c36182b651693cf01ce0bf", "html_url": "https://github.com/rust-lang/rust/commit/b5d953bf7df9e91d96c36182b651693cf01ce0bf"}], "stats": {"total": 64, "additions": 42, "deletions": 22}, "files": [{"sha": "fdd341efa45fd5af463fa0cceb17b97e004a3f14", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4835372df559ff2e14edcdba409f5a6566a779bc/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4835372df559ff2e14edcdba409f5a6566a779bc/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4835372df559ff2e14edcdba409f5a6566a779bc", "patch": "@@ -48,7 +48,7 @@ name\n [result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)               | allow   | using `Result.unwrap()`, which might be better handled\n [shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                           | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                             | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n-[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                   | warn    | The name is re-bound without even using the original value\n+[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                   | allow   | The name is re-bound without even using the original value\n [should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)       | warn    | defining a method that should be implementing a std trait\n [single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                           | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n [str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                         | warn    | using `to_string()` on a str, which should be `to_owned()`"}, {"sha": "ddaa3bf490c2e431b7c03ab00c8a8f52912f5efc", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4835372df559ff2e14edcdba409f5a6566a779bc/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4835372df559ff2e14edcdba409f5a6566a779bc/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4835372df559ff2e14edcdba409f5a6566a779bc", "patch": "@@ -96,6 +96,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         ptr_arg::PTR_ARG,\n         shadow::SHADOW_REUSE,\n         shadow::SHADOW_SAME,\n+        shadow::SHADOW_UNRELATED,\n         strings::STRING_ADD,\n         strings::STRING_ADD_ASSIGN,\n         types::CAST_POSSIBLE_TRUNCATION,\n@@ -141,7 +142,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         ranges::RANGE_STEP_BY_ZERO,\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n-        shadow::SHADOW_UNRELATED,\n         types::BOX_VEC,\n         types::LET_UNIT_VALUE,\n         types::LINKEDLIST,"}, {"sha": "ae1eeee240118b12888ad7e2aac2657f50ecc8a0", "filename": "src/shadow.rs", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4835372df559ff2e14edcdba409f5a6566a779bc/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4835372df559ff2e14edcdba409f5a6566a779bc/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=4835372df559ff2e14edcdba409f5a6566a779bc", "patch": "@@ -4,7 +4,7 @@ use reexport::*;\n use syntax::codemap::Span;\n use rustc_front::visit::FnKind;\n \n-use rustc::lint::{Context, LintArray, LintPass};\n+use rustc::lint::{Context, Level, Lint, LintArray, LintPass};\n use rustc::middle::def::Def::{DefVariant, DefStruct};\n \n use utils::{in_external_macro, snippet, span_lint, span_note_and_lint};\n@@ -14,7 +14,7 @@ declare_lint!(pub SHADOW_SAME, Allow,\n declare_lint!(pub SHADOW_REUSE, Allow,\n     \"rebinding a name to an expression that re-uses the original value, e.g. \\\n     `let x = x + 1`\");\n-declare_lint!(pub SHADOW_UNRELATED, Warn,\n+declare_lint!(pub SHADOW_UNRELATED, Allow,\n     \"The name is re-bound without even using the original value\");\n \n #[derive(Copy, Clone)]\n@@ -36,13 +36,13 @@ fn check_fn(cx: &Context, decl: &FnDecl, block: &Block) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n         if let PatIdent(_, ident, _) = arg.pat.node {\n-            bindings.push(ident.node.name)\n+            bindings.push((ident.node.name, ident.span))\n         }\n     }\n     check_block(cx, block, &mut bindings);\n }\n \n-fn check_block(cx: &Context, block: &Block, bindings: &mut Vec<Name>) {\n+fn check_block(cx: &Context, block: &Block, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n     for stmt in &block.stmts {\n         match stmt.node {\n@@ -55,7 +55,7 @@ fn check_block(cx: &Context, block: &Block, bindings: &mut Vec<Name>) {\n     bindings.truncate(len);\n }\n \n-fn check_decl(cx: &Context, decl: &Decl, bindings: &mut Vec<Name>) {\n+fn check_decl(cx: &Context, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, decl.span) { return; }\n     if let DeclLocal(ref local) = decl.node {\n         let Local{ ref pat, ref ty, ref init, id: _, span } = **local;\n@@ -77,16 +77,23 @@ fn is_binding(cx: &Context, pat: &Pat) -> bool {\n }\n \n fn check_pat(cx: &Context, pat: &Pat, init: &Option<&Expr>, span: Span,\n-        bindings: &mut Vec<Name>) {\n+        bindings: &mut Vec<(Name, Span)>) {\n     //TODO: match more stuff / destructuring\n     match pat.node {\n         PatIdent(_, ref ident, ref inner) => {\n             let name = ident.node.name;\n             if is_binding(cx, pat) {\n-                if bindings.contains(&name) {\n-                    lint_shadow(cx, name, span, pat.span, init);\n-                } else {\n-                    bindings.push(name);\n+                let mut new_binding = true;\n+                for tup in bindings.iter_mut() {\n+                    if tup.0 == name {\n+                        lint_shadow(cx, name, span, pat.span, init, tup.1);\n+                        tup.1 = ident.span;\n+                        new_binding = false;\n+                        break;\n+                    }\n+                }\n+                if new_binding {\n+                    bindings.push((name, ident.span));\n                 }\n             }\n             if let Some(ref p) = *inner { check_pat(cx, p, init, span, bindings); }\n@@ -141,42 +148,50 @@ fn check_pat(cx: &Context, pat: &Pat, init: &Option<&Expr>, span: Span,\n         },\n         PatRegion(ref inner, _) =>\n             check_pat(cx, inner, init, span, bindings),\n-        //PatRange(P<Expr>, P<Expr>),\n         //PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n         _ => (),\n     }\n }\n \n fn lint_shadow<T>(cx: &Context, name: Name, span: Span, lspan: Span, init:\n-        &Option<T>) where T: Deref<Target=Expr> {\n+        &Option<T>, prev_span: Span) where T: Deref<Target=Expr> {\n+    fn note_orig(cx: &Context, lint: &'static Lint, span: Span) {\n+        if cx.current_level(lint) != Level::Allow {\n+            cx.sess().span_note(span, \"previous binding is here\");\n+        }\n+    }\n     if let Some(ref expr) = *init {\n         if is_self_shadow(name, expr) {\n             span_lint(cx, SHADOW_SAME, span, &format!(\n                 \"{} is shadowed by itself in {}\",\n                 snippet(cx, lspan, \"_\"),\n                 snippet(cx, expr.span, \"..\")));\n+                note_orig(cx, SHADOW_SAME, prev_span);\n         } else {\n             if contains_self(name, expr) {\n                 span_note_and_lint(cx, SHADOW_REUSE, lspan, &format!(\n                     \"{} is shadowed by {} which reuses the original value\",\n                     snippet(cx, lspan, \"_\"),\n                     snippet(cx, expr.span, \"..\")),\n                     expr.span, \"initialization happens here\");\n+                note_orig(cx, SHADOW_REUSE, prev_span);\n             } else {\n                 span_note_and_lint(cx, SHADOW_UNRELATED, lspan, &format!(\n                     \"{} is shadowed by {}\",\n                     snippet(cx, lspan, \"_\"),\n                     snippet(cx, expr.span, \"..\")),\n                     expr.span, \"initialization happens here\");\n+                note_orig(cx, SHADOW_UNRELATED, prev_span);\n             }\n         }\n     } else {\n         span_lint(cx, SHADOW_UNRELATED, span, &format!(\n             \"{} shadows a previous declaration\", snippet(cx, lspan, \"_\")));\n+        note_orig(cx, SHADOW_UNRELATED, prev_span);\n     }\n }\n \n-fn check_expr(cx: &Context, expr: &Expr, bindings: &mut Vec<Name>) {\n+fn check_expr(cx: &Context, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, expr.span) { return; }\n     match expr.node {\n         ExprUnary(_, ref e) | ExprParen(ref e) | ExprField(ref e, _) |\n@@ -205,20 +220,20 @@ fn check_expr(cx: &Context, expr: &Expr, bindings: &mut Vec<Name>) {\n             for ref arm in arms {\n                 for ref pat in &arm.pats {\n                     check_pat(cx, &pat, &Some(&**init), pat.span, bindings);\n-                    //TODO: This is ugly, but needed to get the right type\n-                }\n-                if let Some(ref guard) = arm.guard {\n-                    check_expr(cx, guard, bindings);\n+                    //This is ugly, but needed to get the right type\n+                    if let Some(ref guard) = arm.guard {\n+                        check_expr(cx, guard, bindings);\n+                    }\n+                    check_expr(cx, &arm.body, bindings);\n+                    bindings.truncate(len);\n                 }\n-                check_expr(cx, &arm.body, bindings);\n-                bindings.truncate(len);\n             }\n         },\n         _ => ()\n     }\n }\n \n-fn check_ty(cx: &Context, ty: &Ty, bindings: &mut Vec<Name>) {\n+fn check_ty(cx: &Context, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n     match ty.node {\n         TyParen(ref sty) | TyObjectSum(ref sty, _) |\n         TyVec(ref sty) => check_ty(cx, sty, bindings),"}, {"sha": "293d97a42fa873225175160d218ca69ef35e2bd2", "filename": "tests/compile-fail/shadow.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4835372df559ff2e14edcdba409f5a6566a779bc/tests%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4835372df559ff2e14edcdba409f5a6566a779bc/tests%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fshadow.rs?ref=4835372df559ff2e14edcdba409f5a6566a779bc", "patch": "@@ -27,4 +27,9 @@ fn main() {\n         Some(p) => p, // no error, because the p above is in its own scope\n         None => 0,\n     };\n+\n+    match (x, o) {\n+        (1, Some(a)) | (a, Some(1)) => (), // no error though `a` appears twice\n+        _ => (),\n+    }\n }"}]}