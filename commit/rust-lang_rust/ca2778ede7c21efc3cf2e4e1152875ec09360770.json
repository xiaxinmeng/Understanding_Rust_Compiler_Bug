{"sha": "ca2778ede7c21efc3cf2e4e1152875ec09360770", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhMjc3OGVkZTdjMjFlZmMzY2YyZTRlMTE1Mjg3NWVjMDkzNjA3NzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T13:52:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T13:52:00Z"}, "message": "auto merge of #15286 : alexcrichton/rust/channel-stability, r=cmr\n\n* channel() - #[unstable]. This will likely remain forever\r\n\r\n* sync_channel(n: int) - #[unstable with comment]. Concerns have ben raised\r\n  about the usage of the term \"synchronous channel\" because that generally only\r\n  applies to the case where n == 0. If n > 0 then these channels are often\r\n  referred to as buffered channels.\r\n\r\n* Sender::send(), SyncSender::send(), Receiver::recv() - #[experimental]. These\r\n  functions directly violate the general guideline of not providing a failing\r\n  and non-failing variant. These functions were explicitly selected for being\r\n  excused from this guideline, but recent discussions have cast doubt on that\r\n  decision. These functions are #[experimental] for now until a decision is made\r\n  as they are candidates for removal.\r\n\r\n* Sender::send_opt(), SyncSender::send_opt(), Receiver::recv_opt() - #[unstable\r\n  with a comment]. If the above no-`_opt` functions are removed, these functions\r\n  will be renamed to the non-`_opt` variants.\r\n\r\n* SyncSender::try_send(), Receiver::try_recv() - #[unstable with a comment].\r\n  These return types of these functions to not follow general conventions. They\r\n  are consistent with the rest of the api, but not with the rest of the\r\n  libraries. Until their return types are nailed down, these functions are\r\n  #[unstable].\r\n\r\n* Receiver::iter() - #[unstable]. This will likely remain forever.\r\n\r\n* std::com::select - #[experimental]. The functionality is likely to remain in\r\n  some form forever, but it is highly unlikely to remain in its current form. It\r\n  is unknown how much breakage this will cause if and when the api is\r\n  redesigned, so the entire module and its components are all experimental.\r\n\r\n* DuplexStream - #[deprecated]. This type is not composable with other channels\r\n  in terms of selection or other expected locations. It can also not be used\r\n  with ChanWriter and ChanReader, for example. Due to it being only lightly\r\n  used, and easily replaced with two channels, this type is being deprecated and\r\n  slated for removal.\r\n\r\n* Clone for {,Sync}Sender - #[unstable]. This will likely remain forever.", "tree": {"sha": "f9137c168339f3ad2071d4fba5f80862d9ecfc66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9137c168339f3ad2071d4fba5f80862d9ecfc66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca2778ede7c21efc3cf2e4e1152875ec09360770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca2778ede7c21efc3cf2e4e1152875ec09360770", "html_url": "https://github.com/rust-lang/rust/commit/ca2778ede7c21efc3cf2e4e1152875ec09360770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca2778ede7c21efc3cf2e4e1152875ec09360770/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb220a86ba18e91a8d373ac757596707275b86d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb220a86ba18e91a8d373ac757596707275b86d3", "html_url": "https://github.com/rust-lang/rust/commit/cb220a86ba18e91a8d373ac757596707275b86d3"}, {"sha": "58133ae360ff759d444f7743ec7ac55c9eb7b10b", "url": "https://api.github.com/repos/rust-lang/rust/commits/58133ae360ff759d444f7743ec7ac55c9eb7b10b", "html_url": "https://github.com/rust-lang/rust/commit/58133ae360ff759d444f7743ec7ac55c9eb7b10b"}], "stats": {"total": 40, "additions": 40, "deletions": 0}, "files": [{"sha": "9021b761954d05dfd8212e52972c41132dc8d58c", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=ca2778ede7c21efc3cf2e4e1152875ec09360770", "patch": "@@ -457,6 +457,8 @@ the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n ~~~\n+#![allow(deprecated)]\n+\n use std::comm::DuplexStream;\n # fn main() {\n fn stringifier(channel: &DuplexStream<String, uint>) {\n@@ -481,6 +483,8 @@ response itself is simply the stringified version of the received value,\n Here is the code for the parent task:\n \n ~~~\n+#![allow(deprecated)]\n+\n use std::comm::duplex;\n # use std::task::spawn;\n # use std::comm::DuplexStream;"}, {"sha": "44dd63cbf6c010cfd63058c9d6700e4b00922fa4", "filename": "src/libsync/comm/duplex.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Flibsync%2Fcomm%2Fduplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Flibsync%2Fcomm%2Fduplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fduplex.rs?ref=ca2778ede7c21efc3cf2e4e1152875ec09360770", "patch": "@@ -15,6 +15,10 @@ Higher level communication abstractions.\n */\n \n #![allow(missing_doc)]\n+#![deprecated = \"This type is replaced by having a pair of channels. This type \\\n+                 is not fully composable with other channels in terms of \\\n+                 or possible semantics on a duplex stream. It will be removed \\\n+                 soon\"]\n \n use core::prelude::*;\n "}, {"sha": "6c09a021c4338212efe8056a38efd07f76f6229e", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=ca2778ede7c21efc3cf2e4e1152875ec09360770", "patch": "@@ -370,6 +370,7 @@ static RESCHED_FREQ: int = 256;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n+#[unstable]\n pub struct Receiver<T> {\n     inner: Unsafe<Flavor<T>>,\n     receives: Cell<uint>,\n@@ -380,12 +381,14 @@ pub struct Receiver<T> {\n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n+#[unstable]\n pub struct Messages<'a, T> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n+#[unstable]\n pub struct Sender<T> {\n     inner: Unsafe<Flavor<T>>,\n     sends: Cell<uint>,\n@@ -395,6 +398,7 @@ pub struct Sender<T> {\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n+#[unstable = \"this type may be renamed, but it will always exist\"]\n pub struct SyncSender<T> {\n     inner: Arc<Unsafe<sync::Packet<T>>>,\n     // can't share in an arc\n@@ -404,6 +408,7 @@ pub struct SyncSender<T> {\n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n #[deriving(PartialEq, Clone, Show)]\n+#[experimental = \"this is likely to be removed in changing try_recv()\"]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n     /// disconnected, so data may yet become available.\n@@ -416,6 +421,7 @@ pub enum TryRecvError {\n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n #[deriving(PartialEq, Clone, Show)]\n+#[experimental = \"this is likely to be removed in changing try_send()\"]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n     /// the callee block to send the data.\n@@ -478,6 +484,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// // Let's see what that answer was\n /// println!(\"{}\", rx.recv());\n /// ```\n+#[unstable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(Unsafe::new(oneshot::Packet::new()));\n     (Sender::new(Oneshot(a.clone())), Receiver::new(Oneshot(a)))\n@@ -514,6 +521,8 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv(), 1i);\n /// assert_eq!(rx.recv(), 2i);\n /// ```\n+#[unstable = \"this function may be renamed to more accurately reflect the type \\\n+              of channel that is is creating\"]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(Unsafe::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Sync(a)))\n@@ -547,6 +556,8 @@ impl<T: Send> Sender<T> {\n     ///\n     /// The purpose of this functionality is to propagate failure among tasks.\n     /// If failure is not desired, then consider using the `send_opt` method\n+    #[experimental = \"this function is being considered candidate for removal \\\n+                      to adhere to the general guidelines of rust\"]\n     pub fn send(&self, t: T) {\n         if self.send_opt(t).is_err() {\n             fail!(\"sending on a closed channel\");\n@@ -583,6 +594,7 @@ impl<T: Send> Sender<T> {\n     /// drop(rx);\n     /// assert_eq!(tx.send_opt(1i), Err(1));\n     /// ```\n+    #[unstable = \"this function may be renamed to send() in the future\"]\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         // In order to prevent starvation of other tasks in situations where\n         // a task sends repeatedly without ever receiving, we occasionally\n@@ -638,6 +650,7 @@ impl<T: Send> Sender<T> {\n     }\n }\n \n+#[unstable]\n impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper) = match *unsafe { self.inner() } {\n@@ -719,6 +732,8 @@ impl<T: Send> SyncSender<T> {\n     /// If failure is not desired, you can achieve the same semantics with the\n     /// `SyncSender::send_opt` method which will not fail if the receiver\n     /// disconnects.\n+    #[experimental = \"this function is being considered candidate for removal \\\n+                      to adhere to the general guidelines of rust\"]\n     pub fn send(&self, t: T) {\n         if self.send_opt(t).is_err() {\n             fail!(\"sending on a closed channel\");\n@@ -736,6 +751,7 @@ impl<T: Send> SyncSender<T> {\n     /// # Failure\n     ///\n     /// This function cannot fail.\n+    #[unstable = \"this function may be renamed to send() in the future\"]\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         unsafe { (*self.inner.get()).send(t) }\n     }\n@@ -753,11 +769,14 @@ impl<T: Send> SyncSender<T> {\n     /// # Failure\n     ///\n     /// This function cannot fail\n+    #[unstable = \"the return type of this function is candidate for \\\n+                  modification\"]\n     pub fn try_send(&self, t: T) -> Result<(), TrySendError<T>> {\n         unsafe { (*self.inner.get()).try_send(t) }\n     }\n }\n \n+#[unstable]\n impl<T: Send> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }\n@@ -800,6 +819,8 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// * If blocking is not desired, then the `try_recv` method will attempt to\n     ///   peek at a value on this receiver.\n+    #[experimental = \"this function is being considered candidate for removal \\\n+                      to adhere to the general guidelines of rust\"]\n     pub fn recv(&self) -> T {\n         match self.recv_opt() {\n             Ok(t) => t,\n@@ -817,6 +838,7 @@ impl<T: Send> Receiver<T> {\n     /// block on a receiver.\n     ///\n     /// This function cannot fail.\n+    #[unstable = \"the return type of this function may be altered\"]\n     pub fn try_recv(&self) -> Result<T, TryRecvError> {\n         // If a thread is spinning in try_recv, we should take the opportunity\n         // to reschedule things occasionally. See notes above in scheduling on\n@@ -881,6 +903,7 @@ impl<T: Send> Receiver<T> {\n     ///\n     /// If the channel has hung up, then `Err` is returned. Otherwise `Ok` of\n     /// the value found on the receiver is returned.\n+    #[unstable = \"this function may be renamed to recv()\"]\n     pub fn recv_opt(&self) -> Result<T, ()> {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -917,6 +940,7 @@ impl<T: Send> Receiver<T> {\n \n     /// Returns an iterator which will block waiting for messages, but never\n     /// `fail!`. It will return `None` when the channel has hung up.\n+    #[unstable]\n     pub fn iter<'a>(&'a self) -> Messages<'a, T> {\n         Messages { rx: self }\n     }\n@@ -1009,6 +1033,7 @@ impl<T: Send> select::Packet for Receiver<T> {\n     }\n }\n \n+#[unstable]\n impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n     fn next(&mut self) -> Option<T> { self.rx.recv_opt().ok() }\n }"}, {"sha": "230bca624f5a7f61ae80f9c2a4ef0f74f8b6b316", "filename": "src/libsync/comm/select.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Flibsync%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca2778ede7c21efc3cf2e4e1152875ec09360770/src%2Flibsync%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fselect.rs?ref=ca2778ede7c21efc3cf2e4e1152875ec09360770", "patch": "@@ -44,6 +44,13 @@\n //! ```\n \n #![allow(dead_code)]\n+#![experimental = \"This implementation, while likely sufficient, is unsafe and \\\n+                   likely to be error prone. At some point in the future this \\\n+                   module will likely be replaced, and it is currently \\\n+                   unknown how much API breakage that will cause. The ability \\\n+                   to select over a number of channels will remain forever, \\\n+                   but no guarantees beyond this are being made\"]\n+\n \n use core::prelude::*;\n "}]}