{"sha": "3fbb2549ce66e83583bb3bad83bbd15436b10d35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYmIyNTQ5Y2U2NmU4MzU4M2JiM2JhZDgzYmJkMTU0MzZiMTBkMzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-13T22:06:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-03-15T21:29:42Z"}, "message": "resolve: `Legacy(Scope,Binding)` -> `MacroRules(Scope,Binding)`", "tree": {"sha": "c59f2f5bf47ca5aadc6fb8f67b432295066d7ab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c59f2f5bf47ca5aadc6fb8f67b432295066d7ab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fbb2549ce66e83583bb3bad83bbd15436b10d35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbb2549ce66e83583bb3bad83bbd15436b10d35", "html_url": "https://github.com/rust-lang/rust/commit/3fbb2549ce66e83583bb3bad83bbd15436b10d35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fbb2549ce66e83583bb3bad83bbd15436b10d35/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65bf4831d22d3c0eee639a6536bb0bcd191ec915", "url": "https://api.github.com/repos/rust-lang/rust/commits/65bf4831d22d3c0eee639a6536bb0bcd191ec915", "html_url": "https://github.com/rust-lang/rust/commit/65bf4831d22d3c0eee639a6536bb0bcd191ec915"}], "stats": {"total": 120, "additions": 67, "deletions": 53}, "files": [{"sha": "324669963f684541863f26ce4a9b2adb8a3d9885", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3fbb2549ce66e83583bb3bad83bbd15436b10d35", "patch": "@@ -7,7 +7,7 @@\n \n use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n-use crate::macros::{LegacyBinding, LegacyScope};\n+use crate::macros::{MacroRulesBinding, MacroRulesScope};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n use crate::{CrateLint, Determinacy, PathResult, ResolutionError, VisResolutionError};\n use crate::{\n@@ -165,11 +165,11 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         fragment: &AstFragment,\n         parent_scope: ParentScope<'a>,\n-    ) -> LegacyScope<'a> {\n+    ) -> MacroRulesScope<'a> {\n         collect_definitions(&mut self.definitions, fragment, parent_scope.expansion);\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n-        visitor.parent_scope.legacy\n+        visitor.parent_scope.macro_rules\n     }\n \n     crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n@@ -1060,15 +1060,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> MacroRulesScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n         self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        LegacyScope::Invocation(invoc_id)\n+        MacroRulesScope::Invocation(invoc_id)\n     }\n \n     fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n@@ -1095,7 +1095,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn define_macro(&mut self, item: &ast::Item) -> LegacyScope<'a> {\n+    fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScope<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n         let (ext, ident, span, macro_rules) = match &item.kind {\n@@ -1108,7 +1108,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.proc_macro_stubs.insert(item.id);\n                     (self.r.dummy_ext(macro_kind), ident, span, false)\n                 }\n-                None => return parent_scope.legacy,\n+                None => return parent_scope.macro_rules,\n             },\n             _ => unreachable!(),\n         };\n@@ -1137,8 +1137,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, item.id, span);\n             }\n-            LegacyScope::Binding(self.r.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent_legacy_scope: parent_scope.legacy,\n+            MacroRulesScope::Binding(self.r.arenas.alloc_macro_rules_binding(MacroRulesBinding {\n+                parent_macro_rules_scope: parent_scope.macro_rules,\n                 binding,\n                 ident,\n             }))\n@@ -1149,7 +1149,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_unused_macro(ident, item.id, span);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n-            self.parent_scope.legacy\n+            self.parent_scope.macro_rules\n         }\n     }\n }\n@@ -1174,29 +1174,29 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &'b Item) {\n         let macro_use = match item.kind {\n             ItemKind::MacroDef(..) => {\n-                self.parent_scope.legacy = self.define_macro(item);\n+                self.parent_scope.macro_rules = self.define_macro(item);\n                 return;\n             }\n             ItemKind::MacCall(..) => {\n-                self.parent_scope.legacy = self.visit_invoc(item.id);\n+                self.parent_scope.macro_rules = self.visit_invoc(item.id);\n                 return;\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n         let orig_current_module = self.parent_scope.module;\n-        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        let orig_current_macro_rules_scope = self.parent_scope.macro_rules;\n         self.build_reduced_graph_for_item(item);\n         visit::walk_item(self, item);\n         self.parent_scope.module = orig_current_module;\n         if !macro_use {\n-            self.parent_scope.legacy = orig_current_legacy_scope;\n+            self.parent_scope.macro_rules = orig_current_macro_rules_scope;\n         }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::MacCall(..) = stmt.kind {\n-            self.parent_scope.legacy = self.visit_invoc(stmt.id);\n+            self.parent_scope.macro_rules = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1214,11 +1214,11 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_block(&mut self, block: &'b Block) {\n         let orig_current_module = self.parent_scope.module;\n-        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        let orig_current_macro_rules_scope = self.parent_scope.macro_rules;\n         self.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.parent_scope.module = orig_current_module;\n-        self.parent_scope.legacy = orig_current_legacy_scope;\n+        self.parent_scope.macro_rules = orig_current_macro_rules_scope;\n     }\n \n     fn visit_assoc_item(&mut self, item: &'b AssocItem, ctxt: AssocCtxt) {"}, {"sha": "d50f88b59edc3e4fc5c9638facab67240a1c9aac", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=3fbb2549ce66e83583bb3bad83bbd15436b10d35", "patch": "@@ -21,7 +21,9 @@ use rustc_span::{BytePos, MultiSpan, Span};\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{\n+    BindingError, CrateLint, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot,\n+};\n use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n@@ -498,12 +500,12 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n                 }\n-                Scope::MacroRules(legacy_scope) => {\n-                    if let LegacyScope::Binding(legacy_binding) = legacy_scope {\n-                        let res = legacy_binding.binding.res();\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    if let MacroRulesScope::Binding(macro_rules_binding) = macro_rules_scope {\n+                        let res = macro_rules_binding.binding.res();\n                         if filter_fn(res) {\n                             suggestions\n-                                .push(TypoSuggestion::from_res(legacy_binding.ident.name, res))\n+                                .push(TypoSuggestion::from_res(macro_rules_binding.ident.name, res))\n                         }\n                     }\n                 }"}, {"sha": "0d02b8ea074eedc9a1ee8b4eca17774e1297de87", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3fbb2549ce66e83583bb3bad83bbd15436b10d35", "patch": "@@ -58,7 +58,7 @@ use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_ne\n use diagnostics::{ImportSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n-use macros::{LegacyBinding, LegacyScope};\n+use macros::{MacroRulesBinding, MacroRulesScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -94,7 +94,7 @@ impl Determinacy {\n enum Scope<'a> {\n     DeriveHelpers(ExpnId),\n     DeriveHelpersCompat,\n-    MacroRules(LegacyScope<'a>),\n+    MacroRules(MacroRulesScope<'a>),\n     CrateRoot,\n     Module(Module<'a>),\n     RegisteredAttrs,\n@@ -127,15 +127,20 @@ enum ScopeSet {\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n     expansion: ExpnId,\n-    legacy: LegacyScope<'a>,\n+    macro_rules: MacroRulesScope<'a>,\n     derives: &'a [ast::Path],\n }\n \n impl<'a> ParentScope<'a> {\n     /// Creates a parent scope with the passed argument used as the module scope component,\n     /// and other scope components set to default empty values.\n     pub fn module(module: Module<'a>) -> ParentScope<'a> {\n-        ParentScope { module, expansion: ExpnId::root(), legacy: LegacyScope::Empty, derives: &[] }\n+        ParentScope {\n+            module,\n+            expansion: ExpnId::root(),\n+            macro_rules: MacroRulesScope::Empty,\n+            derives: &[],\n+        }\n     }\n }\n \n@@ -930,9 +935,9 @@ pub struct Resolver<'a> {\n     /// Parent scopes in which the macros were invoked.\n     /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n     invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n-    /// Legacy scopes *produced* by expanding the macro invocations,\n+    /// `macro_rules` scopes *produced* by expanding the macro invocations,\n     /// include all the `macro_rules` items and other invocations generated by them.\n-    output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n+    output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScope<'a>>,\n     /// Helper attributes that are in scope for the given expansion.\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n \n@@ -965,7 +970,7 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     imports: arena::TypedArena<Import<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n-    legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n+    macro_rules_bindings: arena::TypedArena<MacroRulesBinding<'a>>,\n     ast_paths: arena::TypedArena<ast::Path>,\n }\n \n@@ -989,8 +994,11 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n-    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n-        self.legacy_bindings.alloc(binding)\n+    fn alloc_macro_rules_binding(\n+        &'a self,\n+        binding: MacroRulesBinding<'a>,\n+    ) -> &'a MacroRulesBinding<'a> {\n+        self.macro_rules_bindings.alloc(binding)\n     }\n     fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n         self.ast_paths.alloc_from_iter(paths.iter().cloned())\n@@ -1210,7 +1218,7 @@ impl<'a> Resolver<'a> {\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocation_parent_scopes,\n-            output_legacy_scopes: Default::default(),\n+            output_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n@@ -1530,16 +1538,18 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::DeriveHelpers(..) => Scope::DeriveHelpersCompat,\n-                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.legacy),\n-                Scope::MacroRules(legacy_scope) => match legacy_scope {\n-                    LegacyScope::Binding(binding) => Scope::MacroRules(binding.parent_legacy_scope),\n-                    LegacyScope::Invocation(invoc_id) => Scope::MacroRules(\n-                        self.output_legacy_scopes\n+                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n+                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope {\n+                    MacroRulesScope::Binding(binding) => {\n+                        Scope::MacroRules(binding.parent_macro_rules_scope)\n+                    }\n+                    MacroRulesScope::Invocation(invoc_id) => Scope::MacroRules(\n+                        self.output_macro_rules_scopes\n                             .get(&invoc_id)\n                             .cloned()\n-                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].legacy),\n+                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].macro_rules),\n                     ),\n-                    LegacyScope::Empty => Scope::Module(module),\n+                    MacroRulesScope::Empty => Scope::Module(module),\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {"}, {"sha": "d8ef148bacff2748694cb32f548b3318e1a5875a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fbb2549ce66e83583bb3bad83bbd15436b10d35/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3fbb2549ce66e83583bb3bad83bbd15436b10d35", "patch": "@@ -33,26 +33,26 @@ use std::{mem, ptr};\n type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n-/// Not modularized, can shadow previous legacy bindings, etc.\n+/// Not modularized, can shadow previous `macro_rules` bindings, etc.\n #[derive(Debug)]\n-pub struct LegacyBinding<'a> {\n+pub struct MacroRulesBinding<'a> {\n     crate binding: &'a NameBinding<'a>,\n-    /// Legacy scope into which the `macro_rules` item was planted.\n-    crate parent_legacy_scope: LegacyScope<'a>,\n+    /// `macro_rules` scope into which the `macro_rules` item was planted.\n+    crate parent_macro_rules_scope: MacroRulesScope<'a>,\n     crate ident: Ident,\n }\n \n /// The scope introduced by a `macro_rules!` macro.\n /// This starts at the macro's definition and ends at the end of the macro's parent\n /// module (named or unnamed), or even further if it escapes with `#[macro_use]`.\n-/// Some macro invocations need to introduce legacy scopes too because they\n+/// Some macro invocations need to introduce `macro_rules` scopes too because they\n /// can potentially expand into macro definitions.\n #[derive(Copy, Clone, Debug)]\n-pub enum LegacyScope<'a> {\n+pub enum MacroRulesScope<'a> {\n     /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n     /// The scope introduced by a `macro_rules!` macro definition.\n-    Binding(&'a LegacyBinding<'a>),\n+    Binding(&'a MacroRulesBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n     Invocation(ExpnId),\n@@ -159,8 +159,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n-        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n-        self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n+        let output_macro_rules_scope = self.build_reduced_graph(fragment, parent_scope);\n+        self.output_macro_rules_scopes.insert(expansion, output_macro_rules_scope);\n \n         parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n@@ -608,12 +608,14 @@ impl<'a> Resolver<'a> {\n                         }\n                         result\n                     }\n-                    Scope::MacroRules(legacy_scope) => match legacy_scope {\n-                        LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident => {\n-                            Ok((legacy_binding.binding, Flags::MACRO_RULES))\n+                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope {\n+                        MacroRulesScope::Binding(macro_rules_binding)\n+                            if ident == macro_rules_binding.ident =>\n+                        {\n+                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n                         }\n-                        LegacyScope::Invocation(invoc_id)\n-                            if !this.output_legacy_scopes.contains_key(&invoc_id) =>\n+                        MacroRulesScope::Invocation(invoc_id)\n+                            if !this.output_macro_rules_scopes.contains_key(&invoc_id) =>\n                         {\n                             Err(Determinacy::Undetermined)\n                         }"}]}