{"sha": "5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYmY5MmNkMGVkNGJlOTdmZTBjYTViZmZlZmJlMjkyZGIxZWM0Y2Y=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-05T17:05:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-05T17:05:07Z"}, "message": "Merge #5648\n\n5648: Add expand glob import assist r=jonas-schievink a=unexge\n\ncloses https://github.com/rust-analyzer/rust-analyzer/issues/5557\n\nCo-authored-by: unexge <unexge@gmail.com>", "tree": {"sha": "6afaf5db6cd8791633090b9345b6a248aa3eff45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6afaf5db6cd8791633090b9345b6a248aa3eff45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfKubDCRBK7hj4Ov3rIwAAdHIIAA5XVHeOX2+3csd3rm8GqijM\n/Ed5DiMjAmB+mJPfDoH8/10zfRt4jWQ6ouOZXTwZ1zgAS8upVKGrSKfTL8eGLCIV\n84kX0XXd6fimVp5N2xv9jNpkv6FzF75YjaOfhPijG/o2JjAg8VU7Dcawcx/Nin6y\nPT7nhN7Htj9k484cEclcteWYmDA/mRPzLI370fHS+JX3QCBtZQo2dHKzVBw0gGC8\nhoEZsIXzCAZ0QJDpuBHePYubEYutPupj6KGF9VqoDYnKrvmNxWd5KAbtLH3dNIuF\nJfclCPtvIYLwZMTBkKvuNzhmgAslPYkc5FGeQ5UVLOWvLtEt4/hFIs+mDYmnEgE=\n=iFAy\n-----END PGP SIGNATURE-----\n", "payload": "tree 6afaf5db6cd8791633090b9345b6a248aa3eff45\nparent 32246b91c217fff5b3b6ea062c9b9a8797a3fdf5\nparent 6cb090345ece4a97c640159240594f3902e37032\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1596647107 +0000\ncommitter GitHub <noreply@github.com> 1596647107 +0000\n\nMerge #5648\n\n5648: Add expand glob import assist r=jonas-schievink a=unexge\n\ncloses https://github.com/rust-analyzer/rust-analyzer/issues/5557\n\nCo-authored-by: unexge <unexge@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "html_url": "https://github.com/rust-lang/rust/commit/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32246b91c217fff5b3b6ea062c9b9a8797a3fdf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/32246b91c217fff5b3b6ea062c9b9a8797a3fdf5", "html_url": "https://github.com/rust-lang/rust/commit/32246b91c217fff5b3b6ea062c9b9a8797a3fdf5"}, {"sha": "6cb090345ece4a97c640159240594f3902e37032", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb090345ece4a97c640159240594f3902e37032", "html_url": "https://github.com/rust-lang/rust/commit/6cb090345ece4a97c640159240594f3902e37032"}], "stats": {"total": 426, "additions": 425, "deletions": 1}, "files": [{"sha": "afd3fd4b9e37c8d8211aed5cf0b675b316506f7b", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "patch": "@@ -73,6 +73,10 @@ impl<'a> AssistContext<'a> {\n         self.sema.db\n     }\n \n+    pub(crate) fn source_file(&self) -> &SourceFile {\n+        &self.source_file\n+    }\n+\n     // NB, this ignores active selection.\n     pub(crate) fn offset(&self) -> TextSize {\n         self.frange.range.start()"}, {"sha": "69f6b3674979d60bd1de8043b801d6e97e2091fd", "filename": "crates/ra_assists/src/handlers/expand_glob_import.rs", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "patch": "@@ -0,0 +1,391 @@\n+use hir::{AssocItem, MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n+use ra_ide_db::{\n+    defs::{classify_name_ref, Definition, NameRefClass},\n+    RootDatabase,\n+};\n+use ra_syntax::{algo, ast, match_ast, AstNode, SyntaxNode, SyntaxToken, T};\n+\n+use crate::{\n+    assist_context::{AssistBuilder, AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+use either::Either;\n+\n+// Assist: expand_glob_import\n+//\n+// Expands glob imports.\n+//\n+// ```\n+// mod foo {\n+//     pub struct Bar;\n+//     pub struct Baz;\n+// }\n+//\n+// use foo::*<|>;\n+//\n+// fn qux(bar: Bar, baz: Baz) {}\n+// ```\n+// ->\n+// ```\n+// mod foo {\n+//     pub struct Bar;\n+//     pub struct Baz;\n+// }\n+//\n+// use foo::{Baz, Bar};\n+//\n+// fn qux(bar: Bar, baz: Baz) {}\n+// ```\n+pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let star = ctx.find_token_at_offset(T![*])?;\n+    let mod_path = find_mod_path(&star)?;\n+\n+    let source_file = ctx.source_file();\n+    let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n+\n+    let defs_in_mod = find_defs_in_mod(ctx, scope, &mod_path)?;\n+    let name_refs_in_source_file =\n+        source_file.syntax().descendants().filter_map(ast::NameRef::cast).collect();\n+    let used_names = find_used_names(ctx, defs_in_mod, name_refs_in_source_file);\n+\n+    let parent = star.parent().parent()?;\n+    acc.add(\n+        AssistId(\"expand_glob_import\", AssistKind::RefactorRewrite),\n+        \"Expand glob import\",\n+        parent.text_range(),\n+        |builder| {\n+            replace_ast(builder, &parent, mod_path, used_names);\n+        },\n+    )\n+}\n+\n+fn find_mod_path(star: &SyntaxToken) -> Option<ast::Path> {\n+    star.ancestors().find_map(|n| ast::UseTree::cast(n).and_then(|u| u.path()))\n+}\n+\n+#[derive(PartialEq)]\n+enum Def {\n+    ModuleDef(ModuleDef),\n+    MacroDef(MacroDef),\n+}\n+\n+impl Def {\n+    fn name(&self, db: &RootDatabase) -> Option<Name> {\n+        match self {\n+            Def::ModuleDef(def) => def.name(db),\n+            Def::MacroDef(def) => def.name(db),\n+        }\n+    }\n+}\n+\n+fn find_defs_in_mod(\n+    ctx: &AssistContext,\n+    from: SemanticsScope<'_>,\n+    path: &ast::Path,\n+) -> Option<Vec<Def>> {\n+    let hir_path = ctx.sema.lower_path(&path)?;\n+    let module = if let Some(PathResolution::Def(ModuleDef::Module(module))) =\n+        from.resolve_hir_path_qualifier(&hir_path)\n+    {\n+        module\n+    } else {\n+        return None;\n+    };\n+\n+    let module_scope = module.scope(ctx.db(), from.module());\n+\n+    let mut defs = vec![];\n+    for (_, def) in module_scope {\n+        match def {\n+            ScopeDef::ModuleDef(def) => defs.push(Def::ModuleDef(def)),\n+            ScopeDef::MacroDef(def) => defs.push(Def::MacroDef(def)),\n+            _ => continue,\n+        }\n+    }\n+\n+    Some(defs)\n+}\n+\n+fn find_used_names(\n+    ctx: &AssistContext,\n+    defs_in_mod: Vec<Def>,\n+    name_refs_in_source_file: Vec<ast::NameRef>,\n+) -> Vec<Name> {\n+    let defs_in_source_file = name_refs_in_source_file\n+        .iter()\n+        .filter_map(|r| classify_name_ref(&ctx.sema, r))\n+        .filter_map(|rc| match rc {\n+            NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n+            NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n+            _ => None,\n+        })\n+        .collect::<Vec<Def>>();\n+\n+    defs_in_mod\n+        .iter()\n+        .filter(|def| {\n+            if let Def::ModuleDef(ModuleDef::Trait(tr)) = def {\n+                for item in tr.items(ctx.db()) {\n+                    if let AssocItem::Function(f) = item {\n+                        if defs_in_source_file.contains(&Def::ModuleDef(ModuleDef::Function(f))) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            defs_in_source_file.contains(def)\n+        })\n+        .filter_map(|d| d.name(ctx.db()))\n+        .collect()\n+}\n+\n+fn replace_ast(\n+    builder: &mut AssistBuilder,\n+    node: &SyntaxNode,\n+    path: ast::Path,\n+    used_names: Vec<Name>,\n+) {\n+    let replacement: Either<ast::UseTree, ast::UseTreeList> = match used_names.as_slice() {\n+        [name] => Either::Left(ast::make::use_tree(\n+            ast::make::path_from_text(&format!(\"{}::{}\", path, name)),\n+            None,\n+            None,\n+            false,\n+        )),\n+        names => Either::Right(ast::make::use_tree_list(names.iter().map(|n| {\n+            ast::make::use_tree(ast::make::path_from_text(&n.to_string()), None, None, false)\n+        }))),\n+    };\n+\n+    let mut replace_node = |replacement: Either<ast::UseTree, ast::UseTreeList>| {\n+        algo::diff(node, &replacement.either(|u| u.syntax().clone(), |ut| ut.syntax().clone()))\n+            .into_text_edit(builder.text_edit_builder());\n+    };\n+\n+    match_ast! {\n+        match node {\n+            ast::UseTree(use_tree) => {\n+                replace_node(replacement);\n+            },\n+            ast::UseTreeList(use_tree_list) => {\n+                replace_node(replacement);\n+            },\n+            ast::Use(use_item) => {\n+                builder.replace_ast(use_item, ast::make::use_item(replacement.left_or_else(|ut| ast::make::use_tree(path, Some(ut), None, false))));\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn expanding_glob_import() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::*<|>;\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{Baz, Bar, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_existing_explicit_names() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{*<|>, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{Baz, Bar, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_nested_glob_import() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{*<|>, f}, baz::*};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{Baz, Bar, f}, baz::*};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_macro_defs() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! bar {\n+    () => ()\n+}\n+\n+pub fn baz() {}\n+\n+//- /main.rs crate:main deps:foo\n+use foo::*<|>;\n+\n+fn main() {\n+    bar!();\n+    baz();\n+}\n+\",\n+            r\"\n+use foo::{bar, baz};\n+\n+fn main() {\n+    bar!();\n+    baz();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_trait_method_uses() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+//- /lib.rs crate:foo\n+pub trait Tr {\n+    fn method(&self) {}\n+}\n+impl Tr for () {}\n+\n+//- /main.rs crate:main deps:foo\n+use foo::*<|>;\n+\n+fn main() {\n+    ().method();\n+}\n+\",\n+            r\"\n+use foo::Tr;\n+\n+fn main() {\n+    ().method();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_is_not_applicable_if_cursor_is_not_in_star_token() {\n+        check_assist_not_applicable(\n+            expand_glob_import,\n+            r\"\n+    mod foo {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+    }\n+\n+    use foo::Bar<|>;\n+\n+    fn qux(bar: Bar, baz: Baz) {}\n+    \",\n+        )\n+    }\n+}"}, {"sha": "507646cc802899573e1b8a1807b43b5fb4ea0fb1", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "patch": "@@ -140,6 +140,7 @@ mod handlers {\n     mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n+    mod expand_glob_import;\n     mod extract_struct_from_enum_variant;\n     mod extract_variable;\n     mod fill_match_arms;\n@@ -181,6 +182,7 @@ mod handlers {\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n+            expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_variable::extract_variable,\n             fill_match_arms::fill_match_arms,"}, {"sha": "97978e7a2e4b9e40b7e1574dfd28d7d975d6718b", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "patch": "@@ -228,6 +228,33 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_expand_glob_import() {\n+    check_doc_test(\n+        \"expand_glob_import\",\n+        r#####\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+}\n+\n+use foo::*<|>;\n+\n+fn qux(bar: Bar, baz: Baz) {}\n+\"#####,\n+        r#####\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+}\n+\n+use foo::{Baz, Bar};\n+\n+fn qux(bar: Bar, baz: Baz) {}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_extract_struct_from_enum_variant() {\n     check_doc_test("}, {"sha": "3cb1d35eeca51fde9290661fed1ec49a94d72a6b", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=5ebf92cd0ed4be97fe0ca5bffefbe292db1ec4cf", "patch": "@@ -30,7 +30,7 @@ pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n     path_from_text(&format!(\"{}::{}\", qual, segment))\n }\n-fn path_from_text(text: &str) -> ast::Path {\n+pub fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n "}]}