{"sha": "8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMGZlYjU4ZTdmNWFlNjc1NDZkYjljM2NkN2ZkZjRhYjc5MmQ4Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-13T18:07:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-13T18:07:31Z"}, "message": "auto merge of #7763 : dotdash/rust/empty_blocks, r=pcwalton\n\nThese commits remove a bunch of empty or otherwise unnecessary blocks, reducing the size of the pre-optimization IR and improving its readability. `librustc.ll` created with `--passes \"\"` shrinks by about 120k lines which equals about 5% of the total size.", "tree": {"sha": "a15e1607b669c08c28735e585f67e75a3e10980e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a15e1607b669c08c28735e585f67e75a3e10980e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "html_url": "https://github.com/rust-lang/rust/commit/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48bfb90865722cf9ffa62a611b3dd41ba8f3d2e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/48bfb90865722cf9ffa62a611b3dd41ba8f3d2e4", "html_url": "https://github.com/rust-lang/rust/commit/48bfb90865722cf9ffa62a611b3dd41ba8f3d2e4"}, {"sha": "1d2e1a9ae5cc1affe54e3280cf272197a036beaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2e1a9ae5cc1affe54e3280cf272197a036beaf", "html_url": "https://github.com/rust-lang/rust/commit/1d2e1a9ae5cc1affe54e3280cf272197a036beaf"}], "stats": {"total": 261, "additions": 163, "deletions": 98}, "files": [{"sha": "1173fa4941963c79d0f55580b448aaddca5c5c37", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 89, "deletions": 37, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "patch": "@@ -1102,11 +1102,6 @@ pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n     Call(bcx, ccx.upcalls.trace, args);\n }\n \n-pub fn build_return(bcx: block) {\n-    let _icx = push_ctxt(\"build_return\");\n-    Br(bcx, bcx.fcx.llreturn);\n-}\n-\n pub fn ignore_lhs(_bcx: block, local: &ast::local) -> bool {\n     match local.node.pat.node {\n         ast::pat_wild => true, _ => false\n@@ -1364,6 +1359,42 @@ pub fn cleanup_and_leave(bcx: block,\n     }\n }\n \n+pub fn cleanup_block(bcx: block, upto: Option<BasicBlockRef>) -> block{\n+    let _icx = push_ctxt(\"cleanup_block\");\n+    let mut cur = bcx;\n+    let mut bcx = bcx;\n+    loop {\n+        debug!(\"cleanup_block: %s\", cur.to_str());\n+\n+        if bcx.sess().trace() {\n+            trans_trace(\n+                bcx, None,\n+                (fmt!(\"cleanup_block(%s)\", cur.to_str())).to_managed());\n+        }\n+\n+        let mut cur_scope = cur.scope;\n+        loop {\n+            cur_scope = match cur_scope {\n+                Some (inf) => {\n+                    bcx = trans_block_cleanups_(bcx, inf.cleanups.to_owned(), false);\n+                    inf.parent\n+                }\n+                None => break\n+            }\n+        }\n+\n+        match upto {\n+          Some(bb) => { if cur.llbb == bb { break; } }\n+          _ => ()\n+        }\n+        cur = match cur.parent {\n+          Some(next) => next,\n+          None => { assert!(upto.is_none()); break; }\n+        };\n+    }\n+    bcx\n+}\n+\n pub fn cleanup_and_Br(bcx: block, upto: block, target: BasicBlockRef) {\n     let _icx = push_ctxt(\"cleanup_and_Br\");\n     cleanup_and_leave(bcx, Some(upto.llbb), Some(target));\n@@ -1526,7 +1557,7 @@ pub fn alloca_maybe_zeroed(cx: block, ty: Type, name: &str, zero: bool) -> Value\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n-    let initcx = base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n+    let initcx = base::raw_block(cx.fcx, false, cx.fcx.get_llstaticallocas());\n     let p = Alloca(initcx, ty, name);\n     if zero { memzero(initcx, p, ty); }\n     p\n@@ -1539,24 +1570,26 @@ pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n-    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), ty, v);\n+    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.get_llstaticallocas()), ty, v);\n }\n \n pub struct BasicBlocks {\n     sa: BasicBlockRef,\n-    rt: BasicBlockRef\n }\n \n-// Creates the standard set of basic blocks for a function\n-pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n+pub fn mk_staticallocas_basic_block(llfn: ValueRef) -> BasicBlockRef {\n     unsafe {\n         let cx = task_llcx();\n-        BasicBlocks {\n-            sa: str::as_c_str(\"static_allocas\",\n-                           |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf)),\n-            rt: str::as_c_str(\"return\",\n-                           |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n-        }\n+        str::as_c_str(\"static_allocas\",\n+                      |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n+    }\n+}\n+\n+pub fn mk_return_basic_block(llfn: ValueRef) -> BasicBlockRef {\n+    unsafe {\n+        let cx = task_llcx();\n+        str::as_c_str(\"return\",\n+                      |buf| llvm::LLVMAppendBasicBlockInContext(cx, llfn, buf))\n     }\n }\n \n@@ -1568,7 +1601,7 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype,\n+            alloca(raw_block(fcx, false, fcx.get_llstaticallocas()), lloutputtype,\n                    \"__make_return_pointer\")\n         }\n     }\n@@ -1596,8 +1629,6 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n            id,\n            param_substs.repr(ccx.tcx));\n \n-    let llbbs = mk_standard_basic_blocks(llfndecl);\n-\n     let substd_output_type = match param_substs {\n         None => output_type,\n         Some(substs) => {\n@@ -1611,9 +1642,9 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n               llvm::LLVMGetUndef(Type::i8p().to_ref())\n           },\n           llretptr: None,\n-          llstaticallocas: llbbs.sa,\n+          llstaticallocas: None,\n           llloadenv: None,\n-          llreturn: llbbs.rt,\n+          llreturn: None,\n           llself: None,\n           personality: None,\n           loop_ret: None,\n@@ -1757,16 +1788,24 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n+pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef, last_bcx: block) {\n     let _icx = push_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n-    build_return_block(fcx);\n+\n+    let ret_cx = match fcx.llreturn {\n+        Some(llreturn) => {\n+            if !last_bcx.terminated {\n+                Br(last_bcx, llreturn);\n+            }\n+            raw_block(fcx, false, llreturn)\n+        }\n+        None => last_bcx\n+    };\n+    build_return_block(fcx, ret_cx);\n }\n \n // Builds the return block for a function.\n-pub fn build_return_block(fcx: fn_ctxt) {\n-    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n-\n+pub fn build_return_block(fcx: fn_ctxt, ret_cx: block) {\n     // Return the value if this function immediate; otherwise, return void.\n     if fcx.llretptr.is_some() && fcx.has_immediate_return_value {\n         Ret(ret_cx, Load(ret_cx, fcx.llretptr.get()))\n@@ -1777,14 +1816,24 @@ pub fn build_return_block(fcx: fn_ctxt) {\n \n pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = push_ctxt(\"tie_up_header_blocks\");\n-    match fcx.llloadenv {\n+    let llnext = match fcx.llloadenv {\n         Some(ll) => {\n-            Br(raw_block(fcx, false, fcx.llstaticallocas), ll);\n+            unsafe {\n+                llvm::LLVMMoveBasicBlockBefore(ll, lltop);\n+            }\n             Br(raw_block(fcx, false, ll), lltop);\n+            ll\n         }\n-        None => {\n-            Br(raw_block(fcx, false, fcx.llstaticallocas), lltop);\n+        None => lltop\n+    };\n+    match fcx.llstaticallocas {\n+        Some(ll) => {\n+            unsafe {\n+                llvm::LLVMMoveBasicBlockBefore(ll, llnext);\n+            }\n+            Br(raw_block(fcx, false, ll), llnext);\n         }\n+        None => ()\n     }\n }\n \n@@ -1854,16 +1903,21 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     }\n \n     finish(bcx);\n-    cleanup_and_Br(bcx, bcx_top, fcx.llreturn);\n+    match fcx.llreturn {\n+        Some(llreturn) => cleanup_and_Br(bcx, bcx_top, llreturn),\n+        None => bcx = cleanup_block(bcx, Some(bcx_top.llbb))\n+    };\n \n     // Put return block after all other blocks.\n     // This somewhat improves single-stepping experience in debugger.\n     unsafe {\n-        llvm::LLVMMoveBasicBlockAfter(fcx.llreturn, bcx.llbb);\n+        for fcx.llreturn.iter().advance |&llreturn| {\n+            llvm::LLVMMoveBasicBlockAfter(llreturn, bcx.llbb);\n+        }\n     }\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(fcx, lltop);\n+    finish_fn(fcx, lltop, bcx);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -2046,8 +2100,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    finish_fn(fcx, lltop, bcx);\n }\n \n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n@@ -2288,8 +2341,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         let args = ~[llenvarg];\n         Call(bcx, main_llfn, args);\n \n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n         return llfdecl;\n     }\n "}, {"sha": "7b7989879a639a4758e2db95bbe2dc46a3f9cc41", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "patch": "@@ -704,7 +704,7 @@ pub fn trans_call_inner(in_cx: block,\n                         Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n                     }\n                 }\n-                base::cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+                base::cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n                 Unreachable(bcx);\n                 bcx\n             }"}, {"sha": "83029a90260ff5d3afe35c215fd4815118a356a9", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "patch": "@@ -178,13 +178,13 @@ pub struct fn_ctxt_ {\n     // the function, due to LLVM's quirks.\n     // A block for all the function's static allocas, so that LLVM\n     // will coalesce them into a single alloca call.\n-    llstaticallocas: BasicBlockRef,\n+    llstaticallocas: Option<BasicBlockRef>,\n     // A block containing code that copies incoming arguments to space\n     // already allocated by code in one of the llallocas blocks.\n     // (LLVM requires that arguments be copied to local allocas before\n     // allowing most any operation to be performed on them.)\n     llloadenv: Option<BasicBlockRef>,\n-    llreturn: BasicBlockRef,\n+    llreturn: Option<BasicBlockRef>,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n     //\n@@ -251,6 +251,21 @@ impl fn_ctxt_ {\n         }\n     }\n \n+    pub fn get_llstaticallocas(&mut self) -> BasicBlockRef {\n+        if self.llstaticallocas.is_none() {\n+            self.llstaticallocas = Some(base::mk_staticallocas_basic_block(self.llfn));\n+        }\n+\n+        self.llstaticallocas.get()\n+    }\n+\n+    pub fn get_llreturn(&mut self) -> BasicBlockRef {\n+        if self.llreturn.is_none() {\n+            self.llreturn = Some(base::mk_return_basic_block(self.llfn));\n+        }\n+\n+        self.llreturn.get()\n+    }\n }\n \n pub type fn_ctxt = @mut fn_ctxt_;"}, {"sha": "81260428f241bc06e814971ef0342c8fd918f7e0", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "patch": "@@ -67,13 +67,8 @@ pub fn trans_if(bcx: block,\n         expr::trans_to_datum(bcx, cond).to_result();\n \n     let then_bcx_in = scope_block(bcx, thn.info(), \"then\");\n-    let else_bcx_in = scope_block(bcx, els.info(), \"else\");\n \n     let cond_val = bool_to_i1(bcx, cond_val);\n-    CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n-\n-    debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n-           then_bcx_in.to_str(), else_bcx_in.to_str());\n \n     let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n     let then_bcx_out = trans_block_cleanups(then_bcx_out,\n@@ -83,9 +78,10 @@ pub fn trans_if(bcx: block,\n     // because trans_expr will create another scope block\n     // context for the block, but we've already got the\n     // 'else' context\n-    let else_bcx_out = match els {\n+    let (else_bcx_in, next_bcx) = match els {\n       Some(elexpr) => {\n-        match elexpr.node {\n+        let else_bcx_in = scope_block(bcx, els.info(), \"else\");\n+        let else_bcx_out = match elexpr.node {\n           ast::expr_if(_, _, _) => {\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n             trans_block(else_bcx_in, &elseif_blk, dest)\n@@ -95,14 +91,25 @@ pub fn trans_if(bcx: block,\n           }\n           // would be nice to have a constraint on ifs\n           _ => bcx.tcx().sess.bug(\"strange alternative in if\")\n-        }\n+        };\n+        let else_bcx_out = trans_block_cleanups(else_bcx_out,\n+                                                block_cleanups(else_bcx_in));\n+\n+        (else_bcx_in, join_blocks(bcx, [then_bcx_out, else_bcx_out]))\n+      }\n+      _ => {\n+          let next_bcx = sub_block(bcx, \"next\");\n+          Br(then_bcx_out, next_bcx.llbb);\n+\n+          (next_bcx, next_bcx)\n       }\n-      _ => else_bcx_in\n     };\n-    let else_bcx_out = trans_block_cleanups(else_bcx_out,\n-                                            block_cleanups(else_bcx_in));\n-    return join_blocks(bcx, [then_bcx_out, else_bcx_out]);\n \n+    debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n+           then_bcx_in.to_str(), else_bcx_in.to_str());\n+\n+    CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n+    next_bcx\n }\n \n pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n@@ -279,7 +286,7 @@ pub fn trans_break_cont(bcx: block,\n                         // This is a return from a loop body block\n                         None => {\n                             Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n-                            cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+                            cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n                             Unreachable(bcx);\n                             return bcx;\n                         }\n@@ -328,7 +335,7 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n       }\n       _ => ()\n     }\n-    cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n+    cleanup_and_leave(bcx, None, Some(bcx.fcx.get_llreturn()));\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "edf003e3e529ecf77e852443f334d4a9d4f391b5", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "patch": "@@ -164,7 +164,10 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n     // follow the normal Rust calling conventions.\n     tie_up_header_blocks(fcx, lltop);\n \n-    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n+    let ret_cx = match fcx.llreturn {\n+        Some(llreturn) => raw_block(fcx, false, llreturn),\n+        None => bcx\n+    };\n     RetVoid(ret_cx);\n \n     return llshimfn;\n@@ -194,7 +197,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     // the C ABI.\n     if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n         let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n-        fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n+        fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.get_llstaticallocas()),\n                                    lloutputtype,\n                                    \"\"));\n     }\n@@ -217,7 +220,10 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     tie_up_header_blocks(fcx, lltop);\n \n     // Then return according to the C ABI.\n-    let return_context = raw_block(fcx, false, fcx.llreturn);\n+    let return_context = match fcx.llreturn {\n+        Some(llreturn) => raw_block(fcx, false, llreturn),\n+        None => bcx\n+    };\n \n     let llfunctiontype = val_ty(llwrapfn);\n     let llfunctiontype = llfunctiontype.element_type();\n@@ -388,7 +394,6 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                                      tys.ret_def,\n                                      llargbundle,\n                                      llretval);\n-            build_return(bcx);\n         }\n \n         let lname = link_name(ccx, foreign_item);\n@@ -438,8 +443,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n     }\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n@@ -467,8 +471,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n     }\n \n     fn build_wrap_fn(ccx: @mut CrateContext,\n@@ -534,7 +537,6 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n                 let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n                 Store(bcx, Load(bcx, llretptr), retptr);\n             }\n-            build_return(bcx);\n         }\n     }\n }\n@@ -629,8 +631,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             }\n         }\n \n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+        finish_fn(fcx, lltop, bcx);\n \n         return;\n     }\n@@ -1124,8 +1125,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    finish_fn(fcx, lltop, bcx);\n }\n \n /**\n@@ -1257,8 +1257,6 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                 // NB: The return pointer in the Rust ABI function is wired\n                 // directly into the return slot in the shim struct.\n             }\n-\n-            build_return(bcx);\n         }\n \n         let shim_name = link::mangle_internal_name_by_path(\n@@ -1314,7 +1312,6 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n         fn build_ret(bcx: block, tys: &ShimTypes, llargbundle: ValueRef) {\n             let _icx = push_ctxt(\"foreign::foreign::wrap::build_ret\");\n             tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n-            build_return(bcx);\n         }\n     }\n "}, {"sha": "418c89e603d07a5db35d1a2fcc8b9e6c0123357a", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "patch": "@@ -348,24 +348,23 @@ pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n     return cx;\n }\n \n-pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = push_ctxt(\"make_visit_glue\");\n-    let bcx = do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n+    do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n         let v = PointerCast(bcx, v, type_of::type_of(bcx.ccx(), object_ty).ptr_to());\n         bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, visitor_trait.def_id);\n         // The visitor is a boxed object and needs to be dropped\n         add_clean(bcx, v, object_ty);\n         bcx\n-    };\n-    build_return(bcx);\n+    }\n }\n \n-pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n-    let bcx = match ty::get(t).sty {\n+    match ty::get(t).sty {\n       ty::ty_box(body_mt) => {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n@@ -389,9 +388,7 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         tvec::make_uniq_free_glue(bcx, v, t)\n       }\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n-        make_free_glue(bcx, v,\n-                       tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n-        return;\n+        make_free_glue(bcx, v, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n       }\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v, t, free_ty)\n@@ -400,8 +397,7 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n       _ => bcx\n-    };\n-    build_return(bcx);\n+    }\n }\n \n pub fn trans_struct_drop_flag(bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::def_id,\n@@ -475,11 +471,11 @@ pub fn trans_struct_drop(mut bcx: block, t: ty::t, v0: ValueRef, dtor_did: ast::\n     bcx\n }\n \n-pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n+pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) -> block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n-    let bcx = match ty::get(t).sty {\n+    match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, Load(bcx, v0), Some(v0), t)\n@@ -542,8 +538,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n             iter_structural_ty(bcx, v0, t, drop_ty)\n         } else { bcx }\n       }\n-    };\n-    build_return(bcx);\n+    }\n }\n \n // box_ptr_ptr is optional, it is constructed if not supplied.\n@@ -569,10 +564,10 @@ pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef,\n }\n \n \n-pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n+pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n-    let bcx = match ty::get(t).sty {\n+    match ty::get(t).sty {\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n@@ -638,9 +633,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n         iter_structural_ty(bcx, v, t, take_ty)\n       }\n       _ => bcx\n-    };\n-\n-    build_return(bcx);\n+    }\n }\n \n pub fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) {\n@@ -690,7 +683,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'self> = &'self fn(block, ValueRef, ty::t);\n+pub type glue_helper<'self> = &'self fn(block, ValueRef, ty::t) -> block;\n \n pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n@@ -723,11 +716,9 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let llty = type_of(ccx, t);\n     let llrawptr0 = PointerCast(bcx, llrawptr0, llty.ptr_to());\n-    helper(bcx, llrawptr0, t);\n+    let bcx = helper(bcx, llrawptr0, t);\n \n-    // This is from the general finish fn, but that emits a ret {} that we don't want\n-    Br(raw_block(fcx, false, fcx.llstaticallocas), lltop);\n-    RetVoid(raw_block(fcx, false, fcx.llreturn));\n+    finish_fn(fcx, lltop, bcx);\n \n     return llfn;\n }"}, {"sha": "dee40f32169eedfb5eb424dcc27b50db50d541b1", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=8d0feb58e7f5ae67546db9c3cd7fdf4ab792d839", "patch": "@@ -299,12 +299,15 @@ impl Reflector {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let bcx = top_scope_block(fcx, None);\n+                let mut bcx = top_scope_block(fcx, None);\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg);\n                 Store(bcx, ret, fcx.llretptr.get());\n-                cleanup_and_Br(bcx, bcx, fcx.llreturn);\n-                finish_fn(fcx, bcx.llbb);\n+                match fcx.llreturn {\n+                    Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n+                    None => bcx = cleanup_block(bcx, Some(bcx.llbb))\n+                };\n+                finish_fn(fcx, bcx.llbb, bcx);\n                 llfdecl\n             };\n "}]}