{"sha": "5c717a6fc21594569d9e64968cdcf2e88e372a07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNzE3YTZmYzIxNTk0NTY5ZDllNjQ5NjhjZGNmMmU4OGUzNzJhMDc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-03-11T10:54:59Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-08T21:38:38Z"}, "message": "implement RFC495 semantics for slice patterns\n\nnon-MIR translation is still not supported for these and will happily ICE.\n\nThis is a [breaking-change] for many uses of slice_patterns.", "tree": {"sha": "c9ab272d35fec2aa900ca7bb06f493e8d849d83b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9ab272d35fec2aa900ca7bb06f493e8d849d83b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c717a6fc21594569d9e64968cdcf2e88e372a07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c717a6fc21594569d9e64968cdcf2e88e372a07", "html_url": "https://github.com/rust-lang/rust/commit/5c717a6fc21594569d9e64968cdcf2e88e372a07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c717a6fc21594569d9e64968cdcf2e88e372a07/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "088b7e2108abd54a31d573301d7c90e012d09150", "url": "https://api.github.com/repos/rust-lang/rust/commits/088b7e2108abd54a31d573301d7c90e012d09150", "html_url": "https://github.com/rust-lang/rust/commit/088b7e2108abd54a31d573301d7c90e012d09150"}], "stats": {"total": 1139, "additions": 621, "deletions": 518}, "files": [{"sha": "ba93e8976771602761dc797a963a97c9fe0733cb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -993,40 +993,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                 }\n-                PatKind::Vec(_, Some(ref slice_pat), _) => {\n-                    // The `slice_pat` here creates a slice into\n-                    // the original vector.  This is effectively a\n-                    // borrow of the elements of the vector being\n-                    // matched.\n-\n-                    let (slice_cmt, slice_mutbl, slice_r) =\n-                        return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n-\n-                    // Note: We declare here that the borrow\n-                    // occurs upon entering the `[...]`\n-                    // pattern. This implies that something like\n-                    // `[a; b]` where `a` is a move is illegal,\n-                    // because the borrow is already in effect.\n-                    // In fact such a move would be safe-ish, but\n-                    // it effectively *requires* that we use the\n-                    // nulling out semantics to indicate when a\n-                    // value has been moved, which we are trying\n-                    // to move away from.  Otherwise, how can we\n-                    // indicate that the first element in the\n-                    // vector has been moved?  Eventually, we\n-                    // could perhaps modify this rule to permit\n-                    // `[..a, b]` where `b` is a move, because in\n-                    // that case we can adjust the length of the\n-                    // original vec accordingly, but we'd have to\n-                    // make trans do the right thing, and it would\n-                    // only work for `Box<[T]>`s. It seems simpler\n-                    // to just require that people call\n-                    // `vec.pop()` or `vec.unshift()`.\n-                    let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);\n-                    delegate.borrow(pat.id, pat.span,\n-                                    slice_cmt, slice_r,\n-                                    slice_bk, RefBinding);\n-                }\n                 _ => {}\n             }\n         }));"}, {"sha": "fc76c00aaf1e36c75758dadb71542a76904d4273", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -1061,43 +1061,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         Ok(ret)\n     }\n \n-    /// Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is the cmt for `P`, `slice_pat` is\n-    /// the pattern `Q`, returns:\n-    ///\n-    /// * a cmt for `Q`\n-    /// * the mutability and region of the slice `Q`\n-    ///\n-    /// These last two bits of info happen to be things that borrowck needs.\n-    pub fn cat_slice_pattern(&self,\n-                             vec_cmt: cmt<'tcx>,\n-                             slice_pat: &hir::Pat)\n-                             -> McResult<(cmt<'tcx>, hir::Mutability, ty::Region)> {\n-        let slice_ty = self.node_ty(slice_pat.id)?;\n-        let (slice_mutbl, slice_r) = vec_slice_info(slice_pat, slice_ty);\n-        let context = InteriorOffsetKind::Pattern;\n-        let cmt_vec = self.deref_vec(slice_pat, vec_cmt, context)?;\n-        let cmt_slice = self.cat_index(slice_pat, cmt_vec, context)?;\n-        return Ok((cmt_slice, slice_mutbl, slice_r));\n-\n-        /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n-        /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n-        /// have to recurse through rptrs.\n-        fn vec_slice_info(pat: &hir::Pat, slice_ty: Ty)\n-                          -> (hir::Mutability, ty::Region) {\n-            match slice_ty.sty {\n-                ty::TyRef(r, ref mt) => match mt.ty.sty {\n-                    ty::TySlice(_) => (mt.mutbl, *r),\n-                    _ => vec_slice_info(pat, mt.ty),\n-                },\n-\n-                _ => {\n-                    span_bug!(pat.span,\n-                              \"type of slice pattern is not a slice\");\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn cat_imm_interior<N:ast_node>(&self,\n                                         node: &N,\n                                         base_cmt: cmt<'tcx>,\n@@ -1325,9 +1288,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                   self.cat_pattern_(elt_cmt.clone(), &before_pat, op)?;\n               }\n               if let Some(ref slice_pat) = *slice {\n-                  let slice_ty = self.pat_ty(&slice_pat)?;\n-                  let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern_(slice_cmt, &slice_pat, op)?;\n+                  self.cat_pattern_(elt_cmt.clone(), &slice_pat, op)?;\n               }\n               for after_pat in after {\n                   self.cat_pattern_(elt_cmt.clone(), &after_pat, op)?;"}, {"sha": "7aaaf38400e878586d1e3476e5817a4dfd107e14", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -674,6 +674,14 @@ pub enum ProjectionElem<'tcx, V> {\n         from_end: bool,\n     },\n \n+    /// These indices are generated by slice patterns.\n+    ///\n+    /// slice[from:-to] in Python terms.\n+    Subslice {\n+        from: u32,\n+        to: u32,\n+    },\n+\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n@@ -753,6 +761,14 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n                         write!(fmt, \"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n                         write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n+                    ProjectionElem::Subslice { from, to } if to == 0 =>\n+                        write!(fmt, \"{:?}[{:?}:\", data.base, from),\n+                    ProjectionElem::Subslice { from, to } if from == 0 =>\n+                        write!(fmt, \"{:?}[:-{:?}]\", data.base, to),\n+                    ProjectionElem::Subslice { from, to } =>\n+                        write!(fmt, \"{:?}[{:?}:-{:?}]\", data.base,\n+                               from, to),\n+\n                 },\n         }\n     }\n@@ -856,17 +872,6 @@ pub enum Rvalue<'tcx> {\n     /// away after type-checking and before lowering.\n     Aggregate(AggregateKind<'tcx>, Vec<Operand<'tcx>>),\n \n-    /// Generates a slice of the form `&input[from_start..L-from_end]`\n-    /// where `L` is the length of the slice. This is only created by\n-    /// slice pattern matching, so e.g. a pattern of the form `[x, y,\n-    /// .., z]` might create a slice with `from_start=2` and\n-    /// `from_end=1`.\n-    Slice {\n-        input: Lvalue<'tcx>,\n-        from_start: usize,\n-        from_end: usize,\n-    },\n-\n     InlineAsm {\n         asm: InlineAsm,\n         outputs: Vec<Lvalue<'tcx>>,\n@@ -972,8 +977,6 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)\n             }\n-            Slice { ref input, from_start, from_end } =>\n-                write!(fmt, \"{:?}[{:?}..-{:?}]\", input, from_start, from_end),\n \n             Ref(_, borrow_kind, ref lv) => {\n                 let kind_str = match borrow_kind {"}, {"sha": "270e33c48f1a0b411b8f38374621eced24ee14ed", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -59,6 +59,20 @@ impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n                 LvalueTy::Ty {\n                     ty: self.to_ty(tcx).builtin_index().unwrap()\n                 },\n+            ProjectionElem::Subslice { from, to } => {\n+                let ty = self.to_ty(tcx);\n+                LvalueTy::Ty {\n+                    ty: match ty.sty {\n+                        ty::TyArray(inner, size) => {\n+                            tcx.mk_array(inner, size-(from as usize)-(to as usize))\n+                        }\n+                        ty::TySlice(..) => ty,\n+                        _ => {\n+                            bug!(\"cannot subslice non-array type: `{:?}`\", self)\n+                        }\n+                    }\n+                }\n+            }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match self.to_ty(tcx).sty {\n                     ty::TyEnum(adt_def, substs) => {\n@@ -219,7 +233,6 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                     }\n                 }\n             }\n-            Rvalue::Slice { .. } => None,\n             Rvalue::InlineAsm { .. } => None\n         }\n     }"}, {"sha": "22b3caf6d0c0ff6e60f8668bccc788452fa3b3eb", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -533,15 +533,6 @@ macro_rules! make_mir_visitor {\n                         }\n                     }\n \n-                    Rvalue::Slice { ref $($mutability)* input,\n-                                    from_start,\n-                                    from_end } => {\n-                        self.visit_lvalue(input, LvalueContext::Slice {\n-                            from_start: from_start,\n-                            from_end: from_end,\n-                        });\n-                    }\n-\n                     Rvalue::InlineAsm { ref $($mutability)* outputs,\n                                         ref $($mutability)* inputs,\n                                         asm: _ } => {\n@@ -602,6 +593,8 @@ macro_rules! make_mir_visitor {\n                 match *proj {\n                     ProjectionElem::Deref => {\n                     }\n+                    ProjectionElem::Subslice { from: _, to: _ } => {\n+                    }\n                     ProjectionElem::Field(_field, ref $($mutability)* ty) => {\n                         self.visit_ty(ty);\n                     }"}, {"sha": "155b615d83c7b704262e424fc49a652cafab8b27", "filename": "src/librustc_borrowck/borrowck/mir/abs_domain.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fabs_domain.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -49,6 +49,8 @@ impl<'tcx> Lift for LvalueElem<'tcx> {\n                 ProjectionElem::Field(f.clone(), ty.clone()),\n             ProjectionElem::Index(ref i) =>\n                 ProjectionElem::Index(i.lift()),\n+            ProjectionElem::Subslice {from, to} =>\n+                ProjectionElem::Subslice { from: from, to: to },\n             ProjectionElem::ConstantIndex {offset,min_length,from_end} =>\n                 ProjectionElem::ConstantIndex {\n                     offset: offset,"}, {"sha": "1acee8e64a9af4ffd2b3aa28f160548157977389", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -620,22 +620,6 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                         Rvalue::Ref(..) |\n                         Rvalue::Len(..) |\n                         Rvalue::InlineAsm { .. } => {}\n-\n-                        Rvalue::Slice {..} => {\n-                            // A slice pattern `x..` binds `x` to a\n-                            // reference; thus no move occurs.\n-                            //\n-                            // FIXME: I recall arielb1 questioning\n-                            // whether this is even a legal thing to\n-                            // have as an R-value. The particular\n-                            // example where I am seeing this arise is\n-                            // `TargetDataLayout::parse(&Session)` in\n-                            // `rustc::ty::layout`.\n-                            //\n-                            // this should be removed soon.\n-                            debug!(\"encountered Rvalue::Slice as RHS of Assign, source: {:?}\",\n-                                   source);\n-                        }\n                     }\n                 }\n             }"}, {"sha": "c3da2b9e53d828c3bd04e9fd54088050491213a8", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 45, "deletions": 58, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -109,7 +109,7 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub param_env: ParameterEnvironment<'tcx>,\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum Constructor {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g. struct patterns and fixed-length arrays.\n@@ -584,31 +584,19 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n             }\n         }\n \n-        ty::TyRef(_, ty::TypeAndMut { ty, mutbl }) => {\n-            match ty.sty {\n-               ty::TyArray(_, n) => match ctor {\n-                    &Single => {\n-                        assert_eq!(pats_len, n);\n-                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n-                    },\n-                    _ => bug!()\n-                },\n-                ty::TySlice(_) => match ctor {\n-                    &Slice(n) => {\n-                        assert_eq!(pats_len, n);\n-                        PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n-                    },\n-                    _ => bug!()\n-                },\n-                ty::TyStr => PatKind::Wild,\n-\n-                _ => {\n-                    assert_eq!(pats_len, 1);\n-                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n-                }\n-            }\n+        ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n+            assert_eq!(pats_len, 1);\n+            PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n         }\n \n+        ty::TySlice(_) => match ctor {\n+            &Slice(n) => {\n+                assert_eq!(pats_len, n);\n+                PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n+            },\n+            _ => unreachable!()\n+        },\n+\n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n             PatKind::Vec(pats.collect(), None, hir::HirVec::new())\n@@ -660,13 +648,8 @@ fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n     match left_ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n-\n-        ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n-            ty::TySlice(_) =>\n-                (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n-            _ => vec![Single]\n-        },\n-\n+        ty::TySlice(_) =>\n+            (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n         ty::TyEnum(def, _) => def.variants.iter().map(|v| Variant(v.did)).collect(),\n         _ => vec![Single]\n     }\n@@ -818,13 +801,14 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n         PatKind::Vec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n                 ty::TyArray(_, _) => vec![Single],\n-                _                      => if slice.is_some() {\n+                ty::TySlice(_) if slice.is_some() => {\n                     (before.len() + after.len()..max_slice_length+1)\n                         .map(|length| Slice(length))\n                         .collect()\n-                } else {\n-                    vec![Slice(before.len() + after.len())]\n                 }\n+                ty::TySlice(_) => vec!(Slice(before.len() + after.len())),\n+                _ => span_bug!(pat.span, \"pat_constructors: unexpected \\\n+                                          slice pattern type {:?}\", left_ty)\n             },\n         PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n             vec![Single],\n@@ -839,18 +823,16 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n         ty::TyBox(_) => 1,\n-        ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n-            ty::TySlice(_) => match *ctor {\n-                Slice(length) => length,\n-                ConstantValue(_) => 0,\n-                _ => bug!()\n-            },\n-            ty::TyStr => 0,\n-            _ => 1\n+        ty::TySlice(_) => match *ctor {\n+            Slice(length) => length,\n+            ConstantValue(_) => 0,\n+            _ => bug!()\n         },\n+        ty::TyRef(..) => 1,\n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _) => {\n             ctor.variant_for_adt(adt).fields.len()\n         }\n@@ -988,29 +970,34 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         PatKind::Vec(ref before, ref slice, ref after) => {\n+            let pat_len = before.len() + after.len();\n             match *constructor {\n-                // Fixed-length vectors.\n                 Single => {\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n-                    pats.extend(after.iter().map(|p| &**p));\n-                    Some(pats)\n-                },\n-                Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n-                    pats.extend(after.iter().map(|p| &**p));\n-                    Some(pats)\n-                },\n-                Slice(length) if before.len() + after.len() == length => {\n-                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.extend(after.iter().map(|p| &**p));\n-                    Some(pats)\n+                    // Fixed-length vectors.\n+                    Some(\n+                        before.iter().map(|p| &**p).chain(\n+                        repeat(DUMMY_WILD_PAT).take(arity - pat_len).chain(\n+                        after.iter().map(|p| &**p)\n+                    )).collect())\n                 },\n+                Slice(length) if pat_len <= length && slice.is_some() => {\n+                    Some(\n+                        before.iter().map(|p| &**p).chain(\n+                        repeat(DUMMY_WILD_PAT).take(arity - pat_len).chain(\n+                        after.iter().map(|p| &**p)\n+                    )).collect())\n+                }\n+                Slice(length) if pat_len == length => {\n+                    Some(\n+                        before.iter().map(|p| &**p).chain(\n+                        after.iter().map(|p| &**p)\n+                    ).collect())\n+                }\n                 SliceWithSubslice(prefix, suffix)\n                     if before.len() == prefix\n                         && after.len() == suffix\n                         && slice.is_some() => {\n+                    // this is used by trans::_match only\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)"}, {"sha": "ffb13356ba2c248638f6bdd790d1c7a640694e0a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 66, "deletions": 25, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -429,42 +429,83 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// simpler (and, in fact, irrefutable).\n     ///\n     /// But there may also be candidates that the test just doesn't\n-    /// apply to. For example, consider the case of #29740:\n+    /// apply to. The classical example involves wildcards:\n     ///\n     /// ```rust,ignore\n-    /// match x {\n-    ///     \"foo\" => ...,\n-    ///     \"bar\" => ...,\n-    ///     \"baz\" => ...,\n-    ///     _ => ...,\n+    /// match (x, y) {\n+    ///     (true, _) => true,      // (0)\n+    ///     (_, true) => true,      // (1)\n+    ///     (false, false) => false // (2)\n     /// }\n     /// ```\n     ///\n-    /// Here the match-pair we are testing will be `x @ \"foo\"`, and we\n-    /// will generate an `Eq` test. Because `\"bar\"` and `\"baz\"` are different\n-    /// constants, we will decide that these later candidates are just not\n-    /// informed by the eq test. So we'll wind up with three candidate sets:\n+    /// In that case, after we test on `x`, there are 2 overlapping candidate\n+    /// sets:\n+    ///\n+    /// - If the outcome is that `x` is true, candidates 0 and 2\n+    /// - If the outcome is that `x` is false, candidates 1 and 2\n     ///\n-    /// - If outcome is that `x == \"foo\"` (one candidate, derived from `x @ \"foo\"`)\n-    /// - If outcome is that `x != \"foo\"` (empty list of candidates)\n-    /// - Otherwise (three candidates, `x @ \"bar\"`, `x @ \"baz\"`, `x @\n-    ///   _`). Here we have the invariant that everything in the\n-    ///   otherwise list is of **lower priority** than the stuff in the\n-    ///   other lists.\n+    /// Here, the traditional \"decision tree\" method would generate 2\n+    /// separate code-paths for the 2 separate cases.\n     ///\n-    /// So we'll compile the test. For each outcome of the test, we\n-    /// recursively call `match_candidates` with the corresponding set\n-    /// of candidates. But note that this set is now inexhaustive: for\n-    /// example, in the case where the test returns false, there are\n-    /// NO candidates, even though there is stll a value to be\n-    /// matched. So we'll collect the return values from\n-    /// `match_candidates`, which are the blocks where control-flow\n-    /// goes if none of the candidates matched. At this point, we can\n-    /// continue with the \"otherwise\" list.\n+    /// In some cases, this duplication can create an exponential amount of\n+    /// code. This is most easily seen by noticing that this method terminates\n+    /// with precisely the reachable arms being reachable - but that problem\n+    /// is trivially NP-complete:\n+    ///\n+    /// ```rust\n+    ///     match (var0, var1, var2, var3, ..) {\n+    ///         (true, _, _, false, true, ...) => false,\n+    ///         (_, true, true, false, _, ...) => false,\n+    ///         (false, _, false, false, _, ...) => false,\n+    ///         ...\n+    ///         _ => true\n+    ///     }\n+    /// ```\n+    ///\n+    /// Here the last arm is reachable only if there is an assignment to\n+    /// the variables that does not match any of the literals. Therefore,\n+    /// compilation would take an exponential amount of time in some cases.\n+    ///\n+    /// That kind of exponential worst-case might not occur in practice, but\n+    /// our simplistic treatment of constants and guards would make it occur\n+    /// in very common situations - for example #29740:\n+    ///\n+    /// ```rust\n+    /// match x {\n+    ///     \"foo\" if foo_guard => ...,\n+    ///     \"bar\" if bar_guard => ...,\n+    ///     \"baz\" if baz_guard => ...,\n+    ///     ...\n+    /// }\n+    /// ```\n+    ///\n+    /// Here we first test the match-pair `x @ \"foo\"`, which is an `Eq` test.\n+    /// It might seem that we would end up with 2 disjoint candidate sets,\n+    /// consisting of the first candidate or the other 3, but our algorithm\n+    /// doesn't reason about \"foo\" being distinct from the other constants,\n+    /// it considers to latter arms to potentially match after both outcomes,\n+    /// which obviously leads to an exponential amount of tests.\n+    /// To avoid these kinds of problems, our algorithm tries to ensure\n+    /// the amount of generated tests is linear. When we do a k-way test,\n+    /// we return an additional \"unmatched\" set alongside the obvious `k`\n+    /// sets. When we encounter a candidate that would be present in more\n+    /// than one of the sets, we put it and all candidates below it into the\n+    /// \"unmatched\" set. This ensures these `k+1` sets are disjoint.\n+    ///\n+    /// After we perform our test, we branch into the appropriate candidate\n+    /// set and recurse with `match_candidates`. These sub-matches are\n+    /// obviously inexhaustive - as we discarded our otherwise set - so\n+    /// we set their continuation to do `match_candidates` on the\n+    /// \"unmatched\" set (which is again inexhaustive).\n     ///\n     /// If you apply this to the above test, you basically wind up\n     /// with an if-else-if chain, testing each candidate in turn,\n     /// which is precisely what we want.\n+    ///\n+    /// In addition to avoiding exponential-time blowups, this algorithm\n+    /// also has nice property that each guard and arm is only generated\n+    /// once.\n     fn test_candidates<'pat>(&mut self,\n                              span: Span,\n                              arm_blocks: &mut ArmBlocks,"}, {"sha": "8392248e3f22e2088ffe6e99e4e38cb4f47bbcbd", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -31,18 +31,16 @@ use std::mem;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn simplify_candidate<'pat>(&mut self,\n-                                    mut block: BasicBlock,\n+                                    block: BasicBlock,\n                                     candidate: &mut Candidate<'pat, 'tcx>)\n                                     -> BlockAnd<()> {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n             let mut progress = match_pairs.len(); // count how many were simplified\n             for match_pair in match_pairs {\n-                match self.simplify_match_pair(block, match_pair, candidate) {\n-                    Ok(b) => {\n-                        block = b;\n-                    }\n+                match self.simplify_match_pair(match_pair, candidate) {\n+                    Ok(()) => {}\n                     Err(match_pair) => {\n                         candidate.match_pairs.push(match_pair);\n                         progress -= 1; // this one was not simplified\n@@ -61,14 +59,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// possible, Err is returned and no changes are made to\n     /// candidate.\n     fn simplify_match_pair<'pat>(&mut self,\n-                                 mut block: BasicBlock,\n                                  match_pair: MatchPair<'pat, 'tcx>,\n                                  candidate: &mut Candidate<'pat, 'tcx>)\n-                                 -> Result<BasicBlock, MatchPair<'pat, 'tcx>> {\n+                                 -> Result<(), MatchPair<'pat, 'tcx>> {\n         match *match_pair.pattern.kind {\n             PatternKind::Wild => {\n                 // nothing left to do\n-                Ok(block)\n+                Ok(())\n             }\n \n             PatternKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n@@ -87,7 +84,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     candidate.match_pairs.push(MatchPair::new(match_pair.lvalue, subpattern));\n                 }\n \n-                Ok(block)\n+                Ok(())\n             }\n \n             PatternKind::Constant { .. } => {\n@@ -96,37 +93,31 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             PatternKind::Range { .. } |\n-            PatternKind::Variant { .. } => {\n-                // cannot simplify, test is required\n-                Err(match_pair)\n-            }\n-\n-            PatternKind::Slice { .. } if !match_pair.slice_len_checked => {\n+            PatternKind::Variant { .. } |\n+            PatternKind::Slice { .. } => {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-                unpack!(block = self.prefix_suffix_slice(&mut candidate.match_pairs,\n-                                                         block,\n-                                                         match_pair.lvalue.clone(),\n-                                                         prefix,\n-                                                         slice.as_ref(),\n-                                                         suffix));\n-                Ok(block)\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n+                self.prefix_slice_suffix(&mut candidate.match_pairs,\n+                                         &match_pair.lvalue,\n+                                         prefix,\n+                                         slice.as_ref(),\n+                                         suffix);\n+                Ok(())\n             }\n \n             PatternKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs\n                          .extend(self.field_match_pairs(match_pair.lvalue, subpatterns));\n-                Ok(block)\n+                Ok(())\n             }\n \n             PatternKind::Deref { ref subpattern } => {\n                 let lvalue = match_pair.lvalue.deref();\n                 candidate.match_pairs.push(MatchPair::new(lvalue, subpattern));\n-                Ok(block)\n+                Ok(())\n             }\n         }\n     }"}, {"sha": "668bdcf735802499d84f5978476a43777b69e7b1", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 112, "deletions": 43, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n+use std::cmp::Ordering;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n@@ -446,69 +447,118 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        match test.kind {\n+        match (&test.kind, &*match_pair.pattern.kind) {\n             // If we are performing a variant switch, then this\n             // informs variant patterns, but nothing else.\n-            TestKind::Switch { adt_def: tested_adt_def , .. } => {\n-                match *match_pair.pattern.kind {\n-                    PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n-                        assert_eq!(adt_def, tested_adt_def);\n-                        let new_candidate =\n-                            self.candidate_after_variant_switch(match_pair_index,\n-                                                                adt_def,\n-                                                                variant_index,\n-                                                                subpatterns,\n-                                                                candidate);\n-                        resulting_candidates[variant_index].push(new_candidate);\n-                        true\n-                    }\n-                    _ => {\n-                        false\n-                    }\n-                }\n+            (&TestKind::Switch { adt_def: tested_adt_def, .. },\n+             &PatternKind::Variant { adt_def, variant_index, ref subpatterns }) => {\n+                assert_eq!(adt_def, tested_adt_def);\n+                let new_candidate =\n+                    self.candidate_after_variant_switch(match_pair_index,\n+                                                        adt_def,\n+                                                        variant_index,\n+                                                        subpatterns,\n+                                                        candidate);\n+                resulting_candidates[variant_index].push(new_candidate);\n+                true\n             }\n+            (&TestKind::Switch { .. }, _) => false,\n \n             // If we are performing a switch over integers, then this informs integer\n             // equality, but nothing else.\n             //\n-            // FIXME(#29623) we could use TestKind::Range to rule\n+            // FIXME(#29623) we could use PatternKind::Range to rule\n             // things out here, in some cases.\n-            TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n-                match *match_pair.pattern.kind {\n-                    PatternKind::Constant { ref value }\n-                    if is_switch_ty(match_pair.pattern.ty) => {\n-                        let index = indices[value];\n-                        let new_candidate = self.candidate_without_match_pair(match_pair_index,\n-                                                                              candidate);\n-                        resulting_candidates[index].push(new_candidate);\n+            (&TestKind::SwitchInt { switch_ty: _, options: _, ref indices },\n+             &PatternKind::Constant { ref value })\n+            if is_switch_ty(match_pair.pattern.ty) => {\n+                let index = indices[value];\n+                let new_candidate = self.candidate_without_match_pair(match_pair_index,\n+                                                                      candidate);\n+                resulting_candidates[index].push(new_candidate);\n+                true\n+            }\n+            (&TestKind::SwitchInt { .. }, _) => false,\n+\n+\n+            (&TestKind::Len { len: test_len, op: BinOp::Eq },\n+             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+                let pat_len = (prefix.len() + suffix.len()) as u64;\n+                match (test_len.cmp(&pat_len), slice) {\n+                    (Ordering::Equal, &None) => {\n+                        // on true, min_len = len = $actual_length,\n+                        // on false, len != $actual_length\n+                        resulting_candidates[0].push(\n+                            self.candidate_after_slice_test(match_pair_index,\n+                                                            candidate,\n+                                                            prefix,\n+                                                            slice.as_ref(),\n+                                                            suffix)\n+                        );\n                         true\n                     }\n-                    _ => {\n+                    (Ordering::Less, _) => {\n+                        // test_len < pat_len. If $actual_len = test_len,\n+                        // then $actual_len < pat_len and we don't have\n+                        // enough elements.\n+                        resulting_candidates[1].push(candidate.clone());\n+                        true\n+                    }\n+                    (Ordering::Equal, &Some(_)) | (Ordering::Greater, &Some(_)) => {\n+                        // This can match both if $actual_len = test_len >= pat_len,\n+                        // and if $actual_len > test_len. We can't advance.\n                         false\n                     }\n+                    (Ordering::Greater, &None) => {\n+                        // test_len != pat_len, so if $actual_len = test_len, then\n+                        // $actual_len != pat_len.\n+                        resulting_candidates[1].push(candidate.clone());\n+                        true\n+                    }\n                 }\n             }\n \n-            // If we are performing a length check, then this\n-            // informs slice patterns, but nothing else.\n-            TestKind::Len { .. } => {\n-                let pattern_test = self.test(&match_pair);\n-                match *match_pair.pattern.kind {\n-                    PatternKind::Slice { .. } if pattern_test.kind == test.kind => {\n-                        let mut new_candidate = candidate.clone();\n-\n-                        // Set up the MatchKind to simplify this like an array.\n-                        new_candidate.match_pairs[match_pair_index]\n-                                     .slice_len_checked = true;\n-                        resulting_candidates[0].push(new_candidate);\n+            (&TestKind::Len { len: test_len, op: BinOp::Ge },\n+             &PatternKind::Slice { ref prefix, ref slice, ref suffix }) => {\n+                // the test is `$actual_len >= test_len`\n+                let pat_len = (prefix.len() + suffix.len()) as u64;\n+                match (test_len.cmp(&pat_len), slice) {\n+                    (Ordering::Equal, &Some(_))  => {\n+                        // $actual_len >= test_len = pat_len,\n+                        // so we can match.\n+                        resulting_candidates[0].push(\n+                            self.candidate_after_slice_test(match_pair_index,\n+                                                            candidate,\n+                                                            prefix,\n+                                                            slice.as_ref(),\n+                                                            suffix)\n+                        );\n                         true\n                     }\n-                    _ => false\n+                    (Ordering::Less, _) | (Ordering::Equal, &None) => {\n+                        // test_len <= pat_len. If $actual_len < test_len,\n+                        // then it is also < pat_len, so the test passing is\n+                        // necessary (but insufficient).\n+                        resulting_candidates[0].push(candidate.clone());\n+                        true\n+                    }\n+                    (Ordering::Greater, &None) => {\n+                        // test_len > pat_len. If $actual_len >= test_len > pat_len,\n+                        // then we know we won't have a match.\n+                        resulting_candidates[1].push(candidate.clone());\n+                        true\n+                    }\n+                    (Ordering::Greater, &Some(_)) => {\n+                        // test_len < pat_len, and is therefore less\n+                        // strict. This can still go both ways.\n+                        false\n+                    }\n                 }\n             }\n \n-            TestKind::Eq { .. } |\n-            TestKind::Range { .. } => {\n+            (&TestKind::Eq { .. }, _) |\n+            (&TestKind::Range { .. }, _) |\n+            (&TestKind::Len { .. }, _) => {\n                 // These are all binary tests.\n                 //\n                 // FIXME(#29623) we can be more clever here\n@@ -544,6 +594,25 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn candidate_after_slice_test<'pat>(&mut self,\n+                                        match_pair_index: usize,\n+                                        candidate: &Candidate<'pat, 'tcx>,\n+                                        prefix: &'pat [Pattern<'tcx>],\n+                                        opt_slice: Option<&'pat Pattern<'tcx>>,\n+                                        suffix: &'pat [Pattern<'tcx>])\n+                                        -> Candidate<'pat, 'tcx> {\n+        let mut new_candidate =\n+            self.candidate_without_match_pair(match_pair_index, candidate);\n+        self.prefix_slice_suffix(\n+            &mut new_candidate.match_pairs,\n+            &candidate.match_pairs[match_pair_index].lvalue,\n+            prefix,\n+            opt_slice,\n+            suffix);\n+\n+        new_candidate\n+    }\n+\n     fn candidate_after_variant_switch<'pat>(&mut self,\n                                             match_pair_index: usize,\n                                             adt_def: ty::AdtDef<'tcx>,"}, {"sha": "53ebf6fceb5c807e2f8ea006dad651db8f42dd46", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 16, "deletions": 57, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::Builder;\n use build::matches::MatchPair;\n use hair::*;\n use rustc::mir::repr::*;\n@@ -28,64 +28,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                    .collect()\n     }\n \n-    /// When processing an array/slice pattern like `lv @ [x, y, ..s, z]`,\n-    /// this function converts the prefix (`x`, `y`) and suffix (`z`) into\n-    /// distinct match pairs:\n-    ///\n-    /// ```rust,ignore\n-    ///     lv[0 of 3] @ x  // see ProjectionElem::ConstantIndex (and its Debug impl)\n-    ///     lv[1 of 3] @ y  // to explain the `[x of y]` notation\n-    ///     lv[-1 of 3] @ z\n-    /// ```\n-    ///\n-    /// If a slice like `s` is present, then the function also creates\n-    /// a temporary like:\n-    ///\n-    /// ```rust,ignore\n-    ///     tmp0 = lv[2..-1] // using the special Rvalue::Slice\n-    /// ```\n-    ///\n-    /// and creates a match pair `tmp0 @ s`\n-    pub fn prefix_suffix_slice<'pat>(&mut self,\n+    pub fn prefix_slice_suffix<'pat>(&mut self,\n                                      match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n-                                     block: BasicBlock,\n-                                     lvalue: Lvalue<'tcx>,\n+                                     lvalue: &Lvalue<'tcx>,\n                                      prefix: &'pat [Pattern<'tcx>],\n                                      opt_slice: Option<&'pat Pattern<'tcx>>,\n-                                     suffix: &'pat [Pattern<'tcx>])\n-                                     -> BlockAnd<()> {\n-        // If there is a `..P` pattern, create a temporary `t0` for\n-        // the slice and then a match pair `t0 @ P`:\n-        if let Some(slice) = opt_slice {\n-            let prefix_len = prefix.len();\n-            let suffix_len = suffix.len();\n-            let rvalue = Rvalue::Slice {\n-                input: lvalue.clone(),\n-                from_start: prefix_len,\n-                from_end: suffix_len,\n-            };\n-            let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n-            let source_info = self.source_info(slice.span);\n-            self.cfg.push_assign(block, source_info, &temp, rvalue);\n-            match_pairs.push(MatchPair::new(temp, slice));\n-        }\n-\n-        self.prefix_suffix(match_pairs, lvalue, prefix, suffix);\n-\n-        block.unit()\n-    }\n-\n-    /// Helper for `prefix_suffix_slice` which just processes the prefix and suffix.\n-    fn prefix_suffix<'pat>(&mut self,\n-                           match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n-                           lvalue: Lvalue<'tcx>,\n-                           prefix: &'pat [Pattern<'tcx>],\n-                           suffix: &'pat [Pattern<'tcx>]) {\n+                                     suffix: &'pat [Pattern<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         assert!(min_length < u32::MAX as usize);\n         let min_length = min_length as u32;\n \n-        let prefix_pairs: Vec<_> =\n+        match_pairs.extend(\n             prefix.iter()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n@@ -97,9 +50,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       let lvalue = lvalue.clone().elem(elem);\n                       MatchPair::new(lvalue, subpattern)\n                   })\n-                  .collect();\n+        );\n+\n+        if let Some(subslice_pat) = opt_slice {\n+            let subslice = lvalue.clone().elem(ProjectionElem::Subslice {\n+                from: prefix.len() as u32,\n+                to: suffix.len() as u32\n+            });\n+            match_pairs.push(MatchPair::new(subslice, subslice_pat));\n+        }\n \n-        let suffix_pairs: Vec<_> =\n+        match_pairs.extend(\n             suffix.iter()\n                   .rev()\n                   .enumerate()\n@@ -112,9 +73,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       let lvalue = lvalue.clone().elem(elem);\n                       MatchPair::new(lvalue, subpattern)\n                   })\n-                  .collect();\n-\n-        match_pairs.extend(prefix_pairs.into_iter().chain(suffix_pairs));\n+        );\n     }\n }\n "}, {"sha": "3fdf492611d467a2ade1e13dbcb8b27cb1d448b6", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -509,6 +509,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         }\n \n                         ProjectionElem::ConstantIndex {..} |\n+                        ProjectionElem::Subslice {..} |\n                         ProjectionElem::Downcast(..) => {\n                             this.not_const()\n                         }\n@@ -708,7 +709,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n \n-            Rvalue::Slice {..} |\n             Rvalue::InlineAsm {..} => {\n                 self.not_const();\n             }"}, {"sha": "c38f1f1e6c0fad98648c8fe70bb1b86d5f8da189", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -203,6 +203,26 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n+            ProjectionElem::Subslice { from, to } => {\n+                LvalueTy::Ty {\n+                    ty: match base_ty.sty {\n+                        ty::TyArray(inner, size) => {\n+                            let min_size = (from as usize) + (to as usize);\n+                            if let Some(rest_size) = size.checked_sub(min_size) {\n+                                tcx.mk_array(inner, rest_size)\n+                            } else {\n+                                span_mirbug_and_err!(\n+                                    self, lvalue, \"taking too-small slice of {:?}\", base_ty)\n+                            }\n+                        }\n+                        ty::TySlice(..) => base_ty,\n+                        _ => {\n+                            span_mirbug_and_err!(\n+                                self, lvalue, \"slice of non-array {:?}\", base_ty)\n+                        }\n+                    }\n+                }\n+            }\n             ProjectionElem::Downcast(adt_def1, index) =>\n                 match base_ty.sty {\n                     ty::TyEnum(adt_def, substs) if adt_def == adt_def1 => {"}, {"sha": "841dcf0301c3fe84bb452fda47159290c67fd861", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -20,13 +20,14 @@ use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n use type_of::type_of;\n+use type_of;\n use Disr;\n \n use std::ptr;\n \n use super::{MirContext, TempRef};\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct LvalueRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n     pub llval: ValueRef,\n@@ -88,7 +89,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let fcx = bcx.fcx();\n         let ccx = bcx.ccx();\n         let tcx = bcx.tcx();\n-        match *lvalue {\n+        let result = match *lvalue {\n             mir::Lvalue::Var(index) => self.vars[index as usize],\n             mir::Lvalue::Temp(index) => match self.temps[index as usize] {\n                 TempRef::Lvalue(lvalue) =>\n@@ -131,7 +132,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let zero = common::C_uint(bcx.ccx(), 0u64);\n                         bcx.inbounds_gep(tr_base.llval, &[zero, llindex])\n                     };\n-                    (element, ptr::null_mut())\n+                    element\n                 };\n \n                 let (llprojected, llextra) = match projection.elem {\n@@ -169,21 +170,44 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n-                        project_index(self.prepare_index(bcx, index.immediate()))\n+                        (project_index(self.prepare_index(bcx, index.immediate())), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx(), offset);\n-                        project_index(self.prepare_index(bcx, lloffset))\n+                        (project_index(lloffset), ptr::null_mut())\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx(), offset);\n                         let lllen = tr_base.len(bcx.ccx());\n                         let llindex = bcx.sub(lllen, lloffset);\n-                        project_index(self.prepare_index(bcx, llindex))\n+                        (project_index(llindex), ptr::null_mut())\n+                    }\n+                    mir::ProjectionElem::Subslice { from, to } => {\n+                        let llindex = C_uint(bcx.ccx(), from);\n+                        let llbase = project_index(llindex);\n+\n+                        let base_ty = tr_base.ty.to_ty(bcx.tcx());\n+                        match base_ty.sty {\n+                            ty::TyArray(..) => {\n+                                // must cast the lvalue pointer type to the new\n+                                // array type (*[%_; new_len]).\n+                                let base_ty = self.mir.lvalue_ty(tcx, lvalue).to_ty(tcx);\n+                                let llbasety = type_of::type_of(bcx.ccx(), base_ty).ptr_to();\n+                                let llbase = bcx.pointercast(llbase, llbasety);\n+                                (bcx.pointercast(llbase, llbasety), ptr::null_mut())\n+                            }\n+                            ty::TySlice(..) => {\n+                                assert!(tr_base.llextra != ptr::null_mut());\n+                                let lllen = bcx.sub(tr_base.llextra,\n+                                                    C_uint(bcx.ccx(), from+to));\n+                                (llbase, lllen)\n+                            }\n+                            _ => bug!(\"unexpected type {:?} in Subslice\", base_ty)\n+                        }\n                     }\n                     mir::ProjectionElem::Downcast(..) => {\n                         (tr_base.llval, tr_base.llextra)\n@@ -195,7 +219,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     ty: projected_ty,\n                 }\n             }\n-        }\n+        };\n+        debug!(\"trans_lvalue(lvalue={:?}) => {:?}\", lvalue, result);\n+        result\n     }\n \n     // Perform an action using the given Lvalue."}, {"sha": "09b07c1440ec579b1ca3099d7d4790d8beaf1233", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -29,7 +29,7 @@ use Disr;\n use super::MirContext;\n use super::constant::const_scalar_checked_binop;\n use super::operand::{OperandRef, OperandValue};\n-use super::lvalue::{LvalueRef, get_dataptr, get_meta};\n+use super::lvalue::{LvalueRef, get_dataptr};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n@@ -170,26 +170,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::Slice { ref input, from_start, from_end } => {\n-                let ccx = bcx.ccx();\n-                let input = self.trans_lvalue(&bcx, input);\n-                let ty = input.ty.to_ty(bcx.tcx());\n-                let (llbase1, lllen) = match ty.sty {\n-                    ty::TyArray(_, n) => {\n-                        (bcx.gepi(input.llval, &[0, from_start]), C_uint(ccx, n))\n-                    }\n-                    ty::TySlice(_) | ty::TyStr => {\n-                        (bcx.gepi(input.llval, &[from_start]), input.llextra)\n-                    }\n-                    _ => bug!(\"cannot slice {}\", ty)\n-                };\n-                let adj = C_uint(ccx, from_start + from_end);\n-                let lllen1 = bcx.sub(lllen, adj);\n-                bcx.store(llbase1, get_dataptr(&bcx, dest.llval));\n-                bcx.store(lllen1, get_meta(&bcx, dest.llval));\n-                bcx\n-            }\n-\n             mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n                     let lvalue = self.trans_lvalue(&bcx, output);\n@@ -498,7 +478,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) |\n-            mir::Rvalue::Slice { .. } |\n             mir::Rvalue::InlineAsm { .. } => {\n                 bug!(\"cannot generate operand from rvalue {:?}\", rvalue);\n \n@@ -652,7 +631,6 @@ pub fn rvalue_creates_operand<'bcx, 'tcx>(_mir: &mir::Mir<'tcx>,\n             true,\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n-        mir::Rvalue::Slice { .. } |\n         mir::Rvalue::InlineAsm { .. } =>\n             false,\n     }"}, {"sha": "2fbeb43b8a3a517df2770d60edf5757ab2fecf17", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -19,8 +19,8 @@ use lint;\n use util::nodemap::FnvHashMap;\n use session::Session;\n \n-use std::cmp;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::cmp;\n use std::ops::Deref;\n use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n@@ -323,44 +323,42 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n             PatKind::Vec(ref before, ref slice, ref after) => {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                let inner_ty = self.next_ty_var();\n-                let pat_ty = match expected_ty.sty {\n-                    ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n+                let (inner_ty, slice_ty) = match expected_ty.sty {\n+                    ty::TyArray(inner_ty, size) => {\n                         let min_len = before.len() + after.len();\n-                        match *slice {\n-                            Some(_) => cmp::max(min_len, size),\n-                            None => min_len\n+                        if slice.is_none() {\n+                            if min_len != size {\n+                                span_err!(tcx.sess, pat.span, E0527,\n+                                          \"pattern requires {} elements but array has {}\",\n+                                          min_len, size);\n+                            }\n+                            (inner_ty, tcx.types.err)\n+                        } else if let Some(rest) = size.checked_sub(min_len) {\n+                            (inner_ty, tcx.mk_array(inner_ty, rest))\n+                        } else {\n+                            span_err!(tcx.sess, pat.span, E0528,\n+                                      \"pattern requires at least {} elements but array has {}\",\n+                                      min_len, size);\n+                            (inner_ty, tcx.types.err)\n                         }\n-                    }),\n+                    }\n+                    ty::TySlice(inner_ty) => (inner_ty, expected_ty),\n                     _ => {\n-                        let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                        tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n-                            ty: tcx.mk_slice(inner_ty),\n-                            mutbl: expected_ty.builtin_deref(true, ty::NoPreference)\n-                                              .map_or(hir::MutImmutable, |mt| mt.mutbl)\n-                        })\n+                        if !expected_ty.references_error() {\n+                            span_err!(tcx.sess, pat.span, E0529,\n+                                      \"expected an array or slice, found `{}`\",\n+                                      expected_ty);\n+                        }\n+                        (tcx.types.err, tcx.types.err)\n                     }\n                 };\n \n-                self.write_ty(pat.id, pat_ty);\n-\n-                // `demand::subtype` would be good enough, but using\n-                // `eqtype` turns out to be equally general. See (*)\n-                // below for details.\n-                self.demand_eqtype(pat.span, expected, pat_ty);\n+                self.write_ty(pat.id, expected_ty);\n \n                 for elt in before {\n                     self.check_pat(&elt, inner_ty);\n                 }\n                 if let Some(ref slice) = *slice {\n-                    let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                    let mutbl = expected_ty.builtin_deref(true, ty::NoPreference)\n-                        .map_or(hir::MutImmutable, |mt| mt.mutbl);\n-\n-                    let slice_ty = tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n-                        ty: tcx.mk_slice(inner_ty),\n-                        mutbl: mutbl\n-                    });\n                     self.check_pat(&slice, slice_ty);\n                 }\n                 for elt in after {\n@@ -369,7 +367,6 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-\n         // (*) In most of the cases above (literals and constants being\n         // the exception), we relate types using strict equality, evewn\n         // though subtyping would be sufficient. There are a few reasons"}, {"sha": "a8cb21126c079c0ec6d45bfce2b7b36d9ec39639", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -1157,25 +1157,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n                discr_cmt,\n                root_pat);\n-        let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n+    let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(hir::BindByRef(mutbl), _, _) => {\n                         self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n                                                         mutbl, sub_cmt);\n                     }\n-\n-                    // `[_, ..slice, _]` pattern\n-                    PatKind::Vec(_, Some(ref slice_pat), _) => {\n-                        match mc.cat_slice_pattern(sub_cmt, &slice_pat) {\n-                            Ok((slice_cmt, slice_mutbl, slice_r)) => {\n-                                self.link_region(sub_pat.span, &slice_r,\n-                                                 ty::BorrowKind::from_mutbl(slice_mutbl),\n-                                                 slice_cmt);\n-                            }\n-                            Err(()) => {}\n-                        }\n-                    }\n                     _ => {}\n                 }\n             });"}, {"sha": "86717da24c54f03493a34cb4bf4417e15ab67222", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -4139,5 +4139,8 @@ register_diagnostics! {\n            // type `{}` was overridden\n     E0436, // functional record update requires a struct\n     E0513, // no type for local variable ..\n-    E0521  // redundant default implementations of trait\n+    E0521, // redundant default implementations of trait\n+    E0527, // expected {} elements, found {}\n+    E0528, // expected at least {} elements, found {}\n+    E0529, // slice pattern expects array or slice, not `{}`\n }"}, {"sha": "5519230890cb6f84c95b0cb3353fce8cc3a1de33", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -560,15 +560,20 @@ impl Wtf8 {\n         }\n     }\n \n+    // FIXME(stage0): use slice patterns after snapshot\n     #[inline]\n     fn final_lead_surrogate(&self) -> Option<u16> {\n         let len = self.len();\n         if len < 3 {\n             return None\n         }\n-        match &self.bytes[(len - 3)..] {\n-            [0xED, b2 @ 0xA0...0xAF, b3] => Some(decode_surrogate(b2, b3)),\n-            _ => None\n+        if self.bytes[len-3] == 0xed &&\n+            self.bytes[len-2] > 0xa0 &&\n+            self.bytes[len-2] <= 0xaf\n+        {\n+            Some(decode_surrogate(self.bytes[len-2], self.bytes[len-1]))\n+        } else {\n+            None\n         }\n     }\n \n@@ -578,9 +583,13 @@ impl Wtf8 {\n         if len < 3 {\n             return None\n         }\n-        match &self.bytes[..3] {\n-            [0xED, b2 @ 0xB0...0xBF, b3] => Some(decode_surrogate(b2, b3)),\n-            _ => None\n+        if self.bytes[len-3] == 0xed &&\n+            self.bytes[len-2] > 0xb0 &&\n+            self.bytes[len-2] <= 0xbf\n+        {\n+            Some(decode_surrogate(self.bytes[len-2], self.bytes[len-1]))\n+        } else {\n+            None\n         }\n     }\n }"}, {"sha": "f595d9d81cc6ef6bcb64eb67ce9055834880443d", "filename": "src/test/compile-fail/borrowck/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -24,14 +24,14 @@ pub fn main() {\n         Foo { string: \"baz\".to_string() }\n     );\n     let x: &[Foo] = &x;\n-    match x {\n-        [_, tail..] => {\n+    match *x {\n+        [_, ref tail..] => {\n             match tail {\n-                [Foo { string: a },\n+                &[Foo { string: a },\n                 //~^ ERROR cannot move out of borrowed content\n                 //~| cannot move out\n                 //~| to prevent move\n-                 Foo { string: b }] => {\n+                  Foo { string: b }] => {\n                     //~^ NOTE and here\n                 }\n                 _ => {"}, {"sha": "63e80b90ac81e6f211d885b77285f64ed6c142d6", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -15,7 +15,7 @@ fn a<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let tail = match vec {\n-        [_, tail..] => tail,\n+        &[_, ref tail..] => tail,\n         _ => panic!(\"a\")\n     };\n     tail\n@@ -25,7 +25,7 @@ fn b<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let init = match vec {\n-        [init.., _] => init,\n+        &[ref init.., _] => init,\n         _ => panic!(\"b\")\n     };\n     init\n@@ -35,7 +35,7 @@ fn c<'a>() -> &'a [isize] {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR does not live long enough\n     let slice = match vec {\n-        [_, slice.., _] => slice,\n+        &[_, ref slice.., _] => slice,\n         _ => panic!(\"c\")\n     };\n     slice"}, {"sha": "9dfd4d779284329ff53909c372604d51869c7a10", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -14,7 +14,7 @@ fn a() {\n     let mut v = vec!(1, 2, 3);\n     let vb: &mut [isize] = &mut v;\n     match vb {\n-        [_a, tail..] => {\n+        &mut [_a, ref tail..] => {\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}"}, {"sha": "fddb9838c44b5e945561561ea298d22fc339a6e4", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let mut a = [1, 2, 3, 4];\n     let t = match a {\n-        [1, 2, tail..] => tail,\n+        [1, 2, ref tail..] => tail,\n         _ => unreachable!()\n     };\n     println!(\"t[0]: {}\", t[0]);"}, {"sha": "d89b4100789f95d7132e969bef3e7e627fdbc8c0", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -28,7 +28,7 @@ fn b() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_b..] => {\n+        &mut [ref _b..] => {\n         //~^ borrow of `vec[..]` occurs here\n             vec[0] = box 4; //~ ERROR cannot assign\n             //~^ assignment to borrowed `vec[..]` occurs here\n@@ -40,10 +40,11 @@ fn c() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_a,         //~ ERROR cannot move out\n-        //~| cannot move out\n-        //~| to prevent move\n-         _b..] => {\n+        &mut [_a, //~ ERROR cannot move out of borrowed content\n+            //~| cannot move out\n+            //~| to prevent move\n+            ..\n+        ] => {\n             // Note: `_a` is *moved* here, but `b` is borrowing,\n             // hence illegal.\n             //\n@@ -61,7 +62,7 @@ fn d() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_a..,     //~ ERROR cannot move out\n+        &mut [ //~ ERROR cannot move out\n         //~^ cannot move out\n          _b] => {} //~ NOTE to prevent move\n         _ => {}\n@@ -75,7 +76,7 @@ fn e() {\n     let mut vec = vec!(box 1, box 2, box 3);\n     let vec: &mut [Box<isize>] = &mut vec;\n     match vec {\n-        [_a, _b, _c] => {}  //~ ERROR cannot move out\n+        &mut [_a, _b, _c] => {}  //~ ERROR cannot move out\n         //~| cannot move out\n         //~| NOTE to prevent move\n         //~| NOTE and here"}, {"sha": "a849e4e2faf3b51ff5d6cc97d90121ca1fadae82", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -14,7 +14,7 @@ fn a<'a>() -> &'a isize {\n     let vec = vec!(1, 2, 3, 4);\n     let vec: &[isize] = &vec; //~ ERROR `vec` does not live long enough\n     let tail = match vec {\n-        [_a, tail..] => &tail[0],\n+        &[_a, ref tail..] => &tail[0],\n         _ => panic!(\"foo\")\n     };\n     tail"}, {"sha": "978d6f59b2df455b41b91ecc45d7244c2f7f6e88", "filename": "src/test/compile-fail/issue-12369.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12369.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -13,9 +13,9 @@\n fn main() {\n     let sl = vec![1,2,3];\n     let v: isize = match &*sl {\n-        [] => 0,\n-        [a,b,c] => 3,\n-        [a, rest..] => a,\n-        [10,a, rest..] => 10 //~ ERROR: unreachable pattern\n+        &[] => 0,\n+        &[a,b,c] => 3,\n+        &[a, ref rest..] => a,\n+        &[10,a, ref rest..] => 10 //~ ERROR: unreachable pattern\n     };\n }"}, {"sha": "32a6ea4f062cbc9819392615e13cd579a288d13e", "filename": "src/test/compile-fail/issue-12567.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -12,13 +12,15 @@\n \n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) {\n     match (l1, l2) {\n-        ([], []) => println!(\"both empty\"),\n-        ([], [hd, tl..]) | ([hd, tl..], []) => println!(\"one empty\"),\n-        //~^ ERROR: cannot move out of borrowed content\n+        (&[], &[]) => println!(\"both empty\"),\n+        (&[], &[hd, ..]) | (&[hd, ..], &[])\n+            => println!(\"one empty\"),\n         //~^^ ERROR: cannot move out of borrowed content\n-        ([hd1, tl1..], [hd2, tl2..]) => println!(\"both nonempty\"),\n-        //~^ ERROR: cannot move out of borrowed content\n+        //~^^^ ERROR: cannot move out of borrowed content\n+        (&[hd1, ..], &[hd2, ..])\n+            => println!(\"both nonempty\"),\n         //~^^ ERROR: cannot move out of borrowed content\n+        //~^^^ ERROR: cannot move out of borrowed content\n     }\n }\n "}, {"sha": "6885c8d94c6b4fd16535103a91fa52bca135d372", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -15,11 +15,7 @@\n fn main() {\n     let x = [1,2];\n     let y = match x {\n-        [] => None,\n-//~^ ERROR mismatched types\n-//~| expected type `[_#1i; 2]`\n-//~| found type `[_#7t; 0]`\n-//~| expected an array with a fixed size of 2 elements, found one with 0 elements\n+        [] => None, //~ ERROR pattern requires 0 elements but array has 2\n         [a,_] => Some(a)\n     };\n }"}, {"sha": "82e82df31861ff35ab4a4fe913be379ebab96bda", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -13,11 +13,7 @@\n fn main() {\n   let x = [1,2];\n   let y = match x {\n-    [] => None,\n-    //~^ ERROR mismatched types\n-    //~| expected type `[_; 2]`\n-    //~| found type `[_; 0]`\n-    //~| expected an array with a fixed size of 2 elements\n+    [] => None, //~ ERROR pattern requires 0 elements but array has 2\n     [a,_] => Some(a)\n   };\n }"}, {"sha": "d0964d2aabea755357b9af916f00c127a642808d", "filename": "src/test/compile-fail/issue-15381.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15381.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -13,8 +13,8 @@\n fn main() {\n     let values: Vec<u8> = vec![1,2,3,4,5,6,7,8];\n \n-    for [x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n-        //~^ ERROR refutable pattern in `for` loop binding: `[]` not covered\n+    for &[x,y,z] in values.chunks(3).filter(|&xs| xs.len() == 3) {\n+        //~^ ERROR refutable pattern in `for` loop binding: `&[]` not covered\n         println!(\"y={}\", y);\n     }\n }"}, {"sha": "375d855d1fd31e6edae51647b965f13dec2e370f", "filename": "src/test/compile-fail/match-vec-mismatch-2.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch-2.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -13,9 +13,6 @@\n fn main() {\n     match () {\n         [()] => { }\n-        //~^ ERROR mismatched types\n-        //~| expected type `()`\n-        //~| found type `&[_]`\n-        //~| expected (), found &-ptr\n+        //~^ ERROR expected an array or slice, found `()`\n     }\n }"}, {"sha": "3ac4958e7db0f6425b5a5d170574d967e1849bdf", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -12,7 +12,36 @@\n \n fn main() {\n     match \"foo\".to_string() {\n-        ['f', 'o', ..] => {} //~ ERROR mismatched types\n+        ['f', 'o', ..] => {}\n+        //~^ ERROR expected an array or slice, found `std::string::String`\n         _ => { }\n-    }\n+    };\n+\n+    match &[0, 1, 2] {\n+        [..] => {} //~ ERROR expected an array or slice, found `&[_; 3]`\n+    };\n+\n+    match &[0, 1, 2] {\n+        &[..] => {} // ok\n+    };\n+\n+    match [0, 1, 2] {\n+        [0] => {}, //~ ERROR pattern requires\n+\n+        [0, 1, x..] => {\n+            let a: [_; 1] = x;\n+        }\n+        [0, 1, 2, 3, x..] => {} //~ ERROR pattern requires\n+    };\n+\n+    match does_not_exist { //~ ERROR unresolved name\n+        [] => {}\n+    };\n+}\n+\n+fn another_fn_to_avoid_suppression() {\n+    match Default::default()\n+    {\n+        [] => {}  //~ ERROR the type of this value\n+    };\n }"}, {"sha": "57e3a58b5660e27267d66d9af9f9643d6dd2542b", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let x: Vec<(isize, isize)> = Vec::new();\n     let x: &[(isize, isize)] = &x;\n-    match x {\n+    match *x {\n         [a, (2, 3), _] => (),\n         [(1, 2), (2, 3), b] => (), //~ ERROR unreachable pattern\n         _ => ()\n@@ -23,16 +23,16 @@ fn main() {\n                               \"bar\".to_string(),\n                               \"baz\".to_string()];\n     let x: &[String] = &x;\n-    match x {\n+    match *x {\n         [a, _, _, ..] => { println!(\"{}\", a); }\n         [_, _, _, _, _] => { } //~ ERROR unreachable pattern\n         _ => { }\n     }\n \n     let x: Vec<char> = vec!('a', 'b', 'c');\n     let x: &[char] = &x;\n-    match x {\n-        ['a', 'b', 'c', _tail..] => {}\n+    match *x {\n+        ['a', 'b', 'c', ref _tail..] => {}\n         ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern\n         _ => {}\n     }"}, {"sha": "1d524217a12a29519653256f9a8785e64d334dbf", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -14,11 +14,11 @@ enum t { a(u), b }\n enum u { c, d }\n \n fn match_nested_vecs<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n-    match (l1, l2) { //~ ERROR non-exhaustive patterns: `(Some([]), Err(_))` not covered\n-        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n-        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n-        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n-        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\"\n+    match (l1, l2) { //~ ERROR non-exhaustive patterns: `(Some(&[]), Err(_))` not covered\n+        (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\",\n+        (Some(&[_, ..]), Ok(_)) | (Some(&[_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok(&[])) | (None, Err(())) | (None, Ok(&[_])) => \"None, Ok(less than one element)\",\n+        (None, Ok(&[_, _, ..])) => \"None, Ok(at least two elements)\"\n     }\n }\n "}, {"sha": "017baacc9d329b771f7e40f295acbbfafeb03a24", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -39,32 +39,32 @@ fn main() {\n     }\n     let vec = vec!(Some(42), None, Some(21));\n     let vec: &[Option<isize>] = &vec;\n-    match vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n-        [Some(..), None, tail..] => {}\n-        [Some(..), Some(..), tail..] => {}\n+    match *vec { //~ ERROR non-exhaustive patterns: `[]` not covered\n+        [Some(..), None, ref tail..] => {}\n+        [Some(..), Some(..), ref tail..] => {}\n         [None] => {}\n     }\n     let vec = vec!(1);\n     let vec: &[isize] = &vec;\n-    match vec {\n-        [_, tail..] => (),\n+    match *vec {\n+        [_, ref tail..] => (),\n         [] => ()\n     }\n     let vec = vec!(0.5f32);\n     let vec: &[f32] = &vec;\n-    match vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n+    match *vec { //~ ERROR non-exhaustive patterns: `[_, _, _, _]` not covered\n         [0.1, 0.2, 0.3] => (),\n         [0.1, 0.2] => (),\n         [0.1] => (),\n         [] => ()\n     }\n     let vec = vec!(Some(42), None, Some(21));\n     let vec: &[Option<isize>] = &vec;\n-    match vec {\n-        [Some(..), None, tail..] => {}\n-        [Some(..), Some(..), tail..] => {}\n-        [None, None, tail..] => {}\n-        [None, Some(..), tail..] => {}\n+    match *vec {\n+        [Some(..), None, ref tail..] => {}\n+        [Some(..), Some(..), ref tail..] => {}\n+        [None, None, ref tail..] => {}\n+        [None, Some(..), ref tail..] => {}\n         [Some(_)] => {}\n         [None] => {}\n         [] => {}"}, {"sha": "0b12a9acbcb9e9d56de662b81d4234bda7fc35a7", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -80,15 +80,15 @@ enum Enum {\n \n fn vectors_with_nested_enums() {\n     let x: &'static [Enum] = &[Enum::First, Enum::Second(false)];\n-    match x {\n+    match *x {\n     //~^ ERROR non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n         [] => (),\n         [_] => (),\n         [Enum::First, _] => (),\n         [Enum::Second(true), Enum::First] => (),\n         [Enum::Second(true), Enum::Second(true)] => (),\n         [Enum::Second(false), _] => (),\n-        [_, _, tail.., _] => ()\n+        [_, _, ref tail.., _] => ()\n     }\n }\n "}, {"sha": "cee0caeb465f56d3206266d85cc4f6f769730fb3", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -16,12 +16,12 @@ fn main() {\n \n     let mut result = vec!();\n     loop {\n-        x = match x {\n-            [1, n, 3, rest..] => {\n+        x = match *x {\n+            [1, n, 3, ref rest..] => {\n                 result.push(n);\n                 rest\n             }\n-            [n, rest..] => {\n+            [n, ref rest..] => {\n                 result.push(n);\n                 rest\n             }"}, {"sha": "508360cb70110a96ac10973133548c07053a1afc", "filename": "src/test/run-pass/issue-15104.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-15104.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15104.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -16,9 +16,9 @@ fn main() {\n }\n \n fn count_members(v: &[usize]) -> usize {\n-    match v {\n+    match *v {\n         []         => 0,\n         [_]        => 1,\n-        [_x, xs..] => 1 + count_members(xs)\n+        [_, ref xs..] => 1 + count_members(xs)\n     }\n }"}, {"sha": "e596bee8bfe9fc7afc4936c33c7537873306aabb", "filename": "src/test/run-pass/issue-16648.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-16648.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16648.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n \n-#![feature(slice_patterns)]\n+#![feature(slice_patterns, rustc_attrs)]\n \n+#[rustc_mir]\n fn main() {\n     let x: (isize, &[isize]) = (2, &[1, 2]);\n     assert_eq!(match x {\n-        (0, [_, _]) => 0,\n+        (0, &[_, _]) => 0,\n         (1, _) => 1,\n-        (2, [_, _]) => 2,\n+        (2, &[_, _]) => 2,\n         (2, _) => 3,\n         _ => 4\n     }, 2);"}, {"sha": "0008825226ba0161fdcd88b4c92e457c42331ec6", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -11,6 +11,7 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n use std::ops::Add;\n \n@@ -21,6 +22,7 @@ fn bar(a: &'static str, b: &'static str) -> [&'static str; 4] {\n     [a, b, b, a]\n }\n \n+#[rustc_mir]\n fn main() {\n     assert_eq!(foo([1, 2, 3]), (1, 3, 6));\n "}, {"sha": "010c1455210084b521a898b125e183d8d1f2f1cb", "filename": "src/test/run-pass/match-vec-alternatives.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-vec-alternatives.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -11,47 +11,53 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n+#[rustc_mir]\n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n-        ([], []) => \"both empty\",\n-        ([], [..]) | ([..], []) => \"one empty\",\n-        ([..], [..]) => \"both non-empty\"\n+        (&[], &[]) => \"both empty\",\n+        (&[], &[..]) | (&[..], &[]) => \"one empty\",\n+        (&[..], &[..]) => \"both non-empty\"\n     }\n }\n \n+#[rustc_mir]\n fn match_vecs_cons<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n-        ([], []) => \"both empty\",\n-        ([], [_, ..]) | ([_, ..], []) => \"one empty\",\n-        ([_, ..], [_, ..]) => \"both non-empty\"\n+        (&[], &[]) => \"both empty\",\n+        (&[], &[_, ..]) | (&[_, ..], &[]) => \"one empty\",\n+        (&[_, ..], &[_, ..]) => \"both non-empty\"\n     }\n }\n \n+#[rustc_mir]\n fn match_vecs_snoc<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {\n-        ([], []) => \"both empty\",\n-        ([], [.., _]) | ([.., _], []) => \"one empty\",\n-        ([.., _], [.., _]) => \"both non-empty\"\n+        (&[], &[]) => \"both empty\",\n+        (&[], &[.., _]) | (&[.., _], &[]) => \"one empty\",\n+        (&[.., _], &[.., _]) => \"both non-empty\"\n     }\n }\n \n+#[rustc_mir]\n fn match_nested_vecs_cons<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n     match (l1, l2) {\n-        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n-        (Some([_, ..]), Ok(_)) | (Some([_, ..]), Err(())) => \"Some(non-empty), any\",\n-        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n-        (None, Ok([_, _, ..])) => \"None, Ok(at least two elements)\",\n+        (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\",\n+        (Some(&[_, ..]), Ok(_)) | (Some(&[_, ..]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok(&[])) | (None, Err(())) | (None, Ok(&[_])) => \"None, Ok(less than one element)\",\n+        (None, Ok(&[_, _, ..])) => \"None, Ok(at least two elements)\",\n         _ => \"other\"\n     }\n }\n \n+#[rustc_mir]\n fn match_nested_vecs_snoc<'a, T>(l1: Option<&'a [T]>, l2: Result<&'a [T], ()>) -> &'static str {\n     match (l1, l2) {\n-        (Some([]), Ok([])) => \"Some(empty), Ok(empty)\",\n-        (Some([.., _]), Ok(_)) | (Some([.., _]), Err(())) => \"Some(non-empty), any\",\n-        (None, Ok([])) | (None, Err(())) | (None, Ok([_])) => \"None, Ok(less than one element)\",\n-        (None, Ok([.., _, _])) => \"None, Ok(at least two elements)\",\n+        (Some(&[]), Ok(&[])) => \"Some(empty), Ok(empty)\",\n+        (Some(&[.., _]), Ok(_)) | (Some(&[.., _]), Err(())) => \"Some(non-empty), any\",\n+        (None, Ok(&[])) | (None, Err(())) | (None, Ok(&[_])) => \"None, Ok(less than one element)\",\n+        (None, Ok(&[.., _, _])) => \"None, Ok(at least two elements)\",\n         _ => \"other\"\n     }\n }"}, {"sha": "7a6129d311ee386e83a51ca4fb706ac2fa0809b5", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -11,21 +11,28 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n+use std::fmt::Debug;\n+\n+#[rustc_mir(graphviz=\"mir.gv\")]\n fn foldl<T, U, F>(values: &[T],\n                   initial: U,\n                   mut function: F)\n                   -> U where\n-    U: Clone,\n+    U: Clone+Debug, T:Debug,\n     F: FnMut(U, &T) -> U,\n-{\n-    match values {\n-        [ref head, tail..] =>\n+{    match values {\n+        &[ref head, ref tail..] =>\n             foldl(tail, function(initial, head), function),\n-        [] => initial.clone()\n+        &[] => {\n+            // FIXME: call guards\n+            let res = initial.clone(); res\n+        }\n     }\n }\n \n+#[rustc_mir]\n fn foldr<T, U, F>(values: &[T],\n                   initial: U,\n                   mut function: F)\n@@ -34,9 +41,12 @@ fn foldr<T, U, F>(values: &[T],\n     F: FnMut(&T, U) -> U,\n {\n     match values {\n-        [head.., ref tail] =>\n+        &[ref head.., ref tail] =>\n             foldr(head, function(tail, initial), function),\n-        [] => initial.clone()\n+        &[] => {\n+            // FIXME: call guards\n+            let res = initial.clone(); res\n+        }\n     }\n }\n "}, {"sha": "1093bc7c18b867e6f6e817e32527df9e09d6b52d", "filename": "src/test/run-pass/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(slice_patterns)]\n+#![feature(slice_patterns, rustc_attrs)]\n \n+#[rustc_mir]\n pub fn main() {\n     let x = &[1, 2, 3, 4, 5];\n     let x: &[isize] = &[1, 2, 3, 4, 5];\n     if !x.is_empty() {\n         let el = match x {\n-            [1, ref tail..] => &tail[0],\n+            &[1, ref tail..] => &tail[0],\n             _ => unreachable!()\n         };\n         println!(\"{}\", *el);"}, {"sha": "075709a63b5f5d2978947ea1062e189fc7440a6a", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -11,7 +11,9 @@\n \n #![feature(advanced_slice_patterns)]\n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n+#[rustc_mir]\n fn a() {\n     let x = [1];\n     match x {\n@@ -21,6 +23,7 @@ fn a() {\n     }\n }\n \n+#[rustc_mir]\n fn b() {\n     let x = [1, 2, 3];\n     match x {\n@@ -56,6 +59,48 @@ fn b() {\n     }\n }\n \n+\n+#[rustc_mir]\n+fn b_slice() {\n+    let x : &[_] = &[1, 2, 3];\n+    match x {\n+        &[a, b, ref c..] => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            let expected: &[_] = &[3];\n+            assert_eq!(c, expected);\n+        }\n+        _ => unreachable!()\n+    }\n+    match x {\n+        &[ref a.., b, c] => {\n+            let expected: &[_] = &[1];\n+            assert_eq!(a, expected);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+        _ => unreachable!()\n+    }\n+    match x {\n+        &[a, ref b.., c] => {\n+            assert_eq!(a, 1);\n+            let expected: &[_] = &[2];\n+            assert_eq!(b, expected);\n+            assert_eq!(c, 3);\n+        }\n+        _ => unreachable!()\n+    }\n+    match x {\n+        &[a, b, c] => {\n+            assert_eq!(a, 1);\n+            assert_eq!(b, 2);\n+            assert_eq!(c, 3);\n+        }\n+        _ => unreachable!()\n+    }\n+}\n+\n+#[rustc_mir]\n fn c() {\n     let x = [1];\n     match x {\n@@ -64,6 +109,7 @@ fn c() {\n     }\n }\n \n+#[rustc_mir]\n fn d() {\n     let x = [1, 2, 3];\n     let branch = match x {\n@@ -75,17 +121,40 @@ fn d() {\n     assert_eq!(branch, 1);\n }\n \n+#[rustc_mir]\n fn e() {\n     let x: &[isize] = &[1, 2, 3];\n-    match x {\n-        [1, 2] => (),\n-        [..] => ()\n-    }\n+    let a = match *x {\n+        [1, 2] => 0,\n+        [..] => 1,\n+    };\n+\n+    assert_eq!(a, 1);\n+\n+    let b = match *x {\n+        [2, ..] => 0,\n+        [1, 2, ..] => 1,\n+        [_] => 2,\n+        [..] => 3\n+    };\n+\n+    assert_eq!(b, 1);\n+\n+\n+    let c = match *x {\n+        [_, _, _, _, ..] => 0,\n+        [1, 2, ..] => 1,\n+        [_] => 2,\n+        [..] => 3\n+    };\n+\n+    assert_eq!(c, 1);\n }\n \n pub fn main() {\n     a();\n     b();\n+    b_slice();\n     c();\n     d();\n     e();"}, {"sha": "6084a0d07a114911f2e180062d159f3e42f11f6c", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -11,26 +11,28 @@\n \n \n #![feature(slice_patterns)]\n+#![feature(rustc_attrs)]\n \n struct Foo {\n-    string: String\n+    string: &'static str\n }\n \n+#[rustc_mir]\n pub fn main() {\n     let x = [\n-        Foo { string: \"foo\".to_string() },\n-        Foo { string: \"bar\".to_string() },\n-        Foo { string: \"baz\".to_string() }\n+        Foo { string: \"foo\" },\n+        Foo { string: \"bar\" },\n+        Foo { string: \"baz\" }\n     ];\n     match x {\n-        [ref first, tail..] => {\n-            assert_eq!(first.string, \"foo\".to_string());\n+        [ref first, ref tail..] => {\n+            assert_eq!(first.string, \"foo\");\n             assert_eq!(tail.len(), 2);\n-            assert_eq!(tail[0].string, \"bar\".to_string());\n-            assert_eq!(tail[1].string, \"baz\".to_string());\n+            assert_eq!(tail[0].string, \"bar\");\n+            assert_eq!(tail[1].string, \"baz\");\n \n-            match tail {\n-                [Foo { .. }, _, Foo { .. }, _tail..] => {\n+            match *(tail as &[_]) {\n+                [Foo { .. }, _, Foo { .. }, ref _tail..] => {\n                     unreachable!();\n                 }\n                 [Foo { string: ref a }, Foo { string: ref b }] => {"}, {"sha": "00f4aa98a3e062bf2694beca39bb2882f682f2d6", "filename": "src/test/run-pass/zero_sized_subslice_match.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c717a6fc21594569d9e64968cdcf2e88e372a07/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs?ref=5c717a6fc21594569d9e64968cdcf2e88e372a07", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+#![feature(rustc_attrs)]\n #![feature(slice_patterns)]\n \n+#[rustc_mir]\n fn main() {\n     let x = [(), ()];\n \n     // The subslice used to go out of bounds for zero-sized array items, check that this doesn't\n     // happen anymore\n     match x {\n-        [_, y..] => assert_eq!(&x[1] as *const (), &y[0] as *const ())\n+        [_, ref y..] => assert_eq!(&x[1] as *const (), &y[0] as *const ())\n     }\n }"}]}