{"sha": "7a13a61e02514f91065add51af6b4f3d9a7dac87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMTNhNjFlMDI1MTRmOTEwNjVhZGQ1MWFmNmI0ZjNkOWE3ZGFjODc=", "commit": {"author": {"name": "Adam Bozanich", "email": "adam.boz@gmail.com", "date": "2010-07-10T04:11:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2010-07-15T23:23:16Z"}, "message": "use,import,export parse fixes\n\n* use,import,export must come before all other items.\n* disallow use,import in \"native\" declarations.", "tree": {"sha": "2e4125470e162d3cdfcf8ce5a860a18666dbe5a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e4125470e162d3cdfcf8ce5a860a18666dbe5a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a13a61e02514f91065add51af6b4f3d9a7dac87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a13a61e02514f91065add51af6b4f3d9a7dac87", "html_url": "https://github.com/rust-lang/rust/commit/7a13a61e02514f91065add51af6b4f3d9a7dac87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a13a61e02514f91065add51af6b4f3d9a7dac87/comments", "author": {"login": "boz", "id": 12553, "node_id": "MDQ6VXNlcjEyNTUz", "avatar_url": "https://avatars.githubusercontent.com/u/12553?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boz", "html_url": "https://github.com/boz", "followers_url": "https://api.github.com/users/boz/followers", "following_url": "https://api.github.com/users/boz/following{/other_user}", "gists_url": "https://api.github.com/users/boz/gists{/gist_id}", "starred_url": "https://api.github.com/users/boz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boz/subscriptions", "organizations_url": "https://api.github.com/users/boz/orgs", "repos_url": "https://api.github.com/users/boz/repos", "events_url": "https://api.github.com/users/boz/events{/privacy}", "received_events_url": "https://api.github.com/users/boz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b096b0e3084079a8cb525e5590b9ab3e512109ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/b096b0e3084079a8cb525e5590b9ab3e512109ea", "html_url": "https://github.com/rust-lang/rust/commit/b096b0e3084079a8cb525e5590b9ab3e512109ea"}], "stats": {"total": 160, "additions": 87, "deletions": 73}, "files": [{"sha": "87604cb0ac6139fca5b7610892603746e693187c", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 87, "deletions": 73, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7a13a61e02514f91065add51af6b4f3d9a7dac87/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7a13a61e02514f91065add51af6b4f3d9a7dac87/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=7a13a61e02514f91065add51af6b4f3d9a7dac87", "patch": "@@ -774,7 +774,6 @@ and parse_type_item\n   let item = Ast.MOD_ITEM_type (effect, ty) in\n     (ident, span ps apos bpos (decl params item))\n \n-\n and parse_mod_item (ps:pstate) : (Ast.ident * Ast.mod_item) =\n   let apos = lexpos ps in\n   let parse_lib_name ident =\n@@ -848,64 +847,35 @@ and parse_mod_item (ps:pstate) : (Ast.ident * Ast.mod_item) =\n                 note_required_mod ps {lo=apos; hi=bpos} conv rlib item;\n                 (ident, item)\n           end\n-\n-      | USE ->\n-          begin\n-            bump ps;\n-            let ident = ctxt \"use mod: ident\" Pexp.parse_ident ps in\n-            let meta =\n-              ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n-            in\n-            let bpos = lexpos ps in\n-            let id = (span ps apos bpos ()).id in\n-            let (path, items) =\n-              ps.pstate_get_mod meta id ps.pstate_node_id ps.pstate_opaque_id\n-            in\n-            let bpos = lexpos ps in\n-              expect ps SEMI;\n-              let rlib =\n-                REQUIRED_LIB_rust { required_libname = path;\n-                                    required_prefix = ps.pstate_depth }\n-              in\n-                iflog ps\n-                  begin\n-                    fun _ ->\n-                      log ps \"extracted mod from %s (binding to %s)\"\n-                        path ident;\n-                      log ps \"%a\" Ast.sprintf_mod_items items;\n-                  end;\n-                let item = decl [||] (Ast.MOD_ITEM_mod (empty_view, items)) in\n-                let item = span ps apos bpos item in\n-                  note_required_mod ps {lo=apos; hi=bpos} CONV_rust rlib item;\n-                  (ident, item)\n-          end\n       | _ -> raise (unexpected ps)\n \n+and parse_mod_items_header_from_signature (ps:pstate) : Ast.mod_view =\n+  let exports = Hashtbl.create 0 in\n+    while (peek ps = EXPORT)\n+    do\n+      bump ps;\n+      parse_export ps exports;\n+      expect ps SEMI;\n+    done;\n+    if (Hashtbl.length exports) = 0\n+    then htab_put exports Ast.EXPORT_all_decls ();\n+    {empty_view with Ast.view_exports = exports}\n \n and parse_mod_items_from_signature\n     (ps:pstate)\n     : (Ast.mod_view * Ast.mod_items) =\n-  let exports = Hashtbl.create 0 in\n-  let mis = Hashtbl.create 0 in\n-    expect ps LBRACE;\n+  expect ps LBRACE;\n+  let view  = parse_mod_items_header_from_signature ps in\n+  let items = Hashtbl.create 0 in\n     while not (peek ps = RBRACE)\n     do\n-      match peek ps with\n-        EXPORT ->\n-            bump ps;\n-            parse_export ps exports;\n-            expect ps SEMI;\n-        | _ ->\n-            let (ident, mti) = ctxt \"mod items from sig: mod item\"\n+      let (ident,item) = ctxt \"mod items from sig: mod item\"\n               parse_mod_item_from_signature ps\n-            in\n-              Hashtbl.add mis ident mti;\n+      in\n+        htab_put items ident item;\n     done;\n-    if (Hashtbl.length exports) = 0\n-    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n     expect ps RBRACE;\n-    ({empty_view with Ast.view_exports = exports}, mis)\n-\n+    (view,items)\n \n and parse_mod_item_from_signature (ps:pstate)\n     : (Ast.ident * Ast.mod_item) =\n@@ -1023,7 +993,6 @@ and expand_tags_to_stmts\n               (Ast.DECL_mod_item (ident, tag_item))))\n       id_items\n \n-\n and expand_tags_to_items\n     (ps:pstate)\n     (item:Ast.mod_item)\n@@ -1034,7 +1003,6 @@ and expand_tags_to_items\n       (fun (ident, item) -> htab_put items ident item)\n       id_items\n \n-\n and note_required_mod\n     (ps:pstate)\n     (sp:span)\n@@ -1114,43 +1082,89 @@ and parse_export\n   in\n     Hashtbl.add exports e ()\n \n+and parse_use\n+    (ps:pstate)\n+    : (Ast.ident * Ast.mod_item) = \n+  bump ps;\n+  let ident = ctxt \"use mod: ident\" Pexp.parse_ident ps in\n+  let meta =\n+    ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n+  in\n+  let apos = lexpos ps in\n+  let bpos = lexpos ps in\n+  let id = (span ps apos bpos ()).id in\n+  let (path, items) =\n+    ps.pstate_get_mod meta id ps.pstate_node_id ps.pstate_opaque_id\n+  in\n+  let bpos = lexpos ps in\n+    expect ps SEMI;\n+    let rlib =\n+      REQUIRED_LIB_rust { required_libname = path;\n+                          required_prefix = ps.pstate_depth }\n+    in\n+      iflog ps\n+        begin\n+          fun _ ->\n+            log ps \"extracted mod from %s (binding to %s)\"\n+              path ident;\n+            log ps \"%a\" Ast.sprintf_mod_items items;\n+        end;\n+      let item = decl [||] (Ast.MOD_ITEM_mod (empty_view, items)) in\n+      let item = span ps apos bpos item in\n+        note_required_mod ps {lo=apos; hi=bpos} CONV_rust rlib item;\n+        (ident, item)\n+\n+and parse_item_decl ps items fn =\n+  let (ident, item) = fn ps in\n+    htab_put items ident item;\n+    expand_tags_to_items ps item items\n+\n+and parse_mod_header (ps:pstate)\n+                     : (Ast.mod_view * Ast.mod_items) =\n+  let imports = Hashtbl.create 0 in\n+  let exports = Hashtbl.create 0 in\n+  let items   = Hashtbl.create 4 in\n+  let rec loop () =\n+    match peek ps with\n+        IMPORT ->\n+          bump ps;\n+          parse_import ps imports;\n+          expect ps SEMI;\n+          loop ()\n+      | EXPORT ->\n+          bump ps;\n+          parse_export ps exports;\n+          expect ps SEMI;\n+          loop ()\n+      | USE ->\n+          parse_item_decl ps items parse_use;\n+          loop ()\n+      | _ -> ()\n+  in\n+    loop ();\n+    if (Hashtbl.length exports) = 0\n+    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n+    let view = { Ast.view_imports = imports;\n+                 Ast.view_exports = exports }\n+    in\n+      (view, items)\n \n and parse_mod_items\n     (ps:pstate)\n     (terminal:token)\n     : (Ast.mod_view * Ast.mod_items) =\n   ps.pstate_depth <- ps.pstate_depth + 1;\n-  let imports = Hashtbl.create 0 in\n-  let exports = Hashtbl.create 0 in\n-  let items = Hashtbl.create 4 in\n+  let (view, items) = parse_mod_header ps in\n     while (not (peek ps = terminal))\n     do\n-      match peek ps with\n-          IMPORT ->\n-            bump ps;\n-            parse_import ps imports;\n-            expect ps SEMI;\n-        | EXPORT ->\n-            bump ps;\n-            parse_export ps exports;\n-            expect ps SEMI;\n-        | _ ->\n-            let (ident, item) = parse_mod_item ps in\n-              htab_put items ident item;\n-              expand_tags_to_items ps item items;\n+      parse_item_decl ps items parse_mod_item;\n     done;\n-    if (Hashtbl.length exports) = 0\n-    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n     expect ps terminal;\n     ps.pstate_depth <- ps.pstate_depth - 1;\n-    let view = { Ast.view_imports = imports;\n-                 Ast.view_exports = exports }\n-    in\n-      (view, items)\n+    (view, items)\n ;;\n \n \n-\n (*\n  * Local Variables:\n  * fill-column: 78;"}]}