{"sha": "2fff041b433a972fbc7604b16341b232e221350a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZmYwNDFiNDMzYTk3MmZiYzc2MDRiMTYzNDFiMjMyZTIyMTM1MGE=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-11-14T21:52:43Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-11-14T21:54:57Z"}, "message": "Pass in whether an ast::Path is in an expression context.\n\nThis gets rid of a slightly nasty hack involving scanning the source\nexpression for a \":\".", "tree": {"sha": "638bf764b64d38075573bbb7c1667676a74beca5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/638bf764b64d38075573bbb7c1667676a74beca5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fff041b433a972fbc7604b16341b232e221350a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fff041b433a972fbc7604b16341b232e221350a", "html_url": "https://github.com/rust-lang/rust/commit/2fff041b433a972fbc7604b16341b232e221350a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fff041b433a972fbc7604b16341b232e221350a/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de599015de210205ccb4fa4619bc2add72d3647f", "url": "https://api.github.com/repos/rust-lang/rust/commits/de599015de210205ccb4fa4619bc2add72d3647f", "html_url": "https://github.com/rust-lang/rust/commit/de599015de210205ccb4fa4619bc2add72d3647f"}], "stats": {"total": 96, "additions": 47, "deletions": 49}, "files": [{"sha": "c4b01e38b42dec2bcf2192b4137cbde610c15538", "filename": "src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fff041b433a972fbc7604b16341b232e221350a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fff041b433a972fbc7604b16341b232e221350a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=2fff041b433a972fbc7604b16341b232e221350a", "patch": "@@ -117,7 +117,7 @@ impl Rewrite for ast::Expr {\n                 rewrite_match(context, cond, arms, width, offset, self.span)\n             }\n             ast::Expr_::ExprPath(ref qself, ref path) => {\n-                rewrite_path(context, qself.as_ref(), path, width, offset)\n+                rewrite_path(context, true, qself.as_ref(), path, width, offset)\n             }\n             ast::Expr_::ExprAssign(ref lhs, ref rhs) => {\n                 rewrite_assignment(context, lhs, rhs, None, width, offset)\n@@ -1242,7 +1242,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     // 2 = \" {\".len()\n     let path_budget = try_opt!(width.checked_sub(2));\n-    let path_str = try_opt!(path.rewrite(context, path_budget, offset));\n+    let path_str = try_opt!(rewrite_path(context, true, None, path, path_budget, offset));\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n     let h_budget = width.checked_sub(path_str.len() + 5).unwrap_or(0);"}, {"sha": "6917b1ff4031c30c1cc3d4d027306ebcd49fd968", "filename": "src/imports.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2fff041b433a972fbc7604b16341b232e221350a/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fff041b433a972fbc7604b16341b232e221350a/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=2fff041b433a972fbc7604b16341b232e221350a", "patch": "@@ -10,6 +10,7 @@\n \n use Indent;\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, definitive_tactic};\n+use types::rewrite_path;\n use utils::span_after;\n use rewrite::{Rewrite, RewriteContext};\n \n@@ -37,7 +38,7 @@ impl Rewrite for ast::ViewPath {\n                 let ident_str = ident.to_string();\n                 // 4 = \" as \".len()\n                 let budget = try_opt!(width.checked_sub(ident_str.len() + 4));\n-                let path_str = try_opt!(path.rewrite(context, budget, offset));\n+                let path_str = try_opt!(rewrite_path(context, false, None, path, budget, offset));\n \n                 Some(if path.segments.last().unwrap().identifier == ident {\n                     path_str\n@@ -105,7 +106,7 @@ pub fn rewrite_use_list(width: usize,\n                         -> Option<String> {\n     // 1 = {}\n     let budget = try_opt!(width.checked_sub(1));\n-    let path_str = try_opt!(path.rewrite(context, budget, offset));\n+    let path_str = try_opt!(rewrite_path(context, false, None, path, budget, offset));\n \n     match path_list.len() {\n         0 => unreachable!(),"}, {"sha": "bac69e4d1266047555fbf93d32252949e0ffe8c5", "filename": "src/patterns.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2fff041b433a972fbc7604b16341b232e221350a/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fff041b433a972fbc7604b16341b232e221350a/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=2fff041b433a972fbc7604b16341b232e221350a", "patch": "@@ -45,7 +45,7 @@ impl Rewrite for Pat {\n                 }\n             }\n             Pat_::PatQPath(ref q_self, ref path) => {\n-                rewrite_path(context, Some(q_self), path, width, offset)\n+                rewrite_path(context, true, Some(q_self), path, width, offset)\n             }\n             Pat_::PatRange(ref lhs, ref rhs) => {\n                 rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, width, offset)\n@@ -58,7 +58,12 @@ impl Rewrite for Pat {\n                 rewrite_tuple(context, items, self.span, width, offset)\n             }\n             Pat_::PatEnum(ref path, Some(ref pat_vec)) => {\n-                let path_str = try_opt!(::types::rewrite_path(context, None, path, width, offset));\n+                let path_str = try_opt!(::types::rewrite_path(context,\n+                                                              true,\n+                                                              None,\n+                                                              path,\n+                                                              width,\n+                                                              offset));\n \n                 if pat_vec.is_empty() {\n                     Some(path_str)"}, {"sha": "9b50333e043558433fde2fa1dd8fac94b0576592", "filename": "src/types.rs", "status": "modified", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2fff041b433a972fbc7604b16341b232e221350a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fff041b433a972fbc7604b16341b232e221350a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=2fff041b433a972fbc7604b16341b232e221350a", "patch": "@@ -10,22 +10,17 @@\n \n use syntax::ast::{self, Mutability};\n use syntax::print::pprust;\n-use syntax::codemap::{self, Span, BytePos, CodeMap};\n+use syntax::codemap::{self, Span, BytePos};\n \n use Indent;\n use lists::{format_item_list, itemize_list, format_fn_args};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after, format_mutability, wrap_str};\n use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple};\n \n-impl Rewrite for ast::Path {\n-    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        rewrite_path(context, None, self, width, offset)\n-    }\n-}\n-\n // Does not wrap on simple segments.\n pub fn rewrite_path(context: &RewriteContext,\n+                    expr_context: bool,\n                     qself: Option<&ast::QSelf>,\n                     path: &ast::Path,\n                     width: usize,\n@@ -53,7 +48,8 @@ pub fn rewrite_path(context: &RewriteContext,\n             // 3 = \">::\".len()\n             let budget = try_opt!(width.checked_sub(extra_offset + 3));\n \n-            result = try_opt!(rewrite_path_segments(result,\n+            result = try_opt!(rewrite_path_segments(expr_context,\n+                                                    result,\n                                                     path.segments.iter().take(skip_count),\n                                                     span_lo,\n                                                     path.span.hi,\n@@ -68,7 +64,8 @@ pub fn rewrite_path(context: &RewriteContext,\n \n     let extra_offset = extra_offset(&result, offset);\n     let budget = try_opt!(width.checked_sub(extra_offset));\n-    rewrite_path_segments(result,\n+    rewrite_path_segments(expr_context,\n+                          result,\n                           path.segments.iter().skip(skip_count),\n                           span_lo,\n                           path.span.hi,\n@@ -77,7 +74,8 @@ pub fn rewrite_path(context: &RewriteContext,\n                           offset + extra_offset)\n }\n \n-fn rewrite_path_segments<'a, I>(mut buffer: String,\n+fn rewrite_path_segments<'a, I>(expr_context: bool,\n+                                mut buffer: String,\n                                 iter: I,\n                                 mut span_lo: BytePos,\n                                 span_hi: BytePos,\n@@ -99,7 +97,8 @@ fn rewrite_path_segments<'a, I>(mut buffer: String,\n         let extra_offset = extra_offset(&buffer, offset);\n         let remaining_width = try_opt!(width.checked_sub(extra_offset));\n         let new_offset = offset + extra_offset;\n-        let segment_string = try_opt!(rewrite_segment(segment,\n+        let segment_string = try_opt!(rewrite_segment(expr_context,\n+                                                      segment,\n                                                       &mut span_lo,\n                                                       span_hi,\n                                                       context,\n@@ -152,30 +151,6 @@ impl<'a> Rewrite for SegmentParam<'a> {\n     }\n }\n \n-// This is a dirty hack to determine if we're in an expression or not. Generic\n-// parameters are passed differently in expressions and items. We'd declare\n-// a struct with Foo<A, B>, but call its functions with Foo::<A, B>::f().\n-// We'd really rather not do this, but there doesn't seem to be an alternative\n-// at this point.\n-// FIXME: fails with spans containing comments with the characters < or :\n-fn get_path_separator(codemap: &CodeMap,\n-                      path_start: BytePos,\n-                      segment_start: BytePos)\n-                      -> &'static str {\n-    let span = codemap::mk_sp(path_start, segment_start);\n-    let snippet = codemap.span_to_snippet(span).unwrap();\n-\n-    for c in snippet.chars().rev() {\n-        if c == ':' {\n-            return \"::\";\n-        } else if !c.is_whitespace() && c != '<' {\n-            return \"\";\n-        }\n-    }\n-\n-    unreachable!();\n-}\n-\n // Formats a path segment. There are some hacks involved to correctly determine\n // the segment's associated span since it's not part of the AST.\n //\n@@ -186,7 +161,8 @@ fn get_path_separator(codemap: &CodeMap,\n //\n // When the segment contains a positive number of parameters, we update span_lo\n // so that invariants described above will hold for the next segment.\n-fn rewrite_segment(segment: &ast::PathSegment,\n+fn rewrite_segment(expr_context: bool,\n+                   segment: &ast::PathSegment,\n                    span_lo: &mut BytePos,\n                    span_hi: BytePos,\n                    context: &RewriteContext,\n@@ -210,7 +186,11 @@ fn rewrite_segment(segment: &ast::PathSegment,\n \n             let next_span_lo = param_list.last().unwrap().get_span().hi + BytePos(1);\n             let list_lo = span_after(codemap::mk_sp(*span_lo, span_hi), \"<\", context.codemap);\n-            let separator = get_path_separator(context.codemap, *span_lo, list_lo);\n+            let separator = if expr_context {\n+                \"::\"\n+            } else {\n+                \"\"\n+            };\n \n             // 1 for <\n             let extra_offset = 1 + separator.len();\n@@ -334,7 +314,12 @@ impl Rewrite for ast::WherePredicate {\n                 // 3 = \" = \".len()\n                 let used_width = 3 + ty_str.len();\n                 let budget = try_opt!(width.checked_sub(used_width));\n-                let path_str = try_opt!(path.rewrite(context, budget, offset + used_width));\n+                let path_str = try_opt!(rewrite_path(context,\n+                                                     false,\n+                                                     None,\n+                                                     path,\n+                                                     budget,\n+                                                     offset + used_width));\n                 format!(\"{} = {}\", path_str, ty_str)\n             }\n         };\n@@ -427,13 +412,16 @@ impl Rewrite for ast::PolyTraitRef {\n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n             let max_path_width = try_opt!(width.checked_sub(extra_offset));\n-            let path_str = try_opt!(self.trait_ref\n-                                        .path\n-                                        .rewrite(context, max_path_width, offset + extra_offset));\n+            let path_str = try_opt!(rewrite_path(context,\n+                                                 false,\n+                                                 None,\n+                                                 &self.trait_ref.path,\n+                                                 max_path_width,\n+                                                 offset + extra_offset));\n \n             Some(format!(\"for<{}> {}\", lifetime_str, path_str))\n         } else {\n-            self.trait_ref.path.rewrite(context, width, offset)\n+            rewrite_path(context, false, None, &self.trait_ref.path, width, offset)\n         }\n     }\n }\n@@ -496,7 +484,7 @@ impl Rewrite for ast::Ty {\n             }\n             ast::TyPolyTraitRef(ref trait_ref) => trait_ref.rewrite(context, width, offset),\n             ast::TyPath(ref q_self, ref path) => {\n-                rewrite_path(context, q_self.as_ref(), path, width, offset)\n+                rewrite_path(context, false, q_self.as_ref(), path, width, offset)\n             }\n             ast::TyFixedLengthVec(ref ty, ref repeats) => {\n                 rewrite_pair(&**ty, &**repeats, \"[\", \"; \", \"]\", context, width, offset)"}, {"sha": "8a4ab769ba3aee7000d999d7bd655aad0162178b", "filename": "tests/source/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fff041b433a972fbc7604b16341b232e221350a/tests%2Fsource%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fff041b433a972fbc7604b16341b232e221350a/tests%2Fsource%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpaths.rs?ref=2fff041b433a972fbc7604b16341b232e221350a", "patch": "@@ -16,6 +16,8 @@ fn main() {\n                     >::some_func();\n \n     < *mut JSObject >:: relocate(entry);\n+\n+    let x: Foo/*::*/<A   >;\n }\n \n fn op(foo: Bar, key : &[u8], upd : Fn(Option<&memcache::Item> , Baz  ) -> Result) -> MapResult {}"}, {"sha": "15cc35e69f11a6808d111424689137105d6e2d14", "filename": "tests/target/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2fff041b433a972fbc7604b16341b232e221350a/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fff041b433a972fbc7604b16341b232e221350a/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=2fff041b433a972fbc7604b16341b232e221350a", "patch": "@@ -15,6 +15,8 @@ fn main() {\n     Quux::<ParamOne /* Comment 1 */, ParamTwo /* Comment 2 */>::some_func();\n \n     <*mut JSObject>::relocate(entry);\n+\n+    let x: Foo<A>;\n }\n \n fn op(foo: Bar, key: &[u8], upd: Fn(Option<&memcache::Item>, Baz) -> Result) -> MapResult {"}]}