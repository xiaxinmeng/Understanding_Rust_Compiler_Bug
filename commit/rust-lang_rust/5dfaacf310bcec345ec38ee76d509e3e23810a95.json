{"sha": "5dfaacf310bcec345ec38ee76d509e3e23810a95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZmFhY2YzMTBiY2VjMzQ1ZWMzOGVlNzZkNTA5ZTNlMjM4MTBhOTU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-27T11:36:41Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-06-27T11:36:41Z"}, "message": "Simplify all the code", "tree": {"sha": "3ab33216e3f627aa508087a7cfccef3b05a160d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ab33216e3f627aa508087a7cfccef3b05a160d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dfaacf310bcec345ec38ee76d509e3e23810a95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dfaacf310bcec345ec38ee76d509e3e23810a95", "html_url": "https://github.com/rust-lang/rust/commit/5dfaacf310bcec345ec38ee76d509e3e23810a95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dfaacf310bcec345ec38ee76d509e3e23810a95/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3832c6476c1b9e74d255be5c64a8719a9cd5ab7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3832c6476c1b9e74d255be5c64a8719a9cd5ab7", "html_url": "https://github.com/rust-lang/rust/commit/f3832c6476c1b9e74d255be5c64a8719a9cd5ab7"}], "stats": {"total": 156, "additions": 37, "deletions": 119}, "files": [{"sha": "958cc688f8accb6c6bb00533f80add782a33dc13", "filename": "src/eval_context.rs", "status": "modified", "additions": 29, "deletions": 68, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=5dfaacf310bcec345ec38ee76d509e3e23810a95", "patch": "@@ -1003,12 +1003,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         lvalue: Lvalue<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let new_lvalue = match lvalue {\n-            Lvalue::Local { frame, local, field } => {\n+            Lvalue::Local { frame, local } => {\n                 // -1 since we don't store the return value\n                 match self.stack[frame].locals[local.index() - 1] {\n                     None => return Err(EvalError::DeadLocal),\n                     Some(Value::ByRef(ptr)) => {\n-                        assert!(field.is_none());\n                         Lvalue::from_ptr(ptr)\n                     },\n                     Some(val) => {\n@@ -1018,12 +1017,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n                         self.stack[frame].locals[local.index() - 1] = Some(Value::ByRef(ptr)); // it stays live\n                         self.write_value_to_ptr(val, PrimVal::Ptr(ptr), ty)?;\n-                        let lval = Lvalue::from_ptr(ptr);\n-                        if let Some((field, field_ty)) = field {\n-                            self.lvalue_field(lval, field, ty, field_ty)?\n-                        } else {\n-                            lval\n-                        }\n+                        Lvalue::from_ptr(ptr)\n                     }\n                 }\n             }\n@@ -1110,11 +1104,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_value_to_ptr(src_val, ptr, dest_ty)\n             }\n \n-            Lvalue::Local { frame, local, field } => {\n-                let dest = self.stack[frame].get_local(local, field.map(|(i, _)| i))?;\n+            Lvalue::Local { frame, local } => {\n+                let dest = self.stack[frame].get_local(local)?;\n                 self.write_value_possibly_by_val(\n                     src_val,\n-                    |this, val| this.stack[frame].set_local(local, field.map(|(i, _)| i), val),\n+                    |this, val| this.stack[frame].set_local(local, val),\n                     dest,\n                     dest_ty,\n                 )\n@@ -1353,7 +1347,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     I128 => 16,\n                     Is => self.memory.pointer_size(),\n                 };\n-                PrimVal::from_i128(self.memory.read_int(ptr, size)?)\n+                // if we cast a ptr to a usize reading it back into a primval shouldn't panic\n+                // Due to read_ptr ignoring the sign, we need to jump around some hoops\n+                match self.memory.read_int(ptr, size) {\n+                    Err(EvalError::ReadPointerAsBytes) if size == self.memory.pointer_size() => self.memory.read_ptr(ptr)?,\n+                    other => PrimVal::from_i128(other?),\n+                }\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1366,7 +1365,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     U128 => 16,\n                     Us => self.memory.pointer_size(),\n                 };\n-                PrimVal::from_u128(self.memory.read_uint(ptr, size)?)\n+                if size == self.memory.pointer_size() {\n+                    // if we cast a ptr to a usize reading it back into a primval shouldn't panic\n+                    self.memory.read_ptr(ptr)?\n+                } else {\n+                    PrimVal::from_u128(self.memory.read_uint(ptr, size)?)\n+                }\n             }\n \n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n@@ -1518,19 +1522,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n         // Debug output\n-        if let Lvalue::Local { frame, local, field } = lvalue {\n+        if let Lvalue::Local { frame, local } = lvalue {\n             let mut allocs = Vec::new();\n             let mut msg = format!(\"{:?}\", local);\n-            if let Some((field, _)) = field {\n-                write!(msg, \".{}\", field).unwrap();\n-            }\n             let last_frame = self.stack.len() - 1;\n             if frame != last_frame {\n                 write!(msg, \" ({} frames up)\", last_frame - frame).unwrap();\n             }\n             write!(msg, \":\").unwrap();\n \n-            match self.stack[frame].get_local(local, field.map(|(i, _)| i)) {\n+            match self.stack[frame].get_local(local) {\n                 Err(EvalError::DeadLocal) => {\n                     write!(msg, \" is dead\").unwrap();\n                 }\n@@ -1575,14 +1576,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         frame: usize,\n         local: mir::Local,\n-        field: Option<usize>,\n         f: F,\n     ) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let val = self.stack[frame].get_local(local, field)?;\n+        let val = self.stack[frame].get_local(local)?;\n         let new_val = f(self, val)?;\n-        self.stack[frame].set_local(local, field, new_val)?;\n+        self.stack[frame].set_local(local, new_val)?;\n         // FIXME(solson): Run this when setting to Undef? (See previous version of this code.)\n         // if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n         //     self.memory.deallocate(ptr)?;\n@@ -1598,59 +1598,20 @@ impl<'tcx> Frame<'tcx> {\n             _ => false,\n         }\n     }\n-    pub fn get_local(&self, local: mir::Local, field: Option<usize>) -> EvalResult<'tcx, Value> {\n+    pub fn get_local(&self, local: mir::Local) -> EvalResult<'tcx, Value> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        if let Some(field) = field {\n-            Ok(match self.locals[local.index() - 1] {\n-                None => return Err(EvalError::DeadLocal),\n-                Some(Value::ByRef(_)) => bug!(\"can't have lvalue fields for ByRef\"),\n-                Some(val @ Value::ByVal(_)) => {\n-                    assert_eq!(field, 0);\n-                    val\n-                },\n-                Some(Value::ByValPair(a, b)) => {\n-                    match field {\n-                        0 => Value::ByVal(a),\n-                        1 => Value::ByVal(b),\n-                        _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n-                    }\n-                },\n-            })\n-        } else {\n-            self.locals[local.index() - 1].ok_or(EvalError::DeadLocal)\n-        }\n+        self.locals[local.index() - 1].ok_or(EvalError::DeadLocal)\n     }\n \n-    fn set_local(&mut self, local: mir::Local, field: Option<usize>, value: Value) -> EvalResult<'tcx> {\n+    fn set_local(&mut self, local: mir::Local, value: Value) -> EvalResult<'tcx> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        if let Some(field) = field {\n-            match self.locals[local.index() - 1] {\n-                None => return Err(EvalError::DeadLocal),\n-                Some(Value::ByRef(_)) => bug!(\"can't have lvalue fields for ByRef\"),\n-                Some(Value::ByVal(_)) => {\n-                    assert_eq!(field, 0);\n-                    self.set_local(local, None, value)?;\n-                },\n-                Some(Value::ByValPair(a, b)) => {\n-                    let prim = match value {\n-                        Value::ByRef(_) => bug!(\"can't set ValPair field to ByRef\"),\n-                        Value::ByVal(val) => val,\n-                        Value::ByValPair(_, _) => bug!(\"can't set ValPair field to ValPair\"),\n-                    };\n-                    match field {\n-                        0 => self.set_local(local, None, Value::ByValPair(prim, b))?,\n-                        1 => self.set_local(local, None, Value::ByValPair(a, prim))?,\n-                        _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n-                    }\n-                },\n-            }\n-        } else {\n-            match self.locals[local.index() - 1] {\n-                None => return Err(EvalError::DeadLocal),\n-                Some(ref mut local) => { *local = value; }\n+        match self.locals[local.index() - 1] {\n+            None => Err(EvalError::DeadLocal),\n+            Some(ref mut local) => {\n+                *local = value;\n+                Ok(())\n             }\n         }\n-        return Ok(());\n     }\n \n     pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, Option<Value>> {"}, {"sha": "93646ba531fdc083754c092e4ff24845e9130f94", "filename": "src/lvalue.rs", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=5dfaacf310bcec345ec38ee76d509e3e23810a95", "patch": "@@ -24,8 +24,6 @@ pub enum Lvalue<'tcx> {\n     Local {\n         frame: usize,\n         local: mir::Local,\n-        /// Optionally, this lvalue can point to a field of the stack value\n-        field: Option<(usize, Ty<'tcx>)>,\n     },\n \n     /// An lvalue referring to a global\n@@ -141,8 +139,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 assert_eq!(extra, LvalueExtra::None);\n                 Ok(Value::ByRef(ptr.to_ptr()?))\n             }\n-            Lvalue::Local { frame, local, field } => {\n-                self.stack[frame].get_local(local, field.map(|(i, _)| i))\n+            Lvalue::Local { frame, local } => {\n+                self.stack[frame].get_local(local)\n             }\n             Lvalue::Global(cid) => {\n                 Ok(self.globals.get(&cid).expect(\"global not cached\").value)\n@@ -154,7 +152,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n-            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local, field: None },\n+            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local },\n \n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);\n@@ -235,48 +233,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n         };\n \n-        let (base_ptr, base_extra) = match base {\n-            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-            Lvalue::Local { frame, local, field } => match self.stack[frame].get_local(local, field.map(|(i, _)| i))? {\n-                Value::ByRef(ptr) => {\n-                    assert!(field.is_none(), \"local can't be ByRef and have a field offset\");\n-                    (PrimVal::Ptr(ptr), LvalueExtra::None)\n-                },\n-                Value::ByVal(PrimVal::Undef) => {\n-                    // FIXME: allocate in fewer cases\n-                    if self.ty_to_primval_kind(base_ty).is_ok() {\n-                        return Ok(base);\n-                    } else {\n-                        (PrimVal::Ptr(self.force_allocation(base)?.to_ptr()?), LvalueExtra::None)\n-                    }\n-                },\n-                Value::ByVal(_) => {\n-                    if self.get_field_count(base_ty)? == 1 {\n-                        assert_eq!(field_index, 0, \"ByVal can only have 1 non zst field with offset 0\");\n-                        return Ok(base);\n-                    }\n-                    // this branch is taken when a union creates a large ByVal which is then\n-                    // accessed as a struct with multiple small fields\n-                    (PrimVal::Ptr(self.force_allocation(base)?.to_ptr()?), LvalueExtra::None)\n-                },\n-                Value::ByValPair(_, _) => {\n-                    let field_count = self.get_field_count(base_ty)?;\n-                    if field_count == 1 {\n-                        assert_eq!(field_index, 0, \"{:?} has only one field\", base_ty);\n-                        return Ok(base);\n-                    }\n-                    assert_eq!(field_count, 2);\n-                    assert!(field_index < 2);\n-                    return Ok(Lvalue::Local {\n-                        frame,\n-                        local,\n-                        field: Some((field_index, field_ty)),\n-                    });\n-                },\n-            },\n-            // FIXME: do for globals what we did for locals\n-            Lvalue::Global(_) => self.force_allocation(base)?.to_ptr_and_extra(),\n-        };\n+        let (base_ptr, base_extra) = self.force_allocation(base)?.to_ptr_and_extra();\n \n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {"}, {"sha": "e2e0d81d0607ad6ef229c8ba86ee61b4f556a0e2", "filename": "src/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=5dfaacf310bcec345ec38ee76d509e3e23810a95", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // Mark locals as dead or alive.\n             StorageLive(ref lvalue) | StorageDead(ref lvalue)=> {\n                 let (frame, local) = match self.eval_lvalue(lvalue)? {\n-                    Lvalue::Local{ frame, local, field: None } if self.stack.len() == frame+1 => (frame, local),\n+                    Lvalue::Local{ frame, local } if self.stack.len() == frame+1 => (frame, local),\n                     _ => return Err(EvalError::Unimplemented(\"Storage annotations must refer to locals of the topmost stack frame.\".to_owned())) // FIXME maybe this should get its own error type\n                 };\n                 let old_val = match stmt.kind {"}, {"sha": "360842ac5475a1805cad8b2a340ecab1ac50e971", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfaacf310bcec345ec38ee76d509e3e23810a95/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=5dfaacf310bcec345ec38ee76d509e3e23810a95", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Ok(zero_val)\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), init)?,\n+                    Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr.to_ptr()?, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, init)?,\n@@ -419,7 +419,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), uninit)?,\n+                    Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None } =>\n                         self.memory.mark_definedness(ptr, size, false)?,\n                     Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat ptr target\"),"}, {"sha": "342eb28a970fcebbe6f658eeb70a105681f7b3a5", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dfaacf310bcec345ec38ee76d509e3e23810a95/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dfaacf310bcec345ec38ee76d509e3e23810a95/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=5dfaacf310bcec345ec38ee76d509e3e23810a95", "patch": "@@ -3,5 +3,5 @@ fn main() {\n     let y = &x;\n     let z = &y as *const &i32 as *const usize;\n     let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _ = ptr_bytes == 15; //~ ERROR: tried to access part of a pointer value as raw bytes\n+    let _ = ptr_bytes % 432; //~ ERROR: tried to access part of a pointer value as raw bytes\n }"}]}