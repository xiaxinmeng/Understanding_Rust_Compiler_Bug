{"sha": "a5dcf66ad3760961244477c610e4478853e13abb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZGNmNjZhZDM3NjA5NjEyNDQ0NzdjNjEwZTQ0Nzg4NTNlMTNhYmI=", "commit": {"author": {"name": "David Rajchenbach-Teller", "email": "dteller@mozilla.com", "date": "2011-11-04T17:38:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-05T20:04:34Z"}, "message": "stdlib: Added a small rope library", "tree": {"sha": "34360bca18a85f8705af6f5a067a2de767ffc5f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34360bca18a85f8705af6f5a067a2de767ffc5f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5dcf66ad3760961244477c610e4478853e13abb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5dcf66ad3760961244477c610e4478853e13abb", "html_url": "https://github.com/rust-lang/rust/commit/a5dcf66ad3760961244477c610e4478853e13abb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5dcf66ad3760961244477c610e4478853e13abb/comments", "author": {"login": "Yoric", "id": 10190, "node_id": "MDQ6VXNlcjEwMTkw", "avatar_url": "https://avatars.githubusercontent.com/u/10190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Yoric", "html_url": "https://github.com/Yoric", "followers_url": "https://api.github.com/users/Yoric/followers", "following_url": "https://api.github.com/users/Yoric/following{/other_user}", "gists_url": "https://api.github.com/users/Yoric/gists{/gist_id}", "starred_url": "https://api.github.com/users/Yoric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Yoric/subscriptions", "organizations_url": "https://api.github.com/users/Yoric/orgs", "repos_url": "https://api.github.com/users/Yoric/repos", "events_url": "https://api.github.com/users/Yoric/events{/privacy}", "received_events_url": "https://api.github.com/users/Yoric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07574363efc8fa046d197c71a53ac9987c064902", "url": "https://api.github.com/repos/rust-lang/rust/commits/07574363efc8fa046d197c71a53ac9987c064902", "html_url": "https://github.com/rust-lang/rust/commit/07574363efc8fa046d197c71a53ac9987c064902"}], "stats": {"total": 1134, "additions": 1134, "deletions": 0}, "files": [{"sha": "0e6560d3c3bb9411f275e5ba91cfbb8220fc9c50", "filename": "src/lib/rope.rs", "status": "added", "additions": 1131, "deletions": 0, "changes": 1131, "blob_url": "https://github.com/rust-lang/rust/blob/a5dcf66ad3760961244477c610e4478853e13abb/src%2Flib%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dcf66ad3760961244477c610e4478853e13abb/src%2Flib%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frope.rs?ref=a5dcf66ad3760961244477c610e4478853e13abb", "patch": "@@ -0,0 +1,1131 @@\n+/*\n+Module: rope\n+\n+\n+High-level text containers.\n+\n+Ropes are a high-level representation of text that offers\n+much better performance than strings for common operations,\n+and generally reduce memory allocations and copies, while only\n+entailing a small degradation of less common operations.\n+\n+More precisely, where a string is represented as a memory buffer,\n+a rope is a tree structure whose leaves are slices of immutable\n+strings. Therefore, concatenation, appending, prepending, substrings,\n+etc. are operations that require only trivial tree manipulation,\n+generally without having to copy memory. In addition, the tree\n+structure of ropes makes them suitable as a form of index to speed-up\n+access to Unicode characters by index in long chunks of text.\n+\n+The following operations are algorithmically faster in ropes:\n+- extracting a subrope is logarithmic (linear in strings);\n+- appending/prepending is near-constant time (linear in strings);\n+- concatenation is near-constant time (linear in strings);\n+- char length is constant-time (linear in strings);\n+- access to a character by index is logarithmic (linear in strings);\n+ */\n+\n+\n+\n+\n+/*\n+ Type: rope\n+\n+ The type of ropes.\n+ */\n+type rope = node::root;\n+\n+/*\n+ Section: Creating a rope\n+ */\n+\n+/*\n+ Function:empty\n+\n+ Create an empty rope\n+ */\n+fn empty() -> rope {\n+   ret node::empty;\n+}\n+\n+/*\n+ Function: of_str\n+\n+ Adopt a string as a rope.\n+\n+ Parameters:\n+\n+str - A valid string.\n+\n+ Returns:\n+\n+A rope representing the same string as `str`. Depending of the length\n+of `str`, this rope may be empty, flat or complex.\n+\n+Performance notes:\n+- this operation does not copy the string;\n+- the function runs in linear time.\n+ */\n+fn of_str(str: @str) -> rope {\n+    ret of_substr(str, 0u, str::byte_len(*str));\n+}\n+\n+/*\n+Function: of_substr\n+\n+As `of_str` but for a substring.\n+\n+Performance note:\n+- this operation does not copy the substring.\n+\n+Parameters:\n+\n+byte_offset - The offset of `str` at which the rope starts.\n+byte_len    - The number of bytes of `str` to use.\n+\n+Returns:\n+\n+A rope representing the same string as\n+`str::substr(str, byte_offset, byte_len)`.\n+Depending on `byte_len`, this rope may be empty, flat or complex.\n+\n+Safety notes:\n+- this function does _not_ check the validity of the substring;\n+- this function fails if `byte_offset` or `byte_len` do not match `str`.\n+ */\n+fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n+    if byte_len == 0u { ret node::empty; }\n+    ret node::content(node::of_substr(str, byte_offset, byte_len));\n+}\n+\n+/*\n+Section: Adding things to a rope\n+ */\n+\n+/*\n+Function: append_char\n+\n+Add one char to the end of the rope\n+\n+Performance note:\n+- this function executes in near-constant time\n+ */\n+fn append_char(rope: rope, char: char) -> rope {\n+    ret append_str(rope, @str::from_chars([char]));\n+}\n+\n+/*\n+Function: append_str\n+\n+Add one string to the end of the rope\n+\n+Performance note:\n+- this function executes in near-linear time\n+ */\n+fn append_str(rope: rope, str: @str) -> rope {\n+    ret append_rope(rope, of_str(str))\n+}\n+\n+/*\n+Function: prepend_char\n+\n+Add one char to the beginning of the rope\n+\n+Performance note:\n+- this function executes in near-constant time\n+ */\n+fn prepend_char(rope: rope, char: char) -> rope {\n+    ret prepend_str(rope, @str::from_chars([char]));\n+}\n+\n+/*\n+Function: prepend_str\n+\n+Add one string to the beginning of the rope\n+\n+Performance note:\n+- this function executes in near-linear time\n+ */\n+fn prepend_str(rope: rope, str: @str) -> rope {\n+    ret append_rope(of_str(str), rope)\n+}\n+\n+/*\n+Function: append_rope\n+\n+Concatenate two ropes\n+ */\n+fn append_rope(left: rope, right: rope) -> rope {\n+   alt(left) {\n+     node::empty. { ret right; }\n+     node::content(left_content) {\n+       alt(right) {\n+         node::empty. { ret left; }\n+     node::content(right_content) {\n+           ret node::content(node::concat2(left_content, right_content));\n+     }\n+       }\n+     }\n+   }\n+}\n+\n+/*\n+Function: concat\n+\n+Concatenate many ropes\n+ */\n+fn concat(v: [rope]) -> rope {\n+   let acc = node::empty;\n+   for r: rope in v {\n+       acc = append_rope(acc, r);\n+   }\n+   ret bal(acc);\n+}\n+\n+\n+/*\n+Section: Keeping ropes healthy\n+ */\n+\n+\n+\n+/*\n+Function: bal\n+\n+Balance a rope.\n+\n+Returns:\n+\n+A copy of the rope in which small nodes have been grouped in memory,\n+and with a reduced height.\n+\n+If you perform numerous rope concatenations, it is generally a good idea\n+to rebalance your rope at some point, before using it for other purposes.\n+ */\n+fn bal(rope:rope) -> rope {\n+    alt(rope) {\n+      node::empty. { ret rope }\n+      node::content(x) {\n+        alt(node::bal(x)) {\n+          option::none.   { rope }\n+          option::some(y) { node::content(y) }\n+        }\n+      }\n+    }\n+}\n+\n+/*\n+Section: Transforming ropes\n+ */\n+\n+\n+/*\n+Function: sub_chars\n+\n+Extract a subrope from a rope.\n+\n+Performance note:\n+- on a balanced rope, this operation takes algorithmic time;\n+- this operation does not involve any copying\n+\n+Safety note:\n+- this function fails if char_offset/char_len do not represent\n+valid positions in rope\n+ */\n+fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n+    if char_len == 0u { ret node::empty; }\n+    alt(rope) {\n+      node::empty. { fail }\n+      node::content(node) {\n+        if char_len > node::char_len(node) { fail }\n+        else {\n+            ret node::content(node::sub_chars(node, char_offset, char_len))\n+        }\n+      }\n+    }\n+}\n+\n+/*\n+Function:sub_bytes\n+\n+Extract a subrope from a rope.\n+\n+Performance note:\n+- on a balanced rope, this operation takes algorithmic time;\n+- this operation does not involve any copying\n+\n+Safety note:\n+- this function fails if byte_offset/byte_len do not represent\n+valid positions in rope\n+ */\n+fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n+    if byte_len == 0u { ret node::empty; }\n+    alt(rope) {\n+      node::empty. { fail }\n+      node::content(node) {\n+        if byte_len > node::byte_len(node) { fail }\n+        else {\n+            ret node::content(node::sub_bytes(node, byte_offset, byte_len))\n+        }\n+      }\n+    }\n+}\n+\n+/*\n+Section: Comparing ropes\n+ */\n+\n+/*\n+Function: cmp\n+\n+Compare two ropes by Unicode lexicographical order.\n+\n+This function compares only the contents of the rope, not their structure.\n+\n+Returns:\n+\n+A negative value if `left < right`, 0 if eq(left, right) or a positive\n+value if `left > right`\n+ */\n+fn cmp(left: rope, right: rope) -> int {\n+    alt((left, right)) {\n+      (node::empty., node::empty.) { ret 0; }\n+      (node::empty., _)     { ret -1;}\n+      (_, node::empty.)     { ret  1;}\n+      (node::content(a), node::content(b)) {\n+        ret node::cmp(a, b);\n+      }\n+    }\n+}\n+\n+fn eq(left: rope, right: rope) -> bool {\n+    ret cmp(left, right) == 0;\n+}\n+\n+fn leq(left: rope, right: rope) -> bool {\n+    ret cmp(left, right) <= 0;\n+}\n+\n+fn lt(left: rope, right: rope) -> bool {\n+    ret cmp(left, right) < 0;\n+}\n+\n+fn geq(left: rope, right: rope) -> bool {\n+    ret cmp(left, right) >= 0;\n+}\n+\n+fn gt(left: rope, right: rope) -> bool {\n+    ret cmp(left, right) > 0;\n+}\n+\n+/*\n+Section: Iterating\n+ */\n+\n+/*\n+Function: loop_chars\n+\n+Loop through a rope, char by char\n+\n+While other mechanisms are available, this is generally the best manner\n+of looping through the contents of a rope char by char. If you prefer a\n+loop that iterates through the contents string by string (e.g. to print\n+the contents of the rope or output it to the system), however,\n+you should rather use `traverse_components`.\n+\n+Parameters:\n+rope - A rope to traverse. It may be empty.\n+it - A block to execute with each consecutive character of the rope.\n+Return `true` to continue, `false` to stop.\n+\n+Returns:\n+\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n+ */\n+fn loop_chars(rope: rope, it: block(char) -> bool) -> bool {\n+   alt(rope) {\n+      node::empty. { ret true }\n+      node::content(x) { ret node::loop_chars(x, it) }\n+   }\n+}\n+fn iter_chars(rope: rope, it: block(char)) {\n+    loop_chars(rope) {|x|\n+        it(x);\n+        ret true\n+    }\n+}\n+\n+/*\n+Function: loop_leaves\n+\n+Loop through a rope, string by string\n+\n+While other mechanisms are available, this is generally the best manner of\n+looping through the contents of a rope string by string, which may be useful\n+e.g. to print strings as you see them (without having to copy their\n+contents into a new string), to send them to then network, to write them to\n+a file, etc.. If you prefer a loop that iterates through the contents\n+char by char (e.g. to search for a char), however, you should rather\n+use `traverse`.\n+\n+Parameters:\n+\n+rope - A rope to traverse. It may be empty.\n+it - A block to execute with each consecutive string component of the rope.\n+Return `true` to continue, `false` to stop.\n+\n+Returns:\n+\n+`true` If execution proceeded correctly, `false` if it was interrupted,\n+that is if `it` returned `false` at any point.\n+ */\n+fn loop_leaves(rope: rope, it: block(node::leaf) -> bool) -> bool{\n+   alt(rope) {\n+      node::empty. { ret true }\n+      node::content(x) {ret node::loop_leaves(x, it)}\n+   }\n+}\n+\n+mod iterator {\n+    mod leaf {\n+        fn start(rope: rope) -> node::leaf_iterator::t {\n+            alt(rope) {\n+              node::empty.     { ret node::leaf_iterator::empty() }\n+              node::content(x) { ret node::leaf_iterator::start(x) }\n+            }\n+        }\n+        fn next(it: node::leaf_iterator::t) -> option::t<node::leaf> {\n+            ret node::leaf_iterator::next(it);\n+        }\n+    }\n+    mod char {\n+        fn start(rope: rope) -> node::char_iterator::t {\n+            alt(rope) {\n+              node::empty.   { ret node::char_iterator::empty() }\n+              node::content(x) { ret node::char_iterator::start(x) }\n+            }\n+        }\n+        fn next(it: node::char_iterator::t) -> option::t<char> {\n+            ret node::char_iterator::next(it)\n+        }\n+    }\n+}\n+\n+/*\n+ Section: Rope properties\n+ */\n+\n+/*\n+ Function: height\n+\n+ Returns: The height of the rope, i.e. a bound on the number of\n+operations which must be performed during a character access before\n+finding the leaf in which a character is contained.\n+\n+ Performance note: Constant time.\n+*/\n+fn height(rope: rope) -> uint {\n+   alt(rope) {\n+      node::empty.    { ret 0u; }\n+      node::content(x) { ret node::height(x); }\n+   }\n+}\n+\n+\n+\n+/*\n+ Function: char_len\n+\n+ Returns: The number of character in the rope\n+\n+ Performance note: Constant time.\n+ */\n+pure fn char_len(rope: rope) -> uint {\n+   alt(rope) {\n+     node::empty.           { ret 0u; }\n+     node::content(x)       { ret node::char_len(x) }\n+   }\n+}\n+\n+/*\n+ Function: char_len\n+\n+ Returns: The number of bytes in the rope\n+\n+ Performance note: Constant time.\n+ */\n+pure fn byte_len(rope: rope) -> uint {\n+   alt(rope) {\n+     node::empty.           { ret 0u; }\n+     node::content(x)       { ret node::byte_len(x) }\n+   }\n+}\n+\n+/*\n+ Function: char_at\n+\n+ Parameters:\n+  pos - A position in the rope\n+\n+ Returns: The character at position `pos`\n+\n+ Safety notes: The function will fail if `pos`\n+ is not a valid position in the rope.\n+\n+ Performance note: This function executes in a time\n+ proportional to the height of the rope + the (bounded)\n+ length of the largest leaf.\n+ */\n+fn char_at(rope: rope, pos: uint) -> char {\n+   alt(rope) {\n+      node::empty. { fail }\n+      node::content(x) { ret node::char_at(x, pos) }\n+   }\n+}\n+\n+\n+/*\n+ Section: Implementation\n+*/\n+mod node {\n+\n+    /*\n+     Enum: node::root\n+\n+     Implementation of type `rope`\n+\n+     Constants:\n+       empty   - An empty rope\n+       content - A non-empty rope\n+    */\n+    tag root {\n+        empty;\n+        content(@node);\n+    }\n+\n+    /*\n+     Struct: node::leaf\n+\n+     A text component in a rope.\n+\n+     This is actually a slice in a rope, so as to ensure maximal sharing.\n+    */\n+    type leaf = {\n+\n+    /*\n+     Field: byte_offset\n+\n+     The number of bytes skipped in `content`\n+    */\n+    byte_offset: uint,\n+\n+    /*\n+     Field: byte_len\n+\n+     The number of bytes of `content` to use\n+    */\n+    byte_len:    uint,\n+\n+    /*\n+     Field: char_len\n+\n+\n+     The number of chars in the leaf.\n+    */\n+    char_len:   uint,\n+\n+    /*\n+    Field: content\n+\n+    Contents of the leaf.\n+\n+    Note that we can have `char_len < str::char_len(content)`, if this\n+    leaf is only a subset of the string. Also note that the string\n+    can be shared between several ropes, e.g. for indexing purposes.\n+    */\n+    content:    @str\n+    };\n+\n+\n+    /*\n+     Struct node::concat\n+\n+     A node obtained from the concatenation of two other nodes\n+    */\n+    type concat = {\n+\n+        /*\n+        Field: left\n+\n+        The node containing the beginning of the text.\n+        */\n+        left:     @node,//TODO: Perhaps a `vec` instead of `left`/`right`\n+\n+        /*\n+        Field: right\n+\n+        The node containing the end of the text.\n+        */\n+        right:    @node,\n+\n+        /*\n+        Field: char_len\n+\n+        The number of chars contained in all leaves of this node.\n+        */\n+        char_len: uint,\n+\n+        /*\n+        Field: byte_len\n+\n+        The number of bytes in the subrope.\n+\n+        Used to pre-allocate the correct amount of storage for serialization.\n+        */\n+        byte_len: uint,\n+\n+        /*\n+        Field: height\n+\n+        Height of the subrope.\n+\n+        Used for rebalancing and to allocate stacks for\n+        traversals.\n+        */\n+        height:   uint\n+    };\n+\n+    /*\n+    Enum: node::node\n+\n+    leaf - A leaf consisting in a `str`\n+    concat - The concatenation of two ropes\n+    */\n+    tag node {\n+        leaf(leaf);\n+        concat(concat);\n+    }\n+\n+    /*\n+    The maximal number of chars that _should_ be permitted in a single node.\n+\n+    This is not a strict value\n+     */\n+    const hint_max_leaf_char_len: uint = 256u;\n+\n+    /*\n+    The maximal height that _should_ be permitted in a tree.\n+\n+    This is not a strict value\n+     */\n+    const hint_max_node_height:   uint = 16u;\n+\n+    /*\n+    Adopt a string as a node.\n+\n+    If the string is longer than `max_leaf_char_len`, it is\n+    logically split between as many leaves as necessary. Regardless,\n+    the string itself is not copied.\n+\n+    Performance note: The complexity of this function is linear in\n+    the length of `str`.\n+     */\n+    fn of_str(str: @str) -> @node {\n+        ret of_substr(str, 0u, str::byte_len(*str));\n+    }\n+\n+    /*\n+    Adopt a slice of a string as a node.\n+\n+    If the slice is longer than `max_leaf_char_len`, it is logically split\n+    between as many leaves as necessary. Regardless, the string itself\n+    is not copied.\n+\n+    @param byte_start The byte offset where the slice of `str` starts.\n+    @param byte_len   The number of bytes from `str` to use.\n+     */\n+    fn of_substr(str: @str, byte_start: uint, byte_len: uint) -> @node {\n+        assert (byte_len > 0u);\n+        let char_len = str::char_len_range(*str, byte_start, byte_len);\n+        let candidate = @leaf({\n+                byte_offset: byte_start,\n+                byte_len:    byte_len,\n+                char_len:    char_len,\n+                content:     str});\n+        if char_len <= hint_max_leaf_char_len {\n+            ret candidate;\n+        } else {\n+            //Firstly, split `str` in slices of hint_max_leaf_char_len\n+            let leaves = uint::div_ceil(char_len, hint_max_leaf_char_len);\n+            //Number of leaves\n+            let nodes  = vec::init_elt_mut(candidate, leaves);\n+\n+            let i = 0u;\n+            let offset = byte_start;\n+            let first_leaf_char_len =\n+                if char_len%hint_max_leaf_char_len == 0u {\n+                  hint_max_leaf_char_len\n+                } else {\n+                char_len%hint_max_leaf_char_len\n+               };\n+            while i < leaves {\n+                let chunk_char_len: uint =\n+                    if i == 0u  { first_leaf_char_len }\n+                    else { hint_max_leaf_char_len };\n+                let chunk_byte_len =\n+                    str::byte_len_range(*str, offset, chunk_char_len);\n+                nodes[i] = @leaf({\n+                    byte_offset: offset,\n+                    byte_len:    chunk_byte_len,\n+                    char_len:    chunk_char_len,\n+                    content:     str\n+                });\n+\n+                offset += chunk_byte_len;\n+                i      += 1u;\n+            }\n+\n+            //Then, build a tree from these slices by collapsing them\n+            while leaves > 1u {\n+                i = 0u;\n+                while i < leaves - 1u {//Concat nodes 0 with 1, 2 with 3 etc.\n+                    nodes[i/2u] = concat2(nodes[i], nodes[i + 1u]);\n+                    i += 2u;\n+                }\n+                if i == leaves - 1u {\n+                    //And don't forget the last node if it is in even position\n+                    nodes[i/2u] = nodes[i];\n+                }\n+                leaves = uint::div_ceil(leaves, 2u);\n+            }\n+            ret nodes[0u];\n+        }\n+    }\n+\n+    pure fn byte_len(node: @node) -> uint {\n+        alt(*node) {//TODO: Could we do this without the pattern-matching?\n+          leaf(y)  { ret y.byte_len; }\n+          concat(y){ ret y.byte_len; }\n+        }\n+    }\n+\n+    pure fn char_len(node: @node) -> uint {\n+        alt(*node) {\n+          leaf(y)   { ret y.char_len; }\n+          concat(y) { ret y.char_len; }\n+        }\n+    }\n+\n+\n+    fn tree_from_forest_destructive(forest: [mutable @node]) -> @node {\n+        let i = 0u;\n+        let len = vec::len(forest);\n+        while len > 1u {\n+            i = 0u;\n+            while i < len - 1u {//Concat nodes 0 with 1, 2 with 3 etc.\n+                let left  = forest[i];\n+                let right = forest[i+1u];\n+                let left_len = char_len(left);\n+                let right_len= char_len(right);\n+                let left_height= height(left);\n+                let right_height=height(right);\n+                if left_len + right_len > hint_max_leaf_char_len\n+                    //TODO: Improve strategy\n+                    || left_height  >= hint_max_node_height\n+                    || right_height >= hint_max_node_height {\n+                    if left_len <= hint_max_leaf_char_len {\n+                        left = flatten(left);\n+                    }\n+                    if right_len <= hint_max_leaf_char_len {\n+                        right = flatten(right);\n+                    }\n+                }\n+                forest[i/2u] = concat2(left, right);\n+                i += 2u;\n+            }\n+            if i == len - 1u {\n+                //And don't forget the last node if it is in even position\n+                forest[i/2u] = forest[i];\n+            }\n+            len = uint::div_ceil(len, 2u);\n+        }\n+        ret forest[0];\n+    }\n+\n+    fn serialize_node(node: @node) -> str unsafe {\n+        let buf = vec::init_elt_mut(0u8, byte_len(node));\n+        let offset = 0u;//Current position in the buffer\n+        let it = leaf_iterator::start(node);\n+        while true {\n+            alt(leaf_iterator::next(it)) {\n+              option::none. { break; }\n+              option::some(x) {\n+                //TODO: Replace with memcpy or something similar\n+                let local_buf: [u8] = unsafe::reinterpret_cast(*x.content);\n+                let i = x.byte_offset;\n+                while i < x.byte_len {\n+                    buf[offset] = local_buf[i];\n+                    offset += 1u;\n+                    i      += 1u;\n+                }\n+                unsafe::leak(local_buf);\n+              }\n+            }\n+        }\n+        let str : str = unsafe::reinterpret_cast(buf);\n+        unsafe::leak(buf);//TODO: Check if this is correct\n+        ret str;\n+    }\n+\n+    /*\n+    Replace a subtree by a single leaf with the same contents.\n+     */\n+    fn flatten(node: @node) -> @node unsafe {\n+        alt(*node) {\n+          leaf(_) { ret node }\n+          concat(x) {\n+            ret @leaf({\n+                byte_offset: 0u,\n+                byte_len:    x.byte_len,\n+                char_len:    x.char_len,\n+                content:     @serialize_node(node)\n+            })\n+          }\n+        }\n+    }\n+\n+    fn bal(node: @node) -> option::t<@node> {\n+        if height(node) < hint_max_node_height { ret option::none }\n+        else {\n+            //1. Gather all leaves as a forest\n+            let forest = [mutable];\n+            let it = leaf_iterator::start(node);\n+            while true {\n+                alt (leaf_iterator::next(it)) {\n+                  option::none.   { break; }\n+                  option::some(x) { forest += [mutable @leaf(x)]; }\n+                }\n+            }\n+            //2. Rebuild tree from forest\n+            let root = @*tree_from_forest_destructive(forest);\n+            ret option::some(root);\n+        }\n+    }\n+\n+    fn sub_bytes(node: @node, byte_offset: uint, byte_len: uint) -> @node {\n+        let node        = node;\n+        let result      = node;//Arbitrary value\n+        let byte_offset = byte_offset;\n+        let byte_len    = byte_len;\n+        while true {\n+            if byte_offset == 0u && byte_len == node::byte_len(node) {\n+                result = node;\n+                break;\n+            }\n+            alt(*node) {\n+              node::leaf(x) {\n+                let char_len =\n+                    str::char_len_range(*x.content, byte_offset, byte_len);\n+                result = @leaf({byte_offset: byte_offset,\n+                                byte_len:    byte_len,\n+                                char_len:    char_len,\n+                                content:     x.content});\n+                break;\n+              }\n+              node::concat(x) {\n+                let left_len: uint = node::byte_len(x.left);\n+                if byte_offset <= left_len {\n+                    if byte_offset + byte_len <= left_len {\n+                   //Case 1: Everything fits in x.left, tail-call\n+                        node = x.left;\n+                    } else {\n+                        //Case 2: A (non-empty, possibly full) suffix\n+                        //of x.left and a (non-empty, possibly full) prefix\n+                        //of x.right\n+                        let left_result  =\n+                            sub_bytes(x.left, byte_offset, left_len);\n+                        let right_result =\n+                            sub_bytes(x.right, 0u, left_len - byte_offset);\n+                        result = concat2(left_result, right_result);\n+                        break;\n+                    }\n+                } else {\n+                    //Case 3: Everything fits in x.right\n+                    byte_offset -= left_len;\n+                    node = x.right;\n+                }\n+              }\n+            }\n+        }\n+        ret result;\n+    }\n+\n+    fn sub_chars(node: @node, char_offset: uint, char_len: uint) -> @node {\n+        alt(*node) {\n+          node::leaf(x) {\n+            if char_offset == 0u && char_len == x.char_len {\n+                ret node;\n+            }\n+            let byte_offset =\n+                str::byte_len_range(*x.content, 0u, char_offset);\n+            let byte_len    =\n+                str::byte_len_range(*x.content, byte_offset, char_len);\n+            ret @leaf({byte_offset: byte_offset,\n+                 byte_len:    byte_len,\n+                 char_len:    char_len,\n+                 content:     x.content});\n+          }\n+          node::concat(x) {\n+            if char_offset == 0u && char_len == x.char_len {ret node;}\n+            let left_len : uint = node::char_len(x.left);\n+            if char_offset <= left_len {\n+                if char_offset + char_len <= left_len {\n+                    //Case 1: Everything fits in x.left\n+                    ret sub_chars(x.left, char_offset, char_len);\n+                    //TODO: Optimize manually this tail call?\n+                } else {\n+                    //Case 2: A (non-empty, possibly full) suffix\n+                    //of x.left and a (non-empty, possibly full) prefix\n+                    //of x.right\n+                    let left_result  =\n+                        sub_chars(x.left, char_offset, left_len);\n+                    let right_result =\n+                        sub_chars(x.right, 0u, left_len - char_offset);\n+                    ret concat2(left_result, right_result)\n+                }\n+            } else {\n+                //Case 3: Everything fits in x.right\n+                ret sub_chars(x.right, char_offset - left_len, char_len);\n+                //TODO: Optimize manually this tail call?\n+            }\n+          }\n+        }\n+    }\n+\n+    fn concat2(left: @node, right: @node) -> @node {\n+        ret @concat({left    : left,\n+                     right   : right,\n+             char_len: char_len(left) + char_len(right),\n+                     byte_len: byte_len(left) + byte_len(right),\n+             height: math::max(height(left), height(right)) + 1u\n+                    })\n+    }\n+\n+    fn height(node: @node) -> uint {\n+        alt(*node) {\n+          leaf(_)   { ret 0u; }\n+          concat(x) { ret x.height; }\n+        }\n+    }\n+\n+    fn cmp(a: @node, b: @node) -> int {\n+        let ita = char_iterator::start(a);\n+        let itb = char_iterator::start(b);\n+        let result = 0;\n+        let pos = 0u;\n+        while result == 0 {\n+            alt((char_iterator::next(ita), char_iterator::next(itb))) {\n+              (option::none., option::none.) {\n+                break;\n+              }\n+              (option::some(chara), option::some(charb)) {\n+                result = char::cmp(chara, charb);\n+              }\n+              (option::some(_), _)         {\n+                result = 1;\n+              }\n+              (_, option::some(_))         {\n+                result = -1;\n+              }\n+            }\n+            pos += 1u;\n+        }\n+        ret result;\n+    }\n+\n+    fn loop_chars(node: @node, it: block(char) -> bool) -> bool {\n+        ret loop_leaves(node, {|leaf|\n+            ret str::loop_chars_sub(*leaf.content,\n+                                    leaf.byte_offset,\n+                                    leaf.byte_len, it)\n+        })\n+    }\n+\n+    fn loop_leaves(node: @node, it: block(leaf) -> bool) -> bool{\n+        let result  = true;\n+        let current = node;\n+        while true {\n+            alt(*current) {\n+              leaf(x) {\n+                result = it(x);\n+                break;\n+              }\n+              concat(x) {\n+                if loop_leaves(x.left, it) { //non tail call\n+                    current = x.right;       //tail call\n+                } else {\n+                    result = false;\n+                    break;\n+                }\n+              }\n+            }\n+        }\n+        ret result;\n+    }\n+\n+   fn char_at(node: @node, pos: uint) -> char {\n+       let node    = node;\n+       let pos     = pos;\n+       let result  = '0';\n+       while true {\n+           alt(*node) {\n+             leaf(x) {\n+               result = str::char_at(*x.content, pos);\n+               break;\n+             }\n+             concat({left: left,\n+                     right: right,\n+                     char_len: _,\n+                     byte_len: _,\n+                     height: _}) {\n+               let left_len = char_len(left);\n+           if left_len > pos {\n+                   node = left;\n+           } else {\n+                   node = right;\n+                   pos  = pos - left_len;\n+           }\n+             }\n+           }\n+       };\n+       ret result;\n+   }\n+\n+    mod leaf_iterator {\n+        type t = {\n+            stack:            [mutable @node],\n+            mutable stackpos: int\n+        };\n+\n+        fn empty() -> t {\n+            let stack : [mutable @node] = [mutable];\n+            ret {stack: stack, mutable stackpos: -1}\n+        }\n+\n+        fn start(node: @node) -> t {\n+            let stack = vec::init_elt_mut(node, height(node)+1u);\n+            ret {\n+                stack:             stack,\n+                mutable stackpos:  0\n+            }\n+        }\n+\n+        fn next(it: t) -> option::t<leaf> {\n+            if it.stackpos < 0 { ret option::none; }\n+            let result  = option::none;\n+            while true {\n+                let current = it.stack[it.stackpos];\n+                it.stackpos -= 1;\n+                alt(*current) {\n+                  concat(x) {\n+                    it.stackpos += 1;\n+                    it.stack[it.stackpos] = x.right;\n+                    it.stackpos += 1;\n+                    it.stack[it.stackpos] = x.left;\n+                  }\n+                  leaf(x) {\n+                    result    = option::some(x);\n+                    break;\n+                  }\n+                }\n+            }\n+            ret result;\n+        }\n+    }\n+\n+    mod char_iterator {\n+        type t = {\n+            leaf_iterator: leaf_iterator::t,\n+            mutable leaf:  option::t<leaf>,\n+            mutable leaf_byte_pos: uint\n+        };\n+\n+        fn start(node: @node) -> t {\n+            ret {\n+                leaf_iterator: leaf_iterator::start(node),\n+                mutable leaf:          option::none,\n+                mutable leaf_byte_pos: 0u\n+            }\n+        }\n+\n+        fn empty() -> t {\n+            ret {\n+                leaf_iterator: leaf_iterator::empty(),\n+                mutable leaf:  option::none,\n+                mutable leaf_byte_pos: 0u\n+            }\n+        }\n+\n+        fn next(it: t) -> option::t<char> {\n+            let result = option::none;\n+            while true {\n+                alt(get_current_or_next_leaf(it)) {\n+                  option::none. {\n+                    break;\n+                  }\n+                  option::some(leaf) {\n+                    let next_char = get_next_char_in_leaf(it);\n+                    alt(next_char) {\n+                      option::none. {\n+                        cont;\n+                      }\n+                      option::some(_) {\n+                        result = next_char;\n+                        break;\n+                      }\n+                    }\n+                  }\n+                }\n+            }\n+            ret result;\n+        }\n+\n+        fn get_current_or_next_leaf(it: t) -> option::t<leaf> {\n+            alt(it.leaf) {\n+              option::some(_) { ret it.leaf }\n+              option::none. {\n+                let next = leaf_iterator::next(it.leaf_iterator);\n+                alt(next) {\n+                  option::none. { ret option::none }\n+                  option::some(leaf) {\n+                    it.leaf          = next;\n+                    it.leaf_byte_pos = 0u;\n+                    ret next;\n+                  }\n+                }\n+              }\n+            }\n+        }\n+\n+        fn get_next_char_in_leaf(it: t) -> option::t<char> {\n+            alt(it.leaf) {\n+              option::none. { ret option::none }\n+              option::some(leaf) {\n+                if it.leaf_byte_pos >= leaf.byte_len {\n+                    //We are actually past the end of the leaf\n+                    it.leaf = option::none;\n+                    ret option::none\n+                } else {\n+                    let {ch, next} =\n+                        str::char_range_at(*leaf.content,\n+                                     it.leaf_byte_pos + leaf.byte_offset);\n+                    it.leaf_byte_pos = next - leaf.byte_offset;\n+                    ret option::some(ch)\n+                }\n+              }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "6906b7f7f830e8fe947ffc5320197e257fd190a1", "filename": "src/lib/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5dcf66ad3760961244477c610e4478853e13abb/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a5dcf66ad3760961244477c610e4478853e13abb/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=a5dcf66ad3760961244477c610e4478853e13abb", "patch": "@@ -11,6 +11,7 @@ export box, char, float, int, str, ptr, uint, u8, u32, u64, vec;\n export aio, comm, fs, io, net, run, sio, sys, task;\n export ctypes, either, option, result, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n+export rope;\n export ebml, dbg, getopts, math, rand, sha1, term, time, unsafe;\n export extfmt, test;\n // FIXME: generic_os and os_fs shouldn't be exported\n@@ -61,6 +62,7 @@ mod deque;\n mod fun_treemap;\n mod list;\n mod map;\n+mod rope;\n mod smallintmap;\n mod sort;\n mod treemap;"}, {"sha": "18ba19d015117b3bd96c10ace4382c5597d5ac4b", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dcf66ad3760961244477c610e4478853e13abb/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a5dcf66ad3760961244477c610e4478853e13abb/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=a5dcf66ad3760961244477c610e4478853e13abb", "patch": "@@ -33,6 +33,7 @@ mod uint;\n mod float;\n mod math;\n mod result;\n+mod rope;\n \n // Local Variables:\n // mode: rust"}]}