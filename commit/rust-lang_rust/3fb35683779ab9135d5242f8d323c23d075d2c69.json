{"sha": "3fb35683779ab9135d5242f8d323c23d075d2c69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYjM1NjgzNzc5YWI5MTM1ZDUyNDJmOGQzMjNjMjNkMDc1ZDJjNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T09:21:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-02T09:21:39Z"}, "message": "auto merge of #15265 : omasanori/rust/udp, r=alexcrichton\n\nPOSIX has recvfrom(2) and sendto(2), but their name seem not to be suitable with Rust. We already renamed getpeername(2) and getsockname(2), so I think it makes sense.\r\n\r\nAlternatively, `receive_from` would be fine. However, we have `.recv()` so I chose `recv_from`.\r\n\r\nWhat do you think? If this makes sense, should I provide `recvfrom` and `sendto` deprecated methods just calling new methods for compatibility?", "tree": {"sha": "c15a6fb71e06e81f18e9fd990732c970e0aff2a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c15a6fb71e06e81f18e9fd990732c970e0aff2a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fb35683779ab9135d5242f8d323c23d075d2c69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fb35683779ab9135d5242f8d323c23d075d2c69", "html_url": "https://github.com/rust-lang/rust/commit/3fb35683779ab9135d5242f8d323c23d075d2c69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fb35683779ab9135d5242f8d323c23d075d2c69/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c4d8e94ba58713c65f125f721e0d95f7f66c035", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4d8e94ba58713c65f125f721e0d95f7f66c035", "html_url": "https://github.com/rust-lang/rust/commit/7c4d8e94ba58713c65f125f721e0d95f7f66c035"}, {"sha": "55f5a1ef59849709a012fcd7e2f89e7ccc42b159", "url": "https://api.github.com/repos/rust-lang/rust/commits/55f5a1ef59849709a012fcd7e2f89e7ccc42b159", "html_url": "https://github.com/rust-lang/rust/commit/55f5a1ef59849709a012fcd7e2f89e7ccc42b159"}], "stats": {"total": 123, "additions": 68, "deletions": 55}, "files": [{"sha": "dfc2c55cde7cb511bb79303ed6942d7b69f1572f", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=3fb35683779ab9135d5242f8d323c23d075d2c69", "patch": "@@ -630,7 +630,7 @@ impl rtio::RtioSocket for UdpSocket {\n #[cfg(unix)]    type msglen_t = libc::size_t;\n \n impl rtio::RtioUdpSocket for UdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n+    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, rtio::SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -652,7 +652,7 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         })\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n+    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> IoResult<()> {\n         let (dst, dstlen) = addr_to_sockaddr(dst);\n         let dstp = &dst as *const _ as *const libc::sockaddr;\n         let dstlen = dstlen as libc::socklen_t;"}, {"sha": "0205f2405f9ce8e1345f214a103e39fad5cde3b3", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=3fb35683779ab9135d5242f8d323c23d075d2c69", "patch": "@@ -269,8 +269,8 @@ pub trait RtioSocket {\n }\n \n pub trait RtioUdpSocket : RtioSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)>;\n-    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()>;\n+    fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)>;\n+    fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()>;\n \n     fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()>;\n     fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()>;"}, {"sha": "91614763ce52f4ed669fe0a7c25dd367ef0f2451", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=3fb35683779ab9135d5242f8d323c23d075d2c69", "patch": "@@ -197,13 +197,13 @@ mod test {\n             let listener = UdpWatcher::bind(local_loop(), addr2);\n             tx.send((listener.unwrap(), addr1));\n             let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n-            listener.sendto([1, 2, 3, 4], addr2).ok().unwrap();\n+            listener.send_to([1, 2, 3, 4], addr2).ok().unwrap();\n         });\n \n         let task = pool.task(TaskOpts::new(), proc() {\n             let (mut watcher, addr) = rx.recv();\n             let mut buf = [0, ..10];\n-            assert!(watcher.recvfrom(buf).ok().unwrap() == (4, addr));\n+            assert!(watcher.recv_from(buf).ok().unwrap() == (4, addr));\n         });\n         pool.spawn_sched().send(sched::TaskFromFriend(task));\n "}, {"sha": "ddcaeccbc190f9927235259a31b0f3fddba16032", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=3fb35683779ab9135d5242f8d323c23d075d2c69", "patch": "@@ -540,7 +540,7 @@ impl rtio::RtioSocket for UdpWatcher {\n }\n \n impl rtio::RtioUdpSocket for UdpWatcher {\n-    fn recvfrom(&mut self, buf: &mut [u8])\n+    fn recv_from(&mut self, buf: &mut [u8])\n         -> Result<(uint, rtio::SocketAddr), IoError>\n     {\n         let loop_ = self.uv_loop();\n@@ -607,7 +607,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> Result<(), IoError> {\n+    fn send_to(&mut self, buf: &[u8], dst: rtio::SocketAddr) -> Result<(), IoError> {\n         let m = self.fire_homing_missile();\n         let loop_ = self.uv_loop();\n         let guard = try!(self.write_access.grant(m));\n@@ -960,7 +960,7 @@ mod test {\n                 Ok(mut w) => {\n                     tx.send(());\n                     let mut buf = [0u8, ..10];\n-                    match w.recvfrom(buf) {\n+                    match w.recv_from(buf) {\n                         Ok((10, addr)) => assert!(addr == client),\n                         e => fail!(\"{:?}\", e),\n                     }\n@@ -976,7 +976,7 @@ mod test {\n         let mut w = match UdpWatcher::bind(local_loop(), client) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n-        match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n+        match w.send_to([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n             Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n         }\n     }\n@@ -992,7 +992,7 @@ mod test {\n                 Ok(mut w) => {\n                     tx.send(());\n                     let mut buf = [0u8, ..10];\n-                    match w.recvfrom(buf) {\n+                    match w.recv_from(buf) {\n                         Ok((10, addr)) => assert!(addr == client),\n                         e => fail!(\"{:?}\", e),\n                     }\n@@ -1008,7 +1008,7 @@ mod test {\n         let mut w = match UdpWatcher::bind(local_loop(), client) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n-        match w.sendto([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n+        match w.send_to([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], server) {\n             Ok(()) => {}, Err(e) => fail!(\"{:?}\", e)\n         }\n     }\n@@ -1057,16 +1057,16 @@ mod test {\n         spawn(proc() {\n             let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n             rx.recv();\n-            assert!(client.sendto([1], server_addr).is_ok());\n-            assert!(client.sendto([2], server_addr).is_ok());\n+            assert!(client.send_to([1], server_addr).is_ok());\n+            assert!(client.send_to([2], server_addr).is_ok());\n         });\n \n         let mut server = UdpWatcher::bind(local_loop(), server_addr).unwrap();\n         tx.send(());\n         let mut buf1 = [0];\n         let mut buf2 = [0];\n-        let (nread1, src1) = server.recvfrom(buf1).ok().unwrap();\n-        let (nread2, src2) = server.recvfrom(buf2).ok().unwrap();\n+        let (nread1, src1) = server.recv_from(buf1).ok().unwrap();\n+        let (nread2, src2) = server.recv_from(buf2).ok().unwrap();\n         assert_eq!(nread1, 1);\n         assert_eq!(nread2, 1);\n         assert!(src1 == client_addr);\n@@ -1098,10 +1098,10 @@ mod test {\n             let mut buf = [1];\n             while buf[0] == 1 {\n                 // send more data\n-                assert!(server_out.sendto(msg, client_in_addr).is_ok());\n+                assert!(server_out.send_to(msg, client_in_addr).is_ok());\n                 total_bytes_sent += msg.len();\n                 // check if the client has received enough\n-                let res = server_in.recvfrom(buf);\n+                let res = server_in.recv_from(buf);\n                 assert!(res.is_ok());\n                 let (nread, src) = res.ok().unwrap();\n                 assert_eq!(nread, 1);\n@@ -1120,9 +1120,9 @@ mod test {\n         let mut buf = [0, .. 2048];\n         while total_bytes_recv < MAX {\n             // ask for more\n-            assert!(client_out.sendto([1], server_in_addr).is_ok());\n+            assert!(client_out.send_to([1], server_in_addr).is_ok());\n             // wait for data\n-            let res = client_in.recvfrom(buf);\n+            let res = client_in.recv_from(buf);\n             assert!(res.is_ok());\n             let (nread, src) = res.ok().unwrap();\n             assert!(src == server_out_addr);\n@@ -1132,7 +1132,7 @@ mod test {\n             }\n         }\n         // tell the server we're done\n-        assert!(client_out.sendto([0], server_in_addr).is_ok());\n+        assert!(client_out.send_to([0], server_in_addr).is_ok());\n     }\n \n     #[test]"}, {"sha": "cd78898d46bb82c22c73b54f39f8d3a3bfc3e516", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 47, "deletions": 34, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fb35683779ab9135d5242f8d323c23d075d2c69/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=3fb35683779ab9135d5242f8d323c23d075d2c69", "patch": "@@ -45,12 +45,12 @@ use rt::rtio;\n /// };\n ///\n /// let mut buf = [0, ..10];\n-/// match socket.recvfrom(buf) {\n+/// match socket.recv_from(buf) {\n ///     Ok((amt, src)) => {\n ///         // Send a reply to the socket we received data from\n ///         let buf = buf.mut_slice_to(amt);\n ///         buf.reverse();\n-///         socket.sendto(buf, src);\n+///         socket.send_to(buf, src);\n ///     }\n ///     Err(e) => println!(\"couldn't receive a datagram: {}\", e)\n /// }\n@@ -72,25 +72,38 @@ impl UdpSocket {\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n-    pub fn recvfrom(&mut self, buf: &mut [u8])\n+    pub fn recv_from(&mut self, buf: &mut [u8])\n                     -> IoResult<(uint, SocketAddr)> {\n-        match self.obj.recvfrom(buf) {\n+        match self.obj.recv_from(buf) {\n             Ok((amt, rtio::SocketAddr { ip, port })) => {\n                 Ok((amt, SocketAddr { ip: super::from_rtio(ip), port: port }))\n             }\n             Err(e) => Err(IoError::from_rtio_error(e)),\n         }\n     }\n \n+    #[allow(missing_doc)]\n+    #[deprecated = \"renamed to `recv_from`\"]\n+    pub fn recvfrom(&mut self, buf: &mut [u8])\n+                    -> IoResult<(uint, SocketAddr)> {\n+        self.recv_from(buf)\n+    }\n+\n     /// Sends data on the socket to the given address. Returns nothing on\n     /// success.\n-    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        self.obj.sendto(buf, rtio::SocketAddr {\n+    pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n+        self.obj.send_to(buf, rtio::SocketAddr {\n             ip: super::to_rtio(dst.ip),\n             port: dst.port,\n         }).map_err(IoError::from_rtio_error)\n     }\n \n+    #[allow(missing_doc)]\n+    #[deprecated = \"renamed to `send_to`\"]\n+    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n+        self.send_to(buf, dst)\n+    }\n+\n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n     /// traits to receive and send data from the same address. This transfers\n     /// ownership of the socket to the stream.\n@@ -225,7 +238,7 @@ impl Reader for UdpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let peer = self.connected_to;\n         self.as_socket(|sock| {\n-            match sock.recvfrom(buf) {\n+            match sock.recv_from(buf) {\n                 Ok((_nread, src)) if src != peer => Ok(0),\n                 Ok((nread, _src)) => Ok(nread),\n                 Err(e) => Err(e),\n@@ -237,7 +250,7 @@ impl Reader for UdpStream {\n impl Writer for UdpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let connected_to = self.connected_to;\n-        self.as_socket(|sock| sock.sendto(buf, connected_to))\n+        self.as_socket(|sock| sock.send_to(buf, connected_to))\n     }\n }\n \n@@ -266,7 +279,7 @@ mod test {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx1.recv();\n-                    client.sendto([99], server_ip).unwrap()\n+                    client.send_to([99], server_ip).unwrap()\n                 }\n                 Err(..) => fail!()\n             }\n@@ -277,7 +290,7 @@ mod test {\n             Ok(ref mut server) => {\n                 tx1.send(());\n                 let mut buf = [0];\n-                match server.recvfrom(buf) {\n+                match server.recv_from(buf) {\n                     Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n@@ -300,7 +313,7 @@ mod test {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx.recv();\n-                    client.sendto([99], server_ip).unwrap()\n+                    client.send_to([99], server_ip).unwrap()\n                 }\n                 Err(..) => fail!()\n             }\n@@ -310,7 +323,7 @@ mod test {\n             Ok(ref mut server) => {\n                 tx.send(());\n                 let mut buf = [0];\n-                match server.recvfrom(buf) {\n+                match server.recv_from(buf) {\n                     Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n@@ -429,9 +442,9 @@ mod test {\n         spawn(proc() {\n             let mut sock2 = sock2;\n             let mut buf = [0, 0];\n-            assert_eq!(sock2.recvfrom(buf), Ok((1, addr1)));\n+            assert_eq!(sock2.recv_from(buf), Ok((1, addr1)));\n             assert_eq!(buf[0], 1);\n-            sock2.sendto([2], addr1).unwrap();\n+            sock2.send_to([2], addr1).unwrap();\n         });\n \n         let sock3 = sock1.clone();\n@@ -441,12 +454,12 @@ mod test {\n         spawn(proc() {\n             let mut sock3 = sock3;\n             rx1.recv();\n-            sock3.sendto([1], addr2).unwrap();\n+            sock3.send_to([1], addr2).unwrap();\n             tx2.send(());\n         });\n         tx1.send(());\n         let mut buf = [0, 0];\n-        assert_eq!(sock1.recvfrom(buf), Ok((1, addr2)));\n+        assert_eq!(sock1.recv_from(buf), Ok((1, addr2)));\n         rx2.recv();\n     })\n \n@@ -460,9 +473,9 @@ mod test {\n \n         spawn(proc() {\n             let mut sock2 = sock2;\n-            sock2.sendto([1], addr1).unwrap();\n+            sock2.send_to([1], addr1).unwrap();\n             rx.recv();\n-            sock2.sendto([2], addr1).unwrap();\n+            sock2.send_to([2], addr1).unwrap();\n             rx.recv();\n         });\n \n@@ -472,12 +485,12 @@ mod test {\n         spawn(proc() {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n-            sock3.recvfrom(buf).unwrap();\n+            sock3.recv_from(buf).unwrap();\n             tx2.send(());\n             done.send(());\n         });\n         let mut buf = [0, 0];\n-        sock1.recvfrom(buf).unwrap();\n+        sock1.recv_from(buf).unwrap();\n         tx1.send(());\n \n         rx.recv();\n@@ -497,7 +510,7 @@ mod test {\n             let mut buf = [0, 1];\n \n             rx.recv();\n-            match sock2.recvfrom(buf) {\n+            match sock2.recv_from(buf) {\n                 Ok(..) => {}\n                 Err(e) => fail!(\"failed receive: {}\", e),\n             }\n@@ -510,13 +523,13 @@ mod test {\n         let tx2 = tx.clone();\n         spawn(proc() {\n             let mut sock3 = sock3;\n-            match sock3.sendto([1], addr2) {\n+            match sock3.send_to([1], addr2) {\n                 Ok(..) => { let _ = tx2.send_opt(()); }\n                 Err(..) => {}\n             }\n             done.send(());\n         });\n-        match sock1.sendto([2], addr2) {\n+        match sock1.send_to([2], addr2) {\n             Ok(..) => { let _ = tx.send_opt(()); }\n             Err(..) => {}\n         }\n@@ -526,7 +539,7 @@ mod test {\n         serv_rx.recv();\n     })\n \n-    iotest!(fn recvfrom_timeout() {\n+    iotest!(fn recv_from_timeout() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut a = UdpSocket::bind(addr1).unwrap();\n@@ -535,42 +548,42 @@ mod test {\n         let (tx2, rx2) = channel();\n         spawn(proc() {\n             let mut a = UdpSocket::bind(addr2).unwrap();\n-            assert_eq!(a.recvfrom([0]), Ok((1, addr1)));\n-            assert_eq!(a.sendto([0], addr1), Ok(()));\n+            assert_eq!(a.recv_from([0]), Ok((1, addr1)));\n+            assert_eq!(a.send_to([0], addr1), Ok(()));\n             rx.recv();\n-            assert_eq!(a.sendto([0], addr1), Ok(()));\n+            assert_eq!(a.send_to([0], addr1), Ok(()));\n \n             tx2.send(());\n         });\n \n         // Make sure that reads time out, but writes can continue\n         a.set_read_timeout(Some(20));\n-        assert_eq!(a.recvfrom([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.recvfrom([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.sendto([0], addr2), Ok(()));\n+        assert_eq!(a.recv_from([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.recv_from([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.send_to([0], addr2), Ok(()));\n \n         // Cloned handles should be able to block\n         let mut a2 = a.clone();\n-        assert_eq!(a2.recvfrom([0]), Ok((1, addr2)));\n+        assert_eq!(a2.recv_from([0]), Ok((1, addr2)));\n \n         // Clearing the timeout should allow for receiving\n         a.set_timeout(None);\n         tx.send(());\n-        assert_eq!(a2.recvfrom([0]), Ok((1, addr2)));\n+        assert_eq!(a2.recv_from([0]), Ok((1, addr2)));\n \n         // Make sure the child didn't die\n         rx2.recv();\n     })\n \n-    iotest!(fn sendto_timeout() {\n+    iotest!(fn send_to_timeout() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut a = UdpSocket::bind(addr1).unwrap();\n         let _b = UdpSocket::bind(addr2).unwrap();\n \n         a.set_write_timeout(Some(1000));\n         for _ in range(0u, 100) {\n-            match a.sendto([0, ..4*1024], addr2) {\n+            match a.send_to([0, ..4*1024], addr2) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n                 Err(e) => fail!(\"other error: {}\", e),"}]}