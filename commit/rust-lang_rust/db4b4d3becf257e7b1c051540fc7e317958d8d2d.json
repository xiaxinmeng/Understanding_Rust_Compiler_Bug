{"sha": "db4b4d3becf257e7b1c051540fc7e317958d8d2d", "node_id": "C_kwDOAAsO6NoAKGRiNGI0ZDNiZWNmMjU3ZTdiMWMwNTE1NDBmYzdlMzE3OTU4ZDhkMmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-21T17:17:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-21T17:17:25Z"}, "message": "Auto merge of #102097 - Dylan-DPC:rollup-gc75oh4, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #89891 (`alloc`: add unstable cfg features `no_rc` and `no_sync`)\n - #101995 (Add another example for `uN::carrying_mul`)\n - #102031 (Adding ignore fuchsia tests for Backtrace, ErrorKind cases)\n - #102041 (Improve `-Zmeta-stats` some more)\n - #102045 (fix ConstProp handling of written_only_inside_own_block_locals)\n - #102058 (Clarify Path::extension() semantics in docs abstract)\n - #102059 (Use rebind instead of dummy binder in `SameTypeModuloInfer` relation)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e6f8cb29b3451534219932f7d7dbd1d1c035ee1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6f8cb29b3451534219932f7d7dbd1d1c035ee1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db4b4d3becf257e7b1c051540fc7e317958d8d2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db4b4d3becf257e7b1c051540fc7e317958d8d2d", "html_url": "https://github.com/rust-lang/rust/commit/db4b4d3becf257e7b1c051540fc7e317958d8d2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db4b4d3becf257e7b1c051540fc7e317958d8d2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b79b7d8b4e0f2b112142a9ce1fea335f321a6558", "url": "https://api.github.com/repos/rust-lang/rust/commits/b79b7d8b4e0f2b112142a9ce1fea335f321a6558", "html_url": "https://github.com/rust-lang/rust/commit/b79b7d8b4e0f2b112142a9ce1fea335f321a6558"}, {"sha": "39bb2a79884b9e4813e2875de0910790d968f6c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/39bb2a79884b9e4813e2875de0910790d968f6c1", "html_url": "https://github.com/rust-lang/rust/commit/39bb2a79884b9e4813e2875de0910790d968f6c1"}], "stats": {"total": 633, "additions": 391, "deletions": 242}, "files": [{"sha": "18255a5089c8d6544d48276610c9120c7a8c9f50", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -2765,7 +2765,7 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n     where\n         T: relate::Relate<'tcx>,\n     {\n-        Ok(ty::Binder::dummy(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n     fn consts("}, {"sha": "67c28461ce5cf338c75373d64c430a3709c0a388", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 152, "deletions": 213, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -28,6 +28,7 @@ use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n+use rustc_middle::util::common::to_readable_str;\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n@@ -261,10 +262,10 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         // This allows us to avoid loading the dependencies of proc-macro crates: all of\n         // the information we need to decode `Span`s is stored in the proc-macro crate.\n         let (tag, metadata_index) = if source_file.is_imported() && !s.is_proc_macro {\n-            // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n-            // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n-            // are relative to the source map information for the 'foreign' crate whose CrateNum\n-            // we write into the metadata. This allows `imported_source_files` to binary\n+            // To simplify deserialization, we 'rebase' this span onto the crate it originally came\n+            // from (the crate that 'owns' the file it references. These rebased 'lo' and 'hi'\n+            // values are relative to the source map information for the 'foreign' crate whose\n+            // CrateNum we write into the metadata. This allows `imported_source_files` to binary\n             // search through the 'foreign' crate's source map information, using the\n             // deserialized 'lo' and 'hi' values directly.\n             //\n@@ -554,78 +555,56 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_crate_root(&mut self) -> LazyValue<CrateRoot> {\n         let tcx = self.tcx;\n-        let mut i = 0;\n-        let preamble_bytes = self.position() - i;\n-\n-        // Encode the crate deps\n-        i = self.position();\n-        let crate_deps = self.encode_crate_deps();\n-        let dylib_dependency_formats = self.encode_dylib_dependency_formats();\n-        let dep_bytes = self.position() - i;\n-\n-        // Encode the lib features.\n-        i = self.position();\n-        let lib_features = self.encode_lib_features();\n-        let lib_feature_bytes = self.position() - i;\n-\n-        // Encode the stability implications.\n-        i = self.position();\n-        let stability_implications = self.encode_stability_implications();\n-        let stability_implications_bytes = self.position() - i;\n-\n-        // Encode the language items.\n-        i = self.position();\n-        let lang_items = self.encode_lang_items();\n-        let lang_items_missing = self.encode_lang_items_missing();\n-        let lang_item_bytes = self.position() - i;\n-\n-        // Encode the diagnostic items.\n-        i = self.position();\n-        let diagnostic_items = self.encode_diagnostic_items();\n-        let diagnostic_item_bytes = self.position() - i;\n-\n-        // Encode the native libraries used\n-        i = self.position();\n-        let native_libraries = self.encode_native_libraries();\n-        let native_lib_bytes = self.position() - i;\n-\n-        i = self.position();\n-        let foreign_modules = self.encode_foreign_modules();\n-        let foreign_modules_bytes = self.position() - i;\n-\n-        // Encode DefPathTable\n-        i = self.position();\n-        self.encode_def_path_table();\n-        let def_path_table_bytes = self.position() - i;\n+        let mut stats: Vec<(&'static str, usize)> = Vec::with_capacity(32);\n+\n+        macro_rules! stat {\n+            ($label:literal, $f:expr) => {{\n+                let orig_pos = self.position();\n+                let res = $f();\n+                stats.push(($label, self.position() - orig_pos));\n+                res\n+            }};\n+        }\n+\n+        // We have already encoded some things. Get their combined size from the current position.\n+        stats.push((\"preamble\", self.position()));\n+\n+        let (crate_deps, dylib_dependency_formats) =\n+            stat!(\"dep\", || (self.encode_crate_deps(), self.encode_dylib_dependency_formats()));\n+\n+        let lib_features = stat!(\"lib-features\", || self.encode_lib_features());\n+\n+        let stability_implications =\n+            stat!(\"stability-implications\", || self.encode_stability_implications());\n+\n+        let (lang_items, lang_items_missing) = stat!(\"lang-items\", || {\n+            (self.encode_lang_items(), self.encode_lang_items_missing())\n+        });\n+\n+        let diagnostic_items = stat!(\"diagnostic-items\", || self.encode_diagnostic_items());\n+\n+        let native_libraries = stat!(\"native-libs\", || self.encode_native_libraries());\n+\n+        let foreign_modules = stat!(\"foreign-modules\", || self.encode_foreign_modules());\n+\n+        _ = stat!(\"def-path-table\", || self.encode_def_path_table());\n \n         // Encode the def IDs of traits, for rustdoc and diagnostics.\n-        i = self.position();\n-        let traits = self.encode_traits();\n-        let traits_bytes = self.position() - i;\n+        let traits = stat!(\"traits\", || self.encode_traits());\n \n         // Encode the def IDs of impls, for coherence checking.\n-        i = self.position();\n-        let impls = self.encode_impls();\n-        let impls_bytes = self.position() - i;\n-\n-        i = self.position();\n-        let incoherent_impls = self.encode_incoherent_impls();\n-        let incoherent_impls_bytes = self.position() - i;\n-\n-        // Encode MIR.\n-        i = self.position();\n-        self.encode_mir();\n-        let mir_bytes = self.position() - i;\n-\n-        // Encode the items.\n-        i = self.position();\n-        self.encode_def_ids();\n-        self.encode_info_for_items();\n-        let item_bytes = self.position() - i;\n-\n-        // Encode the allocation index\n-        i = self.position();\n-        let interpret_alloc_index = {\n+        let impls = stat!(\"impls\", || self.encode_impls());\n+\n+        let incoherent_impls = stat!(\"incoherent-impls\", || self.encode_incoherent_impls());\n+\n+        _ = stat!(\"mir\", || self.encode_mir());\n+\n+        _ = stat!(\"items\", || {\n+            self.encode_def_ids();\n+            self.encode_info_for_items();\n+        });\n+\n+        let interpret_alloc_index = stat!(\"interpret-alloc-index\", || {\n             let mut interpret_alloc_index = Vec::new();\n             let mut n = 0;\n             trace!(\"beginning to encode alloc ids\");\n@@ -646,126 +625,90 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 n = new_n;\n             }\n             self.lazy_array(interpret_alloc_index)\n-        };\n-        let interpret_alloc_index_bytes = self.position() - i;\n+        });\n \n-        // Encode the proc macro data. This affects 'tables',\n-        // so we need to do this before we encode the tables.\n-        // This overwrites def_keys, so it must happen after encode_def_path_table.\n-        i = self.position();\n-        let proc_macro_data = self.encode_proc_macros();\n-        let proc_macro_data_bytes = self.position() - i;\n+        // Encode the proc macro data. This affects `tables`, so we need to do this before we\n+        // encode the tables. This overwrites def_keys, so it must happen after\n+        // encode_def_path_table.\n+        let proc_macro_data = stat!(\"proc-macro-data\", || self.encode_proc_macros());\n \n-        i = self.position();\n-        let tables = self.tables.encode(&mut self.opaque);\n-        let tables_bytes = self.position() - i;\n+        let tables = stat!(\"tables\", || self.tables.encode(&mut self.opaque));\n \n-        i = self.position();\n-        let debugger_visualizers = self.encode_debugger_visualizers();\n-        let debugger_visualizers_bytes = self.position() - i;\n+        let debugger_visualizers =\n+            stat!(\"debugger-visualizers\", || self.encode_debugger_visualizers());\n \n         // Encode exported symbols info. This is prefetched in `encode_metadata` so we encode\n         // this as late as possible to give the prefetching as much time as possible to complete.\n-        i = self.position();\n-        let exported_symbols = tcx.exported_symbols(LOCAL_CRATE);\n-        let exported_symbols = self.encode_exported_symbols(&exported_symbols);\n-        let exported_symbols_bytes = self.position() - i;\n-\n-        // Encode the hygiene data,\n-        // IMPORTANT: this *must* be the last thing that we encode (other than `SourceMap`). The process\n-        // of encoding other items (e.g. `optimized_mir`) may cause us to load\n-        // data from the incremental cache. If this causes us to deserialize a `Span`,\n-        // then we may load additional `SyntaxContext`s into the global `HygieneData`.\n-        // Therefore, we need to encode the hygiene data last to ensure that we encode\n-        // any `SyntaxContext`s that might be used.\n-        i = self.position();\n-        let (syntax_contexts, expn_data, expn_hashes) = self.encode_hygiene();\n-        let hygiene_bytes = self.position() - i;\n-\n-        i = self.position();\n-        let def_path_hash_map = self.encode_def_path_hash_map();\n-        let def_path_hash_map_bytes = self.position() - i;\n-\n-        // Encode source_map. This needs to be done last,\n-        // since encoding `Span`s tells us which `SourceFiles` we actually\n-        // need to encode.\n-        i = self.position();\n-        let source_map = self.encode_source_map();\n-        let source_map_bytes = self.position() - i;\n-\n-        i = self.position();\n-        let attrs = tcx.hir().krate_attrs();\n-        let has_default_lib_allocator = tcx.sess.contains_name(&attrs, sym::default_lib_allocator);\n-        let root = self.lazy(CrateRoot {\n-            name: tcx.crate_name(LOCAL_CRATE),\n-            extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n-            triple: tcx.sess.opts.target_triple.clone(),\n-            hash: tcx.crate_hash(LOCAL_CRATE),\n-            stable_crate_id: tcx.def_path_hash(LOCAL_CRATE.as_def_id()).stable_crate_id(),\n-            required_panic_strategy: tcx.required_panic_strategy(LOCAL_CRATE),\n-            panic_in_drop_strategy: tcx.sess.opts.unstable_opts.panic_in_drop,\n-            edition: tcx.sess.edition(),\n-            has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n-            has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n-            has_default_lib_allocator,\n-            proc_macro_data,\n-            debugger_visualizers,\n-            compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n-            needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n-            needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n-            no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n-            panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n-            profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n-            symbol_mangling_version: tcx.sess.opts.get_symbol_mangling_version(),\n-\n-            crate_deps,\n-            dylib_dependency_formats,\n-            lib_features,\n-            stability_implications,\n-            lang_items,\n-            diagnostic_items,\n-            lang_items_missing,\n-            native_libraries,\n-            foreign_modules,\n-            source_map,\n-            traits,\n-            impls,\n-            incoherent_impls,\n-            exported_symbols,\n-            interpret_alloc_index,\n-            tables,\n-            syntax_contexts,\n-            expn_data,\n-            expn_hashes,\n-            def_path_hash_map,\n+        let exported_symbols = stat!(\"exported-symbols\", || {\n+            self.encode_exported_symbols(&tcx.exported_symbols(LOCAL_CRATE))\n+        });\n+\n+        // Encode the hygiene data.\n+        // IMPORTANT: this *must* be the last thing that we encode (other than `SourceMap`). The\n+        // process of encoding other items (e.g. `optimized_mir`) may cause us to load data from\n+        // the incremental cache. If this causes us to deserialize a `Span`, then we may load\n+        // additional `SyntaxContext`s into the global `HygieneData`. Therefore, we need to encode\n+        // the hygiene data last to ensure that we encode any `SyntaxContext`s that might be used.\n+        let (syntax_contexts, expn_data, expn_hashes) = stat!(\"hygiene\", || self.encode_hygiene());\n+\n+        let def_path_hash_map = stat!(\"def-path-hash-map\", || self.encode_def_path_hash_map());\n+\n+        // Encode source_map. This needs to be done last, because encoding `Span`s tells us which\n+        // `SourceFiles` we actually need to encode.\n+        let source_map = stat!(\"source-map\", || self.encode_source_map());\n+\n+        let root = stat!(\"final\", || {\n+            let attrs = tcx.hir().krate_attrs();\n+            self.lazy(CrateRoot {\n+                name: tcx.crate_name(LOCAL_CRATE),\n+                extra_filename: tcx.sess.opts.cg.extra_filename.clone(),\n+                triple: tcx.sess.opts.target_triple.clone(),\n+                hash: tcx.crate_hash(LOCAL_CRATE),\n+                stable_crate_id: tcx.def_path_hash(LOCAL_CRATE.as_def_id()).stable_crate_id(),\n+                required_panic_strategy: tcx.required_panic_strategy(LOCAL_CRATE),\n+                panic_in_drop_strategy: tcx.sess.opts.unstable_opts.panic_in_drop,\n+                edition: tcx.sess.edition(),\n+                has_global_allocator: tcx.has_global_allocator(LOCAL_CRATE),\n+                has_panic_handler: tcx.has_panic_handler(LOCAL_CRATE),\n+                has_default_lib_allocator: tcx\n+                    .sess\n+                    .contains_name(&attrs, sym::default_lib_allocator),\n+                proc_macro_data,\n+                debugger_visualizers,\n+                compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n+                needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n+                needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n+                no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n+                panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n+                profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n+                symbol_mangling_version: tcx.sess.opts.get_symbol_mangling_version(),\n+\n+                crate_deps,\n+                dylib_dependency_formats,\n+                lib_features,\n+                stability_implications,\n+                lang_items,\n+                diagnostic_items,\n+                lang_items_missing,\n+                native_libraries,\n+                foreign_modules,\n+                source_map,\n+                traits,\n+                impls,\n+                incoherent_impls,\n+                exported_symbols,\n+                interpret_alloc_index,\n+                tables,\n+                syntax_contexts,\n+                expn_data,\n+                expn_hashes,\n+                def_path_hash_map,\n+            })\n         });\n-        let final_bytes = self.position() - i;\n \n         let total_bytes = self.position();\n \n-        let computed_total_bytes = preamble_bytes\n-            + dep_bytes\n-            + lib_feature_bytes\n-            + stability_implications_bytes\n-            + lang_item_bytes\n-            + diagnostic_item_bytes\n-            + native_lib_bytes\n-            + foreign_modules_bytes\n-            + def_path_table_bytes\n-            + traits_bytes\n-            + impls_bytes\n-            + incoherent_impls_bytes\n-            + mir_bytes\n-            + item_bytes\n-            + interpret_alloc_index_bytes\n-            + proc_macro_data_bytes\n-            + tables_bytes\n-            + debugger_visualizers_bytes\n-            + exported_symbols_bytes\n-            + hygiene_bytes\n-            + def_path_hash_map_bytes\n-            + source_map_bytes\n-            + final_bytes;\n+        let computed_total_bytes: usize = stats.iter().map(|(_, size)| size).sum();\n         assert_eq!(total_bytes, computed_total_bytes);\n \n         if tcx.sess.meta_stats() {\n@@ -783,42 +726,38 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             assert_eq!(self.opaque.file().stream_position().unwrap(), pos_before_rewind);\n \n+            stats.sort_by_key(|&(_, usize)| usize);\n+\n+            let prefix = \"meta-stats\";\n             let perc = |bytes| (bytes * 100) as f64 / total_bytes as f64;\n-            let p = |label, bytes| {\n-                eprintln!(\"{:>21}: {:>8} bytes ({:4.1}%)\", label, bytes, perc(bytes));\n-            };\n \n-            eprintln!(\"\");\n+            eprintln!(\"{} METADATA STATS\", prefix);\n+            eprintln!(\"{} {:<23}{:>10}\", prefix, \"Section\", \"Size\");\n+            eprintln!(\n+                \"{} ----------------------------------------------------------------\",\n+                prefix\n+            );\n+            for (label, size) in stats {\n+                eprintln!(\n+                    \"{} {:<23}{:>10} ({:4.1}%)\",\n+                    prefix,\n+                    label,\n+                    to_readable_str(size),\n+                    perc(size)\n+                );\n+            }\n+            eprintln!(\n+                \"{} ----------------------------------------------------------------\",\n+                prefix\n+            );\n             eprintln!(\n-                \"{} metadata bytes, of which {} bytes ({:.1}%) are zero\",\n-                total_bytes,\n-                zero_bytes,\n+                \"{} {:<23}{:>10} (of which {:.1}% are zero bytes)\",\n+                prefix,\n+                \"Total\",\n+                to_readable_str(total_bytes),\n                 perc(zero_bytes)\n             );\n-            p(\"preamble\", preamble_bytes);\n-            p(\"dep\", dep_bytes);\n-            p(\"lib feature\", lib_feature_bytes);\n-            p(\"stability_implications\", stability_implications_bytes);\n-            p(\"lang item\", lang_item_bytes);\n-            p(\"diagnostic item\", diagnostic_item_bytes);\n-            p(\"native lib\", native_lib_bytes);\n-            p(\"foreign modules\", foreign_modules_bytes);\n-            p(\"def-path table\", def_path_table_bytes);\n-            p(\"traits\", traits_bytes);\n-            p(\"impls\", impls_bytes);\n-            p(\"incoherent_impls\", incoherent_impls_bytes);\n-            p(\"mir\", mir_bytes);\n-            p(\"item\", item_bytes);\n-            p(\"interpret_alloc_index\", interpret_alloc_index_bytes);\n-            p(\"proc-macro-data\", proc_macro_data_bytes);\n-            p(\"tables\", tables_bytes);\n-            p(\"debugger visualizers\", debugger_visualizers_bytes);\n-            p(\"exported symbols\", exported_symbols_bytes);\n-            p(\"hygiene\", hygiene_bytes);\n-            p(\"def-path hashes\", def_path_hash_map_bytes);\n-            p(\"source_map\", source_map_bytes);\n-            p(\"final\", final_bytes);\n-            eprintln!(\"\");\n+            eprintln!(\"{}\", prefix);\n         }\n \n         root"}, {"sha": "4a9bd9df327f54d3d4e8a4f3e07c5e7dd25e4d6b", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -1066,32 +1066,32 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         let source_info = terminator.source_info;\n         self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n+        // Do NOT early return in this function, it does some crucial fixup of the state at the end!\n         match &mut terminator.kind {\n             TerminatorKind::Assert { expected, ref mut cond, .. } => {\n                 if let Some(ref value) = self.eval_operand(&cond) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                     let expected = Scalar::from_bool(*expected);\n-                    let Ok(value_const) = self.ecx.read_scalar(&value) else {\n-                        // FIXME should be used use_ecx rather than a local match... but we have\n-                        // quite a few of these read_scalar/read_immediate that need fixing.\n-                        return\n-                    };\n-                    if expected != value_const {\n-                        // Poison all places this operand references so that further code\n-                        // doesn't use the invalid value\n-                        match cond {\n-                            Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                Self::remove_const(&mut self.ecx, place.local);\n+                    // FIXME should be used use_ecx rather than a local match... but we have\n+                    // quite a few of these read_scalar/read_immediate that need fixing.\n+                    if let Ok(value_const) = self.ecx.read_scalar(&value) {\n+                        if expected != value_const {\n+                            // Poison all places this operand references so that further code\n+                            // doesn't use the invalid value\n+                            match cond {\n+                                Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                                    Self::remove_const(&mut self.ecx, place.local);\n+                                }\n+                                Operand::Constant(_) => {}\n+                            }\n+                        } else {\n+                            if self.should_const_prop(value) {\n+                                *cond = self.operand_from_scalar(\n+                                    value_const,\n+                                    self.tcx.types.bool,\n+                                    source_info.span,\n+                                );\n                             }\n-                            Operand::Constant(_) => {}\n-                        }\n-                    } else {\n-                        if self.should_const_prop(value) {\n-                            *cond = self.operand_from_scalar(\n-                                value_const,\n-                                self.tcx.types.bool,\n-                                source_info.span,\n-                            );\n                         }\n                     }\n                 }"}, {"sha": "6b3b1c222229cfe82957f8a082e39874c4b629ff", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -69,6 +69,8 @@\n     any(not(feature = \"miri-test-libstd\"), test, doctest),\n     no_global_oom_handling,\n     not(no_global_oom_handling),\n+    not(no_rc),\n+    not(no_sync),\n     target_has_atomic = \"ptr\"\n ))]\n #![no_std]\n@@ -225,16 +227,17 @@ mod boxed {\n }\n pub mod borrow;\n pub mod collections;\n-#[cfg(not(no_global_oom_handling))]\n+#[cfg(all(not(no_rc), not(no_sync), not(no_global_oom_handling)))]\n pub mod ffi;\n pub mod fmt;\n+#[cfg(not(no_rc))]\n pub mod rc;\n pub mod slice;\n pub mod str;\n pub mod string;\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(all(not(no_rc), not(no_sync), target_has_atomic = \"ptr\"))]\n pub mod sync;\n-#[cfg(all(not(no_global_oom_handling), target_has_atomic = \"ptr\"))]\n+#[cfg(all(not(no_global_oom_handling), not(no_rc), not(no_sync), target_has_atomic = \"ptr\"))]\n pub mod task;\n #[cfg(test)]\n mod tests;"}, {"sha": "dd4409198e39b8025b53b3c8a430eaa367c1508a", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -113,6 +113,9 @@ macro_rules! widening_impl {\n         /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n         /// of the result as two separate values, in that order.\n         ///\n+        /// If you also need to add a carry to the wide result, then you want\n+        /// [`Self::carrying_mul`] instead.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -148,6 +151,8 @@ macro_rules! widening_impl {\n         /// additional amount of overflow. This allows for chaining together multiple\n         /// multiplications to create \"big integers\" which represent larger values.\n         ///\n+        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:\n@@ -167,6 +172,31 @@ macro_rules! widening_impl {\n         )]\n         /// ```\n         ///\n+        /// This is the core operation needed for scalar multiplication when\n+        /// implementing it for wider-than-native types.\n+        ///\n+        /// ```\n+        /// #![feature(bigint_helper_methods)]\n+        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n+        ///     let mut carry = 0;\n+        ///     for d in little_endian_digits.iter_mut() {\n+        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n+        ///     }\n+        ///     if carry != 0 {\n+        ///         little_endian_digits.push(carry);\n+        ///     }\n+        /// }\n+        ///\n+        /// let mut v = vec![10, 20];\n+        /// scalar_mul_eq(&mut v, 3);\n+        /// assert_eq!(v, [30, 60]);\n+        ///\n+        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n+        /// let mut v = vec![0x4321, 0x8765];\n+        /// scalar_mul_eq(&mut v, 0xFEED);\n+        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n+        /// ```\n+        ///\n         /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n         /// except that it gives the value of the overflow instead of just whether one happened:\n         ///"}, {"sha": "4f9dff1ef03536b2fc28b3fa7f9fc25135f38480", "filename": "library/std/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -2401,7 +2401,7 @@ impl Path {\n         self.file_name().map(split_file_at_dot).and_then(|(before, _after)| Some(before))\n     }\n \n-    /// Extracts the extension of [`self.file_name`], if possible.\n+    /// Extracts the extension (without the leading dot) of [`self.file_name`], if possible.\n     ///\n     /// The extension is:\n     ///"}, {"sha": "0464dbde065efa02cc7a2a70f11c51fa9b8accdc", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -201,6 +201,8 @@ const EXTRA_CHECK_CFGS: &[(Option<Mode>, &'static str, Option<&[&'static str]>)]\n     (Some(Mode::Std), \"stdarch_intel_sde\", None),\n     (Some(Mode::Std), \"no_fp_fmt_parse\", None),\n     (Some(Mode::Std), \"no_global_oom_handling\", None),\n+    (Some(Mode::Std), \"no_rc\", None),\n+    (Some(Mode::Std), \"no_sync\", None),\n     (Some(Mode::Std), \"freebsd12\", None),\n     (Some(Mode::Std), \"backtrace_in_libstd\", None),\n     /* Extra values not defined in the built-in targets yet, but used in std */"}, {"sha": "216659a235ef7729df5c632b53a9f90968eba10c", "filename": "src/test/mir-opt/issue-101973.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fmir-opt%2Fissue-101973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fmir-opt%2Fissue-101973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-101973.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -O -C debug-assertions=on\n+// This needs inlining followed by ConstProp to reproduce, so we cannot use \"unit-test\".\n+\n+#[inline]\n+pub fn imm8(x: u32) -> u32 {\n+    let mut out = 0u32;\n+    out |= (x >> 0) & 0xff;\n+    out\n+}\n+\n+// EMIT_MIR issue_101973.inner.ConstProp.diff\n+#[inline(never)]\n+pub fn inner(fields: u32) -> i64 {\n+    imm8(fields).rotate_right(((fields >> 8) & 0xf) << 1) as i32 as i64\n+}\n+\n+fn main() {\n+    let val = inner(0xe32cf20f);\n+    assert_eq!(val as u64, 0xfffffffff0000000);\n+}"}, {"sha": "89733a9a2cb7ced7d4188c0f9a29bcca83f1efde", "filename": "src/test/mir-opt/issue_101973.inner.ConstProp.diff", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -0,0 +1,100 @@\n+- // MIR for `inner` before ConstProp\n++ // MIR for `inner` after ConstProp\n+  \n+  fn inner(_1: u32) -> i64 {\n+      debug fields => _1;                  // in scope 0 at $DIR/issue-101973.rs:+0:14: +0:20\n+      let mut _0: i64;                     // return place in scope 0 at $DIR/issue-101973.rs:+0:30: +0:33\n+      let mut _2: i32;                     // in scope 0 at $DIR/issue-101973.rs:+1:5: +1:65\n+      let mut _3: u32;                     // in scope 0 at $DIR/issue-101973.rs:+1:5: +1:58\n+      let mut _4: u32;                     // in scope 0 at $DIR/issue-101973.rs:+1:5: +1:17\n+      let mut _5: u32;                     // in scope 0 at $DIR/issue-101973.rs:+1:10: +1:16\n+      let mut _6: u32;                     // in scope 0 at $DIR/issue-101973.rs:+1:31: +1:57\n+      let mut _7: u32;                     // in scope 0 at $DIR/issue-101973.rs:+1:31: +1:52\n+      let mut _8: u32;                     // in scope 0 at $DIR/issue-101973.rs:+1:32: +1:45\n+      let mut _9: u32;                     // in scope 0 at $DIR/issue-101973.rs:+1:33: +1:39\n+      let mut _10: (u32, bool);            // in scope 0 at $DIR/issue-101973.rs:+1:32: +1:45\n+      let mut _11: (u32, bool);            // in scope 0 at $DIR/issue-101973.rs:+1:31: +1:57\n+      scope 1 (inlined imm8) {             // at $DIR/issue-101973.rs:14:5: 14:17\n+          debug x => _5;                   // in scope 1 at $DIR/issue-101973.rs:5:13: 5:14\n+          let mut _12: u32;                // in scope 1 at $DIR/issue-101973.rs:7:12: 7:27\n+          let mut _13: u32;                // in scope 1 at $DIR/issue-101973.rs:7:12: 7:20\n+          let mut _14: u32;                // in scope 1 at $DIR/issue-101973.rs:7:13: 7:14\n+          let mut _15: (u32, bool);        // in scope 1 at $DIR/issue-101973.rs:7:12: 7:20\n+          scope 2 {\n+              debug out => _4;             // in scope 2 at $DIR/issue-101973.rs:6:9: 6:16\n+          }\n+      }\n+      scope 3 (inlined core::num::<impl u32>::rotate_right) { // at $DIR/issue-101973.rs:14:5: 14:58\n+          debug self => _4;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          debug n => _6;                   // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          let mut _16: u32;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          let mut _17: u32;                // in scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+      }\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/issue-101973.rs:+1:5: +1:65\n+          StorageLive(_3);                 // scope 0 at $DIR/issue-101973.rs:+1:5: +1:58\n+          StorageLive(_4);                 // scope 0 at $DIR/issue-101973.rs:+1:5: +1:17\n+          StorageLive(_5);                 // scope 0 at $DIR/issue-101973.rs:+1:10: +1:16\n+          _5 = _1;                         // scope 0 at $DIR/issue-101973.rs:+1:10: +1:16\n+          _4 = const 0_u32;                // scope 1 at $DIR/issue-101973.rs:6:19: 6:23\n+          StorageLive(_12);                // scope 2 at $DIR/issue-101973.rs:7:12: 7:27\n+          StorageLive(_13);                // scope 2 at $DIR/issue-101973.rs:7:12: 7:20\n+          StorageLive(_14);                // scope 2 at $DIR/issue-101973.rs:7:13: 7:14\n+          _14 = _5;                        // scope 2 at $DIR/issue-101973.rs:7:13: 7:14\n+          _15 = CheckedShr(_14, const 0_i32); // scope 2 at $DIR/issue-101973.rs:7:12: 7:20\n+          assert(!move (_15.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 0_i32) -> bb3; // scope 2 at $DIR/issue-101973.rs:7:12: 7:20\n+      }\n+  \n+      bb1: {\n+          _8 = move (_10.0: u32);          // scope 0 at $DIR/issue-101973.rs:+1:32: +1:45\n+          StorageDead(_9);                 // scope 0 at $DIR/issue-101973.rs:+1:44: +1:45\n+          _7 = BitAnd(move _8, const 15_u32); // scope 0 at $DIR/issue-101973.rs:+1:31: +1:52\n+          StorageDead(_8);                 // scope 0 at $DIR/issue-101973.rs:+1:51: +1:52\n+          _11 = CheckedShl(_7, const 1_i32); // scope 0 at $DIR/issue-101973.rs:+1:31: +1:57\n+          assert(!move (_11.1: bool), \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue-101973.rs:+1:31: +1:57\n+      }\n+  \n+      bb2: {\n+          _6 = move (_11.0: u32);          // scope 0 at $DIR/issue-101973.rs:+1:31: +1:57\n+          StorageDead(_7);                 // scope 0 at $DIR/issue-101973.rs:+1:56: +1:57\n+          StorageLive(_16);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _16 = _4;                        // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          StorageLive(_17);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _17 = _6;                        // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _3 = rotate_right::<u32>(move _16, move _17) -> bb4; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                           // mir::Constant\n+                                           // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+                                           // + literal: Const { ty: extern \"rust-intrinsic\" fn(u32, u32) -> u32 {rotate_right::<u32>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb3: {\n+          _13 = move (_15.0: u32);         // scope 2 at $DIR/issue-101973.rs:7:12: 7:20\n+          StorageDead(_14);                // scope 2 at $DIR/issue-101973.rs:7:19: 7:20\n+          _12 = BitAnd(move _13, const 255_u32); // scope 2 at $DIR/issue-101973.rs:7:12: 7:27\n+          StorageDead(_13);                // scope 2 at $DIR/issue-101973.rs:7:26: 7:27\n+          _4 = BitOr(_4, move _12);        // scope 2 at $DIR/issue-101973.rs:7:5: 7:27\n+          StorageDead(_12);                // scope 2 at $DIR/issue-101973.rs:7:26: 7:27\n+          StorageDead(_5);                 // scope 0 at $DIR/issue-101973.rs:+1:16: +1:17\n+          StorageLive(_6);                 // scope 0 at $DIR/issue-101973.rs:+1:31: +1:57\n+          StorageLive(_7);                 // scope 0 at $DIR/issue-101973.rs:+1:31: +1:52\n+          StorageLive(_8);                 // scope 0 at $DIR/issue-101973.rs:+1:32: +1:45\n+          StorageLive(_9);                 // scope 0 at $DIR/issue-101973.rs:+1:33: +1:39\n+          _9 = _1;                         // scope 0 at $DIR/issue-101973.rs:+1:33: +1:39\n+          _10 = CheckedShr(_9, const 8_i32); // scope 0 at $DIR/issue-101973.rs:+1:32: +1:45\n+          assert(!move (_10.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue-101973.rs:+1:32: +1:45\n+      }\n+  \n+      bb4: {\n+          StorageDead(_17);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          StorageDead(_16);                // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          StorageDead(_6);                 // scope 0 at $DIR/issue-101973.rs:+1:57: +1:58\n+          StorageDead(_4);                 // scope 0 at $DIR/issue-101973.rs:+1:57: +1:58\n+          _2 = move _3 as i32 (Misc);      // scope 0 at $DIR/issue-101973.rs:+1:5: +1:65\n+          StorageDead(_3);                 // scope 0 at $DIR/issue-101973.rs:+1:64: +1:65\n+          _0 = move _2 as i64 (Misc);      // scope 0 at $DIR/issue-101973.rs:+1:5: +1:72\n+          StorageDead(_2);                 // scope 0 at $DIR/issue-101973.rs:+1:71: +1:72\n+          return;                          // scope 0 at $DIR/issue-101973.rs:+2:2: +2:2\n+      }\n+  }\n+  "}, {"sha": "5f7ae70fa0268bb0b5eae6e2ead37c5945293496", "filename": "src/test/run-make-fulldeps/alloc-no-rc/Makefile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-rc%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-rc%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-rc%2FMakefile?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -0,0 +1,4 @@\n+include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --edition=2021 -Dwarnings --crate-type=rlib ../../../../library/alloc/src/lib.rs --cfg no_rc"}, {"sha": "6a258a2ddfd6952edecaf05ffb6f8a6908f17046", "filename": "src/test/run-make-fulldeps/alloc-no-sync/Makefile", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-sync%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-sync%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Falloc-no-sync%2FMakefile?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -0,0 +1,4 @@\n+include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --edition=2021 -Dwarnings --crate-type=rlib ../../../../library/alloc/src/lib.rs --cfg no_sync"}, {"sha": "dd73dd9886a3b59d61f3aec0ac6608cee937d436", "filename": "src/test/ui/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbacktrace.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -4,6 +4,7 @@\n // ignore-openbsd no support for libbacktrace without filename\n // ignore-sgx no processes\n // ignore-msvc see #62897 and `backtrace-debuginfo.rs` test\n+// ignore-fuchsia Backtraces not symbolized\n // compile-flags:-g\n // compile-flags:-Cstrip=none\n "}, {"sha": "ac4ed8225bd82eb30473b49a8622b279befda84e", "filename": "src/test/ui/panics/issue-47429-short-backtraces.legacy.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.legacy.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.legacy.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.legacy.run.stderr?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -1,4 +1,4 @@\n-thread 'main' panicked at 'explicit panic', $DIR/issue-47429-short-backtraces.rs:22:5\n+thread 'main' panicked at 'explicit panic', $DIR/issue-47429-short-backtraces.rs:23:5\n stack backtrace:\n    0: std::panicking::begin_panic\n    1: issue_47429_short_backtraces::main"}, {"sha": "58d0fa62c34e908a565667a98e632f47687a0020", "filename": "src/test/ui/panics/issue-47429-short-backtraces.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -12,6 +12,7 @@\n // ignore-wasm no panic or subprocess support\n // ignore-emscripten no panic or subprocess support\n // ignore-sgx no subprocess support\n+// ignore-fuchsia Backtraces not symbolized\n \n // NOTE(eddyb) output differs between symbol mangling schemes\n // revisions: legacy v0"}, {"sha": "65401fe1c3d80d43955e24a2a4bbbaa02d8b7782", "filename": "src/test/ui/panics/issue-47429-short-backtraces.v0.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.v0.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.v0.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fissue-47429-short-backtraces.v0.run.stderr?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -1,4 +1,4 @@\n-thread 'main' panicked at 'explicit panic', $DIR/issue-47429-short-backtraces.rs:22:5\n+thread 'main' panicked at 'explicit panic', $DIR/issue-47429-short-backtraces.rs:23:5\n stack backtrace:\n    0: std::panicking::begin_panic::<&str>\n    1: issue_47429_short_backtraces::main"}, {"sha": "0f76551630ccabbea559984fbfa13972bb3ed931", "filename": "src/test/ui/panics/runtime-switch.legacy.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.legacy.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.legacy.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.legacy.run.stderr?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -1,4 +1,4 @@\n-thread 'main' panicked at 'explicit panic', $DIR/runtime-switch.rs:25:5\n+thread 'main' panicked at 'explicit panic', $DIR/runtime-switch.rs:26:5\n stack backtrace:\n    0: std::panicking::begin_panic\n    1: runtime_switch::main"}, {"sha": "882340e495c15640d59657f466d8a92daf8eaeb2", "filename": "src/test/ui/panics/runtime-switch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -12,6 +12,7 @@\n // ignore-wasm no panic or subprocess support\n // ignore-emscripten no panic or subprocess support\n // ignore-sgx no subprocess support\n+// ignore-fuchsia Backtrace not symbolized\n \n // NOTE(eddyb) output differs between symbol mangling schemes\n // revisions: legacy v0"}, {"sha": "a4ae441317dace9320d34ca9194b4884a1f53316", "filename": "src/test/ui/panics/runtime-switch.v0.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.v0.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.v0.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fruntime-switch.v0.run.stderr?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -1,4 +1,4 @@\n-thread 'main' panicked at 'explicit panic', $DIR/runtime-switch.rs:25:5\n+thread 'main' panicked at 'explicit panic', $DIR/runtime-switch.rs:26:5\n stack backtrace:\n    0: std::panicking::begin_panic::<&str>\n    1: runtime_switch::main"}, {"sha": "9dd608986df169be7094cfb639eb15ec36512995", "filename": "src/test/ui/process/process-spawn-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fprocess%2Fprocess-spawn-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fprocess%2Fprocess-spawn-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-spawn-nonexistent.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n // ignore-emscripten no processes\n // ignore-sgx no processes\n+// ignore-fuchsia ErrorKind not translated\n \n use std::io::ErrorKind;\n use std::process::Command;"}, {"sha": "8b5466b6cfa0bd3f006d07253c68f2582d478b15", "filename": "src/test/ui/runtime/backtrace-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fruntime%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fruntime%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fruntime%2Fbacktrace-debuginfo.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -12,6 +12,7 @@\n // ignore-pretty issue #37195\n // ignore-emscripten spawning processes is not supported\n // ignore-sgx no processes\n+// ignore-fuchsia Backtrace not symbolized, trace different line alignment\n \n use std::env;\n "}, {"sha": "59574b471dda45e5f26c56e1d1226870ed6f345b", "filename": "src/test/ui/std-backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fstd-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fstd-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstd-backtrace.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -4,6 +4,7 @@\n // ignore-openbsd no support for libbacktrace without filename\n // ignore-sgx no processes\n // ignore-msvc see #62897 and `backtrace-debuginfo.rs` test\n+// ignore-fuchsia Backtraces not symbolized\n // compile-flags:-g\n // compile-flags:-Cstrip=none\n "}, {"sha": "5f7ecb77e0ed4a952a65b89706a48b6ac3cecc1d", "filename": "src/test/ui/suggestions/issue-101984.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101984.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101984.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101984.rs?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -0,0 +1,27 @@\n+use std::marker::PhantomData;\n+\n+type Component = fn(&());\n+\n+struct Wrapper {\n+    router: Router<(Component, Box<Self>)>,\n+}\n+\n+struct Match<C>(PhantomData<C>);\n+\n+struct Router<T>(PhantomData<T>);\n+\n+impl<T> Router<T> {\n+    pub fn at(&self) -> Result<Match<&T>, ()> {\n+        todo!()\n+    }\n+}\n+\n+impl Wrapper {\n+    fn at(&self, path: &str) -> Result<(Component, Box<Self>), ()> {\n+        let (cmp, router) = self.router.at()?;\n+        //~^ ERROR mismatched types\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c744c62d11f9b85293f6a9f0a3cdf14502f91db5", "filename": "src/test/ui/suggestions/issue-101984.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101984.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db4b4d3becf257e7b1c051540fc7e317958d8d2d/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101984.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101984.stderr?ref=db4b4d3becf257e7b1c051540fc7e317958d8d2d", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-101984.rs:21:13\n+   |\n+LL |         let (cmp, router) = self.router.at()?;\n+   |             ^^^^^^^^^^^^^   ----------------- this expression has type `Match<&(for<'r> fn(&'r ()), Box<Wrapper>)>`\n+   |             |\n+   |             expected struct `Match`, found tuple\n+   |\n+   = note: expected struct `Match<&(for<'r> fn(&'r ()), Box<Wrapper>)>`\n+               found tuple `(_, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}