{"sha": "68db68c4cccb9204e91ffcd08fd27be0f33f0033", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZGI2OGM0Y2NjYjkyMDRlOTFmZmNkMDhmZDI3YmUwZjMzZjAwMzM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T14:10:14Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-18T14:56:53Z"}, "message": "Make trans use last_use info to not actually generate copies\n\nIssue #925", "tree": {"sha": "70f3b99d5ebab4e4187cbffd598e99aa034be7d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70f3b99d5ebab4e4187cbffd598e99aa034be7d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68db68c4cccb9204e91ffcd08fd27be0f33f0033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68db68c4cccb9204e91ffcd08fd27be0f33f0033", "html_url": "https://github.com/rust-lang/rust/commit/68db68c4cccb9204e91ffcd08fd27be0f33f0033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68db68c4cccb9204e91ffcd08fd27be0f33f0033/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d", "html_url": "https://github.com/rust-lang/rust/commit/f6491bb42636f4c43f3cbb48fdb98ddd749e6e5d"}], "stats": {"total": 73, "additions": 48, "deletions": 25}, "files": [{"sha": "74ed9f16a6fd14e6708f63f2affc510477125697", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=68db68c4cccb9204e91ffcd08fd27be0f33f0033", "patch": "@@ -161,7 +161,7 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n     let llmod =\n         time(time_passes, \"translation\",\n              bind trans::trans_crate(sess, crate, ty_cx, output, ast_map,\n-                                     mut_map, copy_map));\n+                                     mut_map, copy_map, last_uses));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, output));\n }"}, {"sha": "d4026ce86589d5153ca239097148b578c3d4ce80", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=68db68c4cccb9204e91ffcd08fd27be0f33f0033", "patch": "@@ -31,7 +31,13 @@ fn find_last_uses(c: @crate, def_map: resolve::def_map, tcx: ty::ctxt)\n               mutable blocks: nil};\n     visit::visit_crate(*c, cx, v);\n     let mini_table = std::map::new_int_hash();\n-    cx.last_uses.items {|key, val| if val { mini_table.insert(key, ()); }}\n+    cx.last_uses.items {|key, val|\n+        if val {\n+            mini_table.insert(key, ());\n+            let def_node = ast_util::def_id_of_def(def_map.get(key)).node;\n+            mini_table.insert(def_node, ());\n+        }\n+    }\n     ret mini_table;\n }\n "}, {"sha": "cd31617ade115e783731b2a5e1e5daac0075c7e3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=68db68c4cccb9204e91ffcd08fd27be0f33f0033", "patch": "@@ -2099,23 +2099,26 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         Store(cx, src_val, dst);\n         if src.kind == owned { ret zero_alloca(cx, src.val, t); }\n         // If we're here, it must be a temporary.\n-        ret revoke_clean(cx, src_val);\n+        revoke_clean(cx, src_val);\n+        ret cx;\n     } else if type_is_structural_or_param(tcx, t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         cx = memmove_ty(cx, dst, src_val, t);\n         if src.kind == owned { ret zero_alloca(cx, src_val, t); }\n         // If we're here, it must be a temporary.\n-        ret revoke_clean(cx, src_val);\n+        revoke_clean(cx, src_val);\n+        ret cx;\n     }\n     /* FIXME: suggests a type constraint */\n     bcx_ccx(cx).sess.bug(\"unexpected type in trans::move_val: \" +\n                              ty_to_str(tcx, t));\n }\n \n fn store_temp_expr(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-                   src: lval_result, t: ty::t) -> @block_ctxt {\n+                   src: lval_result, t: ty::t, last_use: bool)\n+    -> @block_ctxt {\n     // Lvals in memory are not temporaries. Copy them.\n-    if src.kind != temporary {\n+    if src.kind != temporary && !last_use {\n         let v = src.kind == owned ? load_if_immediate(cx, src.val, t)\n                                   : src.val;\n         ret copy_val(cx, action, dst, v, t);\n@@ -3887,9 +3890,7 @@ fn zero_and_revoke(bcx: @block_ctxt,\n     for {v, t} in to_zero {\n         bcx = zero_alloca(bcx, v, t);\n     }\n-    for {v, _} in to_revoke {\n-        bcx = revoke_clean(bcx, v);\n-    }\n+    for {v, _} in to_revoke { revoke_clean(bcx, v); }\n     ret bcx;\n }\n \n@@ -4246,7 +4247,8 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         let {bcx, val: addr, kind} = trans_lval(src_r.bcx, dst);\n         assert kind == owned;\n         ret store_temp_expr(bcx, DROP_EXISTING, addr, src_r,\n-                            ty::expr_ty(bcx_tcx(bcx), src));\n+                            ty::expr_ty(bcx_tcx(bcx), src),\n+                            bcx_ccx(bcx).last_uses.contains_key(src.id));\n       }\n       ast::expr_move(dst, src) {\n         // FIXME: calculate copy init-ness in typestate.\n@@ -4277,25 +4279,30 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n }\n \n fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n-    let lv = trans_lval(bcx, e);\n+    let lv = trans_lval(bcx, e), ccx = bcx_ccx(bcx);\n     let {bcx, val, kind} = lv;\n-    let ty = ty::expr_ty(bcx_tcx(bcx), e);\n+    let last_use = kind == owned && ccx.last_uses.contains_key(e.id);\n+    let ty = ty::expr_ty(ccx.tcx, e);\n     alt dest {\n       by_val(cell) {\n         if kind == temporary {\n             revoke_clean(bcx, val);\n             *cell = val;\n-        } else if ty::type_is_immediate(bcx_tcx(bcx), ty) {\n+        } else if last_use {\n+            *cell = Load(bcx, val);\n+            if ty::type_needs_drop(ccx.tcx, ty) {\n+                bcx = zero_alloca(bcx, val, ty);\n+            }\n+        } else {\n             if kind == owned { val = Load(bcx, val); }\n             let {bcx: cx, val} = take_ty_immediate(bcx, val, ty);\n             *cell = val;\n             bcx = cx;\n-        } else {\n-            bcx = take_ty(bcx, val, ty);\n-            *cell = Load(bcx, val);\n         }\n       }\n-      save_in(loc) { bcx = store_temp_expr(bcx, INIT, loc, lv, ty); }\n+      save_in(loc) {\n+        bcx = store_temp_expr(bcx, INIT, loc, lv, ty, last_use);\n+      }\n       ignore. {}\n     }\n     ret bcx;\n@@ -4807,8 +4814,10 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n       ast::pat_bind(_) { true } _ { false }\n     };\n     // Do not allocate space for locals that can be kept immediate.\n-    if is_simple && !bcx_ccx(cx).mut_map.contains_key(local.node.pat.id) &&\n-        ty::type_is_immediate(bcx_tcx(cx), t) {\n+    let ccx = bcx_ccx(cx);\n+    if is_simple && !ccx.mut_map.contains_key(local.node.pat.id) &&\n+       !ccx.last_uses.contains_key(local.node.pat.id) &&\n+       ty::type_is_immediate(ccx.tcx, t) {\n         alt local.node.init {\n           some({op: ast::init_assign., _}) { ret cx; }\n           _ {}\n@@ -6027,7 +6036,8 @@ fn write_abi_version(ccx: @crate_ctxt) {\n \n fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: str, amap: ast_map::map, mut_map: mut::mut_map,\n-               copy_map: alias::copy_map) -> ModuleRef {\n+               copy_map: alias::copy_map, last_uses: last_use::last_uses)\n+    -> ModuleRef {\n     let sha = std::sha1::mk_sha1();\n     let link_meta = link::build_link_meta(sess, *crate, output, sha);\n     let llmod = str::as_buf(link_meta.name, {|buf|\n@@ -6088,6 +6098,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           tcx: tcx,\n           mut_map: mut_map,\n           copy_map: copy_map,\n+          last_uses: last_uses,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,"}, {"sha": "55518c027e1d753a68bb8c48642aa497beb6b050", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68db68c4cccb9204e91ffcd08fd27be0f33f0033/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=68db68c4cccb9204e91ffcd08fd27be0f33f0033", "patch": "@@ -102,6 +102,7 @@ type crate_ctxt =\n      tcx: ty::ctxt,\n      mut_map: mut::mut_map,\n      copy_map: alias::copy_map,\n+     last_uses: last_use::last_uses,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,\n@@ -283,7 +284,7 @@ fn add_clean_free(cx: @block_ctxt, ptr: ValueRef, shared: bool) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-fn revoke_clean(cx: @block_ctxt, val: ValueRef) -> @block_ctxt {\n+fn revoke_clean(cx: @block_ctxt, val: ValueRef) {\n     let sc_cx = find_scope_cx(cx);\n     let found = -1;\n     let i = 0;\n@@ -296,16 +297,21 @@ fn revoke_clean(cx: @block_ctxt, val: ValueRef) -> @block_ctxt {\n         }\n         i += 1;\n     }\n-    // The value does not have a cleanup associated with it. Might be a\n-    // constant or some immediate value.\n-    if found == -1 { ret cx; }\n+    // The value does not have a cleanup associated with it. Continue to next\n+    // scope.\n+    if found == -1 {\n+        alt sc_cx.parent {\n+          parent_some(parent) { revoke_clean(parent, val); } _ {}\n+        }\n+        ret;\n+    }\n     // We found the cleanup and remove it\n     sc_cx.cleanups =\n         std::vec::slice(sc_cx.cleanups, 0u, found as uint) +\n             std::vec::slice(sc_cx.cleanups, (found as uint) + 1u,\n                             std::vec::len(sc_cx.cleanups));\n     sc_cx.lpad_dirty = true;\n-    ret cx;\n+    ret;\n }\n \n fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)"}]}