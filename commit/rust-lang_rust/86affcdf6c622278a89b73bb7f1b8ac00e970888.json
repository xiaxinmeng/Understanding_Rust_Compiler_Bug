{"sha": "86affcdf6c622278a89b73bb7f1b8ac00e970888", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YWZmY2RmNmM2MjIyNzhhODliNzNiYjdmMWI4YWMwMGU5NzA4ODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-28T22:03:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-28T22:03:26Z"}, "message": "Auto merge of #36805 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 11 pull requests\n\n- Successful merges: #36376, #36672, #36740, #36757, #36765, #36769, #36782, #36783, #36784, #36795, #36796\n- Failed merges:", "tree": {"sha": "f8f361e0f1dd7ed5980297531f829b13fd0314bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8f361e0f1dd7ed5980297531f829b13fd0314bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86affcdf6c622278a89b73bb7f1b8ac00e970888", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86affcdf6c622278a89b73bb7f1b8ac00e970888", "html_url": "https://github.com/rust-lang/rust/commit/86affcdf6c622278a89b73bb7f1b8ac00e970888", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86affcdf6c622278a89b73bb7f1b8ac00e970888/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f17b1e03dfb5df1754a7c68bda439ed9c0b51de4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f17b1e03dfb5df1754a7c68bda439ed9c0b51de4", "html_url": "https://github.com/rust-lang/rust/commit/f17b1e03dfb5df1754a7c68bda439ed9c0b51de4"}, {"sha": "ac82eaaafef1a85c266acfcf659fe62405f1c99f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac82eaaafef1a85c266acfcf659fe62405f1c99f", "html_url": "https://github.com/rust-lang/rust/commit/ac82eaaafef1a85c266acfcf659fe62405f1c99f"}], "stats": {"total": 437, "additions": 301, "deletions": 136}, "files": [{"sha": "784ca6f5cc4002a7a1bb15ea85903fc51ee04bcd", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -659,12 +659,6 @@ impl Build {\n                  .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n         }\n \n-        // If we're building for OSX, inform the compiler and the linker that\n-        // we want to build a compiler runnable on 10.7\n-        if target.contains(\"apple-darwin\") {\n-            cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", \"10.7\");\n-        }\n-\n         // Environment variables *required* needed throughout the build\n         //\n         // FIXME: should update code to not require this env var\n@@ -933,7 +927,6 @@ impl Build {\n         // LLVM/jemalloc/etc are all properly compiled.\n         if target.contains(\"apple-darwin\") {\n             base.push(\"-stdlib=libc++\".into());\n-            base.push(\"-mmacosx-version-min=10.7\".into());\n         }\n         // This is a hack, because newer binutils broke things on some vms/distros\n         // (i.e., linking against unknown relocs disabled by the following flag)"}, {"sha": "22db70e605bf49304bffe76e05ae4ec9a4f714da", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -166,12 +166,22 @@ you can find the Rust executables in a directory like\n `\"C:\\Program Files\\Rust stable GNU 1.x\\bin\"`.\n \n Rust does not do its own linking, and so you\u2019ll need to have a linker\n-installed. Doing so will depend on your specific system, consult its\n-documentation for more details.\n-\n-If not, there are a number of places where we can get help. The easiest is\n-[the #rust-beginners IRC channel on irc.mozilla.org][irc-beginners] and for\n-general discussion [the #rust IRC channel on irc.mozilla.org][irc], which we\n+installed. Doing so will depend on your specific system. For\n+Linux-based systems, Rust will attempt to call `cc` for linking. On\n+`windows-msvc` (Rust built on Windows with Microsoft Visual Studio),\n+this depends on having [Microsoft Visual C++ Build Tools][msvbt]\n+installed. These do not need to be in `%PATH%` as `rustc` will find\n+them automatically. In general, if you have your linker in a\n+non-traditional location you can call `rustc \n+linker=/path/to/cc`, where `/path/to/cc` should point to your linker path.\n+\n+[msvbt]: http://landinghub.visualstudio.com/visual-cpp-build-tools\n+\n+If you are still stuck, there are a number of places where we can get\n+help. The easiest is\n+[the #rust-beginners IRC channel on irc.mozilla.org][irc-beginners] \n+and for general discussion\n+[the #rust IRC channel on irc.mozilla.org][irc], which we \n can access through [Mibbit][mibbit]. Then we'll be chatting with other\n Rustaceans (a silly nickname we call ourselves) who can help us out. Other great\n resources include [the user\u2019s forum][users] and [Stack Overflow][stackoverflow]."}, {"sha": "03f17371de68d8aea04f76fe43fdd632e7b9bb07", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -161,7 +161,7 @@ Could not compile `hello_world`.\n \n Rust will not let us use a value that has not been initialized.\n \n-Let take a minute to talk about this stuff we've added to `println!`.\n+Let us take a minute to talk about this stuff we've added to `println!`.\n \n If you include two curly braces (`{}`, some call them moustaches...) in your\n string to print, Rust will interpret this as a request to interpolate some sort"}, {"sha": "6c4da2a88510d20865a4fb3023a62617524302f9", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -596,6 +596,19 @@ extern \"rust-intrinsic\" {\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `val`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// let mut vec = vec![0; 4];\n+    /// unsafe {\n+    ///     let vec_ptr = vec.as_mut_ptr();\n+    ///     ptr::write_bytes(vec_ptr, b'a', 2);\n+    /// }\n+    /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n "}, {"sha": "39114ec4238e72a9682c6a7b99f87e6ed7fe48f1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -260,7 +260,7 @@ impl<'ast> Map<'ast> {\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n-                EntryTy(p, _) |\n+                    EntryTy(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |"}, {"sha": "7e45b3206536007084206735de1d868717bf884e", "filename": "src/librustc_back/target/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         llvm_target: \"mips64-unknown-linux-gnuabi64\".to_string(),\n         target_endian: \"big\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n-        data_layout: \"E-m:m-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        data_layout: \"E-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "338a5da1e1d1d64e87909a325d8eae6312424733", "filename": "src/librustc_back/target/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> TargetResult {\n         llvm_target: \"mips64el-unknown-linux-gnuabi64\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n-        data_layout: \"e-m:m-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128\".to_string(),\n         arch: \"mips64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_env: \"gnu\".to_string(),"}, {"sha": "5d6d21bb6f8c8bb41402c435990a9d58719c9cc0", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -675,14 +675,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         for &Spanned { node: ref field, span } in fields {\n             let field_ty = match used_fields.entry(field.name) {\n                 Occupied(occupied) => {\n-                    let mut err = struct_span_err!(tcx.sess, span, E0025,\n-                                                   \"field `{}` bound multiple times \\\n-                                                    in the pattern\",\n-                                                   field.name);\n-                    span_note!(&mut err, *occupied.get(),\n-                               \"field `{}` previously bound here\",\n-                               field.name);\n-                    err.emit();\n+                    struct_span_err!(tcx.sess, span, E0025,\n+                                     \"field `{}` bound multiple times \\\n+                                      in the pattern\",\n+                                     field.name)\n+                        .span_label(span,\n+                                    &format!(\"multiple uses of `{}` in pattern\", field.name))\n+                        .span_label(*occupied.get(), &format!(\"first use of `{}`\", field.name))\n+                        .emit();\n                     tcx.types.err\n                 }\n                 Vacant(vacant) => {"}, {"sha": "826a88127d84e78ec5165c29bd083eb884b5bcee", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -148,14 +148,70 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n \n     if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n-        span_err!(tcx.sess, impl_m_span, E0050,\n+        let trait_number_args = trait_m.fty.sig.0.inputs.len();\n+        let impl_number_args = impl_m.fty.sig.0.inputs.len();\n+        let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n+        let trait_span = if let Some(trait_id) = trait_m_node_id {\n+            match tcx.map.expect_trait_item(trait_id).node {\n+                TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                    if let Some(arg) = trait_m_sig.decl.inputs.get(\n+                        if trait_number_args > 0 {\n+                            trait_number_args - 1\n+                        } else {\n+                            0\n+                        }) {\n+                        Some(arg.pat.span)\n+                    } else {\n+                        trait_item_span\n+                    }\n+                }\n+                _ => bug!(\"{:?} is not a method\", impl_m)\n+            }\n+        } else {\n+            trait_item_span\n+        };\n+        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+        let impl_span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+            ImplItemKind::Method(ref impl_m_sig, _) => {\n+                if let Some(arg) = impl_m_sig.decl.inputs.get(\n+                    if impl_number_args > 0 {\n+                        impl_number_args - 1\n+                    } else {\n+                        0\n+                    }) {\n+                    arg.pat.span\n+                } else {\n+                    impl_m_span\n+                }\n+            }\n+            _ => bug!(\"{:?} is not a method\", impl_m)\n+        };\n+        let mut err = struct_span_err!(tcx.sess, impl_span, E0050,\n             \"method `{}` has {} parameter{} \\\n              but the declaration in trait `{}` has {}\",\n             trait_m.name,\n-            impl_m.fty.sig.0.inputs.len(),\n-            if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n+            impl_number_args,\n+            if impl_number_args == 1 {\"\"} else {\"s\"},\n             tcx.item_path_str(trait_m.def_id),\n-            trait_m.fty.sig.0.inputs.len());\n+            trait_number_args);\n+        if let Some(trait_span) = trait_span {\n+            err.span_label(trait_span,\n+                           &format!(\"trait requires {}\",\n+                                    &if trait_number_args != 1 {\n+                                        format!(\"{} parameters\", trait_number_args)\n+                                    } else {\n+                                        format!(\"{} parameter\", trait_number_args)\n+                                    }));\n+        }\n+        err.span_label(impl_span,\n+                       &format!(\"expected {}, found {}\",\n+                                &if trait_number_args != 1 {\n+                                    format!(\"{} parameters\", trait_number_args)\n+                                } else {\n+                                    format!(\"{} parameter\", trait_number_args)\n+                                },\n+                       impl_number_args));\n+        err.emit();\n         return;\n     }\n "}, {"sha": "35f5641679afa0b8efe2eeb13f107bcad2fc39e0", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -335,6 +335,22 @@ fn test_resize_policy() {\n ///     println!(\"{:?} has {} hp\", viking, health);\n /// }\n /// ```\n+///\n+/// A HashMap with fixed list of elements can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+///\n+/// fn main() {\n+///     let timber_resources: HashMap<&str, i32> =\n+///     [(\"Norway\", 100),\n+///      (\"Denmark\", 50),\n+///      (\"Iceland\", 10)]\n+///      .iter().cloned().collect();\n+///     // use the values stored in map\n+/// }\n+/// ```\n+\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashMap<K, V, S = RandomState> {"}, {"sha": "cb8393ed07577a9b49956d8618ea5403b76a8aaa", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -98,6 +98,20 @@ use super::map::{self, HashMap, Keys, RandomState};\n ///     println!(\"{:?}\", x);\n /// }\n /// ```\n+///\n+/// HashSet with fixed list of elements can be initialized from an array:\n+///\n+/// ```\n+/// use std::collections::HashSet;\n+///\n+/// fn main() {\n+///     let viking_names: HashSet<&str> =\n+///         [ \"Einar\", \"Olaf\", \"Harald\" ].iter().cloned().collect();\n+///     // use the values stored in the set\n+/// }\n+/// ```\n+\n+\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct HashSet<T, S = RandomState> {"}, {"sha": "111596cfe88e03de33eacdbdce06c36536006d84", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 122, "deletions": 94, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -108,11 +108,109 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         cx.span_err(mitem.span, \"unexpected value in `derive`\");\n     }\n \n-    let traits = mitem.meta_item_list().unwrap_or(&[]);\n+    let mut traits = mitem.meta_item_list().unwrap_or(&[]).to_owned();\n     if traits.is_empty() {\n         cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n     }\n \n+    // First, weed out malformed #[derive]\n+    traits.retain(|titem| {\n+        if titem.word().is_none() {\n+            cx.span_err(titem.span, \"malformed `derive` entry\");\n+            false\n+        } else {\n+            true\n+        }\n+    });\n+\n+    // Next, check for old-style #[derive(Foo)]\n+    //\n+    // These all get expanded to `#[derive_Foo]` and will get expanded first. If\n+    // we actually add any attributes here then we return to get those expanded\n+    // and then eventually we'll come back to finish off the other derive modes.\n+    let mut new_attributes = Vec::new();\n+    traits.retain(|titem| {\n+        let tword = titem.word().unwrap();\n+        let tname = tword.name();\n+\n+        let derive_mode = ast::Ident::with_empty_ctxt(intern(&tname));\n+        let derive_mode = cx.resolver.resolve_derive_mode(derive_mode);\n+        if is_builtin_trait(&tname) || derive_mode.is_some() {\n+            return true\n+        }\n+\n+        if !cx.ecfg.enable_custom_derive() {\n+            feature_gate::emit_feature_err(&cx.parse_sess,\n+                                           \"custom_derive\",\n+                                           titem.span,\n+                                           feature_gate::GateIssue::Language,\n+                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n+        } else {\n+            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n+            let mitem = cx.meta_word(titem.span, name);\n+            new_attributes.push(cx.attribute(mitem.span, mitem));\n+        }\n+        false\n+    });\n+    if new_attributes.len() > 0 {\n+        item = item.map(|mut i| {\n+            let list = cx.meta_list(mitem.span,\n+                                    intern_and_get_ident(\"derive\"),\n+                                    traits);\n+            i.attrs.extend(new_attributes);\n+            i.attrs.push(cx.attribute(mitem.span, list));\n+            i\n+        });\n+        return vec![Annotatable::Item(item)]\n+    }\n+\n+    // Now check for macros-1.1 style custom #[derive].\n+    //\n+    // Expand each of them in order given, but *before* we expand any built-in\n+    // derive modes. The logic here is to:\n+    //\n+    // 1. Collect the remaining `#[derive]` annotations into a list. If\n+    //    there are any left, attach a `#[derive]` attribute to the item\n+    //    that we're currently expanding with the remaining derive modes.\n+    // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n+    // 3. Expand the current item we're expanding, getting back a list of\n+    //    items that replace it.\n+    // 4. Extend the returned list with the current list of items we've\n+    //    collected so far.\n+    // 5. Return everything!\n+    //\n+    // If custom derive extensions end up threading through the `#[derive]`\n+    // attribute, we'll get called again later on to continue expanding\n+    // those modes.\n+    let macros_11_derive = traits.iter()\n+                                 .cloned()\n+                                 .enumerate()\n+                                 .filter(|&(_, ref name)| !is_builtin_trait(&name.name().unwrap()))\n+                                 .next();\n+    if let Some((i, titem)) = macros_11_derive {\n+        let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n+        let ext = cx.resolver.resolve_derive_mode(tname).unwrap();\n+        traits.remove(i);\n+        if traits.len() > 0 {\n+            item = item.map(|mut i| {\n+                let list = cx.meta_list(mitem.span,\n+                                        intern_and_get_ident(\"derive\"),\n+                                        traits);\n+                i.attrs.push(cx.attribute(mitem.span, list));\n+                i\n+            });\n+        }\n+        let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n+        let mitem = cx.meta_list(titem.span,\n+                                 intern_and_get_ident(\"derive\"),\n+                                 vec![titem]);\n+        let item = Annotatable::Item(item);\n+        return ext.expand(cx, mitem.span, &mitem, item)\n+    }\n+\n+    // Ok, at this point we know that there are no old-style `#[derive_Foo]` nor\n+    // any macros-1.1 style `#[derive(Foo)]`. Expand all built-in traits here.\n+\n     // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n     // `#[structural_match]` attribute.\n     if traits.iter().filter_map(|t| t.name()).any(|t| t == \"PartialEq\") &&\n@@ -141,103 +239,33 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         });\n     }\n \n-    let mut other_items = Vec::new();\n-\n-    let mut iter = traits.iter();\n-    while let Some(titem) = iter.next() {\n-\n-        let tword = match titem.word() {\n-            Some(name) => name,\n-            None => {\n-                cx.span_err(titem.span, \"malformed `derive` entry\");\n-                continue\n-            }\n+    let mut items = Vec::new();\n+    for titem in traits.iter() {\n+        let tname = titem.word().unwrap().name();\n+        let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n+        let mitem = cx.meta_word(titem.span, name);\n+\n+        let span = Span {\n+            expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n+                call_site: titem.span,\n+                callee: codemap::NameAndSpan {\n+                    format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                    span: Some(titem.span),\n+                    allow_internal_unstable: true,\n+                },\n+            }),\n+            ..titem.span\n         };\n-        let tname = tword.name();\n \n-        // If this is a built-in derive mode, then we expand it immediately\n-        // here.\n-        if is_builtin_trait(&tname) {\n-            let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n-            let mitem = cx.meta_word(titem.span, name);\n-\n-            let span = Span {\n-                expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n-                    call_site: titem.span,\n-                    callee: codemap::NameAndSpan {\n-                        format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n-                        span: Some(titem.span),\n-                        allow_internal_unstable: true,\n-                    },\n-                }),\n-                ..titem.span\n-            };\n-\n-            let my_item = Annotatable::Item(item);\n-            expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n-                other_items.push(a);\n-            });\n-            item = my_item.expect_item();\n-\n-        // Otherwise if this is a `rustc_macro`-style derive mode, we process it\n-        // here. The logic here is to:\n-        //\n-        // 1. Collect the remaining `#[derive]` annotations into a list. If\n-        //    there are any left, attach a `#[derive]` attribute to the item\n-        //    that we're currently expanding with the remaining derive modes.\n-        // 2. Manufacture a `#[derive(Foo)]` attribute to pass to the expander.\n-        // 3. Expand the current item we're expanding, getting back a list of\n-        //    items that replace it.\n-        // 4. Extend the returned list with the current list of items we've\n-        //    collected so far.\n-        // 5. Return everything!\n-        //\n-        // If custom derive extensions end up threading through the `#[derive]`\n-        // attribute, we'll get called again later on to continue expanding\n-        // those modes.\n-        } else if let Some(ext) =\n-                   cx.resolver.resolve_derive_mode(ast::Ident::with_empty_ctxt(intern(&tname))) {\n-            let remaining_derives = iter.cloned().collect::<Vec<_>>();\n-            if remaining_derives.len() > 0 {\n-                let list = cx.meta_list(titem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        remaining_derives);\n-                let attr = cx.attribute(titem.span, list);\n-                item = item.map(|mut i| {\n-                    i.attrs.push(attr);\n-                    i\n-                });\n-            }\n-            let titem = cx.meta_list_item_word(titem.span, tname.clone());\n-            let mitem = cx.meta_list(titem.span,\n-                                     intern_and_get_ident(\"derive\"),\n-                                     vec![titem]);\n-            let item = Annotatable::Item(item);\n-            let mut items = ext.expand(cx, mitem.span, &mitem, item);\n-            items.extend(other_items);\n-            return items\n-\n-        // If we've gotten this far then it means that we're in the territory of\n-        // the old custom derive mechanism. If the feature isn't enabled, we\n-        // issue an error, otherwise manufacture the `derive_Foo` attribute.\n-        } else if !cx.ecfg.enable_custom_derive() {\n-            feature_gate::emit_feature_err(&cx.parse_sess,\n-                                           \"custom_derive\",\n-                                           titem.span,\n-                                           feature_gate::GateIssue::Language,\n-                                           feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-        } else {\n-            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n-            let mitem = cx.meta_word(titem.span, name);\n-            item = item.map(|mut i| {\n-                i.attrs.push(cx.attribute(mitem.span, mitem));\n-                i\n-            });\n-        }\n+        let my_item = Annotatable::Item(item);\n+        expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n+            items.push(a);\n+        });\n+        item = my_item.expect_item();\n     }\n \n-    other_items.insert(0, Annotatable::Item(item));\n-    return other_items\n+    items.insert(0, Annotatable::Item(item));\n+    return items\n }\n \n macro_rules! derive_traits {"}, {"sha": "1d15cef8bc9308d54b0860948e0e88ff6308dc71", "filename": "src/test/compile-fail/E0025.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Fcompile-fail%2FE0025.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Fcompile-fail%2FE0025.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0025.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -15,5 +15,8 @@ struct Foo {\n \n fn main() {\n     let x = Foo { a:1, b:2 };\n-    let Foo { a: x, a: y, b: 0 } = x; //~ ERROR E0025\n+    let Foo { a: x, a: y, b: 0 } = x;\n+    //~^ ERROR field `a` bound multiple times in the pattern\n+    //~| NOTE multiple uses of `a` in pattern\n+    //~| NOTE first use of `a`\n }"}, {"sha": "5c53d62709aef2bb6239f266a3e375f1c830aae9", "filename": "src/test/compile-fail/E0050.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Fcompile-fail%2FE0050.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Fcompile-fail%2FE0050.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0050.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -9,13 +9,20 @@\n // except according to those terms.\n \n trait Foo {\n-    fn foo(&self, x: u8) -> bool;\n+    fn foo(&self, x: u8) -> bool; //~ NOTE trait requires 2 parameters\n+    fn bar(&self, x: u8, y: u8, z: u8); //~ NOTE trait requires 4 parameters\n+    fn less(&self); //~ NOTE trait requires 1 parameter\n }\n \n struct Bar;\n \n impl Foo for Bar {\n     fn foo(&self) -> bool { true } //~ ERROR E0050\n+                                   //~| NOTE expected 2 parameters, found 1\n+    fn bar(&self) { } //~ ERROR E0050\n+                      //~| NOTE expected 4 parameters, found 1\n+    fn less(&self, x: u8, y: u8, z: u8) { } //~ ERROR E0050\n+                                            //~| NOTE expected 1 parameter, found 4\n }\n \n fn main() {"}, {"sha": "5f816d34c8445fe29541b0c5f5351a296c030810", "filename": "src/test/compile-fail/issue-15260.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Fcompile-fail%2Fissue-15260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Fcompile-fail%2Fissue-15260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15260.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -14,19 +14,28 @@ struct Foo {\n \n fn main() {\n     let Foo {\n-        a: _, //~ NOTE field `a` previously bound here\n-        a: _ //~ ERROR field `a` bound multiple times in the pattern\n+        a: _, //~ NOTE first use of `a`\n+        a: _\n+        //~^ ERROR field `a` bound multiple times in the pattern\n+        //~| NOTE multiple uses of `a` in pattern\n     } = Foo { a: 29 };\n \n     let Foo {\n-        a, //~ NOTE field `a` previously bound here\n-        a: _ //~ ERROR field `a` bound multiple times in the pattern\n+        a, //~ NOTE first use of `a`\n+        a: _\n+        //~^ ERROR field `a` bound multiple times in the pattern\n+        //~| NOTE multiple uses of `a` in pattern\n     } = Foo { a: 29 };\n \n     let Foo {\n-        a, //~ NOTE field `a` previously bound here\n-        //~^ NOTE field `a` previously bound here\n-        a: _, //~ ERROR field `a` bound multiple times in the pattern\n-        a: x //~ ERROR field `a` bound multiple times in the pattern\n+        a,\n+        //~^ NOTE first use of `a`\n+        //~| NOTE first use of `a`\n+        a: _,\n+        //~^ ERROR field `a` bound multiple times in the pattern\n+        //~| NOTE multiple uses of `a` in pattern\n+        a: x\n+        //~^ ERROR field `a` bound multiple times in the pattern\n+        //~| NOTE multiple uses of `a` in pattern\n     } = Foo { a: 29 };\n }"}, {"sha": "b7025c61fb6c4c4b9acbb4c75538cddaabf1bff4", "filename": "src/test/run-pass-fulldeps/rustc-macro/append-impl.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fappend-impl.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -24,7 +24,6 @@ trait Append {\n          Append,\n          Eq)]\n struct A {\n-//~^ ERROR: the semantics of constant patterns is not yet settled\n     inner: u32,\n }\n ", "previous_filename": "src/test/compile-fail-fulldeps/rustc-macro/append-impl.rs"}, {"sha": "c3d295e02c163f7ec3236efae3506985fc77c5f7", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/append-impl.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fappend-impl.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "previous_filename": "src/test/compile-fail-fulldeps/rustc-macro/auxiliary/append-impl.rs"}, {"sha": "42155383decf95afdce9e754e61055043d3c071d", "filename": "src/test/run-pass-fulldeps/rustc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frustc-macro%2Fauxiliary%2Fderive-a.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -22,6 +22,6 @@ use rustc_macro::TokenStream;\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"struct A;\"));\n-    assert!(input.contains(\"#[derive(Eq, Copy, Clone)]\"));\n-    \"#[derive(Eq, Copy, Clone)] struct A;\".parse().unwrap()\n+    assert!(input.contains(\"#[derive(Debug, PartialEq, Eq, Copy, Clone)]\"));\n+    \"#[derive(Debug, PartialEq, Eq, Copy, Clone)] struct A;\".parse().unwrap()\n }"}, {"sha": "a45256387d6c01e4822afdbe7f7639b0e56a5e21", "filename": "src/test/run-pass/issue-18088.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass%2Fissue-18088.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86affcdf6c622278a89b73bb7f1b8ac00e970888/src%2Ftest%2Frun-pass%2Fissue-18088.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18088.rs?ref=86affcdf6c622278a89b73bb7f1b8ac00e970888", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+pub trait Indexable<T>: std::ops::Index<usize, Output = T> {\n+    fn index2(&self, i: usize) -> &T {\n+        &self[i]\n+    }\n+}\n+fn main() {}"}]}