{"sha": "edda7e959d0dea66ec60b064f63bf275ad1c41c5", "node_id": "C_kwDOAAsO6NoAKGVkZGE3ZTk1OWQwZGVhNjZlYzYwYjA2NGY2M2JmMjc1YWQxYzQxYzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T11:54:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T11:54:17Z"}, "message": "Auto merge of #94216 - psumbera:sparc64-abi-fix2, r=nagisa\n\nmore complete sparc64 ABI fix for aggregates with floating point members\n\nPrevious fix didn't handle nested structures at all.", "tree": {"sha": "79f6bceb2488c9146dc7f636b169a47f527377f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79f6bceb2488c9146dc7f636b169a47f527377f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edda7e959d0dea66ec60b064f63bf275ad1c41c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edda7e959d0dea66ec60b064f63bf275ad1c41c5", "html_url": "https://github.com/rust-lang/rust/commit/edda7e959d0dea66ec60b064f63bf275ad1c41c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edda7e959d0dea66ec60b064f63bf275ad1c41c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48132caac241b4a278d58e1d791c6d31f7439ad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/48132caac241b4a278d58e1d791c6d31f7439ad6", "html_url": "https://github.com/rust-lang/rust/commit/48132caac241b4a278d58e1d791c6d31f7439ad6"}, {"sha": "992c27c601db490d4b1f76a6e0e51475b871d315", "url": "https://api.github.com/repos/rust-lang/rust/commits/992c27c601db490d4b1f76a6e0e51475b871d315", "html_url": "https://github.com/rust-lang/rust/commit/992c27c601db490d4b1f76a6e0e51475b871d315"}], "stats": {"total": 296, "additions": 196, "deletions": 100}, "files": [{"sha": "601b3e7d33b87ff15aed15e538357bc38a308cdc", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 176, "deletions": 100, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/edda7e959d0dea66ec60b064f63bf275ad1c41c5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edda7e959d0dea66ec60b064f63bf275ad1c41c5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=edda7e959d0dea66ec60b064f63bf275ad1c41c5", "patch": "@@ -1,136 +1,212 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use crate::abi::call::{\n-    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, CastTarget, FnAbi, Reg, RegKind, Uniform,\n+    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, CastTarget, FnAbi, Reg, Uniform,\n };\n-use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n+use crate::abi::{self, HasDataLayout, Scalar, Size, TyAbiInterface, TyAndLayout};\n+\n+#[derive(Clone, Debug)]\n+pub struct Sdata {\n+    pub prefix: [Option<Reg>; 8],\n+    pub prefix_index: usize,\n+    pub last_offset: Size,\n+    pub has_float: bool,\n+    pub arg_attribute: ArgAttribute,\n+}\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n+fn arg_scalar<C>(cx: &C, scalar: &Scalar, offset: Size, mut data: Sdata) -> Sdata\n where\n-    Ty: TyAbiInterface<'a, C> + Copy,\n     C: HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n-        // Ensure we have at most eight uniquely addressable members.\n-        if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n-            return None;\n+    let dl = cx.data_layout();\n+\n+    if scalar.value != abi::F32 && scalar.value != abi::F64 {\n+        return data;\n+    }\n+\n+    data.has_float = true;\n+\n+    if !data.last_offset.is_aligned(dl.f64_align.abi) && data.last_offset < offset {\n+        if data.prefix_index == data.prefix.len() {\n+            return data;\n         }\n+        data.prefix[data.prefix_index] = Some(Reg::i32());\n+        data.prefix_index += 1;\n+        data.last_offset = data.last_offset + Reg::i32().size;\n+    }\n \n-        let valid_unit = match unit.kind {\n-            RegKind::Integer => false,\n-            RegKind::Float => false,\n-            RegKind::Vector => arg.layout.size.bits() == 128,\n-        };\n+    for _ in 0..((offset - data.last_offset).bits() / 64)\n+        .min((data.prefix.len() - data.prefix_index) as u64)\n+    {\n+        data.prefix[data.prefix_index] = Some(Reg::i64());\n+        data.prefix_index += 1;\n+        data.last_offset = data.last_offset + Reg::i64().size;\n+    }\n \n-        valid_unit.then_some(Uniform { unit, total: arg.layout.size })\n-    })\n+    if data.last_offset < offset {\n+        if data.prefix_index == data.prefix.len() {\n+            return data;\n+        }\n+        data.prefix[data.prefix_index] = Some(Reg::i32());\n+        data.prefix_index += 1;\n+        data.last_offset = data.last_offset + Reg::i32().size;\n+    }\n+\n+    if data.prefix_index == data.prefix.len() {\n+        return data;\n+    }\n+\n+    if scalar.value == abi::F32 {\n+        data.arg_attribute = ArgAttribute::InReg;\n+        data.prefix[data.prefix_index] = Some(Reg::f32());\n+        data.last_offset = offset + Reg::f32().size;\n+    } else {\n+        data.prefix[data.prefix_index] = Some(Reg::f64());\n+        data.last_offset = offset + Reg::f64().size;\n+    }\n+    data.prefix_index += 1;\n+    return data;\n }\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, in_registers_max: Size)\n+fn arg_scalar_pair<C>(\n+    cx: &C,\n+    scalar1: &Scalar,\n+    scalar2: &Scalar,\n+    mut offset: Size,\n+    mut data: Sdata,\n+) -> Sdata\n where\n-    Ty: TyAbiInterface<'a, C> + Copy,\n     C: HasDataLayout,\n {\n-    if !arg.layout.is_aggregate() {\n-        arg.extend_integer_width_to(64);\n-        return;\n+    data = arg_scalar(cx, &scalar1, offset, data);\n+    if scalar1.value == abi::F32 {\n+        offset += Reg::f32().size;\n+    } else if scalar2.value == abi::F64 {\n+        offset += Reg::f64().size;\n+    } else if let abi::Int(i, _signed) = scalar1.value {\n+        offset += i.size();\n+    } else if scalar1.value == abi::Pointer {\n+        offset = offset + Reg::i64().size;\n     }\n \n-    // This doesn't intentionally handle structures with floats which needs\n-    // special care below.\n-    if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n-        arg.cast_to(uniform);\n-        return;\n+    if (offset.raw % 4) != 0 && (scalar2.value == abi::F32 || scalar2.value == abi::F64) {\n+        offset.raw += 4 - (offset.raw % 4);\n+    }\n+    data = arg_scalar(cx, &scalar2, offset, data);\n+    return data;\n+}\n+\n+fn parse_structure<'a, Ty, C>(\n+    cx: &C,\n+    layout: TyAndLayout<'a, Ty>,\n+    mut data: Sdata,\n+    mut offset: Size,\n+) -> Sdata\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if let abi::FieldsShape::Union(_) = layout.fields {\n+        return data;\n     }\n \n-    if let abi::FieldsShape::Arbitrary { .. } = arg.layout.fields {\n-        let dl = cx.data_layout();\n-        let size = arg.layout.size;\n-        let mut prefix = [None; 8];\n-        let mut prefix_index = 0;\n-        let mut last_offset = Size::ZERO;\n-        let mut has_float = false;\n-        let mut arg_attribute = ArgAttribute::default();\n-\n-        for i in 0..arg.layout.fields.count() {\n-            let field = arg.layout.field(cx, i);\n-            let offset = arg.layout.fields.offset(i);\n-\n-            if let abi::Abi::Scalar(scalar) = &field.abi {\n-                if scalar.value == abi::F32 || scalar.value == abi::F64 {\n-                    has_float = true;\n-\n-                    if !last_offset.is_aligned(dl.f64_align.abi) && last_offset < offset {\n-                        if prefix_index == prefix.len() {\n-                            break;\n-                        }\n-                        prefix[prefix_index] = Some(Reg::i32());\n-                        prefix_index += 1;\n-                        last_offset = last_offset + Reg::i32().size;\n-                    }\n-\n-                    for _ in 0..((offset - last_offset).bits() / 64)\n-                        .min((prefix.len() - prefix_index) as u64)\n-                    {\n-                        prefix[prefix_index] = Some(Reg::i64());\n-                        prefix_index += 1;\n-                        last_offset = last_offset + Reg::i64().size;\n-                    }\n-\n-                    if last_offset < offset {\n-                        if prefix_index == prefix.len() {\n-                            break;\n-                        }\n-                        prefix[prefix_index] = Some(Reg::i32());\n-                        prefix_index += 1;\n-                        last_offset = last_offset + Reg::i32().size;\n-                    }\n-\n-                    if prefix_index == prefix.len() {\n-                        break;\n-                    }\n-\n-                    if scalar.value == abi::F32 {\n-                        arg_attribute = ArgAttribute::InReg;\n-                        prefix[prefix_index] = Some(Reg::f32());\n-                        last_offset = offset + Reg::f32().size;\n-                    } else {\n-                        prefix[prefix_index] = Some(Reg::f64());\n-                        last_offset = offset + Reg::f64().size;\n-                    }\n-                    prefix_index += 1;\n+    match layout.abi {\n+        abi::Abi::Scalar(scalar) => {\n+            data = arg_scalar(cx, &scalar, offset, data);\n+        }\n+        abi::Abi::Aggregate { .. } => {\n+            for i in 0..layout.fields.count().clone() {\n+                if offset < layout.fields.offset(i) {\n+                    offset = layout.fields.offset(i);\n                 }\n+                data = parse_structure(cx, layout.field(cx, i).clone(), data.clone(), offset);\n             }\n         }\n-\n-        if has_float && arg.layout.size <= in_registers_max {\n-            let mut rest_size = size - last_offset;\n-\n-            if (rest_size.raw % 8) != 0 && prefix_index < prefix.len() {\n-                prefix[prefix_index] = Some(Reg::i32());\n-                rest_size = rest_size - Reg::i32().size;\n+        _ => {\n+            if let abi::Abi::ScalarPair(scalar1, scalar2) = &layout.abi {\n+                data = arg_scalar_pair(cx, scalar1, scalar2, offset, data);\n             }\n-\n-            arg.cast_to(CastTarget {\n-                prefix,\n-                rest: Uniform { unit: Reg::i64(), total: rest_size },\n-                attrs: ArgAttributes {\n-                    regular: arg_attribute,\n-                    arg_ext: ArgExtension::None,\n-                    pointee_size: Size::ZERO,\n-                    pointee_align: None,\n-                },\n-            });\n-            return;\n         }\n     }\n \n+    return data;\n+}\n+\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, in_registers_max: Size)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if !arg.layout.is_aggregate() {\n+        arg.extend_integer_width_to(64);\n+        return;\n+    }\n+\n     let total = arg.layout.size;\n     if total > in_registers_max {\n         arg.make_indirect();\n         return;\n     }\n \n+    match arg.layout.fields {\n+        abi::FieldsShape::Primitive => unreachable!(),\n+        abi::FieldsShape::Array { .. } => {\n+            // Arrays are passed indirectly\n+            arg.make_indirect();\n+            return;\n+        }\n+        abi::FieldsShape::Union(_) => {\n+            // Unions and are always treated as a series of 64-bit integer chunks\n+        }\n+        abi::FieldsShape::Arbitrary { .. } => {\n+            // Stuctures with floating point numbers need special care.\n+\n+            let mut data = parse_structure(\n+                cx,\n+                arg.layout.clone(),\n+                Sdata {\n+                    prefix: [None; 8],\n+                    prefix_index: 0,\n+                    last_offset: Size::ZERO,\n+                    has_float: false,\n+                    arg_attribute: ArgAttribute::default(),\n+                },\n+                Size { raw: 0 },\n+            );\n+\n+            if data.has_float {\n+                // Structure { float, int, int } doesn't like to be handled like\n+                // { float, long int }. Other way around it doesn't mind.\n+                if data.last_offset < arg.layout.size\n+                    && (data.last_offset.raw % 8) != 0\n+                    && data.prefix_index < data.prefix.len()\n+                {\n+                    data.prefix[data.prefix_index] = Some(Reg::i32());\n+                    data.prefix_index += 1;\n+                    data.last_offset += Reg::i32().size;\n+                }\n+\n+                let mut rest_size = arg.layout.size - data.last_offset;\n+                if (rest_size.raw % 8) != 0 && data.prefix_index < data.prefix.len() {\n+                    data.prefix[data.prefix_index] = Some(Reg::i32());\n+                    rest_size = rest_size - Reg::i32().size;\n+                }\n+\n+                arg.cast_to(CastTarget {\n+                    prefix: data.prefix,\n+                    rest: Uniform { unit: Reg::i64(), total: rest_size },\n+                    attrs: ArgAttributes {\n+                        regular: data.arg_attribute,\n+                        arg_ext: ArgExtension::None,\n+                        pointee_size: Size::ZERO,\n+                        pointee_align: None,\n+                    },\n+                });\n+                return;\n+            }\n+        }\n+    }\n+\n     arg.cast_to(Uniform { unit: Reg::i64(), total });\n }\n "}, {"sha": "e8816e4f303d4f791f03e181ca3d77b8051e1c2b", "filename": "src/test/codegen/sparc-struct-abi.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/edda7e959d0dea66ec60b064f63bf275ad1c41c5/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edda7e959d0dea66ec60b064f63bf275ad1c41c5/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs?ref=edda7e959d0dea66ec60b064f63bf275ad1c41c5", "patch": "@@ -81,3 +81,23 @@ pub struct FloatLongFloat {\n pub extern \"C\" fn structfloatlongfloat() -> FloatLongFloat {\n     FloatLongFloat { f: 0.1, i: 123, g: 3.14 }\n }\n+\n+#[repr(C)]\n+pub struct FloatFloat {\n+    f: f32,\n+    g: f32,\n+}\n+\n+#[repr(C)]\n+pub struct NestedStructs {\n+    a: FloatFloat,\n+    b: FloatFloat,\n+}\n+\n+// CHECK: define inreg { float, float, float, float } @structnestestructs()\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: ret { float, float, float, float } { float 0x3FB99999A0000000, float 0x3FF19999A0000000, float 0x40019999A0000000, float 0x400A666660000000 }\n+#[no_mangle]\n+pub extern \"C\" fn structnestestructs() -> NestedStructs {\n+    NestedStructs { a: FloatFloat { f: 0.1, g: 1.1 }, b: FloatFloat { f: 2.2, g: 3.3 } }\n+}"}]}