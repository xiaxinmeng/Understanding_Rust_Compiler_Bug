{"sha": "15e3774cb4a6536cdb6c01edaa93315743b9f49a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZTM3NzRjYjRhNjUzNmNkYjZjMDFlZGFhOTMzMTU3NDNiOWY0OWE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-28T05:04:06Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-09-28T05:04:10Z"}, "message": "rustup to 1.5.0-nightly (7bf4c885f 2015-09-26)\n\nfixes #348", "tree": {"sha": "9ff64b2c57cd2f31164118373de5c08f947764a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ff64b2c57cd2f31164118373de5c08f947764a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15e3774cb4a6536cdb6c01edaa93315743b9f49a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15e3774cb4a6536cdb6c01edaa93315743b9f49a", "html_url": "https://github.com/rust-lang/rust/commit/15e3774cb4a6536cdb6c01edaa93315743b9f49a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15e3774cb4a6536cdb6c01edaa93315743b9f49a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b749d832ccdef76b2c857bf8b8d21eb6d6a8aa43", "url": "https://api.github.com/repos/rust-lang/rust/commits/b749d832ccdef76b2c857bf8b8d21eb6d6a8aa43", "html_url": "https://github.com/rust-lang/rust/commit/b749d832ccdef76b2c857bf8b8d21eb6d6a8aa43"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "2c85298201f70a698793f04a42ea0f3e6b1b804c", "filename": "src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=15e3774cb4a6536cdb6c01edaa93315743b9f49a", "patch": "@@ -52,7 +52,7 @@ impl LateLintPass for LenZero {\n \n fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[P<TraitItem>]) {\n     fn is_named_self(item: &TraitItem, name: &str) -> bool {\n-        item.name == name && if let MethodTraitItem(ref sig, _) =\n+        item.name.as_str() == name && if let MethodTraitItem(ref sig, _) =\n             item.node { is_self_sig(sig) } else { false }\n     }\n \n@@ -71,7 +71,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[P<TraitItem>]\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[P<ImplItem>]) {\n     fn is_named_self(item: &ImplItem, name: &str) -> bool {\n-        item.name == name && if let MethodImplItem(ref sig, _) =\n+        item.name.as_str() == name && if let MethodImplItem(ref sig, _) =\n             item.node { is_self_sig(sig) } else { false }\n     }\n \n@@ -98,7 +98,7 @@ fn is_self_sig(sig: &MethodSig) -> bool {\n fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str) {    \n     // check if we are in an is_empty() method \n     if let Some(name) = get_item_name(cx, left) {\n-        if name == \"is_empty\" { return; }\n+        if name.as_str() == \"is_empty\" { return; }\n     }\n     match (&left.node, &right.node) {\n         (&ExprLit(ref lit), &ExprMethodCall(ref method, _, ref args)) =>\n@@ -112,7 +112,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n fn check_len_zero(cx: &LateContext, span: Span, name: &Name,\n                   args: &[P<Expr>], lit: &Lit, op: &str) {\n     if let Spanned{node: LitInt(0, _), ..} = *lit {\n-        if name == &\"len\" && args.len() == 1 &&\n+        if name.as_str() == \"len\" && args.len() == 1 &&\n             has_is_empty(cx, &args[0]) {\n                 span_lint(cx, LEN_ZERO, span, &format!(\n                     \"consider replacing the len comparison with `{}{}.is_empty()`\",\n@@ -128,7 +128,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n         if let &MethodTraitItemId(def_id) = id {\n             if let ty::MethodTraitItem(ref method) =\n                 cx.tcx.impl_or_trait_item(def_id) {\n-                    method.name == \"is_empty\"\n+                    method.name.as_str() == \"is_empty\"\n                         && method.fty.sig.skip_binder().inputs.len() == 1\n                 } else { false }\n         } else { false }"}, {"sha": "b64fa148ef3271af9b94dbef7e543a0f88d16f45", "filename": "src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=15e3774cb4a6536cdb6c01edaa93315743b9f49a", "patch": "@@ -161,7 +161,7 @@ struct RefVisitor(Vec<RefLt>);\n impl RefVisitor {\n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let &Some(ref lt) = lifetime {\n-            if lt.name == \"'static\" {\n+            if lt.name.as_str() == \"'static\" {\n                 self.0.push(Static);\n             } else {\n                 self.0.push(Named(lt.name));"}, {"sha": "9e7b0ee38d438b63c5b56fa633353df095356e8d", "filename": "src/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=15e3774cb4a6536cdb6c01edaa93315743b9f49a", "patch": "@@ -110,17 +110,17 @@ impl LateLintPass for LoopsPass {\n                 if args.len() == 1 {\n                     let method_name = method.node;\n                     // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n-                    if method_name == \"iter\" || method_name == \"iter_mut\" {\n+                    if method_name.as_str() == \"iter\" || method_name.as_str() == \"iter_mut\" {\n                         if is_ref_iterable_type(cx, &args[0]) {\n                             let object = snippet(cx, args[0].span, \"_\");\n                             span_lint(cx, EXPLICIT_ITER_LOOP, expr.span, &format!(\n                                 \"it is more idiomatic to loop over `&{}{}` instead of `{}.{}()`\",\n-                                if method_name == \"iter_mut\" { \"mut \" } else { \"\" },\n+                                if method_name.as_str() == \"iter_mut\" { \"mut \" } else { \"\" },\n                                 object, object, method_name));\n                         }\n                     }\n                     // check for looping over Iterator::next() which is not what you want\n-                    else if method_name == \"next\" &&\n+                    else if method_name.as_str() == \"next\" &&\n                             match_trait_method(cx, arg, &[\"core\", \"iter\", \"Iterator\"]) {\n                         span_lint(cx, ITER_NEXT_LOOP, expr.span,\n                                   \"you are iterating over `Iterator::next()` which is an Option; \\\n@@ -191,7 +191,7 @@ impl LateLintPass for LoopsPass {\n     fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.node == \"collect\" &&\n+                if args.len() == 1 && method.node.as_str() == \"collect\" &&\n                         match_trait_method(cx, expr, &[\"core\", \"iter\", \"Iterator\"]) {\n                     span_lint(cx, UNUSED_COLLECT, expr.span, &format!(\n                         \"you are collect()ing an iterator and throwing away the result. \\"}, {"sha": "18da7e977d6b99bc093aadb6e698b8584948b1f5", "filename": "src/methods.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=15e3774cb4a6536cdb6c01edaa93315743b9f49a", "patch": "@@ -42,7 +42,7 @@ impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(ref name, _, ref args) = expr.node {\n             let (obj_ty, ptr_depth) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n-            if name.node == \"unwrap\" {\n+            if name.node.as_str() == \"unwrap\" {\n                 if match_type(cx, obj_ty, &OPTION_PATH) {\n                     span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n                               \"used unwrap() on an Option value. If you don't want \\\n@@ -54,7 +54,7 @@ impl LateLintPass for MethodsPass {\n                                of Err values is preferred\");\n                 }\n             }\n-            else if name.node == \"to_string\" {\n+            else if name.node.as_str() == \"to_string\" {\n                 if obj_ty.sty == ty::TyStr {\n                     let mut arg_str = snippet(cx, args[0].span, \"_\");\n                     if ptr_depth > 1 {\n@@ -82,7 +82,7 @@ impl LateLintPass for MethodsPass {\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if_let_chain! {\n                             [\n-                                name == method_name,\n+                                name.as_str() == method_name,\n                                 sig.decl.inputs.len() == n_args,\n                                 out_type.matches(&sig.decl.output),\n                                 self_kind.matches(&sig.explicit_self.node, false)"}, {"sha": "cf4504d2f67744631dc109091aadf31b4acb35cb", "filename": "src/misc.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=15e3774cb4a6536cdb6c01edaa93315743b9f49a", "patch": "@@ -94,7 +94,7 @@ impl LateLintPass for CmpNan {\n }\n \n fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n-    path.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n+    path.segments.last().map(|seg| if seg.identifier.name.as_str() == \"NAN\" {\n         span_lint(cx, CMP_NAN, span,\n             \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n     });\n@@ -124,9 +124,10 @@ impl LateLintPass for FloatCmp {\n                     return;\n                 }\n                 if let Some(name) = get_item_name(cx, expr) {\n+                    let name = name.as_str();\n                     if name == \"eq\" || name == \"ne\" || name == \"is_nan\" ||\n-                            name.as_str().starts_with(\"eq_\") ||\n-                            name.as_str().ends_with(\"_eq\") {\n+                            name.starts_with(\"eq_\") ||\n+                            name.ends_with(\"_eq\") {\n                         return;\n                     }\n                 }\n@@ -174,8 +175,8 @@ impl LateLintPass for CmpOwned {\n fn check_to_owned(cx: &LateContext, expr: &Expr, other_span: Span) {\n     match expr.node {\n         ExprMethodCall(Spanned{node: ref name, ..}, _, ref args) => {\n-            if name == &\"to_string\" ||\n-                name == &\"to_owned\" && is_str_arg(cx, args) {\n+            if name.as_str() == \"to_string\" ||\n+                name.as_str() == \"to_owned\" && is_str_arg(cx, args) {\n                     span_lint(cx, CMP_OWNED, expr.span, &format!(\n                         \"this creates an owned instance just for comparison. \\\n                          Consider using `{}.as_slice()` to compare without allocation\","}, {"sha": "2ef272237d135dd69aca6e41232b6c5ba0711020", "filename": "src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=15e3774cb4a6536cdb6c01edaa93315743b9f49a", "patch": "@@ -22,7 +22,7 @@ impl LateLintPass for StepByZero {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _,\n                               ref args) = expr.node {\n             // Only warn on literal ranges.\n-            if name == &\"step_by\" && args.len() == 2 &&\n+            if name.as_str() == \"step_by\" && args.len() == 2 &&\n                 is_range(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n                 cx.span_lint(RANGE_STEP_BY_ZERO, expr.span,\n                              \"Range::step_by(0) produces an infinite iterator. \\"}, {"sha": "0dfc10b390aba08c2c4b94a27f4a0fa166e30c2f", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15e3774cb4a6536cdb6c01edaa93315743b9f49a/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=15e3774cb4a6536cdb6c01edaa93315743b9f49a", "patch": "@@ -36,7 +36,7 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n         opt_info.map_or(false, |info| {\n             match info.callee.format {\n                 ExpnFormat::CompilerExpansion(..) => {\n-                    if info.callee.name() == \"closure expansion\" {\n+                    if info.callee.name().as_str() == \"closure expansion\" {\n                         return false;\n                     }\n                 },\n@@ -66,7 +66,8 @@ pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n /// usage e.g. with\n /// `match_def_path(cx, id, &[\"core\", \"option\", \"Option\"])`\n pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n-    cx.tcx.with_path(def_id, |iter| iter.zip(path).all(|(nm, p)| nm.name() == p))\n+    cx.tcx.with_path(def_id, |iter| iter.zip(path)\n+                                        .all(|(nm, p)| nm.name().as_str() == *p))\n }\n \n /// check if type is struct or enum type with given def path\n@@ -98,7 +99,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(\n-        |(a, b)| &a.identifier.name == b)\n+        |(a, b)| a.identifier.name.as_str() == *b)\n }\n \n /// get the name of the item the expression is in, if available"}]}