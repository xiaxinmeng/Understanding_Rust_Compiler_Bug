{"sha": "76dbe2910465072f85e74d6f7115ec9e6803e8bf", "node_id": "C_kwDOAAsO6NoAKDc2ZGJlMjkxMDQ2NTA3MmY4NWU3NGQ2ZjcxMTVlYzllNjgwM2U4YmY", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-04-16T06:49:27Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-04-16T06:49:27Z"}, "message": "rm const traits in libcore", "tree": {"sha": "1ce5c8f7193a215a14c41a16b5e9ae0a47e28360", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ce5c8f7193a215a14c41a16b5e9ae0a47e28360"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76dbe2910465072f85e74d6f7115ec9e6803e8bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76dbe2910465072f85e74d6f7115ec9e6803e8bf", "html_url": "https://github.com/rust-lang/rust/commit/76dbe2910465072f85e74d6f7115ec9e6803e8bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76dbe2910465072f85e74d6f7115ec9e6803e8bf/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a711152615ad9294dc0e5ee6885c8e9bb8418a9", "html_url": "https://github.com/rust-lang/rust/commit/2a711152615ad9294dc0e5ee6885c8e9bb8418a9"}], "stats": {"total": 1343, "additions": 475, "deletions": 868}, "files": [{"sha": "8278d400c8f27353fa441b2f731f0a39a1556525", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -1234,8 +1234,7 @@ impl<T: Default> Default for Box<T> {\n \n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Box<[T]> {\n+impl<T> Default for Box<[T]> {\n     #[inline]\n     fn default() -> Self {\n         let ptr: Unique<[T]> = Unique::<[T; 0]>::dangling();\n@@ -1245,8 +1244,7 @@ impl<T> const Default for Box<[T]> {\n \n #[cfg(not(no_global_oom_handling))]\n #[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for Box<str> {\n+impl Default for Box<str> {\n     #[inline]\n     fn default() -> Self {\n         // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.\n@@ -1443,8 +1441,7 @@ impl<T> From<T> for Box<T> {\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n-#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-impl<T: ?Sized, A: Allocator> const From<Box<T, A>> for Pin<Box<T, A>>\n+impl<T: ?Sized, A: Allocator> From<Box<T, A>> for Pin<Box<T, A>>\n where\n     A: 'static,\n {\n@@ -1880,8 +1877,7 @@ impl<T: ?Sized, A: Allocator> fmt::Pointer for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-impl<T: ?Sized, A: Allocator> const Deref for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -1890,8 +1886,7 @@ impl<T: ?Sized, A: Allocator> const Deref for Box<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_box\", issue = \"92521\")]\n-impl<T: ?Sized, A: Allocator> const DerefMut for Box<T, A> {\n+impl<T: ?Sized, A: Allocator> DerefMut for Box<T, A> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut **self\n     }"}, {"sha": "cf16a3424a0927da51c97a40a4dd7ca6eff62a6c", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -2247,8 +2247,7 @@ impl_eq! { Cow<'a, str>, &'b str }\n impl_eq! { Cow<'a, str>, String }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for String {\n+impl Default for String {\n     /// Creates an empty `String`.\n     #[inline]\n     fn default() -> String {"}, {"sha": "765c095e37bfcba1b0d1f113607de1d836f4064f", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -3022,8 +3022,7 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Vec<T> {\n+impl<T> Default for Vec<T> {\n     /// Creates an empty `Vec<T>`.\n     ///\n     /// The vector will not allocate until elements are pushed onto it."}, {"sha": "4cacee0414d7d9b95090595b44701d46496623da", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -61,7 +61,7 @@ fn box_deref_lval() {\n \n pub struct ConstAllocator;\n \n-unsafe impl const Allocator for ConstAllocator {\n+unsafe impl Allocator for ConstAllocator {\n     fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {\n         match layout.size() {\n             0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),"}, {"sha": "d6ae2b8213f560e67d1bc8e18c0ab3ff8e7d2144", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -105,7 +105,6 @@ impl fmt::Display for AllocError {\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[const_trait]\n pub unsafe trait Allocator {\n     /// Attempts to allocate a block of memory.\n     ///"}, {"sha": "bb93ea509d8eeee6e8f43469cd4e007f02f413bc", "filename": "library/core/src/any.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -662,8 +662,7 @@ impl dyn Any + Send + Sync {\n /// While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n /// noting that the hashes and ordering will vary between Rust releases. Beware\n /// of relying on them inside of your code!\n-#[derive(Clone, Copy, Debug, Hash, Eq)]\n-#[derive_const(PartialEq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,"}, {"sha": "98c87b2c393ea7d7a37c6cf07fa75e8d5788908a", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -148,8 +148,7 @@ impl Error for TryFromSliceError {\n }\n \n #[stable(feature = \"try_from_slice_error\", since = \"1.36.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<Infallible> for TryFromSliceError {\n+impl From<Infallible> for TryFromSliceError {\n     fn from(x: Infallible) -> TryFromSliceError {\n         match x {}\n     }\n@@ -172,16 +171,14 @@ impl<T, const N: usize> AsMut<[T]> for [T; N] {\n }\n \n #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T, const N: usize> const Borrow<[T]> for [T; N] {\n+impl<T, const N: usize> Borrow<[T]> for [T; N] {\n     fn borrow(&self) -> &[T] {\n         self\n     }\n }\n \n #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T, const N: usize> const BorrowMut<[T]> for [T; N] {\n+impl<T, const N: usize> BorrowMut<[T]> for [T; N] {\n     fn borrow_mut(&mut self) -> &mut [T] {\n         self\n     }\n@@ -336,10 +333,9 @@ impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N] {\n }\n \n #[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I, const N: usize> const Index<I> for [T; N]\n+impl<T, I, const N: usize> Index<I> for [T; N]\n where\n-    [T]: ~const Index<I>,\n+    [T]: Index<I>,\n {\n     type Output = <[T] as Index<I>>::Output;\n \n@@ -350,10 +346,9 @@ where\n }\n \n #[stable(feature = \"index_trait_on_arrays\", since = \"1.50.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I, const N: usize> const IndexMut<I> for [T; N]\n+impl<T, I, const N: usize> IndexMut<I> for [T; N]\n where\n-    [T]: ~const IndexMut<I>,\n+    [T]: IndexMut<I>,\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut Self::Output {\n@@ -435,8 +430,7 @@ impl<T: Copy> SpecArrayClone for T {\n macro_rules! array_impl_default {\n     {$n:expr, $t:ident $($ts:ident)*} => {\n         #[stable(since = \"1.4.0\", feature = \"array_default\")]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl<T> const Default for [T; $n] where T: ~const Default {\n+        impl<T> Default for [T; $n] where T: Default {\n             fn default() -> [T; $n] {\n                 [$t::default(), $($ts::default()),*]\n             }\n@@ -445,8 +439,7 @@ macro_rules! array_impl_default {\n     };\n     {$n:expr,} => {\n         #[stable(since = \"1.4.0\", feature = \"array_default\")]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl<T> const Default for [T; $n] {\n+        impl<T> Default for [T; $n] {\n             fn default() -> [T; $n] { [] }\n         }\n     };"}, {"sha": "374759e38161a16c4068cdfb1f4a8df47d5a221d", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -1,7 +1,5 @@\n //! impl bool {}\n \n-use crate::marker::Destruct;\n-\n impl bool {\n     /// Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html),\n     /// or `None` otherwise.\n@@ -31,11 +29,8 @@ impl bool {\n     /// assert_eq!(a, 2);\n     /// ```\n     #[stable(feature = \"bool_to_option\", since = \"1.62.0\")]\n-    #[rustc_const_unstable(feature = \"const_bool_to_option\", issue = \"91917\")]\n     #[inline]\n-    pub const fn then_some<T>(self, t: T) -> Option<T>\n-    where\n-        T: ~const Destruct,\n+    pub fn then_some<T>(self, t: T) -> Option<T>\n     {\n         if self { Some(t) } else { None }\n     }\n@@ -61,12 +56,8 @@ impl bool {\n     /// assert_eq!(a, 1);\n     /// ```\n     #[stable(feature = \"lazy_bool_to_option\", since = \"1.50.0\")]\n-    #[rustc_const_unstable(feature = \"const_bool_to_option\", issue = \"91917\")]\n     #[inline]\n-    pub const fn then<T, F>(self, f: F) -> Option<T>\n-    where\n-        F: ~const FnOnce() -> T,\n-        F: ~const Destruct,\n+    pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T>\n     {\n         if self { Some(f()) } else { None }\n     }"}, {"sha": "efc9ada3891a035526e9290059eee48ec7c027cb", "filename": "library/core/src/borrow.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fborrow.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -154,7 +154,6 @@\n /// [`String`]: ../../std/string/struct.String.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Borrow\"]\n-#[const_trait]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n     ///\n@@ -185,7 +184,6 @@ pub trait Borrow<Borrowed: ?Sized> {\n /// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n /// for more information on borrowing as another type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n     /// Mutably borrows from an owned value.\n     ///\n@@ -207,41 +205,36 @@ pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const Borrow<T> for T {\n+impl<T: ?Sized> Borrow<T> for T {\n     #[rustc_diagnostic_item = \"noop_method_borrow\"]\n     fn borrow(&self) -> &T {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const BorrowMut<T> for T {\n+impl<T: ?Sized> BorrowMut<T> for T {\n     fn borrow_mut(&mut self) -> &mut T {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const Borrow<T> for &T {\n+impl<T: ?Sized> Borrow<T> for &T {\n     fn borrow(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const Borrow<T> for &mut T {\n+impl<T: ?Sized> Borrow<T> for &mut T {\n     fn borrow(&self) -> &T {\n         &**self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_borrow\", issue = \"91522\")]\n-impl<T: ?Sized> const BorrowMut<T> for &mut T {\n+impl<T: ?Sized> BorrowMut<T> for &mut T {\n     fn borrow_mut(&mut self) -> &mut T {\n         &mut **self\n     }"}, {"sha": "bcca8d924cdd62960fc0ef41e624b50fe572899c", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -370,8 +370,7 @@ impl<T: Ord + Copy> Ord for Cell<T> {\n }\n \n #[stable(feature = \"cell_from\", since = \"1.12.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for Cell<T> {\n+impl<T> From<T> for Cell<T> {\n     /// Creates a new `Cell<T>` containing the given value.\n     fn from(t: T) -> Cell<T> {\n         Cell::new(t)\n@@ -1318,8 +1317,7 @@ impl<T: ?Sized + Ord> Ord for RefCell<T> {\n }\n \n #[stable(feature = \"cell_from\", since = \"1.12.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for RefCell<T> {\n+impl<T> From<T> for RefCell<T> {\n     /// Creates a new `RefCell<T>` containing the given value.\n     fn from(t: T) -> RefCell<T> {\n         RefCell::new(t)\n@@ -2126,8 +2124,7 @@ impl<T: Default> Default for UnsafeCell<T> {\n }\n \n #[stable(feature = \"cell_from\", since = \"1.12.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for UnsafeCell<T> {\n+impl<T> From<T> for UnsafeCell<T> {\n     /// Creates a new `UnsafeCell<T>` containing the given value.\n     fn from(t: T) -> UnsafeCell<T> {\n         UnsafeCell::new(t)\n@@ -2226,8 +2223,7 @@ impl<T: Default> Default for SyncUnsafeCell<T> {\n }\n \n #[unstable(feature = \"sync_unsafe_cell\", issue = \"95439\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for SyncUnsafeCell<T> {\n+impl<T> From<T> for SyncUnsafeCell<T> {\n     /// Creates a new `SyncUnsafeCell<T>` containing the given value.\n     fn from(t: T) -> SyncUnsafeCell<T> {\n         SyncUnsafeCell::new(t)"}, {"sha": "a7cd59e50fc318307329e79c99ef11f8fc29aef8", "filename": "library/core/src/cell/once.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -284,8 +284,7 @@ impl<T: PartialEq> PartialEq for OnceCell<T> {\n impl<T: Eq> Eq for OnceCell<T> {}\n \n #[stable(feature = \"once_cell\", since = \"CURRENT_RUSTC_VERSION\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for OnceCell<T> {\n+impl<T> From<T> for OnceCell<T> {\n     /// Creates a new `OnceCell<T>` which already contains the given `value`.\n     #[inline]\n     fn from(value: T) -> Self {"}, {"sha": "b84e4b35b1c77883c8f884cf855bc6b2142d46a6", "filename": "library/core/src/char/convert.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fconvert.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -27,8 +27,7 @@ pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n }\n \n #[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<char> for u32 {\n+impl From<char> for u32 {\n     /// Converts a [`char`] into a [`u32`].\n     ///\n     /// # Examples\n@@ -47,8 +46,7 @@ impl const From<char> for u32 {\n }\n \n #[stable(feature = \"more_char_conversions\", since = \"1.51.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<char> for u64 {\n+impl From<char> for u64 {\n     /// Converts a [`char`] into a [`u64`].\n     ///\n     /// # Examples\n@@ -69,8 +67,7 @@ impl const From<char> for u64 {\n }\n \n #[stable(feature = \"more_char_conversions\", since = \"1.51.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<char> for u128 {\n+impl From<char> for u128 {\n     /// Converts a [`char`] into a [`u128`].\n     ///\n     /// # Examples\n@@ -123,8 +120,7 @@ impl TryFrom<char> for u8 {\n /// for a superset of Windows-1252 that fills the remaining blanks with corresponding\n /// C0 and C1 control codes.\n #[stable(feature = \"char_convert\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<u8> for char {\n+impl From<u8> for char {\n     /// Converts a [`u8`] into a [`char`].\n     ///\n     /// # Examples"}, {"sha": "5662ff8dfd9ae4721f8f127b9829cacf79616bc5", "filename": "library/core/src/clone.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fclone.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -36,8 +36,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::marker::Destruct;\n-\n /// A common trait for the ability to explicitly duplicate an object.\n ///\n /// Differs from [`Copy`] in that [`Copy`] is implicit and an inexpensive bit-wise copy, while\n@@ -106,7 +104,6 @@ use crate::marker::Destruct;\n #[lang = \"clone\"]\n #[rustc_diagnostic_item = \"Clone\"]\n #[rustc_trivial_field_reads]\n-#[const_trait]\n pub trait Clone: Sized {\n     /// Returns a copy of the value.\n     ///\n@@ -130,8 +127,6 @@ pub trait Clone: Sized {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn clone_from(&mut self, source: &Self)\n-    where\n-        Self: ~const Destruct,\n     {\n         *self = source.clone()\n     }\n@@ -182,8 +177,7 @@ mod impls {\n         ($($t:ty)*) => {\n             $(\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-                impl const Clone for $t {\n+                impl Clone for $t {\n                     #[inline(always)]\n                     fn clone(&self) -> Self {\n                         *self\n@@ -201,26 +195,23 @@ mod impls {\n     }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl const Clone for ! {\n+    impl Clone for ! {\n         #[inline]\n         fn clone(&self) -> Self {\n             *self\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl<T: ?Sized> const Clone for *const T {\n+    impl<T: ?Sized> Clone for *const T {\n         #[inline(always)]\n         fn clone(&self) -> Self {\n             *self\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl<T: ?Sized> const Clone for *mut T {\n+    impl<T: ?Sized> Clone for *mut T {\n         #[inline(always)]\n         fn clone(&self) -> Self {\n             *self\n@@ -229,8 +220,7 @@ mod impls {\n \n     /// Shared references can be cloned, but mutable references *cannot*!\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-    impl<T: ?Sized> const Clone for &T {\n+    impl<T: ?Sized> Clone for &T {\n         #[inline(always)]\n         #[rustc_diagnostic_item = \"noop_method_clone\"]\n         fn clone(&self) -> Self {"}, {"sha": "5582f1be4f438ef2e9ddb909829c141a874f0378", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 29, "deletions": 65, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -212,7 +212,6 @@ use self::Ordering::*;\n     label = \"no implementation for `{Self} == {Rhs}`\",\n     append_const_msg\n )]\n-#[const_trait]\n #[rustc_diagnostic_item = \"PartialEq\"]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used\n@@ -333,8 +332,7 @@ pub struct AssertParamIsEq<T: Eq + ?Sized> {\n /// let result = 2.cmp(&1);\n /// assert_eq!(Ordering::Greater, result);\n /// ```\n-#[derive(Clone, Copy, Eq, Debug, Hash)]\n-#[derive_const(PartialOrd, Ord, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(i8)]\n pub enum Ordering {\n@@ -604,8 +602,7 @@ impl Ordering {\n pub struct Reverse<T>(#[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")] pub T);\n \n #[stable(feature = \"reverse_cmp_key\", since = \"1.19.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-impl<T: ~const PartialOrd> const PartialOrd for Reverse<T> {\n+impl<T: PartialOrd> PartialOrd for Reverse<T> {\n     #[inline]\n     fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n         other.0.partial_cmp(&self.0)\n@@ -763,7 +760,6 @@ impl<T: Clone> Clone for Reverse<T> {\n #[doc(alias = \">=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Ord\"]\n-#[const_trait]\n pub trait Ord: Eq + PartialOrd<Self> {\n     /// This method returns an [`Ordering`] between `self` and `other`.\n     ///\n@@ -799,7 +795,6 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn max(self, other: Self) -> Self\n     where\n         Self: Sized,\n-        Self: ~const Destruct,\n     {\n         max_by(self, other, Ord::cmp)\n     }\n@@ -820,7 +815,6 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn min(self, other: Self) -> Self\n     where\n         Self: Sized,\n-        Self: ~const Destruct,\n     {\n         min_by(self, other, Ord::cmp)\n     }\n@@ -846,8 +840,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     fn clamp(self, min: Self, max: Self) -> Self\n     where\n         Self: Sized,\n-        Self: ~const Destruct,\n-        Self: ~const PartialOrd,\n+        Self: PartialOrd,\n     {\n         assert!(min <= max);\n         if self < min {\n@@ -1035,7 +1028,6 @@ pub macro Ord($item:item) {\n     label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\n     append_const_msg\n )]\n-#[const_trait]\n #[rustc_diagnostic_item = \"PartialOrd\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values if one exists.\n@@ -1168,7 +1160,7 @@ pub macro PartialOrd($item:item) {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"cmp_min\")]\n-pub const fn min<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n+pub const fn min<T: Ord>(v1: T, v2: T) -> T {\n     v1.min(v2)\n }\n \n@@ -1187,11 +1179,7 @@ pub const fn min<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n #[inline]\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn min_by<T, F: ~const FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\n-where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n+pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\n {\n     match compare(&v1, &v2) {\n         Ordering::Less | Ordering::Equal => v1,\n@@ -1214,14 +1202,9 @@ where\n #[inline]\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn min_by_key<T, F: ~const FnMut(&T) -> K, K: ~const Ord>(v1: T, v2: T, mut f: F) -> T\n-where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n-    K: ~const Destruct,\n+pub fn min_by_key<T, F:FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T\n {\n-    min_by(v1, v2, const |v1, v2| f(v1).cmp(&f(v2)))\n+    min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n }\n \n /// Compares and returns the maximum of two values.\n@@ -1241,9 +1224,8 @@ where\n #[inline]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"cmp_max\")]\n-pub const fn max<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n+pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     v1.max(v2)\n }\n \n@@ -1262,11 +1244,7 @@ pub const fn max<T: ~const Ord + ~const Destruct>(v1: T, v2: T) -> T {\n #[inline]\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n-#[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn max_by<T, F: ~const FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\n-where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n+pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T\n {\n     match compare(&v1, &v2) {\n         Ordering::Less | Ordering::Equal => v2,\n@@ -1290,11 +1268,11 @@ where\n #[must_use]\n #[stable(feature = \"cmp_min_max_by\", since = \"1.53.0\")]\n #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-pub const fn max_by_key<T, F: ~const FnMut(&T) -> K, K: ~const Ord>(v1: T, v2: T, mut f: F) -> T\n+pub const fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T\n where\n-    T: ~const Destruct,\n-    F: ~const Destruct,\n-    K: ~const Destruct,\n+    T: Destruct,\n+    F: Destruct,\n+    K: Destruct,\n {\n     max_by(v1, v2, const |v1, v2| f(v1).cmp(&f(v2)))\n }\n@@ -1307,8 +1285,7 @@ mod impls {\n     macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const PartialEq for $t {\n+            impl PartialEq for $t {\n                 #[inline]\n                 fn eq(&self, other: &$t) -> bool { (*self) == (*other) }\n                 #[inline]\n@@ -1318,8 +1295,7 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialEq for () {\n+    impl PartialEq for () {\n         #[inline]\n         fn eq(&self, _other: &()) -> bool {\n             true\n@@ -1346,8 +1322,7 @@ mod impls {\n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const PartialOrd for $t {\n+            impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                     match (*self <= *other, *self >= *other) {\n@@ -1370,17 +1345,15 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialOrd for () {\n+    impl PartialOrd for () {\n         #[inline]\n         fn partial_cmp(&self, _: &()) -> Option<Ordering> {\n             Some(Equal)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialOrd for bool {\n+    impl PartialOrd for bool {\n         #[inline]\n         fn partial_cmp(&self, other: &bool) -> Option<Ordering> {\n             Some(self.cmp(other))\n@@ -1392,8 +1365,7 @@ mod impls {\n     macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const PartialOrd for $t {\n+            impl PartialOrd for $t {\n                 #[inline]\n                 fn partial_cmp(&self, other: &$t) -> Option<Ordering> {\n                     Some(self.cmp(other))\n@@ -1409,8 +1381,7 @@ mod impls {\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl const Ord for $t {\n+            impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n                     // The order here is important to generate more optimal assembly.\n@@ -1424,17 +1395,15 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const Ord for () {\n+    impl Ord for () {\n         #[inline]\n         fn cmp(&self, _other: &()) -> Ordering {\n             Equal\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const Ord for bool {\n+    impl Ord for bool {\n         #[inline]\n         fn cmp(&self, other: &bool) -> Ordering {\n             // Casting to i8's and converting the difference to an Ordering generates\n@@ -1453,8 +1422,7 @@ mod impls {\n     ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialEq for ! {\n+    impl PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n@@ -1464,16 +1432,14 @@ mod impls {\n     impl Eq for ! {}\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const PartialOrd for ! {\n+    impl PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl const Ord for ! {\n+    impl Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self\n         }\n@@ -1482,10 +1448,9 @@ mod impls {\n     // & pointers\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl<A: ?Sized, B: ?Sized> const PartialEq<&B> for &A\n+    impl<A: ?Sized, B: ?Sized> PartialEq<&B> for &A\n     where\n-        A: ~const PartialEq<B>,\n+        A: PartialEq<B>,\n     {\n         #[inline]\n         fn eq(&self, other: &&B) -> bool {\n@@ -1497,10 +1462,9 @@ mod impls {\n         }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-    impl<A: ?Sized, B: ?Sized> const PartialOrd<&B> for &A\n+    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A\n     where\n-        A: ~const PartialOrd<B>,\n+        A: PartialOrd<B>,\n     {\n         #[inline]\n         fn partial_cmp(&self, other: &&B) -> Option<Ordering> {"}, {"sha": "3ae787cac71f85d6eb4a4b1b6cc235a2147cd671", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -214,7 +214,6 @@ pub const fn identity<T>(x: T) -> T {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"AsRef\")]\n-#[const_trait]\n pub trait AsRef<T: ?Sized> {\n     /// Converts this type into a shared reference of the (usually inferred) input type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -366,7 +365,6 @@ pub trait AsRef<T: ?Sized> {\n /// `&mut Vec<u8>`, for example, is the better choice (callers need to pass the correct type then).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"AsMut\")]\n-#[const_trait]\n pub trait AsMut<T: ?Sized> {\n     /// Converts this type into a mutable reference of the (usually inferred) input type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -443,7 +441,6 @@ pub trait AsMut<T: ?Sized> {\n /// [`Vec`]: ../../std/vec/struct.Vec.html\n #[rustc_diagnostic_item = \"Into\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait Into<T>: Sized {\n     /// Converts this type into the (usually inferred) input type.\n     #[must_use]\n@@ -539,7 +536,6 @@ pub trait Into<T>: Sized {\n     all(_Self = \"&str\", T = \"std::string::String\"),\n     note = \"to coerce a `{T}` into a `{Self}`, use `&*` as a prefix\",\n ))]\n-#[const_trait]\n pub trait From<T>: Sized {\n     /// Converts to this type from the input type.\n     #[rustc_diagnostic_item = \"from_fn\"]\n@@ -564,7 +560,6 @@ pub trait From<T>: Sized {\n /// [`Into`], see there for details.\n #[rustc_diagnostic_item = \"TryInto\"]\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[const_trait]\n pub trait TryInto<T>: Sized {\n     /// The type returned in the event of a conversion error.\n     #[stable(feature = \"try_from\", since = \"1.34.0\")]\n@@ -641,7 +636,6 @@ pub trait TryInto<T>: Sized {\n /// [`try_from`]: TryFrom::try_from\n #[rustc_diagnostic_item = \"TryFrom\"]\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[const_trait]\n pub trait TryFrom<T>: Sized {\n     /// The type returned in the event of a conversion error.\n     #[stable(feature = \"try_from\", since = \"1.34.0\")]\n@@ -658,10 +652,9 @@ pub trait TryFrom<T>: Sized {\n \n // As lifts over &\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized, U: ?Sized> const AsRef<U> for &T\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &T\n where\n-    T: ~const AsRef<U>,\n+    T: AsRef<U>,\n {\n     #[inline]\n     fn as_ref(&self) -> &U {\n@@ -671,10 +664,9 @@ where\n \n // As lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized, U: ?Sized> const AsRef<U> for &mut T\n+impl<T: ?Sized, U: ?Sized> AsRef<U> for &mut T\n where\n-    T: ~const AsRef<U>,\n+    T: AsRef<U>,\n {\n     #[inline]\n     fn as_ref(&self) -> &U {\n@@ -692,10 +684,9 @@ where\n \n // AsMut lifts over &mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized, U: ?Sized> const AsMut<U> for &mut T\n+impl<T: ?Sized, U: ?Sized> AsMut<U> for &mut T\n where\n-    T: ~const AsMut<U>,\n+    T: AsMut<U>,\n {\n     #[inline]\n     fn as_mut(&mut self) -> &mut U {\n@@ -713,10 +704,9 @@ where\n \n // From implies Into\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, U> const Into<U> for T\n+impl<T, U> Into<U> for T\n where\n-    U: ~const From<T>,\n+    U: From<T>,\n {\n     /// Calls `U::from(self)`.\n     ///\n@@ -730,8 +720,7 @@ where\n \n // From (and thus Into) is reflexive\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for T {\n+impl<T> From<T> for T {\n     /// Returns the argument unchanged.\n     #[inline(always)]\n     fn from(t: T) -> T {\n@@ -748,19 +737,17 @@ impl<T> const From<T> for T {\n #[allow(unused_attributes)] // FIXME(#58633): do a principled fix instead.\n #[rustc_reservation_impl = \"permitting this impl would forbid us from adding \\\n                             `impl<T> From<!> for T` later; see rust-lang/rust#64715 for details\"]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<!> for T {\n+impl<T> From<!> for T {\n     fn from(t: !) -> T {\n         t\n     }\n }\n \n // TryFrom implies TryInto\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, U> const TryInto<U> for T\n+impl<T, U> TryInto<U> for T\n where\n-    U: ~const TryFrom<T>,\n+    U: TryFrom<T>,\n {\n     type Error = U::Error;\n \n@@ -773,10 +760,9 @@ where\n // Infallible conversions are semantically equivalent to fallible conversions\n // with an uninhabited error type.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, U> const TryFrom<U> for T\n+impl<T, U> TryFrom<U> for T\n where\n-    U: ~const Into<T>,\n+    U: Into<T>,\n {\n     type Error = Infallible;\n \n@@ -876,8 +862,7 @@ impl AsMut<str> for str {\n pub enum Infallible {}\n \n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl const Clone for Infallible {\n+impl Clone for Infallible {\n     fn clone(&self) -> Infallible {\n         match *self {}\n     }\n@@ -929,8 +914,7 @@ impl Ord for Infallible {\n }\n \n #[stable(feature = \"convert_infallible\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<!> for Infallible {\n+impl From<!> for Infallible {\n     fn from(x: !) -> Self {\n         x\n     }"}, {"sha": "56ab63be27d37def1df7a18ed203ecc5a2d6e6e5", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -44,8 +44,7 @@ impl_float_to_int!(f64 => u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize);\n macro_rules! impl_from {\n     ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n         #[$attr]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const From<$Small> for $Large {\n+        impl From<$Small> for $Large {\n             // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n             // Rustdocs on functions do not.\n             #[doc = $doc]\n@@ -170,8 +169,7 @@ impl_from! { f32, f64, #[stable(feature = \"lossless_float_conv\", since = \"1.6.0\"\n \n // bool -> Float\n #[stable(feature = \"float_from_bool\", since = \"1.68.0\")]\n-#[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-impl const From<bool> for f32 {\n+impl From<bool> for f32 {\n     /// Converts `bool` to `f32` losslessly. The resulting value is positive\n     /// `0.0` for `false` and `1.0` for `true` values.\n     ///\n@@ -190,8 +188,7 @@ impl const From<bool> for f32 {\n     }\n }\n #[stable(feature = \"float_from_bool\", since = \"1.68.0\")]\n-#[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-impl const From<bool> for f64 {\n+impl From<bool> for f64 {\n     /// Converts `bool` to `f64` losslessly. The resulting value is positive\n     /// `0.0` for `false` and `1.0` for `true` values.\n     ///\n@@ -214,8 +211,7 @@ impl const From<bool> for f64 {\n macro_rules! try_from_unbounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -233,8 +229,7 @@ macro_rules! try_from_unbounded {\n macro_rules! try_from_lower_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -256,8 +251,7 @@ macro_rules! try_from_lower_bounded {\n macro_rules! try_from_upper_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -279,8 +273,7 @@ macro_rules! try_from_upper_bounded {\n macro_rules! try_from_both_bounded {\n     ($source:ty, $($target:ty),*) => {$(\n         #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const TryFrom<$source> for $target {\n+        impl TryFrom<$source> for $target {\n             type Error = TryFromIntError;\n \n             /// Try to create the target number type from a source\n@@ -431,8 +424,7 @@ use crate::num::NonZeroUsize;\n macro_rules! nzint_impl_from {\n     ($Small: ty, $Large: ty, #[$attr:meta], $doc: expr) => {\n         #[$attr]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const From<$Small> for $Large {\n+        impl From<$Small> for $Large {\n             // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n             // Rustdocs on functions do not.\n             #[doc = $doc]"}, {"sha": "09dbc95810f51216c18e3d8a39e0449d9eb6d194", "filename": "library/core/src/default.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fdefault.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -99,7 +99,6 @@\n /// ```\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Default\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait Default: Sized {\n     /// Returns the \"default value\" for a type.\n     ///\n@@ -190,8 +189,7 @@ pub macro Default($item:item) {\n macro_rules! default_impl {\n     ($t:ty, $v:expr, $doc:tt) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl const Default for $t {\n+        impl Default for $t {\n             #[inline]\n             #[doc = $doc]\n             fn default() -> $t {"}, {"sha": "4a28a6e40e830b96770df0a60c8f9924075f889b", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -87,7 +87,7 @@\n \n use crate::fmt;\n use crate::intrinsics::const_eval_select;\n-use crate::marker::{self, Destruct};\n+use crate::marker;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n@@ -184,7 +184,6 @@ mod sip;\n /// [impl]: ../../std/primitive.str.html#impl-Hash-for-str\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Hash\"]\n-#[const_trait]\n pub trait Hash {\n     /// Feeds this value into the given [`Hasher`].\n     ///\n@@ -199,7 +198,7 @@ pub trait Hash {\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn hash<H: ~const Hasher>(&self, state: &mut H);\n+    fn hash<H: Hasher>(&self, state: &mut H);\n \n     /// Feeds a slice of this type into the given [`Hasher`].\n     ///\n@@ -236,7 +235,7 @@ pub trait Hash {\n     /// [`hash`]: Hash::hash\n     /// [`hash_slice`]: Hash::hash_slice\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: ~const Hasher>(data: &[Self], state: &mut H)\n+    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n     where\n         Self: Sized,\n     {\n@@ -246,7 +245,7 @@ pub trait Hash {\n                 piece.hash(state)\n             }\n         }\n-        const fn ct<T: ~const Hash, H: ~const Hasher>(data: &[T], state: &mut H) {\n+        const fn ct<T: Hash, H: Hasher>(data: &[T], state: &mut H) {\n             let mut i = 0;\n             while i < data.len() {\n                 data[i].hash(state);\n@@ -327,7 +326,6 @@ pub use macros::Hash;\n /// [`write_u8`]: Hasher::write_u8\n /// [`write_u32`]: Hasher::write_u32\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait Hasher {\n     /// Returns the hash value for the values written so far.\n     ///\n@@ -573,8 +571,7 @@ pub trait Hasher {\n }\n \n #[stable(feature = \"indirect_hasher_impl\", since = \"1.22.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n+impl<H: Hasher + ?Sized> Hasher for &mut H {\n     fn finish(&self) -> u64 {\n         (**self).finish()\n     }\n@@ -654,7 +651,6 @@ impl<H: ~const Hasher + ?Sized> const Hasher for &mut H {\n /// [`build_hasher`]: BuildHasher::build_hasher\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-#[const_trait]\n pub trait BuildHasher {\n     /// Type of the hasher that will be created.\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n@@ -715,10 +711,10 @@ pub trait BuildHasher {\n     /// );\n     /// ```\n     #[unstable(feature = \"build_hasher_simple_hash_one\", issue = \"86161\")]\n-    fn hash_one<T: ~const Hash + ~const Destruct>(&self, x: T) -> u64\n+    fn hash_one<T: Hash>(&self, x: T) -> u64\n     where\n         Self: Sized,\n-        Self::Hasher: ~const Hasher + ~const Destruct,\n+        Self::Hasher: Hasher,\n     {\n         let mut hasher = self.build_hasher();\n         x.hash(&mut hasher);\n@@ -782,8 +778,7 @@ impl<H> fmt::Debug for BuildHasherDefault<H> {\n }\n \n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl<H: ~const Default + Hasher> const BuildHasher for BuildHasherDefault<H> {\n+impl<H: Default + Hasher> BuildHasher for BuildHasherDefault<H> {\n     type Hasher = H;\n \n     fn build_hasher(&self) -> H {\n@@ -799,8 +794,7 @@ impl<H> Clone for BuildHasherDefault<H> {\n }\n \n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<H> const Default for BuildHasherDefault<H> {\n+impl<H> Default for BuildHasherDefault<H> {\n     fn default() -> BuildHasherDefault<H> {\n         BuildHasherDefault(marker::PhantomData)\n     }\n@@ -825,15 +819,14 @@ mod impls {\n     macro_rules! impl_write {\n         ($(($ty:ident, $meth:ident),)*) => {$(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-            impl const Hash for $ty {\n+            impl Hash for $ty {\n                 #[inline]\n-                fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+                fn hash<H: Hasher>(&self, state: &mut H) {\n                     state.$meth(*self)\n                 }\n \n                 #[inline]\n-                fn hash_slice<H: ~const Hasher>(data: &[$ty], state: &mut H) {\n+                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n                     let newlen = mem::size_of_val(data);\n                     let ptr = data.as_ptr() as *const u8;\n                     // SAFETY: `ptr` is valid and aligned, as this macro is only used\n@@ -862,60 +855,54 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for bool {\n+    impl Hash for bool {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_u8(*self as u8)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for char {\n+    impl Hash for char {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_u32(*self as u32)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for str {\n+    impl Hash for str {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_str(self);\n         }\n     }\n \n     #[stable(feature = \"never_hash\", since = \"1.29.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl const Hash for ! {\n+    impl Hash for ! {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, _: &mut H) {\n+        fn hash<H: Hasher>(&self, _: &mut H) {\n             *self\n         }\n     }\n \n     macro_rules! impl_hash_tuple {\n         () => (\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-            impl const Hash for () {\n+            impl Hash for () {\n                 #[inline]\n-                fn hash<H: ~const Hasher>(&self, _state: &mut H) {}\n+                fn hash<H: Hasher>(&self, _state: &mut H) {}\n             }\n         );\n \n         ( $($name:ident)+) => (\n             maybe_tuple_doc! {\n                 $($name)+ @\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-                #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-                impl<$($name: ~const Hash),+> const Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n+                impl<$($name: Hash),+> Hash for ($($name,)+) where last_type!($($name,)+): ?Sized {\n                     #[allow(non_snake_case)]\n                     #[inline]\n-                    fn hash<S: ~const Hasher>(&self, state: &mut S) {\n+                    fn hash<S: Hasher>(&self, state: &mut S) {\n                         let ($(ref $name,)+) = *self;\n                         $($name.hash(state);)+\n                     }\n@@ -958,29 +945,26 @@ mod impls {\n     impl_hash_tuple! { T B C D E F G H I J K L }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl<T: ~const Hash> const Hash for [T] {\n+    impl<T: Hash> Hash for [T] {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             state.write_length_prefix(self.len());\n             Hash::hash_slice(self, state)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl<T: ?Sized + ~const Hash> const Hash for &T {\n+    impl<T: ?Sized + Hash> Hash for &T {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-    impl<T: ?Sized + ~const Hash> const Hash for &mut T {\n+    impl<T: ?Sized + Hash> Hash for &mut T {\n         #[inline]\n-        fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n             (**self).hash(state);\n         }\n     }"}, {"sha": "1a87671d1d994a54c58a275a44d08ccb4cb09bc5", "filename": "library/core/src/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fsip.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -225,8 +225,7 @@ impl<S: Sip> Hasher<S> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const super::Hasher for SipHasher {\n+impl super::Hasher for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.0.hasher.write(msg)\n@@ -244,8 +243,7 @@ impl const super::Hasher for SipHasher {\n }\n \n #[unstable(feature = \"hashmap_internals\", issue = \"none\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const super::Hasher for SipHasher13 {\n+impl super::Hasher for SipHasher13 {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         self.hasher.write(msg)\n@@ -262,7 +260,7 @@ impl const super::Hasher for SipHasher13 {\n     }\n }\n \n-impl<S: ~const Sip> const super::Hasher for Hasher<S> {\n+impl<S: Sip> super::Hasher for Hasher<S> {\n     // Note: no integer hashing methods (`write_u*`, `write_i*`) are defined\n     // for this type. We could add them, copy the `short_write` implementation\n     // in librustc_data_structures/sip128.rs, and add `write_u*`/`write_i*`\n@@ -342,7 +340,7 @@ impl<S: ~const Sip> const super::Hasher for Hasher<S> {\n     }\n }\n \n-impl<S: Sip> const Clone for Hasher<S> {\n+impl<S: Sip> Clone for Hasher<S> {\n     #[inline]\n     fn clone(&self) -> Hasher<S> {\n         Hasher {\n@@ -366,7 +364,6 @@ impl<S: Sip> Default for Hasher<S> {\n }\n \n #[doc(hidden)]\n-#[const_trait]\n trait Sip {\n     fn c_rounds(_: &mut State);\n     fn d_rounds(_: &mut State);\n@@ -375,7 +372,7 @@ trait Sip {\n #[derive(Debug, Clone, Default)]\n struct Sip13Rounds;\n \n-impl const Sip for Sip13Rounds {\n+impl Sip for Sip13Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);\n@@ -392,7 +389,7 @@ impl const Sip for Sip13Rounds {\n #[derive(Debug, Clone, Default)]\n struct Sip24Rounds;\n \n-impl const Sip for Sip24Rounds {\n+impl Sip for Sip24Rounds {\n     #[inline]\n     fn c_rounds(state: &mut State) {\n         compress!(state);"}, {"sha": "5774107f5207f7a9d04247b41cf5b1e2f9dbb2fc", "filename": "library/core/src/internal_macros.rs", "status": "modified", "additions": 4, "deletions": 67, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Finternal_macros.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -1,23 +1,10 @@\n // implements the unary operator \"op &T\"\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n-    (impl const $imp:ident, $method:ident for $t:ty) => {\n-        forward_ref_unop!(impl const $imp, $method for $t,\n+    (impl $imp:ident, $method:ident for $t:ty) => {\n+        forward_ref_unop!(impl $imp, $method for $t,\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n     };\n-    // Equivalent to the non-const version, with the addition of `rustc_const_unstable`\n-    (impl const $imp:ident, $method:ident for $t:ty, #[$attr:meta]) => {\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp for &$t {\n-            type Output = <$t as $imp>::Output;\n-\n-            #[inline]\n-            fn $method(self) -> <$t as $imp>::Output {\n-                $imp::$method(*self)\n-            }\n-        }\n-    };\n     (impl $imp:ident, $method:ident for $t:ty, #[$attr:meta]) => {\n         #[$attr]\n         impl $imp for &$t {\n@@ -34,45 +21,10 @@ macro_rules! forward_ref_unop {\n // implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        forward_ref_binop!(impl const $imp, $method for $t, $u,\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        forward_ref_binop!(impl $imp, $method for $t, $u,\n                 #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n     };\n-    // Equivalent to the non-const version, with the addition of `rustc_const_unstable`\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl<'a> const $imp<$u> for &'a $t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(*self, other)\n-            }\n-        }\n-\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp<&$u> for $t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(self, *other)\n-            }\n-        }\n-\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp<&$u> for &$t {\n-            type Output = <$t as $imp<$u>>::Output;\n-\n-            #[inline]\n-            fn $method(self, other: &$u) -> <$t as $imp<$u>>::Output {\n-                $imp::$method(*self, *other)\n-            }\n-        }\n-    };\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n         #[$attr]\n         impl<'a> $imp<$u> for &'a $t {\n@@ -113,21 +65,6 @@ macro_rules! forward_ref_op_assign {\n         forward_ref_op_assign!(impl $imp, $method for $t, $u,\n                 #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n     };\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        forward_ref_op_assign!(impl const $imp, $method for $t, $u,\n-                #[stable(feature = \"op_assign_builtins_by_ref\", since = \"1.22.0\")]);\n-    };\n-    // Equivalent to the non-const version, with the addition of `rustc_const_unstable`\n-    (impl const $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n-        #[$attr]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const $imp<&$u> for $t {\n-            #[inline]\n-            fn $method(&mut self, other: &$u) {\n-                $imp::$method(self, *other);\n-            }\n-        }\n-    };\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n         #[$attr]\n         impl $imp<&$u> for $t {"}, {"sha": "243df015f9a26e767c4435583be54e86dea5a07c", "filename": "library/core/src/iter/sources/empty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -81,8 +81,7 @@ impl<T> Clone for Empty<T> {\n // not #[derive] because that adds a Default bound on T,\n // which isn't necessary.\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Empty<T> {\n+impl<T> Default for Empty<T> {\n     fn default() -> Empty<T> {\n         Empty(marker::PhantomData)\n     }"}, {"sha": "76b3a32880d1b053046c3efcf9545f34be514121", "filename": "library/core/src/iter/traits/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fcollect.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -228,7 +228,6 @@ pub trait FromIterator<A>: Sized {\n #[rustc_diagnostic_item = \"IntoIterator\"]\n #[rustc_skip_array_during_method_dispatch]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait IntoIterator {\n     /// The type of the elements being iterated over.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -264,7 +263,7 @@ pub trait IntoIterator {\n \n #[rustc_const_unstable(feature = \"const_intoiterator_identity\", issue = \"90603\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> const IntoIterator for I {\n+impl<I: Iterator> IntoIterator for I {\n     type Item = I::Item;\n     type IntoIter = I;\n "}, {"sha": "dabfce1447483b9504333d137b4fc4ef3fdbbac6", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -70,7 +70,6 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n #[doc(notable_trait)]\n #[rustc_diagnostic_item = \"Iterator\"]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[const_trait]\n pub trait Iterator {\n     /// The type of the elements being iterated over.\n     #[rustc_diagnostic_item = \"IteratorItem\"]"}, {"sha": "8cc67c6a5260d2f2d165262aaf431843dbbe33e3", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -112,11 +112,8 @@\n #![feature(const_caller_location)]\n #![feature(const_cell_into_inner)]\n #![feature(const_char_from_u32_unchecked)]\n-#![feature(const_clone)]\n #![feature(const_cmp)]\n-#![feature(const_convert)]\n #![feature(const_cstr_methods)]\n-#![feature(const_default_impls)]\n #![feature(const_discriminant)]\n #![feature(const_eval_select)]\n #![feature(const_exact_div)]\n@@ -137,8 +134,6 @@\n #![feature(const_maybe_uninit_assume_init)]\n #![feature(const_maybe_uninit_uninit_array)]\n #![feature(const_nonnull_new)]\n-#![feature(const_num_from_num)]\n-#![feature(const_ops)]\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_pin)]\n@@ -161,7 +156,6 @@\n #![feature(const_slice_split_at_mut)]\n #![feature(const_str_from_utf8_unchecked_mut)]\n #![feature(const_swap)]\n-#![feature(const_trait_impl)]\n #![feature(const_transmute_copy)]\n #![feature(const_try)]\n #![feature(const_type_id)]\n@@ -209,7 +203,6 @@\n #![feature(const_refs_to_cell)]\n #![feature(decl_macro)]\n #![feature(deprecated_suggestion)]\n-#![feature(derive_const)]\n #![feature(doc_cfg)]\n #![feature(doc_cfg_hide)]\n #![feature(doc_notable_trait)]"}, {"sha": "d149ea0320993f25530b6e06d09269b0c96933e4", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -732,8 +732,7 @@ impl<T: ?Sized> Clone for PhantomData<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T: ?Sized> const Default for PhantomData<T> {\n+impl<T: ?Sized> Default for PhantomData<T> {\n     fn default() -> Self {\n         Self\n     }\n@@ -858,7 +857,6 @@ impl<T: ?Sized> Unpin for *mut T {}\n #[unstable(feature = \"const_trait_impl\", issue = \"67792\")]\n #[lang = \"destruct\"]\n #[rustc_on_unimplemented(message = \"can't drop `{Self}`\", append_const_msg)]\n-#[const_trait]\n #[rustc_deny_explicit_impl]\n pub trait Destruct {}\n "}, {"sha": "5f3d66e3773f1edf257e2e8dd0cbdabdb09c9d50", "filename": "library/core/src/mem/manually_drop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -146,8 +146,7 @@ impl<T: ?Sized> ManuallyDrop<T> {\n }\n \n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const Deref for ManuallyDrop<T> {\n+impl<T: ?Sized> Deref for ManuallyDrop<T> {\n     type Target = T;\n     #[inline(always)]\n     fn deref(&self) -> &T {\n@@ -156,8 +155,7 @@ impl<T: ?Sized> const Deref for ManuallyDrop<T> {\n }\n \n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const DerefMut for ManuallyDrop<T> {\n+impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     #[inline(always)]\n     fn deref_mut(&mut self) -> &mut T {\n         &mut self.value"}, {"sha": "87ae30619c63bc091aec8e65c223f943905530de", "filename": "library/core/src/mem/transmutability.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Ftransmutability.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -81,8 +81,7 @@ impl Assume {\n // FIXME(jswrenn): This const op is not actually usable. Why?\n // https://github.com/rust-lang/rust/pull/100726#issuecomment-1219928926\n #[unstable(feature = \"transmutability\", issue = \"99571\")]\n-#[rustc_const_unstable(feature = \"transmutability\", issue = \"99571\")]\n-impl const core::ops::Add for Assume {\n+impl core::ops::Add for Assume {\n     type Output = Assume;\n \n     fn add(self, other_assumptions: Assume) -> Assume {\n@@ -93,8 +92,7 @@ impl const core::ops::Add for Assume {\n // FIXME(jswrenn): This const op is not actually usable. Why?\n // https://github.com/rust-lang/rust/pull/100726#issuecomment-1219928926\n #[unstable(feature = \"transmutability\", issue = \"99571\")]\n-#[rustc_const_unstable(feature = \"transmutability\", issue = \"99571\")]\n-impl const core::ops::Sub for Assume {\n+impl core::ops::Sub for Assume {\n     type Output = Assume;\n \n     fn sub(self, other_assumptions: Assume) -> Assume {"}, {"sha": "2ad0f1dc5063e05ad1e8be800c6d436b3ea26a12", "filename": "library/core/src/num/error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ferror.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -26,15 +26,14 @@ impl Error for TryFromIntError {\n }\n \n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<Infallible> for TryFromIntError {\n+impl From<Infallible> for TryFromIntError {\n     fn from(x: Infallible) -> TryFromIntError {\n         match x {}\n     }\n }\n \n #[unstable(feature = \"never_type\", issue = \"35121\")]\n-impl const From<!> for TryFromIntError {\n+impl From<!> for TryFromIntError {\n     fn from(never: !) -> TryFromIntError {\n         // Match rather than coerce to make sure that code like\n         // `From<Infallible> for TryFromIntError` above will keep working"}, {"sha": "54e03067d1c7ae5ed260a420022cbb56b3d0d7d1", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -96,8 +96,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"from_nonzero\", since = \"1.31.0\")]\n-            #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-            impl const From<$Ty> for $Int {\n+            impl From<$Ty> for $Int {\n                 #[doc = concat!(\"Converts a `\", stringify!($Ty), \"` into an `\", stringify!($Int), \"`\")]\n                 #[inline]\n                 fn from(nonzero: $Ty) -> Self {\n@@ -106,8 +105,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOr for $Ty {\n+            impl BitOr for $Ty {\n                 type Output = Self;\n                 #[inline]\n                 fn bitor(self, rhs: Self) -> Self::Output {\n@@ -118,8 +116,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOr<$Int> for $Ty {\n+            impl BitOr<$Int> for $Ty {\n                 type Output = Self;\n                 #[inline]\n                 fn bitor(self, rhs: $Int) -> Self::Output {\n@@ -131,8 +128,7 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOr<$Ty> for $Int {\n+            impl BitOr<$Ty> for $Int {\n                 type Output = $Ty;\n                 #[inline]\n                 fn bitor(self, rhs: $Ty) -> Self::Output {\n@@ -144,17 +140,15 @@ macro_rules! nonzero_integers {\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOrAssign for $Ty {\n+            impl BitOrAssign for $Ty {\n                 #[inline]\n                 fn bitor_assign(&mut self, rhs: Self) {\n                     *self = *self | rhs;\n                 }\n             }\n \n             #[stable(feature = \"nonzero_bitor\", since = \"1.45.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const BitOrAssign<$Int> for $Ty {\n+            impl BitOrAssign<$Int> for $Ty {\n                 #[inline]\n                 fn bitor_assign(&mut self, rhs: $Int) {\n                     *self = *self | rhs;\n@@ -276,8 +270,7 @@ macro_rules! nonzero_integers_div {\n     ( $( $Ty: ident($Int: ty); )+ ) => {\n         $(\n             #[stable(feature = \"nonzero_div\", since = \"1.51.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const Div<$Ty> for $Int {\n+            impl Div<$Ty> for $Int {\n                 type Output = $Int;\n                 /// This operation rounds towards zero,\n                 /// truncating any fractional part of the exact result, and cannot panic.\n@@ -290,8 +283,7 @@ macro_rules! nonzero_integers_div {\n             }\n \n             #[stable(feature = \"nonzero_div\", since = \"1.51.0\")]\n-            #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-            impl const Rem<$Ty> for $Int {\n+            impl Rem<$Ty> for $Int {\n                 type Output = $Int;\n                 /// This operation satisfies `n % d == n - (n / d) * d`, and cannot panic.\n                 #[inline]"}, {"sha": "ed354a2e50bda9b4c4cabb9b1a626e0cb3e7bd75", "filename": "library/core/src/num/wrapping.rs", "status": "modified", "additions": 67, "deletions": 101, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fwrapping.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -87,8 +87,7 @@ impl<T: fmt::UpperHex> fmt::UpperHex for Wrapping<T> {\n macro_rules! sh_impl_signed {\n     ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shl<$f> for Wrapping<$t> {\n+        impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n@@ -100,22 +99,20 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n-        forward_ref_binop! { impl const Shl, shl for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShlAssign<$f> for Wrapping<$t> {\n+        impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shl_assign(&mut self, other: $f) {\n                 *self = *self << other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShlAssign, shl_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shr<$f> for Wrapping<$t> {\n+        impl Shr<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n@@ -127,68 +124,63 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n-        forward_ref_binop! { impl const Shr, shr for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShrAssign<$f> for Wrapping<$t> {\n+        impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shr_assign(&mut self, other: $f) {\n                 *self = *self >> other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShrAssign, shr_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     };\n }\n \n macro_rules! sh_impl_unsigned {\n     ($t:ident, $f:ident) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shl<$f> for Wrapping<$t> {\n+        impl Shl<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn shl(self, other: $f) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n-        forward_ref_binop! { impl const Shl, shl for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShlAssign<$f> for Wrapping<$t> {\n+        impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shl_assign(&mut self, other: $f) {\n                 *self = *self << other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShlAssign, shl_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Wrapping<$t>, $f }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shr<$f> for Wrapping<$t> {\n+        impl Shr<$f> for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn shr(self, other: $f) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n-        forward_ref_binop! { impl const Shr, shr for Wrapping<$t>, $f,\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n         #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShrAssign<$f> for Wrapping<$t> {\n+        impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline]\n             fn shr_assign(&mut self, other: $f) {\n                 *self = *self >> other;\n             }\n         }\n-        forward_ref_op_assign! { impl const ShrAssign, shr_assign for Wrapping<$t>, $f }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Wrapping<$t>, $f }\n     };\n }\n \n@@ -217,74 +209,67 @@ sh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n macro_rules! wrapping_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Add for Wrapping<$t> {\n+        impl Add for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn add(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_add(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Add, add for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Add, add for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const AddAssign for Wrapping<$t> {\n+        impl AddAssign for Wrapping<$t> {\n             #[inline]\n             fn add_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self + other;\n             }\n         }\n-        forward_ref_op_assign! { impl const AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const AddAssign<$t> for Wrapping<$t> {\n+        impl AddAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn add_assign(&mut self, other: $t) {\n                 *self = *self + Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const AddAssign, add_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Sub for Wrapping<$t> {\n+        impl Sub for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn sub(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_sub(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Sub, sub for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Sub, sub for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const SubAssign for Wrapping<$t> {\n+        impl SubAssign for Wrapping<$t> {\n             #[inline]\n             fn sub_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self - other;\n             }\n         }\n-        forward_ref_op_assign! { impl const SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const SubAssign<$t> for Wrapping<$t> {\n+        impl SubAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn sub_assign(&mut self, other: $t) {\n                 *self = *self - Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const SubAssign, sub_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Mul for Wrapping<$t> {\n+        impl Mul for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n@@ -296,213 +281,194 @@ macro_rules! wrapping_impl {\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const MulAssign for Wrapping<$t> {\n+        impl MulAssign for Wrapping<$t> {\n             #[inline]\n             fn mul_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self * other;\n             }\n         }\n-        forward_ref_op_assign! { impl const MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const MulAssign<$t> for Wrapping<$t> {\n+        impl MulAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn mul_assign(&mut self, other: $t) {\n                 *self = *self * Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const MulAssign, mul_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"wrapping_div\", since = \"1.3.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Div for Wrapping<$t> {\n+        impl Div for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn div(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_div(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Div, div for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Div, div for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const DivAssign for Wrapping<$t> {\n+        impl DivAssign for Wrapping<$t> {\n             #[inline]\n             fn div_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self / other;\n             }\n         }\n-        forward_ref_op_assign! { impl const DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const DivAssign<$t> for Wrapping<$t> {\n+        impl DivAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn div_assign(&mut self, other: $t) {\n                 *self = *self / Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const DivAssign, div_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Rem for Wrapping<$t> {\n+        impl Rem for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0.wrapping_rem(other.0))\n             }\n         }\n-        forward_ref_binop! { impl const Rem, rem for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl Rem, rem for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const RemAssign for Wrapping<$t> {\n+        impl RemAssign for Wrapping<$t> {\n             #[inline]\n             fn rem_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self % other;\n             }\n         }\n-        forward_ref_op_assign! { impl const RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const RemAssign<$t> for Wrapping<$t> {\n+        impl RemAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn rem_assign(&mut self, other: $t) {\n                 *self = *self % Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const RemAssign, rem_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Not for Wrapping<$t> {\n+        impl Not for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn not(self) -> Wrapping<$t> {\n                 Wrapping(!self.0)\n             }\n         }\n-        forward_ref_unop! { impl const Not, not for Wrapping<$t>,\n+        forward_ref_unop! { impl Not, not for Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXor for Wrapping<$t> {\n+        impl BitXor for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn bitxor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 ^ other.0)\n             }\n         }\n-        forward_ref_binop! { impl const BitXor, bitxor for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl BitXor, bitxor for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXorAssign for Wrapping<$t> {\n+        impl BitXorAssign for Wrapping<$t> {\n             #[inline]\n             fn bitxor_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self ^ other;\n             }\n         }\n-        forward_ref_op_assign! { impl const BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXorAssign<$t> for Wrapping<$t> {\n+        impl BitXorAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn bitxor_assign(&mut self, other: $t) {\n                 *self = *self ^ Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const BitXorAssign, bitxor_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOr for Wrapping<$t> {\n+        impl BitOr for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn bitor(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 | other.0)\n             }\n         }\n-        forward_ref_binop! { impl const BitOr, bitor for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl BitOr, bitor for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOrAssign for Wrapping<$t> {\n+        impl BitOrAssign for Wrapping<$t> {\n             #[inline]\n             fn bitor_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self | other;\n             }\n         }\n-        forward_ref_op_assign! { impl const BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOrAssign<$t> for Wrapping<$t> {\n+        impl BitOrAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn bitor_assign(&mut self, other: $t) {\n                 *self = *self | Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const BitOrAssign, bitor_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAnd for Wrapping<$t> {\n+        impl BitAnd for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n             #[inline]\n             fn bitand(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                 Wrapping(self.0 & other.0)\n             }\n         }\n-        forward_ref_binop! { impl const BitAnd, bitand for Wrapping<$t>, Wrapping<$t>,\n+        forward_ref_binop! { impl BitAnd, bitand for Wrapping<$t>, Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAndAssign for Wrapping<$t> {\n+        impl BitAndAssign for Wrapping<$t> {\n             #[inline]\n             fn bitand_assign(&mut self, other: Wrapping<$t>) {\n                 *self = *self & other;\n             }\n         }\n-        forward_ref_op_assign! { impl const BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, Wrapping<$t> }\n \n         #[stable(feature = \"wrapping_int_assign_impl\", since = \"1.60.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAndAssign<$t> for Wrapping<$t> {\n+        impl BitAndAssign<$t> for Wrapping<$t> {\n             #[inline]\n             fn bitand_assign(&mut self, other: $t) {\n                 *self = *self & Wrapping(other);\n             }\n         }\n-        forward_ref_op_assign! { impl const BitAndAssign, bitand_assign for Wrapping<$t>, $t }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Wrapping<$t>, $t }\n \n         #[stable(feature = \"wrapping_neg\", since = \"1.10.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Neg for Wrapping<$t> {\n+        impl Neg for Wrapping<$t> {\n             type Output = Self;\n             #[inline]\n             fn neg(self) -> Self {\n                 Wrapping(0) - self\n             }\n         }\n-        forward_ref_unop! { impl const Neg, neg for Wrapping<$t>,\n+        forward_ref_unop! { impl Neg, neg for Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n \n     )*)"}, {"sha": "1501dc4e38b710e5fcc432413f7be0445a375740", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 26, "deletions": 50, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -73,7 +73,6 @@\n     append_const_msg\n )]\n #[doc(alias = \"+\")]\n-#[const_trait]\n pub trait Add<Rhs = Self> {\n     /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -95,16 +94,15 @@ pub trait Add<Rhs = Self> {\n macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Add for $t {\n+        impl Add for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn add(self, other: $t) -> $t { self + other }\n         }\n \n-        forward_ref_binop! { impl const Add, add for $t, $t }\n+        forward_ref_binop! { impl Add, add for $t, $t }\n     )*)\n }\n \n@@ -183,7 +181,6 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n     append_const_msg\n )]\n #[doc(alias = \"-\")]\n-#[const_trait]\n pub trait Sub<Rhs = Self> {\n     /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -205,16 +202,15 @@ pub trait Sub<Rhs = Self> {\n macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Sub for $t {\n+        impl Sub for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn sub(self, other: $t) -> $t { self - other }\n         }\n \n-        forward_ref_binop! { impl const Sub, sub for $t, $t }\n+        forward_ref_binop! { impl Sub, sub for $t, $t }\n     )*)\n }\n \n@@ -314,7 +310,6 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n     label = \"no implementation for `{Self} * {Rhs}`\"\n )]\n #[doc(alias = \"*\")]\n-#[const_trait]\n pub trait Mul<Rhs = Self> {\n     /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -336,16 +331,15 @@ pub trait Mul<Rhs = Self> {\n macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Mul for $t {\n+        impl Mul for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn mul(self, other: $t) -> $t { self * other }\n         }\n \n-        forward_ref_binop! { impl const Mul, mul for $t, $t }\n+        forward_ref_binop! { impl Mul, mul for $t, $t }\n     )*)\n }\n \n@@ -449,7 +443,6 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n     label = \"no implementation for `{Self} / {Rhs}`\"\n )]\n #[doc(alias = \"/\")]\n-#[const_trait]\n pub trait Div<Rhs = Self> {\n     /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -477,15 +470,14 @@ macro_rules! div_impl_integer {\n         ///\n         #[doc = $panic]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Div for $t {\n+        impl Div for $t {\n             type Output = $t;\n \n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n \n-        forward_ref_binop! { impl const Div, div for $t, $t }\n+        forward_ref_binop! { impl Div, div for $t, $t }\n     )*)*)\n }\n \n@@ -497,15 +489,14 @@ div_impl_integer! {\n macro_rules! div_impl_float {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Div for $t {\n+        impl Div for $t {\n             type Output = $t;\n \n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n \n-        forward_ref_binop! { impl const Div, div for $t, $t }\n+        forward_ref_binop! { impl Div, div for $t, $t }\n     )*)\n }\n \n@@ -553,7 +544,6 @@ div_impl_float! { f32 f64 }\n     label = \"no implementation for `{Self} % {Rhs}`\"\n )]\n #[doc(alias = \"%\")]\n-#[const_trait]\n pub trait Rem<Rhs = Self> {\n     /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -581,15 +571,14 @@ macro_rules! rem_impl_integer {\n         ///\n         #[doc = $panic]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Rem for $t {\n+        impl Rem for $t {\n             type Output = $t;\n \n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n \n-        forward_ref_binop! { impl const Rem, rem for $t, $t }\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     )*)*)\n }\n \n@@ -616,15 +605,14 @@ macro_rules! rem_impl_float {\n         /// assert_eq!(x % y, remainder);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Rem for $t {\n+        impl Rem for $t {\n             type Output = $t;\n \n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n \n-        forward_ref_binop! { impl const Rem, rem for $t, $t }\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     )*)\n }\n \n@@ -669,7 +657,6 @@ rem_impl_float! { f32 f64 }\n #[lang = \"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"-\")]\n-#[const_trait]\n pub trait Neg {\n     /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -692,16 +679,15 @@ pub trait Neg {\n macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Neg for $t {\n+        impl Neg for $t {\n             type Output = $t;\n \n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn neg(self) -> $t { -self }\n         }\n \n-        forward_ref_unop! { impl const Neg, neg for $t }\n+        forward_ref_unop! { impl Neg, neg for $t }\n     )*)\n }\n \n@@ -744,7 +730,6 @@ neg_impl! { isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"+\")]\n #[doc(alias = \"+=\")]\n-#[const_trait]\n pub trait AddAssign<Rhs = Self> {\n     /// Performs the `+=` operation.\n     ///\n@@ -762,14 +747,13 @@ pub trait AddAssign<Rhs = Self> {\n macro_rules! add_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const AddAssign for $t {\n+        impl AddAssign for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn add_assign(&mut self, other: $t) { *self += other }\n         }\n \n-        forward_ref_op_assign! { impl const AddAssign, add_assign for $t, $t }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for $t, $t }\n     )+)\n }\n \n@@ -812,7 +796,6 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"-\")]\n #[doc(alias = \"-=\")]\n-#[const_trait]\n pub trait SubAssign<Rhs = Self> {\n     /// Performs the `-=` operation.\n     ///\n@@ -830,14 +813,13 @@ pub trait SubAssign<Rhs = Self> {\n macro_rules! sub_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const SubAssign for $t {\n+        impl SubAssign for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn sub_assign(&mut self, other: $t) { *self -= other }\n         }\n \n-        forward_ref_op_assign! { impl const SubAssign, sub_assign for $t, $t }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for $t, $t }\n     )+)\n }\n \n@@ -871,7 +853,6 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"*\")]\n #[doc(alias = \"*=\")]\n-#[const_trait]\n pub trait MulAssign<Rhs = Self> {\n     /// Performs the `*=` operation.\n     ///\n@@ -889,14 +870,13 @@ pub trait MulAssign<Rhs = Self> {\n macro_rules! mul_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const MulAssign for $t {\n+        impl MulAssign for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn mul_assign(&mut self, other: $t) { *self *= other }\n         }\n \n-        forward_ref_op_assign! { impl const MulAssign, mul_assign for $t, $t }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for $t, $t }\n     )+)\n }\n \n@@ -930,7 +910,6 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"/\")]\n #[doc(alias = \"/=\")]\n-#[const_trait]\n pub trait DivAssign<Rhs = Self> {\n     /// Performs the `/=` operation.\n     ///\n@@ -948,13 +927,12 @@ pub trait DivAssign<Rhs = Self> {\n macro_rules! div_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const DivAssign for $t {\n+        impl DivAssign for $t {\n             #[inline]\n             fn div_assign(&mut self, other: $t) { *self /= other }\n         }\n \n-        forward_ref_op_assign! { impl const DivAssign, div_assign for $t, $t }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for $t, $t }\n     )+)\n }\n \n@@ -992,7 +970,6 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n )]\n #[doc(alias = \"%\")]\n #[doc(alias = \"%=\")]\n-#[const_trait]\n pub trait RemAssign<Rhs = Self> {\n     /// Performs the `%=` operation.\n     ///\n@@ -1010,13 +987,12 @@ pub trait RemAssign<Rhs = Self> {\n macro_rules! rem_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const RemAssign for $t {\n+        impl RemAssign for $t {\n             #[inline]\n             fn rem_assign(&mut self, other: $t) { *self %= other }\n         }\n \n-        forward_ref_op_assign! { impl const RemAssign, rem_assign for $t, $t }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for $t, $t }\n     )+)\n }\n "}, {"sha": "c70f4a3da2ed8fe2627bf3ee65af701fb750ee21", "filename": "library/core/src/ops/bit.rs", "status": "modified", "additions": 23, "deletions": 46, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fbit.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -31,7 +31,6 @@\n #[lang = \"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"!\")]\n-#[const_trait]\n pub trait Not {\n     /// The resulting type after applying the `!` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -55,23 +54,21 @@ pub trait Not {\n macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Not for $t {\n+        impl Not for $t {\n             type Output = $t;\n \n             #[inline]\n             fn not(self) -> $t { !self }\n         }\n \n-        forward_ref_unop! { impl const Not, not for $t }\n+        forward_ref_unop! { impl Not, not for $t }\n     )*)\n }\n \n not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n #[stable(feature = \"not_never\", since = \"1.60.0\")]\n-#[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-impl const Not for ! {\n+impl Not for ! {\n     type Output = !;\n \n     #[inline]\n@@ -144,7 +141,6 @@ impl const Not for ! {\n     message = \"no implementation for `{Self} & {Rhs}`\",\n     label = \"no implementation for `{Self} & {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitAnd<Rhs = Self> {\n     /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -168,15 +164,14 @@ pub trait BitAnd<Rhs = Self> {\n macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAnd for $t {\n+        impl BitAnd for $t {\n             type Output = $t;\n \n             #[inline]\n             fn bitand(self, rhs: $t) -> $t { self & rhs }\n         }\n \n-        forward_ref_binop! { impl const BitAnd, bitand for $t, $t }\n+        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n     )*)\n }\n \n@@ -246,7 +241,6 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} | {Rhs}`\",\n     label = \"no implementation for `{Self} | {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitOr<Rhs = Self> {\n     /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -270,15 +264,14 @@ pub trait BitOr<Rhs = Self> {\n macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOr for $t {\n+        impl BitOr for $t {\n             type Output = $t;\n \n             #[inline]\n             fn bitor(self, rhs: $t) -> $t { self | rhs }\n         }\n \n-        forward_ref_binop! { impl const BitOr, bitor for $t, $t }\n+        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n     )*)\n }\n \n@@ -348,7 +341,6 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} ^ {Rhs}`\",\n     label = \"no implementation for `{Self} ^ {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitXor<Rhs = Self> {\n     /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -372,15 +364,14 @@ pub trait BitXor<Rhs = Self> {\n macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXor for $t {\n+        impl BitXor for $t {\n             type Output = $t;\n \n             #[inline]\n             fn bitxor(self, other: $t) -> $t { self ^ other }\n         }\n \n-        forward_ref_binop! { impl const BitXor, bitxor for $t, $t }\n+        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n     )*)\n }\n \n@@ -449,7 +440,6 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} << {Rhs}`\",\n     label = \"no implementation for `{Self} << {Rhs}`\"\n )]\n-#[const_trait]\n pub trait Shl<Rhs = Self> {\n     /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -471,8 +461,7 @@ pub trait Shl<Rhs = Self> {\n macro_rules! shl_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shl<$f> for $t {\n+        impl Shl<$f> for $t {\n             type Output = $t;\n \n             #[inline]\n@@ -482,7 +471,7 @@ macro_rules! shl_impl {\n             }\n         }\n \n-        forward_ref_binop! { impl const Shl, shl for $t, $f }\n+        forward_ref_binop! { impl Shl, shl for $t, $f }\n     };\n }\n \n@@ -569,7 +558,6 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n     message = \"no implementation for `{Self} >> {Rhs}`\",\n     label = \"no implementation for `{Self} >> {Rhs}`\"\n )]\n-#[const_trait]\n pub trait Shr<Rhs = Self> {\n     /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -591,8 +579,7 @@ pub trait Shr<Rhs = Self> {\n macro_rules! shr_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const Shr<$f> for $t {\n+        impl Shr<$f> for $t {\n             type Output = $t;\n \n             #[inline]\n@@ -602,7 +589,7 @@ macro_rules! shr_impl {\n             }\n         }\n \n-        forward_ref_binop! { impl const Shr, shr for $t, $f }\n+        forward_ref_binop! { impl Shr, shr for $t, $f }\n     };\n }\n \n@@ -698,7 +685,6 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n     message = \"no implementation for `{Self} &= {Rhs}`\",\n     label = \"no implementation for `{Self} &= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitAndAssign<Rhs = Self> {\n     /// Performs the `&=` operation.\n     ///\n@@ -728,13 +714,12 @@ pub trait BitAndAssign<Rhs = Self> {\n macro_rules! bitand_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitAndAssign for $t {\n+        impl BitAndAssign for $t {\n             #[inline]\n             fn bitand_assign(&mut self, other: $t) { *self &= other }\n         }\n \n-        forward_ref_op_assign! { impl const BitAndAssign, bitand_assign for $t, $t }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for $t, $t }\n     )+)\n }\n \n@@ -771,7 +756,6 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} |= {Rhs}`\",\n     label = \"no implementation for `{Self} |= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitOrAssign<Rhs = Self> {\n     /// Performs the `|=` operation.\n     ///\n@@ -801,13 +785,12 @@ pub trait BitOrAssign<Rhs = Self> {\n macro_rules! bitor_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitOrAssign for $t {\n+        impl BitOrAssign for $t {\n             #[inline]\n             fn bitor_assign(&mut self, other: $t) { *self |= other }\n         }\n \n-        forward_ref_op_assign! { impl const BitOrAssign, bitor_assign for $t, $t }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for $t, $t }\n     )+)\n }\n \n@@ -844,7 +827,6 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} ^= {Rhs}`\",\n     label = \"no implementation for `{Self} ^= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait BitXorAssign<Rhs = Self> {\n     /// Performs the `^=` operation.\n     ///\n@@ -874,13 +856,12 @@ pub trait BitXorAssign<Rhs = Self> {\n macro_rules! bitxor_assign_impl {\n     ($($t:ty)+) => ($(\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const BitXorAssign for $t {\n+        impl BitXorAssign for $t {\n             #[inline]\n             fn bitxor_assign(&mut self, other: $t) { *self ^= other }\n         }\n \n-        forward_ref_op_assign! { impl const BitXorAssign, bitxor_assign for $t, $t }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for $t, $t }\n     )+)\n }\n \n@@ -915,7 +896,6 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n     message = \"no implementation for `{Self} <<= {Rhs}`\",\n     label = \"no implementation for `{Self} <<= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait ShlAssign<Rhs = Self> {\n     /// Performs the `<<=` operation.\n     ///\n@@ -937,16 +917,15 @@ pub trait ShlAssign<Rhs = Self> {\n macro_rules! shl_assign_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShlAssign<$f> for $t {\n+        impl ShlAssign<$f> for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn shl_assign(&mut self, other: $f) {\n                 *self <<= other\n             }\n         }\n \n-        forward_ref_op_assign! { impl const ShlAssign, shl_assign for $t, $f }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for $t, $f }\n     };\n }\n \n@@ -999,7 +978,6 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n     message = \"no implementation for `{Self} >>= {Rhs}`\",\n     label = \"no implementation for `{Self} >>= {Rhs}`\"\n )]\n-#[const_trait]\n pub trait ShrAssign<Rhs = Self> {\n     /// Performs the `>>=` operation.\n     ///\n@@ -1021,16 +999,15 @@ pub trait ShrAssign<Rhs = Self> {\n macro_rules! shr_assign_impl {\n     ($t:ty, $f:ty) => {\n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        #[rustc_const_unstable(feature = \"const_ops\", issue = \"90080\")]\n-        impl const ShrAssign<$f> for $t {\n+        impl ShrAssign<$f> for $t {\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn shr_assign(&mut self, other: $f) {\n                 *self >>= other\n             }\n         }\n \n-        forward_ref_op_assign! { impl const ShrAssign, shr_assign for $t, $f }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for $t, $f }\n     };\n }\n "}, {"sha": "e10c438ef43008a5299dc19c1d962b788adbc7c7", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -97,8 +97,7 @@ pub enum ControlFlow<B, C = ()> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<B, C> const ops::Try for ControlFlow<B, C> {\n+impl<B, C> ops::Try for ControlFlow<B, C> {\n     type Output = C;\n     type Residual = ControlFlow<B, convert::Infallible>;\n \n@@ -117,8 +116,7 @@ impl<B, C> const ops::Try for ControlFlow<B, C> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<B, C> const ops::FromResidual for ControlFlow<B, C> {\n+impl<B, C> ops::FromResidual for ControlFlow<B, C> {\n     #[inline]\n     fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {\n         match residual {\n@@ -128,8 +126,7 @@ impl<B, C> const ops::FromResidual for ControlFlow<B, C> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n-impl<B, C> const ops::Residual<C> for ControlFlow<B, convert::Infallible> {\n+impl<B, C> ops::Residual<C> for ControlFlow<B, convert::Infallible> {\n     type TryType = ControlFlow<B, C>;\n }\n "}, {"sha": "08c35b6dac309368a7f898375f83c587a1997a04", "filename": "library/core/src/ops/deref.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fderef.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -61,7 +61,6 @@\n #[doc(alias = \"&*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Deref\"]\n-#[const_trait]\n pub trait Deref {\n     /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -77,8 +76,7 @@ pub trait Deref {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const Deref for &T {\n+impl<T: ?Sized> Deref for &T {\n     type Target = T;\n \n     #[rustc_diagnostic_item = \"noop_method_deref\"]\n@@ -91,8 +89,7 @@ impl<T: ?Sized> const Deref for &T {\n impl<T: ?Sized> !DerefMut for &T {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_deref\", issue = \"88955\")]\n-impl<T: ?Sized> const Deref for &mut T {\n+impl<T: ?Sized> Deref for &mut T {\n     type Target = T;\n \n     fn deref(&self) -> &T {\n@@ -170,7 +167,6 @@ impl<T: ?Sized> const Deref for &mut T {\n #[lang = \"deref_mut\"]\n #[doc(alias = \"*\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait DerefMut: Deref {\n     /// Mutably dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "de9ddb852df31d8da34a5eda646d42a6bb4fa511", "filename": "library/core/src/ops/drop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fdrop.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -134,7 +134,6 @@\n /// these types cannot have destructors.\n #[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[const_trait]\n pub trait Drop {\n     /// Executes the destructor for this type.\n     ///"}, {"sha": "6c16776b2c209c98b75e803e2c203d5b1ab86a2e", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -72,7 +72,6 @@ use crate::marker::Tuple;\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n pub trait Fn<Args: Tuple>: FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -159,7 +158,6 @@ pub trait Fn<Args: Tuple>: FnMut<Args> {\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n@@ -238,7 +236,6 @@ pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-#[const_trait]\n pub trait FnOnce<Args: Tuple> {\n     /// The returned type after the call operator is used.\n     #[lang = \"fn_once_output\"]\n@@ -254,32 +251,29 @@ mod impls {\n     use crate::marker::Tuple;\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const Fn<A> for &F\n+    impl<A: Tuple, F: ?Sized> Fn<A> for &F\n     where\n-        F: ~const Fn<A>,\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnMut<A> for &F\n+    impl<A: Tuple, F: ?Sized> FnMut<A> for &F\n     where\n-        F: ~const Fn<A>,\n+        F: Fn<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (**self).call(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnOnce<A> for &F\n+    impl<A: Tuple, F: ?Sized> FnOnce<A> for &F\n     where\n-        F: ~const Fn<A>,\n+        F: Fn<A>,\n     {\n         type Output = F::Output;\n \n@@ -289,21 +283,19 @@ mod impls {\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnMut<A> for &mut F\n+    impl<A: Tuple, F: ?Sized> FnMut<A> for &mut F\n     where\n-        F: ~const FnMut<A>,\n+        F: FnMut<A>,\n     {\n         extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n             (*self).call_mut(args)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n-    impl<A: Tuple, F: ?Sized> const FnOnce<A> for &mut F\n+    impl<A: Tuple, F: ?Sized> FnOnce<A> for &mut F\n     where\n-        F: ~const FnMut<A>,\n+        F: FnMut<A>,\n     {\n         type Output = F::Output;\n         extern \"rust-call\" fn call_once(self, args: A) -> F::Output {"}, {"sha": "e2e569cb7ea81aa0ddc9a7e8da43ccc3c4711646", "filename": "library/core/src/ops/index.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Findex.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -55,7 +55,6 @@\n #[doc(alias = \"]\")]\n #[doc(alias = \"[\")]\n #[doc(alias = \"[]\")]\n-#[const_trait]\n pub trait Index<Idx: ?Sized> {\n     /// The returned type after indexing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -164,8 +163,7 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n #[doc(alias = \"[\")]\n #[doc(alias = \"]\")]\n #[doc(alias = \"[]\")]\n-#[const_trait]\n-pub trait IndexMut<Idx: ?Sized>: ~const Index<Idx> {\n+pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// Performs the mutable indexing (`container[index]`) operation.\n     ///\n     /// # Panics"}, {"sha": "6342e40c41c90ad18a56f39893c0a8159e9f06fc", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -96,7 +96,7 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> Range<Idx> {\n+impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -119,8 +119,8 @@ impl<Idx: ~const PartialOrd<Idx>> Range<Idx> {\n     #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n     pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -201,7 +201,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeFrom<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -216,11 +216,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeFrom<Idx> {\n     /// assert!(!(f32::NAN..).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -283,7 +282,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeTo<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -298,11 +297,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeTo<Idx> {\n     /// assert!(!(..f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -474,7 +472,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeInclusive<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -505,11 +503,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!r.contains(&3) && !r.contains(&5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -605,7 +602,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n-impl<Idx: ~const PartialOrd<Idx>> RangeToInclusive<Idx> {\n+impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -620,11 +617,10 @@ impl<Idx: ~const PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// assert!(!(..=f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-    pub const fn contains<U>(&self, item: &U) -> bool\n+    pub fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<Idx>,\n+        Idx: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -765,7 +761,6 @@ impl<T: Clone> Bound<&T> {\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[const_trait]\n pub trait RangeBounds<T: ?Sized> {\n     /// Start index bound.\n     ///\n@@ -818,8 +813,8 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     fn contains<U>(&self, item: &U) -> bool\n     where\n-        T: ~const PartialOrd<U>,\n-        U: ?Sized + ~const PartialOrd<T>,\n+        T: PartialOrd<U>,\n+        U: ?Sized + PartialOrd<T>,\n     {\n         (match self.start_bound() {\n             Included(start) => start <= item,\n@@ -836,8 +831,7 @@ pub trait RangeBounds<T: ?Sized> {\n use self::Bound::{Excluded, Included, Unbounded};\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T: ?Sized> const RangeBounds<T> for RangeFull {\n+impl<T: ?Sized> RangeBounds<T> for RangeFull {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -847,8 +841,7 @@ impl<T: ?Sized> const RangeBounds<T> for RangeFull {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeFrom<T> {\n+impl<T> RangeBounds<T> for RangeFrom<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -858,8 +851,7 @@ impl<T> const RangeBounds<T> for RangeFrom<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeTo<T> {\n+impl<T> RangeBounds<T> for RangeTo<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -869,8 +861,7 @@ impl<T> const RangeBounds<T> for RangeTo<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for Range<T> {\n+impl<T> RangeBounds<T> for Range<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -880,8 +871,7 @@ impl<T> const RangeBounds<T> for Range<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeInclusive<T> {\n+impl<T> RangeBounds<T> for RangeInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -897,8 +887,7 @@ impl<T> const RangeBounds<T> for RangeInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeToInclusive<T> {\n+impl<T> RangeBounds<T> for RangeToInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -908,8 +897,7 @@ impl<T> const RangeBounds<T> for RangeToInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for (Bound<T>, Bound<T>) {\n+impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         match *self {\n             (Included(ref start), _) => Included(start),\n@@ -928,8 +916,7 @@ impl<T> const RangeBounds<T> for (Bound<T>, Bound<T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<'a, T: ?Sized + 'a> const RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n+impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         self.0\n     }\n@@ -940,8 +927,7 @@ impl<'a, T: ?Sized + 'a> const RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeFrom<&T> {\n+impl<T> RangeBounds<T> for RangeFrom<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -951,8 +937,7 @@ impl<T> const RangeBounds<T> for RangeFrom<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeTo<&T> {\n+impl<T> RangeBounds<T> for RangeTo<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -962,8 +947,7 @@ impl<T> const RangeBounds<T> for RangeTo<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for Range<&T> {\n+impl<T> RangeBounds<T> for Range<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -973,8 +957,7 @@ impl<T> const RangeBounds<T> for Range<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeInclusive<&T> {\n+impl<T> RangeBounds<T> for RangeInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -984,8 +967,7 @@ impl<T> const RangeBounds<T> for RangeInclusive<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n-impl<T> const RangeBounds<T> for RangeToInclusive<&T> {\n+impl<T> RangeBounds<T> for RangeToInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }"}, {"sha": "58cc1a408dae112f0b99a7bfe05e56c25aa418a5", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -128,8 +128,7 @@ use crate::ops::ControlFlow;\n )]\n #[doc(alias = \"?\")]\n #[lang = \"Try\"]\n-#[const_trait]\n-pub trait Try: ~const FromResidual {\n+pub trait Try: FromResidual {\n     /// The type of the value produced by `?` when *not* short-circuiting.\n     #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n     type Output;\n@@ -305,7 +304,6 @@ pub trait Try: ~const FromResidual {\n )]\n #[rustc_diagnostic_item = \"FromResidual\"]\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[const_trait]\n pub trait FromResidual<R = <Self as Try>::Residual> {\n     /// Constructs the type from a compatible `Residual` type.\n     ///\n@@ -358,11 +356,10 @@ where\n /// and in the other direction,\n /// `<Result<Infallible, E> as Residual<T>>::TryType = Result<T, E>`.\n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[const_trait]\n pub trait Residual<O> {\n     /// The \"return\" type of this meta-function.\n     #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-    type TryType: ~const Try<Output = O, Residual = Self>;\n+    type TryType: Try<Output = O, Residual = Self>;\n }\n \n #[unstable(feature = \"pub_crate_should_not_need_unstable_attr\", issue = \"none\")]\n@@ -390,15 +387,15 @@ impl<T> NeverShortCircuit<T> {\n \n     #[inline]\n     pub fn wrap_mut_2<A, B>(\n-        mut f: impl ~const FnMut(A, B) -> T,\n-    ) -> impl ~const FnMut(A, B) -> Self {\n-        const move |a, b| NeverShortCircuit(f(a, b))\n+        mut f: impl FnMut(A, B) -> T,\n+    ) -> impl FnMut(A, B) -> Self {\n+        move |a, b| NeverShortCircuit(f(a, b))\n     }\n }\n \n pub(crate) enum NeverShortCircuitResidual {}\n \n-impl<T> const Try for NeverShortCircuit<T> {\n+impl<T> Try for NeverShortCircuit<T> {\n     type Output = T;\n     type Residual = NeverShortCircuitResidual;\n \n@@ -413,14 +410,14 @@ impl<T> const Try for NeverShortCircuit<T> {\n     }\n }\n \n-impl<T> const FromResidual for NeverShortCircuit<T> {\n+impl<T> FromResidual for NeverShortCircuit<T> {\n     #[inline]\n     fn from_residual(never: NeverShortCircuitResidual) -> Self {\n         match never {}\n     }\n }\n \n-impl<T> const Residual<T> for NeverShortCircuitResidual {\n+impl<T> Residual<T> for NeverShortCircuitResidual {\n     type TryType = NeverShortCircuit<T>;\n }\n "}, {"sha": "6c6851d2e533dd5665faf8e1b1d211c2a3209f13", "filename": "library/core/src/option.rs", "status": "modified", "additions": 56, "deletions": 64, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -970,7 +970,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn unwrap_or(self, default: T) -> T\n     where\n-        T: ~const Destruct,\n+        T: Destruct,\n     {\n         match self {\n             Some(x) => x,\n@@ -992,8 +992,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn unwrap_or_else<F>(self, f: F) -> T\n     where\n-        F: ~const FnOnce() -> T,\n-        F: ~const Destruct,\n+        F: FnOnce() -> T,\n+        F: Destruct,\n     {\n         match self {\n             Some(x) => x,\n@@ -1025,7 +1025,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn unwrap_or_default(self) -> T\n     where\n-        T: ~const Default,\n+        T: Default,\n     {\n         match self {\n             Some(x) => x,\n@@ -1092,8 +1092,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn map<U, F>(self, f: F) -> Option<U>\n     where\n-        F: ~const FnOnce(T) -> U,\n-        F: ~const Destruct,\n+        F: FnOnce(T) -> U,\n+        F: Destruct,\n     {\n         match self {\n             Some(x) => Some(f(x)),\n@@ -1121,8 +1121,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn inspect<F>(self, f: F) -> Self\n     where\n-        F: ~const FnOnce(&T),\n-        F: ~const Destruct,\n+        F: FnOnce(&T),\n+        F: Destruct,\n     {\n         if let Some(ref x) = self {\n             f(x);\n@@ -1154,9 +1154,9 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn map_or<U, F>(self, default: U, f: F) -> U\n     where\n-        F: ~const FnOnce(T) -> U,\n-        F: ~const Destruct,\n-        U: ~const Destruct,\n+        F: FnOnce(T) -> U,\n+        F: Destruct,\n+        U: Destruct,\n     {\n         match self {\n             Some(t) => f(t),\n@@ -1183,10 +1183,10 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n     where\n-        D: ~const FnOnce() -> U,\n-        D: ~const Destruct,\n-        F: ~const FnOnce(T) -> U,\n-        F: ~const Destruct,\n+        D: FnOnce() -> U,\n+        D: Destruct,\n+        F: FnOnce(T) -> U,\n+        F: Destruct,\n     {\n         match self {\n             Some(t) => f(t),\n@@ -1220,7 +1220,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn ok_or<E>(self, err: E) -> Result<T, E>\n     where\n-        E: ~const Destruct,\n+        E: Destruct,\n     {\n         match self {\n             Some(v) => Ok(v),\n@@ -1249,8 +1249,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn ok_or_else<E, F>(self, err: F) -> Result<T, E>\n     where\n-        F: ~const FnOnce() -> E,\n-        F: ~const Destruct,\n+        F: FnOnce() -> E,\n+        F: Destruct,\n     {\n         match self {\n             Some(v) => Ok(v),\n@@ -1277,7 +1277,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn as_deref(&self) -> Option<&T::Target>\n     where\n-        T: ~const Deref,\n+        T: Deref,\n     {\n         match self.as_ref() {\n             Some(t) => Some(t.deref()),\n@@ -1304,7 +1304,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n     where\n-        T: ~const DerefMut,\n+        T: DerefMut,\n     {\n         match self.as_mut() {\n             Some(t) => Some(t.deref_mut()),\n@@ -1391,8 +1391,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn and<U>(self, optb: Option<U>) -> Option<U>\n     where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n+        T: Destruct,\n+        U: Destruct,\n     {\n         match self {\n             Some(_) => optb,\n@@ -1433,8 +1433,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn and_then<U, F>(self, f: F) -> Option<U>\n     where\n-        F: ~const FnOnce(T) -> Option<U>,\n-        F: ~const Destruct,\n+        F: FnOnce(T) -> Option<U>,\n+        F: Destruct,\n     {\n         match self {\n             Some(x) => f(x),\n@@ -1471,9 +1471,9 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn filter<P>(self, predicate: P) -> Self\n     where\n-        T: ~const Destruct,\n-        P: ~const FnOnce(&T) -> bool,\n-        P: ~const Destruct,\n+        T: Destruct,\n+        P: FnOnce(&T) -> bool,\n+        P: Destruct,\n     {\n         if let Some(x) = self {\n             if predicate(&x) {\n@@ -1515,7 +1515,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn or(self, optb: Option<T>) -> Option<T>\n     where\n-        T: ~const Destruct,\n+        T: Destruct,\n     {\n         match self {\n             Some(x) => Some(x),\n@@ -1541,8 +1541,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn or_else<F>(self, f: F) -> Option<T>\n     where\n-        F: ~const FnOnce() -> Option<T>,\n-        F: ~const Destruct,\n+        F: FnOnce() -> Option<T>,\n+        F: Destruct,\n     {\n         match self {\n             Some(x) => Some(x),\n@@ -1576,7 +1576,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn xor(self, optb: Option<T>) -> Option<T>\n     where\n-        T: ~const Destruct,\n+        T: Destruct,\n     {\n         match (self, optb) {\n             (Some(a), None) => Some(a),\n@@ -1614,7 +1614,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn insert(&mut self, value: T) -> &mut T\n     where\n-        T: ~const Destruct,\n+        T: Destruct,\n     {\n         *self = Some(value);\n \n@@ -1647,7 +1647,7 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn get_or_insert(&mut self, value: T) -> &mut T\n     where\n-        T: ~const Destruct,\n+        T: Destruct,\n     {\n         if let None = *self {\n             *self = Some(value);\n@@ -1682,9 +1682,9 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn get_or_insert_default(&mut self) -> &mut T\n     where\n-        T: ~const Default,\n+        T: Default,\n     {\n-        const fn default<T: ~const Default>() -> T {\n+        const fn default<T: Default>() -> T {\n             T::default()\n         }\n \n@@ -1713,8 +1713,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn get_or_insert_with<F>(&mut self, f: F) -> &mut T\n     where\n-        F: ~const FnOnce() -> T,\n-        F: ~const Destruct,\n+        F: FnOnce() -> T,\n+        F: Destruct,\n     {\n         if let None = *self {\n             // the compiler isn't smart enough to know that we are not dropping a `T`\n@@ -1797,8 +1797,8 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn zip<U>(self, other: Option<U>) -> Option<(T, U)>\n     where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n+        T: Destruct,\n+        U: Destruct,\n     {\n         match (self, other) {\n             (Some(a), Some(b)) => Some((a, b)),\n@@ -1838,10 +1838,10 @@ impl<T> Option<T> {\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n     pub const fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>\n     where\n-        F: ~const FnOnce(T, U) -> R,\n-        F: ~const Destruct,\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n+        F: FnOnce(T, U) -> R,\n+        F: Destruct,\n+        T: Destruct,\n+        U: Destruct,\n     {\n         match (self, other) {\n             (Some(a), Some(b)) => Some(f(a, b)),\n@@ -1870,8 +1870,8 @@ impl<T, U> Option<(T, U)> {\n     #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n     pub const fn unzip(self) -> (Option<T>, Option<U>)\n     where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n+        T: Destruct,\n+        U: Destruct,\n     {\n         match self {\n             Some((a, b)) => (Some(a), Some(b)),\n@@ -1925,7 +1925,7 @@ impl<T> Option<&T> {\n     #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n     pub const fn cloned(self) -> Option<T>\n     where\n-        T: ~const Clone,\n+        T: Clone,\n     {\n         match self {\n             Some(t) => Some(t.clone()),\n@@ -1977,7 +1977,7 @@ impl<T> Option<&mut T> {\n     #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n     pub const fn cloned(self) -> Option<T>\n     where\n-        T: ~const Clone,\n+        T: Clone,\n     {\n         match self {\n             Some(t) => Some(t.clone()),\n@@ -2030,10 +2030,9 @@ const fn expect_failed(msg: &str) -> ! {\n /////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T> const Clone for Option<T>\n+impl<T> Clone for Option<T>\n where\n-    T: ~const Clone + ~const Destruct,\n+    T: Clone,\n {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -2053,8 +2052,7 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for Option<T> {\n+impl<T> Default for Option<T> {\n     /// Returns [`None`][Option::None].\n     ///\n     /// # Examples\n@@ -2114,8 +2112,7 @@ impl<'a, T> IntoIterator for &'a mut Option<T> {\n }\n \n #[stable(since = \"1.12.0\", feature = \"option_from\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for Option<T> {\n+impl<T> From<T> for Option<T> {\n     /// Moves `val` into a new [`Some`].\n     ///\n     /// # Examples\n@@ -2131,8 +2128,7 @@ impl<T> const From<T> for Option<T> {\n }\n \n #[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<'a, T> const From<&'a Option<T>> for Option<&'a T> {\n+impl<'a, T> From<&'a Option<T>> for Option<&'a T> {\n     /// Converts from `&Option<T>` to `Option<&T>`.\n     ///\n     /// # Examples\n@@ -2159,8 +2155,7 @@ impl<'a, T> const From<&'a Option<T>> for Option<&'a T> {\n }\n \n #[stable(feature = \"option_ref_from_ref_option\", since = \"1.30.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<'a, T> const From<&'a mut Option<T>> for Option<&'a mut T> {\n+impl<'a, T> From<&'a mut Option<T>> for Option<&'a mut T> {\n     /// Converts from `&mut Option<T>` to `Option<&mut T>`\n     ///\n     /// # Examples\n@@ -2507,8 +2502,7 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const ops::Try for Option<T> {\n+impl<T> ops::Try for Option<T> {\n     type Output = T;\n     type Residual = Option<convert::Infallible>;\n \n@@ -2527,8 +2521,7 @@ impl<T> const ops::Try for Option<T> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const ops::FromResidual for Option<T> {\n+impl<T> ops::FromResidual for Option<T> {\n     #[inline]\n     fn from_residual(residual: Option<convert::Infallible>) -> Self {\n         match residual {\n@@ -2546,8 +2539,7 @@ impl<T> ops::FromResidual<ops::Yeet<()>> for Option<T> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n-impl<T> const ops::Residual<T> for Option<convert::Infallible> {\n+impl<T> ops::Residual<T> for Option<convert::Infallible> {\n     type TryType = Option<T>;\n }\n "}, {"sha": "bbf7199fffa06889e73ea335a5df707733d323bd", "filename": "library/core/src/ptr/alignment.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -9,8 +9,7 @@ use crate::{cmp, fmt, hash, mem, num};\n /// Note that particularly large alignments, while representable in this type,\n /// are likely not to be supported by actual allocators and linkers.\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(transparent)]\n pub struct Alignment(AlignmentEnum);\n \n@@ -170,7 +169,7 @@ impl From<Alignment> for usize {\n \n #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-impl const cmp::Ord for Alignment {\n+impl cmp::Ord for Alignment {\n     #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         self.as_nonzero().get().cmp(&other.as_nonzero().get())\n@@ -179,7 +178,7 @@ impl const cmp::Ord for Alignment {\n \n #[rustc_const_unstable(feature = \"const_alloc_layout\", issue = \"67521\")]\n #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n-impl const cmp::PartialOrd for Alignment {\n+impl cmp::PartialOrd for Alignment {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n@@ -201,8 +200,7 @@ type AlignmentEnum = AlignmentEnum32;\n #[cfg(target_pointer_width = \"64\")]\n type AlignmentEnum = AlignmentEnum64;\n \n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(u16)]\n enum AlignmentEnum16 {\n     _Align1Shl0 = 1 << 0,\n@@ -223,8 +221,7 @@ enum AlignmentEnum16 {\n     _Align1Shl15 = 1 << 15,\n }\n \n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(u32)]\n enum AlignmentEnum32 {\n     _Align1Shl0 = 1 << 0,\n@@ -261,8 +258,7 @@ enum AlignmentEnum32 {\n     _Align1Shl31 = 1 << 31,\n }\n \n-#[derive(Copy, Clone, Eq)]\n-#[derive_const(PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n #[repr(u64)]\n enum AlignmentEnum64 {\n     _Align1Shl0 = 1 << 0,"}, {"sha": "fe6efba600348cd8cf044bfa16e5c92d2bdab589", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -1654,7 +1654,7 @@ impl<T> *const [T] {\n     #[inline]\n     pub const unsafe fn get_unchecked<I>(self, index: I) -> *const I::Output\n     where\n-        I: ~const SliceIndex<[T]>,\n+        I: SliceIndex<[T]>,\n     {\n         // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.\n         unsafe { index.get_unchecked(self) }"}, {"sha": "5af28dea472d85e252943c3833d0408f74f605f0", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -2040,7 +2040,7 @@ impl<T> *mut [T] {\n     #[inline(always)]\n     pub const unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output\n     where\n-        I: ~const SliceIndex<[T]>,\n+        I: SliceIndex<[T]>,\n     {\n         // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.\n         unsafe { index.get_unchecked_mut(self) }"}, {"sha": "fdb428ff4e68032e8bc8bfca701c27bba69bc970", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -680,7 +680,7 @@ impl<T> NonNull<[T]> {\n     #[inline]\n     pub const unsafe fn get_unchecked_mut<I>(self, index: I) -> NonNull<I::Output>\n     where\n-        I: ~const SliceIndex<[T]>,\n+        I: SliceIndex<[T]>,\n     {\n         // SAFETY: the caller ensures that `self` is dereferenceable and `index` in-bounds.\n         // As a consequence, the resulting pointer cannot be null.\n@@ -689,8 +689,7 @@ impl<T> NonNull<[T]> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T: ?Sized> const Clone for NonNull<T> {\n+impl<T: ?Sized> Clone for NonNull<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n         *self\n@@ -756,8 +755,7 @@ impl<T: ?Sized> hash::Hash for NonNull<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized> const From<Unique<T>> for NonNull<T> {\n+impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n     #[inline]\n     fn from(unique: Unique<T>) -> Self {\n         // SAFETY: A Unique pointer cannot be null, so the conditions for\n@@ -767,8 +765,7 @@ impl<T: ?Sized> const From<Unique<T>> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized> const From<&mut T> for NonNull<T> {\n+impl<T: ?Sized> From<&mut T> for NonNull<T> {\n     /// Converts a `&mut T` to a `NonNull<T>`.\n     ///\n     /// This conversion is safe and infallible since references cannot be null.\n@@ -780,8 +777,7 @@ impl<T: ?Sized> const From<&mut T> for NonNull<T> {\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T: ?Sized> const From<&T> for NonNull<T> {\n+impl<T: ?Sized> From<&T> for NonNull<T> {\n     /// Converts a `&T` to a `NonNull<T>`.\n     ///\n     /// This conversion is safe and infallible since references cannot be null."}, {"sha": "3547897698594428883c529e915509ed88a712df", "filename": "library/core/src/ptr/unique.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Funique.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -139,8 +139,7 @@ impl<T: ?Sized> Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T: ?Sized> const Clone for Unique<T> {\n+impl<T: ?Sized> Clone for Unique<T> {\n     #[inline]\n     fn clone(&self) -> Self {\n         *self\n@@ -171,7 +170,7 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: ?Sized> const From<&mut T> for Unique<T> {\n+impl<T: ?Sized> From<&mut T> for Unique<T> {\n     /// Converts a `&mut T` to a `Unique<T>`.\n     ///\n     /// This conversion is infallible since references cannot be null.\n@@ -182,7 +181,7 @@ impl<T: ?Sized> const From<&mut T> for Unique<T> {\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"none\")]\n-impl<T: ?Sized> const From<NonNull<T>> for Unique<T> {\n+impl<T: ?Sized> From<NonNull<T>> for Unique<T> {\n     /// Converts a `NonNull<T>` to a `Unique<T>`.\n     ///\n     /// This conversion is infallible since `NonNull` cannot be null."}, {"sha": "967fee2a6addf83e1463d3f99e420acec4af37b8", "filename": "library/core/src/result.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -632,13 +632,11 @@ impl<T, E> Result<T, E> {\n     #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     pub const fn ok(self) -> Option<T>\n     where\n-        E: ~const Destruct,\n+        E: Destruct,\n     {\n         match self {\n             Ok(x) => Some(x),\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Err(x) => None,\n+            Err(_) => None,\n         }\n     }\n \n@@ -661,12 +659,10 @@ impl<T, E> Result<T, E> {\n     #[rustc_const_unstable(feature = \"const_result_drop\", issue = \"92384\")]\n     pub const fn err(self) -> Option<E>\n     where\n-        T: ~const Destruct,\n+        T: Destruct,\n     {\n         match self {\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Ok(x) => None,\n+            Ok(_) => None,\n             Err(x) => Some(x),\n         }\n     }\n@@ -1291,14 +1287,12 @@ impl<T, E> Result<T, E> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn and<U>(self, res: Result<U, E>) -> Result<U, E>\n     where\n-        T: ~const Destruct,\n-        U: ~const Destruct,\n-        E: ~const Destruct,\n+        T: Destruct,\n+        U: Destruct,\n+        E: Destruct,\n     {\n         match self {\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Ok(x) => res,\n+            Ok(_) => res,\n             Err(e) => Err(e),\n         }\n     }\n@@ -1374,15 +1368,13 @@ impl<T, E> Result<T, E> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn or<F>(self, res: Result<T, F>) -> Result<T, F>\n     where\n-        T: ~const Destruct,\n-        E: ~const Destruct,\n-        F: ~const Destruct,\n+        T: Destruct,\n+        E: Destruct,\n+        F: Destruct,\n     {\n         match self {\n             Ok(v) => Ok(v),\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Err(e) => res,\n+            Err(_) => res,\n         }\n     }\n \n@@ -1434,14 +1426,12 @@ impl<T, E> Result<T, E> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub const fn unwrap_or(self, default: T) -> T\n     where\n-        T: ~const Destruct,\n-        E: ~const Destruct,\n+        T: Destruct,\n+        E: Destruct,\n     {\n         match self {\n             Ok(t) => t,\n-            // FIXME: ~const Drop doesn't quite work right yet\n-            #[allow(unused_variables)]\n-            Err(e) => default,\n+            Err(_) => default,\n         }\n     }\n \n@@ -1704,11 +1694,10 @@ fn unwrap_failed<T>(_msg: &str, _error: &T) -> ! {\n /////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_clone\", issue = \"91805\")]\n-impl<T, E> const Clone for Result<T, E>\n+impl<T, E> Clone for Result<T, E>\n where\n-    T: ~const Clone + ~const Destruct,\n-    E: ~const Clone + ~const Destruct,\n+    T: Clone,\n+    E: Clone,\n {\n     #[inline]\n     fn clone(&self) -> Self {\n@@ -1971,8 +1960,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, E> const ops::Try for Result<T, E> {\n+impl<T, E> ops::Try for Result<T, E> {\n     type Output = T;\n     type Residual = Result<convert::Infallible, E>;\n \n@@ -1991,8 +1979,7 @@ impl<T, E> const ops::Try for Result<T, E> {\n }\n \n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T, E, F: ~const From<E>> const ops::FromResidual<Result<convert::Infallible, E>>\n+impl<T, E, F: From<E>> ops::FromResidual<Result<convert::Infallible, E>>\n     for Result<T, F>\n {\n     #[inline]\n@@ -2013,7 +2000,6 @@ impl<T, E, F: From<E>> ops::FromResidual<ops::Yeet<E>> for Result<T, F> {\n }\n \n #[unstable(feature = \"try_trait_v2_residual\", issue = \"91285\")]\n-#[rustc_const_unstable(feature = \"const_try\", issue = \"74935\")]\n-impl<T, E> const ops::Residual<T> for Result<convert::Infallible, E> {\n+impl<T, E> ops::Residual<T> for Result<convert::Infallible, E> {\n     type TryType = Result<T, E>;\n }"}, {"sha": "6ef9f9c95e843be9ede86e176c64c1ccd1fcb435", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -7,10 +7,9 @@ use crate::ops;\n use crate::ptr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I> const ops::Index<I> for [T]\n+impl<T, I> ops::Index<I> for [T]\n where\n-    I: ~const SliceIndex<[T]>,\n+    I: SliceIndex<[T]>,\n {\n     type Output = I::Output;\n \n@@ -21,10 +20,9 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<T, I> const ops::IndexMut<I> for [T]\n+impl<T, I> ops::IndexMut<I> for [T]\n where\n-    I: ~const SliceIndex<[T]>,\n+    I: SliceIndex<[T]>,\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut I::Output {\n@@ -162,7 +160,6 @@ mod private_slice_index {\n     message = \"the type `{T}` cannot be indexed by `{Self}`\",\n     label = \"slice indices are of type `usize` or ranges of `usize`\"\n )]\n-#[const_trait]\n pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// The output type returned by methods.\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n@@ -211,7 +208,7 @@ pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for usize {\n+unsafe impl<T> SliceIndex<[T]> for usize {\n     type Output = T;\n \n     #[inline]\n@@ -271,7 +268,7 @@ unsafe impl<T> const SliceIndex<[T]> for usize {\n /// Because `IndexRange` guarantees `start <= end`, fewer checks are needed here\n /// than there are for a general `Range<usize>` (which might be `100..3`).\n #[rustc_const_unstable(feature = \"const_index_range_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n+unsafe impl<T> SliceIndex<[T]> for ops::IndexRange {\n     type Output = [T];\n \n     #[inline]\n@@ -347,7 +344,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::IndexRange {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -428,7 +425,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeTo<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -466,7 +463,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeTo<usize> {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeFrom<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -512,7 +509,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeFrom<usize> {\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeFull {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n@@ -548,7 +545,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeFull {\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -592,7 +589,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl<T> const SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]"}, {"sha": "992a088b9111160277d4fa032ba7dbc5d3d3e764", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -338,7 +338,7 @@ impl<T> [T] {\n     #[must_use]\n     pub const fn get<I>(&self, index: I) -> Option<&I::Output>\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         index.get(self)\n     }\n@@ -364,7 +364,7 @@ impl<T> [T] {\n     #[must_use]\n     pub const fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         index.get_mut(self)\n     }\n@@ -397,7 +397,7 @@ impl<T> [T] {\n     #[must_use]\n     pub const unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;\n         // the slice is dereferenceable because `self` is a safe reference.\n@@ -435,7 +435,7 @@ impl<T> [T] {\n     #[must_use]\n     pub const unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n     where\n-        I: ~const SliceIndex<Self>,\n+        I: SliceIndex<Self>,\n     {\n         // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n         // the slice is dereferenceable because `self` is a safe reference.\n@@ -4404,17 +4404,15 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for &[T] {\n+impl<T> Default for &[T] {\n     /// Creates an empty slice.\n     fn default() -> Self {\n         &[]\n     }\n }\n \n #[stable(feature = \"mut_slice_default\", since = \"1.5.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for &mut [T] {\n+impl<T> Default for &mut [T] {\n     /// Creates a mutable empty slice.\n     fn default() -> Self {\n         &mut []"}, {"sha": "1ab27d567ca86d0cd02c6058b68b50b66f47c18a", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -438,7 +438,7 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const fn get<I: ~const SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n+    pub const fn get<I: SliceIndex<str>>(&self, i: I) -> Option<&I::Output> {\n         i.get(self)\n     }\n \n@@ -471,7 +471,7 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const fn get_mut<I: ~const SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n+    pub const fn get_mut<I: SliceIndex<str>>(&mut self, i: I) -> Option<&mut I::Output> {\n         i.get_mut(self)\n     }\n \n@@ -504,7 +504,7 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const unsafe fn get_unchecked<I: ~const SliceIndex<str>>(&self, i: I) -> &I::Output {\n+    pub const unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n         // the slice is dereferenceable because `self` is a safe reference.\n         // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n@@ -540,7 +540,7 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n     #[inline]\n-    pub const unsafe fn get_unchecked_mut<I: ~const SliceIndex<str>>(\n+    pub const unsafe fn get_unchecked_mut<I: SliceIndex<str>>(\n         &mut self,\n         i: I,\n     ) -> &mut I::Output {\n@@ -2582,8 +2582,7 @@ impl AsRef<[u8]> for str {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for &str {\n+impl Default for &str {\n     /// Creates an empty str\n     #[inline]\n     fn default() -> Self {"}, {"sha": "1d52335f28ebf2f82f410b8790fe3b95ffa0af28", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -50,10 +50,9 @@ impl PartialOrd for str {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<I> const ops::Index<I> for str\n+impl<I> ops::Index<I> for str\n where\n-    I: ~const SliceIndex<str>,\n+    I: SliceIndex<str>,\n {\n     type Output = I::Output;\n \n@@ -64,10 +63,9 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-impl<I> const ops::IndexMut<I> for str\n+impl<I> ops::IndexMut<I> for str\n where\n-    I: ~const SliceIndex<str>,\n+    I: SliceIndex<str>,\n {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut I::Output {\n@@ -96,7 +94,7 @@ const fn str_index_overflow_fail() -> ! {\n /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeFull {\n+unsafe impl SliceIndex<str> for ops::RangeFull {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -161,7 +159,7 @@ unsafe impl const SliceIndex<str> for ops::RangeFull {\n /// ```\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::Range<usize> {\n+unsafe impl SliceIndex<str> for ops::Range<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -271,7 +269,7 @@ unsafe impl const SliceIndex<str> for ops::Range<usize> {\n /// character (as defined by `is_char_boundary`), or if `end > len`.\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeTo<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -340,7 +338,7 @@ unsafe impl const SliceIndex<str> for ops::RangeTo<usize> {\n /// a character (as defined by `is_char_boundary`), or if `begin > len`.\n #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeFrom<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -412,7 +410,7 @@ unsafe impl const SliceIndex<str> for ops::RangeFrom<usize> {\n /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeInclusive<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -464,7 +462,7 @@ unsafe impl const SliceIndex<str> for ops::RangeInclusive<usize> {\n /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n #[rustc_const_unstable(feature = \"const_slice_index\", issue = \"none\")]\n-unsafe impl const SliceIndex<str> for ops::RangeToInclusive<usize> {\n+unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {"}, {"sha": "b0ab634905ffed4698dc5df4e0f81f24945b1aab", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -147,8 +147,7 @@ pub struct AtomicBool {\n \n #[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl const Default for AtomicBool {\n+impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n     #[inline]\n     fn default() -> Self {\n@@ -179,8 +178,7 @@ pub struct AtomicPtr<T> {\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for AtomicPtr<T> {\n+impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n     fn default() -> AtomicPtr<T> {\n         AtomicPtr::new(crate::ptr::null_mut())\n@@ -1916,8 +1914,7 @@ impl<T> AtomicPtr<T> {\n \n #[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl const From<bool> for AtomicBool {\n+impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n     ///\n     /// # Examples\n@@ -1935,8 +1932,7 @@ impl const From<bool> for AtomicBool {\n \n #[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<*mut T> for AtomicPtr<T> {\n+impl<T> From<*mut T> for AtomicPtr<T> {\n     /// Converts a `*mut T` into an `AtomicPtr<T>`.\n     #[inline]\n     fn from(p: *mut T) -> Self {\n@@ -2002,17 +1998,15 @@ macro_rules! atomic_int {\n         pub const $atomic_init: $atomic_type = $atomic_type::new(0);\n \n         #[$stable]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl const Default for $atomic_type {\n+        impl Default for $atomic_type {\n             #[inline]\n             fn default() -> Self {\n                 Self::new(Default::default())\n             }\n         }\n \n         #[$stable_from]\n-        #[rustc_const_unstable(feature = \"const_num_from_num\", issue = \"87852\")]\n-        impl const From<$int_type> for $atomic_type {\n+        impl From<$int_type> for $atomic_type {\n             #[doc = concat!(\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\")]\n             #[inline]\n             fn from(v: $int_type) -> Self { Self::new(v) }"}, {"sha": "168516263f19019205620b7d5fe6a22d16d3317a", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -247,8 +247,7 @@ impl<T, E> Poll<Option<Result<T, E>>> {\n }\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-#[rustc_const_unstable(feature = \"const_convert\", issue = \"88674\")]\n-impl<T> const From<T> for Poll<T> {\n+impl<T> From<T> for Poll<T> {\n     /// Moves the value into a [`Poll::Ready`] to make a `Poll<T>`.\n     ///\n     /// # Example"}, {"sha": "75d7a3f40058e5edeecaf2583339b3bd0f0b22ec", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -22,8 +22,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl<$($T: ~const PartialEq),+> const PartialEq for ($($T,)+)\n+            impl<$($T: PartialEq),+> PartialEq for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -50,8 +49,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl<$($T: ~const PartialOrd + ~const PartialEq),+> const PartialOrd for ($($T,)+)\n+            impl<$($T: PartialOrd),+> PartialOrd for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -81,8 +79,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n-            impl<$($T: ~const Ord),+> const Ord for ($($T,)+)\n+            impl<$($T: Ord),+> Ord for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -96,8 +93,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-            impl<$($T: ~const Default),+> const Default for ($($T,)+) {\n+            impl<$($T: Default),+> Default for ($($T,)+) {\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n                     ($({ let x: $T = Default::default(); x},)+)"}, {"sha": "dc5b8a399144946113c3ffb8276efdbf5ae37033", "filename": "library/core/tests/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fcmp.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -222,13 +222,13 @@ mod const_cmp {\n \n     struct S(i32);\n \n-    impl const PartialEq for S {\n+    impl PartialEq for S {\n         fn eq(&self, other: &Self) -> bool {\n             self.0 == other.0\n         }\n     }\n \n-    impl const PartialOrd for S {\n+    impl PartialOrd for S {\n         fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n             let ret = match (self.0, other.0) {\n                 (a, b) if a > b => Ordering::Greater,"}, {"sha": "2f4b9c7410155c797f95c80e38a0360deea31f86", "filename": "library/core/tests/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fmod.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -9,13 +9,13 @@ struct MyHasher {\n     hash: u64,\n }\n \n-impl const Default for MyHasher {\n+impl Default for MyHasher {\n     fn default() -> MyHasher {\n         MyHasher { hash: 0 }\n     }\n }\n \n-impl const Hasher for MyHasher {\n+impl Hasher for MyHasher {\n     fn write(&mut self, buf: &[u8]) {\n         // FIXME(const_trait_impl): change to for loop\n         let mut i = 0;\n@@ -35,7 +35,7 @@ impl const Hasher for MyHasher {\n \n #[test]\n fn test_writer_hasher() {\n-    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n+    const fn hash<T: Hash>(t: &T) -> u64 {\n         let mut s = MyHasher { hash: 0 };\n         t.hash(&mut s);\n         s.finish()\n@@ -113,7 +113,7 @@ struct CustomHasher {\n     output: u64,\n }\n \n-impl const Hasher for CustomHasher {\n+impl Hasher for CustomHasher {\n     fn finish(&self) -> u64 {\n         self.output\n     }\n@@ -125,21 +125,21 @@ impl const Hasher for CustomHasher {\n     }\n }\n \n-impl const Default for CustomHasher {\n+impl Default for CustomHasher {\n     fn default() -> CustomHasher {\n         CustomHasher { output: 0 }\n     }\n }\n \n-impl const Hash for Custom {\n-    fn hash<H: ~const Hasher>(&self, state: &mut H) {\n+impl Hash for Custom {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         state.write_u64(self.hash);\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    const fn hash<T: ~const Hash>(t: &T) -> u64 {\n+    const fn hash<T: Hash>(t: &T) -> u64 {\n         let mut c = CustomHasher { output: 0 };\n         t.hash(&mut c);\n         c.finish()"}, {"sha": "4b9f472625d6953fde874154abe57f4f1720de29", "filename": "library/core/tests/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fcore%2Ftests%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fhash%2Fsip.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -28,7 +28,7 @@ const fn test_const_sip() {\n     let val1 = 0x45;\n     let val2 = 0xfeed;\n \n-    const fn const_hash<T: ~const Hash>(x: &T) -> u64 {\n+    const fn const_hash<T: Hash>(x: &T) -> u64 {\n         let mut st = SipHasher::new();\n         x.hash(&mut st);\n         st.finish()"}, {"sha": "c722bad2e4f6365b1d1188061ae9ad0053e6758d", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -3168,8 +3168,7 @@ impl DefaultHasher {\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const Default for DefaultHasher {\n+impl Default for DefaultHasher {\n     /// Creates a new `DefaultHasher` using [`new`].\n     /// See its documentation for more.\n     ///\n@@ -3181,8 +3180,7 @@ impl const Default for DefaultHasher {\n }\n \n #[stable(feature = \"hashmap_default_hasher\", since = \"1.13.0\")]\n-#[rustc_const_unstable(feature = \"const_hash\", issue = \"104061\")]\n-impl const Hasher for DefaultHasher {\n+impl Hasher for DefaultHasher {\n     // The underlying `SipHasher13` doesn't override the other\n     // `write_*` methods, so it's ok not to forward them here.\n "}, {"sha": "36951c4f13e9c934c005b2039661ff0ef5627e55", "filename": "library/std/src/sync/once_lock.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76dbe2910465072f85e74d6f7115ec9e6803e8bf/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs?ref=76dbe2910465072f85e74d6f7115ec9e6803e8bf", "patch": "@@ -344,8 +344,7 @@ impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for OnceLock<T> {}\n impl<T: UnwindSafe> UnwindSafe for OnceLock<T> {}\n \n #[stable(feature = \"once_cell\", since = \"CURRENT_RUSTC_VERSION\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for OnceLock<T> {\n+impl<T> Default for OnceLock<T> {\n     /// Creates a new empty cell.\n     ///\n     /// # Example"}]}