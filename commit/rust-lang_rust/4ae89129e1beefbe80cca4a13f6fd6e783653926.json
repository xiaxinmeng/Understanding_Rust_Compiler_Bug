{"sha": "4ae89129e1beefbe80cca4a13f6fd6e783653926", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhZTg5MTI5ZTFiZWVmYmU4MGNjYTRhMTNmNmZkNmU3ODM2NTM5MjY=", "commit": {"author": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-07-01T03:34:18Z"}, "committer": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-07-01T05:41:01Z"}, "message": "in which hir::Visibility recalls whence it came (i.e., becomes Spanned)\n\nThere are at least a couple (and plausibly even three) diagnostics that\ncould use the spans of visibility modifiers in order to be reliably\ncorrect (rather than hacking and munging surrounding spans to try to\ninfer where the visibility keyword must have been).\n\nWe follow the naming convention established by the other `Spanned` HIR\nnodes: the \"outer\" type alias gets the \"prime\" node-type name, the\n\"inner\" enum gets the name suffixed with an underscore, and the variant\nnames are prefixed with the prime name and `pub use` exported from here\n(from HIR).\n\nThanks to veteran reviewer Vadim Petrochenkov for suggesting this\nuniform approach. (A previous draft, based on the reasoning that\n`Visibility::Inherited` should not have a span, tried to hack in a named\n`span` field on `Visibility::Restricted` and a positional field on\n`Public` and `Crate`. This was ... not so uniform.)", "tree": {"sha": "865dc804eefd1634fb7ad16b497f34db4a89ceba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/865dc804eefd1634fb7ad16b497f34db4a89ceba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ae89129e1beefbe80cca4a13f6fd6e783653926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae89129e1beefbe80cca4a13f6fd6e783653926", "html_url": "https://github.com/rust-lang/rust/commit/4ae89129e1beefbe80cca4a13f6fd6e783653926", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ae89129e1beefbe80cca4a13f6fd6e783653926/comments", "author": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9df9c9df7bdcd688bcad9e91b9e2669f01d9f858", "url": "https://api.github.com/repos/rust-lang/rust/commits/9df9c9df7bdcd688bcad9e91b9e2669f01d9f858", "html_url": "https://github.com/rust-lang/rust/commit/9df9c9df7bdcd688bcad9e91b9e2669f01d9f858"}], "stats": {"total": 220, "additions": 121, "deletions": 99}, "files": [{"sha": "7173f670cd55486470937e84d28f8c44662dd583", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -1104,7 +1104,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n-    if let Visibility::Restricted { ref path, id } = *vis {\n+    if let VisibilityRestricted { ref path, id } = vis.node {\n         visitor.visit_id(id);\n         visitor.visit_path(path, id)\n     }"}, {"sha": "4db12c95168306b7f3903703582a2643b9bff4c1", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -1285,7 +1285,7 @@ impl<'a> LoweringContext<'a> {\n                 name: keywords::Invalid.name(),\n                 attrs: Default::default(),\n                 node: exist_ty_item_kind,\n-                vis: hir::Visibility::Inherited,\n+                vis: respan(span.shrink_to_lo(), hir::VisibilityInherited),\n                 span: exist_ty_span,\n             };\n \n@@ -2770,18 +2770,19 @@ impl<'a> LoweringContext<'a> {\n                         let new_id = this.lower_node_id(new_node_id);\n                         let path = this.lower_path_extra(def, &path, None, ParamMode::Explicit);\n                         let item = hir::ItemUse(P(path), hir::UseKind::Single);\n-                        let vis = match vis {\n-                            hir::Visibility::Public => hir::Visibility::Public,\n-                            hir::Visibility::Crate(sugar) => hir::Visibility::Crate(sugar),\n-                            hir::Visibility::Inherited => hir::Visibility::Inherited,\n-                            hir::Visibility::Restricted { ref path, id: _ } => {\n-                                hir::Visibility::Restricted {\n+                        let vis_kind = match vis.node {\n+                            hir::VisibilityPublic => hir::VisibilityPublic,\n+                            hir::VisibilityCrate(sugar) => hir::VisibilityCrate(sugar),\n+                            hir::VisibilityInherited => hir::VisibilityInherited,\n+                            hir::VisibilityRestricted { ref path, id: _ } => {\n+                                hir::VisibilityRestricted {\n                                     path: path.clone(),\n                                     // We are allocating a new NodeId here\n                                     id: this.next_id().node_id,\n                                 }\n                             }\n                         };\n+                        let vis = respan(vis.span, vis_kind);\n \n                         this.items.insert(\n                             new_id.node_id,\n@@ -2842,18 +2843,19 @@ impl<'a> LoweringContext<'a> {\n                         self.lower_use_tree(use_tree, &prefix, new_id, &mut vis, &mut name, &attrs);\n \n                     self.with_hir_id_owner(new_id, |this| {\n-                        let vis = match vis {\n-                            hir::Visibility::Public => hir::Visibility::Public,\n-                            hir::Visibility::Crate(sugar) => hir::Visibility::Crate(sugar),\n-                            hir::Visibility::Inherited => hir::Visibility::Inherited,\n-                            hir::Visibility::Restricted { ref path, id: _ } => {\n-                                hir::Visibility::Restricted {\n+                        let vis_kind = match vis.node {\n+                            hir::VisibilityPublic => hir::VisibilityPublic,\n+                            hir::VisibilityCrate(sugar) => hir::VisibilityCrate(sugar),\n+                            hir::VisibilityInherited => hir::VisibilityInherited,\n+                            hir::VisibilityRestricted { ref path, id: _ } => {\n+                                hir::VisibilityRestricted {\n                                     path: path.clone(),\n                                     // We are allocating a new NodeId here\n                                     id: this.next_id().node_id,\n                                 }\n                             }\n                         };\n+                        let vis = respan(vis.span, vis_kind);\n \n                         this.items.insert(\n                             new_id,\n@@ -2874,7 +2876,7 @@ impl<'a> LoweringContext<'a> {\n                 // the stability of `use a::{};`, to avoid it showing up as\n                 // a re-export by accident when `pub`, e.g. in documentation.\n                 let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n-                *vis = hir::Inherited;\n+                *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityInherited);\n                 hir::ItemUse(path, hir::UseKind::ListStem)\n             }\n         }\n@@ -4274,19 +4276,20 @@ impl<'a> LoweringContext<'a> {\n         v: &Visibility,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::Visibility {\n-        match v.node {\n-            VisibilityKind::Public => hir::Public,\n-            VisibilityKind::Crate(sugar) => hir::Visibility::Crate(sugar),\n-            VisibilityKind::Restricted { ref path, id, .. } => hir::Visibility::Restricted {\n+        let node = match v.node {\n+            VisibilityKind::Public => hir::VisibilityPublic,\n+            VisibilityKind::Crate(sugar) => hir::VisibilityCrate(sugar),\n+            VisibilityKind::Restricted { ref path, id } => hir::VisibilityRestricted {\n                 path: P(self.lower_path(id, path, ParamMode::Explicit)),\n                 id: if let Some(owner) = explicit_owner {\n                     self.lower_node_id_with_owner(id, owner).node_id\n                 } else {\n                     self.lower_node_id(id).node_id\n                 },\n             },\n-            VisibilityKind::Inherited => hir::Inherited,\n-        }\n+            VisibilityKind::Inherited => hir::VisibilityInherited,\n+        };\n+        respan(v.span, node)\n     }\n \n     fn lower_defaultness(&mut self, d: Defaultness, has_value: bool) -> hir::Defaultness {"}, {"sha": "55ad73515c0d3a34444c784a046f978ecdb552c8", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -458,11 +458,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n-        match *visibility {\n-            Visibility::Public |\n-            Visibility::Crate(_) |\n-            Visibility::Inherited => {}\n-            Visibility::Restricted { id, .. } => {\n+        match visibility.node {\n+            VisibilityPublic |\n+            VisibilityCrate(_) |\n+            VisibilityInherited => {}\n+            VisibilityRestricted { id, .. } => {\n                 self.insert(id, NodeVisibility(visibility));\n                 self.with_parent(id, |this| {\n                     intravisit::walk_vis(this, visibility);"}, {"sha": "a5c0a5e33f7053f907b8d85ad7579a4acf8e09d0", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -1049,7 +1049,9 @@ impl<'hir> Map<'hir> {\n             Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n             Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n             Some(EntryGenericParam(_, _, param)) => param.span,\n-            Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, _, &Spanned {\n+                node: VisibilityRestricted { ref path, .. }, ..\n+            })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,\n             Some(EntryMacroDef(_, macro_def)) => macro_def.span,"}, {"sha": "6f8981e1e6cd40c82ad4c58b1fdc748bcc341ecd", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -24,7 +24,7 @@ pub use self::Stmt_::*;\n pub use self::Ty_::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n-pub use self::Visibility::{Public, Inherited};\n+pub use self::Visibility_::*;\n \n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n@@ -1929,22 +1929,30 @@ pub struct PolyTraitRef {\n     pub span: Span,\n }\n \n+pub type Visibility = Spanned<Visibility_>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Visibility {\n-    Public,\n-    Crate(CrateSugar),\n-    Restricted { path: P<Path>, id: NodeId },\n-    Inherited,\n+pub enum Visibility_ {\n+    VisibilityPublic,\n+    VisibilityCrate(CrateSugar),\n+    VisibilityRestricted { path: P<Path>, id: NodeId },\n+    VisibilityInherited,\n }\n \n-impl Visibility {\n+impl Visibility_ {\n+    pub fn is_pub(&self) -> bool {\n+        match *self {\n+            VisibilityPublic => true,\n+            _ => false\n+        }\n+    }\n+\n     pub fn is_pub_restricted(&self) -> bool {\n-        use self::Visibility::*;\n-        match self {\n-            &Public |\n-            &Inherited => false,\n-            &Crate(_) |\n-            &Restricted { .. } => true,\n+        match *self {\n+            VisibilityPublic |\n+            VisibilityInherited => false,\n+            VisibilityCrate(..) |\n+            VisibilityRestricted { .. } => true,\n         }\n     }\n }"}, {"sha": "5b52764f08d3dbec6cc0cb301171b5cb06230519", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -12,7 +12,7 @@ pub use self::AnnNode::*;\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::CodeMap;\n+use syntax::codemap::{CodeMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n@@ -839,11 +839,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_visibility(&mut self, vis: &hir::Visibility) -> io::Result<()> {\n-        match *vis {\n-            hir::Public => self.word_nbsp(\"pub\")?,\n-            hir::Visibility::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\")?,\n-            hir::Visibility::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\")?,\n-            hir::Visibility::Restricted { ref path, .. } => {\n+        match vis.node {\n+            hir::VisibilityPublic => self.word_nbsp(\"pub\")?,\n+            hir::VisibilityCrate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\")?,\n+            hir::VisibilityCrate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\")?,\n+            hir::VisibilityRestricted { ref path, .. } => {\n                 self.s.word(\"pub(\")?;\n                 if path.segments.len() == 1 &&\n                    path.segments[0].ident.name == keywords::Super.name() {\n@@ -856,7 +856,7 @@ impl<'a> State<'a> {\n                 }\n                 self.word_nbsp(\")\")?;\n             }\n-            hir::Inherited => ()\n+            hir::VisibilityInherited => ()\n         }\n \n         Ok(())\n@@ -952,17 +952,18 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n-                self.print_associated_const(ti.ident, &ty, default, &hir::Inherited)?;\n+                let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityInherited };\n+                self.print_associated_const(ti.ident, &ty, default, &vis)?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, arg_names,\n-                    None)?;\n+                let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityInherited };\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, arg_names, None)?;\n                 self.s.word(\";\")?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n+                let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityInherited };\n                 self.head(\"\")?;\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, &[],\n-                    Some(body))?;\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, &[], Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n@@ -2266,7 +2267,7 @@ impl<'a> State<'a> {\n                       },\n                       name,\n                       &generics,\n-                      &hir::Inherited,\n+                      &Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityInherited },\n                       arg_names,\n                       None)?;\n         self.end()"}, {"sha": "3170f9efafb6beac636ef2fdc48c89c14a6ef72a", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -710,20 +710,20 @@ impl_stable_hash_for!(enum ::syntax::ast::CrateSugar {\n     PubCrate,\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility_ {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            hir::Visibility::Public |\n-            hir::Visibility::Inherited => {\n+            hir::VisibilityPublic |\n+            hir::VisibilityInherited => {\n                 // No fields to hash.\n             }\n-            hir::Visibility::Crate(sugar) => {\n+            hir::VisibilityCrate(sugar) => {\n                 sugar.hash_stable(hcx, hasher);\n             }\n-            hir::Visibility::Restricted { ref path, id } => {\n+            hir::VisibilityRestricted { ref path, id } => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     id.hash_stable(hcx, hasher);\n                 });\n@@ -733,6 +733,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility {\n     }\n }\n \n+impl_stable_hash_for_spanned!(hir::Visibility_);\n+\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "976dee3f7da2a4b9f228284eed71c32de8d15ed8", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -157,7 +157,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemEnum(..) => {\n-                        self.inherited_pub_visibility = item.vis == hir::Public;\n+                        self.inherited_pub_visibility = item.vis.node.is_pub();\n                         intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemFn(..)\n@@ -212,7 +212,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         let has_repr_c = self.repr_has_repr_c;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n         let live_fields = def.fields().iter().filter(|f| {\n-            has_repr_c || inherited_pub_visibility || f.vis == hir::Public\n+            has_repr_c || inherited_pub_visibility || f.vis.node.is_pub()\n         });\n         self.live_symbols.extend(live_fields.map(|f| f.id));\n "}, {"sha": "aad60c0247d2650737aecff0ebe8b84509b67fc3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -268,16 +268,16 @@ impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n \n impl Visibility {\n     pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt) -> Self {\n-        match *visibility {\n-            hir::Public => Visibility::Public,\n-            hir::Visibility::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n-            hir::Visibility::Restricted { ref path, .. } => match path.def {\n+        match visibility.node {\n+            hir::VisibilityPublic => Visibility::Public,\n+            hir::VisibilityCrate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n+            hir::VisibilityRestricted { ref path, .. } => match path.def {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n                 Def::Err => Visibility::Public,\n                 def => Visibility::Restricted(def.def_id()),\n             },\n-            hir::Inherited => {\n+            hir::VisibilityInherited => {\n                 Visibility::Restricted(tcx.hir.get_module_parent(id))\n             }\n         }"}, {"sha": "c5bde8af9cf54fce26f547a32eb86c68d602f582", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemUnion(..) => \"a union\",\n             hir::ItemTrait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n-                if it.vis == hir::Visibility::Inherited {\n+                if it.vis.node == hir::VisibilityInherited {\n                     self.private_traits.insert(it.id);\n                     for trait_item_ref in trait_item_refs {\n                         self.private_traits.insert(trait_item_ref.id.node_id);\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n                     match cx.tcx.hir.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n-                            if item.vis == hir::Visibility::Inherited {\n+                            if item.vis.node == hir::VisibilityInherited {\n                                 for impl_item_ref in impl_item_refs {\n                                     self.private_traits.insert(impl_item_ref.id.node_id);\n                                 }\n@@ -1187,7 +1187,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         let msg = \"function is marked #[no_mangle], but not exported\";\n                         let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_FNS, it.span, msg);\n                         let insertion_span = it.span.shrink_to_lo();\n-                        if it.vis == hir::Visibility::Inherited {\n+                        if it.vis.node == hir::VisibilityInherited {\n                             err.span_suggestion(insertion_span,\n                                                 \"try making it public\",\n                                                 \"pub \".to_owned());\n@@ -1218,7 +1218,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                        let msg = \"static is marked #[no_mangle], but not exported\";\n                        let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg);\n                        let insertion_span = it.span.shrink_to_lo();\n-                       if it.vis == hir::Visibility::Inherited {\n+                       if it.vis.node == hir::VisibilityInherited {\n                            err.span_suggestion(insertion_span,\n                                                \"try making it public\",\n                                                \"pub \".to_owned());\n@@ -1388,7 +1388,7 @@ impl UnreachablePub {\n     fn perform_lint(&self, cx: &LateContext, what: &str, id: ast::NodeId,\n                     vis: &hir::Visibility, span: Span, exportable: bool,\n                     mut applicability: Applicability) {\n-        if !cx.access_levels.is_reachable(id) && *vis == hir::Visibility::Public {\n+        if !cx.access_levels.is_reachable(id) && vis.node.is_pub() {\n             if span.ctxt().outer().expn_info().is_some() {\n                 applicability = Applicability::MaybeIncorrect;\n             }"}, {"sha": "196c53970f6702cd32a473e0522a50b5441aeb06", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -40,6 +40,7 @@ use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n+use syntax::codemap::Spanned;\n use syntax::symbol::keywords;\n use syntax_pos::{self, hygiene, FileName, FileMap, Span};\n \n@@ -319,9 +320,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_items(&mut self) -> Index {\n         let krate = self.tcx.hir.krate();\n         let mut index = IndexBuilder::new(self);\n+        let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityPublic };\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      IsolatedEncoder::encode_info_for_mod,\n-                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n+                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &vis)));\n         let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n         for macro_def in &krate.exported_macros {"}, {"sha": "05ee85e92f5735c369ff617eee4e642b96652c34", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir)\n     }\n     fn visit_vis(&mut self, vis: &'tcx hir::Visibility) {\n-        self.has_pub_restricted = self.has_pub_restricted || vis.is_pub_restricted();\n+        self.has_pub_restricted = self.has_pub_restricted || vis.node.is_pub_restricted();\n     }\n }\n \n@@ -162,7 +162,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemTrait(..) | hir::ItemTraitAlias(..) |\n             hir::ItemExistential(..) |\n             hir::ItemTy(..) | hir::ItemUnion(..) | hir::ItemUse(..) => {\n-                if item.vis == hir::Public { self.prev_level } else { None }\n+                if item.vis.node.is_pub() { self.prev_level } else { None }\n             }\n         };\n \n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n             hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n-                    if impl_item_ref.vis == hir::Public {\n+                    if impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.node_id, item_level);\n                     }\n                 }\n@@ -201,14 +201,14 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     self.update(def.id(), item_level);\n                 }\n                 for field in def.fields() {\n-                    if field.vis == hir::Public {\n+                    if field.vis.node.is_pub() {\n                         self.update(field.id, item_level);\n                     }\n                 }\n             }\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if foreign_item.vis == hir::Public {\n+                    if foreign_item.vis.node.is_pub() {\n                         self.update(foreign_item.id, item_level);\n                     }\n                 }\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n         let module_did = ty::DefIdTree::parent(self.tcx, self.tcx.hir.local_def_id(md.id)).unwrap();\n         let mut module_id = self.tcx.hir.as_local_node_id(module_did).unwrap();\n-        let level = if md.vis == hir::Public { self.get(module_id) } else { None };\n+        let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n         let level = self.update(md.id, level);\n         if level.is_none() {\n             return\n@@ -1023,7 +1023,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n             match self.tcx.hir.find(node_id) {\n-                Some(hir::map::NodeItem(ref item)) => item.vis != hir::Public,\n+                Some(hir::map::NodeItem(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1046,7 +1046,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn item_is_public(&self, id: &ast::NodeId, vis: &hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || *vis == hir::Public\n+        self.access_levels.is_reachable(*id) || vis.node.is_pub()\n     }\n }\n \n@@ -1317,7 +1317,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        if s.vis == hir::Public || self.in_variant {\n+        if s.vis.node.is_pub() || self.in_variant {\n             intravisit::walk_struct_field(self, s);\n         }\n     }"}, {"sha": "414247d22a87a60f87408f0dca97bc18bb04159d", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -55,6 +55,7 @@ use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, Attribute, NodeId, PatKind};\n+use syntax::codemap::Spanned;\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -631,7 +632,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 node: hir::ItemUse(ref path, _),\n                 ..\n             }) |\n-            Node::NodeVisibility(&hir::Visibility::Restricted { ref path, .. }) => path.def,\n+            Node::NodeVisibility(&Spanned {\n+                node: hir::VisibilityRestricted { ref path, .. }, .. }) => path.def,\n \n             Node::NodeExpr(&hir::Expr {\n                 node: hir::ExprStruct(ref qpath, ..),"}, {"sha": "3a8ed0ea25facc3a2a18cf2df893441de93fa00e", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -39,7 +39,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if item.vis == hir::Public || item.span.is_dummy() {\n+        if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n         if let hir::ItemUse(ref path, _) = item.node {\n@@ -214,4 +214,3 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }\n-"}, {"sha": "7394b6d580c9f0d7903378ffec54c13a9f948244", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -286,7 +286,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                         as_primitive(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n                     hir::ItemUse(ref path, hir::UseKind::Single)\n-                    if item.vis == hir::Visibility::Public => {\n+                    if item.vis.node.is_pub() => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n                             (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n@@ -328,7 +328,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                         as_keyword(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n                     hir::ItemUse(ref path, hir::UseKind::Single)\n-                    if item.vis == hir::Visibility::Public => {\n+                    if item.vis.node.is_pub() => {\n                         as_keyword(path.def).map(|(_, prim, attrs)| {\n                             (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n                         })\n@@ -3225,11 +3225,11 @@ pub enum Visibility {\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n     fn clean(&self, cx: &DocContext) -> Option<Visibility> {\n-        Some(match *self {\n-            hir::Visibility::Public => Visibility::Public,\n-            hir::Visibility::Inherited => Visibility::Inherited,\n-            hir::Visibility::Crate(_) => Visibility::Crate,\n-            hir::Visibility::Restricted { ref path, .. } => {\n+        Some(match self.node {\n+            hir::VisibilityPublic => Visibility::Public,\n+            hir::VisibilityInherited => Visibility::Inherited,\n+            hir::VisibilityCrate(_) => Visibility::Crate,\n+            hir::VisibilityRestricted { ref path, .. } => {\n                 let path = path.clean(cx);\n                 let did = register_def(cx, path.def);\n                 Visibility::Restricted(did, path)\n@@ -3932,7 +3932,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n+        let denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n             a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n                            attr::list_contains_name(&l, \"hidden\"),"}, {"sha": "76c11a4e7cdd8b86bd22203b1b01c77c68a90c81", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -17,6 +17,7 @@ use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ptr::P;\n+use syntax::codemap::Spanned;\n use syntax_pos::{self, Span};\n \n use rustc::hir;\n@@ -53,7 +54,7 @@ impl Module {\n         Module {\n             name       : name,\n             id: ast::CRATE_NODE_ID,\n-            vis: hir::Inherited,\n+            vis: Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityInherited },\n             stab: None,\n             depr: None,\n             where_outer: syntax_pos::DUMMY_SP,"}, {"sha": "3a13f61327e2905cd636d40c25344ebeb1b1f51e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ae89129e1beefbe80cca4a13f6fd6e783653926/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4ae89129e1beefbe80cca4a13f6fd6e783653926", "patch": "@@ -15,7 +15,8 @@ use std::mem;\n \n use syntax::ast;\n use syntax::attr;\n-use syntax_pos::Span;\n+use syntax::codemap::Spanned;\n+use syntax_pos::{self, Span};\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n@@ -94,7 +95,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n \n         self.module = self.visit_mod_contents(krate.span,\n                                               krate.attrs.clone(),\n-                                              hir::Public,\n+                                              Spanned { span: syntax_pos::DUMMY_SP,\n+                                                        node: hir::VisibilityPublic },\n                                               ast::CRATE_NODE_ID,\n                                               &krate.module,\n                                               None);\n@@ -204,7 +206,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         om.id = id;\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n-        self.inside_public_path &= vis == hir::Public;\n+        self.inside_public_path &= vis.node.is_pub();\n         for i in &m.item_ids {\n             let item = self.cx.tcx.hir.expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n@@ -376,7 +378,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.name);\n \n-        if item.vis == hir::Public {\n+        if item.vis.node.is_pub() {\n             let def_id = self.cx.tcx.hir.local_def_id(item.id);\n             self.store_path(def_id);\n         }\n@@ -387,14 +389,14 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 om.foreigns.push(if self.inlining {\n                     hir::ForeignMod {\n                         abi: fm.abi,\n-                        items: fm.items.iter().filter(|i| i.vis == hir::Public).cloned().collect(),\n+                        items: fm.items.iter().filter(|i| i.vis.node.is_pub()).cloned().collect(),\n                     }\n                 } else {\n                     fm.clone()\n                 });\n             }\n             // If we're inlining, skip private items.\n-            _ if self.inlining && item.vis != hir::Public => {}\n+            _ if self.inlining && !item.vis.node.is_pub() => {}\n             hir::ItemGlobalAsm(..) => {}\n             hir::ItemExternCrate(orig_name) => {\n                 let def_id = self.cx.tcx.hir.local_def_id(item.id);\n@@ -414,7 +416,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n \n                 // If there was a private module in the current path then don't bother inlining\n                 // anything as it will probably be stripped anyway.\n-                if item.vis == hir::Public && self.inside_public_path {\n+                if item.vis.node.is_pub() && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n                             Some(ref list) if item.check_name(\"doc\") => {"}]}