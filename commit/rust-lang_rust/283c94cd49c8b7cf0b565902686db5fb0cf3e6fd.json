{"sha": "283c94cd49c8b7cf0b565902686db5fb0cf3e6fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4M2M5NGNkNDljOGI3Y2YwYjU2NTkwMjY4NmRiNWZiMGNmM2U2ZmQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-26T16:18:39Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-08T14:42:47Z"}, "message": "Clean up trans::trans_crate() after making things collector driven.", "tree": {"sha": "7f2df87a9e5d758cb3cf154d67ca6c17cb43f9d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f2df87a9e5d758cb3cf154d67ca6c17cb43f9d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd", "html_url": "https://github.com/rust-lang/rust/commit/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37a10ecbe82c040ae307c48a0a0cdbcd9f05f6a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/37a10ecbe82c040ae307c48a0a0cdbcd9f05f6a3", "html_url": "https://github.com/rust-lang/rust/commit/37a10ecbe82c040ae307c48a0a0cdbcd9f05f6a3"}], "stats": {"total": 131, "additions": 69, "deletions": 62}, "files": [{"sha": "234ed800c47de733a238781ee051c5b28df157ea", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 61, "deletions": 54, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=283c94cd49c8b7cf0b565902686db5fb0cf3e6fd", "patch": "@@ -2198,34 +2198,17 @@ pub fn set_link_section(ccx: &CrateContext,\n     }\n }\n \n-pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n+fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n \n-    let tcx = ccx.tcx();\n     match item.node {\n-        hir::ItemFn(_, _, _, _, _, _) => {\n-            let def_id = tcx.map.local_def_id(item.id);\n-            // check for the #[rustc_error] annotation, which forces an\n-            // error in trans. This is used to write compile-fail tests\n-            // that actually test that compilation succeeds without\n-            // reporting an error.\n-            if is_entry_fn(ccx.sess(), item.id) {\n-                let empty_substs = ccx.empty_substs_for_def_id(def_id);\n-                let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                create_entry_wrapper(ccx, item.span, llfn);\n-                if tcx.has_attr(def_id, \"rustc_error\") {\n-                    tcx.sess.span_fatal(item.span, \"compilation successful\");\n-                }\n-            }\n-\n-            // Function is actually translated in trans_instance\n-        }\n         hir::ItemEnum(ref enum_definition, ref gens) => {\n             if gens.ty_params.is_empty() {\n                 // sizes only make sense for non-generic types\n                 enum_variant_size_lint(ccx, enum_definition, item.span, item.id);\n             }\n         }\n+        hir::ItemFn(..) |\n         hir::ItemImpl(..) |\n         hir::ItemStatic(..) => {\n             // Don't do anything here. Translation has been moved to\n@@ -2235,22 +2218,40 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     }\n }\n \n-pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n-    match *sess.entry_fn.borrow() {\n-        Some((entry_id, _)) => node_id == entry_id,\n-        None => false,\n+/// Create the `main` function which will initialise the rust runtime and call\n+/// users\u2019 main function.\n+pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n+    let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n+        Some((id, span)) => {\n+            (ccx.tcx().map.local_def_id(id), span)\n+        }\n+        None => return,\n+    };\n+\n+    // check for the #[rustc_error] annotation, which forces an\n+    // error in trans. This is used to write compile-fail tests\n+    // that actually test that compilation succeeds without\n+    // reporting an error.\n+    if ccx.tcx().has_attr(main_def_id, \"rustc_error\") {\n+        ccx.tcx().sess.span_fatal(span, \"compilation successful\");\n+    }\n+\n+    let instance = Instance::mono(ccx.shared(), main_def_id);\n+\n+    if !ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)) {\n+        // We want to create the wrapper in the same codegen unit as Rust's main\n+        // function.\n+        return;\n     }\n-}\n \n-/// Create the `main` function which will initialise the rust runtime and call users\u2019 main\n-/// function.\n-pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n+    let main_llfn = Callee::def(ccx, main_def_id, instance.substs).reify(ccx).val;\n+\n     let et = ccx.sess().entry_type.get().unwrap();\n     match et {\n         config::EntryMain => {\n-            create_entry_fn(ccx, sp, main_llfn, true);\n+            create_entry_fn(ccx, span, main_llfn, true);\n         }\n-        config::EntryStart => create_entry_fn(ccx, sp, main_llfn, false),\n+        config::EntryStart => create_entry_fn(ccx, span, main_llfn, false),\n         config::EntryNone => {}    // Do nothing.\n     }\n \n@@ -2590,13 +2591,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-    let (codegen_units, symbol_map) =\n-        collect_and_partition_translation_items(&shared_ccx);\n+    // Run the translation item collector and partition the collected items into\n+    // codegen units.\n+    let (codegen_units, symbol_map) = collect_and_partition_translation_items(&shared_ccx);\n     let codegen_unit_count = codegen_units.len();\n \n-    assert!(tcx.sess.opts.cg.codegen_units == codegen_unit_count ||\n-            tcx.sess.opts.debugging_opts.incremental.is_some());\n-\n     let symbol_map = Rc::new(symbol_map);\n \n     let crate_context_list = CrateContextList::new(&shared_ccx,\n@@ -2642,35 +2641,39 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         for (trans_item, _) in trans_items {\n            trans_item.define(&ccx);\n         }\n-    }\n-\n-    {\n-        let ccx = crate_context_list.get_ccx(0);\n-\n-        // Translate all items. See `TransModVisitor` for\n-        // details on why we walk in this particular way.\n-        {\n-            let _icx = push_ctxt(\"text\");\n-            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n-            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n-        }\n \n-        collector::print_collection_results(ccx.shared());\n+        // If this codegen unit contains the main function, also create the\n+        // wrapper here\n+        maybe_create_entry_wrapper(&ccx);\n \n-        symbol_names_test::report_symbol_names(&ccx);\n-    }\n-\n-    for ccx in crate_context_list.iter() {\n-        if ccx.sess().opts.debuginfo != NoDebugInfo {\n-            debuginfo::finalize(&ccx);\n-        }\n+        // Run replace-all-uses-with for statics that need it\n         for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n             unsafe {\n                 let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n                 llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n                 llvm::LLVMDeleteGlobal(old_g);\n             }\n         }\n+\n+        // Finalize debuginfo\n+        if ccx.sess().opts.debuginfo != NoDebugInfo {\n+            debuginfo::finalize(&ccx);\n+        }\n+    }\n+\n+    collector::print_collection_results(&shared_ccx);\n+    symbol_names_test::report_symbol_names(&shared_ccx);\n+\n+    {\n+        let ccx = crate_context_list.get_ccx(0);\n+\n+        // At this point, we only walk the HIR for running\n+        // enum_variant_size_lint(). This should arguably be moved somewhere\n+        // else\n+        {\n+            intravisit::walk_mod(&mut TransItemsWithinModVisitor { ccx: &ccx }, &krate.module);\n+            krate.visit_all_items(&mut TransModVisitor { ccx: &ccx });\n+        }\n     }\n \n     if shared_ccx.sess().trans_stats() {\n@@ -2696,6 +2699,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         }\n     }\n+\n     if shared_ccx.sess().count_llvm_insns() {\n         for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n             println!(\"{:7} {}\", *v, *k);\n@@ -2867,6 +2871,9 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                                 scx.reachable())\n     });\n \n+    assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n+            scx.tcx().sess.opts.debugging_opts.incremental.is_some());\n+\n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = HashMap::new();\n "}, {"sha": "9a7fe54e0d9f5a9f3dc55cfb96e9efc8af1294e2", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/283c94cd49c8b7cf0b565902686db5fb0cf3e6fd/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=283c94cd49c8b7cf0b565902686db5fb0cf3e6fd", "patch": "@@ -19,40 +19,40 @@ use rustc::hir::intravisit::{self, Visitor};\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n \n-use common::CrateContext;\n+use common::SharedCrateContext;\n use monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n const ITEM_PATH: &'static str = \"rustc_item_path\";\n \n-pub fn report_symbol_names(ccx: &CrateContext) {\n+pub fn report_symbol_names(scx: &SharedCrateContext) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mut visitor = SymbolNamesTest { ccx: ccx };\n+    let mut visitor = SymbolNamesTest { scx: scx };\n     tcx.map.krate().visit_all_items(&mut visitor);\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {\n-    ccx: &'a CrateContext<'a, 'tcx>,\n+    scx: &'a SharedCrateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n                      node_id: ast::NodeId) {\n-        let tcx = self.ccx.tcx();\n+        let tcx = self.scx.tcx();\n         let def_id = tcx.map.local_def_id(node_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(self.ccx.shared(), def_id);\n-                let name = instance.symbol_name(self.ccx.shared());\n+                let instance = Instance::mono(self.scx, def_id);\n+                let name = instance.symbol_name(self.scx);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}]}