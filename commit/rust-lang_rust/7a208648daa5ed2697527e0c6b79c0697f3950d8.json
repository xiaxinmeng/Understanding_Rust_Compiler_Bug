{"sha": "7a208648daa5ed2697527e0c6b79c0697f3950d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMjA4NjQ4ZGFhNWVkMjY5NzUyN2UwYzZiNzljMDY5N2YzOTUwZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-24T23:47:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-24T23:47:38Z"}, "message": "Auto merge of #37382 - jonathandturner:rollup, r=jonathandturner\n\nRollup of 7 pull requests\n\n- Successful merges: #37228, #37304, #37324, #37328, #37336, #37349, #37372\n- Failed merges:", "tree": {"sha": "22528c97460d54494874982e62236c879ee4677b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22528c97460d54494874982e62236c879ee4677b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a208648daa5ed2697527e0c6b79c0697f3950d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a208648daa5ed2697527e0c6b79c0697f3950d8", "html_url": "https://github.com/rust-lang/rust/commit/7a208648daa5ed2697527e0c6b79c0697f3950d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a208648daa5ed2697527e0c6b79c0697f3950d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3caf63cc00f5cec580954bdb117f4fa756cc757d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3caf63cc00f5cec580954bdb117f4fa756cc757d", "html_url": "https://github.com/rust-lang/rust/commit/3caf63cc00f5cec580954bdb117f4fa756cc757d"}, {"sha": "e948cf17bcd4d21e4bef2ab63b76a430967b4c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/e948cf17bcd4d21e4bef2ab63b76a430967b4c29", "html_url": "https://github.com/rust-lang/rust/commit/e948cf17bcd4d21e4bef2ab63b76a430967b4c29"}], "stats": {"total": 1149, "additions": 552, "deletions": 597}, "files": [{"sha": "cabe66f5b2282a8467f7151e95372ff6c607f825", "filename": "src/doc/book/deref-coercions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Fdoc%2Fbook%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Fdoc%2Fbook%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fderef-coercions.md?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -69,7 +69,7 @@ foo(&counted);\n All we\u2019ve done is wrap our `String` in an `Rc<T>`. But we can now pass the\n `Rc<String>` around anywhere we\u2019d have a `String`. The signature of `foo`\n didn\u2019t change, but works just as well with either type. This example has two\n-conversions: `Rc<String>` to `String` and then `String` to `&str`. Rust will do\n+conversions: `&Rc<String>` to `&String` and then `&String` to `&str`. Rust will do\n this as many times as possible until the types match.\n \n Another very common implementation provided by the standard library is:"}, {"sha": "fafdf161b2dc29f3e3c234339ec3fb05b2b684dc", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -445,8 +445,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 let mut err = struct_span_err!(self.tcx.sess, span, E0277,\n                                     \"the trait bound `{}` is not satisfied\",\n                                     trait_ref.to_predicate());\n-                                err.span_label(span, &format!(\"trait `{}` not satisfied\",\n-                                                              trait_ref.to_predicate()));\n+                                err.span_label(span, &format!(\"the trait `{}` is not implemented \\\n+                                                               for `{}`\",\n+                                                              trait_ref,\n+                                                              trait_ref.self_ty()));\n \n                                 // Try to report a help message\n "}, {"sha": "bb36fa1487eeea578bc2dcf062ce9b1ea48db5c3", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -392,27 +392,30 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-// When hashing a type this ends up affecting properties like symbol names. We\n-// want these symbol names to be calculated independent of other factors like\n-// what architecture you're compiling *from*.\n-//\n-// The hashing just uses the standard `Hash` trait, but the implementations of\n-// `Hash` for the `usize` and `isize` types are *not* architecture independent\n-// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n-// `isize` completely when hashing. To ensure that these don't leak in we use a\n-// custom hasher implementation here which inflates the size of these to a `u64`\n-// and `i64`.\n-struct WidenUsizeHasher<H> {\n+/// When hashing a type this ends up affecting properties like symbol names. We\n+/// want these symbol names to be calculated independent of other factors like\n+/// what architecture you're compiling *from*.\n+///\n+/// The hashing just uses the standard `Hash` trait, but the implementations of\n+/// `Hash` for the `usize` and `isize` types are *not* architecture independent\n+/// (e.g. they has 4 or 8 bytes). As a result we want to avoid `usize` and\n+/// `isize` completely when hashing. To ensure that these don't leak in we use a\n+/// custom hasher implementation here which inflates the size of these to a `u64`\n+/// and `i64`.\n+///\n+/// The same goes for endianess: We always convert multi-byte integers to little\n+/// endian before hashing.\n+pub struct ArchIndependentHasher<H> {\n     inner: H,\n }\n \n-impl<H> WidenUsizeHasher<H> {\n-    fn new(inner: H) -> WidenUsizeHasher<H> {\n-        WidenUsizeHasher { inner: inner }\n+impl<H> ArchIndependentHasher<H> {\n+    pub fn new(inner: H) -> ArchIndependentHasher<H> {\n+        ArchIndependentHasher { inner: inner }\n     }\n }\n \n-impl<H: Hasher> Hasher for WidenUsizeHasher<H> {\n+impl<H: Hasher> Hasher for ArchIndependentHasher<H> {\n     fn write(&mut self, bytes: &[u8]) {\n         self.inner.write(bytes)\n     }\n@@ -425,44 +428,44 @@ impl<H: Hasher> Hasher for WidenUsizeHasher<H> {\n         self.inner.write_u8(i)\n     }\n     fn write_u16(&mut self, i: u16) {\n-        self.inner.write_u16(i)\n+        self.inner.write_u16(i.to_le())\n     }\n     fn write_u32(&mut self, i: u32) {\n-        self.inner.write_u32(i)\n+        self.inner.write_u32(i.to_le())\n     }\n     fn write_u64(&mut self, i: u64) {\n-        self.inner.write_u64(i)\n+        self.inner.write_u64(i.to_le())\n     }\n     fn write_usize(&mut self, i: usize) {\n-        self.inner.write_u64(i as u64)\n+        self.inner.write_u64((i as u64).to_le())\n     }\n     fn write_i8(&mut self, i: i8) {\n         self.inner.write_i8(i)\n     }\n     fn write_i16(&mut self, i: i16) {\n-        self.inner.write_i16(i)\n+        self.inner.write_i16(i.to_le())\n     }\n     fn write_i32(&mut self, i: i32) {\n-        self.inner.write_i32(i)\n+        self.inner.write_i32(i.to_le())\n     }\n     fn write_i64(&mut self, i: i64) {\n-        self.inner.write_i64(i)\n+        self.inner.write_i64(i.to_le())\n     }\n     fn write_isize(&mut self, i: isize) {\n-        self.inner.write_i64(i as i64)\n+        self.inner.write_i64((i as i64).to_le())\n     }\n }\n \n pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: WidenUsizeHasher<H>,\n+    state: ArchIndependentHasher<H>,\n }\n \n impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n         TypeIdHasher {\n             tcx: tcx,\n-            state: WidenUsizeHasher::new(state),\n+            state: ArchIndependentHasher::new(state),\n         }\n     }\n \n@@ -493,6 +496,10 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     pub fn def_path(&mut self, def_path: &ast_map::DefPath) {\n         def_path.deterministic_hash_to(self.tcx, &mut self.state);\n     }\n+\n+    pub fn into_inner(self) -> H {\n+        self.state.inner\n+    }\n }\n \n impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, H> {"}, {"sha": "f001f8513197894608907d2031976a41271173e3", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -30,7 +30,7 @@ use rustc_serialize::Encodable;\n pub struct Ast<'tcx> {\n     id_range: IdRange,\n     item: Lazy<InlinedItem>,\n-    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>\n+    side_tables: LazySeq<(ast::NodeId, TableEntry<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -39,7 +39,7 @@ enum TableEntry<'tcx> {\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n     Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n-    ConstQualif(ConstQualif)\n+    ConstQualif(ConstQualif),\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         match ii {\n             InlinedItemRef::Item(_, i) => id_visitor.visit_item(i),\n             InlinedItemRef::TraitItem(_, ti) => id_visitor.visit_trait_item(ti),\n-            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii)\n+            InlinedItemRef::ImplItem(_, ii) => id_visitor.visit_impl_item(ii),\n         }\n \n         let ii_pos = self.position();\n@@ -58,27 +58,27 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let tables_count = {\n             let mut visitor = SideTableEncodingIdVisitor {\n                 ecx: self,\n-                count: 0\n+                count: 0,\n             };\n             match ii {\n                 InlinedItemRef::Item(_, i) => visitor.visit_item(i),\n                 InlinedItemRef::TraitItem(_, ti) => visitor.visit_trait_item(ti),\n-                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii)\n+                InlinedItemRef::ImplItem(_, ii) => visitor.visit_impl_item(ii),\n             }\n             visitor.count\n         };\n \n         self.lazy(&Ast {\n             id_range: id_visitor.result(),\n             item: Lazy::with_position(ii_pos),\n-            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count)\n+            side_tables: LazySeq::with_position_and_length(tables_pos, tables_count),\n         })\n     }\n }\n \n-struct SideTableEncodingIdVisitor<'a, 'b:'a, 'tcx:'b> {\n+struct SideTableEncodingIdVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    count: usize\n+    count: usize,\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx> {\n@@ -114,10 +114,11 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n \n     let cnt = ast.id_range.max.as_usize() - ast.id_range.min.as_usize();\n     let start = tcx.sess.reserve_node_ids(cnt);\n-    let id_ranges = [ast.id_range, IdRange {\n-        min: start,\n-        max: ast::NodeId::new(start.as_usize() + cnt)\n-    }];\n+    let id_ranges = [ast.id_range,\n+                     IdRange {\n+                         min: start,\n+                         max: ast::NodeId::new(start.as_usize() + cnt),\n+                     }];\n \n     let ii = ast.item.decode((cdata, tcx, id_ranges));\n     let ii = ast_map::map_decoded_item(&tcx.map,\n@@ -129,7 +130,7 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n     let item_node_id = match ii {\n         &InlinedItem::Item(_, ref i) => i.id,\n         &InlinedItem::TraitItem(_, ref ti) => ti.id,\n-        &InlinedItem::ImplItem(_, ref ii) => ii.id\n+        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n     };\n     let inlined_did = tcx.map.local_def_id(item_node_id);\n     tcx.register_item_type(inlined_did, tcx.lookup_item_type(orig_did));"}, {"sha": "f0952fd145d597f9922f84f982785166a70d894d", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -54,7 +54,7 @@ pub struct ImportedFileMap {\n     /// The end of this FileMap within the codemap of its original crate\n     pub original_end_pos: syntax_pos::BytePos,\n     /// The imported FileMap's representation within the local codemap\n-    pub translated_filemap: Rc<syntax_pos::FileMap>\n+    pub translated_filemap: Rc<syntax_pos::FileMap>,\n }\n \n pub struct CrateMetadata {\n@@ -141,21 +141,23 @@ impl CStore {\n         self.metas.borrow_mut().insert(cnum, data);\n     }\n \n-    pub fn iter_crate_data<I>(&self, mut i: I) where\n-        I: FnMut(CrateNum, &Rc<CrateMetadata>),\n+    pub fn iter_crate_data<I>(&self, mut i: I)\n+        where I: FnMut(CrateNum, &Rc<CrateMetadata>)\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             i(k, v);\n         }\n     }\n \n     /// Like `iter_crate_data`, but passes source paths (if available) as well.\n-    pub fn iter_crate_data_origins<I>(&self, mut i: I) where\n-        I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>),\n+    pub fn iter_crate_data_origins<I>(&self, mut i: I)\n+        where I: FnMut(CrateNum, &CrateMetadata, Option<CrateSource>)\n     {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n-            origin.as_ref().map(|cs| { assert!(k == cs.cnum); });\n+            origin.as_ref().map(|cs| {\n+                assert!(k == cs.cnum);\n+            });\n             i(k, &v, origin);\n         }\n     }\n@@ -167,10 +169,12 @@ impl CStore {\n         }\n     }\n \n-    pub fn opt_used_crate_source(&self, cnum: CrateNum)\n-                                 -> Option<CrateSource> {\n-        self.used_crate_sources.borrow_mut()\n-            .iter().find(|source| source.cnum == cnum).cloned()\n+    pub fn opt_used_crate_source(&self, cnum: CrateNum) -> Option<CrateSource> {\n+        self.used_crate_sources\n+            .borrow_mut()\n+            .iter()\n+            .find(|source| source.cnum == cnum)\n+            .cloned()\n     }\n \n     pub fn reset(&self) {\n@@ -182,19 +186,17 @@ impl CStore {\n         self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n-    pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum>\n-    {\n+    pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);\n         ordering.reverse();\n         ordering\n     }\n \n-    pub fn push_dependencies_in_postorder(&self,\n-                                          ordering: &mut Vec<CrateNum>,\n-                                          krate: CrateNum)\n-    {\n-        if ordering.contains(&krate) { return }\n+    pub fn push_dependencies_in_postorder(&self, ordering: &mut Vec<CrateNum>, krate: CrateNum) {\n+        if ordering.contains(&krate) {\n+            return;\n+        }\n \n         let data = self.get_crate_data(krate);\n         for &dep in data.cnum_map.borrow().iter() {\n@@ -215,20 +217,25 @@ impl CStore {\n     // In order to get this left-to-right dependency ordering, we perform a\n     // topological sort of all crates putting the leaves at the right-most\n     // positions.\n-    pub fn do_get_used_crates(&self, prefer: LinkagePreference)\n+    pub fn do_get_used_crates(&self,\n+                              prefer: LinkagePreference)\n                               -> Vec<(CrateNum, Option<PathBuf>)> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n         }\n         info!(\"topological ordering: {:?}\", ordering);\n         ordering.reverse();\n-        let mut libs = self.used_crate_sources.borrow()\n+        let mut libs = self.used_crate_sources\n+            .borrow()\n             .iter()\n-            .map(|src| (src.cnum, match prefer {\n-                LinkagePreference::RequireDynamic => src.dylib.clone().map(|p| p.0),\n-                LinkagePreference::RequireStatic => src.rlib.clone().map(|p| p.0),\n-            }))\n+            .map(|src| {\n+                (src.cnum,\n+                 match prefer {\n+                     LinkagePreference::RequireDynamic => src.dylib.clone().map(|p| p.0),\n+                     LinkagePreference::RequireStatic => src.rlib.clone().map(|p| p.0),\n+                 })\n+            })\n             .collect::<Vec<_>>();\n         libs.sort_by(|&(a, _), &(b, _)| {\n             let a = ordering.iter().position(|x| *x == a);\n@@ -243,9 +250,7 @@ impl CStore {\n         self.used_libraries.borrow_mut().push((lib, kind));\n     }\n \n-    pub fn get_used_libraries<'a>(&'a self)\n-                              -> &'a RefCell<Vec<(String,\n-                                                  NativeLibraryKind)>> {\n+    pub fn get_used_libraries<'a>(&'a self) -> &'a RefCell<Vec<(String, NativeLibraryKind)>> {\n         &self.used_libraries\n     }\n \n@@ -255,13 +260,11 @@ impl CStore {\n         }\n     }\n \n-    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String> > {\n+    pub fn get_used_link_args<'a>(&'a self) -> &'a RefCell<Vec<String>> {\n         &self.used_link_args\n     }\n \n-    pub fn add_extern_mod_stmt_cnum(&self,\n-                                    emod_id: ast::NodeId,\n-                                    cnum: CrateNum) {\n+    pub fn add_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId, cnum: CrateNum) {\n         self.extern_mod_crate_map.borrow_mut().insert(emod_id, cnum);\n     }\n \n@@ -273,8 +276,7 @@ impl CStore {\n         self.statically_included_foreign_items.borrow().contains(&id)\n     }\n \n-    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>\n-    {\n+    pub fn do_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n \n@@ -288,14 +290,20 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn name(&self) -> &str { &self.root.name }\n-    pub fn hash(&self) -> Svh { self.root.hash }\n-    pub fn disambiguator(&self) -> &str { &self.root.disambiguator }\n+    pub fn name(&self) -> &str {\n+        &self.root.name\n+    }\n+    pub fn hash(&self) -> Svh {\n+        self.root.hash\n+    }\n+    pub fn disambiguator(&self) -> &str {\n+        &self.root.disambiguator\n+    }\n \n     pub fn is_staged_api(&self) -> bool {\n-        self.get_item_attrs(CRATE_DEF_INDEX).iter().any(|attr| {\n-            attr.name() == \"stable\" || attr.name() == \"unstable\"\n-        })\n+        self.get_item_attrs(CRATE_DEF_INDEX)\n+            .iter()\n+            .any(|attr| attr.name() == \"stable\" || attr.name() == \"unstable\")\n     }\n \n     pub fn is_allocator(&self) -> bool {"}, {"sha": "18b5c0fde1f4c1a829751817946a4e4706002cd5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 276, "deletions": 210, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -56,19 +56,23 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n \n-    lazy_state: LazyState\n+    lazy_state: LazyState,\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n pub trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n-    fn cdata(self) -> Option<&'a CrateMetadata> { None }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { None }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        None\n+    }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+        None\n+    }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let id_range = IdRange {\n             min: NodeId::from_u32(u32::MIN),\n-            max: NodeId::from_u32(u32::MAX)\n+            max: NodeId::from_u32(u32::MAX),\n         };\n         DecodeContext {\n             opaque: opaque::Decoder::new(self.raw_bytes(), pos),\n@@ -77,7 +81,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             from_id_range: id_range,\n             to_id_range: id_range,\n             last_filemap_index: 0,\n-            lazy_state: LazyState::NoNode\n+            lazy_state: LazyState::NoNode,\n         }\n     }\n }\n@@ -92,21 +96,37 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n-    fn raw_bytes(self) -> &'a [u8] { self.blob.raw_bytes() }\n-    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self) }\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.blob.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self)\n+    }\n }\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>) {\n-    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n-    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.0.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self.0)\n+    }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+        Some(self.1)\n+    }\n }\n \n // HACK(eddyb) Only used by astencode to customize the from/to IdRange's.\n impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>, [IdRange; 2]) {\n-    fn raw_bytes(self) -> &'a [u8] { self.0.raw_bytes() }\n-    fn cdata(self) -> Option<&'a CrateMetadata> { Some(self.0) }\n-    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> { Some(self.1) }\n+    fn raw_bytes(self) -> &'a [u8] {\n+        self.0.raw_bytes()\n+    }\n+    fn cdata(self) -> Option<&'a CrateMetadata> {\n+        Some(self.0)\n+    }\n+    fn tcx(self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n+        Some(self.1)\n+    }\n \n     fn decoder(self, pos: usize) -> DecodeContext<'a, 'tcx> {\n         let mut dcx = (self.0, self.1).decoder(pos);\n@@ -125,12 +145,10 @@ impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n }\n \n impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n-    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item=T> + 'a {\n+    pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item = T> + 'a {\n         let mut dcx = meta.decoder(self.position);\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        (0..self.len).map(move |_| {\n-            T::decode(&mut dcx).unwrap()\n-        })\n+        (0..self.len).map(move |_| T::decode(&mut dcx).unwrap())\n     }\n }\n \n@@ -153,20 +171,15 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         r\n     }\n \n-    fn read_lazy_distance(&mut self, min_size: usize)\n-                          -> Result<usize, <Self as Decoder>::Error> {\n+    fn read_lazy_distance(&mut self, min_size: usize) -> Result<usize, <Self as Decoder>::Error> {\n         let distance = self.read_usize()?;\n         let position = match self.lazy_state {\n-            LazyState::NoNode => {\n-                bug!(\"read_lazy_distance: outside of a metadata node\")\n-            }\n+            LazyState::NoNode => bug!(\"read_lazy_distance: outside of a metadata node\"),\n             LazyState::NodeStart(start) => {\n                 assert!(distance + min_size <= start);\n                 start - distance - min_size\n             }\n-            LazyState::Previous(last_min_end) => {\n-                last_min_end + distance\n-            }\n+            LazyState::Previous(last_min_end) => last_min_end + distance,\n         };\n         self.lazy_state = LazyState::Previous(position + min_size);\n         Ok(position)\n@@ -239,13 +252,15 @@ impl<'a, 'tcx> SpecializedDecoder<NodeId> for DecodeContext<'a, 'tcx> {\n         // meaningful result\n         if !self.from_id_range.contains(NodeId::from_u32(id)) {\n             bug!(\"NodeId::decode: {} out of DecodeContext range ({:?} -> {:?})\",\n-                 id, self.from_id_range, self.to_id_range);\n+                 id,\n+                 self.from_id_range,\n+                 self.to_id_range);\n         }\n \n         // Use wrapping arithmetic because otherwise it introduces control flow.\n         // Maybe we should just have the control flow? -- aatch\n         Ok(NodeId::from_u32(id.wrapping_sub(self.from_id_range.min.as_u32())\n-                              .wrapping_add(self.to_id_range.min.as_u32())))\n+            .wrapping_add(self.to_id_range.min.as_u32())))\n     }\n }\n \n@@ -290,10 +305,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             // originate from the same filemap.\n             let last_filemap = &imported_filemaps[self.last_filemap_index];\n \n-            if lo >= last_filemap.original_start_pos &&\n-            lo <= last_filemap.original_end_pos &&\n-            hi >= last_filemap.original_start_pos &&\n-            hi <= last_filemap.original_end_pos {\n+            if lo >= last_filemap.original_start_pos && lo <= last_filemap.original_end_pos &&\n+               hi >= last_filemap.original_start_pos &&\n+               hi <= last_filemap.original_end_pos {\n                 last_filemap\n             } else {\n                 let mut a = 0;\n@@ -313,10 +327,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             }\n         };\n \n-        let lo = (lo - filemap.original_start_pos) +\n-                  filemap.translated_filemap.start_pos;\n-        let hi = (hi - filemap.original_start_pos) +\n-                  filemap.translated_filemap.start_pos;\n+        let lo = (lo - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n+        let hi = (hi - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n \n         Ok(syntax_pos::mk_sp(lo, hi))\n     }\n@@ -336,7 +348,7 @@ impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n             assert!(pos >= SHORTHAND_OFFSET);\n             let key = ty::CReaderCacheKey {\n                 cnum: self.cdata().cnum,\n-                pos: pos - SHORTHAND_OFFSET\n+                pos: pos - SHORTHAND_OFFSET,\n             };\n             if let Some(ty) = tcx.rcache.borrow().get(&key).cloned() {\n                 return Ok(ty);\n@@ -357,17 +369,18 @@ impl<'a, 'tcx> SpecializedDecoder<ty::GenericPredicates<'tcx>> for DecodeContext\n         Ok(ty::GenericPredicates {\n             parent: Decodable::decode(self)?,\n             predicates: (0..self.read_usize()?).map(|_| {\n-                // Handle shorthands first, if we have an usize > 0x80.\n-                if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n-                    let pos = self.read_usize()?;\n-                    assert!(pos >= SHORTHAND_OFFSET);\n-                    let pos = pos - SHORTHAND_OFFSET;\n-\n-                    self.with_position(pos, ty::Predicate::decode)\n-                } else {\n-                    ty::Predicate::decode(self)\n-                }\n-            }).collect::<Result<Vec<_>, _>>()?\n+                    // Handle shorthands first, if we have an usize > 0x80.\n+                    if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n+                        let pos = self.read_usize()?;\n+                        assert!(pos >= SHORTHAND_OFFSET);\n+                        let pos = pos - SHORTHAND_OFFSET;\n+\n+                        self.with_position(pos, ty::Predicate::decode)\n+                    } else {\n+                        ty::Predicate::decode(self)\n+                    }\n+                })\n+                .collect::<Result<Vec<_>, _>>()?,\n         })\n     }\n }\n@@ -411,8 +424,7 @@ impl<'a, 'tcx> MetadataBlob {\n     pub fn get_root(&self) -> CrateRoot {\n         let slice = self.raw_bytes();\n         let offset = METADATA_HEADER.len();\n-        let pos = (((slice[offset + 0] as u32) << 24) |\n-                   ((slice[offset + 1] as u32) << 16) |\n+        let pos = (((slice[offset + 0] as u32) << 24) | ((slice[offset + 1] as u32) << 16) |\n                    ((slice[offset + 2] as u32) << 8) |\n                    ((slice[offset + 3] as u32) << 0)) as usize;\n         Lazy::with_position(pos).decode(self)\n@@ -421,9 +433,9 @@ impl<'a, 'tcx> MetadataBlob {\n     /// Go through each item in the metadata and create a map from that\n     /// item's def-key to the item's DefIndex.\n     pub fn load_key_map(&self, index: LazySeq<Index>) -> FnvHashMap<DefKey, DefIndex> {\n-        index.iter_enumerated(self.raw_bytes()).map(|(index, item)| {\n-            (item.decode(self).def_key.decode(self), index)\n-        }).collect()\n+        index.iter_enumerated(self.raw_bytes())\n+            .map(|(index, item)| (item.decode(self).def_key.decode(self), index))\n+            .collect()\n     }\n \n     pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n@@ -440,7 +452,7 @@ impl<'a, 'tcx> MetadataBlob {\n impl<'tcx> EntryKind<'tcx> {\n     fn to_def(&self, did: DefId) -> Option<Def> {\n         Some(match *self {\n-            EntryKind::Const  => Def::Const(did),\n+            EntryKind::Const => Def::Const(did),\n             EntryKind::AssociatedConst(_) => Def::AssociatedConst(did),\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Def::Static(did, false),\n@@ -462,9 +474,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::DefaultImpl(_) |\n             EntryKind::Field |\n-            EntryKind::Closure (_) => {\n-                return None\n-            }\n+            EntryKind::Closure(_) => return None,\n         })\n     }\n }\n@@ -476,23 +486,29 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn entry(&self, item_id: DefIndex) -> Entry<'tcx> {\n         match self.maybe_entry(item_id) {\n-            None => bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n-                         item_id,\n-                         self.name,\n-                         self.cnum),\n-            Some(d) => d.decode(self)\n+            None => {\n+                bug!(\"entry: id not found: {:?} in crate {:?} with number {}\",\n+                     item_id,\n+                     self.name,\n+                     self.cnum)\n+            }\n+            Some(d) => d.decode(self),\n         }\n     }\n \n     fn local_def_id(&self, index: DefIndex) -> DefId {\n         DefId {\n             krate: self.cnum,\n-            index: index\n+            index: index,\n         }\n     }\n \n     fn item_name(&self, item: &Entry<'tcx>) -> ast::Name {\n-        item.def_key.decode(self).disambiguated_data.data.get_opt_name()\n+        item.def_key\n+            .decode(self)\n+            .disambiguated_data\n+            .data\n+            .get_opt_name()\n             .expect(\"no name in item_name\")\n     }\n \n@@ -502,55 +518,66 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_trait_def(&self,\n                          item_id: DefIndex,\n-                         tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx> {\n+                         tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                         -> ty::TraitDef<'tcx> {\n         let data = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self),\n-            _ => bug!()\n+            _ => bug!(),\n         };\n \n-        ty::TraitDef::new(data.unsafety, data.paren_sugar,\n+        ty::TraitDef::new(data.unsafety,\n+                          data.paren_sugar,\n                           tcx.lookup_generics(self.local_def_id(item_id)),\n                           data.trait_ref.decode((self, tcx)),\n                           self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }\n \n-    fn get_variant(&self, item: &Entry<'tcx>, index: DefIndex)\n+    fn get_variant(&self,\n+                   item: &Entry<'tcx>,\n+                   index: DefIndex)\n                    -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data) |\n             EntryKind::Union(data) => data.decode(self),\n-            _ => bug!()\n+            _ => bug!(),\n         };\n \n-        let fields = item.children.decode(self).map(|index| {\n-            let f = self.entry(index);\n-            ty::FieldDefData::new(self.local_def_id(index),\n-                                  self.item_name(&f),\n-                                  f.visibility)\n-        }).collect();\n+        let fields = item.children\n+            .decode(self)\n+            .map(|index| {\n+                let f = self.entry(index);\n+                ty::FieldDefData::new(self.local_def_id(index), self.item_name(&f), f.visibility)\n+            })\n+            .collect();\n \n         (ty::VariantDefData {\n-            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(item),\n-            fields: fields,\n-            disr_val: ConstInt::Infer(data.disr),\n-            ctor_kind: data.ctor_kind,\n-        }, data.struct_ctor)\n-    }\n-\n-    pub fn get_adt_def(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+             name: self.item_name(item),\n+             fields: fields,\n+             disr_val: ConstInt::Infer(data.disr),\n+             ctor_kind: data.ctor_kind,\n+         },\n+         data.struct_ctor)\n+    }\n+\n+    pub fn get_adt_def(&self,\n+                       item_id: DefIndex,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                        -> ty::AdtDefMaster<'tcx> {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n         let mut ctor_index = None;\n         let variants = if let EntryKind::Enum = item.kind {\n-            item.children.decode(self).map(|index| {\n-                let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n-                assert_eq!(struct_ctor, None);\n-                variant\n-            }).collect()\n-        } else{\n+            item.children\n+                .decode(self)\n+                .map(|index| {\n+                    let (variant, struct_ctor) = self.get_variant(&self.entry(index), index);\n+                    assert_eq!(struct_ctor, None);\n+                    variant\n+                })\n+                .collect()\n+        } else {\n             let (variant, struct_ctor) = self.get_variant(&item, item_id);\n             ctor_index = struct_ctor;\n             vec![variant]\n@@ -559,7 +586,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Enum => ty::AdtKind::Enum,\n             EntryKind::Struct(_) => ty::AdtKind::Struct,\n             EntryKind::Union(_) => ty::AdtKind::Union,\n-            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did)\n+            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n         let adt = tcx.intern_adt_def(did, kind, variants);\n@@ -572,33 +599,41 @@ impl<'a, 'tcx> CrateMetadata {\n         // to support recursive structures\n         for variant in &adt.variants {\n             for field in &variant.fields {\n-                debug!(\"evaluating the type of {:?}::{:?}\", variant.name, field.name);\n+                debug!(\"evaluating the type of {:?}::{:?}\",\n+                       variant.name,\n+                       field.name);\n                 let ty = self.get_type(field.did.index, tcx);\n                 field.fulfill_ty(ty);\n                 debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n-                       variant.name, field.name, ty);\n+                       variant.name,\n+                       field.name,\n+                       ty);\n             }\n         }\n \n         adt\n     }\n \n-    pub fn get_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_predicates(&self,\n+                          item_id: DefIndex,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> ty::GenericPredicates<'tcx> {\n         self.entry(item_id).predicates.unwrap().decode((self, tcx))\n     }\n \n-    pub fn get_super_predicates(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_super_predicates(&self,\n+                                item_id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                 -> ty::GenericPredicates<'tcx> {\n         match self.entry(item_id).kind {\n-            EntryKind::Trait(data) => {\n-                data.decode(self).super_predicates.decode((self, tcx))\n-            }\n-            _ => bug!()\n+            EntryKind::Trait(data) => data.decode(self).super_predicates.decode((self, tcx)),\n+            _ => bug!(),\n         }\n     }\n \n-    pub fn get_generics(&self, item_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_generics(&self,\n+                        item_id: DefIndex,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                         -> ty::Generics<'tcx> {\n         self.entry(item_id).generics.unwrap().decode((self, tcx))\n     }\n@@ -622,7 +657,7 @@ impl<'a, 'tcx> CrateMetadata {\n     fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n         match self.entry(id).kind {\n             EntryKind::Impl(data) => data.decode(self),\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n@@ -634,7 +669,8 @@ impl<'a, 'tcx> CrateMetadata {\n         self.get_impl_data(id).polarity\n     }\n \n-    pub fn get_custom_coerce_unsized_kind(&self, id: DefIndex)\n+    pub fn get_custom_coerce_unsized_kind(&self,\n+                                          id: DefIndex)\n                                           -> Option<ty::adjustment::CustomCoerceUnsized> {\n         self.get_impl_data(id).coerce_unsized_kind\n     }\n@@ -674,37 +710,47 @@ impl<'a, 'tcx> CrateMetadata {\n                             if let Some(def) = self.get_def(child_index) {\n                                 callback(def::Export {\n                                     def: def,\n-                                    name: self.item_name(&self.entry(child_index))\n+                                    name: self.item_name(&self.entry(child_index)),\n                                 });\n                             }\n                         }\n                         continue;\n                     }\n-                    EntryKind::Impl(_) | EntryKind::DefaultImpl(_) => continue,\n+                    EntryKind::Impl(_) |\n+                    EntryKind::DefaultImpl(_) => continue,\n \n                     _ => {}\n                 }\n \n                 let def_key = child.def_key.decode(self);\n-                if let (Some(def), Some(name)) = (self.get_def(child_index),\n-                                                  def_key.disambiguated_data.data.get_opt_name()) {\n-                    callback(def::Export { def: def, name: name });\n+                if let (Some(def), Some(name)) =\n+                    (self.get_def(child_index), def_key.disambiguated_data.data.get_opt_name()) {\n+                    callback(def::Export {\n+                        def: def,\n+                        name: name,\n+                    });\n                     // For non-reexport structs and variants add their constructors to children.\n                     // Reexport lists automatically contain constructors when necessary.\n                     match def {\n                         Def::Struct(..) => {\n                             if let Some(ctor_def_id) = self.get_struct_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n                                 let ctor_def = Def::StructCtor(ctor_def_id, ctor_kind);\n-                                callback(def::Export { def: ctor_def, name: name });\n+                                callback(def::Export {\n+                                    def: ctor_def,\n+                                    name: name,\n+                                });\n                             }\n                         }\n                         Def::Variant(def_id) => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n                             let ctor_kind = self.get_ctor_kind(child_index);\n                             let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-                            callback(def::Export { def: ctor_def, name: name });\n+                            callback(def::Export {\n+                                def: ctor_def,\n+                                name: name,\n+                            });\n                         }\n                         _ => {}\n                     }\n@@ -719,7 +765,9 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn maybe_get_item_ast(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+    pub fn maybe_get_item_ast(&self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              id: DefIndex)\n                               -> Option<&'tcx InlinedItem> {\n         debug!(\"Looking up item: {:?}\", id);\n         let item_doc = self.entry(id);\n@@ -737,12 +785,16 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn maybe_get_item_mir(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+    pub fn maybe_get_item_mir(&self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              id: DefIndex)\n                               -> Option<Mir<'tcx>> {\n         self.entry(id).mir.map(|mir| mir.decode((self, tcx)))\n     }\n \n-    pub fn get_impl_or_trait_item(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn get_impl_or_trait_item(&self,\n+                                  id: DefIndex,\n+                                  tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                   -> Option<ty::ImplOrTraitItem<'tcx>> {\n         let item = self.entry(id);\n         let parent_and_name = || {\n@@ -769,9 +821,11 @@ impl<'a, 'tcx> CrateMetadata {\n                 let ity = item.ty.unwrap().decode((self, tcx));\n                 let fty = match ity.sty {\n                     ty::TyFnDef(.., fty) => fty,\n-                    _ => bug!(\n-                        \"the type {:?} of the method {:?} is not a function?\",\n-                        ity, name)\n+                    _ => {\n+                        bug!(\"the type {:?} of the method {:?} is not a function?\",\n+                             ity,\n+                             name)\n+                    }\n                 };\n \n                 let data = data.decode(self);\n@@ -799,7 +853,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     container: container.with_def_id(parent),\n                 }))\n             }\n-            _ => return None\n+            _ => return None,\n         })\n     }\n \n@@ -821,7 +875,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Struct(data) => {\n                 data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n             }\n-            _ => None\n+            _ => None,\n         }\n     }\n \n@@ -838,35 +892,45 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_struct_field_names(&self, id: DefIndex) -> Vec<ast::Name> {\n-        self.entry(id).children.decode(self).map(|index| {\n-            self.item_name(&self.entry(index))\n-        }).collect()\n+        self.entry(id)\n+            .children\n+            .decode(self)\n+            .map(|index| self.item_name(&self.entry(index)))\n+            .collect()\n     }\n \n     fn get_attributes(&self, item: &Entry<'tcx>) -> Vec<ast::Attribute> {\n-        item.attributes.decode(self).map(|mut attr| {\n-            // Need new unique IDs: old thread-local IDs won't map to new threads.\n-            attr.node.id = attr::mk_attr_id();\n-            attr\n-        }).collect()\n+        item.attributes\n+            .decode(self)\n+            .map(|mut attr| {\n+                // Need new unique IDs: old thread-local IDs won't map to new threads.\n+                attr.node.id = attr::mk_attr_id();\n+                attr\n+            })\n+            .collect()\n     }\n \n     // Translate a DefId from the current compilation environment to a DefId\n     // for an external crate.\n     fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n         for (local, &global) in self.cnum_map.borrow().iter_enumerated() {\n             if global == did.krate {\n-                return Some(DefId { krate: local, index: did.index });\n+                return Some(DefId {\n+                    krate: local,\n+                    index: did.index,\n+                });\n             }\n         }\n \n         None\n     }\n \n     pub fn get_inherent_implementations_for_type(&self, id: DefIndex) -> Vec<DefId> {\n-        self.entry(id).inherent_impls.decode(self).map(|index| {\n-            self.local_def_id(index)\n-        }).collect()\n+        self.entry(id)\n+            .inherent_impls\n+            .decode(self)\n+            .map(|index| self.local_def_id(index))\n+            .collect()\n     }\n \n     pub fn get_implementations_for_trait(&self, filter: Option<DefId>, result: &mut Vec<DefId>) {\n@@ -875,7 +939,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n             Some(Some(def_id)) => Some((def_id.krate.as_u32(), def_id.index)),\n             Some(None) => return,\n-            None => None\n+            None => None,\n         };\n \n         // FIXME(eddyb) Make this O(1) instead of O(n).\n@@ -884,9 +948,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 continue;\n             }\n \n-            result.extend(trait_impls.impls.decode(self).map(|index| {\n-                self.local_def_id(index)\n-            }));\n+            result.extend(trait_impls.impls.decode(self).map(|index| self.local_def_id(index)));\n \n             if filter.is_some() {\n                 break;\n@@ -898,7 +960,7 @@ impl<'a, 'tcx> CrateMetadata {\n         self.entry(id).def_key.decode(self).parent.and_then(|parent_index| {\n             match self.entry(parent_index).kind {\n                 EntryKind::Trait(_) => Some(self.local_def_id(parent_index)),\n-                _ => None\n+                _ => None,\n             }\n         })\n     }\n@@ -909,10 +971,15 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n-        self.root.dylib_dependency_formats.decode(self).enumerate().flat_map(|(i, link)| {\n-            let cnum = CrateNum::new(i + 1);\n-            link.map(|link| (self.cnum_map.borrow()[cnum], link))\n-        }).collect()\n+        self.root\n+            .dylib_dependency_formats\n+            .decode(self)\n+            .enumerate()\n+            .flat_map(|(i, link)| {\n+                let cnum = CrateNum::new(i + 1);\n+                link.map(|link| (self.cnum_map.borrow()[cnum], link))\n+            })\n+            .collect()\n     }\n \n     pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n@@ -924,7 +991,7 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::Fn(data) |\n             EntryKind::ForeignFn(data) => data.decode(self).arg_names,\n             EntryKind::Method(data) => data.decode(self).fn_data.arg_names,\n-            _ => LazySeq::empty()\n+            _ => LazySeq::empty(),\n         };\n         arg_names.decode(self).collect()\n     }\n@@ -937,7 +1004,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let constness = match self.entry(id).kind {\n             EntryKind::Method(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n-            _ => hir::Constness::NotConst\n+            _ => hir::Constness::NotConst,\n         };\n         constness == hir::Constness::Const\n     }\n@@ -953,16 +1020,14 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic => true,\n \n-            EntryKind::Fn(_) | EntryKind::ForeignFn(_) => {\n-                self.get_generics(id, tcx).types.is_empty()\n-            }\n+            EntryKind::Fn(_) |\n+            EntryKind::ForeignFn(_) => self.get_generics(id, tcx).types.is_empty(),\n \n             _ => false,\n         };\n \n         if applicable {\n-            attr::contains_extern_indicator(tcx.sess.diagnostic(),\n-                                            &self.get_attributes(&item))\n+            attr::contains_extern_indicator(tcx.sess.diagnostic(), &self.get_attributes(&item))\n         } else {\n             false\n         }\n@@ -973,36 +1038,38 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::ForeignImmStatic |\n             EntryKind::ForeignMutStatic |\n             EntryKind::ForeignFn(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn is_defaulted_trait(&self, trait_id: DefIndex) -> bool {\n         match self.entry(trait_id).kind {\n             EntryKind::Trait(data) => data.decode(self).has_default_impl,\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n-        match self.entry(impl_id).kind  {\n+        match self.entry(impl_id).kind {\n             EntryKind::DefaultImpl(_) => true,\n-            _ => false\n+            _ => false,\n         }\n     }\n \n     pub fn closure_kind(&self, closure_id: DefIndex) -> ty::ClosureKind {\n         match self.entry(closure_id).kind {\n             EntryKind::Closure(data) => data.decode(self).kind,\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n-    pub fn closure_ty(&self, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+    pub fn closure_ty(&self,\n+                      closure_id: DefIndex,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                       -> ty::ClosureTy<'tcx> {\n         match self.entry(closure_id).kind {\n             EntryKind::Closure(data) => data.decode(self).ty.decode((self, tcx)),\n-            _ => bug!()\n+            _ => bug!(),\n         }\n     }\n \n@@ -1045,7 +1112,8 @@ impl<'a, 'tcx> CrateMetadata {\n     /// file they represent, just information about length, line breaks, and\n     /// multibyte characters. This information is enough to generate valid debuginfo\n     /// for items inlined from other crates.\n-    pub fn imported_filemaps(&'a self, local_codemap: &codemap::CodeMap)\n+    pub fn imported_filemaps(&'a self,\n+                             local_codemap: &codemap::CodeMap)\n                              -> Ref<'a, Vec<cstore::ImportedFileMap>> {\n         {\n             let filemaps = self.codemap_import_info.borrow();\n@@ -1057,67 +1125,66 @@ impl<'a, 'tcx> CrateMetadata {\n         let external_codemap = self.root.codemap.decode(self);\n \n         let imported_filemaps = external_codemap.map(|filemap_to_import| {\n-            // Try to find an existing FileMap that can be reused for the filemap to\n-            // be imported. A FileMap is reusable if it is exactly the same, just\n-            // positioned at a different offset within the codemap.\n-            let reusable_filemap = {\n-                local_codemap.files\n-                             .borrow()\n-                             .iter()\n-                             .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n-                             .map(|rc| rc.clone())\n-            };\n+                // Try to find an existing FileMap that can be reused for the filemap to\n+                // be imported. A FileMap is reusable if it is exactly the same, just\n+                // positioned at a different offset within the codemap.\n+                let reusable_filemap = {\n+                    local_codemap.files\n+                        .borrow()\n+                        .iter()\n+                        .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n+                        .map(|rc| rc.clone())\n+                };\n \n-            match reusable_filemap {\n-                Some(fm) => {\n-                    cstore::ImportedFileMap {\n-                        original_start_pos: filemap_to_import.start_pos,\n-                        original_end_pos: filemap_to_import.end_pos,\n-                        translated_filemap: fm\n-                    }\n-                }\n-                None => {\n-                    // We can't reuse an existing FileMap, so allocate a new one\n-                    // containing the information we need.\n-                    let syntax_pos::FileMap {\n-                        name,\n-                        abs_path,\n-                        start_pos,\n-                        end_pos,\n-                        lines,\n-                        multibyte_chars,\n-                        ..\n-                    } = filemap_to_import;\n-\n-                    let source_length = (end_pos - start_pos).to_usize();\n-\n-                    // Translate line-start positions and multibyte character\n-                    // position into frame of reference local to file.\n-                    // `CodeMap::new_imported_filemap()` will then translate those\n-                    // coordinates to their new global frame of reference when the\n-                    // offset of the FileMap is known.\n-                    let mut lines = lines.into_inner();\n-                    for pos in &mut lines {\n-                        *pos = *pos - start_pos;\n-                    }\n-                    let mut multibyte_chars = multibyte_chars.into_inner();\n-                    for mbc in &mut multibyte_chars {\n-                        mbc.pos = mbc.pos - start_pos;\n+                match reusable_filemap {\n+                    Some(fm) => {\n+                        cstore::ImportedFileMap {\n+                            original_start_pos: filemap_to_import.start_pos,\n+                            original_end_pos: filemap_to_import.end_pos,\n+                            translated_filemap: fm,\n+                        }\n                     }\n+                    None => {\n+                        // We can't reuse an existing FileMap, so allocate a new one\n+                        // containing the information we need.\n+                        let syntax_pos::FileMap { name,\n+                                                  abs_path,\n+                                                  start_pos,\n+                                                  end_pos,\n+                                                  lines,\n+                                                  multibyte_chars,\n+                                                  .. } = filemap_to_import;\n+\n+                        let source_length = (end_pos - start_pos).to_usize();\n+\n+                        // Translate line-start positions and multibyte character\n+                        // position into frame of reference local to file.\n+                        // `CodeMap::new_imported_filemap()` will then translate those\n+                        // coordinates to their new global frame of reference when the\n+                        // offset of the FileMap is known.\n+                        let mut lines = lines.into_inner();\n+                        for pos in &mut lines {\n+                            *pos = *pos - start_pos;\n+                        }\n+                        let mut multibyte_chars = multibyte_chars.into_inner();\n+                        for mbc in &mut multibyte_chars {\n+                            mbc.pos = mbc.pos - start_pos;\n+                        }\n \n-                    let local_version = local_codemap.new_imported_filemap(name,\n-                                                                           abs_path,\n-                                                                           source_length,\n-                                                                           lines,\n-                                                                           multibyte_chars);\n-                    cstore::ImportedFileMap {\n-                        original_start_pos: start_pos,\n-                        original_end_pos: end_pos,\n-                        translated_filemap: local_version\n+                        let local_version = local_codemap.new_imported_filemap(name,\n+                                                                               abs_path,\n+                                                                               source_length,\n+                                                                               lines,\n+                                                                               multibyte_chars);\n+                        cstore::ImportedFileMap {\n+                            original_start_pos: start_pos,\n+                            original_end_pos: end_pos,\n+                            translated_filemap: local_version,\n+                        }\n                     }\n                 }\n-            }\n-        }).collect();\n+            })\n+            .collect();\n \n         // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n         *self.codemap_import_info.borrow_mut() = imported_filemaps;\n@@ -1151,8 +1218,7 @@ fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap, fm2: &syntax_pos::FileMa\n     }\n \n     for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n-        if (mb1.bytes != mb2.bytes) ||\n-            ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n+        if (mb1.bytes != mb2.bytes) || ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n             return false;\n         }\n     }"}, {"sha": "76b778fb61f258b9154eac81cc2f70dddc5d31aa", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -799,9 +799,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 s.as_ptr() as *const c_char,\n                                                 s.len() as c_uint,\n                                                 !null_terminated as Bool);\n-\n-        let gsym = token::gensym(\"str\");\n-        let sym = format!(\"str{}\", gsym.0);\n+        let sym = cx.generate_local_symbol_name(\"str\");\n         let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n             bug!(\"symbol `{}` is already defined\", sym);\n         });"}, {"sha": "0dc10aa7759ea8bee754ed1f9f792ec61735ee60", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -30,7 +30,6 @@ use rustc::hir;\n use std::ffi::{CStr, CString};\n use syntax::ast;\n use syntax::attr;\n-use syntax::parse::token;\n \n pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     unsafe {\n@@ -44,10 +43,7 @@ pub fn addr_of_mut(ccx: &CrateContext,\n                    kind: &str)\n                     -> ValueRef {\n     unsafe {\n-        // FIXME: this totally needs a better name generation scheme, perhaps a simple global\n-        // counter? Also most other uses of gensym in trans.\n-        let gsym = token::gensym(\"_\");\n-        let name = format!(\"{}{}\", kind, gsym.0);\n+        let name = ccx.generate_local_symbol_name(kind);\n         let gv = declare::define_global(ccx, &name[..], val_ty(cv)).unwrap_or_else(||{\n             bug!(\"symbol `{}` is already defined\", name);\n         });"}, {"sha": "2a72d42296d19b733c05fb300a967af1d43cb598", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -166,6 +166,9 @@ pub struct LocalCrateContext<'tcx> {\n     type_of_depth: Cell<usize>,\n \n     symbol_map: Rc<SymbolMap<'tcx>>,\n+\n+    /// A counter that is used for generating local symbol names\n+    local_gen_sym_counter: Cell<usize>,\n }\n \n // Implement DepTrackingMapConfig for `trait_cache`\n@@ -688,6 +691,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n                 symbol_map: symbol_map,\n+                local_gen_sym_counter: Cell::new(0),\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -1021,6 +1025,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n         self.shared().empty_substs_for_def_id(item_def_id)\n     }\n+\n+    /// Generate a new symbol name with the given prefix. This symbol name must\n+    /// only be used for definitions with `internal` or `private` linkage.\n+    pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n+        let idx = self.local().local_gen_sym_counter.get();\n+        self.local().local_gen_sym_counter.set(idx + 1);\n+        // Include a '.' character, so there can be no accidental conflicts with\n+        // user defined names\n+        format!(\"{}.{}\", prefix, idx)\n+    }\n }\n \n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);"}, {"sha": "2804e3ffe37ddd2ca30f06b3da7009146e0704d9", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 47, "deletions": 201, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -16,7 +16,7 @@ use self::EnumDiscriminantInfo::*;\n use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                    get_namespace_and_span_for_item, create_DIArray, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n-use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n+use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use context::SharedCrateContext;\n use session::Session;\n@@ -26,8 +26,11 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DI\n \n use rustc::hir::def::CtorKind;\n use rustc::hir::def_id::DefId;\n+use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n+use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n+use rustc_data_structures::blake2b;\n use {type_of, machine, monomorphize};\n use common::CrateContext;\n use type_::Type;\n@@ -38,6 +41,7 @@ use util::common::path2cstr;\n \n use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n+use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n use std::rc::Rc;\n@@ -46,6 +50,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax_pos::{self, Span};\n \n+\n // From DWARF 5.\n // See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n const DW_LANG_RUST: c_uint = 0x1c;\n@@ -138,219 +143,58 @@ impl<'tcx> TypeMap<'tcx> {\n     // ID will be generated and stored for later lookup.\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n-\n-        // basic type             -> {:name of the type:}\n-        // tuple                  -> {tuple_(:param-uid:)*}\n-        // struct                 -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum                   -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum variant           -> {variant_:variant-name:_:enum-uid:}\n-        // reference (&)          -> {& :pointee-uid:}\n-        // mut reference (&mut)   -> {&mut :pointee-uid:}\n-        // ptr (*)                -> {* :pointee-uid:}\n-        // mut ptr (*mut)         -> {*mut :pointee-uid:}\n-        // unique ptr (box)       -> {box :pointee-uid:}\n-        // @-ptr (@)              -> {@ :pointee-uid:}\n-        // sized vec ([T; x])     -> {[:size:] :element-uid:}\n-        // unsized vec ([T])      -> {[] :element-uid:}\n-        // trait (T)              -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n-        // closure                -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n-        //                             :return-type-uid: : (:bounds:)*}\n-        // function               -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n-        //                             :return-type-uid:}\n-\n+        // Let's see if we already have something in the cache\n         match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n             None => { /* generate one */}\n         };\n \n-        let mut unique_type_id = String::with_capacity(256);\n-        unique_type_id.push('{');\n-\n-        match type_.sty {\n-            ty::TyNever    |\n-            ty::TyBool     |\n-            ty::TyChar     |\n-            ty::TyStr      |\n-            ty::TyInt(_)   |\n-            ty::TyUint(_)  |\n-            ty::TyFloat(_) => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyAdt(def, substs) => {\n-                unique_type_id.push_str(&(String::from(def.descr()) + \" \"));\n-                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n-            }\n-            ty::TyTuple(component_types) if component_types.is_empty() => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyTuple(component_types) => {\n-                unique_type_id.push_str(\"tuple \");\n-                for &component_type in component_types {\n-                    let component_type_id =\n-                        self.get_unique_type_id_of_type(cx, component_type);\n-                    let component_type_id =\n-                        self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(&component_type_id[..]);\n-                }\n-            },\n-            ty::TyBox(inner_type) => {\n-                unique_type_id.push_str(\"box \");\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-                unique_type_id.push('*');\n-                if mutbl == hir::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-                unique_type_id.push('&');\n-                if mutbl == hir::MutMutable {\n-                    unique_type_id.push_str(\"mut\");\n-                }\n-\n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyArray(inner_type, len) => {\n-                unique_type_id.push_str(&format!(\"[{}]\", len));\n+        let mut type_id_hasher = TypeIdHasher::new(cx.tcx(),\n+                                                   DebugInfoTypeIdHasher::new());\n+        type_id_hasher.visit_ty(type_);\n+        let hash = type_id_hasher.into_inner().into_hash();\n \n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TySlice(inner_type) => {\n-                unique_type_id.push_str(\"[]\");\n+        let mut unique_type_id = String::with_capacity(TYPE_ID_HASH_LENGTH * 2);\n \n-                let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n-                let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(&inner_type_id[..]);\n-            },\n-            ty::TyTrait(ref trait_data) => {\n-                unique_type_id.push_str(\"trait \");\n-\n-                let principal = cx.tcx().erase_late_bound_regions_and_normalize(\n-                    &trait_data.principal);\n-\n-                from_def_id_and_substs(self,\n-                                       cx,\n-                                       principal.def_id,\n-                                       principal.substs,\n-                                       &mut unique_type_id);\n-            },\n-            ty::TyFnDef(.., &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-            ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-                if unsafety == hir::Unsafety::Unsafe {\n-                    unique_type_id.push_str(\"unsafe \");\n-                }\n+        for byte in hash.into_iter() {\n+            write!(&mut unique_type_id, \"{:x}\", byte).unwrap();\n+        }\n \n-                unique_type_id.push_str(abi.name());\n+        let key = self.unique_id_interner.intern(&unique_type_id);\n+        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n-                unique_type_id.push_str(\" fn(\");\n+        return UniqueTypeId(key);\n \n-                let sig = cx.tcx().erase_late_bound_regions_and_normalize(sig);\n+        // The hasher we are using to generate the UniqueTypeId. We want\n+        // something that provides more than the 64 bits of the DefaultHasher.\n+        const TYPE_ID_HASH_LENGTH: usize = 20;\n \n-                for &parameter_type in &sig.inputs {\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_of_type(cx, parameter_type);\n-                    let parameter_type_id =\n-                        self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(&parameter_type_id[..]);\n-                    unique_type_id.push(',');\n-                }\n-\n-                if sig.variadic {\n-                    unique_type_id.push_str(\"...\");\n-                }\n+        struct DebugInfoTypeIdHasher {\n+            state: blake2b::Blake2bCtx\n+        }\n \n-                unique_type_id.push_str(\")->\");\n-                let return_type_id = self.get_unique_type_id_of_type(cx, sig.output);\n-                let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(&return_type_id[..]);\n-            },\n-            ty::TyClosure(_, substs) if substs.upvar_tys.is_empty() => {\n-                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n-            },\n-            ty::TyClosure(_, substs) => {\n-                unique_type_id.push_str(\"closure \");\n-                for upvar_type in substs.upvar_tys {\n-                    let upvar_type_id =\n-                        self.get_unique_type_id_of_type(cx, upvar_type);\n-                    let upvar_type_id =\n-                        self.get_unique_type_id_as_string(upvar_type_id);\n-                    unique_type_id.push_str(&upvar_type_id[..]);\n-                }\n-            },\n-            _ => {\n-                bug!(\"get_unique_type_id_of_type() - unexpected type: {:?}\",\n-                     type_)\n+        impl ::std::hash::Hasher for DebugInfoTypeIdHasher {\n+            fn finish(&self) -> u64 {\n+                unimplemented!()\n             }\n-        };\n-\n-        unique_type_id.push('}');\n-\n-        // Trim to size before storing permanently\n-        unique_type_id.shrink_to_fit();\n-\n-        let key = self.unique_id_interner.intern(&unique_type_id);\n-        self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n-        return UniqueTypeId(key);\n-\n-        fn from_def_id_and_substs<'a, 'tcx>(type_map: &mut TypeMap<'tcx>,\n-                                            cx: &CrateContext<'a, 'tcx>,\n-                                            def_id: DefId,\n-                                            substs: &Substs<'tcx>,\n-                                            output: &mut String) {\n-            // First, find out the 'real' def_id of the type. Items inlined from\n-            // other crates have to be mapped back to their source.\n-            let def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n-                if cx.tcx().map.is_inlined_node_id(node_id) {\n-                    // The given def_id identifies the inlined copy of a\n-                    // type definition, let's take the source of the copy.\n-                    cx.defid_for_inlined_node(node_id).unwrap()\n-                } else {\n-                    def_id\n-                }\n-            } else {\n-                def_id\n-            };\n+            #[inline]\n+            fn write(&mut self, bytes: &[u8]) {\n+                blake2b::blake2b_update(&mut self.state, bytes);\n+            }\n+        }\n \n-            // Get the crate name/disambiguator as first part of the identifier.\n-            let crate_name = if def_id.is_local() {\n-                cx.tcx().crate_name.clone()\n-            } else {\n-                cx.sess().cstore.original_crate_name(def_id.krate)\n-            };\n-            let crate_disambiguator = cx.tcx().crate_disambiguator(def_id.krate);\n-\n-            output.push_str(&crate_name[..]);\n-            output.push_str(\"/\");\n-            output.push_str(&crate_disambiguator[..]);\n-            output.push_str(\"/\");\n-            // Add the def-index as the second part\n-            output.push_str(&format!(\"{:x}\", def_id.index.as_usize()));\n-\n-            if substs.types().next().is_some() {\n-                output.push('<');\n-\n-                for type_parameter in substs.types() {\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_of_type(cx, type_parameter);\n-                    let param_type_id =\n-                        type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(&param_type_id[..]);\n-                    output.push(',');\n+        impl DebugInfoTypeIdHasher {\n+            fn new() -> DebugInfoTypeIdHasher {\n+                DebugInfoTypeIdHasher {\n+                    state: blake2b::blake2b_new(TYPE_ID_HASH_LENGTH, &[])\n                 }\n+            }\n \n-                output.push('>');\n+            fn into_hash(self) -> [u8; TYPE_ID_HASH_LENGTH] {\n+                let mut hash = [0u8; TYPE_ID_HASH_LENGTH];\n+                blake2b::blake2b_final(self.state, &mut hash);\n+                hash\n             }\n         }\n     }\n@@ -1927,15 +1771,17 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         return;\n     }\n \n+    let tcx = cx.tcx();\n+\n     // Don't create debuginfo for globals inlined from other crates. The other\n     // crate should already contain debuginfo for it. More importantly, the\n     // global might not even exist in un-inlined form anywhere which would lead\n     // to a linker errors.\n-    if cx.tcx().map.is_inlined_node_id(node_id) {\n+    if tcx.map.is_inlined_node_id(node_id) {\n         return;\n     }\n \n-    let node_def_id = cx.tcx().map.local_def_id(node_id);\n+    let node_def_id = tcx.map.local_def_id(node_id);\n     let (var_scope, span) = get_namespace_and_span_for_item(cx, node_def_id);\n \n     let (file_metadata, line_number) = if span != syntax_pos::DUMMY_SP {\n@@ -1946,9 +1792,9 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = cx.tcx().node_id_to_type(node_id);\n+    let variable_type = tcx.erase_regions(&tcx.node_id_to_type(node_id));\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let var_name = cx.tcx().item_name(node_def_id).to_string();\n+    let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");\n \n     let var_name = CString::new(var_name).unwrap();"}, {"sha": "b9e92a01b2f8e72a72102d3ec756bd3731a9110b", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 65, "deletions": 55, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -15,7 +15,7 @@\n //! standard implementations, it should be possible for two libraries to\n //! communicate without significant data conversion.\n //!\n-//! To get this out of the way: you should probably just use `Vec` or `HashMap`.\n+//! To get this out of the way: you should probably just use [`Vec`] or [`HashMap`].\n //! These two collections cover most use cases for generic data storage and\n //! processing. They are exceptionally good at doing what they do. All the other\n //! collections in the standard library have specific use cases where they are\n@@ -25,10 +25,10 @@\n //!\n //! Rust's collections can be grouped into four major categories:\n //!\n-//! * Sequences: `Vec`, `VecDeque`, `LinkedList`\n-//! * Maps: `HashMap`, `BTreeMap`\n-//! * Sets: `HashSet`, `BTreeSet`\n-//! * Misc: `BinaryHeap`\n+//! * Sequences: [`Vec`], [`VecDeque`], [`LinkedList`]\n+//! * Maps: [`HashMap`], [`BTreeMap`]\n+//! * Sets: [`HashSet`], [`BTreeSet`]\n+//! * Misc: [`BinaryHeap`]\n //!\n //! # When Should You Use Which Collection?\n //!\n@@ -46,13 +46,13 @@\n //! * You want a heap-allocated array.\n //!\n //! ### Use a `VecDeque` when:\n-//! * You want a `Vec` that supports efficient insertion at both ends of the\n+//! * You want a [`Vec`] that supports efficient insertion at both ends of the\n //!   sequence.\n //! * You want a queue.\n //! * You want a double-ended queue (deque).\n //!\n //! ### Use a `LinkedList` when:\n-//! * You want a `Vec` or `VecDeque` of unknown size, and can't tolerate\n+//! * You want a [`Vec`] or [`VecDeque`] of unknown size, and can't tolerate\n //!   amortization.\n //! * You want to efficiently split and append lists.\n //! * You are *absolutely* certain you *really*, *truly*, want a doubly linked\n@@ -92,38 +92,38 @@\n //! Throughout the documentation, we will follow a few conventions. For all\n //! operations, the collection's size is denoted by n. If another collection is\n //! involved in the operation, it contains m elements. Operations which have an\n-//! *amortized* cost are suffixed with a `*`.  Operations with an *expected*\n+//! *amortized* cost are suffixed with a `*`. Operations with an *expected*\n //! cost are suffixed with a `~`.\n //!\n //! All amortized costs are for the potential need to resize when capacity is\n-//! exhausted.  If a resize occurs it will take O(n) time. Our collections never\n+//! exhausted. If a resize occurs it will take O(n) time. Our collections never\n //! automatically shrink, so removal operations aren't amortized. Over a\n //! sufficiently large series of operations, the average cost per operation will\n //! deterministically equal the given cost.\n //!\n-//! Only HashMap has expected costs, due to the probabilistic nature of hashing.\n-//! It is theoretically possible, though very unlikely, for HashMap to\n+//! Only [`HashMap`] has expected costs, due to the probabilistic nature of hashing.\n+//! It is theoretically possible, though very unlikely, for [`HashMap`] to\n //! experience worse performance.\n //!\n //! ## Sequences\n //!\n-//! |              | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n-//! |--------------|----------------|-----------------|----------------|--------|----------------|\n-//! | Vec          | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n-//! | VecDeque     | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n-//! | LinkedList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n+//! |                | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n+//! |----------------|----------------|-----------------|----------------|--------|----------------|\n+//! | [`Vec`]        | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! | [`VecDeque`]   | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n+//! | [`LinkedList`] | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n //!\n-//! Note that where ties occur, Vec is generally going to be faster than VecDeque, and VecDeque\n-//! is generally going to be faster than LinkedList.\n+//! Note that where ties occur, [`Vec`] is generally going to be faster than [`VecDeque`], and\n+//! [`VecDeque`] is generally going to be faster than [`LinkedList`].\n //!\n //! ## Maps\n //!\n //! For Sets, all operations have the cost of the equivalent Map operation.\n //!\n-//! |          | get       | insert   | remove   | predecessor | append |\n-//! |----------|-----------|----------|----------|-------------|--------|\n-//! | HashMap  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n-//! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n+//! |              | get       | insert   | remove   | predecessor | append |\n+//! |--------------|-----------|----------|----------|-------------|--------|\n+//! | [`HashMap`]  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n+//! | [`BTreeMap`] | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n //!\n //! # Correct and Efficient Usage of Collections\n //!\n@@ -136,7 +136,7 @@\n //! ## Capacity Management\n //!\n //! Many collections provide several constructors and methods that refer to\n-//! \"capacity\".  These collections are generally built on top of an array.\n+//! \"capacity\". These collections are generally built on top of an array.\n //! Optimally, this array would be exactly the right size to fit only the\n //! elements stored in the collection, but for the collection to do this would\n //! be very inefficient. If the backing array was exactly the right size at all\n@@ -157,29 +157,29 @@\n //! information to do this itself. Therefore, it is up to us programmers to give\n //! it hints.\n //!\n-//! Any `with_capacity` constructor will instruct the collection to allocate\n+//! Any `with_capacity()` constructor will instruct the collection to allocate\n //! enough space for the specified number of elements. Ideally this will be for\n //! exactly that many elements, but some implementation details may prevent\n-//! this. `Vec` and `VecDeque` can be relied on to allocate exactly the\n-//! requested amount, though. Use `with_capacity` when you know exactly how many\n+//! this. [`Vec`] and [`VecDeque`] can be relied on to allocate exactly the\n+//! requested amount, though. Use `with_capacity()` when you know exactly how many\n //! elements will be inserted, or at least have a reasonable upper-bound on that\n //! number.\n //!\n-//! When anticipating a large influx of elements, the `reserve` family of\n+//! When anticipating a large influx of elements, the `reserve()` family of\n //! methods can be used to hint to the collection how much room it should make\n-//! for the coming items.  As with `with_capacity`, the precise behavior of\n+//! for the coming items. As with `with_capacity()`, the precise behavior of\n //! these methods will be specific to the collection of interest.\n //!\n //! For optimal performance, collections will generally avoid shrinking\n-//! themselves.  If you believe that a collection will not soon contain any more\n-//! elements, or just really need the memory, the `shrink_to_fit` method prompts\n+//! themselves. If you believe that a collection will not soon contain any more\n+//! elements, or just really need the memory, the `shrink_to_fit()` method prompts\n //! the collection to shrink the backing array to the minimum size capable of\n //! holding its elements.\n //!\n //! Finally, if ever you're interested in what the actual capacity of the\n-//! collection is, most collections provide a `capacity` method to query this\n-//! information on demand.  This can be useful for debugging purposes, or for\n-//! use with the `reserve` methods.\n+//! collection is, most collections provide a `capacity()` method to query this\n+//! information on demand. This can be useful for debugging purposes, or for\n+//! use with the `reserve()` methods.\n //!\n //! ## Iterators\n //!\n@@ -194,15 +194,15 @@\n //!\n //! All of the standard collections provide several iterators for performing\n //! bulk manipulation of their contents. The three primary iterators almost\n-//! every collection should provide are `iter`, `iter_mut`, and `into_iter`.\n+//! every collection should provide are `iter()`, `iter_mut()`, and `into_iter()`.\n //! Some of these are not provided on collections where it would be unsound or\n //! unreasonable to provide them.\n //!\n-//! `iter` provides an iterator of immutable references to all the contents of a\n-//! collection in the most \"natural\" order. For sequence collections like `Vec`,\n+//! `iter()` provides an iterator of immutable references to all the contents of a\n+//! collection in the most \"natural\" order. For sequence collections like [`Vec`],\n //! this means the items will be yielded in increasing order of index starting\n-//! at 0. For ordered collections like `BTreeMap`, this means that the items\n-//! will be yielded in sorted order.  For unordered collections like `HashMap`,\n+//! at 0. For ordered collections like [`BTreeMap`], this means that the items\n+//! will be yielded in sorted order. For unordered collections like [`HashMap`],\n //! the items will be yielded in whatever order the internal representation made\n //! most convenient. This is great for reading through all the contents of the\n //! collection.\n@@ -214,8 +214,8 @@\n //! }\n //! ```\n //!\n-//! `iter_mut` provides an iterator of *mutable* references in the same order as\n-//! `iter`.  This is great for mutating all the contents of the collection.\n+//! `iter_mut()` provides an iterator of *mutable* references in the same order as\n+//! `iter()`. This is great for mutating all the contents of the collection.\n //!\n //! ```\n //! let mut vec = vec![1, 2, 3, 4];\n@@ -224,12 +224,12 @@\n //! }\n //! ```\n //!\n-//! `into_iter` transforms the actual collection into an iterator over its\n+//! `into_iter()` transforms the actual collection into an iterator over its\n //! contents by-value. This is great when the collection itself is no longer\n-//! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n+//! needed, and the values are needed elsewhere. Using `extend()` with `into_iter()`\n //! is the main way that contents of one collection are moved into another.\n-//! `extend` automatically calls `into_iter`, and takes any `T: IntoIterator`.\n-//! Calling `collect` on an iterator itself is also a great way to convert one\n+//! `extend()` automatically calls `into_iter()`, and takes any `T: `[`IntoIterator`].\n+//! Calling `collect()` on an iterator itself is also a great way to convert one\n //! collection into another. Both of these methods should internally use the\n //! capacity management tools discussed in the previous section to do this as\n //! efficiently as possible.\n@@ -248,9 +248,9 @@\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common\n-//! threads to sequences. Among the adapters are functional favorites like `map`,\n-//! `fold`, `skip`, and `take`. Of particular interest to collections is the\n-//! `rev` adapter, that reverses any iterator that supports this operation. Most\n+//! threads to sequences. Among the adapters are functional favorites like `map()`,\n+//! `fold()`, `skip()` and `take()`. Of particular interest to collections is the\n+//! `rev()` adapter, that reverses any iterator that supports this operation. Most\n //! collections provide reversible iterators as the way to iterate over them in\n //! reverse order.\n //!\n@@ -263,42 +263,42 @@\n //!\n //! Several other collection methods also return iterators to yield a sequence\n //! of results but avoid allocating an entire collection to store the result in.\n-//! This provides maximum flexibility as `collect` or `extend` can be called to\n+//! This provides maximum flexibility as `collect()` or `extend()` can be called to\n //! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n //! can be looped over with a `for` loop. The iterator can also be discarded\n //! after partial use, preventing the computation of the unused items.\n //!\n //! ## Entries\n //!\n-//! The `entry` API is intended to provide an efficient mechanism for\n+//! The `entry()` API is intended to provide an efficient mechanism for\n //! manipulating the contents of a map conditionally on the presence of a key or\n //! not. The primary motivating use case for this is to provide efficient\n //! accumulator maps. For instance, if one wishes to maintain a count of the\n //! number of times each key has been seen, they will have to perform some\n //! conditional logic on whether this is the first time the key has been seen or\n-//! not. Normally, this would require a `find` followed by an `insert`,\n+//! not. Normally, this would require a `find()` followed by an `insert()`,\n //! effectively duplicating the search effort on each insertion.\n //!\n //! When a user calls `map.entry(&key)`, the map will search for the key and\n //! then yield a variant of the `Entry` enum.\n //!\n //! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case\n-//! the only valid operation is to `insert` a value into the entry. When this is\n+//! the only valid operation is to `insert()` a value into the entry. When this is\n //! done, the vacant entry is consumed and converted into a mutable reference to\n //! the value that was inserted. This allows for further manipulation of the\n //! value beyond the lifetime of the search itself. This is useful if complex\n //! logic needs to be performed on the value regardless of whether the value was\n //! just inserted.\n //!\n //! If an `Occupied(entry)` is yielded, then the key *was* found. In this case,\n-//! the user has several options: they can `get`, `insert`, or `remove` the\n+//! the user has several options: they can `get()`, `insert()` or `remove()` the\n //! value of the occupied entry. Additionally, they can convert the occupied\n //! entry into a mutable reference to its value, providing symmetry to the\n-//! vacant `insert` case.\n+//! vacant `insert()` case.\n //!\n //! ### Examples\n //!\n-//! Here are the two primary ways in which `entry` is used. First, a simple\n+//! Here are the two primary ways in which `entry()` is used. First, a simple\n //! example where the logic performed on the values is trivial.\n //!\n //! #### Counting the number of times each character in a string occurs\n@@ -322,7 +322,7 @@\n //! ```\n //!\n //! When the logic to be performed on the value is more complex, we may simply\n-//! use the `entry` API to ensure that the value is initialized, and perform the\n+//! use the `entry()` API to ensure that the value is initialized and perform the\n //! logic afterwards.\n //!\n //! #### Tracking the inebriation of customers at a bar\n@@ -406,6 +406,16 @@\n //! // ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n //! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n //! ```\n+//!\n+//! [`Vec`]: ../../std/vec/struct.Vec.html\n+//! [`HashMap`]: ../../std/collections/struct.HashMap.html\n+//! [`VecDeque`]: ../../std/collections/struct.VecDeque.html\n+//! [`LinkedList`]: ../../std/collections/struct.LinkedList.html\n+//! [`BTreeMap`]: ../../std/collections/struct.BTreeMap.html\n+//! [`HashSet`]: ../../std/collections/struct.HashSet.html\n+//! [`BTreeSet`]: ../../std/collections/struct.BTreeSet.html\n+//! [`BinaryHeap`]: ../../std/collections/struct.BinaryHeap.html\n+//! [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "a55318d388396034a03381e51c0287331b590145", "filename": "src/libstd/path.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -1294,14 +1294,18 @@ impl Into<OsString> for PathBuf {\n /// This type supports a number of operations for inspecting a path, including\n /// breaking the path into its components (separated by `/` or `\\`, depending on\n /// the platform), extracting the file name, determining whether the path is\n-/// absolute, and so on. More details about the overall approach can be found in\n-/// the module documentation.\n+/// absolute, and so on.\n ///\n /// This is an *unsized* type, meaning that it must always be used behind a\n-/// pointer like `&` or [`Box`].\n+/// pointer like `&` or [`Box`]. For an owned version of this type,\n+/// see [`PathBuf`].\n ///\n /// [`str`]: ../primitive.str.html\n /// [`Box`]: ../boxed/struct.Box.html\n+/// [`PathBuf`]: struct.PathBuf.html\n+///\n+/// More details about the overall approach can be found in\n+/// the module documentation.\n ///\n /// # Examples\n ///"}, {"sha": "33b4221b73338b454f993ab62a4f1a3c8f2f23e7", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -19,12 +19,12 @@\n // CHECK: @STATIC = {{.*}}, align 4\n \n // This checks the constants from inline_enum_const\n-// CHECK: @ref{{[0-9]+}} = {{.*}}, align 2\n+// CHECK: @ref.{{[0-9]+}} = {{.*}}, align 2\n \n // This checks the constants from {low,high}_align_const, they share the same\n // constant, but the alignment differs, so the higher one should be used\n-// CHECK: [[LOW_HIGH:@ref[0-9]+]] = {{.*}}, align 4\n-// CHECK: [[LOW_HIGH_REF:@const[0-9]+]] = {{.*}} [[LOW_HIGH]]\n+// CHECK: [[LOW_HIGH:@ref.[0-9]+]] = {{.*}}, align 4\n+// CHECK: [[LOW_HIGH_REF:@const.[0-9]+]] = {{.*}} [[LOW_HIGH]]\n \n #[derive(Copy, Clone)]\n "}, {"sha": "e4cb50cd3f25348deaa0d65df285e1ff5d600ef1", "filename": "src/test/compile-fail/E0277.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2FE0277.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2FE0277.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0277.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -19,6 +19,6 @@ fn some_func<T: Foo>(foo: T) {\n fn main() {\n     some_func(5i32);\n     //~^ ERROR the trait bound `i32: Foo` is not satisfied\n-    //~| NOTE trait `i32: Foo` not satisfied\n+    //~| NOTE the trait `Foo` is not implemented for `i32`\n     //~| NOTE required by `some_func`\n }"}, {"sha": "5a19aecf667f0fedfd77550fffaaff60b5d7bc34", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -32,5 +32,5 @@ fn ice<A>(a: A) {\n     let r = loop {};\n     r = r + a;\n     //~^ ERROR the trait bound `(): Add<A>` is not satisfied\n-    //~| NOTE trait `(): Add<A>` not satisfied\n+    //~| NOTE the trait `Add<A>` is not implemented for `()`\n }"}, {"sha": "0c373057c76e05fb36d7dd9cc2d4a862b160762e", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -92,7 +92,7 @@ fn main()\n     let _ = v as *const [u8]; //~ ERROR cannot cast\n     let _ = fat_v as *const Foo;\n     //~^ ERROR the trait bound `[u8]: std::marker::Sized` is not satisfied\n-    //~| NOTE trait `[u8]: std::marker::Sized` not satisfied\n+    //~| NOTE the trait `std::marker::Sized` is not implemented for `[u8]`\n     //~| NOTE `[u8]` does not have a constant size known at compile-time\n     //~| NOTE required for the cast to the object type `Foo`\n     let _ = foo as *const str; //~ ERROR casting\n@@ -107,7 +107,7 @@ fn main()\n     let a : *const str = \"hello\";\n     let _ = a as *const Foo;\n     //~^ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n-    //~| NOTE trait `str: std::marker::Sized` not satisfied\n+    //~| NOTE the trait `std::marker::Sized` is not implemented for `str`\n     //~| NOTE `str` does not have a constant size known at compile-time\n     //~| NOTE required for the cast to the object type `Foo`\n "}, {"sha": "226b567c546e52fcb54f9b8c147ce7c435e43ce0", "filename": "src/test/compile-fail/const-unsized.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-unsized.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -12,25 +12,25 @@ use std::fmt::Debug;\n \n const CONST_0: Debug+Sync = *(&0 as &(Debug+Sync));\n //~^ ERROR `std::fmt::Debug + Sync + 'static: std::marker::Sized` is not satisfied\n-//~| NOTE `std::fmt::Debug + Sync + 'static: std::marker::Sized` not satisfied\n+//~| NOTE the trait `std::marker::Sized` is not implemented for `std::fmt::Debug + Sync + 'static`\n //~| NOTE does not have a constant size known at compile-time\n //~| NOTE constant expressions must have a statically known size\n \n const CONST_FOO: str = *\"foo\";\n //~^ ERROR `str: std::marker::Sized` is not satisfied\n-//~| NOTE `str: std::marker::Sized` not satisfied\n+//~| NOTE the trait `std::marker::Sized` is not implemented for `str`\n //~| NOTE does not have a constant size known at compile-time\n //~| NOTE constant expressions must have a statically known size\n \n static STATIC_1: Debug+Sync = *(&1 as &(Debug+Sync));\n //~^ ERROR `std::fmt::Debug + Sync + 'static: std::marker::Sized` is not satisfied\n-//~| NOTE `std::fmt::Debug + Sync + 'static: std::marker::Sized` not satisfied\n+//~| NOTE the trait `std::marker::Sized` is not implemented for `std::fmt::Debug + Sync + 'static`\n //~| NOTE does not have a constant size known at compile-time\n //~| NOTE constant expressions must have a statically known size\n \n static STATIC_BAR: str = *\"bar\";\n //~^ ERROR `str: std::marker::Sized` is not satisfied\n-//~| NOTE `str: std::marker::Sized` not satisfied\n+//~| NOTE the trait `std::marker::Sized` is not implemented for `str`\n //~| NOTE does not have a constant size known at compile-time\n //~| NOTE constant expressions must have a statically known size\n "}, {"sha": "f055d20e1343be79178270ef1fa266801aa6537a", "filename": "src/test/compile-fail/impl-trait/auto-trait-leak.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -26,15 +26,15 @@ fn send<T: Send>(_: T) {}\n fn main() {\n     send(before());\n     //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n-    //~| NOTE trait `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` not satisfied\n+    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n     //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n     //~| NOTE required because it appears within the type `[closure\n     //~| NOTE required because it appears within the type `impl std::ops::Fn<(i32,)>`\n     //~| NOTE required by `send`\n \n     send(after());\n     //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n-    //~| NOTE trait `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` not satisfied\n+    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n     //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n     //~| NOTE required because it appears within the type `[closure\n     //~| NOTE required because it appears within the type `impl std::ops::Fn<(i32,)>`\n@@ -54,7 +54,7 @@ fn after() -> impl Fn(i32) {\n fn cycle1() -> impl Clone {\n     send(cycle2().clone());\n     //~^ ERROR the trait bound `std::rc::Rc<std::string::String>: std::marker::Send` is not satisfied\n-    //~| NOTE trait `std::rc::Rc<std::string::String>: std::marker::Send` not satisfied\n+    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::string::String>`\n     //~| NOTE `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n     //~| NOTE required because it appears within the type `impl std::clone::Clone`\n     //~| NOTE required by `send`\n@@ -65,7 +65,7 @@ fn cycle1() -> impl Clone {\n fn cycle2() -> impl Clone {\n     send(cycle1().clone());\n     //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n-    //~| NOTE trait `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` not satisfied\n+    //~| NOTE the trait `std::marker::Send` is not implemented for `std::rc::Rc<std::cell::Cell<i32>>`\n     //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n     //~| NOTE required because it appears within the type `impl std::clone::Clone`\n     //~| NOTE required by `send`"}, {"sha": "0ad9f21e0983f491bc079f65dfec4e4e76656f5f", "filename": "src/test/compile-fail/on-unimplemented/multiple-impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fmultiple-impls.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -42,17 +42,17 @@ impl Index<Bar<usize>> for [i32] {\n fn main() {\n     Index::index(&[] as &[i32], 2u32);\n     //~^ ERROR E0277\n-    //~| NOTE not satisfied\n+    //~| NOTE the trait `Index<u32>` is not implemented for `[i32]`\n     //~| NOTE trait message\n     //~| NOTE required by\n     Index::index(&[] as &[i32], Foo(2u32));\n     //~^ ERROR E0277\n-    //~| NOTE not satisfied\n+    //~| NOTE the trait `Index<Foo<u32>>` is not implemented for `[i32]`\n     //~| NOTE on impl for Foo\n     //~| NOTE required by\n     Index::index(&[] as &[i32], Bar(2u32));\n     //~^ ERROR E0277\n-    //~| NOTE not satisfied\n+    //~| NOTE the trait `Index<Bar<u32>>` is not implemented for `[i32]`\n     //~| NOTE on impl for Bar\n     //~| NOTE required by\n }"}, {"sha": "a7c599330a070e70051a8b9b7771bcefb7c26b12", "filename": "src/test/compile-fail/on-unimplemented/on-impl.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-impl.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -29,8 +29,9 @@ impl Index<usize> for [i32] {\n \n #[rustc_error]\n fn main() {\n-    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n-                                                     //~| NOTE not satisfied\n-                                                     //~| NOTE a usize is required\n-                                                     //~| NOTE required by\n+    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32);\n+    //~^ ERROR E0277\n+    //~| NOTE the trait `Index<u32>` is not implemented for `[i32]`\n+    //~| NOTE a usize is required\n+    //~| NOTE required by\n }"}, {"sha": "ef7695af3e12e52cbb7acee91892048927770d80", "filename": "src/test/compile-fail/on-unimplemented/on-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fon-trait.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -35,9 +35,9 @@ pub fn main() {\n     //~^ ERROR\n     //~^^ NOTE a collection of type `std::option::Option<std::vec::Vec<u8>>` cannot be built from an iterator over elements of type `&u8`\n     //~^^^ NOTE required by `collect`\n-    //~| NOTE trait `std::option::Option<std::vec::Vec<u8>>: MyFromIterator<&u8>` not satisfied\n+    //~| NOTE the trait `MyFromIterator<&u8>` is not implemented for `std::option::Option<std::vec::Vec<u8>>`\n     let x: String = foobar(); //~ ERROR\n     //~^ NOTE test error `std::string::String` with `u8` `_` `u32`\n     //~^^ NOTE required by `foobar`\n-    //~| NOTE trait `std::string::String: Foo<u8, _, u32>` not satisfied\n+    //~| NOTE the trait `Foo<u8, _, u32>` is not implemented for `std::string::String`\n }"}, {"sha": "d528d0e626a79511d619509e50c9c2618432f531", "filename": "src/test/compile-fail/on-unimplemented/slice-index.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -17,10 +17,12 @@ use std::ops::Index;\n #[rustc_error]\n fn main() {\n     let x = &[1, 2, 3] as &[i32];\n-    x[1i32]; //~ ERROR E0277\n-             //~| NOTE trait `[i32]: std::ops::Index<i32>` not satisfied\n-             //~| NOTE slice indices are of type `usize`\n-    x[..1i32]; //~ ERROR E0277\n-               //~| NOTE trait `[i32]: std::ops::Index<std::ops::RangeTo<i32>>` not satisfied\n-               //~| NOTE slice indices are of type `usize`\n+    x[1i32];\n+    //~^ ERROR E0277\n+    //~| NOTE the trait `std::ops::Index<i32>` is not implemented for `[i32]`\n+    //~| NOTE slice indices are of type `usize`\n+    x[..1i32];\n+    //~^ ERROR E0277\n+    //~| NOTE the trait `std::ops::Index<std::ops::RangeTo<i32>>` is not implemented for `[i32]`\n+    //~| NOTE slice indices are of type `usize`\n }"}, {"sha": "7530d8890b98c9397f45e10bb23fab948959ecf7", "filename": "src/test/compile-fail/trait-suggest-where-clause.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Ftrait-suggest-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Fcompile-fail%2Ftrait-suggest-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-suggest-where-clause.rs?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -16,13 +16,13 @@ fn check<T: Iterator, U: ?Sized>() {\n     // suggest a where-clause, if needed\n     mem::size_of::<U>();\n     //~^ ERROR `U: std::marker::Sized` is not satisfied\n-    //~| NOTE trait `U: std::marker::Sized` not satisfied\n+    //~| NOTE the trait `std::marker::Sized` is not implemented for `U`\n     //~| HELP consider adding a `where U: std::marker::Sized` bound\n     //~| NOTE required by `std::mem::size_of`\n \n     mem::size_of::<Misc<U>>();\n     //~^ ERROR `U: std::marker::Sized` is not satisfied\n-    //~| NOTE trait `U: std::marker::Sized` not satisfied\n+    //~| NOTE the trait `std::marker::Sized` is not implemented for `U`\n     //~| HELP consider adding a `where U: std::marker::Sized` bound\n     //~| NOTE required because it appears within the type `Misc<U>`\n     //~| NOTE required by `std::mem::size_of`\n@@ -31,34 +31,34 @@ fn check<T: Iterator, U: ?Sized>() {\n \n     <u64 as From<T>>::from;\n     //~^ ERROR `u64: std::convert::From<T>` is not satisfied\n-    //~| NOTE trait `u64: std::convert::From<T>` not satisfied\n+    //~| NOTE the trait `std::convert::From<T>` is not implemented for `u64`\n     //~| HELP consider adding a `where u64: std::convert::From<T>` bound\n     //~| NOTE required by `std::convert::From::from`\n \n     <u64 as From<<T as Iterator>::Item>>::from;\n     //~^ ERROR `u64: std::convert::From<<T as std::iter::Iterator>::Item>` is not satisfied\n-    //~| NOTE trait `u64: std::convert::From<<T as std::iter::Iterator>::Item>` not satisfied\n+    //~| NOTE the trait `std::convert::From<<T as std::iter::Iterator>::Item>` is not implemented\n     //~| HELP consider adding a `where u64:\n     //~| NOTE required by `std::convert::From::from`\n \n     // ... but not if there are inference variables\n \n     <Misc<_> as From<T>>::from;\n     //~^ ERROR `Misc<_>: std::convert::From<T>` is not satisfied\n-    //~| NOTE trait `Misc<_>: std::convert::From<T>` not satisfied\n+    //~| NOTE the trait `std::convert::From<T>` is not implemented for `Misc<_>`\n     //~| NOTE required by `std::convert::From::from`\n \n     // ... and also not if the error is not related to the type\n \n     mem::size_of::<[T]>();\n     //~^ ERROR `[T]: std::marker::Sized` is not satisfied\n-    //~| NOTE `[T]: std::marker::Sized` not satisfied\n+    //~| NOTE the trait `std::marker::Sized` is not implemented for `[T]`\n     //~| NOTE `[T]` does not have a constant size\n     //~| NOTE required by `std::mem::size_of`\n \n     mem::size_of::<[&U]>();\n     //~^ ERROR `[&U]: std::marker::Sized` is not satisfied\n-    //~| NOTE `[&U]: std::marker::Sized` not satisfied\n+    //~| NOTE the trait `std::marker::Sized` is not implemented for `[&U]`\n     //~| NOTE `[&U]` does not have a constant size\n     //~| NOTE required by `std::mem::size_of`\n }"}, {"sha": "1c117cf0c9e62b18b81d113f233a6d76c6022aab", "filename": "src/test/run-make/symbols-are-reasonable/Makefile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7a208648daa5ed2697527e0c6b79c0697f3950d8/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile?ref=7a208648daa5ed2697527e0c6b79c0697f3950d8", "patch": "@@ -1,7 +1,7 @@\n -include ../tools.mk\n \n # check that the compile generated symbols for strings, binaries,\n-# vtables, etc. have semisane names (e.g. `str1234`); it's relatively\n+# vtables, etc. have semisane names (e.g. `str.1234`); it's relatively\n # easy to accidentally modify the compiler internals to make them\n # become things like `str\"str\"(1234)`.\n \n@@ -10,6 +10,6 @@ OUT=$(TMPDIR)/lib.s\n all:\n \t$(RUSTC) lib.rs --emit=asm --crate-type=staticlib\n \t# just check for symbol declarations with the names we're expecting.\n-\tgrep 'str[0-9][0-9]*:' $(OUT)\n-\tgrep 'byte_str[0-9][0-9]*:' $(OUT)\n-\tgrep 'vtable[0-9][0-9]*' $(OUT)\n+\tgrep 'str.[0-9][0-9]*:' $(OUT)\n+\tgrep 'byte_str.[0-9][0-9]*:' $(OUT)\n+\tgrep 'vtable.[0-9][0-9]*' $(OUT)"}]}