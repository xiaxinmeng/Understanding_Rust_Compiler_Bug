{"sha": "7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MDczNDVlNThiNGY0ZDJjOTVlNWVhOWI4ZTBiM2JmZjg5NDY1MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-26T14:47:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-26T14:47:51Z"}, "message": "Auto merge of #81217 - ssomers:btree_bring_back_the_slice, r=Mark-Simulacrum\n\nBTreeMap: bring back the key slice for immutable lookup\n\nPave the way for binary search, by reverting a bit of #73971, which banned `keys` for misbehaving while it was defined for every `BorrowType`. Adding some `debug_assert`s along the way.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "8c93b50ca6d90521aaf074f8c0bc82d9583c065d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c93b50ca6d90521aaf074f8c0bc82d9583c065d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "html_url": "https://github.com/rust-lang/rust/commit/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1483e67addd37d9bd20ba3b4613b678ee9ad4d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/1483e67addd37d9bd20ba3b4613b678ee9ad4d68", "html_url": "https://github.com/rust-lang/rust/commit/1483e67addd37d9bd20ba3b4613b678ee9ad4d68"}, {"sha": "c0e807563c9974d7f73f5ecceb1de4a4c132de1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e807563c9974d7f73f5ecceb1de4a4c132de1d", "html_url": "https://github.com/rust-lang/rust/commit/c0e807563c9974d7f73f5ecceb1de4a4c132de1d"}], "stats": {"total": 66, "additions": 23, "deletions": 43}, "files": [{"sha": "57fad4217b6c6381760dfe323e4940604d7b4c5b", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "patch": "@@ -238,13 +238,12 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n /// such restrictions:\n /// - For each type parameter, we can only define a method either generically\n ///   or for one particular type. For example, we cannot define a method like\n-///   `key_at` generically for all `BorrowType`, because we want it to return\n-///   `&'a K` for most choices of `BorrowType`, but plain `K` for `Owned`.\n-///   We cannot define `key_at` once for all types that carry a lifetime.\n+///   `into_kv` generically for all `BorrowType`, or once for all types that\n+///   carry a lifetime, because we want it to return `&'a` references.\n ///   Therefore, we define it only for the least powerful type `Immut<'a>`.\n /// - We cannot get implicit coercion from say `Mut<'a>` to `Immut<'a>`.\n ///   Therefore, we have to explicitly call `reborrow` on a more powerfull\n-///   `NodeRef` in order to reach a method like `key_at`.\n+///   `NodeRef` in order to reach a method like `into_kv`.\n ///\n /// All methods on `NodeRef` that return some kind of reference, either:\n /// - Take `self` by value, and return the lifetime carried by `BorrowType`.\n@@ -344,26 +343,6 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Exposes one of the keys stored in the node.\n-    ///\n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    pub unsafe fn key_at(self, idx: usize) -> &'a K {\n-        debug_assert!(idx < self.len());\n-        unsafe { self.into_leaf().keys.get_unchecked(idx).assume_init_ref() }\n-    }\n-\n-    /// Exposes one of the values stored in the node.\n-    ///\n-    /// # Safety\n-    /// The node has more than `idx` initialized elements.\n-    unsafe fn val_at(self, idx: usize) -> &'a V {\n-        debug_assert!(idx < self.len());\n-        unsafe { self.into_leaf().vals.get_unchecked(idx).assume_init_ref() }\n-    }\n-}\n-\n impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n     /// node actually has a parent, where `handle` points to the edge of the parent\n@@ -421,6 +400,14 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.\n         unsafe { &*ptr }\n     }\n+\n+    /// Borrows a view into the keys stored in the node.\n+    pub fn keys(&self) -> &[K] {\n+        let leaf = self.into_leaf();\n+        unsafe {\n+            MaybeUninit::slice_assume_init_ref(leaf.keys.get_unchecked(..usize::from(leaf.len)))\n+        }\n+    }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n@@ -987,7 +974,11 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        (unsafe { self.node.key_at(self.idx) }, unsafe { self.node.val_at(self.idx) })\n+        debug_assert!(self.idx < self.node.len());\n+        let leaf = self.node.into_leaf();\n+        let k = unsafe { leaf.keys.get_unchecked(self.idx).assume_init_ref() };\n+        let v = unsafe { leaf.vals.get_unchecked(self.idx).assume_init_ref() };\n+        (k, v)\n     }\n }\n \n@@ -997,6 +988,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n     }\n \n     pub fn into_val_mut(self) -> &'a mut V {\n+        debug_assert!(self.idx < self.node.len());\n         let leaf = self.node.into_leaf_mut();\n         unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() }\n     }\n@@ -1010,6 +1002,7 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::ValMut<'a>, K, V, NodeType>, mar\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n+        debug_assert!(self.idx < self.node.len());\n         // We cannot call separate key and value methods, because calling the second one\n         // invalidates the reference returned by the first.\n         unsafe {"}, {"sha": "11433cd845beeed6c3f3b1f8497a0ff49a720961", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "patch": "@@ -29,17 +29,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n             navigate::Position::Leaf(leaf) => {\n                 let depth = self.height();\n                 let indent = \"  \".repeat(depth);\n-                result += &format!(\"\\n{}\", indent);\n-                if leaf.len() == 0 {\n-                    result += \"(empty node)\";\n-                } else {\n-                    for idx in 0..leaf.len() {\n-                        if idx > 0 {\n-                            result += \", \";\n-                        }\n-                        result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n-                    }\n-                }\n+                result += &format!(\"\\n{}{:?}\", indent, leaf.keys());\n             }\n             navigate::Position::Internal(_) => {}\n             navigate::Position::InternalKV(kv) => {"}, {"sha": "d8bebed758f1aaa23ea5379455550a526b4366e4", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7907345e58b4f4d2c95e5ea9b8e0b3bff8946523/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=7907345e58b4f4d2c95e5ea9b8e0b3bff8946523", "patch": "@@ -71,18 +71,15 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         Q: Ord,\n         K: Borrow<Q>,\n     {\n-        // This function is defined over all borrow types (immutable, mutable, owned).\n-        // Using `keys_at()` is fine here even if BorrowType is mutable, as all we return\n-        // is an index -- not a reference.\n-        let len = self.len();\n-        for i in 0..len {\n-            let k = unsafe { self.reborrow().key_at(i) };\n+        let node = self.reborrow();\n+        let keys = node.keys();\n+        for (i, k) in keys.iter().enumerate() {\n             match key.cmp(k.borrow()) {\n                 Ordering::Greater => {}\n                 Ordering::Equal => return IndexResult::KV(i),\n                 Ordering::Less => return IndexResult::Edge(i),\n             }\n         }\n-        IndexResult::Edge(len)\n+        IndexResult::Edge(keys.len())\n     }\n }"}]}