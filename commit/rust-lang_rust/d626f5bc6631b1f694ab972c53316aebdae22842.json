{"sha": "d626f5bc6631b1f694ab972c53316aebdae22842", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MjZmNWJjNjYzMWIxZjY5NGFiOTcyYzUzMzE2YWViZGFlMjI4NDI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-24T06:13:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-24T06:13:35Z"}, "message": "Rollup merge of #70077 - Aaron1011:feature/new-def-path-ident, r=petrochenkov\n\nStore idents for `DefPathData` into crate metadata\n\nPreviously, we threw away the `Span` associated with a definition's\nidentifier when we encoded crate metadata, causing us to lose location\nand hygiene information.\n\nWe now store the identifier's `Span` in a side table, which gets encoded\ninto the crate metadata. When we decode items from the metadata, we\ncombine the name and span back into an `Ident`.\n\nThis improves the output of several tests, which previously had messages\nsuppressed due to dummy spans.\n\nThis is a prerequisite for #68686, since throwing away a `Span` means\nthat we lose hygiene information.", "tree": {"sha": "f3d2b2f286ffb4ec0c0494f04429973710470747", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3d2b2f286ffb4ec0c0494f04429973710470747"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d626f5bc6631b1f694ab972c53316aebdae22842", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeaUPCRBK7hj4Ov3rIwAAdHIIAKCPiKjOz/emw3dpiqXwr4r4\n8v3hK+hS87Cn//GDOzbE2LZWM7LAUWTwAdm4UATA0G487OG67Vvvd7Vl0Vcco1IK\nvznMkVu8zh2RnJux+Wub36MGc0gcSX7B29ANhpAth0MS9G4IMlAVvG2StNob0amz\n1x4Y9BlTeTJRVZOoJZA946iqhhUIXDCKCkqidUBY2MWsBqS0K2W5wL8vHbM+Njbr\ng6V3KU1CV6crmrw7BSinUtV4dVpnfHt6z3FFlqbOn1vu6KbzqDXYabux/YAE+nMk\n0Mq/+2tahrThAQ1eyFBG+I0yGzl8BenJF+6dPAVF+qgzk6isi9FPoAu+SuEA1OE=\n=EUkX\n-----END PGP SIGNATURE-----\n", "payload": "tree f3d2b2f286ffb4ec0c0494f04429973710470747\nparent 3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0\nparent 86b8dea5ecb10dd12f9e352e9f31ced88a16e5e8\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585030415 +0100\ncommitter GitHub <noreply@github.com> 1585030415 +0100\n\nRollup merge of #70077 - Aaron1011:feature/new-def-path-ident, r=petrochenkov\n\nStore idents for `DefPathData` into crate metadata\n\nPreviously, we threw away the `Span` associated with a definition's\nidentifier when we encoded crate metadata, causing us to lose location\nand hygiene information.\n\nWe now store the identifier's `Span` in a side table, which gets encoded\ninto the crate metadata. When we decode items from the metadata, we\ncombine the name and span back into an `Ident`.\n\nThis improves the output of several tests, which previously had messages\nsuppressed due to dummy spans.\n\nThis is a prerequisite for #68686, since throwing away a `Span` means\nthat we lose hygiene information.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d626f5bc6631b1f694ab972c53316aebdae22842", "html_url": "https://github.com/rust-lang/rust/commit/d626f5bc6631b1f694ab972c53316aebdae22842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d626f5bc6631b1f694ab972c53316aebdae22842/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0", "html_url": "https://github.com/rust-lang/rust/commit/3d8b9614d3aae6ef8bd877e3f020f7ac8ad7f7e0"}, {"sha": "86b8dea5ecb10dd12f9e352e9f31ced88a16e5e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b8dea5ecb10dd12f9e352e9f31ced88a16e5e8", "html_url": "https://github.com/rust-lang/rust/commit/86b8dea5ecb10dd12f9e352e9f31ced88a16e5e8"}], "stats": {"total": 420, "additions": 345, "deletions": 75}, "files": [{"sha": "4520df588996e7a7dfec470e41088d05481731ef", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -509,14 +509,6 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl SpecializedDecoder<Ident> for DecodeContext<'_, '_> {\n-    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n-        // FIXME(jseyfried): intercrate hygiene\n-\n-        Ok(Ident::with_dummy_span(Symbol::decode(self)?))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n         Fingerprint::decode_opaque(&mut self.opaque)\n@@ -663,15 +655,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n         if !self.is_proc_macro(item_index) {\n-            self.def_key(item_index)\n+            let name = self\n+                .def_key(item_index)\n                 .disambiguated_data\n                 .data\n                 .get_opt_name()\n-                .expect(\"no name in item_name\")\n+                .expect(\"no name in item_ident\");\n+            let span = self\n+                .root\n+                .per_def\n+                .ident_span\n+                .get(self, item_index)\n+                .map(|data| data.decode((self, sess)))\n+                .unwrap_or_else(|| panic!(\"Missing ident span for {:?} ({:?})\", name, item_index));\n+            Ident::new(name, span)\n         } else {\n-            Symbol::intern(self.raw_proc_macro(item_index).name())\n+            Ident::new(\n+                Symbol::intern(self.raw_proc_macro(item_index).name()),\n+                self.get_span(item_index, sess),\n+            )\n         }\n     }\n \n@@ -750,6 +754,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         kind: &EntryKind,\n         index: DefIndex,\n         parent_did: DefId,\n+        sess: &Session,\n     ) -> ty::VariantDef {\n         let data = match kind {\n             EntryKind::Variant(data) | EntryKind::Struct(data, _) | EntryKind::Union(data, _) => {\n@@ -771,7 +776,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         ty::VariantDef::new(\n             tcx,\n-            Ident::with_dummy_span(self.item_name(index)),\n+            self.item_ident(index, sess),\n             variant_did,\n             ctor_did,\n             data.discr,\n@@ -783,7 +788,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    ident: Ident::with_dummy_span(self.item_name(index)),\n+                    ident: self.item_ident(index, sess),\n                     vis: self.get_visibility(index),\n                 })\n                 .collect(),\n@@ -812,10 +817,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n                 .decode(self)\n-                .map(|index| self.get_variant(tcx, &self.kind(index), index, did))\n+                .map(|index| self.get_variant(tcx, &self.kind(index), index, did, tcx.sess))\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &kind, item_id, did)).collect()\n+            std::iter::once(self.get_variant(tcx, &kind, item_id, did, tcx.sess)).collect()\n         };\n \n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n@@ -1007,7 +1012,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: Ident::with_dummy_span(self.item_name(child_index)),\n+                                    ident: self.item_ident(child_index, sess),\n                                     vis: self.get_visibility(child_index),\n                                     span: self\n                                         .root\n@@ -1028,10 +1033,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 let def_key = self.def_key(child_index);\n                 let span = self.get_span(child_index, sess);\n-                if let (Some(kind), Some(name)) =\n-                    (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name())\n-                {\n-                    let ident = Ident::with_dummy_span(name);\n+                if let (Some(kind), true) = (\n+                    self.def_kind(child_index),\n+                    def_key.disambiguated_data.data.get_opt_name().is_some(),\n+                ) {\n+                    let ident = self.item_ident(child_index, sess);\n                     let vis = self.get_visibility(child_index);\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n@@ -1138,10 +1144,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    fn get_associated_item(&self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n-        let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n+        let ident = self.item_ident(id, sess);\n \n         let (kind, container, has_self) = match self.kind(id) {\n             EntryKind::AssocConst(container, _, _) => (ty::AssocKind::Const, container, false),\n@@ -1155,7 +1161,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         ty::AssocItem {\n-            ident: Ident::with_dummy_span(name),\n+            ident,\n             kind,\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n@@ -1219,7 +1225,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .get(self, id)\n             .unwrap_or(Lazy::empty())\n             .decode(self)\n-            .map(|index| respan(self.get_span(index, sess), self.item_name(index)))\n+            .map(|index| respan(self.get_span(index, sess), self.item_ident(index, sess).name))\n             .collect()\n     }\n "}, {"sha": "b9f1dd1663eee4de658b95efab064ad54e36776b", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -110,7 +110,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n           |child| result.push(child.res.def_id()), tcx.sess);\n         tcx.arena.alloc_slice(&result)\n     }\n-    associated_item => { cdata.get_associated_item(def_id.index) }\n+    associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n     impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n     coerce_unsized_info => {\n@@ -442,8 +442,8 @@ impl CStore {\n         )\n     }\n \n-    pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n-        self.get_crate_data(def.krate).get_associated_item(def.index)\n+    pub fn associated_item_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::AssocItem {\n+        self.get_crate_data(def.krate).get_associated_item(def.index, sess)\n     }\n \n     pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {"}, {"sha": "9718d192816207c8887e43910d1dda21e90bff7e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -12,7 +12,7 @@ use rustc::traits::specialization_graph;\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_ast::ast;\n+use rustc_ast::ast::{self, Ident};\n use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -30,7 +30,7 @@ use rustc_index::vec::Idx;\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n use rustc_session::config::{self, CrateType};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n@@ -220,13 +220,6 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n     }\n }\n \n-impl SpecializedEncoder<Ident> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, ident: &Ident) -> Result<(), Self::Error> {\n-        // FIXME(jseyfried): intercrate hygiene\n-        ident.name.encode(self)\n-    }\n-}\n-\n impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -633,6 +626,7 @@ impl EncodeContext<'tcx> {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n+        self.encode_ident_span(def_id, variant.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n@@ -735,6 +729,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- field.vis);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.per_def.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n+        self.encode_ident_span(def_id, field.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n@@ -869,6 +864,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- trait_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n         record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        self.encode_ident_span(def_id, ast_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -952,6 +948,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- impl_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n         record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1058,6 +1055,8 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n+        self.encode_ident_span(def_id, item.ident);\n+\n         record!(self.per_def.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n@@ -1284,6 +1283,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- macro_def.span);\n         record!(self.per_def.attributes[def_id] <- macro_def.attrs);\n+        self.encode_ident_span(def_id, macro_def.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n@@ -1528,6 +1528,7 @@ impl EncodeContext<'tcx> {\n             ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n         record!(self.per_def.span[def_id] <- nitem.span);\n         record!(self.per_def.attributes[def_id] <- nitem.attrs);\n+        self.encode_ident_span(def_id, nitem.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1622,6 +1623,10 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n+    fn encode_ident_span(&mut self, def_id: DefId, ident: Ident) {\n+        record!(self.per_def.ident_span[def_id] <- ident.span);\n+    }\n+\n     /// In some cases, along with the item itself, we also\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter"}, {"sha": "3a4214e916acb2c0156997afb777382848bd6680", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -256,6 +256,7 @@ define_per_def_tables! {\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     span: Table<DefIndex, Lazy<Span>>,\n+    ident_span: Table<DefIndex, Lazy<Span>>,\n     attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n     children: Table<DefIndex, Lazy<[DefIndex]>>,\n     stability: Table<DefIndex, Lazy<attr::Stability>>,"}, {"sha": "5408c85a4d00677592405ac470641078f131e034", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -904,7 +904,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::AssocFn, def_id) => {\n-                if cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                if cstore\n+                    .associated_item_cloned_untracked(def_id, self.r.session)\n+                    .method_has_self_argument\n+                {\n                     self.r.has_self.insert(def_id);\n                 }\n             }"}, {"sha": "1a647692018e58c78c6caf046c96d68f73e31227", "filename": "src/test/ui/copy-a-resource.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #[derive(Debug)]\n struct Foo {\n   i: isize,"}, {"sha": "71d2eead3554cd9fee40761adf0b716abb7a04b3", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,11 +1,19 @@\n error[E0599]: no method named `clone` found for struct `Foo` in the current scope\n-  --> $DIR/copy-a-resource.rs:18:16\n+  --> $DIR/copy-a-resource.rs:23:16\n    |\n LL | struct Foo {\n    | ---------- method `clone` not found for this\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Foo>` here\n+   |        the method is available for `std::rc::Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "fa5afd24192611d8f552195f0773b801c1265c39", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n trait Foo {\n     type X;\n     fn method(&self) {}"}, {"sha": "f15aba97ded8110c7f5380a7d352edcd62814885", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: no method named `clone` found for struct `Bar<NotClone>` in the current scope\n-  --> $DIR/derive-assoc-type-not-impl.rs:18:30\n+  --> $DIR/derive-assoc-type-not-impl.rs:23:30\n    |\n LL | struct Bar<T: Foo> {\n    | ------------------\n@@ -12,6 +12,14 @@ LL | struct NotClone;\n ...\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method not found in `Bar<NotClone>`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Bar<NotClone>>` here\n+   |        the method is available for `std::rc::Rc<Bar<NotClone>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `NotClone: std::clone::Clone`"}, {"sha": "7f1d064cf3f5037e54189471f8997f26a2f4af3d", "filename": "src/test/ui/error-codes/E0004-2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let x = Some(1);\n "}, {"sha": "e47a4fa755cacd235cb15372ce977b671359a37b", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,8 +1,16 @@\n error[E0004]: non-exhaustive patterns: `None` and `Some(_)` not covered\n-  --> $DIR/E0004-2.rs:4:11\n+  --> $DIR/E0004-2.rs:9:11\n    |\n LL |     match x { }\n    |           ^ patterns `None` and `Some(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n+...\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "75faad80579c67b05e71156b1eff27a55608cb84", "filename": "src/test/ui/error-codes/E0005.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0005.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0005.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let x = Some(1);\n     let Some(y) = x; //~ ERROR E0005"}, {"sha": "192b99440319117ad4afc4adae190144a2fc7bfb", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in local binding: `None` not covered\n-  --> $DIR/E0005.rs:3:9\n+  --> $DIR/E0005.rs:8:9\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "b26ede9c8e2190451f0aa9bad784951295d2c675", "filename": "src/test/ui/error-codes/E0297.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0297.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0297.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n fn main() {\n     let xs : Vec<Option<i32>> = vec![Some(1), None];\n "}, {"sha": "4a75e9d1771f3b6ec8ec1e92f10849160580f120", "filename": "src/test/ui/error-codes/E0297.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n-  --> $DIR/E0297.rs:4:9\n+  --> $DIR/E0297.rs:9:9\n    |\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n \n error: aborting due to previous error\n "}, {"sha": "d2e52299c0d869981f19104c65ee357d2e0d389d", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![feature(never_type)]\n \n fn foo() -> Result<u32, !> {"}, {"sha": "c2dd90b91e700eff7ed17aa112da6ed630dda824", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/feature-gate-exhaustive-patterns.rs:8:9\n+  --> $DIR/feature-gate-exhaustive-patterns.rs:13:9\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "616421112db672a99459f4f3d15be47b3107ccf9", "filename": "src/test/ui/generic-associated-types/iterable.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![allow(incomplete_features)]\n #![feature(generic_associated_types)]\n "}, {"sha": "e18c6cec64e71d4ac6d647efe46e0f4990a13e63", "filename": "src/test/ui/generic-associated-types/iterable.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,31 +1,41 @@\n error[E0271]: type mismatch resolving `for<'a> <<std::vec::Vec<T> as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <std::vec::Vec<T> as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:15:5\n+  --> $DIR/iterable.rs:20:5\n    |\n LL | impl<T> Iterable for Vec<T> {\n    | --------------------------- in this `impl` item\n LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n+   | \n+  ::: $SRC_DIR/libcore/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     type Item;\n+   |          ---- associated type defined here\n    |\n    = note:    expected reference `&T`\n            found associated type `<std::vec::Vec<T> as Iterable>::Item<'_>`\n    = note: consider constraining the associated type `<std::vec::Vec<T> as Iterable>::Item<'_>` to `&_`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error[E0271]: type mismatch resolving `for<'a> <<[T] as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <[T] as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:27:5\n+  --> $DIR/iterable.rs:32:5\n    |\n LL | impl<T> Iterable for [T] {\n    | ------------------------ in this `impl` item\n LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n+   | \n+  ::: $SRC_DIR/libcore/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     type Item;\n+   |          ---- associated type defined here\n    |\n    = note:    expected reference `&T`\n            found associated type `<[T] as Iterable>::Item<'_>`\n    = note: consider constraining the associated type `<[T] as Iterable>::Item<'_>` to `&_`\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error[E0271]: type mismatch resolving `for<'a> <<std::vec::Vec<T> as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <std::vec::Vec<T> as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:19:30\n+  --> $DIR/iterable.rs:24:30\n    |\n LL | trait Iterable {\n    | -------------- required by `Iterable`\n@@ -39,7 +49,7 @@ LL |     fn iter<'a>(&'a self) -> Self::Iter<'a> {\n    = note: for more information, visit https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\n \n error[E0271]: type mismatch resolving `for<'a> <<[T] as Iterable>::Iter<'a> as std::iter::Iterator>::Item == <[T] as Iterable>::Item<'a>`\n-  --> $DIR/iterable.rs:31:30\n+  --> $DIR/iterable.rs:36:30\n    |\n LL | trait Iterable {\n    | -------------- required by `Iterable`"}, {"sha": "b5135b53e18905852274a53c42caccbab77c6173", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -83,6 +83,16 @@ error[E0599]: no method named `method` found for struct `std::rc::Rc<&mut std::b\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n    |                                            ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&i32>>`\n+   | \n+  ::: $DIR/auxiliary/no_method_suggested_traits.rs:8:12\n+   |\n+LL |         fn method(&self) {}\n+   |            ------\n+   |            |\n+   |            the method is available for `std::boxed::Box<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::pin::Pin<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::sync::Arc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::rc::Rc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\n help: the following trait is implemented but not in scope; perhaps add a `use` for it:"}, {"sha": "f00c2304733cafeeb4b61c444fe90cfff0a92ed6", "filename": "src/test/ui/issues/issue-2823.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n struct C {\n     x: isize,\n }"}, {"sha": "6e11dd4028836b4b6df202304f78e70aadb29353", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,11 +1,19 @@\n error[E0599]: no method named `clone` found for struct `C` in the current scope\n-  --> $DIR/issue-2823.rs:13:16\n+  --> $DIR/issue-2823.rs:18:16\n    |\n LL | struct C {\n    | -------- method `clone` not found for this\n ...\n LL |     let _d = c.clone();\n    |                ^^^^^ method not found in `C`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<C>` here\n+   |        the method is available for `std::rc::Rc<C>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "a8e72e9459e339084e07513b755bc3782959b8e7", "filename": "src/test/ui/issues/issue-69725.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // aux-build:issue-69725.rs\n \n extern crate issue_69725;"}, {"sha": "439fae9511167d08806b66d620e3cbd486697069", "filename": "src/test/ui/issues/issue-69725.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: no method named `clone` found for struct `issue_69725::Struct<A>` in the current scope\n-  --> $DIR/issue-69725.rs:7:32\n+  --> $DIR/issue-69725.rs:12:32\n    |\n LL |     let _ = Struct::<A>::new().clone();\n    |                                ^^^^^ method not found in `issue_69725::Struct<A>`\n@@ -8,6 +8,14 @@ LL |     let _ = Struct::<A>::new().clone();\n    |\n LL | pub struct Struct<A>(A);\n    | ------------------------ doesn't satisfy `issue_69725::Struct<A>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<issue_69725::Struct<A>>` here\n+   |        the method is available for `std::rc::Rc<issue_69725::Struct<A>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `A: std::clone::Clone`"}, {"sha": "186731f2e7233ef010157be1ca968ebae35bb78d", "filename": "src/test/ui/non-copyable-void.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-copyable-void.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // ignore-wasm32-bare no libc to test ffi with\n \n #![feature(rustc_private)]"}, {"sha": "dd67a110d2218c11d79c5ebaddd3203dbc5af32e", "filename": "src/test/ui/non-copyable-void.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-copyable-void.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,8 +1,16 @@\n error[E0599]: no method named `clone` found for enum `libc::c_void` in the current scope\n-  --> $DIR/non-copyable-void.rs:11:23\n+  --> $DIR/non-copyable-void.rs:16:23\n    |\n LL |         let _z = (*y).clone();\n    |                       ^^^^^ method not found in `libc::c_void`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<libc::c_void>` here\n+   |        the method is available for `std::rc::Rc<libc::c_void>` here\n \n error: aborting due to previous error\n "}, {"sha": "731f4ab9c784a59c6881578c10fc0c47e63018c8", "filename": "src/test/ui/noncopyable-class.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n // Test that a class with a non-copyable field can't be\n // copied\n "}, {"sha": "472ce34870a0a71e710fd23802e6416732acd74e", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,11 +1,19 @@\n error[E0599]: no method named `clone` found for struct `Foo` in the current scope\n-  --> $DIR/noncopyable-class.rs:34:16\n+  --> $DIR/noncopyable-class.rs:39:16\n    |\n LL | struct Foo {\n    | ---------- method `clone` not found for this\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Foo>` here\n+   |        the method is available for `std::rc::Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "728d4a64495b162ebe7f723063baa368434f6b52", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n use self::Direction::{North, East, South, West};\n \n #[derive(PartialEq, Eq)]"}, {"sha": "7bb6a700a3717d98b56d7575f7e48179094852bf", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,21 +1,29 @@\n error[E0004]: non-exhaustive patterns: `(true, false)` not covered\n-  --> $DIR/match-arm-statics-2.rs:17:11\n+  --> $DIR/match-arm-statics-2.rs:22:11\n    |\n LL |     match (true, false) {\n    |           ^^^^^^^^^^^^^ pattern `(true, false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Some(Some(West))` not covered\n-  --> $DIR/match-arm-statics-2.rs:29:11\n+  --> $DIR/match-arm-statics-2.rs:34:11\n    |\n LL |     match Some(Some(North)) {\n    |           ^^^^^^^^^^^^^^^^^ pattern `Some(Some(West))` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ----\n+   |     |\n+   |     not covered\n+   |     not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Foo { bar: Some(North), baz: NewBool(true) }` not covered\n-  --> $DIR/match-arm-statics-2.rs:48:11\n+  --> $DIR/match-arm-statics-2.rs:53:11\n    |\n LL | / struct Foo {\n LL | |     bar: Option<Direction>,"}, {"sha": "c7cde468bb9bfc5c8edc95e4b383450de194ecf8", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n "}, {"sha": "4dcbf05ecce2ba675f6f42c122a48b70e1140508", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,8 +1,13 @@\n error[E0004]: non-exhaustive patterns: `Some(Private { misc: true, .. })` not covered\n-  --> $DIR/match-privately-empty.rs:13:11\n+  --> $DIR/match-privately-empty.rs:18:11\n    |\n LL |     match private::DATA {\n    |           ^^^^^^^^^^^^^ pattern `Some(Private { misc: true, .. })` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "59f7bb892c68c03f0946e2b53e1cfc311a965373", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![allow(illegal_floating_point_literal_pattern)]\n \n enum T { A, B }"}, {"sha": "dff2c8d9424c365746f068de3b153e81b3f1cf1f", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,5 +1,5 @@\n error[E0004]: non-exhaustive patterns: `A` not covered\n-  --> $DIR/non-exhaustive-match.rs:7:11\n+  --> $DIR/non-exhaustive-match.rs:12:11\n    |\n LL | enum T { A, B }\n    | ---------------\n@@ -13,39 +13,44 @@ LL |     match x { T::B => { } }\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `false` not covered\n-  --> $DIR/non-exhaustive-match.rs:8:11\n+  --> $DIR/non-exhaustive-match.rs:13:11\n    |\n LL |     match true {\n    |           ^^^^ pattern `false` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Some(_)` not covered\n-  --> $DIR/non-exhaustive-match.rs:11:11\n+  --> $DIR/non-exhaustive-match.rs:16:11\n    |\n LL |     match Some(10) {\n    |           ^^^^^^^^ pattern `Some(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n-  --> $DIR/non-exhaustive-match.rs:14:11\n+  --> $DIR/non-exhaustive-match.rs:19:11\n    |\n LL |     match (2, 3, 4) {\n    |           ^^^^^^^^^ patterns `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(A, A)` not covered\n-  --> $DIR/non-exhaustive-match.rs:18:11\n+  --> $DIR/non-exhaustive-match.rs:23:11\n    |\n LL |     match (T::A, T::A) {\n    |           ^^^^^^^^^^^^ pattern `(A, A)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `B` not covered\n-  --> $DIR/non-exhaustive-match.rs:22:11\n+  --> $DIR/non-exhaustive-match.rs:27:11\n    |\n LL | enum T { A, B }\n    | ---------------\n@@ -59,15 +64,15 @@ LL |     match T::A {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `[]` not covered\n-  --> $DIR/non-exhaustive-match.rs:33:11\n+  --> $DIR/non-exhaustive-match.rs:38:11\n    |\n LL |     match *vec {\n    |           ^^^^ pattern `[]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `[_, _, _, _, ..]` not covered\n-  --> $DIR/non-exhaustive-match.rs:46:11\n+  --> $DIR/non-exhaustive-match.rs:51:11\n    |\n LL |     match *vec {\n    |           ^^^^ pattern `[_, _, _, _, ..]` not covered"}, {"sha": "5be426eb38278be39a7d32b42efd6a83a02cd975", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n struct R<'a> {\n     r: &'a R<'a>,\n }"}, {"sha": "f371d460cf733ceaa8031ce0b77c7e0a929660cc", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,8 +1,13 @@\n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/recursive-types-are-not-uninhabited.rs:6:9\n+  --> $DIR/recursive-types-are-not-uninhabited.rs:11:9\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "bd6e9d5950272dfe941c34b11ca83d5351101062", "filename": "src/test/ui/resolve/issue-3907-2.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -3,8 +3,11 @@ error[E0038]: the trait `issue_3907::Foo` cannot be made into an object\n    |\n LL | fn bar(_x: Foo) {}\n    |            ^^^ the trait `issue_3907::Foo` cannot be made into an object\n+   | \n+  ::: $DIR/auxiliary/issue-3907.rs:2:8\n    |\n-   = note: the trait cannot be made into an object because associated function `bar` has no `self` parameter\n+LL |     fn bar();\n+   |        --- the trait cannot be made into an object because associated function `bar` has no `self` parameter\n \n error: aborting due to previous error\n "}, {"sha": "a214a652a387fcb4348daff59dbbeb9071499167", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -27,6 +27,13 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   | \n+  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+   |\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ----- not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "63564e9c3cc8c097b82f9532f14952829bd7c570", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -27,6 +27,13 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   | \n+  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+   |\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ----- not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "a959aaae05568916576c4b88c3c0624c9763e0d6", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n use std::mem::zeroed;\n enum Void {}\n "}, {"sha": "9245e293caa853074c9bc657eae71483e166b37b", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,13 +1,18 @@\n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:6:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:11:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `&Void` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:15:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:20:19\n    |\n LL | enum Void {}\n    | ------------ `Void` defined here\n@@ -18,42 +23,52 @@ LL |     let _ = match x {};\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `(Void,)` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:18:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:23:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: type `[Void; 1]` is non-empty\n-  --> $DIR/uninhabited-matches-feature-gated.rs:21:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:26:19\n    |\n LL |     let _ = match x {};\n    |                   ^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:24:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:29:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `&[_, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:32:19\n+  --> $DIR/uninhabited-matches-feature-gated.rs:37:19\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n-  --> $DIR/uninhabited-matches-feature-gated.rs:37:9\n+  --> $DIR/uninhabited-matches-feature-gated.rs:42:9\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "4b92475f1e4cd07f388ee089b2bfe74c8a075019", "filename": "src/test/ui/union/union-derive-clone.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,3 +1,8 @@\n+// FIXME: missing sysroot spans (#53081)\n+// ignore-i586-unknown-linux-gnu\n+// ignore-i586-unknown-linux-musl\n+// ignore-i686-unknown-linux-musl\n+\n #![feature(untagged_unions)]\n \n use std::mem::ManuallyDrop;"}, {"sha": "d0a82a96c165c88b28dbe4ca8650238e0ea409c8", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `U1: std::marker::Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:5:10\n+  --> $DIR/union-derive-clone.rs:10:10\n    |\n LL | #[derive(Clone)]\n    |          ^^^^^ the trait `std::marker::Copy` is not implemented for `U1`\n@@ -8,7 +8,7 @@ LL | #[derive(Clone)]\n    = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0599]: no method named `clone` found for union `U5<CloneNoCopy>` in the current scope\n-  --> $DIR/union-derive-clone.rs:37:15\n+  --> $DIR/union-derive-clone.rs:42:15\n    |\n LL | union U5<T> {\n    | -----------\n@@ -21,6 +21,14 @@ LL | struct CloneNoCopy;\n ...\n LL |     let w = u.clone();\n    |               ^^^^^ method not found in `U5<CloneNoCopy>`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<U5<CloneNoCopy>>` here\n+   |        the method is available for `std::rc::Rc<U5<CloneNoCopy>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `CloneNoCopy: std::marker::Copy`"}, {"sha": "2e81e7cf8320011e744bce625109f99450f4642b", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -14,6 +14,14 @@ LL |     let _z = y.clone();\n    |\n LL | pub struct Box<T: ?Sized>(Unique<T>);\n    | ------------------------------------- doesn't satisfy `std::boxed::Box<dyn Foo>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<std::boxed::Box<dyn Foo>>` here\n+   |        the method is available for `std::rc::Rc<std::boxed::Box<dyn Foo>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `dyn Foo: std::marker::Sized`"}, {"sha": "06c4b95baef565c73632127734f4a80d38482f38", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d626f5bc6631b1f694ab972c53316aebdae22842/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=d626f5bc6631b1f694ab972c53316aebdae22842", "patch": "@@ -11,6 +11,14 @@ LL |     let _j = i.clone();\n    |\n LL | pub struct Box<T: ?Sized>(Unique<T>);\n    | ------------------------------------- doesn't satisfy `std::boxed::Box<R>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<std::boxed::Box<R>>` here\n+   |        the method is available for `std::rc::Rc<std::boxed::Box<R>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `R: std::clone::Clone`"}]}