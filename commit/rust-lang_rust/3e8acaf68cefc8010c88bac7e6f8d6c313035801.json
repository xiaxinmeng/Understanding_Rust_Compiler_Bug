{"sha": "3e8acaf68cefc8010c88bac7e6f8d6c313035801", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOGFjYWY2OGNlZmM4MDEwYzg4YmFjN2U2ZjhkNmMzMTMwMzU4MDE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-10-20T18:10:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-20T18:10:57Z"}, "message": "Rollup merge of #65579 - skinny121:resolve_const_vars, r=varkor\n\nChanged `resolve_type_vars_with_obligations` to also resolve const inference variables\n\nFixes #65380\nr? @varkor", "tree": {"sha": "07af3e566442ce448a6f0c706f05a370d80dc58c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07af3e566442ce448a6f0c706f05a370d80dc58c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e8acaf68cefc8010c88bac7e6f8d6c313035801", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdrKMxCRBK7hj4Ov3rIwAAdHIIAHQ4rZbHbVsRRvJ1aBSG+5o7\n4Z8jTfQDbQB7EahqG5bDLOVcmFQoJ/3ZpaLVV38vRecujlCJMo8YyCr0QoQuHxhO\nUYpdYnoVcOaChMqUL5XKrL89w9mP01AYPwMv10FwluPtz2orV5/FWnXE2YlDksGH\nbH5B03uppuz4trnrArH5HVRHxyP11yDP/k8Mhu1p9jovz6W/Wdawzg38cHQdZ0UW\nx2iFpknrXwpvHHQbOfv0xXNZs3rePOa/xN6dIso1nHJzN9YRevD+QJjjoiwzgXk0\njKOusH7tKJyvW0yutqBLEmogHBgdrDcRkqnaKrGWYAdPIv1xEdyCU1hnwCoHm8k=\n=6prf\n-----END PGP SIGNATURE-----\n", "payload": "tree 07af3e566442ce448a6f0c706f05a370d80dc58c\nparent cc42adf3a21a4b1a359dfd8281693f3e892669d3\nparent 9cefcd3051ac7f4ea3c924bd7542c70c59ac5dfd\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1571595057 +0900\ncommitter GitHub <noreply@github.com> 1571595057 +0900\n\nRollup merge of #65579 - skinny121:resolve_const_vars, r=varkor\n\nChanged `resolve_type_vars_with_obligations` to also resolve const inference variables\n\nFixes #65380\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e8acaf68cefc8010c88bac7e6f8d6c313035801", "html_url": "https://github.com/rust-lang/rust/commit/3e8acaf68cefc8010c88bac7e6f8d6c313035801", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e8acaf68cefc8010c88bac7e6f8d6c313035801/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc42adf3a21a4b1a359dfd8281693f3e892669d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc42adf3a21a4b1a359dfd8281693f3e892669d3", "html_url": "https://github.com/rust-lang/rust/commit/cc42adf3a21a4b1a359dfd8281693f3e892669d3"}, {"sha": "9cefcd3051ac7f4ea3c924bd7542c70c59ac5dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cefcd3051ac7f4ea3c924bd7542c70c59ac5dfd", "html_url": "https://github.com/rust-lang/rust/commit/9cefcd3051ac7f4ea3c924bd7542c70c59ac5dfd"}], "stats": {"total": 71, "additions": 37, "deletions": 34}, "files": [{"sha": "7c3a338366c9af3f3edf3ab291006e33411875b3", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -1,7 +1,7 @@\n use super::{InferCtxt, FixupError, FixupResult, Span};\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst, TypeFlags};\n+use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -29,7 +29,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_infer_types() {\n+        if !t.has_infer_types() && !t.has_infer_consts() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n@@ -38,7 +38,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticVarResolver<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n-        if !ct.has_type_flags(TypeFlags::HAS_CT_INFER) {\n+        if !ct.has_infer_consts() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n             let ct = self.infcx.shallow_resolve(ct);"}, {"sha": "a95ed589c3e2a8950442fb0aabebd81105723f01", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -88,6 +88,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_infer_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_INFER)\n     }\n+    fn has_infer_consts(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_CT_INFER)\n+    }\n     fn has_local_value(&self) -> bool {\n         self.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n     }"}, {"sha": "bfccb032458f5288bef592a4cb1fc2fc02f06ef9", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -811,7 +811,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         target: Ty<'tcx>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let source = self.resolve_type_vars_with_obligations(expr_ty);\n+        let source = self.resolve_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n@@ -829,7 +829,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Same as `try_coerce()`, but without side-effects.\n     pub fn can_coerce(&self, expr_ty: Ty<'tcx>, target: Ty<'tcx>) -> bool {\n-        let source = self.resolve_type_vars_with_obligations(expr_ty);\n+        let source = self.resolve_vars_with_obligations(expr_ty);\n         debug!(\"coercion::can({:?} -> {:?})\", source, target);\n \n         let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n@@ -853,8 +853,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n         where E: AsCoercionSite\n     {\n-        let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n-        let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n+        let prev_ty = self.resolve_vars_with_obligations(prev_ty);\n+        let new_ty = self.resolve_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         // Special-case that coercion alone cannot handle:\n@@ -1333,7 +1333,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             err.span_label(return_sp, \"expected because this return type...\");\n             err.span_label( *sp, format!(\n                 \"...is found to be `{}` here\",\n-                fcx.resolve_type_vars_with_obligations(expected),\n+                fcx.resolve_vars_with_obligations(expected),\n             ));\n         }\n         err"}, {"sha": "3509d6566ec93860315bea31234230f9a6df90f3", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               expected: Ty<'tcx>,\n                               allow_two_phase: AllowTwoPhase)\n                               -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n-        let expected = self.resolve_type_vars_with_obligations(expected);\n+        let expected = self.resolve_vars_with_obligations(expected);\n \n         let e = match self.try_coerce(expr, checked_ty, expected, allow_two_phase) {\n             Ok(ty) => return (ty, None),\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expr = expr.peel_drop_temps();\n         let cause = self.misc(expr.span);\n-        let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n+        let expr_ty = self.resolve_vars_with_obligations(checked_ty);\n         let mut err = self.report_mismatched_types(&cause, expected, expr_ty, e);\n \n         if self.is_assign_to_bool(expr, expected) {"}, {"sha": "f5f85bbcb100c4bb7028de09dfc20380326dbc4b", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -1010,7 +1010,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr,\n     ) -> Ty<'tcx> {\n         let flds = expected.only_has_type(self).and_then(|ty| {\n-            let ty = self.resolve_type_vars_with_obligations(ty);\n+            let ty = self.resolve_vars_with_obligations(ty);\n             match ty.kind {\n                 ty::Tuple(ref flds) => Some(&flds[..]),\n                 _ => None"}, {"sha": "d90ed2a790bb642fdecbcaaf1ac97e149e3bdfbb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -919,7 +919,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // This occurs for UFCS desugaring of `T::method`, where there is no\n         // receiver expression for the method call, and thus no autoderef.\n         if let SelfSource::QPath(_) = source {\n-            return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n+            return is_local(self.resolve_vars_with_obligations(rcvr_ty));\n         }\n \n         self.autoderef(span, rcvr_ty).any(|(ty, _)| is_local(ty))"}, {"sha": "73f35dde4f6ebc0d46718300a633553c71c2e774", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -2440,23 +2440,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.cause(span, ObligationCauseCode::MiscObligation)\n     }\n \n-    /// Resolves type variables in `ty` if possible. Unlike the infcx\n+    /// Resolves type and const variables in `ty` if possible. Unlike the infcx\n     /// version (resolve_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n     /// to get more type information.\n-    fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type_vars_with_obligations(ty={:?})\", ty);\n+    fn resolve_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        debug!(\"resolve_vars_with_obligations(ty={:?})\", ty);\n \n         // No Infer()? Nothing needs doing.\n-        if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n+        if !ty.has_infer_types() && !ty.has_infer_consts() {\n+            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n         ty = self.resolve_vars_if_possible(&ty);\n-        if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n+        if !ty.has_infer_types() && !ty.has_infer_consts()  {\n+            debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }\n \n@@ -2467,7 +2467,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.select_obligations_where_possible(false, |_| {});\n         ty = self.resolve_vars_if_possible(&ty);\n \n-        debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n+        debug!(\"resolve_vars_with_obligations: ty={:?}\", ty);\n         ty\n     }\n \n@@ -3668,7 +3668,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                            formal_ret: Ty<'tcx>,\n                                            formal_args: &[Ty<'tcx>])\n                                            -> Vec<Ty<'tcx>> {\n-        let formal_ret = self.resolve_type_vars_with_obligations(formal_ret);\n+        let formal_ret = self.resolve_vars_with_obligations(formal_ret);\n         let ret_ty = match expected_ret.only_has_type(self) {\n             Some(ret) => ret,\n             None => return Vec::new()\n@@ -4517,7 +4517,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.span_suggestion(\n                     span,\n                     \"try adding a return type\",\n-                    format!(\"-> {} \", self.resolve_type_vars_with_obligations(found)),\n+                    format!(\"-> {} \", self.resolve_vars_with_obligations(found)),\n                     Applicability::MachineApplicable);\n                 true\n             }\n@@ -4993,7 +4993,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // If no resolution is possible, then an error is reported.\n     // Numeric inference variables may be left unresolved.\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.resolve_type_vars_with_obligations(ty);\n+        let ty = self.resolve_vars_with_obligations(ty);\n         if !ty.is_ty_var() {\n             ty\n         } else {"}, {"sha": "819c347d3ae95988008297ca12de1f10cd5e694e", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_with_needs(lhs_expr, Needs::MutPlace)\n             }\n         };\n-        let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n+        let lhs_ty = self.resolve_vars_with_obligations(lhs_ty);\n \n         // N.B., as we have not yet type-checked the RHS, we don't have the\n         // type at hand. Make a variable to represent it. The whole reason\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // see `NB` above\n         let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n-        let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n+        let rhs_ty = self.resolve_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {\n             Ok(method) => {"}, {"sha": "97c30f208f5ecb8fa8f2d40cdee2b977590563de", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -251,7 +251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         mut def_bm: BindingMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n-        let mut expected = self.resolve_type_vars_with_obligations(&expected);\n+        let mut expected = self.resolve_vars_with_obligations(&expected);\n \n         // Peel off as many `&` or `&mut` from the scrutinee type as possible. For example,\n         // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches"}, {"sha": "7090cb880fd497b3c587a5d2519466bbd061426b", "filename": "src/test/ui/const-generics/const-argument-cross-crate-mismatch.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e8acaf68cefc8010c88bac7e6f8d6c313035801/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-cross-crate-mismatch.stderr?ref=3e8acaf68cefc8010c88bac7e6f8d6c313035801", "patch": "@@ -1,20 +1,20 @@\n error[E0308]: mismatched types\n-  --> $DIR/const-argument-cross-crate-mismatch.rs:6:41\n+  --> $DIR/const-argument-cross-crate-mismatch.rs:6:67\n    |\n LL |     let _ = const_generic_lib::function(const_generic_lib::Struct([0u8, 1u8]));\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `3usize`, found `2usize`\n+   |                                                                   ^^^^^^^^^^ expected an array with a fixed size of 3 elements, found one with 2 elements\n    |\n-   = note: expected type `const_generic_lib::Struct<3usize>`\n-              found type `const_generic_lib::Struct<_: usize>`\n+   = note: expected type `[u8; 3]`\n+              found type `[u8; 2]`\n \n error[E0308]: mismatched types\n-  --> $DIR/const-argument-cross-crate-mismatch.rs:8:39\n+  --> $DIR/const-argument-cross-crate-mismatch.rs:8:65\n    |\n LL |     let _: const_generic_lib::Alias = const_generic_lib::Struct([0u8, 1u8, 2u8]);\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2usize`, found `3usize`\n+   |                                                                 ^^^^^^^^^^^^^^^ expected an array with a fixed size of 2 elements, found one with 3 elements\n    |\n-   = note: expected type `const_generic_lib::Struct<2usize>`\n-              found type `const_generic_lib::Struct<_: usize>`\n+   = note: expected type `[u8; 2]`\n+              found type `[u8; 3]`\n \n error: aborting due to 2 previous errors\n "}]}