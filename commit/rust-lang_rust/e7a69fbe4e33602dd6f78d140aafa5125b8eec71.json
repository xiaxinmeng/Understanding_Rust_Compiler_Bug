{"sha": "e7a69fbe4e33602dd6f78d140aafa5125b8eec71", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTY5ZmJlNGUzMzYwMmRkNmY3OGQxNDBhYWZhNTEyNWI4ZWVjNzE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-01T18:56:46Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-01T19:30:07Z"}, "message": "Working on documentation of pipes.", "tree": {"sha": "efeae6782ee2a24f579f17c7156300dc15e79178", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efeae6782ee2a24f579f17c7156300dc15e79178"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a69fbe4e33602dd6f78d140aafa5125b8eec71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a69fbe4e33602dd6f78d140aafa5125b8eec71", "html_url": "https://github.com/rust-lang/rust/commit/e7a69fbe4e33602dd6f78d140aafa5125b8eec71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a69fbe4e33602dd6f78d140aafa5125b8eec71/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "899400cd1a7465ffcc80d848d6cb2b6fb2436e02", "url": "https://api.github.com/repos/rust-lang/rust/commits/899400cd1a7465ffcc80d848d6cb2b6fb2436e02", "html_url": "https://github.com/rust-lang/rust/commit/899400cd1a7465ffcc80d848d6cb2b6fb2436e02"}], "stats": {"total": 178, "additions": 162, "deletions": 16}, "files": [{"sha": "429651616a76eaa416ded683dc2f26da9ddc8b29", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 128, "deletions": 16, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e7a69fbe4e33602dd6f78d140aafa5125b8eec71/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a69fbe4e33602dd6f78d140aafa5125b8eec71/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=e7a69fbe4e33602dd6f78d140aafa5125b8eec71", "patch": "@@ -1,4 +1,47 @@\n-// Runtime support for pipes.\n+/*! Runtime support for message passing with protocol enforcement.\n+\n+\n+Pipes consist of two endpoints. One endpoint can send messages and\n+the other can receive messages. The set of legal messages and which\n+directions they can flow at any given point are determined by a\n+protocol. Below is an example protocol.\n+\n+~~~\n+proto! pingpong {\n+    ping: send {\n+        ping -> pong\n+    }\n+    pong: recv {\n+        pong -> ping\n+    }\n+}\n+~~~\n+\n+The `proto!` syntax extension will convert this into a module called\n+`pingpong`, which includes a set of types and functions that can be\n+used to write programs that follow the pingpong protocol.\n+\n+*/\n+\n+/* IMPLEMENTATION NOTES\n+\n+The initial design for this feature is available at:\n+\n+https://github.com/eholk/rust/wiki/Proposal-for-channel-contracts\n+\n+Much of the design in that document is still accurate. There are\n+several components for the pipe implementation. First of all is the\n+syntax extension. To see how that works, it is best see comments in\n+libsyntax/ext/pipes.rs.\n+\n+This module includes two related pieces of the runtime\n+implementation. There is support for unbounded and bounded\n+protocols. The main difference between the two is the type of the\n+buffer that is carried along in the endpoint data structures.\n+\n+FIXME (#3072) - This is still incomplete\n+\n+*/\n \n import unsafe::{forget, reinterpret_cast, transmute};\n import either::{either, left, right};\n@@ -11,7 +54,7 @@ export send_packet_buffered, recv_packet_buffered;\n export packet, mk_packet, entangle_buffer, has_buffer, buffer_header;\n \n // export these so we can find them in the buffer_resource\n-// destructor. This is probably another metadata bug.\n+// destructor. This is probably a symptom of #3005.\n export atomic_add_acq, atomic_sub_rel;\n \n // User-level things\n@@ -20,24 +63,22 @@ export select, select2, selecti, select2i, selectable;\n export spawn_service, spawn_service_recv;\n export stream, port, chan, shared_chan, port_set, channel;\n \n+#[doc(hidden)]\n const SPIN_COUNT: uint = 0;\n \n macro_rules! move_it {\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n }\n \n-// This is to help make sure we only move out of enums in safe\n-// places. Once there is unary move, it can be removed.\n-fn move_it<T>(-x: T) -> T { x }\n-\n+#[doc(hidden)]\n enum state {\n     empty,\n     full,\n     blocked,\n     terminated\n }\n \n-class buffer_header {\n+struct buffer_header {\n     // Tracks whether this buffer needs to be freed. We can probably\n     // get away with restricting it to 0 or 1, if we're careful.\n     let mut ref_count: int;\n@@ -49,12 +90,13 @@ class buffer_header {\n }\n \n // This is for protocols to associate extra data to thread around.\n+#[doc(hidden)]\n type buffer<T: send> = {\n     header: buffer_header,\n     data: T,\n };\n \n-class packet_header {\n+struct packet_header {\n     let mut state: state;\n     let mut blocked_task: option<*rust_task>;\n \n@@ -95,6 +137,7 @@ class packet_header {\n     }\n }\n \n+#[doc(hidden)]\n type packet<T: send> = {\n     header: packet_header,\n     mut payload: option<T>,\n@@ -133,6 +176,7 @@ fn unibuffer<T: send>() -> ~buffer<packet<T>> {\n     b\n }\n \n+#[doc(hidden)]\n fn packet<T: send>() -> *packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(b.data);\n@@ -141,6 +185,7 @@ fn packet<T: send>() -> *packet<T> {\n     p\n }\n \n+#[doc(hidden)]\n fn entangle_buffer<T: send, Tstart: send>(\n     -buffer: ~buffer<T>,\n     init: fn(*libc::c_void, x: &T) -> *packet<Tstart>)\n@@ -163,18 +208,22 @@ extern mod rusti {\n \n // If I call the rusti versions directly from a polymorphic function,\n // I get link errors. This is a bug that needs investigated more.\n+#[doc(hidden)]\n fn atomic_xchng_rel(&dst: int, src: int) -> int {\n     rusti::atomic_xchng_rel(dst, src)\n }\n \n+#[doc(hidden)]\n fn atomic_add_acq(&dst: int, src: int) -> int {\n     rusti::atomic_add_acq(dst, src)\n }\n \n+#[doc(hidden)]\n fn atomic_sub_rel(&dst: int, src: int) -> int {\n     rusti::atomic_sub_rel(dst, src)\n }\n \n+#[doc(hidden)]\n type rust_task = libc::c_void;\n \n extern mod rustrt {\n@@ -188,6 +237,7 @@ extern mod rustrt {\n     pure fn task_signal_event(target: *rust_task, event: *libc::c_void);\n }\n \n+#[doc(hidden)]\n fn wait_event(this: *rust_task) -> *libc::c_void {\n     let mut event = ptr::null();\n \n@@ -198,6 +248,7 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n     event\n }\n \n+#[doc(hidden)]\n fn swap_state_acq(&dst: state, src: state) -> state {\n     unsafe {\n         reinterpret_cast(rusti::atomic_xchng_acq(\n@@ -206,6 +257,7 @@ fn swap_state_acq(&dst: state, src: state) -> state {\n     }\n }\n \n+#[doc(hidden)]\n fn swap_state_rel(&dst: state, src: state) -> state {\n     unsafe {\n         reinterpret_cast(rusti::atomic_xchng_rel(\n@@ -214,11 +266,12 @@ fn swap_state_rel(&dst: state, src: state) -> state {\n     }\n }\n \n+#[doc(hidden)]\n unsafe fn get_buffer<T: send>(p: *packet_header) -> ~buffer<T> {\n     transmute((*p).buf_header())\n }\n \n-class buffer_resource<T: send> {\n+struct buffer_resource<T: send> {\n     let buffer: ~buffer<T>;\n     new(+b: ~buffer<T>) {\n         //let p = ptr::addr_of(*b);\n@@ -244,6 +297,7 @@ class buffer_resource<T: send> {\n     }\n }\n \n+#[doc(hidden)]\n fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n                                 -payload: T) {\n     let header = p.header();\n@@ -281,10 +335,21 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n     }\n }\n \n+/** Receives a message from a pipe.\n+\n+Fails if the sender closes the connection.\n+\n+*/\n fn recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>) -> T {\n     option::unwrap(try_recv(p))\n }\n \n+/** Attempts to receive a message from a pipe.\n+\n+Returns `none` if the sender has closed the connection without sending\n+a message, or `some(T)` if a message was received.\n+\n+*/\n fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n     -> option<T>\n {\n@@ -351,6 +416,7 @@ impl peek<T: send, Tb: send> for recv_packet_buffered<T, Tb> {\n     }\n }\n \n+#[doc(hidden)]\n fn sender_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n     alt swap_state_rel(p.header.state, terminated) {\n@@ -377,6 +443,7 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n     }\n }\n \n+#[doc(hidden)]\n fn receiver_terminate<T: send>(p: *packet<T>) {\n     let p = unsafe { &*p };\n     alt swap_state_rel(p.header.state, terminated) {\n@@ -394,8 +461,16 @@ fn receiver_terminate<T: send>(p: *packet<T>) {\n     }\n }\n \n-#[doc = \"Returns when one of the packet headers reports data is\n-available.\"]\n+/** Returns when one of the packet headers reports data is available.\n+\n+This function is primarily intended for building higher level waiting\n+functions, such as `select`, `select2`, etc.\n+\n+It takes a vector slice of packet_headers and returns an index into\n+that vector. The index points to an endpoint that has either been\n+closed by the sender or has a message waiting to be received.\n+\n+*/\n fn wait_many(pkts: &[*packet_header]) -> uint {\n     let this = rustrt::rust_get_task();\n \n@@ -447,6 +522,34 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n     ready_packet\n }\n \n+/** Receives a message from one of two endpoints.\n+\n+The return value is `left` if the first endpoint received something,\n+or `right` if the second endpoint receives something. In each case,\n+the result includes the other endpoint as well so it can be used\n+again. Below is an example of using `select2`.\n+\n+~~~\n+match select2(a, b) {\n+  left((none, b)) {\n+    // endpoint a was closed.\n+  }\n+  right((a, none)) {\n+    // endpoint b was closed.\n+  }\n+  left((some(_), b)) {\n+    // endpoint a received a message\n+  }\n+  right(a, some(_)) {\n+    // endpoint b received a message.\n+  }\n+}\n+~~~\n+\n+Sometimes messages will be available on both endpoints at once. In\n+this case, `select2` may return either `left` or `right`.\n+\n+*/\n fn select2<A: send, Ab: send, B: send, Bb: send>(\n     +a: recv_packet_buffered<A, Ab>,\n     +b: recv_packet_buffered<B, Bb>)\n@@ -500,13 +603,16 @@ fn select<T: send, Tb: send>(+endpoints: ~[recv_packet_buffered<T, Tb>])\n     (ready, result, remaining)\n }\n \n+/// The sending end of a pipe. It can be used to send exactly one\n+/// message.\n type send_packet<T: send> = send_packet_buffered<T, packet<T>>;\n \n+#[doc(hidden)]\n fn send_packet<T: send>(p: *packet<T>) -> send_packet<T> {\n     send_packet_buffered(p)\n }\n \n-class send_packet_buffered<T: send, Tbuffer: send> {\n+struct send_packet_buffered<T: send, Tbuffer: send> {\n     let mut p: option<*packet<T>>;\n     let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n@@ -560,13 +666,16 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n     }\n }\n \n+/// Represents the receive end of a pipe. It can receive exactly one\n+/// message.\n type recv_packet<T: send> = recv_packet_buffered<T, packet<T>>;\n \n+#[doc(hidden)]\n fn recv_packet<T: send>(p: *packet<T>) -> recv_packet<T> {\n     recv_packet_buffered(p)\n }\n \n-class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n+struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     let mut p: option<*packet<T>>;\n     let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n@@ -620,6 +729,7 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     }\n }\n \n+#[doc(hidden)]\n fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n     let p = packet();\n     (send_packet(p), recv_packet(p))\n@@ -686,12 +796,14 @@ trait recv<T: send> {\n     pure fn peek() -> bool;\n }\n \n+#[doc(hidden)]\n type chan_<T:send> = { mut endp: option<streamp::client::open<T>> };\n \n enum chan<T:send> {\n     chan_(chan_<T>)\n }\n \n+#[doc(hidden)]\n type port_<T:send> = { mut endp: option<streamp::server::open<T>> };\n \n enum port<T:send> {\n@@ -725,7 +837,7 @@ impl port<T: send> of recv<T> for port<T> {\n     fn try_recv() -> option<T> {\n         let mut endp = none;\n         endp <-> self.endp;\n-        alt move_it(pipes::try_recv(unwrap(endp))) {\n+        alt move pipes::try_recv(unwrap(endp)) {\n           some(streamp::data(x, endp)) {\n             self.endp = some(move_it!{endp});\n             some(move_it!{x})\n@@ -749,7 +861,7 @@ impl port<T: send> of recv<T> for port<T> {\n }\n \n // Treat a whole bunch of ports as one.\n-class port_set<T: send> : recv<T> {\n+struct port_set<T: send> : recv<T> {\n     let mut ports: ~[pipes::port<T>];\n \n     new() { self.ports = ~[]; }\n@@ -770,7 +882,7 @@ class port_set<T: send> : recv<T> {\n             let i = wait_many(self.ports.map(|p| p.header()));\n             // dereferencing an unsafe pointer nonsense to appease the\n             // borrowchecker.\n-            alt move_it(unsafe {(*ptr::addr_of(self.ports[i])).try_recv()}) {\n+            alt move unsafe {(*ptr::addr_of(self.ports[i])).try_recv()} {\n               some(m) {\n                   result = some(move_it!{m});\n               }"}, {"sha": "08562c4490ffa71b4bf3e4d7fe4aa82b927b5bbe", "filename": "src/libsyntax/ext/pipes.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e7a69fbe4e33602dd6f78d140aafa5125b8eec71/src%2Flibsyntax%2Fext%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a69fbe4e33602dd6f78d140aafa5125b8eec71/src%2Flibsyntax%2Fext%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes.rs?ref=e7a69fbe4e33602dd6f78d140aafa5125b8eec71", "patch": "@@ -1,3 +1,37 @@\n+/*! Implementation of proto! extension.\n+\n+This is frequently called the pipe compiler. It handles code such as...\n+\n+~~~\n+proto! pingpong {\n+    ping: send {\n+        ping -> pong\n+    }\n+    pong: recv {\n+        pong -> ping\n+    }\n+}\n+~~~\n+\n+There are several components:\n+\n+ * The parser (libsyntax/ext/pipes/parse_proto.rs)\n+   * Responsible for building an AST from a protocol specification.\n+\n+ * The checker (libsyntax/ext/pipes/check.rs)\n+   * Basic correctness checking for protocols (i.e. no undefined states, etc.)\n+\n+ * The analyzer (libsyntax/ext/pipes/liveness.rs)\n+   * Determines whether the protocol is bounded or unbounded.\n+\n+ * The compiler (libsynatx/ext/pipes/pipec.rs)\n+   * Generates a Rust AST from the protocol AST and the results of analysis.\n+\n+There is more documentation in each of the files referenced above.\n+\n+FIXME (#3072) - This is still incomplete.\n+\n+*/\n \n import codemap::span;\n import ext::base::ext_ctxt;"}]}