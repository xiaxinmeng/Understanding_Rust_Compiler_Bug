{"sha": "3ac00a94895f4d9a8119ef35494fddb9d66436ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYzAwYTk0ODk1ZjRkOWE4MTE5ZWYzNTQ5NGZkZGI5ZDY2NDM2YWU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-11T11:37:22Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-12T02:21:04Z"}, "message": "std: remove substr & str::count_*, methodise char_len, implement slice_chars.\n\nThe confusing mixture of byte index and character count meant that every\nuse of .substr was incorrect; replaced by slice_chars which only uses\ncharacter indices. The old behaviour of `.substr(start, n)` can be emulated\nvia `.slice_from(start).slice_chars(0, n)`.", "tree": {"sha": "05891e2d06bdd87071ec5df904f746494bdf8f7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05891e2d06bdd87071ec5df904f746494bdf8f7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ac00a94895f4d9a8119ef35494fddb9d66436ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac00a94895f4d9a8119ef35494fddb9d66436ae", "html_url": "https://github.com/rust-lang/rust/commit/3ac00a94895f4d9a8119ef35494fddb9d66436ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ac00a94895f4d9a8119ef35494fddb9d66436ae/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fff8c6eba287e0ed7cce6014dc58482afe425b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fff8c6eba287e0ed7cce6014dc58482afe425b0", "html_url": "https://github.com/rust-lang/rust/commit/9fff8c6eba287e0ed7cce6014dc58482afe425b0"}], "stats": {"total": 180, "additions": 76, "deletions": 104}, "files": [{"sha": "a458036116665354c214f48f46ae181dff3fdc50", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -1410,7 +1410,7 @@ let new_favorite_crayon_name = favorite_crayon_name.trim();\n \n if favorite_crayon_name.len() > 5 {\n    // Create a substring\n-   println(favorite_crayon_name.substr(0, 5));\n+   println(favorite_crayon_name.slice_chars(0, 5));\n }\n ~~~\n "}, {"sha": "0856c256c5b1506fb56d676778aca9d308260094", "filename": "src/libextra/rope.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibextra%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibextra%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frope.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -84,9 +84,9 @@ pub fn of_str(str: @~str) -> Rope {\n  *\n  * # Return value\n  *\n- * A rope representing the same string as `str.substr(byte_offset,\n- * byte_len)`.  Depending on `byte_len`, this rope may be empty, flat\n- * or complex.\n+ * A rope representing the same string as `str.slice(byte_offset,\n+ * byte_offset + byte_len)`.  Depending on `byte_len`, this rope may\n+ * be empty, flat or complex.\n  *\n  * # Performance note\n  *\n@@ -588,7 +588,7 @@ pub mod node {\n      * * char_len - The number of chars in the leaf.\n      * * content - Contents of the leaf.\n      *\n-     *     Note that we can have `char_len < str::char_len(content)`, if\n+     *     Note that we can have `char_len < content.char_len()`, if\n      *     this leaf is only a subset of the string. Also note that the\n      *     string can be shared between several ropes, e.g. for indexing\n      *     purposes.\n@@ -680,7 +680,7 @@ pub mod node {\n      */\n     pub fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n         return of_substr_unsafer(str, byte_start, byte_len,\n-                              str::count_chars(*str, byte_start, byte_len));\n+                                 str.slice(byte_start, byte_start + byte_len).char_len());\n     }\n \n     /**\n@@ -734,7 +734,7 @@ pub mod node {\n                     if i == 0u  { first_leaf_char_len }\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n-                    str::count_bytes(*str, offset, chunk_char_len);\n+                    str.slice_from(offset).slice_chars(0, chunk_char_len).len();\n                 nodes[i] = @Leaf(Leaf {\n                     byte_offset: offset,\n                     byte_len: chunk_byte_len,\n@@ -938,7 +938,7 @@ pub mod node {\n             match (*node) {\n               node::Leaf(x) => {\n                 let char_len =\n-                    str::count_chars(*x.content, byte_offset, byte_len);\n+                    x.content.slice(byte_offset, byte_offset + byte_len).char_len();\n                 return @Leaf(Leaf {\n                     byte_offset: byte_offset,\n                     byte_len: byte_len,\n@@ -1002,9 +1002,9 @@ pub mod node {\n                     return node;\n                 }\n                 let byte_offset =\n-                    str::count_bytes(*x.content, 0u, char_offset);\n+                    x.content.slice_chars(0, char_offset).len();\n                 let byte_len    =\n-                    str::count_bytes(*x.content, byte_offset, char_len);\n+                    x.content.slice_from(byte_offset).slice_chars(0, char_len).len();\n                 return @Leaf(Leaf {\n                     byte_offset: byte_offset,\n                     byte_len: byte_len,\n@@ -1312,7 +1312,7 @@ mod tests {\n         let sample = @~\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert_eq!(char_len(r), str::char_len(*sample));\n+        assert_eq!(char_len(r), sample.char_len());\n         assert!(rope_to_string(r) == *sample);\n     }\n \n@@ -1328,7 +1328,7 @@ mod tests {\n         }\n         let sample = @copy *buf;\n         let r      = of_str(sample);\n-        assert!(char_len(r) == str::char_len(*sample));\n+        assert_eq!(char_len(r), sample.char_len());\n         assert!(rope_to_string(r) == *sample);\n \n         let mut string_iter = 0u;\n@@ -1374,7 +1374,7 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(len, str::char_len(*sample));\n+        assert_eq!(len, sample.char_len());\n     }\n \n     #[test]"}, {"sha": "48a3e1e9c695c51762529100d34d758faadb663e", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -27,7 +27,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n     let homedir = os::homedir();\n \n     let mut dirs_to_search = ~[];\n-    let first_char = term.substr(0, 1);\n+    let first_char = term.char_at(0);\n \n     // Find search directory\n     match getenv(\"TERMINFO\") {\n@@ -57,12 +57,12 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~path> {\n \n     // Look for the terminal in all of the search directories\n     for dirs_to_search.each |p| {\n-        let newp = ~p.push_many(&[first_char.to_owned(), term.to_owned()]);\n+        let newp = ~p.push_many(&[str::from_char(first_char), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);\n         }\n         // on some installations the dir is named after the hex of the char (e.g. OS X)\n-        let newp = ~p.push_many(&[fmt!(\"%x\", first_char[0] as uint), term.to_owned()]);\n+        let newp = ~p.push_many(&[fmt!(\"%x\", first_char as uint), term.to_owned()]);\n         if os::path_exists(p) && os::path_exists(newp) {\n             return Some(newp);\n         }"}, {"sha": "7a631b5fc6832fbe0a99374149bc8647edbdb96f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -590,7 +590,7 @@ pub fn build_session_options(binary: @~str,\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n         // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-        let level_short = level_name.substr(0,1);\n+        let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));"}, {"sha": "1adb991c96e71c7421bb32c7eb9057865046a24f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -2678,14 +2678,14 @@ impl Resolver {\n         match module_prefix_result {\n             Failed => {\n                 let mpath = self.idents_to_str(module_path);\n-                match self.idents_to_str(module_path).rfind(':') {\n+                match mpath.rfind(':') {\n                     Some(idx) => {\n                         self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` \\\n-                                                         in `%s`\", mpath.substr(idx,\n-                                                                                mpath.len() - idx),\n-                                                         // idx - 1 to account for the extra\n-                                                         // colon\n-                                                         mpath.substr(0, idx - 1)));\n+                                                         in `%s`\",\n+                                                         // idx +- 1 to account for the colons\n+                                                         // on either side\n+                                                         mpath.slice_from(idx + 1),\n+                                                         mpath.slice_to(idx - 1)));\n                     },\n                     None => (),\n                 };"}, {"sha": "65755345ac3d5f03fe7fc9843bcbcc736fd49322", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -1704,5 +1704,5 @@ fn trans_assign_op(bcx: block,\n }\n \n fn shorten(x: ~str) -> ~str {\n-    if x.len() > 60 { x.substr(0, 60).to_owned() } else { x }\n+    if x.char_len() > 60 { x.slice_chars(0, 60).to_owned() } else { x }\n }"}, {"sha": "3e1883062f33c5346fd2e26c8bee87e8f1780a7f", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -284,7 +284,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n             for args.each |arg| {\n                 let (crate, filename) =\n                     if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.substr(0, arg.len() - 3).to_owned(), copy *arg)\n+                    (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n                 } else {\n                     (copy *arg, arg + \".rs\")\n                 };\n@@ -342,7 +342,8 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n         // FIXME #5898: conflicts with Cell.take(), so can't be at the top level\n         use core::iterator::IteratorUtil;\n \n-        let full = line.substr(1, line.len() - 1);\n+        // drop the : and the \\n (one byte each)\n+        let full = line.slice(1, line.len() - 1);\n         let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n         let len = split.len();\n "}, {"sha": "0c99dd4f9fe0ba301908ee650ca79b4835bf8fff", "filename": "src/libstd/str.rs", "status": "modified", "additions": 44, "deletions": 73, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -848,15 +848,6 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     return true;\n }\n \n-\n-/*\n-Section: String properties\n-*/\n-\n-/// Returns the number of characters that a string holds\n-#[inline(always)]\n-pub fn char_len(s: &str) -> uint { count_chars(s, 0u, s.len()) }\n-\n /*\n Section: Misc\n */\n@@ -974,46 +965,6 @@ pub fn with_capacity(capacity: uint) -> ~str {\n     buf\n }\n \n-/**\n- * As char_len but for a slice of a string\n- *\n- * # Arguments\n- *\n- * * s - A valid string\n- * * start - The position inside `s` where to start counting in bytes\n- * * end - The position where to stop counting\n- *\n- * # Return value\n- *\n- * The number of Unicode characters in `s` between the given indices.\n- */\n-pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n-    assert!(s.is_char_boundary(start));\n-    assert!(s.is_char_boundary(end));\n-    let mut (i, len) = (start, 0u);\n-    while i < end {\n-        let next = s.char_range_at(i).next;\n-        len += 1u;\n-        i = next;\n-    }\n-    return len;\n-}\n-\n-/// Counts the number of bytes taken by the first `n` chars in `s`\n-/// starting from `start`.\n-pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n-    assert!(s.is_char_boundary(start));\n-    let mut (end, cnt) = (start, n);\n-    let l = s.len();\n-    while cnt > 0u {\n-        assert!(end < l);\n-        let next = s.char_range_at(end).next;\n-        cnt -= 1u;\n-        end = next;\n-    }\n-    end - start\n-}\n-\n /// Given a first byte, determine how many bytes are in this UTF-8 character\n pub fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n@@ -1394,11 +1345,14 @@ pub trait StrSlice<'self> {\n     fn is_alphanumeric(&self) -> bool;\n     fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n+\n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n     fn slice_from(&self, begin: uint) -> &'self str;\n     fn slice_to(&self, end: uint) -> &'self str;\n+\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'self str;\n+\n     fn starts_with(&self, needle: &str) -> bool;\n-    fn substr(&self, begin: uint, n: uint) -> &'self str;\n     fn escape_default(&self) -> ~str;\n     fn escape_unicode(&self) -> ~str;\n     fn trim(&self) -> &'self str;\n@@ -1595,7 +1549,8 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n     /// Returns the number of characters that a string holds\n     #[inline]\n-    fn char_len(&self) -> uint { char_len(*self) }\n+    fn char_len(&self) -> uint { self.iter().count() }\n+\n     /**\n      * Returns a slice of the given string from the byte range\n      * [`begin`..`end`)\n@@ -1626,6 +1581,32 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn slice_to(&self, end: uint) -> &'self str {\n         self.slice(0, end)\n     }\n+\n+    /// Returns a slice of the string from the char range\n+    /// [`begin`..`end`).\n+    ///\n+    /// Fails if `begin` > `end` or the either `begin` or `end` are\n+    /// beyond the last character of the string.\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n+        assert!(begin <= end);\n+        // not sure how to use the iterators for this nicely.\n+        let mut (position, count) = (0, 0);\n+        let l = self.len();\n+        while count < begin && position < l {\n+            position = self.char_range_at(position).next;\n+            count += 1;\n+        }\n+        if count < begin { fail!(\"Attempted to begin slice_chars beyond end of string\") }\n+        let start_byte = position;\n+        while count < end && position < l {\n+            position = self.char_range_at(position).next;\n+            count += 1;\n+        }\n+        if count < end { fail!(\"Attempted to end slice_chars beyond end of string\") }\n+\n+        self.slice(start_byte, position)\n+    }\n+\n     /// Returns true if `needle` is a prefix of the string.\n     fn starts_with<'a>(&self, needle: &'a str) -> bool {\n         let (self_len, needle_len) = (self.len(), needle.len());\n@@ -1641,16 +1622,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         else { match_at(*self, needle, self_len - needle_len) }\n     }\n \n-    /**\n-     * Take a substring of another.\n-     *\n-     * Returns a string containing `n` characters starting at byte offset\n-     * `begin`.\n-     */\n-    #[inline]\n-    fn substr(&self, begin: uint, n: uint) -> &'self str {\n-        self.slice(begin, begin + count_bytes(*self, begin, n))\n-    }\n     /// Escape each char in `s` with char::escape_default.\n     #[inline]\n     fn escape_default(&self) -> ~str { escape_default(*self) }\n@@ -2367,14 +2338,14 @@ mod tests {\n         assert_eq!(\"\\u2620\".len(), 3u);\n         assert_eq!(\"\\U0001d11e\".len(), 4u);\n \n-        assert_eq!(char_len(\"\"), 0u);\n-        assert_eq!(char_len(\"hello world\"), 11u);\n-        assert_eq!(char_len(\"\\x63\"), 1u);\n-        assert_eq!(char_len(\"\\xa2\"), 1u);\n-        assert_eq!(char_len(\"\\u03c0\"), 1u);\n-        assert_eq!(char_len(\"\\u2620\"), 1u);\n-        assert_eq!(char_len(\"\\U0001d11e\"), 1u);\n-        assert_eq!(char_len(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"), 19u);\n+        assert_eq!(\"\".char_len(), 0u);\n+        assert_eq!(\"hello world\".char_len(), 11u);\n+        assert_eq!(\"\\x63\".char_len(), 1u);\n+        assert_eq!(\"\\xa2\".char_len(), 1u);\n+        assert_eq!(\"\\u03c0\".char_len(), 1u);\n+        assert_eq!(\"\\u2620\".char_len(), 1u);\n+        assert_eq!(\"\\U0001d11e\".char_len(), 1u);\n+        assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".char_len(), 19u);\n     }\n \n     #[test]\n@@ -2509,13 +2480,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_substr() {\n-        fn t(a: &str, b: &str, start: int) {\n-            assert_eq!(a.substr(start as uint, b.len()), b);\n+    fn test_slice_chars() {\n+        fn t(a: &str, b: &str, start: uint) {\n+            assert_eq!(a.slice_chars(start, start + b.char_len()), b);\n         }\n         t(\"hello\", \"llo\", 2);\n         t(\"hello\", \"el\", 1);\n-        assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".substr(6u, 6u));\n+        assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n     #[test]"}, {"sha": "7d9ce585d7c5239a0730ef9602e701f81ceff2ff", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -325,7 +325,7 @@ pub mod ct {\n             'o' => TyOctal,\n             'f' => TyFloat,\n             '?' => TyPoly,\n-            _ => err(~\"unknown type in conversion: \" + s.substr(i, 1))\n+            _ => err(fmt!(\"unknown type in conversion: %c\", s.char_at(i)))\n         };\n \n         Parsed::new(t, i + 1)\n@@ -546,7 +546,7 @@ pub mod rt {\n         // displayed\n         let unpadded = match cv.precision {\n           CountImplied => s,\n-          CountIs(max) => if (max as uint) < str::char_len(s) {\n+          CountIs(max) => if (max as uint) < s.char_len() {\n             s.slice(0, max as uint)\n           } else {\n             s\n@@ -584,7 +584,7 @@ pub mod rt {\n                 ~\"\"\n             } else {\n                 let s = uint::to_str_radix(num, radix);\n-                let len = str::char_len(s);\n+                let len = s.char_len();\n                 if len < prec {\n                     let diff = prec - len;\n                     let pad = str::from_chars(vec::from_elem(diff, '0'));\n@@ -614,7 +614,7 @@ pub mod rt {\n             }\n             CountIs(width) => { width as uint }\n         };\n-        let strlen = str::char_len(s) + headsize;\n+        let strlen = s.char_len() + headsize;\n         if uwidth <= strlen {\n             for head.iter().advance |&c| {\n                 buf.push_char(c);"}, {"sha": "c126a84e78227c5e5db672a180cae48b08b5c50d", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ac00a94895f4d9a8119ef35494fddb9d66436ae/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=3ac00a94895f4d9a8119ef35494fddb9d66436ae", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n     let schs: ~[char] = s.iter().collect();\n \n     assert!(s.len() == 10u);\n-    assert!(str::char_len(s) == 4u);\n+    assert!(s.char_len() == 4u);\n     assert!(schs.len() == 4u);\n     assert!(str::from_chars(schs) == s);\n     assert!(s.char_at(0u) == 'e');"}]}