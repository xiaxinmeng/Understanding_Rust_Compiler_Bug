{"sha": "bbc5c1d24e1a641b134f634516828301e8cfc320", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYzVjMWQyNGUxYTY0MWIxMzRmNjM0NTE2ODI4MzAxZThjZmMzMjA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-21T21:28:06Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-21T21:28:06Z"}, "message": "Merge #1189\n\n1189: Fix #1178 r=matklad a=edwin0cheng\n\nThis PR improves / fixes mbe :\r\n\r\n1. Fixed a offest bug in `SourceTreeWalker`\r\n2. Handle `*+` matcher properly\r\n3. Add missing separator in rhs macro expansion.\r\n4. Fixed bug in single token with empty delimiter subtree case. It is because the current `mbe_expander` will create an delimiter subtree for each expansion. But in `tt` case, all puncts expansion will be incorrect because of it. \r\n5. Fixed lifetime bug\r\n6. Add more information on parse_macro fail\r\n7. Add tests for above.\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "f10fe8412874714edcc2d317ab7822b9bbf80a74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f10fe8412874714edcc2d317ab7822b9bbf80a74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbc5c1d24e1a641b134f634516828301e8cfc320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc5c1d24e1a641b134f634516828301e8cfc320", "html_url": "https://github.com/rust-lang/rust/commit/bbc5c1d24e1a641b134f634516828301e8cfc320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbc5c1d24e1a641b134f634516828301e8cfc320/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "ee94edc722c9649bd16bb754959ad349593045e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee94edc722c9649bd16bb754959ad349593045e2", "html_url": "https://github.com/rust-lang/rust/commit/ee94edc722c9649bd16bb754959ad349593045e2"}, {"sha": "120bfde3c22ed662cd4d3c35e91a739a86d0e990", "url": "https://api.github.com/repos/rust-lang/rust/commits/120bfde3c22ed662cd4d3c35e91a739a86d0e990", "html_url": "https://github.com/rust-lang/rust/commit/120bfde3c22ed662cd4d3c35e91a739a86d0e990"}], "stats": {"total": 228, "additions": 194, "deletions": 34}, "files": [{"sha": "e771a311c47f8e3944d662dbc2a9e990e9565758", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=bbc5c1d24e1a641b134f634516828301e8cfc320", "patch": "@@ -63,11 +63,15 @@ impl HirFileId {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.parse(file_id),\n             HirFileIdRepr::Macro(macro_call_id) => {\n-                parse_macro(db, macro_call_id).unwrap_or_else(|| {\n+                parse_macro(db, macro_call_id).unwrap_or_else(|err| {\n                     // Note:\n                     // The final goal we would like to make all parse_macro success,\n                     // such that the following log will not call anyway.\n-                    log::warn!(\"fail on macro_parse: {}\", macro_call_id.debug_dump(db));\n+                    log::warn!(\n+                        \"fail on macro_parse: (reason: {}) {}\",\n+                        err,\n+                        macro_call_id.debug_dump(db)\n+                    );\n \n                     // returning an empty string looks fishy...\n                     SourceFile::parse(\"\")\n@@ -77,14 +81,20 @@ impl HirFileId {\n     }\n }\n \n-fn parse_macro(db: &impl DefDatabase, macro_call_id: MacroCallId) -> Option<TreeArc<SourceFile>> {\n+fn parse_macro(\n+    db: &impl DefDatabase,\n+    macro_call_id: MacroCallId,\n+) -> Result<TreeArc<SourceFile>, String> {\n     let loc = macro_call_id.loc(db);\n     let macro_call = loc.ast_id.to_node(db);\n-    let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n-\n-    let macro_rules = db.macro_def(loc.def)?;\n-    let tt = macro_rules.expand(&macro_arg).ok()?;\n-    Some(mbe::token_tree_to_ast_item_list(&tt))\n+    let (macro_arg, _) = macro_call\n+        .token_tree()\n+        .and_then(mbe::ast_to_token_tree)\n+        .ok_or(\"Fail to args in to tt::TokenTree\")?;\n+\n+    let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n+    let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n+    Ok(mbe::token_tree_to_ast_item_list(&tt))\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -311,11 +321,18 @@ impl MacroCallId {\n     pub fn debug_dump(&self, db: &impl DefDatabase) -> String {\n         let loc = self.clone().loc(db);\n         let node = loc.ast_id.to_node(db);\n-        let syntax_str = node.syntax().to_string();\n+        let syntax_str = node.syntax().text().chunks().collect::<Vec<_>>().join(\" \");\n \n         // dump the file name\n         let file_id: HirFileId = self.clone().into();\n         let original = file_id.original_file(db);\n-        format!(\"macro call [file: {:#?}] : {}\", db.file_relative_path(original), syntax_str)\n+        let macro_rules = db.macro_def(loc.def);\n+\n+        format!(\n+            \"macro call [file: {:#?}] : {}\\nhas rules: {}\",\n+            db.file_relative_path(original),\n+            syntax_str,\n+            macro_rules.is_some()\n+        )\n     }\n }"}, {"sha": "e78bc734bbee9dbd1f3cb6f2b3af945ed64a611a", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 87, "deletions": 2, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=bbc5c1d24e1a641b134f634516828301e8cfc320", "patch": "@@ -220,9 +220,10 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         let expansion = syntax_node_to_token_tree(expansion.syntax()).unwrap().0;\n         let file = token_tree_to_macro_items(&expansion);\n         let file = file.unwrap().syntax().debug_dump().trim().to_string();\n-        let file = file.replace(\"C_C__C\", \"$crate\");\n+        let tree = tree.unwrap().syntax().debug_dump().trim().to_string();\n \n-        assert_eq!(tree.unwrap().syntax().debug_dump().trim(), file,);\n+        let file = file.replace(\"C_C__C\", \"$crate\");\n+        assert_eq!(tree, file,);\n     }\n \n     #[test]\n@@ -348,6 +349,21 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n     }\n \n+    #[test]\n+    fn test_match_group_pattern_with_multiple_statement_without_semi() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ ($ i:ident),*) => ( fn baz { $ (\n+                $i()\n+            );*} );            \n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n+    }\n+\n     #[test]\n     fn test_match_group_empty_fixed_token() {\n         let rules = create_rules(\n@@ -691,6 +707,33 @@ MACRO_ITEMS@[0; 40)\n         );\n     }\n \n+    #[test]\n+    fn test_ty_with_complex_type() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:ty) => (\n+                fn bar() -> $ i { unimplemented!() }\n+            )\n+        }\n+\"#,\n+        );\n+\n+        // Reference lifetime struct with generic type\n+        assert_expansion(\n+            &rules,\n+            \"foo! { &'a Baz<u8> }\",\n+            \"fn bar () -> & 'a Baz < u8 > {unimplemented ! ()}\",\n+        );\n+\n+        // extern \"Rust\" func type\n+        assert_expansion(\n+            &rules,\n+            r#\"foo! { extern \"Rust\" fn() -> Ret }\"#,\n+            r#\"fn bar () -> extern \"Rust\" fn () -> Ret {unimplemented ! ()}\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_pat_() {\n         let rules = create_rules(\n@@ -853,6 +896,26 @@ MACRO_ITEMS@[0; 40)\n     }\n \n     // The following tests are based on real world situations\n+    #[test]\n+    fn test_vec() {\n+        let rules = create_rules(\n+            r#\"\n+         macro_rules! vec {\n+            ($($item:expr),*) => {\n+                {\n+                    let mut v = Vec::new();\n+                    $(\n+                        v.push($item);\n+                    )*\n+                    v\n+                }\n+            };\n+}\n+\"#,\n+        );\n+        assert_expansion(&rules, r#\"vec!();\"#, r#\"{let mut v = Vec :: new () ;  v}\"#);\n+    }\n+\n     #[test]\n     fn test_winapi_struct() {\n         // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/macros.rs#L366\n@@ -886,4 +949,26 @@ macro_rules! STRUCT {\n         assert_expansion(&rules, r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#, \n         \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n     }\n+\n+    #[test]\n+    fn test_int_base() {\n+        let rules = create_rules(\n+            r#\"\n+macro_rules! int_base {\n+    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl fmt::$Trait for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                $Radix.fmt_int(*self as $U, f)\n+            }\n+        }\n+    }\n+}            \n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#, \n+        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt :: Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n+        );\n+    }\n }"}, {"sha": "00fb09a3b4a766160b6960b7039030724becf9bb", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=bbc5c1d24e1a641b134f634516828301e8cfc320", "patch": "@@ -221,11 +221,13 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                 }\n                 _ => return Err(ExpandError::UnexpectedToken),\n             },\n-            crate::TokenTree::Repeat(crate::Repeat { subtree, kind: _, separator }) => {\n+            crate::TokenTree::Repeat(crate::Repeat { subtree, kind, separator }) => {\n                 // Dirty hack to make macro-expansion terminate.\n                 // This should be replaced by a propper macro-by-example implementation\n                 let mut limit = 128;\n+                let mut counter = 0;\n                 while let Ok(nested) = match_lhs(subtree, input) {\n+                    counter += 1;\n                     limit -= 1;\n                     if limit == 0 {\n                         break;\n@@ -239,6 +241,17 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                         }\n                     }\n                 }\n+\n+                match kind {\n+                    crate::RepeatKind::OneOrMore if counter == 0 => {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+                    crate::RepeatKind::ZeroOrOne if counter > 1 => {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+\n+                    _ => {}\n+                }\n             }\n             crate::TokenTree::Subtree(subtree) => {\n                 let input_subtree =\n@@ -274,6 +287,20 @@ fn expand_subtree(\n     Ok(tt::Subtree { token_trees, delimiter: template.delimiter })\n }\n \n+/// Reduce single token subtree to single token\n+/// In `tt` matcher case, all tt tokens will be braced by a Delimiter::None\n+/// which makes all sort of problems.\n+fn reduce_single_token(mut subtree: tt::Subtree) -> tt::TokenTree {\n+    if subtree.delimiter != tt::Delimiter::None || subtree.token_trees.len() != 1 {\n+        return subtree.into();\n+    }\n+\n+    match subtree.token_trees.pop().unwrap() {\n+        tt::TokenTree::Subtree(subtree) => reduce_single_token(subtree),\n+        tt::TokenTree::Leaf(token) => token.into(),\n+    }\n+}\n+\n fn expand_tt(\n     template: &crate::TokenTree,\n     bindings: &Bindings,\n@@ -282,22 +309,40 @@ fn expand_tt(\n     let res: tt::TokenTree = match template {\n         crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n-            let mut token_trees = Vec::new();\n+            let mut token_trees: Vec<tt::TokenTree> = Vec::new();\n             nesting.push(0);\n             // Dirty hack to make macro-expansion terminate.\n             // This should be replaced by a propper macro-by-example implementation\n             let mut limit = 128;\n+            let mut has_sep = false;\n+\n             while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n                 limit -= 1;\n                 if limit == 0 {\n                     break;\n                 }\n                 let idx = nesting.pop().unwrap();\n                 nesting.push(idx + 1);\n-                token_trees.push(t.into())\n+                token_trees.push(reduce_single_token(t).into());\n+\n+                if let Some(sep) = repeat.separator {\n+                    let punct =\n+                        tt::Leaf::from(tt::Punct { char: sep, spacing: tt::Spacing::Alone });\n+                    token_trees.push(punct.into());\n+                    has_sep = true;\n+                }\n             }\n             nesting.pop().unwrap();\n-            tt::Subtree { token_trees, delimiter: tt::Delimiter::None }.into()\n+\n+            // Dirty hack for remove the last sep\n+            // if it is a \",\" undo the push\n+            if has_sep && repeat.separator.unwrap() == ',' {\n+                token_trees.pop();\n+            }\n+\n+            // Check if it is a singel token subtree without any delimiter\n+            // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n+            reduce_single_token(tt::Subtree { token_trees, delimiter: tt::Delimiter::None })\n         }\n         crate::TokenTree::Leaf(leaf) => match leaf {\n             crate::Leaf::Ident(ident) => {\n@@ -311,7 +356,13 @@ fn expand_tt(\n                     tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: TokenId::unspecified() })\n                         .into()\n                 } else {\n-                    bindings.get(&v.text, nesting)?.clone()\n+                    let tkn = bindings.get(&v.text, nesting)?.clone();\n+\n+                    if let tt::TokenTree::Subtree(subtree) = tkn {\n+                        reduce_single_token(subtree)\n+                    } else {\n+                        tkn\n+                    }\n                 }\n             }\n             crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),"}, {"sha": "0710062d9fd9ef8066fe24f23011d8b23582e4e4", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=bbc5c1d24e1a641b134f634516828301e8cfc320", "patch": "@@ -20,25 +20,25 @@ pub(crate) fn parse(tt: &tt::Subtree) -> Result<crate::MacroRules, ParseError> {\n }\n \n fn parse_rule(p: &mut TtCursor) -> Result<crate::Rule, ParseError> {\n-    let lhs = parse_subtree(p.eat_subtree()?)?;\n+    let lhs = parse_subtree(p.eat_subtree()?, false)?;\n     p.expect_char('=')?;\n     p.expect_char('>')?;\n-    let mut rhs = parse_subtree(p.eat_subtree()?)?;\n+    let mut rhs = parse_subtree(p.eat_subtree()?, true)?;\n     rhs.delimiter = crate::Delimiter::None;\n     Ok(crate::Rule { lhs, rhs })\n }\n \n-fn parse_subtree(tt: &tt::Subtree) -> Result<crate::Subtree, ParseError> {\n+fn parse_subtree(tt: &tt::Subtree, transcriber: bool) -> Result<crate::Subtree, ParseError> {\n     let mut token_trees = Vec::new();\n     let mut p = TtCursor::new(tt);\n     while let Some(tt) = p.eat() {\n         let child: crate::TokenTree = match tt {\n             tt::TokenTree::Leaf(leaf) => match leaf {\n                 tt::Leaf::Punct(tt::Punct { char: '$', .. }) => {\n                     if p.at_ident().is_some() {\n-                        crate::Leaf::from(parse_var(&mut p)?).into()\n+                        crate::Leaf::from(parse_var(&mut p, transcriber)?).into()\n                     } else {\n-                        parse_repeat(&mut p)?.into()\n+                        parse_repeat(&mut p, transcriber)?.into()\n                     }\n                 }\n                 tt::Leaf::Punct(punct) => crate::Leaf::from(*punct).into(),\n@@ -49,17 +49,17 @@ fn parse_subtree(tt: &tt::Subtree) -> Result<crate::Subtree, ParseError> {\n                     crate::Leaf::from(crate::Literal { text: text.clone() }).into()\n                 }\n             },\n-            tt::TokenTree::Subtree(subtree) => parse_subtree(&subtree)?.into(),\n+            tt::TokenTree::Subtree(subtree) => parse_subtree(&subtree, transcriber)?.into(),\n         };\n         token_trees.push(child);\n     }\n     Ok(crate::Subtree { token_trees, delimiter: tt.delimiter })\n }\n \n-fn parse_var(p: &mut TtCursor) -> Result<crate::Var, ParseError> {\n+fn parse_var(p: &mut TtCursor, transcriber: bool) -> Result<crate::Var, ParseError> {\n     let ident = p.eat_ident().unwrap();\n     let text = ident.text.clone();\n-    let kind = if p.at_char(':') {\n+    let kind = if !transcriber && p.at_char(':') {\n         p.bump();\n         if let Some(ident) = p.eat_ident() {\n             Some(ident.text.clone())\n@@ -70,12 +70,13 @@ fn parse_var(p: &mut TtCursor) -> Result<crate::Var, ParseError> {\n     } else {\n         None\n     };\n+\n     Ok(crate::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut TtCursor) -> Result<crate::Repeat, ParseError> {\n+fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, ParseError> {\n     let subtree = p.eat_subtree().unwrap();\n-    let mut subtree = parse_subtree(subtree)?;\n+    let mut subtree = parse_subtree(subtree, transcriber)?;\n     subtree.delimiter = crate::Delimiter::None;\n     let sep = p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?;\n     let (separator, rep) = match sep.char {"}, {"sha": "20da1e9f7e54239865651fba6d7e137faf908229", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc5c1d24e1a641b134f634516828301e8cfc320/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=bbc5c1d24e1a641b134f634516828301e8cfc320", "patch": "@@ -21,6 +21,7 @@ impl<'a> From<&'a [tt::TokenTree]> for TokenSeq<'a> {\n     }\n }\n \n+#[derive(Debug)]\n enum DelimToken<'a> {\n     Delim(&'a tt::Delimiter, bool),\n     Token(&'a tt::TokenTree),\n@@ -52,10 +53,10 @@ impl<'a> TokenSeq<'a> {\n         }\n     }\n \n-    fn child_slice(&self) -> &[tt::TokenTree] {\n+    fn child_slice(&self, pos: usize) -> &[tt::TokenTree] {\n         match self {\n-            TokenSeq::Subtree(subtree) => &subtree.token_trees,\n-            TokenSeq::Seq(tokens) => &tokens,\n+            TokenSeq::Subtree(subtree) => &subtree.token_trees[pos - 1..],\n+            TokenSeq::Seq(tokens) => &tokens[pos..],\n         }\n     }\n }\n@@ -114,7 +115,7 @@ impl<'a> SubTreeWalker<'a> {\n                     WalkCursor::Token(0, convert_delim(subtree.delimiter, false))\n                 }\n                 tt::TokenTree::Leaf(leaf) => {\n-                    let next_tokens = self.ts.child_slice();\n+                    let next_tokens = self.ts.child_slice(0);\n                     WalkCursor::Token(0, convert_leaf(&next_tokens, leaf))\n                 }\n             },\n@@ -190,8 +191,8 @@ impl<'a> SubTreeWalker<'a> {\n                     WalkCursor::Token(new_idx, convert_delim(subtree.delimiter, backward))\n                 }\n                 tt::TokenTree::Leaf(leaf) => {\n-                    let next_tokens = top.child_slice();\n-                    WalkCursor::Token(pos, convert_leaf(&next_tokens[pos..], leaf))\n+                    let next_tokens = top.child_slice(pos);\n+                    WalkCursor::Token(pos, convert_leaf(&next_tokens, leaf))\n                 }\n             },\n             DelimToken::Delim(delim, is_end) => {\n@@ -429,7 +430,12 @@ fn convert_literal(l: &tt::Literal) -> TtToken {\n }\n \n fn convert_ident(ident: &tt::Ident) -> TtToken {\n-    let kind = SyntaxKind::from_keyword(ident.text.as_str()).unwrap_or(IDENT);\n+    let kind = if let Some('\\'') = ident.text.chars().next() {\n+        LIFETIME\n+    } else {\n+        SyntaxKind::from_keyword(ident.text.as_str()).unwrap_or(IDENT)\n+    };\n+\n     TtToken { kind, is_joint_to_next: false, text: ident.text.clone(), n_tokens: 1 }\n }\n "}]}