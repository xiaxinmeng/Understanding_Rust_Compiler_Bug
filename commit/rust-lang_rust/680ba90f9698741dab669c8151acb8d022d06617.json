{"sha": "680ba90f9698741dab669c8151acb8d022d06617", "node_id": "C_kwDOAAsO6NoAKDY4MGJhOTBmOTY5ODc0MWRhYjY2OWM4MTUxYWNiOGQwMjJkMDY2MTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-11-22T11:06:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-22T11:06:36Z"}, "message": "Rollup merge of #104295 - compiler-errors:rpitit-generics-parity, r=eholk\n\nCheck generics parity before collecting return-position `impl Trait`s in trait\n\nThe only thing is that this duplicates the error message for number of generics mismatch, but we already deduplicate that error message in Cargo. I could add a flag to delay the error if the reviewer cares.\n\nFixes #104281\n\nAlso drive-by adds a few comments to the `collect_trait_impl_trait_tys` method, and removes an unused argument from `compare_number_of_generics`.", "tree": {"sha": "430945ced3e669e3d57f16eee0b9161b55cc7b02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/430945ced3e669e3d57f16eee0b9161b55cc7b02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/680ba90f9698741dab669c8151acb8d022d06617", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjfK08CRBK7hj4Ov3rIwAAsZAIAEHmyi4ZZr22z+js6/U7yQL4\nbt55tWRVAN8wZuVGp69n8VsO0/OI2Ui/OBoWzDHSeuFcS17ck5DLhn9y5i404Zjl\nMT9G4zjS3YogeegF0Bz1T6VyxjUA9oKv46HGoAbglL5Lrl38/+KSV9qSznGvtD8h\nO/maJS4cfp09TNzcrGiWZIBqTGHZsCeFKk3nZLnBBDfOpGDfgB5dAj6aR42Qzd0C\nKWJz721o5xnemGa5Felf0p0NYe6z4RGdiEHK1nScxBoLfnhhn7sTqOkt48qAdw1x\nB84h1Drti8AwClPLxJmRhS/IrXN0z3utaherb5e6JKE33V4R5B8l9KRYfb8b35k=\n=3Yy7\n-----END PGP SIGNATURE-----\n", "payload": "tree 430945ced3e669e3d57f16eee0b9161b55cc7b02\nparent a78c9bee4d9d51a3891bd8ecae1f28a93b83653b\nparent df5f247a5c5432fc85a84cafb8461fafd01cf6ae\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1669115196 +0530\ncommitter GitHub <noreply@github.com> 1669115196 +0530\n\nRollup merge of #104295 - compiler-errors:rpitit-generics-parity, r=eholk\n\nCheck generics parity before collecting return-position `impl Trait`s in trait\n\nThe only thing is that this duplicates the error message for number of generics mismatch, but we already deduplicate that error message in Cargo. I could add a flag to delay the error if the reviewer cares.\n\nFixes #104281\n\nAlso drive-by adds a few comments to the `collect_trait_impl_trait_tys` method, and removes an unused argument from `compare_number_of_generics`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/680ba90f9698741dab669c8151acb8d022d06617", "html_url": "https://github.com/rust-lang/rust/commit/680ba90f9698741dab669c8151acb8d022d06617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/680ba90f9698741dab669c8151acb8d022d06617/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b", "html_url": "https://github.com/rust-lang/rust/commit/a78c9bee4d9d51a3891bd8ecae1f28a93b83653b"}, {"sha": "df5f247a5c5432fc85a84cafb8461fafd01cf6ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/df5f247a5c5432fc85a84cafb8461fafd01cf6ae", "html_url": "https://github.com/rust-lang/rust/commit/df5f247a5c5432fc85a84cafb8461fafd01cf6ae"}], "stats": {"total": 97, "additions": 65, "deletions": 32}, "files": [{"sha": "6a1784787587752de4e55ec22267ebb02af47549", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/680ba90f9698741dab669c8151acb8d022d06617/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680ba90f9698741dab669c8151acb8d022d06617/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=680ba90f9698741dab669c8151acb8d022d06617", "patch": "@@ -14,10 +14,8 @@ use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n use rustc_middle::ty::{\n-    self, AssocItem, DefIdTree, TraitRef, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n-    TypeVisitable,\n+    self, DefIdTree, InternalSubsts, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n-use rustc_middle::ty::{FnSig, InternalSubsts};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -51,11 +49,11 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_number_of_generics(tcx, impl_m, impl_m_span, trait_m, trait_item_span) {\n+    if let Err(_) = compare_number_of_generics(tcx, impl_m, trait_m, trait_item_span, false) {\n         return;\n     }\n \n-    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m) {\n+    if let Err(_) = compare_generic_param_kinds(tcx, impl_m, trait_m, false) {\n         return;\n     }\n \n@@ -144,9 +142,9 @@ pub(crate) fn compare_impl_method<'tcx>(\n #[instrument(level = \"debug\", skip(tcx, impl_m_span, impl_trait_ref))]\n fn compare_predicate_entailment<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    impl_m: &AssocItem,\n+    impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n-    trait_m: &AssocItem,\n+    trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n@@ -157,8 +155,7 @@ fn compare_predicate_entailment<'tcx>(\n     // FIXME(@lcnr): remove that after removing `cause.body_id` from\n     // obligations.\n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n-    // We sometimes modify the span further down.\n-    let mut cause = ObligationCause::new(\n+    let cause = ObligationCause::new(\n         impl_m_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -307,14 +304,13 @@ fn compare_predicate_entailment<'tcx>(\n         debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n         let emitted = report_trait_method_mismatch(\n-            tcx,\n-            &mut cause,\n             &infcx,\n+            cause,\n             terr,\n             (trait_m, trait_fty),\n             (impl_m, impl_fty),\n-            &trait_sig,\n-            &impl_trait_ref,\n+            trait_sig,\n+            impl_trait_ref,\n         );\n         return Err(emitted);\n     }\n@@ -352,11 +348,15 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let impl_trait_ref = tcx.impl_trait_ref(impl_m.impl_container(tcx).unwrap()).unwrap();\n     let param_env = tcx.param_env(def_id);\n \n+    // First, check a few of the same thing as `compare_impl_method`, just so we don't ICE during substitutions later.\n+    compare_number_of_generics(tcx, impl_m, trait_m, tcx.hir().span_if_local(impl_m.def_id), true)?;\n+    compare_generic_param_kinds(tcx, impl_m, trait_m, true)?;\n+\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-    let mut cause = ObligationCause::new(\n+    let cause = ObligationCause::new(\n         return_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -376,6 +376,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let infcx = &tcx.infer_ctxt().build();\n     let ocx = ObligationCtxt::new(infcx);\n \n+    // Normalize the impl signature with fresh variables for lifetime inference.\n     let norm_cause = ObligationCause::misc(return_span, impl_m_hir_id);\n     let impl_sig = ocx.normalize(\n         norm_cause.clone(),\n@@ -388,6 +389,10 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     );\n     let impl_return_ty = impl_sig.output();\n \n+    // Normalize the trait signature with liberated bound vars, passing it through\n+    // the ImplTraitInTraitCollector, which gathers all of the RPITITs and replaces\n+    // them with inference variables.\n+    // We will use these inference variables to collect the hidden types of RPITITs.\n     let mut collector = ImplTraitInTraitCollector::new(&ocx, return_span, param_env, impl_m_hir_id);\n     let unnormalized_trait_sig = tcx\n         .liberate_late_bound_regions(\n@@ -448,14 +453,13 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n             // emit an error now because `compare_predicate_entailment` will not report the error\n             // when normalization fails.\n             let emitted = report_trait_method_mismatch(\n-                tcx,\n-                &mut cause,\n                 infcx,\n+                cause,\n                 terr,\n                 (trait_m, trait_fty),\n                 (impl_m, impl_fty),\n-                &trait_sig,\n-                &impl_trait_ref,\n+                trait_sig,\n+                impl_trait_ref,\n             );\n             return Err(emitted);\n         }\n@@ -625,23 +629,21 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n }\n \n fn report_trait_method_mismatch<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cause: &mut ObligationCause<'tcx>,\n     infcx: &InferCtxt<'tcx>,\n+    mut cause: ObligationCause<'tcx>,\n     terr: TypeError<'tcx>,\n-    (trait_m, trait_fty): (&AssocItem, Ty<'tcx>),\n-    (impl_m, impl_fty): (&AssocItem, Ty<'tcx>),\n-    trait_sig: &FnSig<'tcx>,\n-    impl_trait_ref: &TraitRef<'tcx>,\n+    (trait_m, trait_fty): (&ty::AssocItem, Ty<'tcx>),\n+    (impl_m, impl_fty): (&ty::AssocItem, Ty<'tcx>),\n+    trait_sig: ty::FnSig<'tcx>,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> ErrorGuaranteed {\n+    let tcx = infcx.tcx;\n     let (impl_err_span, trait_err_span) =\n         extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n \n-    cause.span = impl_err_span;\n-\n     let mut diag = struct_span_err!(\n         tcx.sess,\n-        cause.span(),\n+        impl_err_span,\n         E0053,\n         \"method `{}` has an incompatible type for trait\",\n         trait_m.name\n@@ -712,6 +714,7 @@ fn report_trait_method_mismatch<'tcx>(\n         _ => {}\n     }\n \n+    cause.span = impl_err_span;\n     infcx.err_ctxt().note_type_err(\n         &mut diag,\n         &cause,\n@@ -922,9 +925,9 @@ fn compare_self_type<'tcx>(\n fn compare_number_of_generics<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_: &ty::AssocItem,\n-    _impl_span: Span,\n     trait_: &ty::AssocItem,\n     trait_span: Option<Span>,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_own_counts = tcx.generics_of(trait_.def_id).own_counts();\n     let impl_own_counts = tcx.generics_of(impl_.def_id).own_counts();\n@@ -1054,7 +1057,7 @@ fn compare_number_of_generics<'tcx>(\n                 err.span_label(*span, \"`impl Trait` introduces an implicit type parameter\");\n             }\n \n-            let reported = err.emit();\n+            let reported = err.emit_unless(delay);\n             err_occurred = Some(reported);\n         }\n     }\n@@ -1306,6 +1309,7 @@ fn compare_generic_param_kinds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_item: &ty::AssocItem,\n     trait_item: &ty::AssocItem,\n+    delay: bool,\n ) -> Result<(), ErrorGuaranteed> {\n     assert_eq!(impl_item.kind, trait_item.kind);\n \n@@ -1363,7 +1367,7 @@ fn compare_generic_param_kinds<'tcx>(\n             err.span_label(impl_header_span, \"\");\n             err.span_label(param_impl_span, make_param_message(\"found\", param_impl));\n \n-            let reported = err.emit();\n+            let reported = err.emit_unless(delay);\n             return Err(reported);\n         }\n     }\n@@ -1489,9 +1493,9 @@ pub(crate) fn compare_ty_impl<'tcx>(\n     debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n \n     let _: Result<(), ErrorGuaranteed> = (|| {\n-        compare_number_of_generics(tcx, impl_ty, impl_ty_span, trait_ty, trait_item_span)?;\n+        compare_number_of_generics(tcx, impl_ty, trait_ty, trait_item_span, false)?;\n \n-        compare_generic_param_kinds(tcx, impl_ty, trait_ty)?;\n+        compare_generic_param_kinds(tcx, impl_ty, trait_ty, false)?;\n \n         let sp = tcx.def_span(impl_ty.def_id);\n         compare_type_predicate_entailment(tcx, impl_ty, sp, trait_ty, impl_trait_ref)?;"}, {"sha": "0bbe50ea6fd37a14b94992b6a9ed6bc104544da5", "filename": "src/test/ui/impl-trait/in-trait/trait-more-generics-than-impl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/680ba90f9698741dab669c8151acb8d022d06617/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680ba90f9698741dab669c8151acb8d022d06617/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs?ref=680ba90f9698741dab669c8151acb8d022d06617", "patch": "@@ -0,0 +1,17 @@\n+#![feature(return_position_impl_trait_in_trait)]\n+#![allow(incomplete_features)]\n+\n+struct S;\n+\n+trait Foo {\n+    fn bar<T>() -> impl Sized;\n+}\n+\n+impl Foo for S {\n+    fn bar() -> impl Sized {}\n+    //~^ ERROR method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n+}\n+\n+fn main() {\n+    S::bar();\n+}"}, {"sha": "8ff54cad95139377497df069ac926709e01192a8", "filename": "src/test/ui/impl-trait/in-trait/trait-more-generics-than-impl.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/680ba90f9698741dab669c8151acb8d022d06617/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/680ba90f9698741dab669c8151acb8d022d06617/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.stderr?ref=680ba90f9698741dab669c8151acb8d022d06617", "patch": "@@ -0,0 +1,12 @@\n+error[E0049]: method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n+  --> $DIR/trait-more-generics-than-impl.rs:11:11\n+   |\n+LL |     fn bar<T>() -> impl Sized;\n+   |            - expected 1 type parameter\n+...\n+LL |     fn bar() -> impl Sized {}\n+   |           ^ found 0 type parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0049`."}]}