{"sha": "a6ce402401f0da3a48a5a183ae109a00024ba666", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2Y2U0MDI0MDFmMGRhM2E0OGE1YTE4M2FlMTA5YTAwMDI0YmE2NjY=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:06:52Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-12-05T18:06:52Z"}, "message": "rollup merge of #19416: sfackler/global-stdin\n\nio::stdin returns a new `BufferedReader` each time it's called, which\nresults in some very confusing behavior with disappearing output. It now\nreturns a `StdinReader`, which wraps a global singleton\n`Arc<Mutex<BufferedReader<StdReader>>`. `Reader` is implemented directly\non `StdinReader`. However, `Buffer` is not, as the `fill_buf` method is\nfundamentaly un-thread safe. A `lock` method is defined on `StdinReader`\nwhich returns a smart pointer wrapping the underlying `BufferedReader`\nwhile guaranteeing mutual exclusion.\n\nCode that treats the return value of io::stdin as implementing `Buffer`\nwill break. Add a call to `lock`:\n\n```rust\nio::stdin().read_line();\n// =>\nio::stdin().lock().read_line();\n```\n\nCloses #14434\n\n[breaking-change]", "tree": {"sha": "0bc4fa5f3fe2b82889e7ab754ef68358a4cc8008", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bc4fa5f3fe2b82889e7ab754ef68358a4cc8008"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6ce402401f0da3a48a5a183ae109a00024ba666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ce402401f0da3a48a5a183ae109a00024ba666", "html_url": "https://github.com/rust-lang/rust/commit/a6ce402401f0da3a48a5a183ae109a00024ba666", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6ce402401f0da3a48a5a183ae109a00024ba666/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26f2867c2e5439156f40f18c5a828a5a94c4352a", "url": "https://api.github.com/repos/rust-lang/rust/commits/26f2867c2e5439156f40f18c5a828a5a94c4352a", "html_url": "https://github.com/rust-lang/rust/commit/26f2867c2e5439156f40f18c5a828a5a94c4352a"}, {"sha": "e7c1f57d6c8781cfb3e746eac5f13f760fcde2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c1f57d6c8781cfb3e746eac5f13f760fcde2b4", "html_url": "https://github.com/rust-lang/rust/commit/e7c1f57d6c8781cfb3e746eac5f13f760fcde2b4"}], "stats": {"total": 174, "additions": 143, "deletions": 31}, "files": [{"sha": "b2e4fc75cf2387bd7068589bd49bf487cdd6a0aa", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -32,7 +32,7 @@\n //!     ```rust\n //!     use std::io;\n //!\n-//!     for line in io::stdin().lines() {\n+//!     for line in io::stdin().lock().lines() {\n //!         print!(\"{}\", line.unwrap());\n //!     }\n //!     ```\n@@ -1413,10 +1413,10 @@ pub trait Buffer: Reader {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io;\n+    /// use std::io::BufReader;\n     ///\n-    /// let mut reader = io::stdin();\n-    /// let input = reader.read_line().ok().unwrap_or(\"nothing\".to_string());\n+    /// let mut reader = BufReader::new(b\"hello\\nworld\");\n+    /// assert_eq!(\"hello\\n\", &*reader.read_line().unwrap());\n     /// ```\n     ///\n     /// # Error"}, {"sha": "ad5dcf71df737e304ed1a3ef276d030324fbdb24", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 132, "deletions": 20, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -29,22 +29,27 @@ use self::StdSource::*;\n \n use boxed::Box;\n use cell::RefCell;\n+use clone::Clone;\n use failure::LOCAL_STDERR;\n use fmt;\n-use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n+use io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use kinds::Send;\n use libc;\n use mem;\n use option::{Option, Some, None};\n+use ops::{Deref, DerefMut};\n use result::{Ok, Err};\n use rustrt;\n use rustrt::local::Local;\n use rustrt::task::Task;\n use slice::SlicePrelude;\n use str::StrPrelude;\n+use string::String;\n use sys::{fs, tty};\n+use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n use uint;\n+use vec::Vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -90,28 +95,135 @@ thread_local!(static LOCAL_STDOUT: RefCell<Option<Box<Writer + Send>>> = {\n     RefCell::new(None)\n })\n \n-/// Creates a new non-blocking handle to the stdin of the current process.\n-///\n-/// The returned handled is buffered by default with a `BufferedReader`. If\n-/// buffered access is not desired, the `stdin_raw` function is provided to\n-/// provided unbuffered access to stdin.\n+/// A synchronized wrapper around a buffered reader from stdin\n+#[deriving(Clone)]\n+pub struct StdinReader {\n+    inner: Arc<Mutex<BufferedReader<StdReader>>>,\n+}\n+\n+/// A guard for exlusive access to `StdinReader`'s internal `BufferedReader`.\n+pub struct StdinReaderGuard<'a> {\n+    inner: MutexGuard<'a, BufferedReader<StdReader>>,\n+}\n+\n+impl<'a> Deref<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+    fn deref(&self) -> &BufferedReader<StdReader> {\n+        &*self.inner\n+    }\n+}\n+\n+impl<'a> DerefMut<BufferedReader<StdReader>> for StdinReaderGuard<'a> {\n+    fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> {\n+        &mut *self.inner\n+    }\n+}\n+\n+impl StdinReader {\n+    /// Locks the `StdinReader`, granting the calling thread exclusive access\n+    /// to the underlying `BufferedReader`.\n+    ///\n+    /// This provides access to methods like `chars` and `lines`.\n+    ///\n+    /// ## Example\n+    ///\n+    /// ```rust\n+    /// use std::io;\n+    ///\n+    /// for line in io::stdin().lock().lines() {\n+    ///     println!(\"{}\", line.unwrap());\n+    /// }\n+    /// ```\n+    pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> {\n+        StdinReaderGuard {\n+            inner: self.inner.lock()\n+        }\n+    }\n+\n+    /// Like `Buffer::read_line`.\n+    ///\n+    /// The read is performed atomically - concurrent read calls in other\n+    /// threads will not interleave with this one.\n+    pub fn read_line(&mut self) -> IoResult<String> {\n+        self.inner.lock().read_line()\n+    }\n+\n+    /// Like `Buffer::read_until`.\n+    ///\n+    /// The read is performed atomically - concurrent read calls in other\n+    /// threads will not interleave with this one.\n+    pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n+        self.inner.lock().read_until(byte)\n+    }\n+\n+    /// Like `Buffer::read_char`.\n+    ///\n+    /// The read is performed atomically - concurrent read calls in other\n+    /// threads will not interleave with this one.\n+    pub fn read_char(&mut self) -> IoResult<char> {\n+        self.inner.lock().read_char()\n+    }\n+}\n+\n+impl Reader for StdinReader {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        self.inner.lock().read(buf)\n+    }\n+\n+    // We have to manually delegate all of these because the default impls call\n+    // read more than once and we don't want those calls to interleave (or\n+    // incur the costs of repeated locking).\n+\n+    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n+        self.inner.lock().read_at_least(min, buf)\n+    }\n+\n+    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+        self.inner.lock().push_at_least(min, len, buf)\n+    }\n+\n+    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n+        self.inner.lock().read_to_end()\n+    }\n+\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+        self.inner.lock().read_le_uint_n(nbytes)\n+    }\n+\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+        self.inner.lock().read_be_uint_n(nbytes)\n+    }\n+}\n+\n+/// Creates a new handle to the stdin of the current process.\n ///\n-/// Care should be taken when creating multiple handles to the stdin of a\n-/// process. Because this is a buffered reader by default, it's possible for\n-/// pending input to be unconsumed in one reader and unavailable to other\n-/// readers. It is recommended that only one handle at a time is created for the\n-/// stdin of a process.\n+/// The returned handle is a wrapper around a global `BufferedReader` shared\n+/// by all threads. If buffered access is not desired, the `stdin_raw` function\n+/// is provided to provided unbuffered access to stdin.\n ///\n /// See `stdout()` for more notes about this function.\n-pub fn stdin() -> BufferedReader<StdReader> {\n-    // The default buffer capacity is 64k, but apparently windows doesn't like\n-    // 64k reads on stdin. See #13304 for details, but the idea is that on\n-    // windows we use a slightly smaller buffer that's been seen to be\n-    // acceptable.\n-    if cfg!(windows) {\n-        BufferedReader::with_capacity(8 * 1024, stdin_raw())\n-    } else {\n-        BufferedReader::new(stdin_raw())\n+pub fn stdin() -> StdinReader {\n+    // We're following the same strategy as kimundi's lazy_static library\n+    static mut STDIN: *const StdinReader = 0 as *const StdinReader;\n+    static ONCE: Once = ONCE_INIT;\n+\n+    unsafe {\n+        ONCE.doit(|| {\n+            // The default buffer capacity is 64k, but apparently windows doesn't like\n+            // 64k reads on stdin. See #13304 for details, but the idea is that on\n+            // windows we use a slightly smaller buffer that's been seen to be\n+            // acceptable.\n+            let stdin = if cfg!(windows) {\n+                BufferedReader::with_capacity(8 * 1024, stdin_raw())\n+            } else {\n+                BufferedReader::new(stdin_raw())\n+            };\n+            let stdin = StdinReader {\n+                inner: Arc::new(Mutex::new(stdin))\n+            };\n+            STDIN = mem::transmute(box stdin);\n+        });\n+\n+        (*STDIN).clone()\n     }\n }\n "}, {"sha": "8ed041513c47c45a2ef7006660ecba830c17832f", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -295,7 +295,7 @@ fn main() {\n         let fd = std::io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n         get_sequence(&mut std::io::BufferedReader::new(fd), \">THREE\")\n     } else {\n-        get_sequence(&mut std::io::stdin(), \">THREE\")\n+        get_sequence(&mut *std::io::stdin().lock(), \">THREE\")\n     };\n     let input = Arc::new(input);\n "}, {"sha": "c55f85f40e8b628b180c101af342108698e8214c", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -65,7 +65,7 @@ impl Sudoku {\n         return true;\n     }\n \n-    pub fn read(mut reader: BufferedReader<StdReader>) -> Sudoku {\n+    pub fn read(mut reader: &mut BufferedReader<StdReader>) -> Sudoku {\n         /* assert first line is exactly \"9,9\" */\n         assert!(reader.read_line().unwrap() == \"9,9\".to_string());\n \n@@ -284,7 +284,7 @@ fn main() {\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        Sudoku::read(io::stdin())\n+        Sudoku::read(&mut *io::stdin().lock())\n     };\n     sudoku.solve();\n     sudoku.write(&mut io::stdout());"}, {"sha": "daad1afedaaeae10308c5e52b1c4c24956d7c9d3", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     //~^ ERROR: cannot assign to immutable captured outer variable in a proc `x`\n \n     let s = std::io::stdin();\n-    proc() { s.lines(); };\n+    proc() { s.read_to_end(); };\n     //~^ ERROR: cannot borrow immutable captured outer variable in a proc `s` as mutable\n }"}, {"sha": "11003c6fc524de50a71f2e39331bef3168328261", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -37,7 +37,7 @@ fn parent() {\n }\n \n fn child() {\n-    for line in io::stdin().lines() {\n+    for line in io::stdin().lock().lines() {\n         println!(\"{}\", line.unwrap());\n     }\n }"}, {"sha": "f5fdf8704ed25ca888d624599e6379802c4228f6", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -27,7 +27,7 @@ fn main() {\n fn child() {\n     io::stdout().write_line(\"foo\").unwrap();\n     io::stderr().write_line(\"bar\").unwrap();\n-    assert_eq!(io::stdin().read_line().err().unwrap().kind, io::EndOfFile);\n+    assert_eq!(io::stdin().lock().read_line().err().unwrap().kind, io::EndOfFile);\n }\n \n fn test() {"}, {"sha": "27a97e1f172e36bd561713266b997edb5e4733dc", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ce402401f0da3a48a5a183ae109a00024ba666/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=a6ce402401f0da3a48a5a183ae109a00024ba666", "patch": "@@ -19,6 +19,6 @@\n pub fn main() {\n     let mut stdin = std::io::stdin();\n     spawn(proc() {\n-        let _ = stdin.lines();\n+        let _ = stdin.read_to_end();\n     });\n }"}]}