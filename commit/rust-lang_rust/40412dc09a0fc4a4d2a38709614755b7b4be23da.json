{"sha": "40412dc09a0fc4a4d2a38709614755b7b4be23da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNDEyZGMwOWEwZmM0YTRkMmEzODcwOTYxNDc1NWI3YjRiZTIzZGE=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-28T15:07:30Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-28T15:07:30Z"}, "message": "Deduplicate literal -> constant lowering", "tree": {"sha": "22b3a8d496db1b2b0e06f04c1bf331e00a261b9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22b3a8d496db1b2b0e06f04c1bf331e00a261b9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40412dc09a0fc4a4d2a38709614755b7b4be23da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40412dc09a0fc4a4d2a38709614755b7b4be23da", "html_url": "https://github.com/rust-lang/rust/commit/40412dc09a0fc4a4d2a38709614755b7b4be23da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40412dc09a0fc4a4d2a38709614755b7b4be23da/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b68fc18c45350e1cdcd83cecf0f12e294e55af56", "url": "https://api.github.com/repos/rust-lang/rust/commits/b68fc18c45350e1cdcd83cecf0f12e294e55af56", "html_url": "https://github.com/rust-lang/rust/commit/b68fc18c45350e1cdcd83cecf0f12e294e55af56"}], "stats": {"total": 158, "additions": 45, "deletions": 113}, "files": [{"sha": "ea1ec24c9914179d22015f5c505c45821a5a88a2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/40412dc09a0fc4a4d2a38709614755b7b4be23da/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40412dc09a0fc4a4d2a38709614755b7b4be23da/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=40412dc09a0fc4a4d2a38709614755b7b4be23da", "patch": "@@ -26,12 +26,12 @@ use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::layout::VariantIdx;\n-use syntax::ast::{self, LitKind};\n+use syntax::ast;\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n-use hair::pattern::parse_float;\n+use hair::pattern::{lit_to_const, LitToConstError};\n \n #[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -131,7 +131,6 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty::Const::from_bool(self.tcx, false)\n     }\n \n-    // FIXME: Combine with rustc_mir::hair::pattern::lit_to_const\n     pub fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n@@ -141,61 +140,19 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     ) -> &'tcx ty::Const<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n \n-        let parse_float = |num, fty| -> ConstValue<'tcx> {\n-            parse_float(num, fty, neg).unwrap_or_else(|_| {\n+        match lit_to_const(lit, self.tcx, ty, neg) {\n+            Ok(c) => c,\n+            Err(LitToConstError::UnparseableFloat) => {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n-                self.tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n-            })\n-        };\n-\n-        let trunc = |n| {\n-            let param_ty = self.param_env.and(self.tcx.lift_to_global(&ty).unwrap());\n-            let width = self.tcx.layout_of(param_ty).unwrap().size;\n-            trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n-            let shift = 128 - width.bits();\n-            let result = (n << shift) >> shift;\n-            trace!(\"trunc result: {}\", result);\n-            ConstValue::Scalar(Scalar::Bits {\n-                bits: result,\n-                size: width.bytes() as u8,\n-            })\n-        };\n-\n-        use rustc::mir::interpret::*;\n-        let lit = match *lit {\n-            LitKind::Str(ref s, _) => {\n-                let s = s.as_str();\n-                let id = self.tcx.allocate_bytes(s.as_bytes());\n-                ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, &self.tcx)\n-            },\n-            LitKind::ByteStr(ref data) => {\n-                let id = self.tcx.allocate_bytes(data);\n-                ConstValue::Scalar(Scalar::Ptr(id.into()))\n+                self.tcx.sess.span_err(sp, \"could not evaluate float literal (see issue #31407)\");\n+                // create a dummy value and continue compiling\n+                Const::from_bits(self.tcx, 0, self.param_env.and(ty))\n             },\n-            LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n-                bits: n as u128,\n-                size: 1,\n-            }),\n-            LitKind::Int(n, _) if neg => {\n-                let n = n as i128;\n-                let n = n.overflowing_neg().0;\n-                trunc(n as u128)\n-            },\n-            LitKind::Int(n, _) => trunc(n),\n-            LitKind::Float(n, fty) => {\n-                parse_float(n, fty)\n-            }\n-            LitKind::FloatUnsuffixed(n) => {\n-                let fty = match ty.sty {\n-                    ty::Float(fty) => fty,\n-                    _ => bug!()\n-                };\n-                parse_float(n, fty)\n+            Err(LitToConstError::Reported) => {\n+                // create a dummy value and continue compiling\n+                Const::from_bits(self.tcx, 0, self.param_env.and(ty))\n             }\n-            LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n-            LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n-        };\n-        ty::Const::from_const_value(self.tcx, lit, ty)\n+        }\n     }\n \n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {"}, {"sha": "deea03acf0c21cf9f8397f9e4951dbdb7b454ccd", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/40412dc09a0fc4a4d2a38709614755b7b4be23da/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40412dc09a0fc4a4d2a38709614755b7b4be23da/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=40412dc09a0fc4a4d2a38709614755b7b4be23da", "patch": "@@ -23,7 +23,7 @@ use hair::util::UserAnnotatedTyHelpers;\n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty};\n+use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, ParamEnv};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -891,12 +891,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n-                    Err(e) => {\n-                        if e == LitToConstError::UnparseableFloat {\n-                            self.errors.push(PatternError::FloatBug);\n-                        }\n+                    Err(LitToConstError::UnparseableFloat) => {\n+                        self.errors.push(PatternError::FloatBug);\n                         PatternKind::Wild\n                     },\n+                    Err(LitToConstError::Reported) => PatternKind::Wild,\n                 }\n             },\n             hir::ExprKind::Path(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n@@ -914,12 +913,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         );\n                         *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n                     },\n-                    Err(e) => {\n-                        if e == LitToConstError::UnparseableFloat {\n-                            self.errors.push(PatternError::FloatBug);\n-                        }\n+                    Err(LitToConstError::UnparseableFloat) => {\n+                        self.errors.push(PatternError::FloatBug);\n                         PatternKind::Wild\n                     },\n+                    Err(LitToConstError::Reported) => PatternKind::Wild,\n                 }\n             }\n             _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n@@ -1296,19 +1294,32 @@ pub fn compare_const_vals<'a, 'tcx>(\n }\n \n #[derive(PartialEq)]\n-enum LitToConstError {\n+pub enum LitToConstError {\n     UnparseableFloat,\n-    Propagated,\n+    Reported,\n }\n \n-// FIXME: Combine with rustc_mir::hair::cx::const_eval_literal\n-fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          neg: bool)\n-                          -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n+pub fn lit_to_const<'a, 'gcx, 'tcx>(\n+    lit: &'tcx ast::LitKind,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ty: Ty<'tcx>,\n+    neg: bool,\n+) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n     use syntax::ast::*;\n \n+    let trunc = |n| {\n+        let param_ty = ParamEnv::reveal_all().and(tcx.lift_to_global(&ty).unwrap());\n+        let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n+        trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n+        let shift = 128 - width.bits();\n+        let result = (n << shift) >> shift;\n+        trace!(\"trunc result: {}\", result);\n+        Ok(ConstValue::Scalar(Scalar::Bits {\n+            bits: result,\n+            size: width.bytes() as u8,\n+        }))\n+    };\n+\n     use rustc::mir::interpret::*;\n     let lit = match *lit {\n         LitKind::Str(ref s, _) => {\n@@ -1324,48 +1335,12 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n             bits: n as u128,\n             size: 1,\n         }),\n-        LitKind::Int(n, _) => {\n-            enum Int {\n-                Signed(IntTy),\n-                Unsigned(UintTy),\n-            }\n-            let ity = match ty.sty {\n-                ty::Int(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n-                ty::Int(other) => Int::Signed(other),\n-                ty::Uint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n-                ty::Uint(other) => Int::Unsigned(other),\n-                ty::Error => { // Avoid ICE (#51963)\n-                    return Err(LitToConstError::Propagated);\n-                }\n-                _ => bug!(\"literal integer type with bad type ({:?})\", ty.sty),\n-            };\n-            // This converts from LitKind::Int (which is sign extended) to\n-            // Scalar::Bytes (which is zero extended)\n-            let n = match ity {\n-                // FIXME(oli-obk): are these casts correct?\n-                Int::Signed(IntTy::I8) if neg =>\n-                    (n as i8).overflowing_neg().0 as u8 as u128,\n-                Int::Signed(IntTy::I16) if neg =>\n-                    (n as i16).overflowing_neg().0 as u16 as u128,\n-                Int::Signed(IntTy::I32) if neg =>\n-                    (n as i32).overflowing_neg().0 as u32 as u128,\n-                Int::Signed(IntTy::I64) if neg =>\n-                    (n as i64).overflowing_neg().0 as u64 as u128,\n-                Int::Signed(IntTy::I128) if neg =>\n-                    (n as i128).overflowing_neg().0 as u128,\n-                Int::Signed(IntTy::I8) | Int::Unsigned(UintTy::U8) => n as u8 as u128,\n-                Int::Signed(IntTy::I16) | Int::Unsigned(UintTy::U16) => n as u16 as u128,\n-                Int::Signed(IntTy::I32) | Int::Unsigned(UintTy::U32) => n as u32 as u128,\n-                Int::Signed(IntTy::I64) | Int::Unsigned(UintTy::U64) => n as u64 as u128,\n-                Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n-                _ => bug!(),\n-            };\n-            let size = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bytes() as u8;\n-            ConstValue::Scalar(Scalar::Bits {\n-                bits: n,\n-                size,\n-            })\n+        LitKind::Int(n, _) if neg => {\n+            let n = n as i128;\n+            let n = n.overflowing_neg().0;\n+            trunc(n as u128)?\n         },\n+        LitKind::Int(n, _) => trunc(n)?,\n         LitKind::Float(n, fty) => {\n             parse_float(n, fty, neg).map_err(|_| LitToConstError::UnparseableFloat)?\n         }"}]}