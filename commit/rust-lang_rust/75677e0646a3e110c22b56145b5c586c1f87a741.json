{"sha": "75677e0646a3e110c22b56145b5c586c1f87a741", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1Njc3ZTA2NDZhM2UxMTBjMjJiNTYxNDViNWM1ODZjMWY4N2E3NDE=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-08T02:04:46Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-09T23:07:26Z"}, "message": "Move arithmetic ops to module.", "tree": {"sha": "cf456af197250ad34a68742739b7ce5bfcfd5390", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf456af197250ad34a68742739b7ce5bfcfd5390"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75677e0646a3e110c22b56145b5c586c1f87a741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75677e0646a3e110c22b56145b5c586c1f87a741", "html_url": "https://github.com/rust-lang/rust/commit/75677e0646a3e110c22b56145b5c586c1f87a741", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75677e0646a3e110c22b56145b5c586c1f87a741/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9c8e99955c03c61b514cc870d1462029ef956ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c8e99955c03c61b514cc870d1462029ef956ff", "html_url": "https://github.com/rust-lang/rust/commit/b9c8e99955c03c61b514cc870d1462029ef956ff"}], "stats": {"total": 1744, "additions": 880, "deletions": 864}, "files": [{"sha": "c6fb75f6acefc8bce4a6b2eb815e18ff92f8708a", "filename": "src/libcore/ops/arith.rs", "status": "added", "additions": 873, "deletions": 0, "changes": 873, "blob_url": "https://github.com/rust-lang/rust/blob/75677e0646a3e110c22b56145b5c586c1f87a741/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75677e0646a3e110c22b56145b5c586c1f87a741/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=75677e0646a3e110c22b56145b5c586c1f87a741", "patch": "@@ -0,0 +1,873 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The addition operator `+`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `Add` trait, and\n+/// then demonstrates adding two `Point`s.\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl Add for Point {\n+///     type Output = Point;\n+///\n+///     fn add(self, other: Point) -> Point {\n+///         Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///                Point { x: 3, y: 3 });\n+/// }\n+/// ```\n+///\n+/// Here is an example of the same `Point` struct implementing the `Add` trait\n+/// using generics.\n+///\n+/// ```\n+/// use std::ops::Add;\n+///\n+/// #[derive(Debug)]\n+/// struct Point<T> {\n+///     x: T,\n+///     y: T,\n+/// }\n+///\n+/// // Notice that the implementation uses the `Output` associated type\n+/// impl<T: Add<Output=T>> Add for Point<T> {\n+///     type Output = Point<T>;\n+///\n+///     fn add(self, other: Point<T>) -> Point<T> {\n+///         Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl<T: PartialEq> PartialEq for Point<T> {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///                Point { x: 3, y: 3 });\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime + Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n+#[lang = \"add\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\n+pub trait Add<RHS=Self> {\n+    /// The resulting type after applying the `+` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `+` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! add_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Add for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn add(self, other: $t) -> $t { self + other }\n+        }\n+\n+        forward_ref_binop! { impl Add, add for $t, $t }\n+    )*)\n+}\n+\n+add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The subtraction operator `-`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `Sub` trait, and\n+/// then demonstrates subtracting two `Point`s.\n+///\n+/// ```\n+/// use std::ops::Sub;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl Sub for Point {\n+///     type Output = Point;\n+///\n+///     fn sub(self, other: Point) -> Point {\n+///         Point {\n+///             x: self.x - other.x,\n+///             y: self.y - other.y,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n+///                Point { x: 1, y: 0 });\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime - Duration`.\n+///\n+/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n+#[lang = \"sub\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\n+pub trait Sub<RHS=Self> {\n+    /// The resulting type after applying the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn sub(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! sub_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Sub for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn sub(self, other: $t) -> $t { self - other }\n+        }\n+\n+        forward_ref_binop! { impl Sub, sub for $t, $t }\n+    )*)\n+}\n+\n+sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The multiplication operator `*`.\n+///\n+/// # Examples\n+///\n+/// Implementing a `Mul`tipliable rational number struct:\n+///\n+/// ```\n+/// use std::ops::Mul;\n+///\n+/// // The uniqueness of rational numbers in lowest terms is a consequence of\n+/// // the fundamental theorem of arithmetic.\n+/// #[derive(Eq)]\n+/// #[derive(PartialEq, Debug)]\n+/// struct Rational {\n+///     nominator: usize,\n+///     denominator: usize,\n+/// }\n+///\n+/// impl Rational {\n+///     fn new(nominator: usize, denominator: usize) -> Self {\n+///         if denominator == 0 {\n+///             panic!(\"Zero is an invalid denominator!\");\n+///         }\n+///\n+///         // Reduce to lowest terms by dividing by the greatest common\n+///         // divisor.\n+///         let gcd = gcd(nominator, denominator);\n+///         Rational {\n+///             nominator: nominator / gcd,\n+///             denominator: denominator / gcd,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl Mul for Rational {\n+///     // The multiplication of rational numbers is a closed operation.\n+///     type Output = Self;\n+///\n+///     fn mul(self, rhs: Self) -> Self {\n+///         let nominator = self.nominator * rhs.nominator;\n+///         let denominator = self.denominator * rhs.denominator;\n+///         Rational::new(nominator, denominator)\n+///     }\n+/// }\n+///\n+/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n+/// // divisor.\n+/// fn gcd(x: usize, y: usize) -> usize {\n+///     let mut x = x;\n+///     let mut y = y;\n+///     while y != 0 {\n+///         let t = y;\n+///         y = x % y;\n+///         x = t;\n+///     }\n+///     x\n+/// }\n+///\n+/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+/// assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n+///            Rational::new(1, 2));\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n+/// implementation which enables multiplication of vectors by scalars, as is\n+/// done in linear algebra.\n+///\n+/// ```\n+/// use std::ops::Mul;\n+///\n+/// struct Scalar {value: usize};\n+///\n+/// #[derive(Debug)]\n+/// struct Vector {value: Vec<usize>};\n+///\n+/// impl Mul<Vector> for Scalar {\n+///     type Output = Vector;\n+///\n+///     fn mul(self, rhs: Vector) -> Vector {\n+///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n+///     }\n+/// }\n+///\n+/// impl PartialEq<Vector> for Vector {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.value == other.value\n+///     }\n+/// }\n+///\n+/// let scalar = Scalar{value: 3};\n+/// let vector = Vector{value: vec![2, 4, 6]};\n+/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n+/// ```\n+#[lang = \"mul\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\n+pub trait Mul<RHS=Self> {\n+    /// The resulting type after applying the `*` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `*` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn mul(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! mul_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Mul for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn mul(self, other: $t) -> $t { self * other }\n+        }\n+\n+        forward_ref_binop! { impl Mul, mul for $t, $t }\n+    )*)\n+}\n+\n+mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The division operator `/`.\n+///\n+/// # Examples\n+///\n+/// Implementing a `Div`idable rational number struct:\n+///\n+/// ```\n+/// use std::ops::Div;\n+///\n+/// // The uniqueness of rational numbers in lowest terms is a consequence of\n+/// // the fundamental theorem of arithmetic.\n+/// #[derive(Eq)]\n+/// #[derive(PartialEq, Debug)]\n+/// struct Rational {\n+///     nominator: usize,\n+///     denominator: usize,\n+/// }\n+///\n+/// impl Rational {\n+///     fn new(nominator: usize, denominator: usize) -> Self {\n+///         if denominator == 0 {\n+///             panic!(\"Zero is an invalid denominator!\");\n+///         }\n+///\n+///         // Reduce to lowest terms by dividing by the greatest common\n+///         // divisor.\n+///         let gcd = gcd(nominator, denominator);\n+///         Rational {\n+///             nominator: nominator / gcd,\n+///             denominator: denominator / gcd,\n+///         }\n+///     }\n+/// }\n+///\n+/// impl Div for Rational {\n+///     // The division of rational numbers is a closed operation.\n+///     type Output = Self;\n+///\n+///     fn div(self, rhs: Self) -> Self {\n+///         if rhs.nominator == 0 {\n+///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n+///         }\n+///\n+///         let nominator = self.nominator * rhs.denominator;\n+///         let denominator = self.denominator * rhs.nominator;\n+///         Rational::new(nominator, denominator)\n+///     }\n+/// }\n+///\n+/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n+/// // divisor.\n+/// fn gcd(x: usize, y: usize) -> usize {\n+///     let mut x = x;\n+///     let mut y = y;\n+///     while y != 0 {\n+///         let t = y;\n+///         y = x % y;\n+///         x = t;\n+///     }\n+///     x\n+/// }\n+///\n+/// fn main() {\n+///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n+///                Rational::new(2, 3));\n+/// }\n+/// ```\n+///\n+/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n+/// implementation which enables division of vectors by scalars, as is done in\n+/// linear algebra.\n+///\n+/// ```\n+/// use std::ops::Div;\n+///\n+/// struct Scalar {value: f32};\n+///\n+/// #[derive(Debug)]\n+/// struct Vector {value: Vec<f32>};\n+///\n+/// impl Div<Scalar> for Vector {\n+///     type Output = Vector;\n+///\n+///     fn div(self, rhs: Scalar) -> Vector {\n+///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n+///     }\n+/// }\n+///\n+/// impl PartialEq<Vector> for Vector {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.value == other.value\n+///     }\n+/// }\n+///\n+/// let scalar = Scalar{value: 2f32};\n+/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n+/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n+/// ```\n+#[lang = \"div\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\n+pub trait Div<RHS=Self> {\n+    /// The resulting type after applying the `/` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the `/` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn div(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! div_impl_integer {\n+    ($($t:ty)*) => ($(\n+        /// This operation rounds towards zero, truncating any\n+        /// fractional part of the exact result.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Div for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n+    )*)\n+}\n+\n+div_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! div_impl_float {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Div for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn div(self, other: $t) -> $t { self / other }\n+        }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n+    )*)\n+}\n+\n+div_impl_float! { f32 f64 }\n+\n+/// The remainder operator `%`.\n+///\n+/// # Examples\n+///\n+/// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n+/// implemented, one can use the `%` operator to find out what the remaining\n+/// elements of the slice would be after splitting it into equal slices of a\n+/// given length.\n+///\n+/// ```\n+/// use std::ops::Rem;\n+///\n+/// #[derive(PartialEq, Debug)]\n+/// struct SplitSlice<'a, T: 'a> {\n+///     slice: &'a [T],\n+/// }\n+///\n+/// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n+///     type Output = SplitSlice<'a, T>;\n+///\n+///     fn rem(self, modulus: usize) -> Self {\n+///         let len = self.slice.len();\n+///         let rem = len % modulus;\n+///         let start = len - rem;\n+///         SplitSlice {slice: &self.slice[start..]}\n+///     }\n+/// }\n+///\n+/// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n+/// // the remainder would be &[6, 7]\n+/// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n+///            SplitSlice { slice: &[6, 7] });\n+/// ```\n+#[lang = \"rem\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\n+pub trait Rem<RHS=Self> {\n+    /// The resulting type after applying the `%` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output = Self;\n+\n+    /// The method for the `%` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn rem(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! rem_impl_integer {\n+    ($($t:ty)*) => ($(\n+        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// result has the same sign as the left operand.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Rem for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    )*)\n+}\n+\n+rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+\n+macro_rules! rem_impl_float {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Rem for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            fn rem(self, other: $t) -> $t { self % other }\n+        }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n+    )*)\n+}\n+\n+rem_impl_float! { f32 f64 }\n+\n+/// The unary negation operator `-`.\n+///\n+/// # Examples\n+///\n+/// An implementation of `Neg` for `Sign`, which allows the use of `-` to\n+/// negate its value.\n+///\n+/// ```\n+/// use std::ops::Neg;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Sign {\n+///     Negative,\n+///     Zero,\n+///     Positive,\n+/// }\n+///\n+/// impl Neg for Sign {\n+///     type Output = Sign;\n+///\n+///     fn neg(self) -> Sign {\n+///         match self {\n+///             Sign::Negative => Sign::Positive,\n+///             Sign::Zero => Sign::Zero,\n+///             Sign::Positive => Sign::Negative,\n+///         }\n+///     }\n+/// }\n+///\n+/// // a negative positive is a negative\n+/// assert_eq!(-Sign::Positive, Sign::Negative);\n+/// // a double negative is a positive\n+/// assert_eq!(-Sign::Negative, Sign::Positive);\n+/// // zero is its own negation\n+/// assert_eq!(-Sign::Zero, Sign::Zero);\n+/// ```\n+#[lang = \"neg\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Neg {\n+    /// The resulting type after applying the `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    type Output;\n+\n+    /// The method for the unary `-` operator\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn neg(self) -> Self::Output;\n+}\n+\n+\n+\n+macro_rules! neg_impl_core {\n+    ($id:ident => $body:expr, $($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Neg for $t {\n+            type Output = $t;\n+\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn neg(self) -> $t { let $id = self; $body }\n+        }\n+\n+        forward_ref_unop! { impl Neg, neg for $t }\n+    )*)\n+}\n+\n+macro_rules! neg_impl_numeric {\n+    ($($t:ty)*) => { neg_impl_core!{ x => -x, $($t)*} }\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! neg_impl_unsigned {\n+    ($($t:ty)*) => {\n+        neg_impl_core!{ x => {\n+            !x.wrapping_add(1)\n+        }, $($t)*} }\n+}\n+\n+// neg_impl_unsigned! { usize u8 u16 u32 u64 }\n+neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The addition assignment operator `+=`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `AddAssign`\n+/// trait, and then demonstrates add-assigning to a mutable `Point`.\n+///\n+/// ```\n+/// use std::ops::AddAssign;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl AddAssign for Point {\n+///     fn add_assign(&mut self, other: Point) {\n+///         *self = Point {\n+///             x: self.x + other.x,\n+///             y: self.y + other.y,\n+///         };\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// let mut point = Point { x: 1, y: 0 };\n+/// point += Point { x: 2, y: 3 };\n+/// assert_eq!(point, Point { x: 3, y: 3 });\n+/// ```\n+#[lang = \"add_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\n+pub trait AddAssign<Rhs=Self> {\n+    /// The method for the `+=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn add_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! add_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl AddAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn add_assign(&mut self, other: $t) { *self += other }\n+        }\n+    )+)\n+}\n+\n+add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The subtraction assignment operator `-=`.\n+///\n+/// # Examples\n+///\n+/// This example creates a `Point` struct that implements the `SubAssign`\n+/// trait, and then demonstrates sub-assigning to a mutable `Point`.\n+///\n+/// ```\n+/// use std::ops::SubAssign;\n+///\n+/// #[derive(Debug)]\n+/// struct Point {\n+///     x: i32,\n+///     y: i32,\n+/// }\n+///\n+/// impl SubAssign for Point {\n+///     fn sub_assign(&mut self, other: Point) {\n+///         *self = Point {\n+///             x: self.x - other.x,\n+///             y: self.y - other.y,\n+///         };\n+///     }\n+/// }\n+///\n+/// impl PartialEq for Point {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.x == other.x && self.y == other.y\n+///     }\n+/// }\n+///\n+/// let mut point = Point { x: 3, y: 3 };\n+/// point -= Point { x: 2, y: 3 };\n+/// assert_eq!(point, Point {x: 1, y: 0});\n+/// ```\n+#[lang = \"sub_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\n+pub trait SubAssign<Rhs=Self> {\n+    /// The method for the `-=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn sub_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! sub_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl SubAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn sub_assign(&mut self, other: $t) { *self -= other }\n+        }\n+    )+)\n+}\n+\n+sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The multiplication assignment operator `*=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n+/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n+///\n+/// ```\n+/// use std::ops::MulAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl MulAssign for Foo {\n+///     fn mul_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Multiplying!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo *= Foo;\n+/// }\n+/// ```\n+#[lang = \"mul_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\n+pub trait MulAssign<Rhs=Self> {\n+    /// The method for the `*=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn mul_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! mul_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl MulAssign for $t {\n+            #[inline]\n+            #[rustc_inherit_overflow_checks]\n+            fn mul_assign(&mut self, other: $t) { *self *= other }\n+        }\n+    )+)\n+}\n+\n+mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The division assignment operator `/=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n+/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n+///\n+/// ```\n+/// use std::ops::DivAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl DivAssign for Foo {\n+///     fn div_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Dividing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo /= Foo;\n+/// }\n+/// ```\n+#[lang = \"div_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\n+pub trait DivAssign<Rhs=Self> {\n+    /// The method for the `/=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn div_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! div_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl DivAssign for $t {\n+            #[inline]\n+            fn div_assign(&mut self, other: $t) { *self /= other }\n+        }\n+    )+)\n+}\n+\n+div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n+\n+/// The remainder assignment operator `%=`.\n+///\n+/// # Examples\n+///\n+/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n+/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n+///\n+/// ```\n+/// use std::ops::RemAssign;\n+///\n+/// struct Foo;\n+///\n+/// impl RemAssign for Foo {\n+///     fn rem_assign(&mut self, _rhs: Foo) {\n+///         println!(\"Remainder-ing!\");\n+///     }\n+/// }\n+///\n+/// # #[allow(unused_assignments)]\n+/// fn main() {\n+///     let mut foo = Foo;\n+///     foo %= Foo;\n+/// }\n+/// ```\n+#[lang = \"rem_assign\"]\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+#[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\n+pub trait RemAssign<Rhs=Self> {\n+    /// The method for the `%=` operator\n+    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+    fn rem_assign(&mut self, rhs: Rhs);\n+}\n+\n+macro_rules! rem_assign_impl {\n+    ($($t:ty)+) => ($(\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl RemAssign for $t {\n+            #[inline]\n+            fn rem_assign(&mut self, other: $t) { *self %= other }\n+        }\n+    )+)\n+}\n+\n+rem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }"}, {"sha": "7d10c35d5e0bf158bea194e2690eebff994aae33", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 7, "deletions": 864, "changes": 871, "blob_url": "https://github.com/rust-lang/rust/blob/75677e0646a3e110c22b56145b5c586c1f87a741/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75677e0646a3e110c22b56145b5c586c1f87a741/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=75677e0646a3e110c22b56145b5c586c1f87a741", "patch": "@@ -147,9 +147,16 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod arith;\n mod function;\n mod range;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n+\n+#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::function::{Fn, FnMut, FnOnce};\n \n@@ -251,620 +258,6 @@ pub trait Drop {\n     fn drop(&mut self);\n }\n \n-/// The addition operator `+`.\n-///\n-/// # Examples\n-///\n-/// This example creates a `Point` struct that implements the `Add` trait, and\n-/// then demonstrates adding two `Point`s.\n-///\n-/// ```\n-/// use std::ops::Add;\n-///\n-/// #[derive(Debug)]\n-/// struct Point {\n-///     x: i32,\n-///     y: i32,\n-/// }\n-///\n-/// impl Add for Point {\n-///     type Output = Point;\n-///\n-///     fn add(self, other: Point) -> Point {\n-///         Point {\n-///             x: self.x + other.x,\n-///             y: self.y + other.y,\n-///         }\n-///     }\n-/// }\n-///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n-/// ```\n-///\n-/// Here is an example of the same `Point` struct implementing the `Add` trait\n-/// using generics.\n-///\n-/// ```\n-/// use std::ops::Add;\n-///\n-/// #[derive(Debug)]\n-/// struct Point<T> {\n-///     x: T,\n-///     y: T,\n-/// }\n-///\n-/// // Notice that the implementation uses the `Output` associated type\n-/// impl<T: Add<Output=T>> Add for Point<T> {\n-///     type Output = Point<T>;\n-///\n-///     fn add(self, other: Point<T>) -> Point<T> {\n-///         Point {\n-///             x: self.x + other.x,\n-///             y: self.y + other.y,\n-///         }\n-///     }\n-/// }\n-///\n-/// impl<T: PartialEq> PartialEq for Point<T> {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n-/// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime + Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n-#[lang = \"add\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\n-pub trait Add<RHS=Self> {\n-    /// The resulting type after applying the `+` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `+` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn add(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! add_impl {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Add for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn add(self, other: $t) -> $t { self + other }\n-        }\n-\n-        forward_ref_binop! { impl Add, add for $t, $t }\n-    )*)\n-}\n-\n-add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n-/// The subtraction operator `-`.\n-///\n-/// # Examples\n-///\n-/// This example creates a `Point` struct that implements the `Sub` trait, and\n-/// then demonstrates subtracting two `Point`s.\n-///\n-/// ```\n-/// use std::ops::Sub;\n-///\n-/// #[derive(Debug)]\n-/// struct Point {\n-///     x: i32,\n-///     y: i32,\n-/// }\n-///\n-/// impl Sub for Point {\n-///     type Output = Point;\n-///\n-///     fn sub(self, other: Point) -> Point {\n-///         Point {\n-///             x: self.x - other.x,\n-///             y: self.y - other.y,\n-///         }\n-///     }\n-/// }\n-///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n-///                Point { x: 1, y: 0 });\n-/// }\n-/// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime - Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n-#[lang = \"sub\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\n-pub trait Sub<RHS=Self> {\n-    /// The resulting type after applying the `-` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `-` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn sub(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! sub_impl {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Sub for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn sub(self, other: $t) -> $t { self - other }\n-        }\n-\n-        forward_ref_binop! { impl Sub, sub for $t, $t }\n-    )*)\n-}\n-\n-sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n-/// The multiplication operator `*`.\n-///\n-/// # Examples\n-///\n-/// Implementing a `Mul`tipliable rational number struct:\n-///\n-/// ```\n-/// use std::ops::Mul;\n-///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n-/// struct Rational {\n-///     nominator: usize,\n-///     denominator: usize,\n-/// }\n-///\n-/// impl Rational {\n-///     fn new(nominator: usize, denominator: usize) -> Self {\n-///         if denominator == 0 {\n-///             panic!(\"Zero is an invalid denominator!\");\n-///         }\n-///\n-///         // Reduce to lowest terms by dividing by the greatest common\n-///         // divisor.\n-///         let gcd = gcd(nominator, denominator);\n-///         Rational {\n-///             nominator: nominator / gcd,\n-///             denominator: denominator / gcd,\n-///         }\n-///     }\n-/// }\n-///\n-/// impl Mul for Rational {\n-///     // The multiplication of rational numbers is a closed operation.\n-///     type Output = Self;\n-///\n-///     fn mul(self, rhs: Self) -> Self {\n-///         let nominator = self.nominator * rhs.nominator;\n-///         let denominator = self.denominator * rhs.denominator;\n-///         Rational::new(nominator, denominator)\n-///     }\n-/// }\n-///\n-/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n-/// // divisor.\n-/// fn gcd(x: usize, y: usize) -> usize {\n-///     let mut x = x;\n-///     let mut y = y;\n-///     while y != 0 {\n-///         let t = y;\n-///         y = x % y;\n-///         x = t;\n-///     }\n-///     x\n-/// }\n-///\n-/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n-/// assert_eq!(Rational::new(2, 3) * Rational::new(3, 4),\n-///            Rational::new(1, 2));\n-/// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables multiplication of vectors by scalars, as is\n-/// done in linear algebra.\n-///\n-/// ```\n-/// use std::ops::Mul;\n-///\n-/// struct Scalar {value: usize};\n-///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<usize>};\n-///\n-/// impl Mul<Vector> for Scalar {\n-///     type Output = Vector;\n-///\n-///     fn mul(self, rhs: Vector) -> Vector {\n-///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n-///     }\n-/// }\n-///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n-///     }\n-/// }\n-///\n-/// let scalar = Scalar{value: 3};\n-/// let vector = Vector{value: vec![2, 4, 6]};\n-/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n-/// ```\n-#[lang = \"mul\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\n-pub trait Mul<RHS=Self> {\n-    /// The resulting type after applying the `*` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `*` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn mul(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! mul_impl {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Mul for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn mul(self, other: $t) -> $t { self * other }\n-        }\n-\n-        forward_ref_binop! { impl Mul, mul for $t, $t }\n-    )*)\n-}\n-\n-mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n-/// The division operator `/`.\n-///\n-/// # Examples\n-///\n-/// Implementing a `Div`idable rational number struct:\n-///\n-/// ```\n-/// use std::ops::Div;\n-///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n-/// struct Rational {\n-///     nominator: usize,\n-///     denominator: usize,\n-/// }\n-///\n-/// impl Rational {\n-///     fn new(nominator: usize, denominator: usize) -> Self {\n-///         if denominator == 0 {\n-///             panic!(\"Zero is an invalid denominator!\");\n-///         }\n-///\n-///         // Reduce to lowest terms by dividing by the greatest common\n-///         // divisor.\n-///         let gcd = gcd(nominator, denominator);\n-///         Rational {\n-///             nominator: nominator / gcd,\n-///             denominator: denominator / gcd,\n-///         }\n-///     }\n-/// }\n-///\n-/// impl Div for Rational {\n-///     // The division of rational numbers is a closed operation.\n-///     type Output = Self;\n-///\n-///     fn div(self, rhs: Self) -> Self {\n-///         if rhs.nominator == 0 {\n-///             panic!(\"Cannot divide by zero-valued `Rational`!\");\n-///         }\n-///\n-///         let nominator = self.nominator * rhs.denominator;\n-///         let denominator = self.denominator * rhs.nominator;\n-///         Rational::new(nominator, denominator)\n-///     }\n-/// }\n-///\n-/// // Euclid's two-thousand-year-old algorithm for finding the greatest common\n-/// // divisor.\n-/// fn gcd(x: usize, y: usize) -> usize {\n-///     let mut x = x;\n-///     let mut y = y;\n-///     while y != 0 {\n-///         let t = y;\n-///         y = x % y;\n-///         x = t;\n-///     }\n-///     x\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n-///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n-///                Rational::new(2, 3));\n-/// }\n-/// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables division of vectors by scalars, as is done in\n-/// linear algebra.\n-///\n-/// ```\n-/// use std::ops::Div;\n-///\n-/// struct Scalar {value: f32};\n-///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<f32>};\n-///\n-/// impl Div<Scalar> for Vector {\n-///     type Output = Vector;\n-///\n-///     fn div(self, rhs: Scalar) -> Vector {\n-///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n-///     }\n-/// }\n-///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n-///     }\n-/// }\n-///\n-/// let scalar = Scalar{value: 2f32};\n-/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n-/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n-/// ```\n-#[lang = \"div\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\n-pub trait Div<RHS=Self> {\n-    /// The resulting type after applying the `/` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the `/` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn div(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! div_impl_integer {\n-    ($($t:ty)*) => ($(\n-        /// This operation rounds towards zero, truncating any\n-        /// fractional part of the exact result.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Div for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn div(self, other: $t) -> $t { self / other }\n-        }\n-\n-        forward_ref_binop! { impl Div, div for $t, $t }\n-    )*)\n-}\n-\n-div_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-macro_rules! div_impl_float {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Div for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn div(self, other: $t) -> $t { self / other }\n-        }\n-\n-        forward_ref_binop! { impl Div, div for $t, $t }\n-    )*)\n-}\n-\n-div_impl_float! { f32 f64 }\n-\n-/// The remainder operator `%`.\n-///\n-/// # Examples\n-///\n-/// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n-/// implemented, one can use the `%` operator to find out what the remaining\n-/// elements of the slice would be after splitting it into equal slices of a\n-/// given length.\n-///\n-/// ```\n-/// use std::ops::Rem;\n-///\n-/// #[derive(PartialEq, Debug)]\n-/// struct SplitSlice<'a, T: 'a> {\n-///     slice: &'a [T],\n-/// }\n-///\n-/// impl<'a, T> Rem<usize> for SplitSlice<'a, T> {\n-///     type Output = SplitSlice<'a, T>;\n-///\n-///     fn rem(self, modulus: usize) -> Self {\n-///         let len = self.slice.len();\n-///         let rem = len % modulus;\n-///         let start = len - rem;\n-///         SplitSlice {slice: &self.slice[start..]}\n-///     }\n-/// }\n-///\n-/// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n-/// // the remainder would be &[6, 7]\n-/// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n-///            SplitSlice { slice: &[6, 7] });\n-/// ```\n-#[lang = \"rem\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\n-pub trait Rem<RHS=Self> {\n-    /// The resulting type after applying the `%` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output = Self;\n-\n-    /// The method for the `%` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rem(self, rhs: RHS) -> Self::Output;\n-}\n-\n-macro_rules! rem_impl_integer {\n-    ($($t:ty)*) => ($(\n-        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n-        /// result has the same sign as the left operand.\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Rem for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn rem(self, other: $t) -> $t { self % other }\n-        }\n-\n-        forward_ref_binop! { impl Rem, rem for $t, $t }\n-    )*)\n-}\n-\n-rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-\n-\n-macro_rules! rem_impl_float {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Rem for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            fn rem(self, other: $t) -> $t { self % other }\n-        }\n-\n-        forward_ref_binop! { impl Rem, rem for $t, $t }\n-    )*)\n-}\n-\n-rem_impl_float! { f32 f64 }\n-\n-/// The unary negation operator `-`.\n-///\n-/// # Examples\n-///\n-/// An implementation of `Neg` for `Sign`, which allows the use of `-` to\n-/// negate its value.\n-///\n-/// ```\n-/// use std::ops::Neg;\n-///\n-/// #[derive(Debug, PartialEq)]\n-/// enum Sign {\n-///     Negative,\n-///     Zero,\n-///     Positive,\n-/// }\n-///\n-/// impl Neg for Sign {\n-///     type Output = Sign;\n-///\n-///     fn neg(self) -> Sign {\n-///         match self {\n-///             Sign::Negative => Sign::Positive,\n-///             Sign::Zero => Sign::Zero,\n-///             Sign::Positive => Sign::Negative,\n-///         }\n-///     }\n-/// }\n-///\n-/// // a negative positive is a negative\n-/// assert_eq!(-Sign::Positive, Sign::Negative);\n-/// // a double negative is a positive\n-/// assert_eq!(-Sign::Negative, Sign::Positive);\n-/// // zero is its own negation\n-/// assert_eq!(-Sign::Zero, Sign::Zero);\n-/// ```\n-#[lang = \"neg\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Neg {\n-    /// The resulting type after applying the `-` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    type Output;\n-\n-    /// The method for the unary `-` operator\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn neg(self) -> Self::Output;\n-}\n-\n-\n-\n-macro_rules! neg_impl_core {\n-    ($id:ident => $body:expr, $($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Neg for $t {\n-            type Output = $t;\n-\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn neg(self) -> $t { let $id = self; $body }\n-        }\n-\n-        forward_ref_unop! { impl Neg, neg for $t }\n-    )*)\n-}\n-\n-macro_rules! neg_impl_numeric {\n-    ($($t:ty)*) => { neg_impl_core!{ x => -x, $($t)*} }\n-}\n-\n-#[allow(unused_macros)]\n-macro_rules! neg_impl_unsigned {\n-    ($($t:ty)*) => {\n-        neg_impl_core!{ x => {\n-            !x.wrapping_add(1)\n-        }, $($t)*} }\n-}\n-\n-// neg_impl_unsigned! { usize u8 u16 u32 u64 }\n-neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n-\n /// The unary logical negation operator `!`.\n ///\n /// # Examples\n@@ -1386,256 +779,6 @@ macro_rules! shr_impl_all {\n \n shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n \n-/// The addition assignment operator `+=`.\n-///\n-/// # Examples\n-///\n-/// This example creates a `Point` struct that implements the `AddAssign`\n-/// trait, and then demonstrates add-assigning to a mutable `Point`.\n-///\n-/// ```\n-/// use std::ops::AddAssign;\n-///\n-/// #[derive(Debug)]\n-/// struct Point {\n-///     x: i32,\n-///     y: i32,\n-/// }\n-///\n-/// impl AddAssign for Point {\n-///     fn add_assign(&mut self, other: Point) {\n-///         *self = Point {\n-///             x: self.x + other.x,\n-///             y: self.y + other.y,\n-///         };\n-///     }\n-/// }\n-///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// let mut point = Point { x: 1, y: 0 };\n-/// point += Point { x: 2, y: 3 };\n-/// assert_eq!(point, Point { x: 3, y: 3 });\n-/// ```\n-#[lang = \"add_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\n-pub trait AddAssign<Rhs=Self> {\n-    /// The method for the `+=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn add_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! add_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl AddAssign for $t {\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn add_assign(&mut self, other: $t) { *self += other }\n-        }\n-    )+)\n-}\n-\n-add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n-/// The subtraction assignment operator `-=`.\n-///\n-/// # Examples\n-///\n-/// This example creates a `Point` struct that implements the `SubAssign`\n-/// trait, and then demonstrates sub-assigning to a mutable `Point`.\n-///\n-/// ```\n-/// use std::ops::SubAssign;\n-///\n-/// #[derive(Debug)]\n-/// struct Point {\n-///     x: i32,\n-///     y: i32,\n-/// }\n-///\n-/// impl SubAssign for Point {\n-///     fn sub_assign(&mut self, other: Point) {\n-///         *self = Point {\n-///             x: self.x - other.x,\n-///             y: self.y - other.y,\n-///         };\n-///     }\n-/// }\n-///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// let mut point = Point { x: 3, y: 3 };\n-/// point -= Point { x: 2, y: 3 };\n-/// assert_eq!(point, Point {x: 1, y: 0});\n-/// ```\n-#[lang = \"sub_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\n-pub trait SubAssign<Rhs=Self> {\n-    /// The method for the `-=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn sub_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! sub_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl SubAssign for $t {\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn sub_assign(&mut self, other: $t) { *self -= other }\n-        }\n-    )+)\n-}\n-\n-sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n-/// The multiplication assignment operator `*=`.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n-/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n-///\n-/// ```\n-/// use std::ops::MulAssign;\n-///\n-/// struct Foo;\n-///\n-/// impl MulAssign for Foo {\n-///     fn mul_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Multiplying!\");\n-///     }\n-/// }\n-///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo *= Foo;\n-/// }\n-/// ```\n-#[lang = \"mul_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\n-pub trait MulAssign<Rhs=Self> {\n-    /// The method for the `*=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn mul_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! mul_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl MulAssign for $t {\n-            #[inline]\n-            #[rustc_inherit_overflow_checks]\n-            fn mul_assign(&mut self, other: $t) { *self *= other }\n-        }\n-    )+)\n-}\n-\n-mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n-/// The division assignment operator `/=`.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n-/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n-///\n-/// ```\n-/// use std::ops::DivAssign;\n-///\n-/// struct Foo;\n-///\n-/// impl DivAssign for Foo {\n-///     fn div_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Dividing!\");\n-///     }\n-/// }\n-///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo /= Foo;\n-/// }\n-/// ```\n-#[lang = \"div_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\n-pub trait DivAssign<Rhs=Self> {\n-    /// The method for the `/=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn div_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! div_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl DivAssign for $t {\n-            #[inline]\n-            fn div_assign(&mut self, other: $t) { *self /= other }\n-        }\n-    )+)\n-}\n-\n-div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n-/// The remainder assignment operator `%=`.\n-///\n-/// # Examples\n-///\n-/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n-/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n-///\n-/// ```\n-/// use std::ops::RemAssign;\n-///\n-/// struct Foo;\n-///\n-/// impl RemAssign for Foo {\n-///     fn rem_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Remainder-ing!\");\n-///     }\n-/// }\n-///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo %= Foo;\n-/// }\n-/// ```\n-#[lang = \"rem_assign\"]\n-#[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-#[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\n-pub trait RemAssign<Rhs=Self> {\n-    /// The method for the `%=` operator\n-    #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-    fn rem_assign(&mut self, rhs: Rhs);\n-}\n-\n-macro_rules! rem_assign_impl {\n-    ($($t:ty)+) => ($(\n-        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n-        impl RemAssign for $t {\n-            #[inline]\n-            fn rem_assign(&mut self, other: $t) { *self %= other }\n-        }\n-    )+)\n-}\n-\n-rem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-\n /// The bitwise AND assignment operator `&=`.\n ///\n /// # Examples"}]}