{"sha": "21dd71f51460eb791dc5f938ad4b02b76c6c8520", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZGQ3MWY1MTQ2MGViNzkxZGM1ZjkzOGFkNGIwMmI3NmM2Yzg1MjA=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-23T14:21:24Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-05-23T16:20:51Z"}, "message": "incr.comp.: Track expanded spans instead of FileMaps.", "tree": {"sha": "6cd80b9b430f114ec14229cea7b7c3082a909350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cd80b9b430f114ec14229cea7b7c3082a909350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21dd71f51460eb791dc5f938ad4b02b76c6c8520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21dd71f51460eb791dc5f938ad4b02b76c6c8520", "html_url": "https://github.com/rust-lang/rust/commit/21dd71f51460eb791dc5f938ad4b02b76c6c8520", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21dd71f51460eb791dc5f938ad4b02b76c6c8520/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b13bff5203c1bdc6ac6dc87f69b5359a9503078", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b13bff5203c1bdc6ac6dc87f69b5359a9503078", "html_url": "https://github.com/rust-lang/rust/commit/5b13bff5203c1bdc6ac6dc87f69b5359a9503078"}], "stats": {"total": 217, "additions": 78, "deletions": 139}, "files": [{"sha": "38ad473e4042fc015fdf2881acb4c74612c87178", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -176,7 +176,6 @@ pub enum DepNode<D: Clone + Debug> {\n     IsMirAvailable(D),\n     ItemAttrs(D),\n     FnArgNames(D),\n-    FileMap(D, Arc<String>),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -307,7 +306,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             ConstIsRvaluePromotableToStatic(ref d) => op(d).map(ConstIsRvaluePromotableToStatic),\n             IsMirAvailable(ref d) => op(d).map(IsMirAvailable),\n             GlobalMetaData(ref d, kind) => op(d).map(|d| GlobalMetaData(d, kind)),\n-            FileMap(ref d, ref file_name) => op(d).map(|d| FileMap(d, file_name.clone())),\n         }\n     }\n }"}, {"sha": "9aecd8ad83602cf515c565a7dd243aa2e0b01778", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -8,11 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::{DepGraph, DepNode};\n-use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n-use rustc_data_structures::bitvec::BitVector;\n use std::rc::Rc;\n-use std::sync::Arc;\n use syntax::codemap::CodeMap;\n use syntax_pos::{BytePos, FileMap};\n use ty::TyCtxt;\n@@ -31,14 +27,12 @@ pub struct CachingCodemapView<'tcx> {\n     codemap: &'tcx CodeMap,\n     line_cache: [CacheEntry; 3],\n     time_stamp: usize,\n-    dep_graph: DepGraph,\n-    dep_tracking_reads: BitVector,\n }\n \n impl<'tcx> CachingCodemapView<'tcx> {\n     pub fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachingCodemapView<'tcx> {\n         let codemap = tcx.sess.codemap();\n-        let files = codemap.files_untracked();\n+        let files = codemap.files();\n         let first_file = files[0].clone();\n         let entry = CacheEntry {\n             time_stamp: 0,\n@@ -50,11 +44,9 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         };\n \n         CachingCodemapView {\n-            dep_graph: tcx.dep_graph.clone(),\n             codemap: codemap,\n             line_cache: [entry.clone(), entry.clone(), entry.clone()],\n             time_stamp: 0,\n-            dep_tracking_reads: BitVector::new(files.len()),\n         }\n     }\n \n@@ -67,9 +59,6 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         for cache_entry in self.line_cache.iter_mut() {\n             if pos >= cache_entry.line_start && pos < cache_entry.line_end {\n                 cache_entry.time_stamp = self.time_stamp;\n-                if self.dep_tracking_reads.insert(cache_entry.file_index) {\n-                    self.dep_graph.read(dep_node(cache_entry));\n-                }\n \n                 return Some((cache_entry.file.clone(),\n                              cache_entry.line_number,\n@@ -90,7 +79,7 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         // If the entry doesn't point to the correct file, fix it up\n         if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n             let file_valid;\n-            let files = self.codemap.files_untracked();\n+            let files = self.codemap.files();\n \n             if files.len() > 0 {\n                 let file_index = self.codemap.lookup_filemap_idx(pos);\n@@ -120,21 +109,8 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         cache_entry.line_end = line_bounds.1;\n         cache_entry.time_stamp = self.time_stamp;\n \n-        if self.dep_tracking_reads.insert(cache_entry.file_index) {\n-            self.dep_graph.read(dep_node(cache_entry));\n-        }\n-\n         return Some((cache_entry.file.clone(),\n                      cache_entry.line_number,\n                      pos - cache_entry.line_start));\n     }\n }\n-\n-fn dep_node(cache_entry: &CacheEntry) -> DepNode<DefId> {\n-    let def_id = DefId {\n-        krate: CrateNum::from_u32(cache_entry.file.crate_of_origin),\n-        index: CRATE_DEF_INDEX,\n-    };\n-    let name = Arc::new(cache_entry.file.name.clone());\n-    DepNode::FileMap(def_id, name)\n-}"}, {"sha": "f8dddc42e48ccf8d1c2d2e044f38711f83b83546", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -74,6 +74,11 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n         }\n     }\n \n+    pub fn force_span_hashing(mut self) -> Self {\n+        self.hash_spans = true;\n+        self\n+    }\n+\n     #[inline]\n     pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self,\n                                                           hash_bodies: bool,"}, {"sha": "d523d40ccd4ab691512e5bf1dbb54b55bf452a8e", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -22,11 +22,55 @@ impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n-impl_stable_hash_for!(struct mir::LocalDecl<'tcx> { mutability, ty, name, source_info,\n-is_user_variable});\n+impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n+    mutability,\n+    ty,\n+    name,\n+    source_info,\n+    is_user_variable\n+});\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n-impl_stable_hash_for!(struct mir::Terminator<'tcx> { source_info, kind });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Terminator<'tcx> {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mir::Terminator {\n+            ref kind,\n+            ref source_info,\n+        } = *self;\n+\n+        let hash_spans_unconditionally = match *kind {\n+            mir::TerminatorKind::Assert { .. } => {\n+                // Assert terminators generate a panic message that contains the\n+                // source location, so we always have to feed its span into the\n+                // ICH.\n+                true\n+            }\n+            mir::TerminatorKind::Goto { .. } |\n+            mir::TerminatorKind::SwitchInt { .. } |\n+            mir::TerminatorKind::Resume |\n+            mir::TerminatorKind::Return |\n+            mir::TerminatorKind::Unreachable |\n+            mir::TerminatorKind::Drop { .. } |\n+            mir::TerminatorKind::DropAndReplace { .. } |\n+            mir::TerminatorKind::Call { .. } => false,\n+        };\n+\n+        if hash_spans_unconditionally {\n+            hcx.while_hashing_spans(true, |hcx| {\n+                source_info.hash_stable(hcx, hasher);\n+            })\n+        } else {\n+            source_info.hash_stable(hcx, hasher);\n+        }\n+\n+        kind.hash_stable(hcx, hasher);\n+    }\n+}\n+\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for mir::Local {\n     #[inline]"}, {"sha": "28531893659e61f05bb291ccd26e177f6ca4d9e3", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -11,8 +11,9 @@\n pub use self::code_stats::{CodeStats, DataTypeKind, FieldInfo};\n pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n \n-use dep_graph::{DepGraph, DepNode};\n-use hir::def_id::{DefId, CrateNum, DefIndex, CRATE_DEF_INDEX};\n+use dep_graph::DepGraph;\n+use hir::def_id::{CrateNum, DefIndex};\n+\n use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n@@ -32,7 +33,7 @@ use syntax::parse::ParseSess;\n use syntax::symbol::Symbol;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n-use syntax_pos::{Span, MultiSpan, FileMap};\n+use syntax_pos::{Span, MultiSpan};\n \n use rustc_back::{LinkerFlavor, PanicStrategy};\n use rustc_back::target::Target;\n@@ -46,7 +47,6 @@ use std::io::Write;\n use std::rc::Rc;\n use std::fmt;\n use std::time::Duration;\n-use std::sync::Arc;\n \n mod code_stats;\n pub mod config;\n@@ -626,21 +626,6 @@ pub fn build_session_(sopts: config::Options,\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n-    // Hook up the codemap with a callback that allows it to register FileMap\n-    // accesses with the dependency graph.\n-    let cm_depgraph = dep_graph.clone();\n-    let codemap_dep_tracking_callback = Box::new(move |filemap: &FileMap| {\n-        let def_id = DefId {\n-            krate: CrateNum::from_u32(filemap.crate_of_origin),\n-            index: CRATE_DEF_INDEX,\n-        };\n-        let name = Arc::new(filemap.name.clone());\n-        let dep_node = DepNode::FileMap(def_id, name);\n-\n-        cm_depgraph.read(dep_node);\n-    });\n-    codemap.set_dep_tracking_callback(codemap_dep_tracking_callback);\n-\n     let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,"}, {"sha": "f5727aa0a5ecc4be364e23c0fbcbfe27571c45dc", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -29,10 +29,9 @@\n \n use std::cell::RefCell;\n use std::hash::Hash;\n-use std::sync::Arc;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n-use rustc::hir::def_id::{LOCAL_CRATE, CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n@@ -155,11 +154,6 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                         // We want to incoporate these into the\n                                         // SVH.\n                                     }\n-                                    DepNode::FileMap(..) => {\n-                                        // These don't make a semantic\n-                                        // difference, filter them out.\n-                                        return None\n-                                    }\n                                     DepNode::AllLocalTraitImpls => {\n                                         // These are already covered by hashing\n                                         // the HIR.\n@@ -306,24 +300,6 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n             visitor.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, macro_def);\n         }\n \n-        for filemap in tcx.sess\n-                          .codemap()\n-                          .files_untracked()\n-                          .iter()\n-                          .filter(|fm| !fm.is_imported()) {\n-            assert_eq!(LOCAL_CRATE.as_u32(), filemap.crate_of_origin);\n-            let def_id = DefId {\n-                krate: LOCAL_CRATE,\n-                index: CRATE_DEF_INDEX,\n-            };\n-            let name = Arc::new(filemap.name.clone());\n-            let dep_node = DepNode::FileMap(def_id, name);\n-            let mut hasher = IchHasher::new();\n-            filemap.hash_stable(&mut visitor.hcx, &mut hasher);\n-            let fingerprint = hasher.finish();\n-            visitor.hashes.insert(dep_node, fingerprint);\n-        }\n-\n         visitor.compute_and_store_ich_for_trait_impls(krate);\n     });\n "}, {"sha": "6ab280be470dd329794c0c6b536d06af67f6b211", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -51,8 +51,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         match *dep_node {\n             DepNode::Krate |\n             DepNode::Hir(_) |\n-            DepNode::HirBody(_) |\n-            DepNode::FileMap(..) =>\n+            DepNode::HirBody(_) =>\n                 true,\n             DepNode::MetaData(def_id) |\n             DepNode::GlobalMetaData(def_id, _) => !def_id.is_local(),\n@@ -77,20 +76,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n \n-            DepNode::FileMap(def_id, ref name) => {\n-                if def_id.is_local() {\n-                    // We will have been able to retrace the DefId (which is\n-                    // always the local CRATE_DEF_INDEX), but the file with the\n-                    // given name might have been removed, so we use get() in\n-                    // order to allow for that case.\n-                    self.incremental_hashes_map.get(dep_node).map(|x| *x)\n-                } else {\n-                    Some(self.metadata_hash(DepNode::FileMap(def_id, name.clone()),\n-                                            def_id.krate,\n-                                            |this| &mut this.global_metadata_hashes))\n-                }\n-            }\n-\n             // MetaData from other crates is an *input* to us.\n             // MetaData nodes from *our* crates are an *output*; we\n             // don't hash them, but we do compute a hash for them and\n@@ -242,7 +227,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n             let dep_node = match dep_node {\n                 DepNode::GlobalMetaData(_, kind) => DepNode::GlobalMetaData(def_id, kind),\n-                DepNode::FileMap(_, name) => DepNode::FileMap(def_id, name),\n                 other => {\n                     bug!(\"unexpected DepNode variant: {:?}\", other)\n                 }"}, {"sha": "317b14e4ad27d301c50761f9034c59146b9b2413", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n-use rustc::ich::{StableHashingContext, Fingerprint};\n+use rustc::ich::Fingerprint;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -29,15 +29,13 @@ use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n \n use std::hash::Hash;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::path::Path;\n use std::rc::Rc;\n-use std::sync::Arc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n@@ -284,7 +282,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let codemap = self.tcx.sess.codemap();\n         let all_filemaps = codemap.files();\n \n-        let hcx = &mut StableHashingContext::new(self.tcx);\n         let (working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir.clone();\n \n         let adapted = all_filemaps.iter()\n@@ -316,21 +313,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     adapted.name = abs_path;\n                     Rc::new(adapted)\n                 }\n-            });\n-\n-        let filemaps: Vec<_> = if self.compute_ich {\n-            adapted.inspect(|filemap| {\n-                let mut hasher = StableHasher::new();\n-                filemap.hash_stable(hcx, &mut hasher);\n-                let fingerprint = hasher.finish();\n-                let dep_node = DepNode::FileMap((), Arc::new(filemap.name.clone()));\n-                self.metadata_hashes.global_hashes.push((dep_node, fingerprint));\n-            }).collect()\n-        } else {\n-            adapted.collect()\n-        };\n+            })\n+            .collect::<Vec<_>>();\n \n-        self.lazy_seq_ref(filemaps.iter().map(|fm| &**fm))\n+        self.lazy_seq_ref(adapted.iter().map(|rc| &**rc))\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {"}, {"sha": "ed1680fbfaee86e76084891fd33c574f31e4e1d6", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -35,7 +35,17 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             tcx: tcx,\n             ecx: ecx,\n             hcx: if compute_ich {\n-                Some((StableHashingContext::new(tcx), StableHasher::new()))\n+                // We are always hashing spans for things in metadata because\n+                // don't know if a downstream crate will use them or not.\n+                // Except when -Zquery-dep-graph is specified because we don't\n+                // want to mess up our tests.\n+                let hcx = if tcx.sess.opts.debugging_opts.query_dep_graph {\n+                    StableHashingContext::new(tcx)\n+                } else {\n+                    StableHashingContext::new(tcx).force_span_hashing()\n+                };\n+\n+                Some((hcx, StableHasher::new()))\n             } else {\n                 None\n             }"}, {"sha": "bbe5bd4a10cf17c4fe026f92bd9aae0c66053f70", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -103,18 +103,11 @@ impl FileLoader for RealFileLoader {\n //\n \n pub struct CodeMap {\n-    // The `files` field should not be visible outside of libsyntax so that we\n-    // can do proper dependency tracking.\n     pub(super) files: RefCell<Vec<Rc<FileMap>>>,\n     file_loader: Box<FileLoader>,\n     // This is used to apply the file path remapping as specified via\n     // -Zremap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n-    // The CodeMap will invoke this callback whenever a specific FileMap is\n-    // accessed. The callback starts out as a no-op but when the dependency\n-    // graph becomes available later during the compilation process, it is\n-    // be replaced with something that notifies the dep-tracking system.\n-    dep_tracking_callback: RefCell<Box<Fn(&FileMap)>>,\n }\n \n impl CodeMap {\n@@ -123,7 +116,6 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader: Box::new(RealFileLoader),\n             path_mapping: path_mapping,\n-            dep_tracking_callback: RefCell::new(Box::new(|_| {})),\n         }\n     }\n \n@@ -134,18 +126,13 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader: file_loader,\n             path_mapping: path_mapping,\n-            dep_tracking_callback: RefCell::new(Box::new(|_| {})),\n         }\n     }\n \n     pub fn path_mapping(&self) -> &FilePathMapping {\n         &self.path_mapping\n     }\n \n-    pub fn set_dep_tracking_callback(&self, cb: Box<Fn(&FileMap)>) {\n-        *self.dep_tracking_callback.borrow_mut() = cb;\n-    }\n-\n     pub fn file_exists(&self, path: &Path) -> bool {\n         self.file_loader.file_exists(path)\n     }\n@@ -156,15 +143,6 @@ impl CodeMap {\n     }\n \n     pub fn files(&self) -> Ref<Vec<Rc<FileMap>>> {\n-        let files = self.files.borrow();\n-        for file in files.iter() {\n-            (self.dep_tracking_callback.borrow())(file);\n-        }\n-        files\n-    }\n-\n-    /// Only use this if you do your own dependency tracking!\n-    pub fn files_untracked(&self) -> Ref<Vec<Rc<FileMap>>> {\n         self.files.borrow()\n     }\n \n@@ -311,8 +289,6 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n \n-        (self.dep_tracking_callback.borrow())(&f);\n-\n         match f.lookup_line(pos) {\n             Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n             None => Err(f)\n@@ -502,7 +478,6 @@ impl CodeMap {\n     pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {\n-               (self.dep_tracking_callback.borrow())(fm);\n                 return Some(fm.clone());\n             }\n         }\n@@ -513,7 +488,6 @@ impl CodeMap {\n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = (*self.files.borrow())[idx].clone();\n-        (self.dep_tracking_callback.borrow())(&fm);\n         let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n@@ -524,8 +498,6 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let map = &(*files)[idx];\n \n-        (self.dep_tracking_callback.borrow())(map);\n-\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n "}, {"sha": "1099aeb921763383da47b8feec0ac81d3889d61a", "filename": "src/test/incremental/rlib_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // no-prefer-dynamic\n+// compile-flags: -Z query-dep-graph\n \n #![crate_type=\"rlib\"]\n "}, {"sha": "2ae434071f2c5f1dfeceb1e640839cba847fd7b4", "filename": "src/test/incremental/type_alias_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21dd71f51460eb791dc5f938ad4b02b76c6c8520/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs?ref=21dd71f51460eb791dc5f938ad4b02b76c6c8520", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z query-dep-graph\n+\n #![crate_type=\"rlib\"]\n \n #[cfg(rpass1)]"}]}