{"sha": "45832b990c7f291abe578dff3c460f4a1232f024", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ODMyYjk5MGM3ZjI5MWFiZTU3OGRmZjNjNDYwZjRhMTIzMmYwMjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-25T19:30:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-25T19:30:04Z"}, "message": "Merge #4145\n\n4145: Remove dead code r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "82a7e9ea1e7599d4ddb77d1f79f961c9bbaef298", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82a7e9ea1e7599d4ddb77d1f79f961c9bbaef298"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45832b990c7f291abe578dff3c460f4a1232f024", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJepI+8CRBK7hj4Ov3rIwAAdHIIAKLE8tRFvDmolG5d5UpxuIw0\nEEqLGWdWT6/12CCvp5K5X51UP6fHyInG/ZMC0lohwMR+B3JPe0+MDhQ7/LCCv3lC\nNhJ6ZlkGB967kAGBy+mi1wiZaEUKE7aCqPQWajJQHMZmDSDkQSv2SU1fbaIMP+/L\n4c1BDWed9xbzAbladBpFDOymZaWLdiWNykW8m8g3frLme95A2f+Cljj4H89eZ4MA\nCeeD0FYCsG/V4e/i2pDOsjyZCmQ1Pm18AuI6gfbxW4q84/Yn8Mh8sZqwaRM65tJD\nycf7kExBCDimCGrF1bh0LShVzz+33QHkhPu7O8FxXkexXfKUg3x0NzX9GCe8StQ=\n=aaRW\n-----END PGP SIGNATURE-----\n", "payload": "tree 82a7e9ea1e7599d4ddb77d1f79f961c9bbaef298\nparent 7021352dc2668c17fb5a05a3fed68c3da6656b97\nparent 0ac5ed5a84799e52770cdd5edf0b8c099c3c0421\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1587843004 +0000\ncommitter GitHub <noreply@github.com> 1587843004 +0000\n\nMerge #4145\n\n4145: Remove dead code r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45832b990c7f291abe578dff3c460f4a1232f024", "html_url": "https://github.com/rust-lang/rust/commit/45832b990c7f291abe578dff3c460f4a1232f024", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45832b990c7f291abe578dff3c460f4a1232f024/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7021352dc2668c17fb5a05a3fed68c3da6656b97", "url": "https://api.github.com/repos/rust-lang/rust/commits/7021352dc2668c17fb5a05a3fed68c3da6656b97", "html_url": "https://github.com/rust-lang/rust/commit/7021352dc2668c17fb5a05a3fed68c3da6656b97"}, {"sha": "0ac5ed5a84799e52770cdd5edf0b8c099c3c0421", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac5ed5a84799e52770cdd5edf0b8c099c3c0421", "html_url": "https://github.com/rust-lang/rust/commit/0ac5ed5a84799e52770cdd5edf0b8c099c3c0421"}], "stats": {"total": 773, "additions": 346, "deletions": 427}, "files": [{"sha": "367ff3f82812ec0449a44c2dea7d7e683a515c82", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -1139,6 +1139,7 @@ dependencies = [\n  \"jemalloc-ctl\",\n  \"jemallocator\",\n  \"once_cell\",\n+ \"ra_arena\",\n ]\n \n [[package]]"}, {"sha": "441fbb3cbeffb8c83e6a075cf79a88fc07957280", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -96,6 +96,9 @@ impl<T> Arena<T> {\n     pub const fn new() -> Arena<T> {\n         Arena { data: Vec::new() }\n     }\n+    pub fn clear(&mut self) {\n+        self.data.clear();\n+    }\n \n     pub fn len(&self) -> usize {\n         self.data.len()"}, {"sha": "bd4ef69a079a252c3fc3caf35f1af7a46367006f", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -667,7 +667,7 @@ impl Expectation {\n }\n \n mod diagnostics {\n-    use hir_def::{expr::ExprId, src::HasSource, FunctionId, Lookup};\n+    use hir_def::{expr::ExprId, FunctionId};\n     use hir_expand::diagnostics::DiagnosticSink;\n \n     use crate::{db::HirDatabase, diagnostics::NoSuchField};\n@@ -686,10 +686,9 @@ mod diagnostics {\n         ) {\n             match self {\n                 InferenceDiagnostic::NoSuchField { expr, field } => {\n-                    let source = owner.lookup(db.upcast()).source(db.upcast());\n                     let (_, source_map) = db.body_with_source_map(owner.into());\n                     let field = source_map.field_syntax(*expr, *field);\n-                    sink.push(NoSuchField { file: source.file_id, field: field.value })\n+                    sink.push(NoSuchField { file: field.file_id, field: field.value })\n                 }\n             }\n         }"}, {"sha": "c33b5121ae267f619c2026adfa76b64463158707", "filename": "crates/ra_prof/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2FCargo.toml?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -9,6 +9,7 @@ publish = false\n doctest = false\n \n [dependencies]\n+ra_arena = { path = \"../ra_arena\" }\n once_cell = \"1.3.1\"\n backtrace = { version = \"0.3.44\", optional = true }\n "}, {"sha": "2b8a903636ca645c512940deb3ad77628862e7f8", "filename": "crates/ra_prof/src/hprof.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2Fsrc%2Fhprof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Fhprof.rs?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -0,0 +1,246 @@\n+//! Simple hierarchical profiler\n+use once_cell::sync::Lazy;\n+use std::{\n+    cell::RefCell,\n+    collections::{BTreeMap, HashSet},\n+    io::{stderr, Write},\n+    sync::{\n+        atomic::{AtomicBool, Ordering},\n+        RwLock,\n+    },\n+    time::{Duration, Instant},\n+};\n+\n+use crate::tree::{Idx, Tree};\n+\n+/// Filtering syntax\n+/// env RA_PROFILE=*             // dump everything\n+/// env RA_PROFILE=foo|bar|baz   // enabled only selected entries\n+/// env RA_PROFILE=*@3>10        // dump everything, up to depth 3, if it takes more than 10 ms\n+pub fn init() {\n+    let spec = std::env::var(\"RA_PROFILE\").unwrap_or_default();\n+    init_from(&spec);\n+}\n+\n+pub fn init_from(spec: &str) {\n+    let filter = if spec.is_empty() { Filter::disabled() } else { Filter::from_spec(spec) };\n+    filter.install();\n+}\n+\n+pub type Label = &'static str;\n+\n+/// This function starts a profiling scope in the current execution stack with a given description.\n+/// It returns a Profile structure and measure elapsed time between this method invocation and Profile structure drop.\n+/// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n+/// Profiling information is being printed in the stderr.\n+///\n+/// # Example\n+/// ```\n+/// use ra_prof::{profile, set_filter, Filter};\n+///\n+/// let f = Filter::from_spec(\"profile1|profile2@2\");\n+/// set_filter(f);\n+/// profiling_function1();\n+///\n+/// fn profiling_function1() {\n+///     let _p = profile(\"profile1\");\n+///     profiling_function2();\n+/// }\n+///\n+/// fn profiling_function2() {\n+///     let _p = profile(\"profile2\");\n+/// }\n+/// ```\n+/// This will print in the stderr the following:\n+/// ```text\n+///  0ms - profile\n+///      0ms - profile2\n+/// ```\n+pub fn profile(label: Label) -> Profiler {\n+    assert!(!label.is_empty());\n+    let enabled = PROFILING_ENABLED.load(Ordering::Relaxed)\n+        && PROFILE_STACK.with(|stack| stack.borrow_mut().push(label));\n+    let label = if enabled { Some(label) } else { None };\n+    Profiler { label, detail: None }\n+}\n+\n+pub struct Profiler {\n+    label: Option<Label>,\n+    detail: Option<String>,\n+}\n+\n+impl Profiler {\n+    pub fn detail(mut self, detail: impl FnOnce() -> String) -> Profiler {\n+        if self.label.is_some() {\n+            self.detail = Some(detail())\n+        }\n+        self\n+    }\n+}\n+\n+impl Drop for Profiler {\n+    fn drop(&mut self) {\n+        match self {\n+            Profiler { label: Some(label), detail } => {\n+                PROFILE_STACK.with(|stack| {\n+                    stack.borrow_mut().pop(label, detail.take());\n+                });\n+            }\n+            Profiler { label: None, .. } => (),\n+        }\n+    }\n+}\n+\n+static PROFILING_ENABLED: AtomicBool = AtomicBool::new(false);\n+static FILTER: Lazy<RwLock<Filter>> = Lazy::new(Default::default);\n+thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n+\n+#[derive(Default, Clone, Debug)]\n+struct Filter {\n+    depth: usize,\n+    allowed: HashSet<String>,\n+    longer_than: Duration,\n+    version: usize,\n+}\n+\n+impl Filter {\n+    fn disabled() -> Filter {\n+        Filter::default()\n+    }\n+\n+    fn from_spec(mut spec: &str) -> Filter {\n+        let longer_than = if let Some(idx) = spec.rfind('>') {\n+            let longer_than = spec[idx + 1..].parse().expect(\"invalid profile longer_than\");\n+            spec = &spec[..idx];\n+            Duration::from_millis(longer_than)\n+        } else {\n+            Duration::new(0, 0)\n+        };\n+\n+        let depth = if let Some(idx) = spec.rfind('@') {\n+            let depth: usize = spec[idx + 1..].parse().expect(\"invalid profile depth\");\n+            spec = &spec[..idx];\n+            depth\n+        } else {\n+            999\n+        };\n+        let allowed =\n+            if spec == \"*\" { HashSet::new() } else { spec.split('|').map(String::from).collect() };\n+        Filter { depth, allowed, longer_than, version: 0 }\n+    }\n+\n+    fn install(mut self) {\n+        PROFILING_ENABLED.store(self.depth > 0, Ordering::SeqCst);\n+        let mut old = FILTER.write().unwrap();\n+        self.version = old.version + 1;\n+        *old = self;\n+    }\n+}\n+\n+struct ProfileStack {\n+    starts: Vec<Instant>,\n+    filter: Filter,\n+    messages: Tree<Message>,\n+}\n+\n+#[derive(Default)]\n+struct Message {\n+    duration: Duration,\n+    label: Label,\n+    detail: Option<String>,\n+}\n+\n+impl ProfileStack {\n+    fn new() -> ProfileStack {\n+        ProfileStack { starts: Vec::new(), messages: Tree::default(), filter: Default::default() }\n+    }\n+\n+    fn push(&mut self, label: Label) -> bool {\n+        if self.starts.is_empty() {\n+            if let Ok(f) = FILTER.try_read() {\n+                if f.version > self.filter.version {\n+                    self.filter = f.clone();\n+                }\n+            };\n+        }\n+        if self.starts.len() > self.filter.depth {\n+            return false;\n+        }\n+        let allowed = &self.filter.allowed;\n+        if self.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n+            return false;\n+        }\n+\n+        self.starts.push(Instant::now());\n+        self.messages.start();\n+        true\n+    }\n+\n+    pub fn pop(&mut self, label: Label, detail: Option<String>) {\n+        let start = self.starts.pop().unwrap();\n+        let duration = start.elapsed();\n+        let level = self.starts.len();\n+        self.messages.finish(Message { duration, label, detail });\n+        if level == 0 {\n+            let longer_than = self.filter.longer_than;\n+            // Convert to millis for comparison to avoid problems with rounding\n+            // (otherwise we could print `0ms` despite user's `>0` filter when\n+            // `duration` is just a few nanos).\n+            if duration.as_millis() > longer_than.as_millis() {\n+                let stderr = stderr();\n+                if let Some(root) = self.messages.root() {\n+                    print(&self.messages, root, 0, longer_than, &mut stderr.lock());\n+                }\n+            }\n+            self.messages.clear();\n+            assert!(self.starts.is_empty())\n+        }\n+    }\n+}\n+\n+fn print(\n+    tree: &Tree<Message>,\n+    curr: Idx<Message>,\n+    level: u32,\n+    longer_than: Duration,\n+    out: &mut impl Write,\n+) {\n+    let current_indent = \"    \".repeat(level as usize);\n+    let detail = tree[curr].detail.as_ref().map(|it| format!(\" @ {}\", it)).unwrap_or_default();\n+    writeln!(\n+        out,\n+        \"{}{:5}ms - {}{}\",\n+        current_indent,\n+        tree[curr].duration.as_millis(),\n+        tree[curr].label,\n+        detail,\n+    )\n+    .expect(\"printing profiling info\");\n+\n+    let mut accounted_for = Duration::default();\n+    let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n+    for child in tree.children(curr) {\n+        accounted_for += tree[child].duration;\n+\n+        if tree[child].duration.as_millis() > longer_than.as_millis() {\n+            print(tree, child, level + 1, longer_than, out)\n+        } else {\n+            let (total_duration, cnt) =\n+                short_children.entry(tree[child].label).or_insert((Duration::default(), 0));\n+            *total_duration += tree[child].duration;\n+            *cnt += 1;\n+        }\n+    }\n+\n+    for (child_msg, (duration, count)) in short_children.iter() {\n+        let millis = duration.as_millis();\n+        writeln!(out, \"    {}{:5}ms - {} ({} calls)\", current_indent, millis, child_msg, count)\n+            .expect(\"printing profiling info\");\n+    }\n+\n+    let unaccounted = tree[curr].duration - accounted_for;\n+    if tree.children(curr).next().is_some() && unaccounted > longer_than {\n+        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted.as_millis())\n+            .expect(\"printing profiling info\");\n+    }\n+}"}, {"sha": "89df7f04b7f90dbbbf62064ca710e636ffa7ce84", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 8, "deletions": 390, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -1,323 +1,24 @@\n-//! FIXME: write short doc here\n+//! A collection of tools for profiling rust-analyzer.\n \n mod memory_usage;\n #[cfg(feature = \"cpu_profiler\")]\n mod google_cpu_profiler;\n+mod hprof;\n+mod tree;\n \n-use std::{\n-    cell::RefCell,\n-    collections::BTreeMap,\n-    collections::HashSet,\n-    io::{stderr, Write},\n-    sync::{\n-        atomic::{AtomicBool, Ordering},\n-        RwLock,\n-    },\n-    time::{Duration, Instant},\n-};\n-\n-use once_cell::sync::Lazy;\n+use std::cell::RefCell;\n \n-pub use crate::memory_usage::{Bytes, MemoryUsage};\n+pub use crate::{\n+    hprof::{init, init_from, profile},\n+    memory_usage::{Bytes, MemoryUsage},\n+};\n \n // We use jemalloc mainly to get heap usage statistics, actual performance\n // difference is not measures.\n #[cfg(all(feature = \"jemalloc\", not(target_env = \"msvc\")))]\n #[global_allocator]\n static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n \n-pub fn init() {\n-    set_filter(match std::env::var(\"RA_PROFILE\") {\n-        Ok(spec) => Filter::from_spec(&spec),\n-        Err(_) => Filter::disabled(),\n-    });\n-}\n-\n-/// Set profiling filter. It specifies descriptions allowed to profile.\n-/// This is helpful when call stack has too many nested profiling scopes.\n-/// Additionally filter can specify maximum depth of profiling scopes nesting.\n-///\n-/// #Example\n-/// ```\n-/// use ra_prof::{set_filter, Filter};\n-/// let f = Filter::from_spec(\"profile1|profile2@2\");\n-/// set_filter(f);\n-/// ```\n-pub fn set_filter(f: Filter) {\n-    PROFILING_ENABLED.store(f.depth > 0, Ordering::SeqCst);\n-    let set: HashSet<_> = f.allowed.iter().cloned().collect();\n-    let mut old = FILTER.write().unwrap();\n-    let filter_data = FilterData {\n-        depth: f.depth,\n-        allowed: set,\n-        longer_than: f.longer_than,\n-        version: old.version + 1,\n-    };\n-    *old = filter_data;\n-}\n-\n-pub type Label = &'static str;\n-\n-/// This function starts a profiling scope in the current execution stack with a given description.\n-/// It returns a Profile structure and measure elapsed time between this method invocation and Profile structure drop.\n-/// It supports nested profiling scopes in case when this function invoked multiple times at the execution stack. In this case the profiling information will be nested at the output.\n-/// Profiling information is being printed in the stderr.\n-///\n-/// # Example\n-/// ```\n-/// use ra_prof::{profile, set_filter, Filter};\n-///\n-/// let f = Filter::from_spec(\"profile1|profile2@2\");\n-/// set_filter(f);\n-/// profiling_function1();\n-///\n-/// fn profiling_function1() {\n-///     let _p = profile(\"profile1\");\n-///     profiling_function2();\n-/// }\n-///\n-/// fn profiling_function2() {\n-///     let _p = profile(\"profile2\");\n-/// }\n-/// ```\n-/// This will print in the stderr the following:\n-/// ```text\n-///  0ms - profile\n-///      0ms - profile2\n-/// ```\n-pub fn profile(label: Label) -> Profiler {\n-    assert!(!label.is_empty());\n-    if !PROFILING_ENABLED.load(Ordering::Relaxed) {\n-        return Profiler { label: None, detail: None };\n-    }\n-\n-    PROFILE_STACK.with(|stack| {\n-        let mut stack = stack.borrow_mut();\n-        if stack.starts.is_empty() {\n-            if let Ok(f) = FILTER.try_read() {\n-                if f.version > stack.filter_data.version {\n-                    stack.filter_data = f.clone();\n-                }\n-            };\n-        }\n-        if stack.starts.len() > stack.filter_data.depth {\n-            return Profiler { label: None, detail: None };\n-        }\n-        let allowed = &stack.filter_data.allowed;\n-        if stack.starts.is_empty() && !allowed.is_empty() && !allowed.contains(label) {\n-            return Profiler { label: None, detail: None };\n-        }\n-\n-        stack.starts.push(Instant::now());\n-        Profiler { label: Some(label), detail: None }\n-    })\n-}\n-\n-pub struct Profiler {\n-    label: Option<Label>,\n-    detail: Option<String>,\n-}\n-\n-impl Profiler {\n-    pub fn detail(mut self, detail: impl FnOnce() -> String) -> Profiler {\n-        if self.label.is_some() {\n-            self.detail = Some(detail())\n-        }\n-        self\n-    }\n-}\n-\n-pub struct Filter {\n-    depth: usize,\n-    allowed: Vec<String>,\n-    longer_than: Duration,\n-}\n-\n-impl Filter {\n-    // Filtering syntax\n-    // env RA_PROFILE=*             // dump everything\n-    // env RA_PROFILE=foo|bar|baz   // enabled only selected entries\n-    // env RA_PROFILE=*@3>10        // dump everything, up to depth 3, if it takes more than 10 ms\n-    pub fn from_spec(mut spec: &str) -> Filter {\n-        let longer_than = if let Some(idx) = spec.rfind('>') {\n-            let longer_than = spec[idx + 1..].parse().expect(\"invalid profile longer_than\");\n-            spec = &spec[..idx];\n-            Duration::from_millis(longer_than)\n-        } else {\n-            Duration::new(0, 0)\n-        };\n-\n-        let depth = if let Some(idx) = spec.rfind('@') {\n-            let depth: usize = spec[idx + 1..].parse().expect(\"invalid profile depth\");\n-            spec = &spec[..idx];\n-            depth\n-        } else {\n-            999\n-        };\n-        let allowed =\n-            if spec == \"*\" { Vec::new() } else { spec.split('|').map(String::from).collect() };\n-        Filter::new(depth, allowed, longer_than)\n-    }\n-\n-    pub fn disabled() -> Filter {\n-        Filter::new(0, Vec::new(), Duration::new(0, 0))\n-    }\n-\n-    pub fn new(depth: usize, allowed: Vec<String>, longer_than: Duration) -> Filter {\n-        Filter { depth, allowed, longer_than }\n-    }\n-}\n-\n-struct ProfileStack {\n-    starts: Vec<Instant>,\n-    messages: Vec<Message>,\n-    filter_data: FilterData,\n-}\n-\n-struct Message {\n-    level: usize,\n-    duration: Duration,\n-    label: Label,\n-    detail: Option<String>,\n-}\n-\n-impl ProfileStack {\n-    fn new() -> ProfileStack {\n-        ProfileStack { starts: Vec::new(), messages: Vec::new(), filter_data: Default::default() }\n-    }\n-}\n-\n-#[derive(Default, Clone)]\n-struct FilterData {\n-    depth: usize,\n-    version: usize,\n-    allowed: HashSet<String>,\n-    longer_than: Duration,\n-}\n-\n-static PROFILING_ENABLED: AtomicBool = AtomicBool::new(false);\n-\n-static FILTER: Lazy<RwLock<FilterData>> = Lazy::new(Default::default);\n-\n-thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n-\n-impl Drop for Profiler {\n-    fn drop(&mut self) {\n-        match self {\n-            Profiler { label: Some(label), detail } => {\n-                PROFILE_STACK.with(|stack| {\n-                    let mut stack = stack.borrow_mut();\n-                    let start = stack.starts.pop().unwrap();\n-                    let duration = start.elapsed();\n-                    let level = stack.starts.len();\n-                    stack.messages.push(Message { level, duration, label, detail: detail.take() });\n-                    if level == 0 {\n-                        let stdout = stderr();\n-                        let longer_than = stack.filter_data.longer_than;\n-                        // Convert to millis for comparison to avoid problems with rounding\n-                        // (otherwise we could print `0ms` despite user's `>0` filter when\n-                        // `duration` is just a few nanos).\n-                        if duration.as_millis() > longer_than.as_millis() {\n-                            print(&stack.messages, longer_than, &mut stdout.lock());\n-                        }\n-                        stack.messages.clear();\n-                    }\n-                });\n-            }\n-            Profiler { label: None, .. } => (),\n-        }\n-    }\n-}\n-\n-fn print(msgs: &[Message], longer_than: Duration, out: &mut impl Write) {\n-    if msgs.is_empty() {\n-        return;\n-    }\n-    let children_map = idx_to_children(msgs);\n-    let root_idx = msgs.len() - 1;\n-    print_for_idx(root_idx, &children_map, msgs, longer_than, out);\n-}\n-\n-fn print_for_idx(\n-    current_idx: usize,\n-    children_map: &[Vec<usize>],\n-    msgs: &[Message],\n-    longer_than: Duration,\n-    out: &mut impl Write,\n-) {\n-    let current = &msgs[current_idx];\n-    let current_indent = \"    \".repeat(current.level);\n-    let detail = current.detail.as_ref().map(|it| format!(\" @ {}\", it)).unwrap_or_default();\n-    writeln!(\n-        out,\n-        \"{}{:5}ms - {}{}\",\n-        current_indent,\n-        current.duration.as_millis(),\n-        current.label,\n-        detail,\n-    )\n-    .expect(\"printing profiling info\");\n-\n-    let longer_than_millis = longer_than.as_millis();\n-    let children_indices = &children_map[current_idx];\n-    let mut accounted_for = Duration::default();\n-    let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n-\n-    for child_idx in children_indices.iter() {\n-        let child = &msgs[*child_idx];\n-        if child.duration.as_millis() > longer_than_millis {\n-            print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n-        } else {\n-            let pair = short_children.entry(child.label).or_insert((Duration::default(), 0));\n-            pair.0 += child.duration;\n-            pair.1 += 1;\n-        }\n-        accounted_for += child.duration;\n-    }\n-\n-    for (child_msg, (duration, count)) in short_children.iter() {\n-        let millis = duration.as_millis();\n-        writeln!(out, \"    {}{:5}ms - {} ({} calls)\", current_indent, millis, child_msg, count)\n-            .expect(\"printing profiling info\");\n-    }\n-\n-    let unaccounted_millis = (current.duration - accounted_for).as_millis();\n-    if !children_indices.is_empty()\n-        && unaccounted_millis > 0\n-        && unaccounted_millis > longer_than_millis\n-    {\n-        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted_millis)\n-            .expect(\"printing profiling info\");\n-    }\n-}\n-\n-/// Returns a mapping from an index in the `msgs` to the vector with the indices of its children.\n-///\n-/// This assumes that the entries in `msgs` are in the order of when the calls to `profile` finish.\n-/// In other words, a postorder of the call graph. In particular, the root is the last element of\n-/// `msgs`.\n-fn idx_to_children(msgs: &[Message]) -> Vec<Vec<usize>> {\n-    // Initialize with the index of the root; `msgs` and `ancestors` should be never empty.\n-    assert!(!msgs.is_empty());\n-    let mut ancestors = vec![msgs.len() - 1];\n-    let mut result: Vec<Vec<usize>> = vec![vec![]; msgs.len()];\n-    for (idx, msg) in msgs[..msgs.len() - 1].iter().enumerate().rev() {\n-        // We need to find the parent of the current message, i.e., the last ancestor that has a\n-        // level lower than the current message.\n-        while msgs[*ancestors.last().unwrap()].level >= msg.level {\n-            ancestors.pop();\n-        }\n-        result[*ancestors.last().unwrap()].push(idx);\n-        ancestors.push(idx);\n-    }\n-    // Note that above we visited all children from the last to the first one. Let's reverse vectors\n-    // to get the more natural order where the first element is the first child.\n-    for vec in result.iter_mut() {\n-        vec.reverse();\n-    }\n-    result\n-}\n-\n /// Prints backtrace to stderr, useful for debugging.\n #[cfg(feature = \"backtrace\")]\n pub fn print_backtrace() {\n@@ -403,86 +104,3 @@ impl Drop for CpuProfiler {\n pub fn memory_usage() -> MemoryUsage {\n     MemoryUsage::current()\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_basic_profile() {\n-        let s = vec![\"profile1\".to_string(), \"profile2\".to_string()];\n-        let f = Filter::new(2, s, Duration::new(0, 0));\n-        set_filter(f);\n-        profiling_function1();\n-    }\n-\n-    fn profiling_function1() {\n-        let _p = profile(\"profile1\");\n-        profiling_function2();\n-    }\n-\n-    fn profiling_function2() {\n-        let _p = profile(\"profile2\");\n-    }\n-\n-    #[test]\n-    fn test_longer_than() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 1, duration: Duration::from_nanos(3), label: \"bar\", detail: None },\n-            Message { level: 1, duration: Duration::from_nanos(2), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(1), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n-        // when printing.\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap(),\n-            \"    1ms - foo\\n        0ms - bar (2 calls)\\n\"\n-        );\n-    }\n-\n-    #[test]\n-    fn test_unaccounted_for_topmost() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 1, duration: Duration::from_millis(2), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(5), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n-            vec![\n-                \"    5ms - foo\",\n-                \"        2ms - bar\",\n-                \"        3ms - ???\",\n-                // Dummy comment to improve formatting\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_unaccounted_for_multiple_levels() {\n-        let mut result = vec![];\n-        let msgs = vec![\n-            Message { level: 2, duration: Duration::from_millis(3), label: \"baz\", detail: None },\n-            Message { level: 1, duration: Duration::from_millis(5), label: \"bar\", detail: None },\n-            Message { level: 2, duration: Duration::from_millis(2), label: \"baz\", detail: None },\n-            Message { level: 1, duration: Duration::from_millis(4), label: \"bar\", detail: None },\n-            Message { level: 0, duration: Duration::from_millis(9), label: \"foo\", detail: None },\n-        ];\n-        print(&msgs, Duration::from_millis(0), &mut result);\n-        assert_eq!(\n-            std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n-            vec![\n-                \"    9ms - foo\",\n-                \"        5ms - bar\",\n-                \"            3ms - baz\",\n-                \"            2ms - ???\",\n-                \"        4ms - bar\",\n-                \"            2ms - baz\",\n-                \"            2ms - ???\",\n-            ]\n-        );\n-    }\n-}"}, {"sha": "9ea5b5db8e1f3fdd42c128815e461705a14b0942", "filename": "crates/ra_prof/src/tree.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2Fsrc%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Fra_prof%2Fsrc%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Ftree.rs?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -0,0 +1,84 @@\n+//! A simple tree implementation which tries to not allocate all over the place.\n+use std::ops;\n+\n+use ra_arena::Arena;\n+\n+#[derive(Default)]\n+pub struct Tree<T> {\n+    nodes: Arena<Node<T>>,\n+    current_path: Vec<(Idx<T>, Option<Idx<T>>)>,\n+}\n+\n+pub type Idx<T> = ra_arena::Idx<Node<T>>;\n+\n+impl<T> Tree<T> {\n+    pub fn start(&mut self)\n+    where\n+        T: Default,\n+    {\n+        let me = self.nodes.alloc(Node::new(T::default()));\n+        if let Some((parent, last_child)) = self.current_path.last_mut() {\n+            let slot = match *last_child {\n+                Some(last_child) => &mut self.nodes[last_child].next_sibling,\n+                None => &mut self.nodes[*parent].first_child,\n+            };\n+            let prev = slot.replace(me);\n+            assert!(prev.is_none());\n+            *last_child = Some(me);\n+        }\n+\n+        self.current_path.push((me, None));\n+    }\n+\n+    pub fn finish(&mut self, data: T) {\n+        let (me, _last_child) = self.current_path.pop().unwrap();\n+        self.nodes[me].data = data;\n+    }\n+\n+    pub fn root(&self) -> Option<Idx<T>> {\n+        self.nodes.iter().next().map(|(idx, _)| idx)\n+    }\n+\n+    pub fn children(&self, idx: Idx<T>) -> impl Iterator<Item = Idx<T>> + '_ {\n+        NodeIter { nodes: &self.nodes, next: self.nodes[idx].first_child }\n+    }\n+    pub fn clear(&mut self) {\n+        self.nodes.clear();\n+        self.current_path.clear();\n+    }\n+}\n+\n+impl<T> ops::Index<Idx<T>> for Tree<T> {\n+    type Output = T;\n+    fn index(&self, index: Idx<T>) -> &T {\n+        &self.nodes[index].data\n+    }\n+}\n+\n+pub struct Node<T> {\n+    data: T,\n+    first_child: Option<Idx<T>>,\n+    next_sibling: Option<Idx<T>>,\n+}\n+\n+impl<T> Node<T> {\n+    fn new(data: T) -> Node<T> {\n+        Node { data, first_child: None, next_sibling: None }\n+    }\n+}\n+\n+struct NodeIter<'a, T> {\n+    nodes: &'a Arena<Node<T>>,\n+    next: Option<Idx<T>>,\n+}\n+\n+impl<'a, T> Iterator for NodeIter<'a, T> {\n+    type Item = Idx<T>;\n+\n+    fn next(&mut self) -> Option<Idx<T>> {\n+        self.next.map(|next| {\n+            self.next = self.nodes[next].next_sibling;\n+            next\n+        })\n+    }\n+}"}, {"sha": "e4fe3411aa632da87c8a97535e19e6382650764b", "filename": "crates/rust-analyzer/tests/heavy_tests/support.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -62,11 +62,7 @@ impl<'a> Project<'a> {\n         static INIT: Once = Once::new();\n         INIT.call_once(|| {\n             env_logger::builder().is_test(true).try_init().unwrap();\n-            ra_prof::set_filter(if crate::PROFILE.is_empty() {\n-                ra_prof::Filter::disabled()\n-            } else {\n-                ra_prof::Filter::from_spec(&crate::PROFILE)\n-            });\n+            ra_prof::init_from(crate::PROFILE);\n         });\n \n         let mut paths = vec![];"}, {"sha": "cffdcf11acf293521538c4b580388d3c60a2a48e", "filename": "editors/code/src/client.ts", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/45832b990c7f291abe578dff3c460f4a1232f024/editors%2Fcode%2Fsrc%2Fclient.ts", "raw_url": "https://github.com/rust-lang/rust/raw/45832b990c7f291abe578dff3c460f4a1232f024/editors%2Fcode%2Fsrc%2Fclient.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fclient.ts?ref=45832b990c7f291abe578dff3c460f4a1232f024", "patch": "@@ -42,35 +42,6 @@ export function createClient(serverPath: string, cwd: string): lc.LanguageClient\n         clientOptions,\n     );\n \n-    // HACK: This is an awful way of filtering out the decorations notifications\n-    // However, pending proper support, this is the most effecitve approach\n-    // Proper support for this would entail a change to vscode-languageclient to allow not notifying on certain messages\n-    // Or the ability to disable the serverside component of highlighting (but this means that to do tracing we need to disable hihlighting)\n-    // This also requires considering our settings strategy, which is work which needs doing\n-    // @ts-ignore The tracer is private to vscode-languageclient, but we need access to it to not log publishDecorations requests\n-    res._tracer = {\n-        log: (messageOrDataObject: string | unknown, data?: string) => {\n-            if (typeof messageOrDataObject === 'string') {\n-                if (\n-                    messageOrDataObject.includes(\n-                        'rust-analyzer/publishDecorations',\n-                    ) ||\n-                    messageOrDataObject.includes(\n-                        'rust-analyzer/decorationsRequest',\n-                    )\n-                ) {\n-                    // Don't log publish decorations requests\n-                } else {\n-                    // @ts-ignore This is just a utility function\n-                    res.logTrace(messageOrDataObject, data);\n-                }\n-            } else {\n-                // @ts-ignore\n-                res.logObjectTrace(messageOrDataObject);\n-            }\n-        },\n-    };\n-\n     // To turn on all proposed features use: res.registerProposedFeatures();\n     // Here we want to enable CallHierarchyFeature and SemanticTokensFeature\n     // since they are available on stable."}]}