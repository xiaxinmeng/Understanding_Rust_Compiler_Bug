{"sha": "1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmODkxZDExZjVmZjY0ZTFmMmU5Y2JhNzlmMTA2OWY3YThkMTNjN2Y=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-05-06T01:54:47Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2017-05-06T01:54:47Z"}, "message": "Improve implementation approach comments in [T]::reverse()", "tree": {"sha": "11e387f90f87cab447cfbb29ac9d15cbb746c95b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11e387f90f87cab447cfbb29ac9d15cbb746c95b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f", "html_url": "https://github.com/rust-lang/rust/commit/1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0", "html_url": "https://github.com/rust-lang/rust/commit/e8fad325fe8630c0a6561d3e0c9c5fc51423aac0"}], "stats": {"total": 19, "additions": 15, "deletions": 4}, "files": [{"sha": "e15eb8f24440956b5e1ff88e48b794ecca1194c6", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=1f891d11f5ff64e1f2e9cba79f1069f7a8d13c7f", "patch": "@@ -540,12 +540,24 @@ impl<T> SliceExt for [T] {\n         let mut i: usize = 0;\n         let ln = self.len();\n \n+        // For very small types, all the individual reads in the normal\n+        // path perform poorly.  We can do better, given efficient unaligned\n+        // load/store, by loading a larger chunk and reversing a register.\n+\n+        // Ideally LLVM would do this for us, as it knows better than we do\n+        // whether unaligned reads are efficient (since that changes between\n+        // different ARM versions, for example) and what the best chunk size\n+        // would be.  Unfortunately, as of LLVM 4.0 (2017-05) it only unrolls\n+        // the loop, so we need to do this ourselves.  (Hypothesis: reverse\n+        // is troublesome because the sides can be aligned differently --\n+        // will be, when the length is odd -- so there's no way of emitting\n+        // pre- and postludes to use fully-aligned SIMD in the middle.)\n+\n         let fast_unaligned =\n             cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\"));\n \n         if fast_unaligned && mem::size_of::<T>() == 1 {\n-            // Single-byte read & write are comparatively slow. Instead,\n-            // work in usize chunks and get bswap to do the hard work.\n+            // Use the llvm.bswap intrinsic to reverse u8s in a usize\n             let chunk = mem::size_of::<usize>();\n             while i + chunk - 1 < ln / 2 {\n                 unsafe {\n@@ -561,8 +573,7 @@ impl<T> SliceExt for [T] {\n         }\n \n         if fast_unaligned && mem::size_of::<T>() == 2 {\n-            // Not quite as good as the above, but still helpful.\n-            // Same general idea, read bigger and do the swap in a register.\n+            // Use rotate-by-16 to reverse u16s in a u32\n             let chunk = mem::size_of::<u32>() / 2;\n             while i + chunk - 1 < ln / 2 {\n                 unsafe {"}]}