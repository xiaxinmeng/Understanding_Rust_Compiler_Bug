{"sha": "5068ae4771d9abd23b955bdec97b397396a312a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwNjhhZTQ3NzFkOWFiZDIzYjk1NWJkZWM5N2IzOTczOTZhMzEyYTQ=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-28T23:54:06Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-29T01:40:17Z"}, "message": "Factor out a bunch of environment construction code from trans_bind.", "tree": {"sha": "7050637c11df2c70df115a9984772b320212ceab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7050637c11df2c70df115a9984772b320212ceab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5068ae4771d9abd23b955bdec97b397396a312a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5068ae4771d9abd23b955bdec97b397396a312a4", "html_url": "https://github.com/rust-lang/rust/commit/5068ae4771d9abd23b955bdec97b397396a312a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5068ae4771d9abd23b955bdec97b397396a312a4/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "389652475064b3cf558f0530db83ecc8938062cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/389652475064b3cf558f0530db83ecc8938062cb", "html_url": "https://github.com/rust-lang/rust/commit/389652475064b3cf558f0530db83ecc8938062cb"}], "stats": {"total": 183, "additions": 99, "deletions": 84}, "files": [{"sha": "2f8f2aee5fc62762a9724b63e8b1524b67697cff", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 99, "deletions": 84, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/5068ae4771d9abd23b955bdec97b397396a312a4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5068ae4771d9abd23b955bdec97b397396a312a4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5068ae4771d9abd23b955bdec97b397396a312a4", "patch": "@@ -3679,25 +3679,103 @@ fn trans_for(cx: &@block_ctxt, local: &@ast::local, seq: &@ast::expr,\n \n // Finds the ValueRef associated with a variable in a function\n // context. It checks locals, upvars, and args.\n-fn find_variable(fcx: &@fn_ctxt, nid: ast::node_id) -> ValueRef {\n-    ret alt fcx.lllocals.find(nid) {\n+fn find_variable(cx: &@block_ctxt, nid: ast::node_id) -> lval_result {\n+    let fcx = cx.fcx;\n+    let llval = alt fcx.lllocals.find(nid) {\n+      none. {\n+        alt fcx.llupvars.find(nid) {\n           none. {\n-            alt fcx.llupvars.find(nid) {\n-              none. {\n-                alt fcx.llargs.find(nid) {\n-                  some(llval) { llval }\n-                  _ {\n-                    fcx.lcx.ccx.sess.bug(\"unbound var \\\n-                                      in build_environment \"\n-                                             + int::str(nid))\n-                  }\n-                }\n-              }\n+            alt fcx.llargs.find(nid) {\n               some(llval) { llval }\n+              _ {\n+                fcx.lcx.ccx.sess.bug(\"unbound var in build_environment \"\n+                                     + int::str(nid))\n+              }\n             }\n           }\n           some(llval) { llval }\n         }\n+      }\n+      some(llval) { llval }\n+    };\n+    ret lval_mem(cx, llval);\n+}\n+\n+// build_environment_heap and build_environment are very similar. It\n+// would be nice to unify them.\n+\n+fn build_environment_heap(bcx: @block_ctxt, lltydescs: ValueRef[],\n+                          bound_tys: ty::t[], bound_vals: lval_result[])\n+    -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+    // Synthesize a closure type.\n+\n+    // First, synthesize a tuple type containing the types of all the\n+    // bound expressions.\n+    // bindings_ty = ~[bound_ty1, bound_ty2, ...]\n+    let bindings_ty: ty::t = ty::mk_imm_tup(bcx_tcx(bcx), bound_tys);\n+\n+    // NB: keep this in sync with T_closure_ptr; we're making\n+    // a ty::t structure that has the same \"shape\" as the LLVM type\n+    // it constructs.\n+\n+    // Make a vector that contains ty_param_count copies of tydesc_ty.\n+    // (We'll need room for that many tydescs in the closure.)\n+    let ty_param_count = std::ivec::len(lltydescs);\n+    let tydesc_ty: ty::t = ty::mk_type(bcx_tcx(bcx));\n+    let captured_tys: ty::t[] =\n+        std::ivec::init_elt(tydesc_ty, ty_param_count);\n+\n+    // Get all the types we've got (some of which we synthesized\n+    // ourselves) into a vector.  The whole things ends up looking\n+    // like:\n+\n+    // closure_tys = [tydesc_ty, outgoing_fty, [bound_ty1, bound_ty2,\n+    // ...], [tydesc_ty, tydesc_ty, ...]]\n+    let closure_tys: ty::t[] =\n+        ~[tydesc_ty, bindings_ty, ty::mk_imm_tup(bcx_tcx(bcx), captured_tys)];\n+\n+    // Finally, synthesize a type for that whole vector.\n+    let closure_ty: ty::t = ty::mk_imm_tup(bcx_tcx(bcx), closure_tys);\n+\n+    // Allocate a box that can hold something closure-sized.\n+    let r = trans_malloc_boxed(bcx, closure_ty);\n+    bcx = r.bcx;\n+    let closure = r.body;\n+\n+    // Store bindings tydesc.\n+    let bound_tydesc =\n+        bcx.build.GEP(closure, ~[C_int(0), C_int(abi::closure_elt_tydesc)]);\n+    let ti = none;\n+    let bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+    bcx = bindings_tydesc.bcx;\n+    bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n+\n+    // Copy expr values into boxed bindings.\n+    let i = 0u;\n+    let bindings =\n+        bcx.build.GEP(closure, ~[C_int(0), C_int(abi::closure_elt_bindings)]);\n+    for lv: lval_result  in bound_vals {\n+        let bound = bcx.build.GEP(bindings, ~[C_int(0), C_int(i as int)]);\n+        bcx = move_val_if_temp(bcx, INIT, bound, lv, bound_tys.(i)).bcx;\n+        i += 1u;\n+    }\n+\n+    // If necessary, copy tydescs describing type parameters into the\n+    // appropriate slot in the closure.\n+    let ty_params_slot =\n+        bcx.build.GEP(closure,\n+                      ~[C_int(0), C_int(abi::closure_elt_ty_params)]);\n+    i = 0u;\n+    for td: ValueRef  in lltydescs {\n+        let ty_param_slot =\n+            bcx.build.GEP(ty_params_slot, ~[C_int(0), C_int(i as int)]);\n+        bcx.build.Store(td, ty_param_slot);\n+        i += 1u;\n+    }\n+\n+    ret {ptr: r.box, ptrty: closure_ty, bcx: bcx};\n }\n \n // Given a block context and a list of upvars, construct a closure that\n@@ -3717,7 +3795,7 @@ fn build_environment(cx: &@block_ctxt, upvars: &freevar_set) ->\n             llbindingtys += ~[val_ty(llbindings.(0))];\n         }\n         for each nid: ast::node_id  in upvars.keys() {\n-            let llbinding = find_variable(cx.fcx, nid);\n+            let llbinding = find_variable(cx, nid).res.val;\n             llbindings += ~[llbinding];\n             llbindingtys += ~[val_ty(llbinding)];\n         }\n@@ -4606,84 +4684,21 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n         bound_tys += ~[ty::expr_ty(bcx_tcx(cx), e)];\n     }\n \n-    // Synthesize a closure type.\n-\n-    // First, synthesize a tuple type containing the types of all the\n-    // bound expressions.\n-    // bindings_ty = ~[bound_ty1, bound_ty2, ...]\n-    let bindings_ty: ty::t = ty::mk_imm_tup(bcx_tcx(cx), bound_tys);\n-\n-    // NB: keep this in sync with T_closure_ptr; we're making\n-    // a ty::t structure that has the same \"shape\" as the LLVM type\n-    // it constructs.\n-\n-    // Make a vector that contains ty_param_count copies of tydesc_ty.\n-    // (We'll need room for that many tydescs in the closure.)\n-    let tydesc_ty: ty::t = ty::mk_type(bcx_tcx(cx));\n-    let captured_tys: ty::t[] =\n-        std::ivec::init_elt(tydesc_ty, ty_param_count);\n-\n-    // Get all the types we've got (some of which we synthesized\n-    // ourselves) into a vector.  The whole things ends up looking\n-    // like:\n-\n-    // closure_tys = [tydesc_ty, outgoing_fty, [bound_ty1, bound_ty2,\n-    // ...], [tydesc_ty, tydesc_ty, ...]]\n-    let closure_tys: ty::t[] =\n-        ~[tydesc_ty, bindings_ty, ty::mk_imm_tup(bcx_tcx(cx), captured_tys)];\n-\n-    // Finally, synthesize a type for that whole vector.\n-    let closure_ty: ty::t = ty::mk_imm_tup(bcx_tcx(cx), closure_tys);\n-\n-    // Allocate a box that can hold something closure-sized.\n-    let r = trans_malloc_boxed(bcx, closure_ty);\n-    bcx = r.bcx;\n-    let closure = r.body;\n-\n-    // Store bindings tydesc.\n-    let bound_tydesc =\n-        bcx.build.GEP(closure, ~[C_int(0), C_int(abi::closure_elt_tydesc)]);\n-    let ti = none;\n-    let bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-    bcx = bindings_tydesc.bcx;\n-    bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n-\n-    // Copy expr values into boxed bindings.\n-    let i = 0u;\n-    let bindings =\n-        bcx.build.GEP(closure, ~[C_int(0), C_int(abi::closure_elt_bindings)]);\n-    for lv: lval_result  in bound_vals {\n-        let bound = bcx.build.GEP(bindings, ~[C_int(0), C_int(i as int)]);\n-        bcx = move_val_if_temp(bcx, INIT, bound, lv, bound_tys.(i)).bcx;\n-        i += 1u;\n-    }\n-\n-    // If necessary, copy tydescs describing type parameters into the\n-    // appropriate slot in the closure.\n-    if ty_param_count > 0u {\n-        let ty_params_slot =\n-            bcx.build.GEP(closure,\n-                          ~[C_int(0), C_int(abi::closure_elt_ty_params)]);\n-        let i = 0;\n-        for td: ValueRef  in lltydescs {\n-            let ty_param_slot =\n-                bcx.build.GEP(ty_params_slot, ~[C_int(0), C_int(i)]);\n-            bcx.build.Store(td, ty_param_slot);\n-            i += 1;\n-        }\n-    }\n+    // Actually construct the closure\n+    let closure = build_environment_heap(bcx, lltydescs,\n+                                         bound_tys, bound_vals);\n+    bcx = closure.bcx;\n \n     // Make thunk\n     // The type of the entire bind expression.\n     let pair_ty = node_id_type(bcx_ccx(cx), id);\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real,\n-                         args, closure_ty, bound_tys, ty_param_count);\n+                         args, closure.ptrty, bound_tys, ty_param_count);\n \n     // Construct the function pair\n-    let pair_v = create_real_fn_pair(bcx, llthunk.ty, llthunk.val, r.box);\n+    let pair_v = create_real_fn_pair(bcx, llthunk.ty, llthunk.val,\n+                                     closure.ptr);\n     add_clean_temp(cx, pair_v, pair_ty);\n     ret rslt(bcx, pair_v);\n }"}]}