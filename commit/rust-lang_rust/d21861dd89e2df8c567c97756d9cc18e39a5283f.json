{"sha": "d21861dd89e2df8c567c97756d9cc18e39a5283f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMTg2MWRkODllMmRmOGM1NjdjOTc3NTZkOWNjMThlMzlhNTI4M2Y=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-27T13:54:50Z"}, "committer": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-11-30T14:16:34Z"}, "message": "Refactor one_bound_for_assoc_type to take an Iterator instead of Vec.", "tree": {"sha": "5135120d79860826b9e71858f892934e2c7dae47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5135120d79860826b9e71858f892934e2c7dae47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d21861dd89e2df8c567c97756d9cc18e39a5283f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d21861dd89e2df8c567c97756d9cc18e39a5283f", "html_url": "https://github.com/rust-lang/rust/commit/d21861dd89e2df8c567c97756d9cc18e39a5283f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d21861dd89e2df8c567c97756d9cc18e39a5283f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3abaf43f770a8bae23da474690e3841041219029", "url": "https://api.github.com/repos/rust-lang/rust/commits/3abaf43f770a8bae23da474690e3841041219029", "html_url": "https://github.com/rust-lang/rust/commit/3abaf43f770a8bae23da474690e3841041219029"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "96088db9d8ea5e5df35c9088cf9529ff3c21aea2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d21861dd89e2df8c567c97756d9cc18e39a5283f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d21861dd89e2df8c567c97756d9cc18e39a5283f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d21861dd89e2df8c567c97756d9cc18e39a5283f", "patch": "@@ -884,10 +884,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // those that do.\n         self.ensure_super_predicates(binding.span, trait_ref.def_id())?;\n \n-        let candidates: Vec<ty::PolyTraitRef> =\n+        let candidates =\n             traits::supertraits(tcx, trait_ref.clone())\n-            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n-            .collect();\n+            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), binding.item_name));\n \n         let candidate = self.one_bound_for_assoc_type(candidates,\n                                                       &trait_ref.to_string(),\n@@ -1191,10 +1190,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check that there is exactly one way to find an associated type with the\n         // correct name.\n-        let suitable_bounds: Vec<_> =\n+        let suitable_bounds =\n             traits::transitive_bounds(tcx, &bounds)\n-            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name))\n-            .collect();\n+            .filter(|b| self.trait_defines_associated_type_named(b.def_id(), assoc_name));\n \n         self.one_bound_for_assoc_type(suitable_bounds,\n                                       &ty_param_name.as_str(),\n@@ -1205,54 +1203,57 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     // Checks that bounds contains exactly one element and reports appropriate\n     // errors otherwise.\n-    fn one_bound_for_assoc_type(&self,\n-                                bounds: Vec<ty::PolyTraitRef<'tcx>>,\n+    fn one_bound_for_assoc_type<I>(&self,\n+                                mut bounds: I,\n                                 ty_param_name: &str,\n                                 assoc_name: &str,\n                                 span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n+        where I: Iterator<Item=ty::PolyTraitRef<'tcx>>\n     {\n-        if bounds.is_empty() {\n-            struct_span_err!(self.tcx().sess, span, E0220,\n-                      \"associated type `{}` not found for `{}`\",\n-                      assoc_name,\n-                      ty_param_name)\n-              .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n-              .emit();\n-            return Err(ErrorReported);\n-        }\n-\n-        if bounds.len() > 1 {\n-            let spans = bounds.iter().map(|b| {\n-                self.tcx().associated_items(b.def_id()).find(|item| {\n-                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n-                })\n-                .and_then(|item| self.tcx().map.span_if_local(item.def_id))\n-            });\n+        let bound = match bounds.next() {\n+            Some(bound) => bound,\n+            None => {\n+                struct_span_err!(self.tcx().sess, span, E0220,\n+                          \"associated type `{}` not found for `{}`\",\n+                          assoc_name,\n+                          ty_param_name)\n+                  .span_label(span, &format!(\"associated type `{}` not found\", assoc_name))\n+                  .emit();\n+                return Err(ErrorReported);\n+            }\n+        };\n \n+        if let Some(bound2) = bounds.next() {\n+            let bounds = iter::once(bound).chain(iter::once(bound2)).chain(bounds);\n             let mut err = struct_span_err!(\n                 self.tcx().sess, span, E0221,\n                 \"ambiguous associated type `{}` in bounds of `{}`\",\n                 assoc_name,\n                 ty_param_name);\n             err.span_label(span, &format!(\"ambiguous associated type `{}`\", assoc_name));\n \n-            for span_and_bound in spans.zip(&bounds) {\n-                if let Some(span) = span_and_bound.0 {\n+            for bound in bounds {\n+                let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n+                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n+                })\n+                .and_then(|item| self.tcx().map.span_if_local(item.def_id));\n+\n+                if let Some(span) = bound_span {\n                     err.span_label(span, &format!(\"ambiguous `{}` from `{}`\",\n                                                   assoc_name,\n-                                                  span_and_bound.1));\n+                                                  bound));\n                 } else {\n                     span_note!(&mut err, span,\n                                \"associated type `{}` could derive from `{}`\",\n                                ty_param_name,\n-                               span_and_bound.1);\n+                               bound);\n                 }\n             }\n             err.emit();\n         }\n \n-        Ok(bounds[0].clone())\n+        return Ok(bound);\n     }\n \n     // Create a type from a path to an associated type.\n@@ -1293,11 +1294,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     return (tcx.types.err, Def::Err);\n                 }\n \n-                let candidates: Vec<ty::PolyTraitRef> =\n+                let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n-                                                                         assoc_name))\n-                    .collect();\n+                                                                         assoc_name));\n \n                 match self.one_bound_for_assoc_type(candidates,\n                                                     \"Self\","}]}