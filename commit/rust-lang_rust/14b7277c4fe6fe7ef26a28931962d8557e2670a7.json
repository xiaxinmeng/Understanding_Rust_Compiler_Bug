{"sha": "14b7277c4fe6fe7ef26a28931962d8557e2670a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YjcyNzdjNGZlNmZlN2VmMjZhMjg5MzE5NjJkODU1N2UyNjcwYTc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-01-04T21:52:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-04-18T21:39:40Z"}, "message": "core: add vec::bsearch.", "tree": {"sha": "289add5430c55677491b6b3ff460ec45c6bf0d0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/289add5430c55677491b6b3ff460ec45c6bf0d0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14b7277c4fe6fe7ef26a28931962d8557e2670a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14b7277c4fe6fe7ef26a28931962d8557e2670a7", "html_url": "https://github.com/rust-lang/rust/commit/14b7277c4fe6fe7ef26a28931962d8557e2670a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14b7277c4fe6fe7ef26a28931962d8557e2670a7/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a864852774e924f1f9bb68da34adca736211545", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a864852774e924f1f9bb68da34adca736211545", "html_url": "https://github.com/rust-lang/rust/commit/2a864852774e924f1f9bb68da34adca736211545"}], "stats": {"total": 85, "additions": 85, "deletions": 0}, "files": [{"sha": "01d1a57d78c3d5b7f4fc0f2ea5b450fa2ce33528", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/14b7277c4fe6fe7ef26a28931962d8557e2670a7/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14b7277c4fe6fe7ef26a28931962d8557e2670a7/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=14b7277c4fe6fe7ef26a28931962d8557e2670a7", "patch": "@@ -1223,6 +1223,46 @@ pub fn rposition_between<T>(v: &[T], start: uint, end: uint,\n     None\n }\n \n+\n+\n+/**\n+ * Binary search a sorted vector with a comparator function.\n+ *\n+ * The comparator should implement an order consistent with the sort\n+ * order of the underlying vector, returning an order code that indicates\n+ * whether its argument is `Less`, `Equal` or `Greater` the desired target.\n+ *\n+ * Returns the index where the comparator returned `Equal`, or `None` if\n+ * not found.\n+ */\n+pub pure fn bsearch<T>(v: &[T], f: &fn(&T) -> Ordering) -> Option<uint> {\n+    let mut base : uint = 0;\n+    let mut lim : uint = v.len();\n+\n+    while lim != 0 {\n+        let ix = base + (lim >> 1);\n+        match f(&v[ix]) {\n+            Equal => return Some(ix),\n+            Less => {\n+                base = ix + 1;\n+                lim -= 1;\n+            }\n+            Greater => ()\n+        }\n+        lim >>= 1;\n+    }\n+    return None;\n+}\n+\n+/**\n+ * Binary search a sorted vector for a given element.\n+ *\n+ * Returns the index of the element or None if not found.\n+ */\n+pub pure fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n+    bsearch(v, |p| p.cmp(x))\n+}\n+\n // FIXME: if issue #586 gets implemented, could have a postcondition\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n@@ -3710,6 +3750,51 @@ mod tests {\n         assert!(rfind_between(v, 4u, 4u, f).is_none());\n     }\n \n+    #[test]\n+    fn test_bsearch_elem() {\n+        fail_unless!(bsearch_elem([1,2,3,4,5], &5) == Some(4));\n+        fail_unless!(bsearch_elem([1,2,3,4,5], &4) == Some(3));\n+        fail_unless!(bsearch_elem([1,2,3,4,5], &3) == Some(2));\n+        fail_unless!(bsearch_elem([1,2,3,4,5], &2) == Some(1));\n+        fail_unless!(bsearch_elem([1,2,3,4,5], &1) == Some(0));\n+\n+        fail_unless!(bsearch_elem([2,4,6,8,10], &1) == None);\n+        fail_unless!(bsearch_elem([2,4,6,8,10], &5) == None);\n+        fail_unless!(bsearch_elem([2,4,6,8,10], &4) == Some(1));\n+        fail_unless!(bsearch_elem([2,4,6,8,10], &10) == Some(4));\n+\n+        fail_unless!(bsearch_elem([2,4,6,8], &1) == None);\n+        fail_unless!(bsearch_elem([2,4,6,8], &5) == None);\n+        fail_unless!(bsearch_elem([2,4,6,8], &4) == Some(1));\n+        fail_unless!(bsearch_elem([2,4,6,8], &8) == Some(3));\n+\n+        fail_unless!(bsearch_elem([2,4,6], &1) == None);\n+        fail_unless!(bsearch_elem([2,4,6], &5) == None);\n+        fail_unless!(bsearch_elem([2,4,6], &4) == Some(1));\n+        fail_unless!(bsearch_elem([2,4,6], &6) == Some(2));\n+\n+        fail_unless!(bsearch_elem([2,4], &1) == None);\n+        fail_unless!(bsearch_elem([2,4], &5) == None);\n+        fail_unless!(bsearch_elem([2,4], &2) == Some(0));\n+        fail_unless!(bsearch_elem([2,4], &4) == Some(1));\n+\n+        fail_unless!(bsearch_elem([2], &1) == None);\n+        fail_unless!(bsearch_elem([2], &5) == None);\n+        fail_unless!(bsearch_elem([2], &2) == Some(0));\n+\n+        fail_unless!(bsearch_elem([], &1) == None);\n+        fail_unless!(bsearch_elem([], &5) == None);\n+\n+        fail_unless!(bsearch_elem([1,1,1,1,1], &1) != None);\n+        fail_unless!(bsearch_elem([1,1,1,1,2], &1) != None);\n+        fail_unless!(bsearch_elem([1,1,1,2,2], &1) != None);\n+        fail_unless!(bsearch_elem([1,1,2,2,2], &1) != None);\n+        fail_unless!(bsearch_elem([1,2,2,2,2], &1) == Some(0));\n+\n+        fail_unless!(bsearch_elem([1,2,3,4,5], &6) == None);\n+        fail_unless!(bsearch_elem([1,2,3,4,5], &0) == None);\n+    }\n+\n     #[test]\n     fn reverse_and_reversed() {\n         let mut v: ~[int] = ~[10, 20];"}]}