{"sha": "75786fb0b707a9a4938ee31b916762c1a3eae09d", "node_id": "C_kwDOAAsO6NoAKDc1Nzg2ZmIwYjcwN2E5YTQ5MzhlZTMxYjkxNjc2MmMxYTNlYWUwOWQ", "commit": {"author": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2022-06-09T00:58:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-09T00:58:15Z"}, "message": "Merge pull request #5374 from calebcartwright/subtree-sync-2022-06-07\n\nSubtree sync", "tree": {"sha": "8c16e611ce019ae0151081558c350d0215275cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c16e611ce019ae0151081558c350d0215275cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75786fb0b707a9a4938ee31b916762c1a3eae09d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJioUWnCRBK7hj4Ov3rIwAALJoIAJjsL/j4iNU8R1CJ7HlhB0hk\nZWj5z1nYXQ+rL2/96GSU6Da5ylvQ/8WMNok0dB2E6F1EzG8vtamHrL+YRKP4ANiO\n6zz4+APfjGNu12EGRTrXtSdq/CI6tal/DaBF1RB9huqqMHUji1sZYH9fyKdb0NG1\nXnIpgxkqbwUb5Q8DDESkxzMz8axc3qKYqd8o+OKUQ0NPi+5naL99lMHIRwErIl0W\nOXCq5/JUIVzzc5bJ6YfGtoMCJmbFYq3xkA/CrfXVaSuLJN5e262yO1uKDbVILkX5\nPyrmWse/t7aqKbKrXECop/cuiUa9fnnrUDWgh+bbklpLAIeHriHoJHO7Uq3d7c8=\n=UmcQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c16e611ce019ae0151081558c350d0215275cf3\nparent 64f1f57a4837694cb2449d6bc1f614e60c6ff42c\nparent aedb396063e2cd166e3cc0bfd762bf382996cd03\nauthor Caleb Cartwright <calebcartwright@users.noreply.github.com> 1654736295 -0500\ncommitter GitHub <noreply@github.com> 1654736295 -0500\n\nMerge pull request #5374 from calebcartwright/subtree-sync-2022-06-07\n\nSubtree sync"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75786fb0b707a9a4938ee31b916762c1a3eae09d", "html_url": "https://github.com/rust-lang/rust/commit/75786fb0b707a9a4938ee31b916762c1a3eae09d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75786fb0b707a9a4938ee31b916762c1a3eae09d/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64f1f57a4837694cb2449d6bc1f614e60c6ff42c", "url": "https://api.github.com/repos/rust-lang/rust/commits/64f1f57a4837694cb2449d6bc1f614e60c6ff42c", "html_url": "https://github.com/rust-lang/rust/commit/64f1f57a4837694cb2449d6bc1f614e60c6ff42c"}, {"sha": "aedb396063e2cd166e3cc0bfd762bf382996cd03", "url": "https://api.github.com/repos/rust-lang/rust/commits/aedb396063e2cd166e3cc0bfd762bf382996cd03", "html_url": "https://github.com/rust-lang/rust/commit/aedb396063e2cd166e3cc0bfd762bf382996cd03"}], "stats": {"total": 248, "additions": 122, "deletions": 126}, "files": [{"sha": "813e5e2c10feae1d7c3290c8cc8bc8cab78d0bd0", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-03-27\"\n+channel = \"nightly-2022-06-06\"\n components = [\"rustc-dev\"]"}, {"sha": "41ba9a847e67a0bc2bf4167aac630782e8e3be2a", "filename": "src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -1,7 +1,7 @@\n //! Format attributes and meta items.\n \n use rustc_ast::ast;\n-use rustc_ast::AstLike;\n+use rustc_ast::HasAttrs;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n use self::doc_comment::DocCommentFormatter;"}, {"sha": "8e871e61f26837c5b2ed21cd1fd4348ec60e4cbd", "filename": "src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -693,6 +693,7 @@ fn edition_from_edition_str(edition_str: &str) -> Result<Edition> {\n         \"2015\" => Ok(Edition::Edition2015),\n         \"2018\" => Ok(Edition::Edition2018),\n         \"2021\" => Ok(Edition::Edition2021),\n+        \"2024\" => Ok(Edition::Edition2024),\n         _ => Err(format_err!(\"Invalid value for `--edition`\")),\n     }\n }"}, {"sha": "257a17b2703a9deab95d0e5f5533dde1523ed112", "filename": "src/config/options.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -423,6 +423,10 @@ pub enum Edition {\n     #[doc_hint = \"2021\"]\n     /// Edition 2021.\n     Edition2021,\n+    #[value = \"2024\"]\n+    #[doc_hint = \"2024\"]\n+    /// Edition 2024.\n+    Edition2024,\n }\n \n impl Default for Edition {\n@@ -437,6 +441,7 @@ impl From<Edition> for rustc_span::edition::Edition {\n             Edition::Edition2015 => Self::Edition2015,\n             Edition::Edition2018 => Self::Edition2018,\n             Edition::Edition2021 => Self::Edition2021,\n+            Edition::Edition2024 => Self::Edition2024,\n         }\n     }\n }"}, {"sha": "4ccf1ca70c9d99c1a129c89f29fc5fa48f4afb35", "filename": "src/expr.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -3,7 +3,7 @@ use std::cmp::min;\n use std::collections::HashMap;\n \n use itertools::Itertools;\n-use rustc_ast::token::{DelimToken, LitKind};\n+use rustc_ast::token::{Delimiter, LitKind};\n use rustc_ast::{ast, ptr};\n use rustc_span::{BytePos, Span};\n \n@@ -274,6 +274,10 @@ fn format_expr_inner(\n         ast::ExprKind::Ret(Some(ref expr)) => {\n             rewrite_unary_prefix(context, \"return \", &**expr, shape)\n         }\n+        ast::ExprKind::Yeet(None) => Some(\"do yeet\".to_owned()),\n+        ast::ExprKind::Yeet(Some(ref expr)) => {\n+            rewrite_unary_prefix(context, \"do yeet \", &**expr, shape)\n+        }\n         ast::ExprKind::Box(ref expr) => rewrite_unary_prefix(context, \"box \", &**expr, shape),\n         ast::ExprKind::AddrOf(borrow_kind, mutability, ref expr) => {\n             rewrite_expr_addrof(context, borrow_kind, mutability, expr, shape)\n@@ -461,7 +465,7 @@ pub(crate) fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext<'_>,\n     shape: Shape,\n     force_separator_tactic: Option<SeparatorTactic>,\n-    delim_token: Option<DelimToken>,\n+    delim_token: Option<Delimiter>,\n ) -> Option<String> {\n     overflow::rewrite_with_square_brackets(\n         context,\n@@ -1374,7 +1378,7 @@ pub(crate) fn can_be_overflowed_expr(\n         }\n         ast::ExprKind::MacCall(ref mac) => {\n             match (\n-                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim()),\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim().unwrap()),\n                 context.config.overflow_delimited_expr(),\n             ) {\n                 (Some(ast::MacDelimiter::Bracket), true)"}, {"sha": "e644ea50effd76c40184525ff6f1e5544cfcaa4a", "filename": "src/formatting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -6,7 +6,6 @@ use std::rc::Rc;\n use std::time::{Duration, Instant};\n \n use rustc_ast::ast;\n-use rustc_ast::AstLike;\n use rustc_span::Span;\n \n use self::newline_style::apply_newline_style;"}, {"sha": "bab881f4b4e8dceedfa31c2b6ed9834810fe3455", "filename": "src/items.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -204,12 +204,11 @@ impl<'a> FnSig<'a> {\n \n     pub(crate) fn from_fn_kind(\n         fn_kind: &'a visit::FnKind<'_>,\n-        generics: &'a ast::Generics,\n         decl: &'a ast::FnDecl,\n         defaultness: ast::Defaultness,\n     ) -> FnSig<'a> {\n         match *fn_kind {\n-            visit::FnKind::Fn(fn_ctxt, _, fn_sig, vis, _) => match fn_ctxt {\n+            visit::FnKind::Fn(fn_ctxt, _, fn_sig, vis, generics, _) => match fn_ctxt {\n                 visit::FnCtxt::Assoc(..) => {\n                     let mut fn_sig = FnSig::from_method_sig(fn_sig, generics, vis);\n                     fn_sig.defaultness = defaultness;\n@@ -1362,7 +1361,7 @@ pub(crate) fn format_struct_struct(\n \n fn get_bytepos_after_visibility(vis: &ast::Visibility, default_span: Span) -> BytePos {\n     match vis.kind {\n-        ast::VisibilityKind::Crate(..) | ast::VisibilityKind::Restricted { .. } => vis.span.hi(),\n+        ast::VisibilityKind::Restricted { .. } => vis.span.hi(),\n         _ => default_span.lo(),\n     }\n }\n@@ -3180,8 +3179,14 @@ impl Rewrite for ast::ForeignItem {\n                     let inner_attrs = inner_attributes(&self.attrs);\n                     let fn_ctxt = visit::FnCtxt::Foreign;\n                     visitor.visit_fn(\n-                        visit::FnKind::Fn(fn_ctxt, self.ident, sig, &self.vis, Some(body)),\n-                        generics,\n+                        visit::FnKind::Fn(\n+                            fn_ctxt,\n+                            self.ident,\n+                            sig,\n+                            &self.vis,\n+                            generics,\n+                            Some(body),\n+                        ),\n                         &sig.decl,\n                         self.span,\n                         defaultness,"}, {"sha": "f4b2bcf281577711c89b53f27ea387551c897003", "filename": "src/macros.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -12,7 +12,7 @@\n use std::collections::HashMap;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n-use rustc_ast::token::{BinOpToken, DelimToken, Token, TokenKind};\n+use rustc_ast::token::{BinOpToken, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{Cursor, Spacing, TokenStream, TokenTree};\n use rustc_ast::{ast, ptr};\n use rustc_ast_pretty::pprust;\n@@ -203,7 +203,7 @@ fn rewrite_macro_inner(\n     let is_forced_bracket = FORCED_BRACKET_MACROS.contains(&&macro_name[..]);\n \n     let style = if is_forced_bracket && !is_nested_macro {\n-        DelimToken::Bracket\n+        Delimiter::Bracket\n     } else {\n         original_style\n     };\n@@ -212,21 +212,21 @@ fn rewrite_macro_inner(\n     let has_comment = contains_comment(context.snippet(mac.span()));\n     if ts.is_empty() && !has_comment {\n         return match style {\n-            DelimToken::Paren if position == MacroPosition::Item => {\n+            Delimiter::Parenthesis if position == MacroPosition::Item => {\n                 Some(format!(\"{}();\", macro_name))\n             }\n-            DelimToken::Bracket if position == MacroPosition::Item => {\n+            Delimiter::Bracket if position == MacroPosition::Item => {\n                 Some(format!(\"{}[];\", macro_name))\n             }\n-            DelimToken::Paren => Some(format!(\"{}()\", macro_name)),\n-            DelimToken::Bracket => Some(format!(\"{}[]\", macro_name)),\n-            DelimToken::Brace => Some(format!(\"{} {{}}\", macro_name)),\n+            Delimiter::Parenthesis => Some(format!(\"{}()\", macro_name)),\n+            Delimiter::Bracket => Some(format!(\"{}[]\", macro_name)),\n+            Delimiter::Brace => Some(format!(\"{} {{}}\", macro_name)),\n             _ => unreachable!(),\n         };\n     }\n     // Format well-known macros which cannot be parsed as a valid AST.\n     if macro_name == \"lazy_static!\" && !has_comment {\n-        if let success @ Some(..) = format_lazy_static(context, shape, ts.trees().collect()) {\n+        if let success @ Some(..) = format_lazy_static(context, shape, ts.clone()) {\n             return success;\n         }\n     }\n@@ -260,7 +260,7 @@ fn rewrite_macro_inner(\n     }\n \n     match style {\n-        DelimToken::Paren => {\n+        Delimiter::Parenthesis => {\n             // Handle special case: `vec!(expr; expr)`\n             if vec_with_semi {\n                 handle_vec_semi(context, shape, arg_vec, macro_name, style)\n@@ -286,7 +286,7 @@ fn rewrite_macro_inner(\n                 })\n             }\n         }\n-        DelimToken::Bracket => {\n+        Delimiter::Bracket => {\n             // Handle special case: `vec![expr; expr]`\n             if vec_with_semi {\n                 handle_vec_semi(context, shape, arg_vec, macro_name, style)\n@@ -323,7 +323,7 @@ fn rewrite_macro_inner(\n                 Some(format!(\"{}{}\", rewrite, comma))\n             }\n         }\n-        DelimToken::Brace => {\n+        Delimiter::Brace => {\n             // For macro invocations with braces, always put a space between\n             // the `macro_name!` and `{ /* macro_body */ }` but skip modifying\n             // anything in between the braces (for now).\n@@ -342,11 +342,11 @@ fn handle_vec_semi(\n     shape: Shape,\n     arg_vec: Vec<MacroArg>,\n     macro_name: String,\n-    delim_token: DelimToken,\n+    delim_token: Delimiter,\n ) -> Option<String> {\n     let (left, right) = match delim_token {\n-        DelimToken::Paren => (\"(\", \")\"),\n-        DelimToken::Bracket => (\"[\", \"]\"),\n+        Delimiter::Parenthesis => (\"(\", \")\"),\n+        Delimiter::Bracket => (\"[\", \"]\"),\n         _ => unreachable!(),\n     };\n \n@@ -528,7 +528,7 @@ enum MacroArgKind {\n     /// e.g., `$($foo: expr),*`\n     Repeat(\n         /// `()`, `[]` or `{}`.\n-        DelimToken,\n+        Delimiter,\n         /// Inner arguments inside delimiters.\n         Vec<ParsedMacroArg>,\n         /// Something after the closing delimiter and the repeat token, if available.\n@@ -537,7 +537,7 @@ enum MacroArgKind {\n         Token,\n     ),\n     /// e.g., `[derive(Debug)]`\n-    Delimited(DelimToken, Vec<ParsedMacroArg>),\n+    Delimited(Delimiter, Vec<ParsedMacroArg>),\n     /// A possible separator. e.g., `,` or `;`.\n     Separator(String, String),\n     /// Other random stuff that does not fit to other kinds.\n@@ -547,22 +547,22 @@ enum MacroArgKind {\n \n fn delim_token_to_str(\n     context: &RewriteContext<'_>,\n-    delim_token: DelimToken,\n+    delim_token: Delimiter,\n     shape: Shape,\n     use_multiple_lines: bool,\n     inner_is_empty: bool,\n ) -> (String, String) {\n     let (lhs, rhs) = match delim_token {\n-        DelimToken::Paren => (\"(\", \")\"),\n-        DelimToken::Bracket => (\"[\", \"]\"),\n-        DelimToken::Brace => {\n+        Delimiter::Parenthesis => (\"(\", \")\"),\n+        Delimiter::Bracket => (\"[\", \"]\"),\n+        Delimiter::Brace => {\n             if inner_is_empty || use_multiple_lines {\n                 (\"{\", \"}\")\n             } else {\n                 (\"{ \", \" }\")\n             }\n         }\n-        DelimToken::NoDelim => (\"\", \"\"),\n+        Delimiter::Invisible => unreachable!(),\n     };\n     if use_multiple_lines {\n         let indent_str = shape.indent.to_string_with_newline(context.config);\n@@ -583,8 +583,8 @@ impl MacroArgKind {\n     fn starts_with_brace(&self) -> bool {\n         matches!(\n             *self,\n-            MacroArgKind::Repeat(DelimToken::Brace, _, _, _)\n-                | MacroArgKind::Delimited(DelimToken::Brace, _)\n+            MacroArgKind::Repeat(Delimiter::Brace, _, _, _)\n+                | MacroArgKind::Delimited(Delimiter::Brace, _)\n         )\n     }\n \n@@ -753,7 +753,7 @@ impl MacroArgParser {\n         }\n     }\n \n-    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: DelimToken) {\n+    fn add_delimited(&mut self, inner: Vec<ParsedMacroArg>, delim: Delimiter) {\n         self.result.push(ParsedMacroArg {\n             kind: MacroArgKind::Delimited(delim, inner),\n         });\n@@ -763,7 +763,7 @@ impl MacroArgParser {\n     fn add_repeat(\n         &mut self,\n         inner: Vec<ParsedMacroArg>,\n-        delim: DelimToken,\n+        delim: Delimiter,\n         iter: &mut Cursor,\n     ) -> Option<()> {\n         let mut buffer = String::new();\n@@ -855,7 +855,7 @@ impl MacroArgParser {\n \n     /// Returns a collection of parsed macro def's arguments.\n     fn parse(mut self, tokens: TokenStream) -> Option<Vec<ParsedMacroArg>> {\n-        let mut iter = tokens.trees();\n+        let mut iter = tokens.into_trees();\n \n         while let Some(tok) = iter.next() {\n             match tok {\n@@ -1083,18 +1083,18 @@ pub(crate) fn convert_try_mac(\n     }\n }\n \n-pub(crate) fn macro_style(mac: &ast::MacCall, context: &RewriteContext<'_>) -> DelimToken {\n+pub(crate) fn macro_style(mac: &ast::MacCall, context: &RewriteContext<'_>) -> Delimiter {\n     let snippet = context.snippet(mac.span());\n     let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());\n     let bracket_pos = snippet.find_uncommented(\"[\").unwrap_or(usize::max_value());\n     let brace_pos = snippet.find_uncommented(\"{\").unwrap_or(usize::max_value());\n \n     if paren_pos < bracket_pos && paren_pos < brace_pos {\n-        DelimToken::Paren\n+        Delimiter::Parenthesis\n     } else if bracket_pos < brace_pos {\n-        DelimToken::Bracket\n+        Delimiter::Bracket\n     } else {\n-        DelimToken::Brace\n+        Delimiter::Brace\n     }\n }\n \n@@ -1174,7 +1174,7 @@ struct Macro {\n // rather than clone them, if we can make the borrowing work out.\n struct MacroBranch {\n     span: Span,\n-    args_paren_kind: DelimToken,\n+    args_paren_kind: Delimiter,\n     args: TokenStream,\n     body: Span,\n     whole_body: Span,\n@@ -1188,7 +1188,7 @@ impl MacroBranch {\n         multi_branch_style: bool,\n     ) -> Option<String> {\n         // Only attempt to format function-like macros.\n-        if self.args_paren_kind != DelimToken::Paren {\n+        if self.args_paren_kind != Delimiter::Parenthesis {\n             // FIXME(#1539): implement for non-sugared macros.\n             return None;\n         }\n@@ -1350,18 +1350,18 @@ fn rewrite_macro_with_items(\n     items: &[MacroArg],\n     macro_name: &str,\n     shape: Shape,\n-    style: DelimToken,\n+    style: Delimiter,\n     position: MacroPosition,\n     span: Span,\n ) -> Option<String> {\n     let (opener, closer) = match style {\n-        DelimToken::Paren => (\"(\", \")\"),\n-        DelimToken::Bracket => (\"[\", \"]\"),\n-        DelimToken::Brace => (\" {\", \"}\"),\n+        Delimiter::Parenthesis => (\"(\", \")\"),\n+        Delimiter::Bracket => (\"[\", \"]\"),\n+        Delimiter::Brace => (\" {\", \"}\"),\n         _ => return None,\n     };\n     let trailing_semicolon = match style {\n-        DelimToken::Paren | DelimToken::Bracket if position == MacroPosition::Item => \";\",\n+        Delimiter::Parenthesis | Delimiter::Bracket if position == MacroPosition::Item => \";\",\n         _ => \"\",\n     };\n "}, {"sha": "81da724329f02edc918bc6eaf5b91e76238dc011", "filename": "src/modules.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -4,7 +4,6 @@ use std::path::{Path, PathBuf};\n \n use rustc_ast::ast;\n use rustc_ast::visit::Visitor;\n-use rustc_ast::AstLike;\n use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::Span;\n use thiserror::Error;\n@@ -50,19 +49,10 @@ impl<'a> Module<'a> {\n             ast_mod_kind,\n         }\n     }\n-}\n \n-impl<'a> AstLike for Module<'a> {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n-    fn attrs(&self) -> &[ast::Attribute] {\n+    pub(crate) fn attrs(&self) -> &[ast::Attribute] {\n         &self.inner_attr\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<ast::Attribute>)) {\n-        f(&mut self.inner_attr)\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<rustc_ast::tokenstream::LazyTokenStream>> {\n-        unimplemented!()\n-    }\n }\n \n /// Maps each module to the corresponding file."}, {"sha": "6bf8cd0c70be0653b5bb4d8904c0d2749925a3c3", "filename": "src/overflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -3,7 +3,7 @@\n use std::cmp::min;\n \n use itertools::Itertools;\n-use rustc_ast::token::DelimToken;\n+use rustc_ast::token::Delimiter;\n use rustc_ast::{ast, ptr};\n use rustc_span::Span;\n \n@@ -297,11 +297,11 @@ pub(crate) fn rewrite_with_square_brackets<'a, T: 'a + IntoOverflowableItem<'a>>\n     shape: Shape,\n     span: Span,\n     force_separator_tactic: Option<SeparatorTactic>,\n-    delim_token: Option<DelimToken>,\n+    delim_token: Option<Delimiter>,\n ) -> Option<String> {\n     let (lhs, rhs) = match delim_token {\n-        Some(DelimToken::Paren) => (\"(\", \")\"),\n-        Some(DelimToken::Brace) => (\"{\", \"}\"),\n+        Some(Delimiter::Parenthesis) => (\"(\", \")\"),\n+        Some(Delimiter::Brace) => (\"{\", \"}\"),\n         _ => (\"[\", \"]\"),\n     };\n     Context::new("}, {"sha": "09b3e32df312d5b026be722102e2e20e526ad1a8", "filename": "src/parse/macros/cfg_if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Fcfg_if.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -1,7 +1,7 @@\n use std::panic::{catch_unwind, AssertUnwindSafe};\n \n use rustc_ast::ast;\n-use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_ast::token::{Delimiter, TokenKind};\n use rustc_parse::parser::ForceCollect;\n use rustc_span::symbol::kw;\n \n@@ -47,11 +47,11 @@ fn parse_cfg_if_inner<'a>(\n                 .map_err(|_| \"Failed to parse attributes\")?;\n         }\n \n-        if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n+        if !parser.eat(&TokenKind::OpenDelim(Delimiter::Brace)) {\n             return Err(\"Expected an opening brace\");\n         }\n \n-        while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n+        while parser.token != TokenKind::CloseDelim(Delimiter::Brace)\n             && parser.token.kind != TokenKind::Eof\n         {\n             let item = match parser.parse_item(ForceCollect::No) {\n@@ -70,7 +70,7 @@ fn parse_cfg_if_inner<'a>(\n             }\n         }\n \n-        if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n+        if !parser.eat(&TokenKind::CloseDelim(Delimiter::Brace)) {\n             return Err(\"Expected a closing brace\");\n         }\n "}, {"sha": "67f3985926e2f0a9af26fd4d0ab6f5bfdd6bd20d", "filename": "src/parse/macros/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fparse%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fparse%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fmacros%2Fmod.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::token::{DelimToken, TokenKind};\n+use rustc_ast::token::{Delimiter, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::{ast, ptr};\n use rustc_parse::parser::{ForceCollect, Parser};\n@@ -79,9 +79,7 @@ fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n     for &keyword in RUST_KW.iter() {\n         if parser.token.is_keyword(keyword)\n             && parser.look_ahead(1, |t| {\n-                t.kind == TokenKind::Eof\n-                    || t.kind == TokenKind::Comma\n-                    || t.kind == TokenKind::CloseDelim(DelimToken::NoDelim)\n+                t.kind == TokenKind::Eof || t.kind == TokenKind::Comma\n             })\n         {\n             parser.bump();\n@@ -97,15 +95,15 @@ fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n pub(crate) fn parse_macro_args(\n     context: &RewriteContext<'_>,\n     tokens: TokenStream,\n-    style: DelimToken,\n+    style: Delimiter,\n     forced_bracket: bool,\n ) -> Option<ParsedMacroArgs> {\n     let mut parser = build_parser(context, tokens);\n     let mut args = Vec::new();\n     let mut vec_with_semi = false;\n     let mut trailing_comma = false;\n \n-    if DelimToken::Brace != style {\n+    if Delimiter::Brace != style {\n         loop {\n             if let Some(arg) = check_keyword(&mut parser) {\n                 args.push(arg);"}, {"sha": "a0f71c2b8ba939325ac09d6d9ade34ac15bca2d6", "filename": "src/parse/session.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparse%2Fsession.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -33,6 +33,12 @@ impl Emitter for SilentEmitter {\n         None\n     }\n     fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        panic!(\"silent emitter attempted to translate a diagnostic\");\n+    }\n }\n \n fn silent_emitter() -> Box<dyn Emitter + Send> {\n@@ -82,6 +88,14 @@ impl Emitter for SilentOnIgnoredFilesEmitter {\n         }\n         self.handle_non_ignoreable_error(db);\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        self.emitter.fluent_bundle()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+        self.emitter.fallback_fluent_bundle()\n+    }\n }\n \n fn default_handler(\n@@ -100,9 +114,13 @@ fn default_handler(\n     let emitter = if hide_parse_errors {\n         silent_emitter()\n     } else {\n+        let fallback_bundle =\n+            rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n         Box::new(EmitterWriter::stderr(\n             color_cfg,\n             Some(source_map.clone()),\n+            None,\n+            fallback_bundle,\n             false,\n             false,\n             None,\n@@ -313,7 +331,8 @@ mod tests {\n         use super::*;\n         use crate::config::IgnoreList;\n         use crate::utils::mk_sp;\n-        use rustc_span::{FileName as SourceMapFileName, MultiSpan, RealFileName};\n+        use rustc_errors::MultiSpan;\n+        use rustc_span::{FileName as SourceMapFileName, RealFileName};\n         use std::path::PathBuf;\n         use std::sync::atomic::AtomicU32;\n \n@@ -328,6 +347,12 @@ mod tests {\n             fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n                 self.num_emitted_errors.fetch_add(1, Ordering::Release);\n             }\n+            fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+                None\n+            }\n+            fn fallback_fluent_bundle(&self) -> &rustc_errors::FluentBundle {\n+                panic!(\"test emitter attempted to translate a diagnostic\");\n+            }\n         }\n \n         fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {"}, {"sha": "58fd95c656e799fafccf22f41a52483495c0ce16", "filename": "src/utils.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n \n use rustc_ast::ast::{\n-    self, Attribute, CrateSugar, MetaItem, MetaItemKind, NestedMetaItem, NodeId, Path, Visibility,\n+    self, Attribute, MetaItem, MetaItemKind, NestedMetaItem, NodeId, Path, Visibility,\n     VisibilityKind,\n };\n use rustc_ast::ptr;\n@@ -44,15 +44,7 @@ pub(crate) fn is_same_visibility(a: &Visibility, b: &Visibility) -> bool {\n             VisibilityKind::Restricted { path: q, .. },\n         ) => pprust::path_to_string(p) == pprust::path_to_string(q),\n         (VisibilityKind::Public, VisibilityKind::Public)\n-        | (VisibilityKind::Inherited, VisibilityKind::Inherited)\n-        | (\n-            VisibilityKind::Crate(CrateSugar::PubCrate),\n-            VisibilityKind::Crate(CrateSugar::PubCrate),\n-        )\n-        | (\n-            VisibilityKind::Crate(CrateSugar::JustCrate),\n-            VisibilityKind::Crate(CrateSugar::JustCrate),\n-        ) => true,\n+        | (VisibilityKind::Inherited, VisibilityKind::Inherited) => true,\n         _ => false,\n     }\n }\n@@ -65,8 +57,6 @@ pub(crate) fn format_visibility(\n     match vis.kind {\n         VisibilityKind::Public => Cow::from(\"pub \"),\n         VisibilityKind::Inherited => Cow::from(\"\"),\n-        VisibilityKind::Crate(CrateSugar::PubCrate) => Cow::from(\"pub(crate) \"),\n-        VisibilityKind::Crate(CrateSugar::JustCrate) => Cow::from(\"crate \"),\n         VisibilityKind::Restricted { ref path, .. } => {\n             let Path { ref segments, .. } = **path;\n             let mut segments_iter = segments.iter().map(|seg| rewrite_ident(context, seg.ident));\n@@ -75,7 +65,7 @@ pub(crate) fn format_visibility(\n                     .next()\n                     .expect(\"Non-global path in pub(restricted)?\");\n             }\n-            let is_keyword = |s: &str| s == \"self\" || s == \"super\";\n+            let is_keyword = |s: &str| s == \"crate\" || s == \"self\" || s == \"super\";\n             let path = segments_iter.collect::<Vec<_>>().join(\"::\");\n             let in_str = if is_keyword(&path) { \"\" } else { \"in \" };\n \n@@ -512,6 +502,7 @@ pub(crate) fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr\n         | ast::ExprKind::Range(..)\n         | ast::ExprKind::Repeat(..)\n         | ast::ExprKind::Ret(..)\n+        | ast::ExprKind::Yeet(..)\n         | ast::ExprKind::Tup(..)\n         | ast::ExprKind::Type(..)\n         | ast::ExprKind::Yield(None)"}, {"sha": "3ff56d52f92d6e813c14fbc210119a4a85dae538", "filename": "src/visitor.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -1,7 +1,7 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_ast::{ast, token::DelimToken, visit, AstLike};\n+use rustc_ast::{ast, token::Delimiter, visit};\n use rustc_data_structures::sync::Lrc;\n use rustc_span::{symbol, BytePos, Pos, Span};\n \n@@ -383,7 +383,6 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     pub(crate) fn visit_fn(\n         &mut self,\n         fk: visit::FnKind<'_>,\n-        generics: &ast::Generics,\n         fd: &ast::FnDecl,\n         s: Span,\n         defaultness: ast::Defaultness,\n@@ -392,12 +391,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         let indent = self.block_indent;\n         let block;\n         let rewrite = match fk {\n-            visit::FnKind::Fn(_, ident, _, _, Some(ref b)) => {\n+            visit::FnKind::Fn(_, ident, _, _, _, Some(ref b)) => {\n                 block = b;\n                 self.rewrite_fn_before_block(\n                     indent,\n                     ident,\n-                    &FnSig::from_fn_kind(&fk, generics, fd, defaultness),\n+                    &FnSig::from_fn_kind(&fk, fd, defaultness),\n                     mk_sp(s.lo(), b.span.lo()),\n                 )\n             }\n@@ -553,8 +552,14 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                             _ => visit::FnCtxt::Foreign,\n                         };\n                         self.visit_fn(\n-                            visit::FnKind::Fn(fn_ctxt, item.ident, sig, &item.vis, Some(body)),\n-                            generics,\n+                            visit::FnKind::Fn(\n+                                fn_ctxt,\n+                                item.ident,\n+                                sig,\n+                                &item.vis,\n+                                generics,\n+                                Some(body),\n+                            ),\n                             &sig.decl,\n                             item.span,\n                             defaultness,\n@@ -643,8 +648,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     let inner_attrs = inner_attributes(&ai.attrs);\n                     let fn_ctxt = visit::FnCtxt::Assoc(assoc_ctxt);\n                     self.visit_fn(\n-                        visit::FnKind::Fn(fn_ctxt, ai.ident, sig, &ai.vis, Some(body)),\n-                        generics,\n+                        visit::FnKind::Fn(fn_ctxt, ai.ident, sig, &ai.vis, generics, Some(body)),\n                         &sig.decl,\n                         ai.span,\n                         defaultness,\n@@ -686,7 +690,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         // with whitespace between the delimiters and trailing semi (i.e. `foo!(abc)     ;`)\n         // are formatted correctly.\n         let (span, rewrite) = match macro_style(mac, &self.get_context()) {\n-            DelimToken::Bracket | DelimToken::Paren if MacroPosition::Item == pos => {\n+            Delimiter::Bracket | Delimiter::Parenthesis if MacroPosition::Item == pos => {\n                 let search_span = mk_sp(mac.span().hi(), self.snippet_provider.end_pos());\n                 let hi = self.snippet_provider.span_before(search_span, \";\");\n                 let target_span = mk_sp(mac.span().lo(), hi + BytePos(1));"}, {"sha": "d26f4ee894fad47e06775b84580d806c16109734", "filename": "tests/source/cfg_if/detect/arch/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -3,7 +3,7 @@\n //! The features are detected using the `detect_features` function below.\n //! This function uses the CPUID instruction to read the feature flags from the\n //! CPU and encodes them in a `usize` where each bit position represents\n-//! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n+//! whether a feature is available (bit is set) or unavailable (bit is cleared).\n //!\n //! The enum `Feature` is used to map bit positions to feature names, and the\n //! the `__crate::detect::check_for!` macro is used to map string literals (e.g.,"}, {"sha": "12a50c013a91f3ccca9dc88084191525b6a6dac8", "filename": "tests/source/fn-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Fsource%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Fsource%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ffn-simple.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -63,7 +63,7 @@ mod foo {\n // #2082\n pub(crate) fn init() {}\n \n-crate fn init() {}\n+pub(crate) fn init() {}\n \n // #2630\n fn make_map<T, F: (Fn(&T) -> String)>(records: &Vec<T>, key_fn: F) -> HashMap<String, usize> {}"}, {"sha": "5683acbf3aa936dd622a536906c06a6faf9a9d39", "filename": "tests/source/pub-restricted.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Fsource%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Fsource%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fpub-restricted.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -24,19 +24,6 @@ pub(  crate  ) enum WriteState<D> {\n     WriteData(Writer<D>),\n }\n \n-  crate   enum WriteState<D> {\n-    WriteId {\n-        id: U64Writer,\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteSize {\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteData(Writer<D>),\n-}\n-\n pub(in  ::global::  path :: to::some_mod  ) enum WriteState<D> {\n     WriteId {\n         id: U64Writer,"}, {"sha": "02d5eed1c2923ce759f98ebc7e9869f99f4dca0a", "filename": "tests/target/cfg_if/detect/arch/x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -3,7 +3,7 @@\n //! The features are detected using the `detect_features` function below.\n //! This function uses the CPUID instruction to read the feature flags from the\n //! CPU and encodes them in a `usize` where each bit position represents\n-//! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n+//! whether a feature is available (bit is set) or unavailable (bit is cleared).\n //!\n //! The enum `Feature` is used to map bit positions to feature names, and the\n //! the `__crate::detect::check_for!` macro is used to map string literals (e.g.,"}, {"sha": "e725269360d2cf23b8c4fd6b162e72bf74be7c47", "filename": "tests/target/fn-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Ftarget%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Ftarget%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-simple.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -105,7 +105,7 @@ mod foo {\n // #2082\n pub(crate) fn init() {}\n \n-crate fn init() {}\n+pub(crate) fn init() {}\n \n // #2630\n fn make_map<T, F: (Fn(&T) -> String)>(records: &Vec<T>, key_fn: F) -> HashMap<String, usize> {}"}, {"sha": "0e178ef10136e3965f7185ef1998b329b5982da5", "filename": "tests/target/pub-restricted.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Ftarget%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75786fb0b707a9a4938ee31b916762c1a3eae09d/tests%2Ftarget%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpub-restricted.rs?ref=75786fb0b707a9a4938ee31b916762c1a3eae09d", "patch": "@@ -24,19 +24,6 @@ pub(crate) enum WriteState<D> {\n     WriteData(Writer<D>),\n }\n \n-crate enum WriteState<D> {\n-    WriteId {\n-        id: U64Writer,\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteSize {\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteData(Writer<D>),\n-}\n-\n pub(in global::path::to::some_mod) enum WriteState<D> {\n     WriteId {\n         id: U64Writer,"}]}