{"sha": "f2cf9944831f15b1940da85c8fb1b419dec9f074", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyY2Y5OTQ0ODMxZjE1YjE5NDBkYTg1YzhmYjFiNDE5ZGVjOWYwNzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-05-19T01:09:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2020-06-22T14:33:44Z"}, "message": "rewrite leak check to be based on universes\n\nIn the new leak check, instead of getting a list of placeholders to\ntrack, we look for any placeholder that is part of a universe which\nwas created during the snapshot.\n\nWe are looking for the following error patterns:\n\n* P1: P2, where P1 != P2\n* P1: R, where R is in some universe that cannot name P1\n\nThis new leak check is more precise than before, in that it accepts\nthis patterns:\n\n* R: P1, even if R cannot name P1, because R = 'static is a valid\nsol'n\n* R: P1, R: P2, as above\n\nNote that this leak check, when running during subtyping, is less\nefficient than before in some sense because it is going to check and\nre-check all the universes created since the snapshot. We're going to\nmove when the leak check runs to try and correct that.", "tree": {"sha": "d7f255b1b039ca14ef42a048ede6fc83da60275a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7f255b1b039ca14ef42a048ede6fc83da60275a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2cf9944831f15b1940da85c8fb1b419dec9f074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2cf9944831f15b1940da85c8fb1b419dec9f074", "html_url": "https://github.com/rust-lang/rust/commit/f2cf9944831f15b1940da85c8fb1b419dec9f074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2cf9944831f15b1940da85c8fb1b419dec9f074/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4199b3ae26007eb9c871b57f56057da586bbd1db", "url": "https://api.github.com/repos/rust-lang/rust/commits/4199b3ae26007eb9c871b57f56057da586bbd1db", "html_url": "https://github.com/rust-lang/rust/commit/4199b3ae26007eb9c871b57f56057da586bbd1db"}], "stats": {"total": 890, "additions": 571, "deletions": 319}, "files": [{"sha": "b94221785ae755b4a15dd4d32239dab74b0207df", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         self.infcx.commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n-            let (b_prime, placeholder_map) = self.infcx.replace_bound_vars_with_placeholders(b);\n+            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(b);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n             // Compare types now that bound regions have been replaced.\n             let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n-            self.infcx.leak_check(!a_is_expected, &placeholder_map, snapshot)?;\n+            self.infcx.leak_check(!a_is_expected, snapshot)?;\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n@@ -119,7 +119,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn leak_check(\n         &self,\n         overly_polymorphic: bool,\n-        placeholder_map: &PlaceholderMap<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n         // If the user gave `-Zno-leak-check`, or we have been\n@@ -135,7 +134,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n             overly_polymorphic,\n-            placeholder_map,\n+            self.universe(),\n             snapshot,\n         )\n     }"}, {"sha": "0e569be34aa66dc0ce7258236fdd22f88944205d", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -992,12 +992,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         Some(self.commit_if_ok(|snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n+            let (ty::SubtypePredicate { a_is_expected, a, b }, _) =\n                 self.replace_bound_vars_with_placeholders(&predicate);\n \n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n \n-            self.leak_check(false, &placeholder_map, snapshot)?;\n+            self.leak_check(false, snapshot)?;\n \n             Ok(ok.unit())\n         }))\n@@ -1009,13 +1009,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         predicate: ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n+            let (ty::OutlivesPredicate(r_a, r_b), _) =\n                 self.replace_bound_vars_with_placeholders(&predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, &placeholder_map, snapshot)?;\n+            self.leak_check(false, snapshot)?;\n             Ok(())\n         })\n     }"}, {"sha": "f3b78909b42d890328127eadb47c3df349145365", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 404, "deletions": 117, "changes": 521, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,158 +1,445 @@\n use super::*;\n-use crate::infer::{CombinedSnapshot, PlaceholderMap};\n-use rustc_data_structures::undo_log::UndoLogs;\n+use crate::infer::CombinedSnapshot;\n+use rustc_data_structures::{\n+    graph::{scc::Sccs, vec_graph::VecGraph},\n+    undo_log::UndoLogs,\n+};\n+use rustc_index::vec::Idx;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::RelateResult;\n \n impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n-    /// Searches region constraints created since `snapshot` that\n-    /// affect one of the placeholders in `placeholder_map`, returning\n-    /// an error if any of the placeholders are related to another\n-    /// placeholder or would have to escape into some parent universe\n-    /// that cannot name them.\n+    /// Searches new universes created during `snapshot`, looking for\n+    /// placeholders that may \"leak\" out from the universes they are contained\n+    /// in. If any leaking placeholders are found, then an `Err` is returned\n+    /// (typically leading to the snapshot being reversed).\n     ///\n-    /// This is a temporary backwards compatibility measure to try and\n-    /// retain the older (arguably incorrect) behavior of the\n-    /// compiler.\n+    /// The leak check *used* to be the only way we had to handle higher-ranked\n+    /// obligations. Now that we have integrated universes into the region\n+    /// solvers, this is no longer the case, but we retain the leak check for\n+    /// backwards compatibility purposes. In particular, it lets us make \"early\"\n+    /// decisions about whether a region error will be reported that are used in\n+    /// coherence and elsewhere -- see #56105 and #59490 for more details. The\n+    /// eventual fate of the leak checker is not yet settled.\n     ///\n-    /// NB. Although `_snapshot` isn't used, it's passed in to prove\n-    /// that we are in a snapshot, which guarantees that we can just\n-    /// search the \"undo log\" for edges. This is mostly an efficiency\n-    /// thing -- we could search *all* region constraints, but that'd be\n-    /// a bigger set and the data structures are not setup for that. If\n-    /// we wind up keeping some form of this check long term, it would\n-    /// probably be better to remove the snapshot parameter and to\n-    /// refactor the constraint set.\n+    /// The leak checker works by searching for the following error patterns:\n+    ///\n+    /// * P1: P2, where P1 != P2\n+    /// * P1: R, where R is in some universe that cannot name P1\n+    ///\n+    /// The idea here is that each of these patterns represents something that\n+    /// the region solver would eventually report as an error, so we can detect\n+    /// the error early. There is a fly in the ointment, though, in that this is\n+    /// not entirely true. In particular, in the future, we may extend the\n+    /// environment with implied bounds or other info about how placeholders\n+    /// relate to regions in outer universes. In that case, `P1: R` for example\n+    /// might become solveable.\n+    ///\n+    /// # Summary of the implementation\n+    ///\n+    /// The leak checks as follows. First, we construct a graph where `R2: R1`\n+    /// implies `R2 -> R1`, and we compute the SCCs.\n+    ///\n+    /// For each SCC S, we compute:\n+    ///\n+    /// * what placeholder P it must be equal to, if any\n+    ///   * if there are multiple placeholders that must be equal, report an error because `P1: P2`\n+    /// * the minimum universe of its constituents\n+    ///\n+    /// Then we walk the SCCs in dependency order and compute\n+    ///\n+    /// * what placeholder they must outlive transitively\n+    ///   * if they must also be equal to a placeholder, report an error because `P1: P2`\n+    /// * minimum universe U of all SCCs they must outlive\n+    ///   * if they must also be equal to a placeholder P, and U cannot name P, report an error, as that\n+    ///     indicates `P: R` and `R` is in an incompatible universe\n+    ///\n+    /// # Historical note\n+    ///\n+    /// Older variants of the leak check used to report errors for these\n+    /// patterns, but we no longer do:\n+    ///\n+    /// * R: P1, even if R cannot name P1, because R = 'static is a valid sol'n\n+    /// * R: P1, R: P2, as above\n     pub fn leak_check(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         overly_polymorphic: bool,\n-        placeholder_map: &PlaceholderMap<'tcx>,\n-        _snapshot: &CombinedSnapshot<'_, 'tcx>,\n+        max_universe: ty::UniverseIndex,\n+        snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n-        debug!(\"leak_check(placeholders={:?})\", placeholder_map);\n+        debug!(\n+            \"leak_check(max_universe={:?}, snapshot.universe={:?}, overly_polymorphic={:?})\",\n+            max_universe, snapshot.universe, overly_polymorphic\n+        );\n \n         assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n \n-        // Go through each placeholder that we created.\n-        for &placeholder_region in placeholder_map.values() {\n-            // Find the universe this placeholder inhabits.\n-            let placeholder = match placeholder_region {\n-                ty::RePlaceholder(p) => p,\n-                _ => bug!(\"leak_check: expected placeholder found {:?}\", placeholder_region,),\n-            };\n-\n-            // Find all regions that are related to this placeholder\n-            // in some way. This means any region that either outlives\n-            // or is outlived by a placeholder.\n-            let mut taint_set = TaintSet::new(TaintDirections::both(), placeholder_region);\n-            taint_set.fixed_point(\n-                tcx,\n-                self.undo_log.region_constraints(),\n-                &self.storage.data.verifys,\n-            );\n-            let tainted_regions = taint_set.into_set();\n-\n-            // Report an error if two placeholders in the same universe\n-            // are related to one another, or if a placeholder is related\n-            // to something from a parent universe.\n-            for &tainted_region in &tainted_regions {\n-                if let ty::RePlaceholder(_) = tainted_region {\n-                    // Two placeholders cannot be related:\n-                    if tainted_region == placeholder_region {\n-                        continue;\n-                    }\n-                } else if self.universe(tainted_region).can_name(placeholder.universe) {\n-                    continue;\n-                }\n-\n-                return Err(if overly_polymorphic {\n-                    debug!(\"overly polymorphic!\");\n-                    TypeError::RegionsOverlyPolymorphic(placeholder.name, tainted_region)\n-                } else {\n-                    debug!(\"not as polymorphic!\");\n-                    TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, tainted_region)\n-                });\n-            }\n+        let universe_at_start_of_snapshot = snapshot.universe;\n+        if universe_at_start_of_snapshot == max_universe {\n+            return Ok(());\n         }\n \n+        let mini_graph =\n+            &MiniGraph::new(tcx, self.undo_log.region_constraints(), &self.storage.data.verifys);\n+\n+        let mut leak_check = LeakCheck::new(\n+            tcx,\n+            universe_at_start_of_snapshot,\n+            max_universe,\n+            overly_polymorphic,\n+            mini_graph,\n+            self,\n+        );\n+        leak_check.assign_placeholder_values()?;\n+        leak_check.propagate_scc_value()?;\n         Ok(())\n     }\n }\n \n-#[derive(Debug)]\n-struct TaintSet<'tcx> {\n-    directions: TaintDirections,\n-    regions: FxHashSet<ty::Region<'tcx>>,\n+struct LeakCheck<'me, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    universe_at_start_of_snapshot: ty::UniverseIndex,\n+    overly_polymorphic: bool,\n+    mini_graph: &'me MiniGraph<'tcx>,\n+    rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n+\n+    // Initially, for each SCC S, stores a placeholder `P` such that `S = P`\n+    // must hold.\n+    //\n+    // Later, during the [`LeakCheck::propagate_scc_value`] function, this array\n+    // is repurposed to store some placeholder `P` such that the weaker\n+    // condition `S: P` must hold. (This is true if `S: S1` transitively and `S1\n+    // = P`.)\n+    scc_placeholders: IndexVec<LeakCheckScc, Option<ty::PlaceholderRegion>>,\n+\n+    // For each SCC S, track the minimum universe that flows into it. Note that\n+    // this is both the minimum of the universes for every region that is a\n+    // member of the SCC, but also if you have `R1: R2`, then the universe of\n+    // `R2` must be less than the universe of `R1` (i.e., `R1` flows `R2`). To\n+    // see that, imagine that you have `P1: R` -- in that case, `R` must be\n+    // either the placeholder `P1` or the empty region in that same universe.\n+    //\n+    // To detect errors, we look for an SCC S where the values in\n+    // `scc_values[S]` (if any) cannot be stored into `scc_universes[S]`.\n+    scc_universes: IndexVec<LeakCheckScc, SccUniverse<'tcx>>,\n }\n \n-impl<'tcx> TaintSet<'tcx> {\n-    fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n-        let mut regions = FxHashSet::default();\n-        regions.insert(initial_region);\n-        TaintSet { directions, regions }\n+impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        universe_at_start_of_snapshot: ty::UniverseIndex,\n+        max_universe: ty::UniverseIndex,\n+        overly_polymorphic: bool,\n+        mini_graph: &'me MiniGraph<'tcx>,\n+        rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n+    ) -> Self {\n+        let dummy_scc_universe = SccUniverse { universe: max_universe, region: None };\n+        Self {\n+            tcx,\n+            universe_at_start_of_snapshot,\n+            overly_polymorphic,\n+            mini_graph,\n+            rcc,\n+            scc_placeholders: IndexVec::from_elem_n(None, mini_graph.sccs.num_sccs()),\n+            scc_universes: IndexVec::from_elem_n(dummy_scc_universe, mini_graph.sccs.num_sccs()),\n+        }\n+    }\n+\n+    /// Compute what placeholders (if any) each SCC must be equal to.\n+    /// Also compute the minimum universe of all the regions in each SCC.\n+    fn assign_placeholder_values(&mut self) -> RelateResult<'tcx, ()> {\n+        // First walk: find each placeholder that is from a newly created universe.\n+        for (region, leak_check_node) in &self.mini_graph.nodes {\n+            let scc = self.mini_graph.sccs.scc(*leak_check_node);\n+\n+            // Set the universe of each SCC to be the minimum of its constituent universes\n+            let universe = self.rcc.universe(region);\n+            debug!(\n+                \"assign_placeholder_values: scc={:?} universe={:?} region={:?}\",\n+                scc, universe, region\n+            );\n+            self.scc_universes[scc].take_min(universe, region);\n+\n+            // Detect those SCCs that directly contain a placeholder\n+            if let ty::RePlaceholder(placeholder) = region {\n+                if self.universe_at_start_of_snapshot.cannot_name(placeholder.universe) {\n+                    self.assign_scc_value(scc, *placeholder)?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n     }\n \n-    fn fixed_point<'a>(\n+    // assign_scc_value(S, P): Update `scc_values` to account for the fact that `P: S` must hold.\n+    // This may create an error.\n+    fn assign_scc_value(\n         &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        undo_log: impl IntoIterator<Item = &'a UndoLog<'tcx>> + Clone,\n-        verifys: &[Verify<'tcx>],\n-    ) where\n-        'tcx: 'a,\n-    {\n-        let mut prev_len = 0;\n-        while prev_len < self.len() {\n-            debug!(\"tainted: prev_len = {:?} new_len = {:?}\", prev_len, self.len());\n-\n-            prev_len = self.len();\n-\n-            for undo_entry in undo_log.clone() {\n-                match undo_entry {\n-                    &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::RegSubVar(a, b)) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddConstraint(Constraint::VarSubReg(a, b)) => {\n-                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n-                    }\n-                    &AddConstraint(Constraint::RegSubReg(a, b)) => {\n-                        self.add_edge(a, b);\n-                    }\n-                    &AddGiven(a, b) => {\n-                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n-                    }\n-                    &AddVerify(i) => span_bug!(\n-                        verifys[i].origin.span(),\n-                        \"we never add verifications while doing higher-ranked things\",\n-                    ),\n-                    &AddCombination(..) | &AddVar(..) => {}\n+        scc: LeakCheckScc,\n+        placeholder: ty::PlaceholderRegion,\n+    ) -> RelateResult<'tcx, ()> {\n+        match self.scc_placeholders[scc] {\n+            Some(p) => {\n+                assert_ne!(p, placeholder);\n+                return Err(self.placeholder_error(p, placeholder));\n+            }\n+            None => {\n+                self.scc_placeholders[scc] = Some(placeholder);\n+            }\n+        };\n+\n+        Ok(())\n+    }\n+\n+    /// For each SCC S, iterate over each successor S1 where `S: S1`:\n+    ///\n+    /// * Compute\n+    /// Iterate over each SCC `S` and ensure that, for each `S1` where `S1: S`,\n+    /// `universe(S) <= universe(S1)`. This executes after\n+    /// `assign_placeholder_values`, so `universe(S)` is already the minimum\n+    /// universe of any of its direct constituents.\n+    fn propagate_scc_value(&mut self) -> RelateResult<'tcx, ()> {\n+        // Loop invariants:\n+        //\n+        // On start of the loop iteration for `scc1`:\n+        //\n+        // * `scc_universes[scc1]` contains the minimum universe of the\n+        //   constituents of `scc1`\n+        // * `scc_placeholder[scc1]` stores the placeholder that `scc1` must\n+        //   be equal to (if any)\n+        //\n+        // For each succssor `scc2` where `scc1: scc2`:\n+        //\n+        // * `scc_placeholder[scc2]` stores some placeholder `P` where\n+        //   `scc2: P` (if any)\n+        // * `scc_universes[scc2]` contains the minimum universe of the\n+        //   constituents of `scc2` and any of its successors\n+        for scc1 in self.mini_graph.sccs.all_sccs() {\n+            debug!(\n+                \"propagate_scc_value: scc={:?} with universe {:?}\",\n+                scc1, self.scc_universes[scc1]\n+            );\n+\n+            // Walk over each `scc2` such that `scc1: scc2` and compute:\n+            //\n+            // * `scc1_universe`: the minimum universe of `scc2` and the constituents of `scc1`\n+            // * `succ_bound`: placeholder `P` that the successors must outlive, if any (if there are multiple,\n+            //   we pick one arbitrarily)\n+            let mut scc1_universe = self.scc_universes[scc1];\n+            let mut succ_bound = None;\n+            for &scc2 in self.mini_graph.sccs.successors(scc1) {\n+                let SccUniverse { universe: scc2_universe, region: scc2_region } =\n+                    self.scc_universes[scc2];\n+\n+                scc1_universe.take_min(scc2_universe, scc2_region.unwrap());\n+\n+                if let Some(b) = self.scc_placeholders[scc2] {\n+                    succ_bound = Some(b);\n                 }\n             }\n+\n+            // Update minimum universe of scc1.\n+            self.scc_universes[scc1] = scc1_universe;\n+\n+            // At this point, `scc_placholder[scc1]` stores the placeholder that\n+            // `scc1` must be equal to, if any.\n+            if let Some(scc1_placeholder) = self.scc_placeholders[scc1] {\n+                debug!(\n+                    \"propagate_scc_value: scc1={:?} placeholder={:?} scc1_universe={:?}\",\n+                    scc1, scc1_placeholder, scc1_universe\n+                );\n+\n+                // Check if `P1: R` for some `R` in a universe that cannot name\n+                // P1. That's an error.\n+                if scc1_universe.universe.cannot_name(scc1_placeholder.universe) {\n+                    return Err(self.error(scc1_placeholder, scc1_universe.region.unwrap()));\n+                }\n+\n+                // Check if we have some placeholder where `S: P2`\n+                // (transitively). In that case, since `S = P1`, that implies\n+                // `P1: P2`, which is an error condition.\n+                if let Some(scc2_placeholder) = succ_bound {\n+                    assert_ne!(scc1_placeholder, scc2_placeholder);\n+                    return Err(self.placeholder_error(scc1_placeholder, scc2_placeholder));\n+                }\n+            } else {\n+                // Otherwise, we can reach a placeholder if some successor can.\n+                self.scc_placeholders[scc1] = succ_bound;\n+            }\n+\n+            // At this point, `scc_placeholder[scc1]` stores some placeholder that `scc1` must outlive (if any).\n         }\n+        Ok(())\n     }\n \n-    fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n-        self.regions\n+    fn placeholder_error(\n+        &self,\n+        placeholder1: ty::PlaceholderRegion,\n+        placeholder2: ty::PlaceholderRegion,\n+    ) -> TypeError<'tcx> {\n+        self.error(placeholder1, self.tcx.mk_region(ty::RePlaceholder(placeholder2)))\n     }\n \n-    fn len(&self) -> usize {\n-        self.regions.len()\n+    fn error(\n+        &self,\n+        placeholder: ty::PlaceholderRegion,\n+        other_region: ty::Region<'tcx>,\n+    ) -> TypeError<'tcx> {\n+        if self.overly_polymorphic {\n+            return TypeError::RegionsOverlyPolymorphic(placeholder.name, other_region);\n+        } else {\n+            return TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, other_region);\n+        }\n     }\n+}\n \n-    fn add_edge(&mut self, source: ty::Region<'tcx>, target: ty::Region<'tcx>) {\n-        if self.directions.incoming {\n-            if self.regions.contains(&target) {\n-                self.regions.insert(source);\n-            }\n+// States we need to distinguish:\n+//\n+// * must be equal to a placeholder (i.e., a placeholder is in the SCC)\n+//     * it could conflict with some other regions in the SCC in different universes\n+//     * or a different placeholder\n+// * `P1: S` and `S` must be equal to a placeholder\n+// * `P1: S` and `S` is in an incompatible universe\n+//\n+// So if we\n+//\n+// (a) compute which placeholder (if any) each SCC must be equal to\n+// (b) compute its minimum universe\n+// (c) compute *some* placeholder where `S: P1` (any one will do)\n+//\n+// then we get an error if:\n+//\n+// - it must be equal to a placeholder `P1` and minimum universe cannot name `P1`\n+// - `S: P1` and minimum universe cannot name `P1`\n+// - `S: P1` and we must be equal to `P2`\n+//\n+// So we want to track:\n+//\n+// * Equal placeholder (if any)\n+// * Some bounding placeholder (if any)\n+// * Minimum universe\n+//\n+// * We compute equal placeholder + minimum universe of constituents in first pass\n+// * Then we walk in order and compute from our dependencies `S1` where `S: S1` (`S -> S1`)\n+//   * bounding placeholder (if any)\n+//   * minimum universe\n+// * And if we must be equal to a placeholder then we check it against\n+//   * minimum universe\n+//   * no bounding placeholder\n+\n+/// Tracks the \"minimum universe\" for each SCC, along with some region that\n+/// caused it to change.\n+#[derive(Copy, Clone, Debug)]\n+struct SccUniverse<'tcx> {\n+    /// For some SCC S, the minimum universe of:\n+    ///\n+    /// * each region R in S\n+    /// * each SCC S1 such that S: S1\n+    universe: ty::UniverseIndex,\n+\n+    /// Some region that caused `universe` to be what it is.\n+    region: Option<ty::Region<'tcx>>,\n+}\n+\n+impl<'tcx> SccUniverse<'tcx> {\n+    /// If `universe` is less than our current universe, then update\n+    /// `self.universe` and `self.region`.\n+    fn take_min(&mut self, universe: ty::UniverseIndex, region: ty::Region<'tcx>) {\n+        if universe < self.universe || self.region.is_none() {\n+            self.universe = universe;\n+            self.region = Some(region);\n         }\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    struct LeakCheckNode {\n+        DEBUG_FORMAT = \"LeakCheckNode({})\"\n+    }\n+}\n \n-        if self.directions.outgoing {\n-            if self.regions.contains(&source) {\n-                self.regions.insert(target);\n+rustc_index::newtype_index! {\n+    struct LeakCheckScc {\n+        DEBUG_FORMAT = \"LeakCheckScc({})\"\n+    }\n+}\n+\n+/// Represents the graph of constraints. For each `R1: R2` constraint we create\n+/// an edge `R1 -> R2` in the graph.\n+struct MiniGraph<'tcx> {\n+    /// Map from a region to the index of the node in the graph.\n+    nodes: FxHashMap<ty::Region<'tcx>, LeakCheckNode>,\n+\n+    /// Map from node index to SCC, and stores the successors of each SCC. All\n+    /// the regions in the same SCC are equal to one another, and if `S1 -> S2`,\n+    /// then `S1: S2`.\n+    sccs: Sccs<LeakCheckNode, LeakCheckScc>,\n+}\n+\n+impl<'tcx> MiniGraph<'tcx> {\n+    fn new<'a>(\n+        tcx: TyCtxt<'tcx>,\n+        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n+        verifys: &[Verify<'tcx>],\n+    ) -> Self\n+    where\n+        'tcx: 'a,\n+    {\n+        let mut nodes = FxHashMap::default();\n+        let mut edges = Vec::new();\n+\n+        // Note that if `R2: R1`, we get a callback `r1, r2`, so `target` is first parameter.\n+        Self::iterate_undo_log(tcx, undo_log, verifys, |target, source| {\n+            let source_node = Self::add_node(&mut nodes, source);\n+            let target_node = Self::add_node(&mut nodes, target);\n+            edges.push((source_node, target_node));\n+        });\n+        let graph = VecGraph::new(nodes.len(), edges);\n+        let sccs = Sccs::new(&graph);\n+        Self { nodes, sccs }\n+    }\n+\n+    /// Invokes `each_edge(R1, R2)` for each edge where `R2: R1`\n+    fn iterate_undo_log<'a>(\n+        tcx: TyCtxt<'tcx>,\n+        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n+        verifys: &[Verify<'tcx>],\n+        mut each_edge: impl FnMut(ty::Region<'tcx>, ty::Region<'tcx>),\n+    ) where\n+        'tcx: 'a,\n+    {\n+        for undo_entry in undo_log {\n+            match undo_entry {\n+                &AddConstraint(Constraint::VarSubVar(a, b)) => {\n+                    each_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n+                }\n+                &AddConstraint(Constraint::RegSubVar(a, b)) => {\n+                    each_edge(a, tcx.mk_region(ReVar(b)));\n+                }\n+                &AddConstraint(Constraint::VarSubReg(a, b)) => {\n+                    each_edge(tcx.mk_region(ReVar(a)), b);\n+                }\n+                &AddConstraint(Constraint::RegSubReg(a, b)) => {\n+                    each_edge(a, b);\n+                }\n+                &AddGiven(a, b) => {\n+                    each_edge(a, tcx.mk_region(ReVar(b)));\n+                }\n+                &AddVerify(i) => span_bug!(\n+                    verifys[i].origin.span(),\n+                    \"we never add verifications while doing higher-ranked things\",\n+                ),\n+                &AddCombination(..) | &AddVar(..) => {}\n             }\n         }\n     }\n+\n+    fn add_node(\n+        nodes: &mut FxHashMap<ty::Region<'tcx>, LeakCheckNode>,\n+        r: ty::Region<'tcx>,\n+    ) -> LeakCheckNode {\n+        let l = nodes.len();\n+        *nodes.entry(r).or_insert(LeakCheckNode::new(l))\n+    }\n }"}, {"sha": "0f3f3db8679596d1e7ab990c2ccdf6a4fd7fdee2", "filename": "src/librustc_infer/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -16,6 +16,9 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_fn)]\n+#![feature(const_if_match)]\n+#![feature(const_panic)]\n #![feature(extend_one)]\n #![feature(never_type)]\n #![feature(or_patterns)]"}, {"sha": "4bc58fbaadcda8b516fd265b3f7f9655281d04c8", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -150,14 +150,12 @@ pub fn poly_project_and_unify_type<'cx, 'tcx>(\n \n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n-        let (placeholder_predicate, placeholder_map) =\n+        let (placeholder_predicate, _) =\n             infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n \n         let placeholder_obligation = obligation.with(placeholder_predicate);\n         let result = project_and_unify_type(selcx, &placeholder_obligation)?;\n-        infcx\n-            .leak_check(false, &placeholder_map, snapshot)\n-            .map_err(|err| MismatchedProjectionTypes { err })?;\n+        infcx.leak_check(false, snapshot).map_err(|err| MismatchedProjectionTypes { err })?;\n         Ok(result)\n     })\n }\n@@ -300,7 +298,11 @@ impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n     fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n         let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n-        if !value.has_projections() { value } else { value.fold_with(self) }\n+        if !value.has_projections() {\n+            value\n+        } else {\n+            value.fold_with(self)\n+        }\n     }\n }\n "}, {"sha": "e90acbbce67ba17643d3674309e03ff7463f6a12", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -21,7 +21,7 @@ use super::{Normalized, ProjectionCacheKey};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{Overflow, SelectionError, Unimplemented};\n \n-use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, PlaceholderMap, TypeFreshener};\n+use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::project::ProjectionCacheKeyExt;\n use rustc_ast::attr;\n@@ -1265,7 +1265,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> bool {\n         let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n-        let (placeholder_trait_predicate, placeholder_map) =\n+        let (placeholder_trait_predicate, _) =\n             self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n@@ -1297,7 +1297,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         obligation,\n                         bound,\n                         placeholder_trait_predicate.trait_ref,\n-                        &placeholder_map,\n                         snapshot,\n                     )\n                 }) {\n@@ -1320,7 +1319,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     obligation,\n                     bound,\n                     placeholder_trait_predicate.trait_ref,\n-                    &placeholder_map,\n                     snapshot,\n                 );\n \n@@ -1335,15 +1333,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n         placeholder_trait_ref: ty::TraitRef<'tcx>,\n-        placeholder_map: &PlaceholderMap<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> bool {\n         debug_assert!(!placeholder_trait_ref.has_escaping_bound_vars());\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .is_ok()\n-            && self.infcx.leak_check(false, placeholder_map, snapshot).is_ok()\n+            && self.infcx.leak_check(false, snapshot).is_ok()\n     }\n \n     fn evaluate_where_clause<'o>(\n@@ -1837,7 +1834,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        let (placeholder_obligation, placeholder_map) =\n+        let (placeholder_obligation, _) =\n             self.infcx().replace_bound_vars_with_placeholders(&obligation.predicate);\n         let placeholder_obligation_trait_ref = placeholder_obligation.trait_ref;\n \n@@ -1869,7 +1866,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n         nested_obligations.extend(obligations);\n \n-        if let Err(e) = self.infcx.leak_check(false, &placeholder_map, snapshot) {\n+        if let Err(e) = self.infcx.leak_check(false, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n         }\n@@ -2405,7 +2402,11 @@ impl<'o, 'tcx> TraitObligationStackList<'o, 'tcx> {\n     }\n \n     fn depth(&self) -> usize {\n-        if let Some(head) = self.head { head.depth } else { 0 }\n+        if let Some(head) = self.head {\n+            head.depth\n+        } else {\n+            0\n+        }\n     }\n }\n "}, {"sha": "50f1d07142f8c8ee18f43bd8411c0be3e326acba", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -49,7 +49,7 @@ LL |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'x isize>\n    |                                                           ------------- required by this bound in `tuple_one`\n ...\n LL |     tuple_one::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n+   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'y, found concrete lifetime\n \n error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n   --> $DIR/associated-types-eq-hr.rs:97:17\n@@ -74,7 +74,7 @@ LL |     where T : for<'x,'y> TheTrait<(&'x isize, &'y isize), A = &'y isize>\n    |                                                           ------------- required by this bound in `tuple_two`\n ...\n LL |     tuple_two::<Tuple>();\n-   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'x, found concrete lifetime\n+   |     ^^^^^^^^^^^^^^^^^^ expected bound lifetime parameter 'y, found concrete lifetime\n \n error[E0277]: the trait bound `for<'x, 'y> Tuple: TheTrait<(&'x isize, &'y isize)>` is not satisfied\n   --> $DIR/associated-types-eq-hr.rs:107:18"}, {"sha": "1da224a3e85e090fb4df252402381bcefd25d02b", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n ...\n LL | / check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n-LL | |                                             for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n-   | |_________________________________________________________________________________________- in this macro invocation\n+LL | | for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n+   | |_____________________________________________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32>`\n               found enum `std::option::Option<for<'a> fn(&'a u32, &'a u32) -> &'a u32>`"}, {"sha": "880a8c7be8305d3e3f1426a44a0a40c86f9b6ed0", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_vs_bound_a.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n ...\n LL | / check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n-LL | |                                 for<'a>    fn(&'a u32, &'a u32)) }\n-   | |__________________________________________________________________- in this macro invocation\n+LL | | for<'a>    fn(&'a u32, &'a u32)) }\n+   | |__________________________________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(&'a u32, &'b u32)>`\n               found enum `std::option::Option<for<'a> fn(&'a u32, &'a u32)>`"}, {"sha": "0cc30e479c7b9ace3702125858f51407ee3b0460", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_a.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_a.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:104:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "0cc30e479c7b9ace3702125858f51407ee3b0460", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_bound_b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_bound_b.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:104:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "d2abcc4a66091d7800655a40411949384180ebe3", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_free_x.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n ...\n LL | / check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n-LL | |                              fn(&'x u32)) }\n-   | |___________________________________________- in this macro invocation\n+LL | | fn(&'x u32)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a> fn(&'a u32)>`\n               found enum `std::option::Option<fn(&'x u32)>`"}, {"sha": "0cc30e479c7b9ace3702125858f51407ee3b0460", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,17 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/hr-subtype.rs:104:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),\n-LL | |                                       for<'a>    fn(Co<'a>, Co<'a>)) }\n-   | |______________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected enum `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>)>`\n-              found enum `std::option::Option<for<'a> fn(Co<'a>, Co<'a>)>`\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / fn main() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "0cc30e479c7b9ace3702125858f51407ee3b0460", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,17 +1,14 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+error: fatal error triggered by #[rustc_error]\n+  --> $DIR/hr-subtype.rs:104:1\n    |\n-LL |               gimme::<$t1>(None::<$t2>);\n-   |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n-...\n-LL | / check! { bound_co_a_co_b_ret_contra_a: (for<'a,'b> fn(Co<'a>, Co<'b>) -> Contra<'a>,\n-LL | |                                         for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n-   | |______________________________________________________________________________________- in this macro invocation\n-   |\n-   = note: expected enum `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>) -> Contra<'a>>`\n-              found enum `std::option::Option<for<'a> fn(Co<'a>, Co<'a>) -> Contra<'a>>`\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL | / fn main() {\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "0cc30e479c7b9ace3702125858f51407ee3b0460", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_vs_bound_co_b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_vs_bound_co_b.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:104:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "e1a16f5149cc6069d241a1a8f5a94ce2021e60ee", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n ...\n LL | / check! { bound_contra_a_contra_b_ret_co_a: (for<'a,'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>,\n-LL | |                                             for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n-   | |______________________________________________________________________________________________- in this macro invocation\n+LL | | for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n+   | |__________________________________________________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>>`\n               found enum `std::option::Option<for<'a> fn(Contra<'a>, Contra<'a>) -> Co<'a>>`"}, {"sha": "5fec1e9a92eaecbee6332c74d0b6ac80062223fa", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,12 +1,12 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ expected concrete lifetime, found bound lifetime parameter 'a\n ...\n LL | / check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n-LL | |                                         for<'a>    fn(Inv<'a>, Inv<'a>)) }\n-   | |__________________________________________________________________________- in this macro invocation\n+LL | | for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+   | |__________________________________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(Inv<'a>, Inv<'b>)>`\n               found enum `std::option::Option<for<'a> fn(Inv<'a>, Inv<'a>)>`"}, {"sha": "0cc30e479c7b9ace3702125858f51407ee3b0460", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_vs_bound_inv_b.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:104:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "3c8af20e50cef383296b4663c454839320917791", "filename": "src/test/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.stderr", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,65 +1,65 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:33:26\n+  --> $DIR/hr-subtype.rs:39:26\n    |\n LL |               gimme::<$t2>(None::<$t1>);\n    |                            ^^^^^^^^^^^ lifetime mismatch\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<fn(Inv<'y>)>`\n               found enum `std::option::Option<fn(Inv<'x>)>`\n-note: the lifetime `'x` as defined on the function body at 32:20...\n-  --> $DIR/hr-subtype.rs:32:20\n+note: the lifetime `'x` as defined on the function body at 38:20...\n+  --> $DIR/hr-subtype.rs:38:20\n    |\n-LL |           fn subtype<'x,'y:'x,'z:'y>() {\n+LL |           fn subtype<'x, 'y: 'x, 'z: 'y>() {\n    |                      ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 32:23\n-  --> $DIR/hr-subtype.rs:32:23\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:24\n+  --> $DIR/hr-subtype.rs:38:24\n    |\n-LL |           fn subtype<'x,'y:'x,'z:'y>() {\n-   |                         ^^\n+LL |           fn subtype<'x, 'y: 'x, 'z: 'y>() {\n+   |                          ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ lifetime mismatch\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<fn(Inv<'x>)>`\n               found enum `std::option::Option<fn(Inv<'y>)>`\n-note: the lifetime `'x` as defined on the function body at 38:22...\n-  --> $DIR/hr-subtype.rs:38:22\n+note: the lifetime `'x` as defined on the function body at 44:22...\n+  --> $DIR/hr-subtype.rs:44:22\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n    |                        ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:25\n-  --> $DIR/hr-subtype.rs:38:25\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 44:26\n+  --> $DIR/hr-subtype.rs:44:26\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n-   |                           ^^\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n+   |                            ^^\n ...\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-LL | |                                     fn(Inv<'y>)) }\n-   | |__________________________________________________- in this macro invocation\n+LL | | fn(Inv<'y>)) }\n+   | |______________- in this macro invocation\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "0cc30e479c7b9ace3702125858f51407ee3b0460", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_x.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_x.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,11 +1,11 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/hr-subtype.rs:100:1\n+  --> $DIR/hr-subtype.rs:104:1\n    |\n LL | / fn main() {\n LL | |\n LL | |\n LL | |\n-LL | |\n+...  |\n LL | |\n LL | | }\n    | |_^"}, {"sha": "7b4cdd4a419b4f4856e7f7409f71e5f5766a5af8", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_y.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,33 +1,33 @@\n error[E0308]: mismatched types\n-  --> $DIR/hr-subtype.rs:39:26\n+  --> $DIR/hr-subtype.rs:45:26\n    |\n LL |               gimme::<$t1>(None::<$t2>);\n    |                            ^^^^^^^^^^^ lifetime mismatch\n ...\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n-LL | |                             fn(&'y u32)) }\n-   | |__________________________________________- in this macro invocation\n+LL | | fn(&'y u32)) }\n+   | |______________- in this macro invocation\n    |\n    = note: expected enum `std::option::Option<fn(&'x u32)>`\n               found enum `std::option::Option<fn(&'y u32)>`\n-note: the lifetime `'x` as defined on the function body at 38:22...\n-  --> $DIR/hr-subtype.rs:38:22\n+note: the lifetime `'x` as defined on the function body at 44:22...\n+  --> $DIR/hr-subtype.rs:44:22\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n    |                        ^^\n ...\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n-LL | |                             fn(&'y u32)) }\n-   | |__________________________________________- in this macro invocation\n-note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 38:25\n-  --> $DIR/hr-subtype.rs:38:25\n+LL | | fn(&'y u32)) }\n+   | |______________- in this macro invocation\n+note: ...does not necessarily outlive the lifetime `'y` as defined on the function body at 44:26\n+  --> $DIR/hr-subtype.rs:44:26\n    |\n-LL |           fn supertype<'x,'y:'x,'z:'y>() {\n-   |                           ^^\n+LL |           fn supertype<'x, 'y: 'x, 'z: 'y>() {\n+   |                            ^^\n ...\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n-LL | |                             fn(&'y u32)) }\n-   | |__________________________________________- in this macro invocation\n+LL | | fn(&'y u32)) }\n+   | |______________- in this macro invocation\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "9e9c2ce9c61d71aa143854a262664fe0e054a389", "filename": "src/test/ui/hr-subtype/hr-subtype.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -18,60 +18,64 @@\n // revisions: bound_inv_a_b_vs_bound_inv_a\n // revisions: bound_a_b_ret_a_vs_bound_a_ret_a\n \n-fn gimme<T>(_: Option<T>) { }\n+fn gimme<T>(_: Option<T>) {}\n \n-struct Inv<'a> { x: *mut &'a u32 }\n+struct Inv<'a> {\n+    x: *mut &'a u32,\n+}\n \n-struct Co<'a> { x: fn(&'a u32) }\n+struct Co<'a> {\n+    x: fn(&'a u32),\n+}\n \n-struct Contra<'a> { x: &'a u32 }\n+struct Contra<'a> {\n+    x: &'a u32,\n+}\n \n macro_rules! check {\n     ($rev:ident: ($t1:ty, $t2:ty)) => {\n         #[cfg($rev)]\n-        fn subtype<'x,'y:'x,'z:'y>() {\n+        fn subtype<'x, 'y: 'x, 'z: 'y>() {\n             gimme::<$t2>(None::<$t1>);\n             //[free_inv_x_vs_free_inv_y]~^ ERROR\n         }\n \n         #[cfg($rev)]\n-        fn supertype<'x,'y:'x,'z:'y>() {\n+        fn supertype<'x, 'y: 'x, 'z: 'y>() {\n             gimme::<$t1>(None::<$t2>);\n             //[bound_a_vs_free_x]~^ ERROR\n             //[free_x_vs_free_y]~^^ ERROR\n             //[bound_inv_a_b_vs_bound_inv_a]~^^^ ERROR\n             //[bound_a_b_ret_a_vs_bound_a_ret_a]~^^^^ ERROR\n             //[free_inv_x_vs_free_inv_y]~^^^^^ ERROR\n             //[bound_a_b_vs_bound_a]~^^^^^^ ERROR mismatched types\n-            //[bound_co_a_co_b_ret_contra_a]~^^^^^^^ ERROR\n-            //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^ ERROR\n-            //[bound_co_a_b_vs_bound_co_a]~^^^^^^^^^ ERROR\n+            //[bound_contra_a_contra_b_ret_co_a]~^^^^^^^ ERROR\n         }\n-    }\n+    };\n }\n \n // If both have bound regions, they are equivalent, regardless of\n // variant.\n check! { bound_a_vs_bound_a: (for<'a> fn(&'a u32),\n-                              for<'a> fn(&'a u32)) }\n+for<'a> fn(&'a u32)) }\n check! { bound_a_vs_bound_b: (for<'a> fn(&'a u32),\n-                              for<'b> fn(&'b u32)) }\n+for<'b> fn(&'b u32)) }\n check! { bound_inv_a_vs_bound_inv_b: (for<'a> fn(Inv<'a>),\n-                                      for<'b> fn(Inv<'b>)) }\n+for<'b> fn(Inv<'b>)) }\n check! { bound_co_a_vs_bound_co_b: (for<'a> fn(Co<'a>),\n-                                    for<'b> fn(Co<'b>)) }\n+for<'b> fn(Co<'b>)) }\n \n // Bound is a subtype of free.\n check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n-                             fn(&'x u32)) }\n+fn(&'x u32)) }\n \n // Two free regions are relatable if subtyping holds.\n check! { free_x_vs_free_x: (fn(&'x u32),\n-                            fn(&'x u32)) }\n+fn(&'x u32)) }\n check! { free_x_vs_free_y: (fn(&'x u32),\n-                            fn(&'y u32)) }\n+fn(&'y u32)) }\n check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n-                                    fn(Inv<'y>)) }\n+fn(Inv<'y>)) }\n \n // Somewhat surprisingly, a fn taking two distinct bound lifetimes and\n // a fn taking one bound lifetime can be interchangeable, but only if\n@@ -82,25 +86,27 @@ check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n //   intersection;\n // - if we are contravariant, then 'a can be inferred to 'static.\n check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n-                                for<'a>    fn(&'a u32, &'a u32)) }\n+for<'a>    fn(&'a u32, &'a u32)) }\n check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),\n-                                      for<'a>    fn(Co<'a>, Co<'a>)) }\n+for<'a>    fn(Co<'a>, Co<'a>)) }\n check! { bound_contra_a_contra_b_ret_co_a: (for<'a,'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>,\n-                                            for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n+for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n check! { bound_co_a_co_b_ret_contra_a: (for<'a,'b> fn(Co<'a>, Co<'b>) -> Contra<'a>,\n-                                        for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n+for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n \n // If we make those lifetimes invariant, then the two types are not interchangeable.\n check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n-                                        for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+for<'a>    fn(Inv<'a>, Inv<'a>)) }\n check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n-                                            for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n+for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n \n #[rustc_error]\n fn main() {\n-//[bound_a_vs_bound_a]~^ ERROR fatal error triggered by #[rustc_error]\n-//[bound_a_vs_bound_b]~^^ ERROR fatal error triggered by #[rustc_error]\n-//[bound_inv_a_vs_bound_inv_b]~^^^ ERROR fatal error triggered by #[rustc_error]\n-//[bound_co_a_vs_bound_co_b]~^^^^ ERROR fatal error triggered by #[rustc_error]\n-//[free_x_vs_free_x]~^^^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_a_vs_bound_a]~^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_a_vs_bound_b]~^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_inv_a_vs_bound_inv_b]~^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_co_a_vs_bound_co_b]~^^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[free_x_vs_free_x]~^^^^^ ERROR fatal error triggered by #[rustc_error]\n+    //[bound_co_a_b_vs_bound_co_a]~^^^^^^ ERROR\n+    //[bound_co_a_co_b_ret_contra_a]~^^^^^^^ ERROR\n }"}, {"sha": "f95496a6c3cc0dc5845f83dfede498241dd2632f", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-covariant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -2,6 +2,8 @@\n //\n // In particular, we test this pattern in trait solving, where it is not connected\n // to any part of the source code.\n+//\n+// check-pass\n \n trait Trait<T> {}\n \n@@ -30,9 +32,6 @@ fn main() {\n     //         - `?b: ?a` -- solveable if `?b` is inferred to `'static`\n     // - So the subtyping check succeeds, somewhat surprisingly.\n     //   This is because we can use `'static`.\n-    //\n-    // NB. *However*, the reinstated leak-check gives an error here.\n \n     foo::<()>();\n-    //~^ ERROR not satisfied\n }"}, {"sha": "1e335f9ee96106d4a8df6b0f1a36f12ca6df4077", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-covariant.stderr", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4199b3ae26007eb9c871b57f56057da586bbd1db/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4199b3ae26007eb9c871b57f56057da586bbd1db/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-covariant.stderr?ref=4199b3ae26007eb9c871b57f56057da586bbd1db", "patch": "@@ -1,18 +0,0 @@\n-error[E0277]: the trait bound `(): Trait<for<'b> fn(fn(&'b u32))>` is not satisfied\n-  --> $DIR/hrtb-exists-forall-trait-covariant.rs:36:11\n-   |\n-LL | fn foo<T>()\n-   |    --- required by a bound in this\n-LL | where\n-LL |     T: Trait<for<'b> fn(fn(&'b u32))>,\n-   |        ------------------------------ required by this bound in `foo`\n-...\n-LL |     foo::<()>();\n-   |           ^^ the trait `Trait<for<'b> fn(fn(&'b u32))>` is not implemented for `()`\n-   |\n-   = help: the following implementations were found:\n-             <() as Trait<fn(fn(&'a u32))>>\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "539221b5a046c20c694430ab05cb46f77305282c", "filename": "src/test/ui/regions-fn-subtyping-return-static-fail.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -13,19 +13,19 @@ struct S;\n \n // Given 'cx, return 'cx\n type F = for<'cx> fn(&'cx S) -> &'cx S;\n-fn want_F(f: F) { }\n+fn want_F(f: F) {}\n \n // Given anything, return 'static\n type G = for<'cx> fn(&'cx S) -> &'static S;\n-fn want_G(f: G) { }\n+fn want_G(f: G) {}\n \n // Should meet both.\n fn foo(x: &S) -> &'static S {\n     panic!()\n }\n \n // Should meet both.\n-fn bar<'a,'b>(x: &'a S) -> &'b S {\n+fn bar<'a, 'b>(x: &'a S) -> &'b S {\n     panic!()\n }\n \n@@ -37,7 +37,7 @@ fn baz(x: &S) -> &S {\n fn supply_F() {\n     want_F(foo);\n \n-    want_F(bar); //~ ERROR mismatched types\n+    want_F(bar);\n \n     want_F(baz);\n }\n@@ -48,5 +48,4 @@ fn supply_G() {\n     want_G(baz); //~ ERROR mismatched types\n }\n \n-pub fn main() {\n-}\n+pub fn main() {}"}, {"sha": "6d75ace3c469814ac21e13a1848bc689e57ee72c", "filename": "src/test/ui/regions-fn-subtyping-return-static-fail.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static-fail.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -1,12 +1,3 @@\n-error[E0308]: mismatched types\n-  --> $DIR/regions-fn-subtyping-return-static-fail.rs:40:12\n-   |\n-LL |     want_F(bar);\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n-   |\n-   = note: expected fn pointer `for<'cx> fn(&'cx S) -> &'cx S`\n-                 found fn item `for<'a> fn(&'a S) -> &S {bar::<'_>}`\n-\n error[E0308]: mismatched types\n   --> $DIR/regions-fn-subtyping-return-static-fail.rs:48:12\n    |\n@@ -16,6 +7,6 @@ LL |     want_G(baz);\n    = note: expected fn pointer `for<'cx> fn(&'cx S) -> &'static S`\n                  found fn item `for<'r> fn(&'r S) -> &'r S {baz}`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "de14d5ba82a1b7dfc10348ceafbfb012c771034e", "filename": "src/test/ui/regions/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.rs?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -5,6 +5,8 @@\n // *ANY* lifetime and returns a reference with the 'static lifetime.\n // This can safely be considered to be an instance of `F` because all\n // lifetimes are sublifetimes of 'static.\n+//\n+// check-pass\n \n #![allow(dead_code)]\n #![allow(unused_variables)]\n@@ -14,19 +16,19 @@ struct S;\n \n // Given 'cx, return 'cx\n type F = for<'cx> fn(&'cx S) -> &'cx S;\n-fn want_F(f: F) { }\n+fn want_F(f: F) {}\n \n // Given anything, return 'static\n type G = for<'cx> fn(&'cx S) -> &'static S;\n-fn want_G(f: G) { }\n+fn want_G(f: G) {}\n \n // Should meet both.\n fn foo(x: &S) -> &'static S {\n     panic!()\n }\n \n // Should meet both.\n-fn bar<'a,'b>(x: &'a S) -> &'b S {\n+fn bar<'a, 'b>(x: &'a S) -> &'b S {\n     panic!()\n }\n \n@@ -38,10 +40,9 @@ fn baz(x: &S) -> &S {\n fn supply_F() {\n     want_F(foo);\n \n-    want_F(bar); //~ ERROR mismatched types\n+    want_F(bar);\n \n     want_F(baz);\n }\n \n-pub fn main() {\n-}\n+pub fn main() {}"}, {"sha": "a8a7e97e6acf66a11660662851060962ff03557b", "filename": "src/test/ui/regions/regions-fn-subtyping-return-static.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4199b3ae26007eb9c871b57f56057da586bbd1db/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4199b3ae26007eb9c871b57f56057da586bbd1db/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-fn-subtyping-return-static.stderr?ref=4199b3ae26007eb9c871b57f56057da586bbd1db", "patch": "@@ -1,12 +0,0 @@\n-error[E0308]: mismatched types\n-  --> $DIR/regions-fn-subtyping-return-static.rs:41:12\n-   |\n-LL |     want_F(bar);\n-   |            ^^^ expected concrete lifetime, found bound lifetime parameter 'cx\n-   |\n-   = note: expected fn pointer `for<'cx> fn(&'cx S) -> &'cx S`\n-                 found fn item `for<'a> fn(&'a S) -> &S {bar::<'_>}`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "75df99137179b6b08d7c18a81a4d46a6c00ff2d1", "filename": "src/test/ui/rfc1623.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Frfc1623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2cf9944831f15b1940da85c8fb1b419dec9f074/src%2Ftest%2Fui%2Frfc1623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623.stderr?ref=f2cf9944831f15b1940da85c8fb1b419dec9f074", "patch": "@@ -36,7 +36,7 @@ error[E0271]: type mismatch resolving `for<'a, 'b> <fn(_) -> _ {id::<_>} as std:\n   --> $DIR/rfc1623.rs:25:8\n    |\n LL |     f: &id,\n-   |        ^^^ expected bound lifetime parameter 'a, found concrete lifetime\n+   |        ^^^ expected bound lifetime parameter 'b, found concrete lifetime\n    |\n    = note: required for the cast to the object type `dyn for<'a, 'b> std::ops::Fn(&'a Foo<'b>) -> &'a Foo<'b>`\n "}]}