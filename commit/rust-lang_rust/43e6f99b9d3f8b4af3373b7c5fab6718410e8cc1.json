{"sha": "43e6f99b9d3f8b4af3373b7c5fab6718410e8cc1", "node_id": "C_kwDOAAsO6NoAKDQzZTZmOTliOWQzZjhiNGFmMzM3M2I3YzVmYWI2NzE4NDEwZThjYzE", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-04-11T08:27:57Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-04-11T08:27:57Z"}, "message": "remove issue-2718.rs test\n\nthis test was added for rust 0.4 and doesn't test anything specific.\nThe repro originally relied on extern functions which are now just\nordinary methods. It's also a run pass test even though `main` has\nbeen commented out.", "tree": {"sha": "64904f2dc7577314226b39642ff081bf1d21c814", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64904f2dc7577314226b39642ff081bf1d21c814"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43e6f99b9d3f8b4af3373b7c5fab6718410e8cc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43e6f99b9d3f8b4af3373b7c5fab6718410e8cc1", "html_url": "https://github.com/rust-lang/rust/commit/43e6f99b9d3f8b4af3373b7c5fab6718410e8cc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43e6f99b9d3f8b4af3373b7c5fab6718410e8cc1/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "171f5414705194067557cd7b70bd680308b9cced", "url": "https://api.github.com/repos/rust-lang/rust/commits/171f5414705194067557cd7b70bd680308b9cced", "html_url": "https://github.com/rust-lang/rust/commit/171f5414705194067557cd7b70bd680308b9cced"}], "stats": {"total": 327, "additions": 0, "deletions": 327}, "files": [{"sha": "6449337eea4e7ee1978dfa0b2faa654027b1054f", "filename": "tests/ui/regions/issue-2718.rs", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/171f5414705194067557cd7b70bd680308b9cced/tests%2Fui%2Fregions%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/171f5414705194067557cd7b70bd680308b9cced/tests%2Fui%2Fregions%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregions%2Fissue-2718.rs?ref=171f5414705194067557cd7b70bd680308b9cced", "patch": "@@ -1,327 +0,0 @@\n-// run-pass\n-#![allow(dead_code)]\n-#![allow(unused_unsafe)]\n-#![allow(unused_imports)]\n-#![allow(non_camel_case_types)]\n-\n-pub type Task = isize;\n-\n-// tjc: I don't know why\n-pub mod pipes {\n-    use self::state::{empty, full, blocked, terminated};\n-    use super::Task;\n-    use std::mem::{forget, transmute};\n-    use std::mem::{replace, swap};\n-    use std::mem;\n-    use std::thread;\n-    use std::marker::Send;\n-\n-    pub struct Stuff<T> {\n-        state: state,\n-        blocked_task: Option<Task>,\n-        payload: Option<T>\n-    }\n-\n-    #[derive(PartialEq, Debug)]\n-    #[repr(isize)]\n-    pub enum state {\n-        empty,\n-        full,\n-        blocked,\n-        terminated\n-    }\n-\n-    pub struct packet<T> {\n-        state: state,\n-        blocked_task: Option<Task>,\n-        payload: Option<T>\n-    }\n-\n-    unsafe impl<T:Send> Send for packet<T> {}\n-\n-    pub fn packet<T:Send>() -> *const packet<T> {\n-        unsafe {\n-            let p: *const packet<T> = mem::transmute(Box::new(Stuff{\n-                state: empty,\n-                blocked_task: None::<Task>,\n-                payload: None::<T>\n-            }));\n-            p\n-        }\n-    }\n-\n-    mod rusti {\n-      pub fn atomic_xchg(_dst: &mut isize, _src: isize) -> isize { panic!(); }\n-      pub fn atomic_xchg_acq(_dst: &mut isize, _src: isize) -> isize { panic!(); }\n-      pub fn atomic_xchg_rel(_dst: &mut isize, _src: isize) -> isize { panic!(); }\n-    }\n-\n-    // We should consider moving this to ::std::unsafe, although I\n-    // suspect graydon would want us to use void pointers instead.\n-    pub unsafe fn uniquify<T>(x: *const T) -> Box<T> {\n-        mem::transmute(x)\n-    }\n-\n-    pub fn swap_state_acq(dst: &mut state, src: state) -> state {\n-        unsafe {\n-            transmute(rusti::atomic_xchg_acq(transmute(dst), src as isize))\n-        }\n-    }\n-\n-    pub fn swap_state_rel(dst: &mut state, src: state) -> state {\n-        unsafe {\n-            transmute(rusti::atomic_xchg_rel(transmute(dst), src as isize))\n-        }\n-    }\n-\n-    pub fn send<T:Send>(mut p: send_packet<T>, payload: T) {\n-        let p = p.unwrap();\n-        let mut p = unsafe { uniquify(p) };\n-        assert!((*p).payload.is_none());\n-        (*p).payload = Some(payload);\n-        let old_state = swap_state_rel(&mut (*p).state, full);\n-        match old_state {\n-          empty => {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          full => { panic!(\"duplicate send\") }\n-          blocked => {\n-\n-            // The receiver will eventually clean this up.\n-            unsafe { forget(p); }\n-          }\n-          terminated => {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-          }\n-        }\n-    }\n-\n-    pub fn recv<T:Send>(mut p: recv_packet<T>) -> Option<T> {\n-        let p = p.unwrap();\n-        let mut p = unsafe { uniquify(p) };\n-        loop {\n-            let old_state = swap_state_acq(&mut (*p).state,\n-                                           blocked);\n-            match old_state {\n-              empty | blocked => { thread::yield_now(); }\n-              full => {\n-                let payload = replace(&mut p.payload, None);\n-                return Some(payload.unwrap())\n-              }\n-              terminated => {\n-                assert_eq!(old_state, terminated);\n-                return None;\n-              }\n-            }\n-        }\n-    }\n-\n-    pub fn sender_terminate<T:Send>(p: *const packet<T>) {\n-        let mut p = unsafe { uniquify(p) };\n-        match swap_state_rel(&mut (*p).state, terminated) {\n-          empty | blocked => {\n-            // The receiver will eventually clean up.\n-            unsafe { forget(p) }\n-          }\n-          full => {\n-            // This is impossible\n-            panic!(\"you dun goofed\")\n-          }\n-          terminated => {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    pub fn receiver_terminate<T:Send>(p: *const packet<T>) {\n-        let mut p = unsafe { uniquify(p) };\n-        match swap_state_rel(&mut (*p).state, terminated) {\n-          empty => {\n-            // the sender will clean up\n-            unsafe { forget(p) }\n-          }\n-          blocked => {\n-            // this shouldn't happen.\n-            panic!(\"terminating a blocked packet\")\n-          }\n-          terminated | full => {\n-            // I have to clean up, use drop_glue\n-          }\n-        }\n-    }\n-\n-    pub struct send_packet<T:Send> {\n-        p: Option<*const packet<T>>,\n-    }\n-\n-    impl<T:Send> Drop for send_packet<T> {\n-        fn drop(&mut self) {\n-            unsafe {\n-                if self.p != None {\n-                    let self_p: &mut Option<*const packet<T>> =\n-                        mem::transmute(&mut self.p);\n-                    let p = replace(self_p, None);\n-                    sender_terminate(p.unwrap())\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<T:Send> send_packet<T> {\n-        pub fn unwrap(&mut self) -> *const packet<T> {\n-            replace(&mut self.p, None).unwrap()\n-        }\n-    }\n-\n-    pub fn send_packet<T:Send>(p: *const packet<T>) -> send_packet<T> {\n-        send_packet {\n-            p: Some(p)\n-        }\n-    }\n-\n-    pub struct recv_packet<T:Send> {\n-        p: Option<*const packet<T>>,\n-    }\n-\n-    impl<T:Send> Drop for recv_packet<T> {\n-        fn drop(&mut self) {\n-            unsafe {\n-                if self.p != None {\n-                    let self_p: &mut Option<*const packet<T>> =\n-                        mem::transmute(&mut self.p);\n-                    let p = replace(self_p, None);\n-                    receiver_terminate(p.unwrap())\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<T:Send> recv_packet<T> {\n-        pub fn unwrap(&mut self) -> *const packet<T> {\n-            replace(&mut self.p, None).unwrap()\n-        }\n-    }\n-\n-    pub fn recv_packet<T:Send>(p: *const packet<T>) -> recv_packet<T> {\n-        recv_packet {\n-            p: Some(p)\n-        }\n-    }\n-\n-    pub fn entangle<T:Send>() -> (send_packet<T>, recv_packet<T>) {\n-        let p = packet();\n-        (send_packet(p), recv_packet(p))\n-    }\n-}\n-\n-pub mod pingpong {\n-    use std::mem;\n-\n-    pub struct ping(::pipes::send_packet<pong>);\n-\n-    unsafe impl Send for ping {}\n-\n-    pub struct pong(::pipes::send_packet<ping>);\n-\n-    unsafe impl Send for pong {}\n-\n-    pub fn liberate_ping(p: ping) -> ::pipes::send_packet<pong> {\n-        unsafe {\n-            let _addr : *const ::pipes::send_packet<pong> = match &p {\n-              &ping(ref x) => { mem::transmute(x) }\n-            };\n-            panic!()\n-        }\n-    }\n-\n-    pub fn liberate_pong(p: pong) -> ::pipes::send_packet<ping> {\n-        unsafe {\n-            let _addr : *const ::pipes::send_packet<ping> = match &p {\n-              &pong(ref x) => { mem::transmute(x) }\n-            };\n-            panic!()\n-        }\n-    }\n-\n-    pub fn init() -> (client::ping, server::ping) {\n-        ::pipes::entangle()\n-    }\n-\n-    pub mod client {\n-        use pingpong;\n-\n-        pub type ping = ::pipes::send_packet<pingpong::ping>;\n-        pub type pong = ::pipes::recv_packet<pingpong::pong>;\n-\n-        pub fn do_ping(c: ping) -> pong {\n-            let (sp, rp) = ::pipes::entangle();\n-\n-            ::pipes::send(c, pingpong::ping(sp));\n-            rp\n-        }\n-\n-        pub fn do_pong(c: pong) -> (ping, ()) {\n-            let packet = ::pipes::recv(c);\n-            if packet.is_none() {\n-                panic!(\"sender closed the connection\")\n-            }\n-            (pingpong::liberate_pong(packet.unwrap()), ())\n-        }\n-    }\n-\n-    pub mod server {\n-        use pingpong;\n-\n-        pub type ping = ::pipes::recv_packet<pingpong::ping>;\n-        pub type pong = ::pipes::send_packet<pingpong::pong>;\n-\n-        pub fn do_ping(c: ping) -> (pong, ()) {\n-            let packet = ::pipes::recv(c);\n-            if packet.is_none() {\n-                panic!(\"sender closed the connection\")\n-            }\n-            (pingpong::liberate_ping(packet.unwrap()), ())\n-        }\n-\n-        pub fn do_pong(c: pong) -> ping {\n-            let (sp, rp) = ::pipes::entangle();\n-            ::pipes::send(c, pingpong::pong(sp));\n-            rp\n-        }\n-    }\n-}\n-\n-fn client(chan: pingpong::client::ping) {\n-    let chan = pingpong::client::do_ping(chan);\n-    println!(\"Sent ping\");\n-    let (_chan, _data) = pingpong::client::do_pong(chan);\n-    println!(\"Received pong\");\n-}\n-\n-fn server(chan: pingpong::server::ping) {\n-    let (chan, _data) = pingpong::server::do_ping(chan);\n-    println!(\"Received ping\");\n-    let _chan = pingpong::server::do_pong(chan);\n-    println!(\"Sent pong\");\n-}\n-\n-pub fn main() {\n-  /*\n-//    Commented out because of option::get error\n-\n-    let (client_, server_) = pingpong::init();\n-\n-    task::spawn {|client_|\n-        let client__ = client_.take();\n-        client(client__);\n-    };\n-    task::spawn {|server_|\n-        let server__ = server_.take();\n-        server(server_\u02ca);\n-    };\n-  */\n-}"}]}