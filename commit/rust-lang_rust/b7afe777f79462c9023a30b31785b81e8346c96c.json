{"sha": "b7afe777f79462c9023a30b31785b81e8346c96c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YWZlNzc3Zjc5NDYyYzkwMjNhMzBiMzE3ODViODFlODM0NmM5NmM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-01T17:39:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-20T08:44:02Z"}, "message": "stabilize core parts of MaybeUninit and deprecate mem::uninitialized in the future\n\nAlso expand the documentation a bit", "tree": {"sha": "924a5e3a2dcef35692863d4606834c00cdb1aa3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/924a5e3a2dcef35692863d4606834c00cdb1aa3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7afe777f79462c9023a30b31785b81e8346c96c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7afe777f79462c9023a30b31785b81e8346c96c", "html_url": "https://github.com/rust-lang/rust/commit/b7afe777f79462c9023a30b31785b81e8346c96c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7afe777f79462c9023a30b31785b81e8346c96c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caef1e833fbd9de740d521114d716a11a29b71cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/caef1e833fbd9de740d521114d716a11a29b71cb", "html_url": "https://github.com/rust-lang/rust/commit/caef1e833fbd9de740d521114d716a11a29b71cb"}], "stats": {"total": 308, "additions": 138, "deletions": 170}, "files": [{"sha": "d90036eaf49b8f3da6389d23e8f978f69fe5984e", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b7afe777f79462c9023a30b31785b81e8346c96c", "patch": "@@ -109,7 +109,7 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n #![feature(iter_nth_back)]"}, {"sha": "4a70329b64bc983a7d43b0b4214be77d892c8447", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b7afe777f79462c9023a30b31785b81e8346c96c", "patch": "@@ -125,7 +125,7 @@\n #![feature(structural_match)]\n #![feature(abi_unadjusted)]\n #![feature(adx_target_feature)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_slice, maybe_uninit_array)]\n #![feature(external_doc)]\n \n #[prelude_import]"}, {"sha": "9e23a5e61e4ccd2f229469a0155553b3e12a080a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 135, "deletions": 165, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b7afe777f79462c9023a30b31785b81e8346c96c", "patch": "@@ -465,29 +465,39 @@ pub const fn needs_drop<T>() -> bool {\n \n /// Creates a value whose bytes are all zero.\n ///\n-/// This has the same effect as allocating space with\n-/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n-/// FFI sometimes, but should generally be avoided.\n+/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n+/// It is useful for FFI sometimes, but should generally be avoided.\n ///\n /// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n-/// a panic or the end of a scope) before being initialized, then the destructor\n-/// will run on zeroed data, likely leading to [undefined behavior][ub].\n+/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n+/// causes immediate [undefined behavior][ub].\n ///\n-/// See also the documentation for [`mem::uninitialized`][uninit], which has\n-/// many of the same caveats.\n+/// See the documentation of [`MaybeUninit<T>`] and [`MaybeUninit::zeroed()`][zeroed]\n+/// for more discussion on how to initialize values.\n ///\n-/// [uninit]: fn.uninitialized.html\n+/// [zeroed]: union.MaybeUninit.html#method.zeroed\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n /// [ub]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Examples\n ///\n+/// Correct usage of this function: initializing an integer with zero.\n+///\n /// ```\n /// use std::mem;\n ///\n /// let x: i32 = unsafe { mem::zeroed() };\n /// assert_eq!(0, x);\n /// ```\n+///\n+/// *Incorrect* usage of this function: initializing a reference with zero.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n@@ -498,130 +508,13 @@ pub unsafe fn zeroed<T>() -> T {\n /// Bypasses Rust's normal memory-initialization checks by pretending to\n /// produce a value of type `T`, while doing nothing at all.\n ///\n-/// **This is incredibly dangerous and should not be done lightly. Deeply\n-/// consider initializing your memory with a default value instead.**\n-///\n-/// This is useful for FFI functions and initializing arrays sometimes,\n-/// but should generally be avoided.\n-///\n-/// # Undefined behavior\n-///\n-/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n-/// uninitialized boolean. For instance, if you branch on the value of such\n-/// a boolean, your program may take one, both, or neither of the branches.\n-///\n-/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n-/// value is initialized, and will therefore try to [`Drop`] the uninitialized\n-/// value and its fields if you try to overwrite it in a normal manner. The only way\n-/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n-/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n-///\n-/// If the value does implement [`Drop`], it must be initialized before\n-/// it goes out of scope (and therefore would be dropped). Note that this\n-/// includes a `panic` occurring and unwinding the stack suddenly.\n-///\n-/// If you partially initialize an array, you may need to use\n-/// [`ptr::drop_in_place`][drop_in_place] to remove the elements you have fully\n-/// initialized followed by [`mem::forget`][mem_forget] to prevent drop running\n-/// on the array. If a partially allocated array is dropped this will lead to\n-/// undefined behaviour.\n+/// **This functon is deprecated because it basically cannot be used correctly.**\n ///\n-/// # Examples\n-///\n-/// Here's how to safely initialize an array of [`Vec`]s.\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// // Only declare the array. This safely leaves it\n-/// // uninitialized in a way that Rust will track for us.\n-/// // However we can't initialize it element-by-element\n-/// // safely, and we can't use the `[value; 1000]`\n-/// // constructor because it only works with `Copy` data.\n-/// let mut data: [Vec<u32>; 1000];\n-///\n-/// unsafe {\n-///     // So we need to do this to initialize it.\n-///     data = mem::uninitialized();\n-///\n-///     // DANGER ZONE: if anything panics or otherwise\n-///     // incorrectly reads the array here, we will have\n-///     // Undefined Behavior.\n-///\n-///     // It's ok to mutably iterate the data, since this\n-///     // doesn't involve reading it at all.\n-///     // (ptr and len are statically known for arrays)\n-///     for elem in &mut data[..] {\n-///         // *elem = Vec::new() would try to drop the\n-///         // uninitialized memory at `elem` -- bad!\n-///         //\n-///         // Vec::new doesn't allocate or do really\n-///         // anything. It's only safe to call here\n-///         // because we know it won't panic.\n-///         ptr::write(elem, Vec::new());\n-///     }\n+/// Use [`MaybeUninit<T>`] instead.\n ///\n-///     // SAFE ZONE: everything is initialized.\n-/// }\n-///\n-/// println!(\"{:?}\", &data[0]);\n-/// ```\n-///\n-/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n-/// can be. Note that the [`vec!`] macro *does* let you initialize every element with a\n-/// value that is only [`Clone`], so the following is semantically equivalent and\n-/// vastly less dangerous, as long as you can live with an extra heap\n-/// allocation:\n-///\n-/// ```\n-/// let data: Vec<Vec<u32>> = vec![Vec::new(); 1000];\n-/// println!(\"{:?}\", &data[0]);\n-/// ```\n-///\n-/// This example shows how to handle partially initialized arrays, which could\n-/// be found in low-level datastructures.\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// // Count the number of elements we have assigned.\n-/// let mut data_len: usize = 0;\n-/// let mut data: [String; 1000];\n-///\n-/// unsafe {\n-///     data = mem::uninitialized();\n-///\n-///     for elem in &mut data[0..500] {\n-///         ptr::write(elem, String::from(\"hello\"));\n-///         data_len += 1;\n-///     }\n-///\n-///     // For each item in the array, drop if we allocated it.\n-///     for i in &mut data[0..data_len] {\n-///         ptr::drop_in_place(i);\n-///     }\n-/// }\n-/// // Forget the data. If this is allowed to drop, you may see a crash such as:\n-/// // 'mem_uninit_test(2457,0x7fffb55dd380) malloc: *** error for object\n-/// // 0x7ff3b8402920: pointer being freed was not allocated'\n-/// mem::forget(data);\n-/// ```\n-///\n-/// [`Vec`]: ../../std/vec/struct.Vec.html\n-/// [`vec!`]: ../../std/macro.vec.html\n-/// [`Clone`]: ../../std/clone/trait.Clone.html\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [write]: ../ptr/fn.write.html\n-/// [drop_in_place]: ../ptr/fn.drop_in_place.html\n-/// [mem_zeroed]: fn.zeroed.html\n-/// [mem_forget]: fn.forget.html\n-/// [copy]: ../intrinsics/fn.copy.html\n-/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n-/// [`Drop`]: ../ops/trait.Drop.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n #[inline]\n-#[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninit` instead\")]\n+#[rustc_deprecated(since = \"1.40.0\", reason = \"use `mem::MaybeUninit` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::panic_if_uninhabited::<T>();\n@@ -899,7 +792,6 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n     }\n }\n \n-// FIXME: Reference `MaybeUninit` from these docs, once that is stable.\n /// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n ///\n /// This wrapper is 0-cost.\n@@ -908,6 +800,7 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// As a consequence, it has *no effect* on the assumptions that the compiler makes\n /// about all values being initialized at their type.  In particular, initializing\n /// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n ///\n /// # Examples\n ///\n@@ -942,6 +835,7 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n /// ```\n ///\n /// [`mem::zeroed`]: fn.zeroed.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -1042,17 +936,18 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n     }\n }\n \n-/// A wrapper to construct uninitialized instances of `T`.\n+/// A wrapper type to construct uninitialized instances of `T`.\n+///\n+/// # Initialization invariant\n ///\n /// The compiler, in general, assumes that variables are properly initialized\n /// at their respective type. For example, a variable of reference type must\n /// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n /// even in unsafe code. As a consequence, zero-initializing a variable of reference\n-/// type causes instantaneous undefined behavior, no matter whether that reference\n+/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n /// ever gets used to access memory:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n@@ -1067,7 +962,6 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -1078,10 +972,9 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// Moreover, uninitialized memory is special in that the compiler knows that\n /// it does not have a fixed value. This makes it undefined behavior to have\n /// uninitialized data in a variable even if that variable has an integer type,\n-/// which otherwise can hold any bit pattern:\n+/// which otherwise can hold any *fixed* bit pattern:\n ///\n /// ```rust,no_run\n-/// #![feature(maybe_uninit)]\n /// use std::mem::{self, MaybeUninit};\n ///\n /// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n@@ -1091,37 +984,108 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n /// (Notice that the rules around uninitialized integers are not finalized yet, but\n /// until they are, it is advisable to avoid them.)\n ///\n+/// On top of that, remember that most types have additional invariants beyond merely\n+/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n+/// is considered initialized because the only requirement the compiler knows about it\n+/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n+/// *immediate* undefined behavior, but will cause undefined behavior with most\n+/// safe operations (including dropping it).\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+///\n+/// # Examples\n+///\n /// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n /// It is a signal to the compiler indicating that the data here might *not*\n /// be initialized:\n ///\n /// ```rust\n-/// #![feature(maybe_uninit)]\n /// use std::mem::MaybeUninit;\n ///\n /// // Create an explicitly uninitialized reference. The compiler knows that data inside\n /// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n /// let mut x = MaybeUninit::<&i32>::uninit();\n /// // Set it to a valid value.\n-/// x.write(&0);\n+/// unsafe { x.as_mut_ptr().write(&0); }\n /// // Extract the initialized data -- this is only allowed *after* properly\n /// // initializing `x`!\n /// let x = unsafe { x.assume_init() };\n /// ```\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n-//\n-// FIXME before stabilizing, explain how to initialize a struct field-by-field.\n+///\n+/// ## Initializing an array element-by-element\n+///\n+/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n+///\n+/// ```\n+/// use std::mem::{self, MaybeUninit};\n+/// use std::ptr;\n+///\n+/// let data = unsafe {\n+///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+///     // safe because the type we are claiming to have initialized here is a\n+///     // bunch of `MaybeUninit`s, which do not require initialization.\n+///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = MaybeUninit::uninit().assume_init();\n+///\n+///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n+///     // we have a memory leak, but there is no memory safety issue.\n+///     for elem in &mut data[..] {\n+///         ptr::write(elem.as_mut_ptr(), vec![42]);\n+///     }\n+///\n+///     // Everything is initialized. Transmute the array to the\n+///     // initialized type.\n+///     mem::transmute::<_, [Vec<u32>; 1000]>(data)\n+/// };\n+///\n+/// println!(\"{:?}\", &data[0]);\n+/// ```\n+///\n+/// You can also work with partially initialized arrays, which could\n+/// be found in low-level datastructures.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+/// use std::ptr;\n+///\n+/// unsafe {\n+///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+///     // safe because the type we are claiming to have initialized here is a\n+///     // bunch of `MaybeUninit`s, which do not require initialization.\n+///     let mut data: [MaybeUninit<String>; 1000] = MaybeUninit::uninit().assume_init();\n+///     // Count the number of elements we have assigned.\n+///     let mut data_len: usize = 0;\n+///\n+///     for elem in &mut data[0..500] {\n+///         ptr::write(elem.as_mut_ptr(), String::from(\"hello\"));\n+///         data_len += 1;\n+///     }\n+///\n+///     // For each item in the array, drop if we allocated it.\n+///     for elem in &mut data[0..data_len] {\n+///         ptr::drop_in_place(elem.as_mut_ptr());\n+///     }\n+/// }\n+/// ```\n+///\n+/// ## Initializing a struct field-by-field\n+///\n+/// There is unfortunately currently no supported way to create a raw pointer or reference\n+/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n+/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n+/// to its fields.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n #[allow(missing_debug_implementations)]\n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n #[derive(Copy)]\n-// NOTE: after stabilizing `MaybeUninit`, proceed to deprecate `mem::uninitialized`.\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,\n }\n \n-#[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n impl<T: Copy> Clone for MaybeUninit<T> {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n@@ -1132,10 +1096,13 @@ impl<T: Copy> Clone for MaybeUninit<T> {\n \n impl<T> MaybeUninit<T> {\n     /// Creates a new `MaybeUninit<T>` initialized with the given value.\n+    /// It is safe to call [`assume_init`] on the return value of this function.\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    ///\n+    /// [`assume_init`]: #method.assume_init\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub const fn new(val: T) -> MaybeUninit<T> {\n         MaybeUninit { value: ManuallyDrop::new(val) }\n@@ -1145,7 +1112,11 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n     /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    ///\n+    /// See the [type-level documentation][type] for some examples.\n+    ///\n+    /// [type]: union.MaybeUninit.html\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub const fn uninit() -> MaybeUninit<T> {\n         MaybeUninit { uninit: () }\n@@ -1166,7 +1137,6 @@ impl<T> MaybeUninit<T> {\n     /// fields of the struct can hold the bit-pattern 0 as a valid value.\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n@@ -1178,7 +1148,6 @@ impl<T> MaybeUninit<T> {\n     /// cannot hold 0 as a valid value.\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// enum NotZero { One = 1, Two = 2 };\n@@ -1188,7 +1157,7 @@ impl<T> MaybeUninit<T> {\n     /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n     /// // This is undefined behavior.\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline]\n     pub fn zeroed() -> MaybeUninit<T> {\n         let mut u = MaybeUninit::<T>::uninit();\n@@ -1202,7 +1171,7 @@ impl<T> MaybeUninit<T> {\n     /// without dropping it, so be careful not to use this twice unless you want to\n     /// skip running the destructor. For your convenience, this also returns a mutable\n     /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n     #[inline(always)]\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n@@ -1213,13 +1182,14 @@ impl<T> MaybeUninit<T> {\n \n     /// Gets a pointer to the contained value. Reading from this pointer or turning it\n     /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n+    /// (except inside an `UnsafeCell`).\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1232,7 +1202,6 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1242,7 +1211,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub fn as_ptr(&self) -> *const T {\n         unsafe { &*self.value as *const T }\n@@ -1256,7 +1225,6 @@ impl<T> MaybeUninit<T> {\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1271,7 +1239,6 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n@@ -1281,7 +1248,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         unsafe { &mut *self.value as *mut T }\n@@ -1294,15 +1261,17 @@ impl<T> MaybeUninit<T> {\n     /// # Safety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// [inv]: #initialization-invariant\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<bool>::uninit();\n@@ -1314,14 +1283,13 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let x = MaybeUninit::<Vec<u32>>::uninit();\n     /// let x_init = unsafe { x.assume_init() };\n     /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n     #[inline(always)]\n     pub unsafe fn assume_init(self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n@@ -1338,21 +1306,23 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n     ///\n     /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n     /// multiple copies of the data (by calling `read` multiple times, or first\n     /// calling `read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n+    /// [inv]: #initialization-invariant\n     /// [`assume_init`]: #method.assume_init\n     ///\n     /// # Examples\n     ///\n     /// Correct usage of this method:\n     ///\n     /// ```rust\n-    /// #![feature(maybe_uninit)]\n+    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<u32>::uninit();\n@@ -1373,7 +1343,7 @@ impl<T> MaybeUninit<T> {\n     /// *Incorrect* usage of this method:\n     ///\n     /// ```rust,no_run\n-    /// #![feature(maybe_uninit)]\n+    /// #![feature(maybe_uninit_extra)]\n     /// use std::mem::MaybeUninit;\n     ///\n     /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n@@ -1383,7 +1353,7 @@ impl<T> MaybeUninit<T> {\n     /// // We now created two copies of the same vector, leading to a double-free when\n     /// // they both get dropped!\n     /// ```\n-    #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();"}, {"sha": "e044b46e0d0763252baf5254a69fe57f88d1e5b8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b7afe777f79462c9023a30b31785b81e8346c96c", "patch": "@@ -272,7 +272,6 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(linkage)]\n-#![feature(maybe_uninit)]\n #![feature(needs_panic_runtime)]\n #![feature(never_type)]\n #![feature(nll)]"}, {"sha": "5004f787cde190725b2b5d3b69a117a319fcb0a6", "filename": "src/test/codegen/box-maybe-uninit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fbox-maybe-uninit.rs?ref=b7afe777f79462c9023a30b31785b81e8346c96c", "patch": "@@ -1,6 +1,5 @@\n // compile-flags: -O\n #![crate_type=\"lib\"]\n-#![feature(maybe_uninit)]\n \n use std::mem::MaybeUninit;\n "}, {"sha": "4ca4b407bd4ff2b70ca60e3aed042874bc8efcec", "filename": "src/test/run-pass/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7afe777f79462c9023a30b31785b81e8346c96c/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs?ref=b7afe777f79462c9023a30b31785b81e8346c96c", "patch": "@@ -2,7 +2,7 @@\n // This test checks that instantiating an uninhabited type via `mem::{uninitialized,zeroed}` results\n // in a runtime panic.\n \n-#![feature(never_type, maybe_uninit)]\n+#![feature(never_type)]\n \n use std::{mem, panic};\n "}]}