{"sha": "5acfe3d5376d58a549b508e4fbfe21cf31a79396", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhY2ZlM2Q1Mzc2ZDU4YTU0OWI1MDhlNGZiZmUyMWNmMzFhNzkzOTY=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-21T19:21:06Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-21T21:50:12Z"}, "message": "replace the core-map benchmark\n\n* Closes #4603", "tree": {"sha": "e71f3c3488d53f3994a0e3d18a83b787921cf48c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e71f3c3488d53f3994a0e3d18a83b787921cf48c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5acfe3d5376d58a549b508e4fbfe21cf31a79396", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5acfe3d5376d58a549b508e4fbfe21cf31a79396", "html_url": "https://github.com/rust-lang/rust/commit/5acfe3d5376d58a549b508e4fbfe21cf31a79396", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5acfe3d5376d58a549b508e4fbfe21cf31a79396/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d4063083bc366d1423572855f6320bb964d2a22", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4063083bc366d1423572855f6320bb964d2a22", "html_url": "https://github.com/rust-lang/rust/commit/5d4063083bc366d1423572855f6320bb964d2a22"}], "stats": {"total": 333, "additions": 86, "deletions": 247}, "files": [{"sha": "67281594a395a1df073ba4ec4490353e96b862f2", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 86, "deletions": 247, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/5acfe3d5376d58a549b508e4fbfe21cf31a79396/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5acfe3d5376d58a549b508e4fbfe21cf31a79396/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=5acfe3d5376d58a549b508e4fbfe21cf31a79396", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,322 +9,161 @@\n // except according to those terms.\n \n extern mod std;\n-use std::oldmap;\n-use std::treemap::TreeMap;\n-use core::hashmap::linear::*;\n-use core::io::WriterUtil;\n-\n-struct Results {\n-    sequential_ints: float,\n-    random_ints: float,\n-    delete_ints: float,\n-\n-    sequential_strings: float,\n-    random_strings: float,\n-    delete_strings: float\n-}\n \n-fn timed(result: &mut float,\n-         op: &fn()) {\n-    let start = std::time::precise_time_s();\n-    op();\n-    let end = std::time::precise_time_s();\n-    *result = (end - start);\n+use core::io;\n+use std::time;\n+use std::treemap::TreeMap;\n+use core::hashmap::linear::{LinearMap, LinearSet};\n+use core::trie::TrieMap;\n+\n+fn timed(label: &str, f: &fn()) {\n+    let start = time::precise_time_s();\n+    f();\n+    let end = time::precise_time_s();\n+    io::println(fmt!(\"  %s: %f\", label, end - start));\n }\n \n-fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-\n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.sequential_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(i, i+1);\n-            }\n+fn ascending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n+    io::println(\" Ascending integers:\");\n \n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.get(&i) == i+1);\n-            }\n+    do timed(\"insert\") {\n+        for uint::range(0, n_keys) |i| {\n+            map.insert(i, i + 1);\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.random_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(rng.next() as uint, i);\n-            }\n+    do timed(\"search\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.find(&i).unwrap() == &(i + 1));\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(i, i);;\n-        }\n-\n-        do timed(&mut results.delete_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&i));\n-            }\n+    do timed(\"remove\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.remove(&i));\n         }\n     }\n }\n \n-fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.sequential_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                map.insert(s, i);\n-            }\n+fn descending<M: Map<uint, uint>>(map: &mut M, n_keys: uint) {\n+    io::println(\" Descending integers:\");\n \n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                fail_unless!(map.get(&s) == i);\n-            }\n+    do timed(\"insert\") {\n+        for uint::range(0, n_keys) |i| {\n+            map.insert(i, i + 1);\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        do timed(&mut results.random_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint);\n-                map.insert(s, i);\n-            }\n+    do timed(\"search\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.find(&i).unwrap() == &(i + 1));\n         }\n     }\n \n-    {\n-        let map = oldmap::HashMap();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i), i);\n-        }\n-        do timed(&mut results.delete_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&uint::to_str(i)));\n-            }\n+    do timed(\"remove\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.remove(&i));\n         }\n     }\n }\n \n-fn linear_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.sequential_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(i, i+1);\n-            }\n+fn vector<M: Map<uint, uint>>(map: &mut M, n_keys: uint, dist: &[uint]) {\n \n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.find(&i).unwrap() == &(i+1));\n-            }\n+    do timed(\"insert\") {\n+        for uint::range(0, n_keys) |i| {\n+            map.insert(dist[i], i + 1);\n         }\n     }\n \n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.random_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(rng.next() as uint, i);\n-            }\n+    do timed(\"search\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.find(&dist[i]).unwrap() == &(i + 1));\n         }\n     }\n \n-    {\n-        let mut map = LinearMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(i, i);;\n-        }\n-\n-        do timed(&mut results.delete_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&i));\n-            }\n+    do timed(\"remove\") {\n+        for uint::range(0, n_keys) |i| {\n+            fail_unless!(map.remove(&dist[i]));\n         }\n     }\n }\n \n-fn linear_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.sequential_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                map.insert(s, i);\n-            }\n-\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                fail_unless!(map.find(&s).unwrap() == &i);\n-            }\n+fn main() {\n+    let args = os::args();\n+    let n_keys = {\n+        if args.len() == 2 {\n+            uint::from_str(args[1]).get()\n+        } else {\n+            1000000\n         }\n-    }\n+    };\n \n-    {\n-        let mut map = LinearMap::new();\n-        do timed(&mut results.random_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint);\n-                map.insert(s, i);\n-            }\n-        }\n-    }\n+    let mut rand = vec::with_capacity(n_keys);\n \n     {\n-        let mut map = LinearMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i), i);\n-        }\n-        do timed(&mut results.delete_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&uint::to_str(i)));\n+        let rng = core::rand::seeded_rng([1, 1, 1, 1, 1, 1, 1]);\n+        let mut set = LinearSet::new();\n+        while set.len() != n_keys {\n+            let next = rng.next() as uint;\n+            if set.insert(next) {\n+                rand.push(next);\n             }\n         }\n     }\n-}\n \n-fn tree_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n-    {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.sequential_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(i, i+1);\n-            }\n+    io::println(fmt!(\"%? keys\", n_keys));\n \n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.find(&i).unwrap() == &(i+1));\n-            }\n-        }\n-    }\n+    io::println(\"\\nTreeMap:\");\n \n     {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.random_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                map.insert(rng.next() as uint, i);\n-            }\n-        }\n+        let mut map = TreeMap::new::<uint, uint>();\n+        ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = TreeMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(i, i);;\n-        }\n-\n-        do timed(&mut results.delete_ints) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&i));\n-            }\n-        }\n+        let mut map = TreeMap::new::<uint, uint>();\n+        descending(&mut map, n_keys);\n     }\n-}\n \n-fn tree_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n     {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.sequential_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                map.insert(s, i);\n-            }\n-\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(i);\n-                fail_unless!(map.find(&s).unwrap() == &i);\n-            }\n-        }\n+        io::println(\" Random integers:\");\n+        let mut map = TreeMap::new::<uint, uint>();\n+        vector(&mut map, n_keys, rand);\n     }\n \n+    io::println(\"\\nLinearMap:\");\n+\n     {\n-        let mut map = TreeMap::new();\n-        do timed(&mut results.random_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                let s = uint::to_str(rng.next() as uint);\n-                map.insert(s, i);\n-            }\n-        }\n+        let mut map = LinearMap::new::<uint, uint>();\n+        ascending(&mut map, n_keys);\n     }\n \n     {\n-        let mut map = TreeMap::new();\n-        for uint::range(0, num_keys) |i| {\n-            map.insert(uint::to_str(i), i);\n-        }\n-        do timed(&mut results.delete_strings) {\n-            for uint::range(0, num_keys) |i| {\n-                fail_unless!(map.remove(&uint::to_str(i)));\n-            }\n-        }\n+        let mut map = LinearMap::new::<uint, uint>();\n+        descending(&mut map, n_keys);\n     }\n-}\n-\n-fn write_header(header: &str) {\n-    io::stdout().write_str(header);\n-    io::stdout().write_str(\"\\n\");\n-}\n-\n-fn write_row(label: &str, value: float) {\n-    io::stdout().write_str(fmt!(\"%30s %f s\\n\", label, value));\n-}\n-\n-fn write_results(label: &str, results: &Results) {\n-    write_header(label);\n-    write_row(\"sequential_ints\", results.sequential_ints);\n-    write_row(\"random_ints\", results.random_ints);\n-    write_row(\"delete_ints\", results.delete_ints);\n-    write_row(\"sequential_strings\", results.sequential_strings);\n-    write_row(\"random_strings\", results.random_strings);\n-    write_row(\"delete_strings\", results.delete_strings);\n-}\n \n-fn empty_results() -> Results {\n-    Results {\n-        sequential_ints: 0f,\n-        random_ints: 0f,\n-        delete_ints: 0f,\n-\n-        sequential_strings: 0f,\n-        random_strings: 0f,\n-        delete_strings: 0f,\n+    {\n+        io::println(\" Random integers:\");\n+        let mut map = LinearMap::new::<uint, uint>();\n+        vector(&mut map, n_keys, rand);\n     }\n-}\n-\n-fn main() {\n-    let args = os::args();\n-    let num_keys = {\n-        if args.len() == 2 {\n-            uint::from_str(args[1]).get()\n-        } else {\n-            100 // woefully inadequate for any real measurement\n-        }\n-    };\n \n-    let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    io::println(\"\\nTrieMap:\");\n \n     {\n-        let rng = rand::seeded_rng(seed);\n-        let mut results = empty_results();\n-        old_int_benchmarks(rng, num_keys, &mut results);\n-        old_str_benchmarks(rng, num_keys, &mut results);\n-        write_results(\"std::oldmap::HashMap\", &results);\n+        let mut map = TrieMap::new::<uint>();\n+        ascending(&mut map, n_keys);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n-        let mut results = empty_results();\n-        linear_int_benchmarks(rng, num_keys, &mut results);\n-        linear_str_benchmarks(rng, num_keys, &mut results);\n-        write_results(\"core::hashmap::linear::LinearMap\", &results);\n+        let mut map = TrieMap::new::<uint>();\n+        descending(&mut map, n_keys);\n     }\n \n     {\n-        let rng = rand::seeded_rng(seed);\n-        let mut results = empty_results();\n-        tree_int_benchmarks(rng, num_keys, &mut results);\n-        tree_str_benchmarks(rng, num_keys, &mut results);\n-        write_results(\"std::treemap::TreeMap\", &results);\n+        io::println(\" Random integers:\");\n+        let mut map = TrieMap::new::<uint>();\n+        vector(&mut map, n_keys, rand);\n     }\n }"}]}